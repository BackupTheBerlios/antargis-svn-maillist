<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Antargis-svn] r1237 - in antargis/trunk: . build ext/basic rookey	rookey/configs rookey/cpp rookey/spec rookey/spec/cpp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/antargis-svn/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1237%20-%20in%20antargis/trunk%3A%20.%20build%20ext/basic%20rookey%0A%09rookey/configs%20rookey/cpp%20rookey/spec%20rookey/spec/cpp&In-Reply-To=%3C200803281659.m2SGxnhX007491%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000192.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Antargis-svn] r1237 - in antargis/trunk: . build ext/basic rookey	rookey/configs rookey/cpp rookey/spec rookey/spec/cpp</H1>
    <B>davidkamphausen at BerliOS</B> 
    <A HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1237%20-%20in%20antargis/trunk%3A%20.%20build%20ext/basic%20rookey%0A%09rookey/configs%20rookey/cpp%20rookey/spec%20rookey/spec/cpp&In-Reply-To=%3C200803281659.m2SGxnhX007491%40sheep.berlios.de%3E"
       TITLE="[Antargis-svn] r1237 - in antargis/trunk: . build ext/basic rookey	rookey/configs rookey/cpp rookey/spec rookey/spec/cpp">davidkamphausen at mail.berlios.de
       </A><BR>
    <I>Fri Mar 28 17:59:49 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000192.html">[Antargis-svn] r1236 - in antargis/trunk: . ext/3dengine ext/basic ext/game ext/gui ext/math ext/video main rookey rookey/configs rookey/docs rookey/docs/ruby rookey/docs/ruby/classes rookey/docs/ruby/classes/Array.src rookey/docs/ruby/classes/Class.src rookey/docs/ruby/classes/Rookey rookey/docs/ruby/classes/Rookey/CcacheConfig.src rookey/docs/ruby/classes/Rookey/Compiler.src rookey/docs/ruby/classes/Rookey/Config.src rookey/docs/ruby/classes/Rookey/Configurator.src rookey/docs/ruby/classes/Rookey/CppHierarchyParser.src rookey/docs/ruby/classes/Rookey/DebugConfig.src rookey/docs/ruby/classes/Rookey/GLConfig.src rookey/docs/ruby/classes/Rookey/RubyConfig.src rookey/docs/ruby/classes/Rookey/SDLConfig.src rookey/docs/ruby/classes/Rookey/Swig.src rookey/docs/ruby/classes/Rookey/SwigConfig.src rookey/docs/ruby/classes/Rookey/SwigInterfaceBuilder.src rookey/docs/ruby/classes/Rookey/Tools.src rookey/docs/ruby/classes/Rookey.src rookey/docs/ruby/files rookey/docs/ruby/files/configs rooke! y/spec ruby
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#193">[ date ]</a>
              <a href="thread.html#193">[ thread ]</a>
              <a href="subject.html#193">[ subject ]</a>
              <a href="author.html#193">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: davidkamphausen
Date: 2008-03-28 17:59:36 +0100 (Fri, 28 Mar 2008)
New Revision: 1237

Added:
   antargis/trunk/rookey/configs/compiler.rb
   antargis/trunk/rookey/cpp/
   antargis/trunk/rookey/cpp/ag_base.h
   antargis/trunk/rookey/cpp/ag_rubyobj.cc
   antargis/trunk/rookey/cpp/ag_rubyobj.h
   antargis/trunk/rookey/spec/a.h
   antargis/trunk/rookey/spec/b.h
   antargis/trunk/rookey/spec/c.h
   antargis/trunk/rookey/spec/cpp/
   antargis/trunk/rookey/spec/cpp/ag_rubyobj.cc
   antargis/trunk/rookey/spec/helper_spec.rb
   antargis/trunk/rookey/spec/main.h
   antargis/trunk/rookey/spec/test
   antargis/trunk/rookey/spec/test.c
   antargis/trunk/rookey/spec_output.html
Removed:
   antargis/trunk/build/build.rb
   antargis/trunk/ext/basic/ag_base.h
   antargis/trunk/ext/basic/ag_rubyobj.cc
   antargis/trunk/ext/basic/ag_rubyobj.h
   antargis/trunk/rookey/docs/
   antargis/trunk/rookey/spec/interface.i
   antargis/trunk/rookey/swig.cc
Modified:
   antargis/trunk/Rakefile
   antargis/trunk/build/cross_compile.rb
   antargis/trunk/ext/basic/ag_main.cc
   antargis/trunk/rookey/
   antargis/trunk/rookey/Rakefile
   antargis/trunk/rookey/compile.rb
   antargis/trunk/rookey/config_generator.rb
   antargis/trunk/rookey/cpp_hierarchy_parser.rb
   antargis/trunk/rookey/spec/Rakefile
   antargis/trunk/rookey/spec/main.cc
   antargis/trunk/rookey/spec/spec_rookey.rb
   antargis/trunk/rookey/tasks.rb
   antargis/trunk/rookey/tools.rb
Log:
* some more additions to rookey

Modified: antargis/trunk/Rakefile
===================================================================
--- antargis/trunk/Rakefile	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/Rakefile	2008-03-28 16:59:36 UTC (rev 1237)
@@ -33,5 +33,5 @@
         t.spec_files = FileList['**/spec_*.rb']
         t.warning = true
         t.rcov = true
-        t.spec_opts=[&quot;--format html:spec_output.html&quot;]
+        t.spec_opts=[&quot;--format html:&quot;+File.expand_path(&quot;spec_output.html&quot;)]
 end
\ No newline at end of file

Deleted: antargis/trunk/build/build.rb
===================================================================
--- antargis/trunk/build/build.rb	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/build/build.rb	2008-03-28 16:59:36 UTC (rev 1237)
@@ -1,104 +0,0 @@
-def makeDepName(output)
-	dep=&quot;.deps/&quot;+output.gsub(&quot;/&quot;,&quot;_&quot;)
-end
-
-
-# build a command out of templates in config.rb
-def makeCommand(cmd,output,input)
-	#cmd.sub(&quot;&#167;OUTPUT&#167;&quot;,output).sub(&quot;&#167;INPUT&#167;&quot;,input)
-	begin
-		Dir.mkdir(&quot;.deps&quot;)
-	rescue
-	end
-	dep=makeDepName(output)
-	extendCommand($config,cmd,{&quot;OUTPUT&quot;=&gt;output,&quot;INPUT&quot;=&gt;input,&quot;DEP&quot;=&gt;dep})
-end
-
-module Cmd
-	@@quiet=false 
-	def Cmd.sys(cmd)
-		puts cmd if not @@quiet
-		res=system(cmd)
-		raise 1 unless res
-	end
-
-	def Cmd.setQuiet(flag)
-		@@quiet=flag
-	end
-end
-
-
-module Build
-	include Cmd
-	@@silent=false
-	@@logFile=nil
-	@@log=nil
-
-	def self.log=(log)
-		@@log=log
-	end
-
-	def self.silent=(flag)
-		@@silent=flag
-	end
-
-	def Build.includes
-		includes=Dir.glob(File.join(&quot;ext&quot;,&quot;**&quot;,&quot;*.h&quot;)).collect{|f|f.sub(/\/[^\/]*$/,&quot;&quot;)}.uniq+[getConfig(&quot;archdir&quot;)]
-		includes.collect{|i|&quot;-I#{i}&quot;}.join(&quot; &quot;)
-	end
-
-	def Build.cflags
-		includes+&quot; &quot;+getConfig(&quot;CFLAGS&quot;)+&quot; &quot;+$config[&quot;CFLAGS&quot;].to_s
-	end
-
-	def Build.compile(cFile)
-		cObj=cFileToObj(cFile)
-		cmd=makeCommand(&quot;CXX_CALL&quot;,cObj,cflags+&quot; &quot;+cFile)
-		call(cmd)
-	end
-
-	def Build.link(target,objs,libs)
-		cmd=makeCommand(&quot;LINK_EXE&quot;,target,(objs+libs).join(&quot; &quot;))
-		call(cmd)
-	end
-	
-	def Build.linkToLib(target,objs,libs)
-		cmd=makeCommand(&quot;LINK_SHARED&quot;,target,(objs+libs).join(&quot; &quot;))
-		call(cmd)
-	end
-
-	def Build.cFileToObj(filename)
-		filename.sub(/\.cc$/,&quot;.oo&quot;).sub(/\.c$/,&quot;.o&quot;)
-	end
-private	
-	def self.call(cmd)
-		if @@silent
-			if @@log
-				initLog
-				pushLog cmd
-				cmd+=&quot; 2&gt;&amp;1 &gt;&gt;#{@@log}&quot;
-				output=`#{cmd}`
-				pushLog(output)
-				$?
-			else
-				cmd+=&quot; 2&gt;/dev/null&quot;
-				system(cmd)
-			end
-		else
-			Cmd.sys(cmd)
-		end
-	end
-	def self.initLog
-		@@logFile=File.open(@@log,&quot;w&quot;) if @@log and @@logFile.nil?
-		@@logFile.puts &quot;INIT&quot;
-		#@@logFile.close
-	end
-	def self.pushLog(text)
-		return if @@logFile.nil?
-		#@@logFile=File.open(@@log,&quot;a&quot;)
-		raise 1 if @@logFile.nil?
-		@@logFile.puts text
-		#@@logFile.close
-	end
-end
-

Modified: antargis/trunk/build/cross_compile.rb
===================================================================
--- antargis/trunk/build/cross_compile.rb	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/build/cross_compile.rb	2008-03-28 16:59:36 UTC (rev 1237)
@@ -38,7 +38,7 @@
 rubyZip=&quot;ag_ruby_bin.tar.gz&quot;
 
 downloadTo(&quot;<A HREF="http://svn.berlios.de/wsvn/antargis/contrib/binary/ag_sdl_libs.tar.gz?op=file&amp;rev=0&amp;sc=0">http://svn.berlios.de/wsvn/antargis/contrib/binary/ag_sdl_libs.tar.gz?op=file&amp;rev=0&amp;sc=0</A>&quot;,File.join(libdir,sdlLibZip))
-downloadTo(&quot;<A HREF="http://svn.berlios.de/wsvn/antargis/contrib/binary/ag_ruby_libs.tar.gz?op=file&amp;rev=0&amp;sc=0">http://svn.berlios.de/wsvn/antargis/contrib/binary/ag_ruby_libs.tar.gz?op=file&amp;rev=0&amp;sc=0</A>&quot;,File.join(libdir,rubyZip))
+downloadTo(&quot;<A HREF="http://svn.berlios.de/wsvn/antargis/contrib/binary/ag_ruby_bin.tar.gz?op=file&amp;rev=0&amp;sc=0">http://svn.berlios.de/wsvn/antargis/contrib/binary/ag_ruby_bin.tar.gz?op=file&amp;rev=0&amp;sc=0</A>&quot;,File.join(libdir,rubyZip))
 #downloadTo(&quot;<A HREF="ftp://ftp.ruby-lang.org/pub/ruby/binaries/mswin32/ruby-1.8.6-i386-mswin32.zip">ftp://ftp.ruby-lang.org/pub/ruby/binaries/mswin32/ruby-1.8.6-i386-mswin32.zip</A>&quot;,File.join(libdir,rubyZip))
 
 unzip(sdlLibZip,libdir)
@@ -68,4 +68,4 @@
 pp path
 
 call=path+&quot; antargis.iss&quot;
-system(call)
\ No newline at end of file
+system(call)

Deleted: antargis/trunk/ext/basic/ag_base.h
===================================================================
--- antargis/trunk/ext/basic/ag_base.h	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/ext/basic/ag_base.h	2008-03-28 16:59:36 UTC (rev 1237)
@@ -1,24 +0,0 @@
-#ifndef AG_BASE_H
-#define AG_BASE_H
-
-#ifdef WIN32
-#ifdef AGIMPORT
-#define AGEXPORT __declspec(dllimport)
-#else
-#undef AGEXPORT
-#define AGEXPORT __declspec(dllexport)
-#endif // AGIMPORT
-#else
-
-#undef AGEXPORT
-#define AGEXPORT
-
-#endif // WIN32
-
-#ifdef SWIG
-#undef AGEXPORT
-#define AGEXPORT
-#endif
-
-
-#endif

Modified: antargis/trunk/ext/basic/ag_main.cc
===================================================================
--- antargis/trunk/ext/basic/ag_main.cc	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/ext/basic/ag_main.cc	2008-03-28 16:59:36 UTC (rev 1237)
@@ -50,6 +50,7 @@
 bool gDRMok=false;
 #endif
 
+//FIXME: discard this function!
 bool hasQuit()
   {
     return quited;
@@ -98,6 +99,7 @@
     cdebug(&quot;QUIT&quot;);
     SDL_Quit();
     quited=true;
+    setQuitting();
 
     //  saveDelete(mRand);
 

Deleted: antargis/trunk/ext/basic/ag_rubyobj.cc
===================================================================
--- antargis/trunk/ext/basic/ag_rubyobj.cc	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/ext/basic/ag_rubyobj.cc	2008-03-28 16:59:36 UTC (rev 1237)
@@ -1,149 +0,0 @@
-#include &quot;ag_rubyobj.h&quot;
-#include &quot;ag_debug.h&quot;
-#include &quot;ag_profiler.h&quot;
-#include &lt;assert.h&gt;
-#include &lt;typeinfo&gt;
-#include &lt;set&gt;
-#include &lt;map&gt;
-#include &lt;iostream&gt;
-
-
-#ifdef __WIN32__
-#include &lt;winsock2.h&gt; // fix problem with fd_set
-#endif
-#include &lt;ruby.h&gt;
-
-#include &lt;ag_main.h&gt;
-
-VALUE convertCpp2Ruby(AGRubyObject *cObject);
-
-AGEXPORT void *getAddressOfRubyObject(AGRubyObject *o)
-  {
-    return o;
-  }
-
-AGEXPORT bool rubyObjectExists(void *po)
-  {
-    VALUE v=convertCpp2Ruby((AGRubyObject*)po);
-    return(v!=Qnil);
-  }
-
-AGRubyObject::AGRubyObject()
-  {
-  }
-AGRubyObject::~AGRubyObject()
-  {
-    for(std::set&lt;AGBaseObject*&gt;::iterator i=mReferences.begin();i!=mReferences.end();i++)
-      (*i)-&gt;baseClear();
-  }
-
-
-/// override this function to mark your children
-void AGRubyObject::mark()
-  {
-  }
-
-
-// call this function with any object you want to mark.
-void AGRubyObject::markObject(AGRubyObject *o, bool recursive)
-  {
-    VALUE v=convertCpp2Ruby(o);
-    if(v!=Qnil)
-      rb_gc_mark(v);
-    
-    assert(o);
-    if(recursive)
-      o-&gt;mark(); // call this directly
-  }
-
-void AGRubyObject::clear()
-  {
-    CTRACE;
-  }
-
-void AGRubyObject::addRef(AGBaseObject *o)
-  {
-    mReferences.insert(o);
-  }
-
-void AGRubyObject::deleteRef(AGBaseObject *o)
-  {
-    mReferences.erase(o);
-  }
-
-
-
-/// this is the marking function, that gets called by ruby
-/// it handles all the AGRubyObjects
-void general_markfunc(void *ptr)
-  {
-    STACKTRACE;
-    //  TRACE;
-    if(!ptr)
-      {
-        cdebug(&quot;WARNING: a ptr==0 was given in general_markfunc!&quot;);
-        //      throw std::runtime_error(&quot;WARNING: a ptr==0 was given in general_markfunc!&quot;);
-        return; // ignore
-      }
-    assert(ptr);
-    AGRubyObject *o=static_cast&lt;AGRubyObject*&gt;(ptr);
-
-#ifdef GCDEBUG
-    printf(&quot;mark: 0x%lx\n&quot;,o-&gt;mRUBY);
-#endif
-
-    assert(o);
-    o-&gt;mark();
-  }
-
-
-/**
-   saveDelete is used to delete AGRubyObjects savely.
-
-   ruby does a gc-run and then deletes everything, which is not marked
-   so eventually sub-instances of a rubyobject are killed before
-   a workaround for this:
-   1) put all deleted objects in a set
-   2) check set before clearing/deleting
-   3) clear this set when marking
- */
-bool saveDelete(AGRubyObject *o)
-  {
-    if(hasQuit())
-      return false; // we are quitting - so memory is discarded anyway - hopefully ;-)
-
-    VALUE v=convertCpp2Ruby(o);
-    if(v!=Qnil)
-      return false; // do not delete - it's under ruby's control!
-
-    
-    assert(o);
-    o-&gt;clear();
-    delete o;
-    return true;
-  }
-
-
-
-
-
-
-
-
-AGBaseObject::AGBaseObject(AGRubyObject *p)
-:mp(p)
-{
-  if(p)
-    p-&gt;addRef(this);
-}
-
-AGBaseObject::~AGBaseObject()
-  {
-    if(mp)
-      mp-&gt;deleteRef(this);
-  }
-
-void AGBaseObject::baseClear()
-  {
-    mp=0;
-  }

Deleted: antargis/trunk/ext/basic/ag_rubyobj.h
===================================================================
--- antargis/trunk/ext/basic/ag_rubyobj.h	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/ext/basic/ag_rubyobj.h	2008-03-28 16:59:36 UTC (rev 1237)
@@ -1,120 +0,0 @@
-#ifndef RUBY_OBJ_H
-#define RUBY_OBJ_H
-
-// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
-
-#ifdef WIN32
-#undef connect
-#undef close
-#endif
-
-/**
-   AGRubyObject does handling between ruby and c++ memory management.
-   Ruby has a garbage collector (GC) which is not really to be influenced.
-   Every object that is created in ruby is handled by the GC.
-   So we have to take care of that.
-
-   Ruby's GC has no reference counting whatsoever but it uses a mark-and-sweep
-   algorithm. When the GC is run the algorithm marks any known object and then calls
-   all the objects' mark-functions which therefore call mark-functions all the objects it
-   knowns. When anything known is marked, the algorithm kills any object that isn't marked.
-
-   So all we have to do is to mark any object that is connected to the current object in any way.
-   Normally you would mark any object that is a children of the current one.
-
-   To make things easier AGRubyObject takes care of objects which are not handled by ruby. They get called
-   recursively anyways. So all you have to do is overriding the mark() function and then calling 
-   markObject(AGRubyObject *o) for any object you want to mark.
-
-   If you need an explicit destructor-call at a specified time you must be content with a call to clear(), which
-   you can override. For deletion of any AGRubyObject you should use saveDelete. This calls clear() and deletes the
-   object, if it's not a ruby-managed one.
-
-   @see saveDelete(AGRubyObject *o)
- */
-
-// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
-
-#include &lt;string&gt;
-#include &lt;set&gt;
-#include &lt;ag_base.h&gt;
-#include &lt;stdexcept&gt;
-
-class AGRubyObject;
-
-class AGEXPORT AGBaseObject
-{
-protected:
-  AGRubyObject *mp;
-public:
-  AGBaseObject(AGRubyObject *p);
-
-  ~AGBaseObject();
-  void baseClear();
-
-  bool valid()
-    {
-      return mp;
-    }
-};
-
-template&lt;class T&gt;
-class AGEXPORT gc_ptr:public AGBaseObject
-{
-public:
-  gc_ptr(T*t):AGBaseObject(t)
-  {
-  }
-
-  T*operator-&gt;()
-    {
-      return (T*)mp;
-    }
-  T* getPtr()
-  {
-    if(!mp)
-      throw std::runtime_error(&quot;mp not defined!&quot;);
-    return (T*)mp;
-  }
-};
-
-class AGEXPORT AGRubyObject
-{
-public:
-  /**
-     This is copied from ruby.h, so that this header-file is not included all over the place.
-     FIXME: this must eventually be changed - when the ruby implementation changes
-   */
-  typedef unsigned long VALUE;
-
-  AGRubyObject();
-  virtual ~AGRubyObject();
-
-protected:
-#ifndef SWIG
-  // functions shouldn't be exported and NEVER be used in ruby!
-  virtual void clear();
-  virtual void mark();
-  void markObject(AGRubyObject *o,bool recursive=true);
-
-#endif
-public:
-#ifndef SWIG
-
-#endif
-  friend void general_markfunc(void *ptr);
-  friend bool saveDelete(AGRubyObject *o);
-
-  void addRef(AGBaseObject *o);
-  void deleteRef(AGBaseObject *o);
-private:
-  std::set&lt;AGBaseObject*&gt; mReferences;
-};
-
-AGEXPORT void general_markfunc(void *ptr);
-AGEXPORT bool saveDelete(AGRubyObject *o);
-
-AGEXPORT void *getAddressOfRubyObject(AGRubyObject *object);
-AGEXPORT bool rubyObjectExists(void *o);
-
-#endif


Property changes on: antargis/trunk/rookey
___________________________________________________________________
Name: svn:ignore
   + docs


Modified: antargis/trunk/rookey/Rakefile
===================================================================
--- antargis/trunk/rookey/Rakefile	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/Rakefile	2008-03-28 16:59:36 UTC (rev 1237)
@@ -12,3 +12,13 @@
 	 rd.rdoc_files.include(a)
 end
  
+
+# rspec
+Spec::Rake::SpecTask.new(:spec) do |t|
+	t.spec_files = FileList['**/spec_*.rb']
+	t.warning = true
+	#t.rcov = true
+	t.spec_opts=[&quot;--format html:&quot;+File.expand_path(&quot;spec_output.html&quot;)]
+end
+
+task :default=&gt;:spec
\ No newline at end of file

Modified: antargis/trunk/rookey/compile.rb
===================================================================
--- antargis/trunk/rookey/compile.rb	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/compile.rb	2008-03-28 16:59:36 UTC (rev 1237)
@@ -31,7 +31,13 @@
 	    includes=includeDirs.map{|d|&quot;-I&quot;+d}
 	    options+=includes
 	    
-	    options &lt;&lt; &quot;-c &quot;+File.expand_path(source)
+      expanded_path=File.expand_path(source)
+      sourcepath=source
+      sourcepath=expanded_path if File.exists?(expanded_path) and not File.exists?(source)
+      sourcepath=&quot;/&quot;+sourcepath if File.exists?(&quot;/&quot;+sourcepath) and not File.exists?(sourcepath)
+      #pp sourcepath,source
+      #exit
+	    options &lt;&lt; &quot;-c &quot;+sourcepath
 	    options &lt;&lt; &quot;-o &quot;+target
       
       

Modified: antargis/trunk/rookey/config_generator.rb
===================================================================
--- antargis/trunk/rookey/config_generator.rb	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/config_generator.rb	2008-03-28 16:59:36 UTC (rev 1237)
@@ -31,7 +31,7 @@
     end
   end
   
-  CONFIG_FILENAME=&quot;antconfig.rb&quot;
+  CONFIG_FILENAME=&quot;config_cache.rb&quot;
   
   @@config=nil
   
@@ -117,7 +117,6 @@
   end
   
  
-  # 
   def Rookey.getDescendantsOfClass(p)
     c=[]
     ObjectSpace.each_object(Class){|a|c.push(a) if a.ancestors.member?(p)}

Added: antargis/trunk/rookey/configs/compiler.rb
===================================================================
--- antargis/trunk/rookey/configs/compiler.rb	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/configs/compiler.rb	2008-03-28 16:59:36 UTC (rev 1237)
@@ -0,0 +1,9 @@
+module Rookey
+  class CompilerConfig&lt;Configurator
+    needs :compiler
+    
+    def run(config)
+      config.add(&quot;INCLUDEDIRS&quot;,File.join(File.split(File.split(__FILE__)[0])[0],&quot;cpp&quot;))
+    end
+  end
+end
\ No newline at end of file

Copied: antargis/trunk/rookey/cpp/ag_base.h (from rev 1235, antargis/trunk/ext/basic/ag_base.h)
===================================================================
--- antargis/trunk/ext/basic/ag_base.h	2008-03-17 15:29:28 UTC (rev 1235)
+++ antargis/trunk/rookey/cpp/ag_base.h	2008-03-28 16:59:36 UTC (rev 1237)
@@ -0,0 +1,39 @@
+/**
+ * This file provides a define &quot;AGEXPORT&quot; to be used for exporting functions and classes
+ * out of DLLs on Windows.
+ * For this to function you'll just insert it:
+ * 1) before a function declaration:
+ *    AGEXPORT void myFunction();
+ * 2) or inbetween a class-definition:
+ *    class AGEXPORT MyClass {
+ *    .....
+ *    };
+ * No additional configuration should be needed.
+ * including within swig is taken care of. 
+ *  
+ * */
+
+#ifndef AG_BASE_H
+#define AG_BASE_H
+
+#ifdef WIN32
+#ifdef AGIMPORT
+#define AGEXPORT __declspec(dllimport)
+#else
+#undef AGEXPORT
+#define AGEXPORT __declspec(dllexport)
+#endif // AGIMPORT
+#else
+
+#undef AGEXPORT
+#define AGEXPORT
+
+#endif // WIN32
+
+#ifdef SWIG
+#undef AGEXPORT
+#define AGEXPORT
+#endif
+
+
+#endif

Copied: antargis/trunk/rookey/cpp/ag_rubyobj.cc (from rev 1236, antargis/trunk/ext/basic/ag_rubyobj.cc)
===================================================================
--- antargis/trunk/ext/basic/ag_rubyobj.cc	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/cpp/ag_rubyobj.cc	2008-03-28 16:59:36 UTC (rev 1237)
@@ -0,0 +1,162 @@
+#include &quot;ag_rubyobj.h&quot;
+//#include &quot;ag_debug.h&quot;
+//#include &quot;ag_profiler.h&quot;
+#include &lt;assert.h&gt;
+#include &lt;typeinfo&gt;
+#include &lt;set&gt;
+#include &lt;map&gt;
+#include &lt;iostream&gt;
+
+
+#ifdef __WIN32__
+#include &lt;winsock2.h&gt; // fix problem with fd_set
+#endif
+#include &lt;ruby.h&gt;
+
+//#include &lt;ag_main.h&gt;
+
+bool mRubyQuitting=false;
+
+void setQuitting()
+  {
+    mRubyQuitting=true;
+  }
+
+VALUE convertCpp2Ruby(AGRubyObject *cObject);
+
+AGEXPORT void *getAddressOfRubyObject(AGRubyObject *o)
+  {
+    return o;
+  }
+
+AGEXPORT bool rubyObjectExists(void *po)
+  {
+    VALUE v=convertCpp2Ruby((AGRubyObject*)po);
+    return(v!=Qnil);
+  }
+
+AGRubyObject::AGRubyObject()
+  {
+  }
+AGRubyObject::~AGRubyObject()
+  {
+    for(std::set&lt;AGBaseObject*&gt;::iterator i=mReferences.begin();i!=mReferences.end();i++)
+      (*i)-&gt;baseClear();
+  }
+
+
+/// override this function to mark your children
+void AGRubyObject::mark()
+  {
+  }
+
+
+// call this function with any object you want to mark.
+void AGRubyObject::markObject(AGRubyObject *o, bool recursive)
+  {
+    VALUE v=convertCpp2Ruby(o);
+    if(v!=Qnil)
+      rb_gc_mark(v);
+    
+    assert(o);
+    if(recursive)
+      o-&gt;mark(); // call this directly
+  }
+
+void AGRubyObject::clear()
+  {
+    //CTRACE;
+  }
+
+void AGRubyObject::addRef(AGBaseObject *o)
+  {
+    mReferences.insert(o);
+  }
+
+void AGRubyObject::deleteRef(AGBaseObject *o)
+  {
+    mReferences.erase(o);
+  }
+
+
+
+/// this is the marking function, that gets called by ruby
+/// it handles all the AGRubyObjects
+void general_markfunc(void *ptr)
+  {
+    //STACKTRACE;
+    //  TRACE;
+    if(!ptr)
+      {
+        // FIXME: add logging!!!
+        std::cerr&lt;&lt;(&quot;WARNING: a ptr==0 was given in general_markfunc!&quot;)&lt;&lt;std::endl;
+        //      throw std::runtime_error(&quot;WARNING: a ptr==0 was given in general_markfunc!&quot;);
+        return; // ignore
+      }
+    assert(ptr);
+    AGRubyObject *o=static_cast&lt;AGRubyObject*&gt;(ptr);
+
+#ifdef GCDEBUG
+    printf(&quot;mark: 0x%lx\n&quot;,o-&gt;mRUBY);
+#endif
+
+    assert(o);
+    o-&gt;mark();
+  }
+
+
+/**
+   saveDelete is used to delete AGRubyObjects savely.
+
+   ruby does a gc-run and then deletes everything, which is not marked
+   so eventually sub-instances of a rubyobject are killed before
+   a workaround for this:
+   1) put all deleted objects in a set
+   2) check set before clearing/deleting
+   3) clear this set when marking
+ */
+bool saveDelete(AGRubyObject *o)
+  {
+    
+    
+    //FIXME: can this really be discarded ?
+    if(mRubyQuitting)
+      return false; // we are quitting - so memory is discarded anyway - hopefully ;-)
+
+    
+    
+    VALUE v=convertCpp2Ruby(o);
+    if(v!=Qnil)
+      return false; // do not delete - it's under ruby's control!
+
+    
+    assert(o);
+    o-&gt;clear();
+    delete o;
+    return true;
+  }
+
+
+
+
+
+
+
+
+AGBaseObject::AGBaseObject(AGRubyObject *p)
+:mp(p)
+{
+  if(p)
+    p-&gt;addRef(this);
+}
+
+AGBaseObject::~AGBaseObject()
+  {
+    if(mp)
+      mp-&gt;deleteRef(this);
+  }
+
+void AGBaseObject::baseClear()
+  {
+    mp=0;
+  }

Copied: antargis/trunk/rookey/cpp/ag_rubyobj.h (from rev 1236, antargis/trunk/ext/basic/ag_rubyobj.h)
===================================================================
--- antargis/trunk/ext/basic/ag_rubyobj.h	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/cpp/ag_rubyobj.h	2008-03-28 16:59:36 UTC (rev 1237)
@@ -0,0 +1,132 @@
+#ifndef RUBY_OBJ_H
+#define RUBY_OBJ_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifdef WIN32
+#undef connect
+#undef close
+#endif
+
+/**
+   AGRubyObject does handling between ruby and c++ memory management.
+   Ruby has a garbage collector (GC) which is not really to be influenced.
+   Every object that is created in ruby is handled by the GC.
+   So we have to take care of that.
+
+   Ruby's GC has no reference counting whatsoever but it uses a mark-and-sweep
+   algorithm. When the GC is run the algorithm marks any known object and then calls
+   all the objects' mark-functions which therefore call mark-functions all the objects it
+   knowns. When anything known is marked, the algorithm kills any object that isn't marked.
+
+   So all we have to do is to mark any object that is connected to the current object in any way.
+   Normally you would mark any object that is a children of the current one.
+
+   To make things easier AGRubyObject takes care of objects which are not handled by ruby. They get called
+   recursively anyways. So all you have to do is overriding the mark() function and then calling 
+   markObject(AGRubyObject *o) for any object you want to mark.
+
+   If you need an explicit destructor-call at a specified time you must be content with a call to clear(), which
+   you can override. For deletion of any AGRubyObject you should use saveDelete. This calls clear() and deletes the
+   object, if it's not a ruby-managed one.
+
+   @see saveDelete(AGRubyObject *o)
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &lt;string&gt;
+#include &lt;set&gt;
+#include &lt;ag_base.h&gt;
+#include &lt;stdexcept&gt;
+
+class AGRubyObject;
+
+class AGEXPORT AGBaseObject
+{
+protected:
+  AGRubyObject *mp;
+public:
+  AGBaseObject(AGRubyObject *p);
+
+  ~AGBaseObject();
+  void baseClear();
+
+  bool valid()
+    {
+      return mp;
+    }
+};
+
+
+/**
+ * gc_ptr&lt;T&gt; is a managed ptr to a (possibly) garbage-collected object
+ * it will be redirected to 0, if the targeted object is destroyed. So
+ * you'll get a null-pointer exception when the object is not longer
+ * present. This prevents you from accessing random memory. 
+ */
+template&lt;class T&gt;
+class AGEXPORT gc_ptr:public AGBaseObject
+{
+public:
+  gc_ptr(T*t):AGBaseObject(t)
+  {
+  }
+
+  T*operator-&gt;()
+    {
+      return (T*)mp;
+    }
+  T* getPtr()
+  {
+    if(!mp)
+      throw std::runtime_error(&quot;mp not defined!&quot;);
+    return (T*)mp;
+  }
+};
+
+/**
+ * 
+ * */
+class AGEXPORT AGRubyObject
+{
+public:
+  /**
+     This is copied from ruby.h, so that this header-file is not included all over the place.
+     FIXME: this must eventually be changed - when the ruby implementation changes
+   */
+  typedef unsigned long VALUE;
+
+  AGRubyObject();
+  virtual ~AGRubyObject();
+
+protected:
+#ifndef SWIG
+  // functions shouldn't be exported and NEVER be used in ruby!
+  virtual void clear();
+  virtual void mark();
+  void markObject(AGRubyObject *o,bool recursive=true);
+
+#endif
+public:
+#ifndef SWIG
+
+#endif
+  friend void general_markfunc(void *ptr);
+  friend bool saveDelete(AGRubyObject *o);
+
+  void addRef(AGBaseObject *o);
+  void deleteRef(AGBaseObject *o);
+private:
+  std::set&lt;AGBaseObject*&gt; mReferences;
+};
+
+AGEXPORT void general_markfunc(void *ptr);
+AGEXPORT bool saveDelete(AGRubyObject *o);
+
+AGEXPORT void *getAddressOfRubyObject(AGRubyObject *object);
+AGEXPORT bool rubyObjectExists(void *o);
+
+AGEXPORT void setQuitting();
+
+#endif

Modified: antargis/trunk/rookey/cpp_hierarchy_parser.rb
===================================================================
--- antargis/trunk/rookey/cpp_hierarchy_parser.rb	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/cpp_hierarchy_parser.rb	2008-03-28 16:59:36 UTC (rev 1237)
@@ -15,6 +15,8 @@
     map={}
     order={}
     
+    pp classes
+    
     allClasses=classes.dup
     classes=getRubyClasses(classes)
     
@@ -109,7 +111,7 @@
       }
     end
     
-	  def parseFiles(files)
+	  def parseFiles(files)	    
 		  class2File={}
 		  deriveList={} # x=&gt;y :x is child of y
 		  allClasses=[]

Modified: antargis/trunk/rookey/spec/Rakefile
===================================================================
--- antargis/trunk/rookey/spec/Rakefile	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/spec/Rakefile	2008-03-28 16:59:36 UTC (rev 1237)
@@ -1,12 +1,7 @@
 require '../tasks.rb'
-
-swigTarget = Rookey::swig &quot;swig.cc&quot;=&gt;&quot;interface.i&quot;
-
-targets = Rookey::compile [&quot;main.cc&quot;,swigTarget]
-
-
-antargisDll = Rookey::link_dll &quot;antargis&quot;,targets
-antargisExe = Rookey::link_exe &quot;antargis&quot;,targets
-
-task :default=&gt;[antargisExe,antargisDll] do
-end
\ No newline at end of file
+require 'rake/clean.rb'
+var1=Rookey.swig_interface('file3'=&gt;['a.h'])
+var2=Rookey.swig('file3_swig.cc'=&gt;[var1])
+var4=Rookey.compile(['main.cc',var2])
+var5=Rookey.link_dll(File.split(var4.flatten.select{|f|f=~/swig/}[0])[1].sub(/_swig.*/,''),var4)
+task :default=&gt;var5

Added: antargis/trunk/rookey/spec/a.h
===================================================================
--- antargis/trunk/rookey/spec/a.h	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/spec/a.h	2008-03-28 16:59:36 UTC (rev 1237)
@@ -0,0 +1,12 @@
+#include &quot;ag_rubyobj.h&quot;
+
+//INCLUDE_SWIG
+
+class B:public AGRubyObject
+  {
+public:
+  virtual void x()
+    {
+    }
+
+  };


Property changes on: antargis/trunk/rookey/spec/a.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/rookey/spec/b.h
===================================================================
--- antargis/trunk/rookey/spec/b.h	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/spec/b.h	2008-03-28 16:59:36 UTC (rev 1237)
@@ -0,0 +1,8 @@
+class A
+  {
+public:
+  void x()
+    {
+    }
+
+  };


Property changes on: antargis/trunk/rookey/spec/b.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/rookey/spec/c.h
===================================================================
--- antargis/trunk/rookey/spec/c.h	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/spec/c.h	2008-03-28 16:59:36 UTC (rev 1237)
@@ -0,0 +1,10 @@
+// INCLUDE_SWIG
+
+class C
+  {
+public:
+  void x()
+    {
+    }
+
+  };


Property changes on: antargis/trunk/rookey/spec/c.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/rookey/spec/cpp/ag_rubyobj.cc
===================================================================
--- antargis/trunk/rookey/spec/cpp/ag_rubyobj.cc	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/spec/cpp/ag_rubyobj.cc	2008-03-28 16:59:36 UTC (rev 1237)
@@ -0,0 +1,101 @@
+ag_rubyobj.o: ../cpp/ag_rubyobj.cc ../cpp/ag_rubyobj.h \
+  /usr/include/c++/4.0.0/string \
+  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/c++config.h \
+  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/os_defines.h \
+  /usr/include/c++/4.0.0/bits/stringfwd.h \
+  /usr/include/c++/4.0.0/bits/char_traits.h \
+  /usr/include/c++/4.0.0/cstring /usr/include/c++/4.0.0/cstddef \
+  /usr/lib/gcc/powerpc-apple-darwin9/4.0.1/include/stddef.h \
+  /usr/include/string.h /usr/include/_types.h /usr/include/sys/_types.h \
+  /usr/include/sys/cdefs.h /usr/include/machine/_types.h \
+  /usr/include/ppc/_types.h /usr/include/c++/4.0.0/bits/stl_algobase.h \
+  /usr/include/c++/4.0.0/climits \
+  /usr/lib/gcc/powerpc-apple-darwin9/4.0.1/include/limits.h \
+  /usr/lib/gcc/powerpc-apple-darwin9/4.0.1/include/syslimits.h \
+  /usr/include/limits.h /usr/include/machine/limits.h \
+  /usr/include/ppc/limits.h /usr/include/ppc/_limits.h \
+  /usr/include/sys/syslimits.h /usr/include/c++/4.0.0/cstdlib \
+  /usr/include/stdlib.h /usr/include/available.h /usr/include/sys/wait.h \
+  /usr/include/sys/signal.h /usr/include/sys/appleapiopts.h \
+  /usr/include/machine/signal.h /usr/include/ppc/signal.h \
+  /usr/include/ppc/_structs.h /usr/include/sys/_structs.h \
+  /usr/include/machine/_structs.h /usr/include/mach/ppc/_structs.h \
+  /usr/include/sys/resource.h /usr/include/machine/endian.h \
+  /usr/include/ppc/endian.h /usr/include/sys/_endian.h \
+  /usr/include/alloca.h /usr/include/machine/types.h \
+  /usr/include/ppc/types.h /usr/include/c++/4.0.0/iosfwd \
+  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/c++locale.h \
+  /usr/include/c++/4.0.0/clocale /usr/include/locale.h \
+  /usr/include/_locale.h /usr/include/c++/4.0.0/cstdio \
+  /usr/include/stdio.h \
+  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/c++io.h \
+  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/gthr.h \
+  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/gthr-default.h \
+  /usr/include/pthread.h /usr/include/pthread_impl.h /usr/include/sched.h \
+  /usr/include/time.h /usr/include/_structs.h /usr/include/unistd.h \
+  /usr/include/sys/unistd.h /usr/include/sys/select.h \
+  /usr/include/sys/_select.h /usr/include/c++/4.0.0/cctype \
+  /usr/include/ctype.h /usr/include/runetype.h \
+  /usr/include/c++/4.0.0/bits/postypes.h /usr/include/c++/4.0.0/cwchar \
+  /usr/include/c++/4.0.0/ctime /usr/include/wchar.h \
+  /usr/lib/gcc/powerpc-apple-darwin9/4.0.1/include/stdarg.h \
+  /usr/include/_wctype.h \
+  /usr/lib/gcc/powerpc-apple-darwin9/4.0.1/include/stdint.h \
+  /usr/include/c++/4.0.0/bits/functexcept.h \
+  /usr/include/c++/4.0.0/exception_defines.h \
+  /usr/include/c++/4.0.0/bits/stl_pair.h \
+  /usr/include/c++/4.0.0/bits/cpp_type_traits.h \
+  /usr/include/c++/4.0.0/bits/stl_iterator_base_types.h \
+  /usr/include/c++/4.0.0/bits/stl_iterator_base_funcs.h \
+  /usr/include/c++/4.0.0/bits/concept_check.h \
+  /usr/include/c++/4.0.0/bits/stl_iterator.h \
+  /usr/include/c++/4.0.0/debug/debug.h /usr/include/c++/4.0.0/cassert \
+  /usr/include/assert.h /usr/include/c++/4.0.0/memory \
+  /usr/include/c++/4.0.0/bits/allocator.h \
+  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/c++allocator.h \
+  /usr/include/c++/4.0.0/ext/new_allocator.h /usr/include/c++/4.0.0/new \
+  /usr/include/c++/4.0.0/exception \
+  /usr/include/c++/4.0.0/bits/stl_construct.h \
+  /usr/include/c++/4.0.0/bits/stl_uninitialized.h \
+  /usr/include/c++/4.0.0/bits/stl_raw_storage_iter.h \
+  /usr/include/c++/4.0.0/limits \
+  /usr/include/c++/4.0.0/bits/stl_function.h \
+  /usr/include/c++/4.0.0/bits/basic_string.h \
+  /usr/include/c++/4.0.0/bits/atomicity.h \
+  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/atomic_word.h \
+  /usr/include/c++/4.0.0/algorithm /usr/include/c++/4.0.0/bits/stl_algo.h \
+  /usr/include/c++/4.0.0/bits/stl_heap.h \
+  /usr/include/c++/4.0.0/bits/stl_tempbuf.h \
+  /usr/include/c++/4.0.0/bits/basic_string.tcc /usr/include/c++/4.0.0/set \
+  /usr/include/c++/4.0.0/bits/stl_tree.h \
+  /usr/include/c++/4.0.0/bits/stl_set.h \
+  /usr/include/c++/4.0.0/bits/stl_multiset.h ../cpp/ag_base.h \
+  /usr/include/c++/4.0.0/stdexcept /usr/include/c++/4.0.0/typeinfo \
+  /usr/include/c++/4.0.0/map /usr/include/c++/4.0.0/bits/stl_map.h \
+  /usr/include/c++/4.0.0/bits/stl_multimap.h \
+  /usr/include/c++/4.0.0/iostream /usr/include/c++/4.0.0/ostream \
+  /usr/include/c++/4.0.0/ios /usr/include/c++/4.0.0/bits/localefwd.h \
+  /usr/include/c++/4.0.0/bits/ios_base.h \
+  /usr/include/c++/4.0.0/bits/locale_classes.h \
+  /usr/include/c++/4.0.0/streambuf \
+  /usr/include/c++/4.0.0/bits/streambuf.tcc \
+  /usr/include/c++/4.0.0/bits/basic_ios.h \
+  /usr/include/c++/4.0.0/bits/streambuf_iterator.h \
+  /usr/include/c++/4.0.0/bits/locale_facets.h \
+  /usr/include/c++/4.0.0/cwctype /usr/include/wctype.h \
+  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/ctype_base.h \
+  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/ctype_inline.h \
+  /usr/include/c++/4.0.0/bits/codecvt.h \
+  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/time_members.h \
+  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/messages_members.h \
+  /usr/include/c++/4.0.0/bits/basic_ios.tcc \
+  /usr/include/c++/4.0.0/bits/ostream.tcc /usr/include/c++/4.0.0/locale \
+  /usr/include/c++/4.0.0/bits/locale_facets.tcc \
+  /usr/include/c++/4.0.0/istream /usr/include/c++/4.0.0/bits/istream.tcc \
+  /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/universal-darwin9.0/ruby.h \
+  /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/universal-darwin9.0/config.h \
+  /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/universal-darwin9.0/defines.h \
+  /usr/lib/gcc/powerpc-apple-darwin9/4.0.1/include/syslimits.h \
+  /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/universal-darwin9.0/missing.h \
+  /usr/include/sys/time.h /usr/include/sys/types.h \
+  /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/universal-darwin9.0/intern.h


Property changes on: antargis/trunk/rookey/spec/cpp/ag_rubyobj.cc
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/rookey/spec/helper_spec.rb
===================================================================
--- antargis/trunk/rookey/spec/helper_spec.rb	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/spec/helper_spec.rb	2008-03-28 16:59:36 UTC (rev 1237)
@@ -0,0 +1,125 @@
+require 'pp'
+
+def checkExe(exe)
+  puts `#{exe}`
+  $?.should == 0
+end
+
+def local(var)
+  File.expand_path(var.my)
+end
+
+class FileInspector
+  def initialize(file)
+    @filename=file
+    @mtime=File.mtime(file)
+    sleep(2)
+  end
+  
+  def touched?
+    curtime=File.mtime(@filename)
+    puts &quot;#{@mtime}!=#{curtime}&quot;
+    @mtime!=curtime
+  end
+  def touch(file)
+    checkExe(&quot;touch #{file}&quot;)
+  end
+end
+
+def inspectFile(filename,&amp;block)
+  ins=FileInspector.new(filename)
+  ins.instance_eval(&amp;block)
+  ins
+end
+
+class Rakefile
+  def method_missing(name)
+    checkExe(&quot;rake #{name}&quot;)
+  end
+end
+
+class RakefileConfig
+  
+  class Var
+    attr_reader :my
+    def initialize(v,m=nil)
+      @s=v.to_s
+      @my=m
+    end
+    def to_s
+      @s
+    end
+  end
+  
+  def initialize
+    @tasks=[]
+    @varcounter=0
+  end
+  
+  def link_dll(what)
+    var=makeVar
+    swigname=&quot;File.split(#{what}.flatten.select{|f|f=~/swig/}[0])[1].sub(/_swig.*/,'')&quot;
+    @tasks &lt;&lt; &quot;#{var}=Rookey.link_dll(&quot;+swigname+&quot;,#{what})&quot;
+    Var.new(var)    
+  end
+  def link_exe(what)
+    var=makeVar
+    myFile=dummyFile
+    @tasks &lt;&lt; &quot;#{var}=Rookey.link_exe('&quot;+myFile+&quot;',#{what})&quot;
+    Var.new(var,myFile)
+  end
+  
+  def compile(files)
+    var=makeVar
+    @tasks &lt;&lt; var+&quot;=Rookey.compile([&quot;+files.map{|f|f.is_a?(String)?&quot;'#{f}'&quot;:f}.join(&quot;,&quot;)+&quot;])&quot;
+    Var.new(var)
+  end
+  
+  def swig(inputs)
+    var=makeVar
+    var2=makeVar
+    swigName=dummyFile
+    @tasks &lt;&lt; var +&quot;=Rookey.swig_interface('#{swigName}'=&gt;[&quot;+inputs.map{|f|f.is_a?(String)?&quot;'#{f}'&quot;:f}.join(&quot;,&quot;)+&quot;])&quot;
+    @tasks &lt;&lt; var2 +&quot;=Rookey.swig('#{swigName}_swig.cc'=&gt;[&quot;+var+&quot;])&quot;
+    Var.new(var2)
+  end
+  
+  def write
+    puts &quot;RUN&quot;
+    content=@tasks.join(&quot;\n&quot;)
+    makeRakefile(content)
+  end
+  def default(r)
+    @tasks &lt;&lt; &quot;task :default=&gt;#{r}&quot;
+  end
+
+private
+  def dummyFile
+    @varcounter+=1
+    f=&quot;file#{@varcounter}&quot;
+    f
+  end
+
+  def makeVar
+    @varcounter+=1
+    &quot;var#{@varcounter}&quot;
+  end
+  
+  def makeRakefile(content)
+    fd=File.open(&quot;Rakefile&quot;,&quot;w&quot;)
+    fd.puts &quot;require '../tasks.rb'&quot;
+    fd.puts &quot;require 'rake/clean.rb'&quot;
+    fd.puts content
+    fd.close
+  end
+end
+
+def rake(&amp;block)
+  rakefile=RakefileConfig.new
+  #yield rakefile
+  r=rakefile.instance_eval(&amp;block)
+  
+  rakefile.default(r)
+  rakefile.write
+  Rakefile.new
+end

Deleted: antargis/trunk/rookey/spec/interface.i
===================================================================
--- antargis/trunk/rookey/spec/interface.i	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/spec/interface.i	2008-03-28 16:59:36 UTC (rev 1237)
@@ -1 +0,0 @@
-%module antargis
\ No newline at end of file

Modified: antargis/trunk/rookey/spec/main.cc
===================================================================
--- antargis/trunk/rookey/spec/main.cc	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/spec/main.cc	2008-03-28 16:59:36 UTC (rev 1237)
@@ -1,7 +1,9 @@
 #include &lt;iostream&gt;
+#include &quot;main.h&quot;
 
 int main()
   {
+    m();
     std::cout&lt;&lt;&quot;ok&quot;&lt;&lt;std::endl;
     return 0;
-  }
\ No newline at end of file
+  }

Added: antargis/trunk/rookey/spec/main.h
===================================================================
--- antargis/trunk/rookey/spec/main.h	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/spec/main.h	2008-03-28 16:59:36 UTC (rev 1237)
@@ -0,0 +1,13 @@
+#ifndef MAIN_H
+#define MAIN_H
+
+
+#include &lt;iostream&gt;
+
+inline int m()
+  {
+    std::cout&lt;&lt;&quot;yup&quot;&lt;&lt;std::endl;
+    return 0;
+  }
+
+#endif


Property changes on: antargis/trunk/rookey/spec/main.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Modified: antargis/trunk/rookey/spec/spec_rookey.rb
===================================================================
--- antargis/trunk/rookey/spec/spec_rookey.rb	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/spec/spec_rookey.rb	2008-03-28 16:59:36 UTC (rev 1237)
@@ -1,3 +1,9 @@
+require File.join(File.split(__FILE__)[0],&quot;helper_spec.rb&quot;)
+
+Dir.chdir(File.split(__FILE__)[0])
+
+
+
 describe &quot;Dependencies&quot; do
   describe &quot;for swig&quot; do
     it &quot;should handle interface-files correctly&quot;
@@ -6,10 +12,33 @@
   end
   describe &quot;for gcc&quot; do
     it &quot;should handle c-files correctly&quot;
-    it &quot;should handle depending header files correctly&quot;
+    it &quot;should handle depending header files correctly&quot; do
+      exe=nil
+      rakefile=rake do
+        exe=link_exe(compile(&quot;main.cc&quot;))
+      end
+      rakefile.default
+      checkExe(local(exe))
+      inspectFile(local(exe)) do
+        touch(&quot;main.h&quot;)
+        rakefile.default
+      end.should be_touched
+    end
+    it &quot;link should include cleanup&quot; do
+      exe=nil
+      rakefile=rake do
+        exe=link_exe(compile(&quot;main.cc&quot;))
+      end
+      rakefile.default
+      File.exists?(local(exe)).should be_true
+      rakefile.clean
+      File.exists?(local(exe)).should be_false
+    end
   end
+  
 end
 
+
 describe &quot;Config&quot; do
   it &quot;should have an interface for configuring profiling, debugging, paths and so on&quot;
   it &quot;should handle config-scripts in correct order&quot;
@@ -20,5 +49,23 @@
 end
 
 describe &quot;Interface generation&quot; do
-  it &quot;should generate directors for all ruby-classes&quot;
-end
\ No newline at end of file
+  it &quot;should generate directors for all ruby-classes&quot; do
+    dll=nil
+    rakefile=rake do 
+      dll=link_dll(compile([&quot;main.cc&quot;,swig(&quot;a.h&quot;)]))
+    end
+    rakefile.default
+    # run my test
+    ruby do
+      c &quot;require '#{local(dll)}&quot;
+      c &quot;B.new&quot;
+    end
+    
+    rakefile.clean
+  end
+end
+
+
+describe &quot;Swig tests&quot; do
+end
+

Added: antargis/trunk/rookey/spec/test
===================================================================
(Binary files differ)


Property changes on: antargis/trunk/rookey/spec/test
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: antargis/trunk/rookey/spec/test.c
===================================================================
--- antargis/trunk/rookey/spec/test.c	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/spec/test.c	2008-03-28 16:59:36 UTC (rev 1237)
@@ -0,0 +1 @@
+extern &quot;C&quot; void Mix_LoadMus();int main(){return 0;}


Property changes on: antargis/trunk/rookey/spec/test.c
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/rookey/spec_output.html
===================================================================
--- antargis/trunk/rookey/spec_output.html	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/spec_output.html	2008-03-28 16:59:36 UTC (rev 1237)
@@ -0,0 +1,250 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!DOCTYPE html 
+  PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;
+  &quot;<A HREF="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</A>&quot;&gt;
+&lt;html xmlns=&quot;<A HREF="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</A>&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;
+&lt;head&gt;
+  &lt;title&gt;RSpec results&lt;/title&gt;
+  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
+  &lt;meta http-equiv=&quot;Expires&quot; content=&quot;-1&quot; /&gt;
+  &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt;
+  &lt;style type=&quot;text/css&quot;&gt;
+  body {
+    margin: 0;
+    padding: 0;
+    background: #fff;
+    font-size: 80%;
+  }
+  &lt;/style&gt;
+&lt;/head&gt;
+&lt;body&gt;
+&lt;div class=&quot;rspec-report&quot;&gt;
+  &lt;script type=&quot;text/javascript&quot;&gt;
+    // &lt;![CDATA[
+function moveProgressBar(percentDone) {
+  document.getElementById(&quot;rspec-header&quot;).style.width = percentDone +&quot;%&quot;;
+}
+function makeRed(element_id) {
+  document.getElementById(element_id).style.background = '#C40D0D';
+  document.getElementById(element_id).style.color = '#FFFFFF';
+}
+
+function makeYellow(element_id) {
+  if (element_id == &quot;rspec-header&quot; &amp;&amp; document.getElementById(element_id).style.background != '#C40D0D')
+  {
+    document.getElementById(element_id).style.background = '#FAF834';
+    document.getElementById(element_id).style.color = '#000000';
+  }
+  else
+  {
+    document.getElementById(element_id).style.background = '#FAF834';
+    document.getElementById(element_id).style.color = '#000000';
+  }
+}
+
+    // ]]&gt;
+  &lt;/script&gt;
+  &lt;style type=&quot;text/css&quot;&gt;
+#rspec-header {
+  background: #65C400; color: #fff;
+}
+
+.rspec-report h1 {
+  margin: 0px 10px 0px 10px;
+  padding: 10px;
+  font-family: &quot;Lucida Grande&quot;, Helvetica, sans-serif;
+  font-size: 1.8em;
+}
+
+#summary {
+  margin: 0; padding: 5px 10px;
+  font-family: &quot;Lucida Grande&quot;, Helvetica, sans-serif;
+  text-align: right;
+  position: absolute;
+  top: 0px;
+  right: 0px;
+}
+
+#summary p {
+  margin: 0 0 0 2px;
+}
+
+#summary #totals {
+  font-size: 1.2em;
+}
+
+.example_group {
+  margin: 0 10px 5px;
+  background: #fff;
+}
+
+dl {
+  margin: 0; padding: 0 0 5px;
+  font: normal 11px &quot;Lucida Grande&quot;, Helvetica, sans-serif;
+}
+
+dt {
+  padding: 3px;
+  background: #65C400;
+  color: #fff;
+  font-weight: bold;
+}
+
+dd {
+  margin: 5px 0 5px 5px;
+  padding: 3px 3px 3px 18px;
+}
+
+dd.spec.passed {
+  border-left: 5px solid #65C400;
+  border-bottom: 1px solid #65C400;
+  background: #DBFFB4; color: #3D7700;
+}
+
+dd.spec.failed {
+  border-left: 5px solid #C20000;
+  border-bottom: 1px solid #C20000;
+  color: #C20000; background: #FFFBD3;
+}
+
+dd.spec.not_implemented {
+  border-left: 5px solid #FAF834;
+  border-bottom: 1px solid #FAF834;
+  background: #FCFB98; color: #131313;
+}
+
+dd.spec.pending_fixed {
+  border-left: 5px solid #0000C2;
+  border-bottom: 1px solid #0000C2;
+  color: #0000C2; background: #D3FBFF;
+}
+
+.backtrace {
+  color: #000;
+  font-size: 12px;
+}
+
+a {
+  color: #BE5C00;
+}
+
+/* Ruby code, style similar to vibrant ink */
+.ruby {
+  font-size: 12px;
+  font-family: monospace;
+  color: white;
+  background-color: black;
+  padding: 0.1em 0 0.2em 0;
+}
+
+.ruby .keyword { color: #FF6600; }
+.ruby .constant { color: #339999; }
+.ruby .attribute { color: white; }
+.ruby .global { color: white; }
+.ruby .module { color: white; }
+.ruby .class { color: white; }
+.ruby .string { color: #66FF00; }
+.ruby .ident { color: white; }
+.ruby .method { color: #FFCC00; }
+.ruby .number { color: white; }
+.ruby .char { color: white; }
+.ruby .comment { color: #9933CC; }
+.ruby .symbol { color: white; }
+.ruby .regex { color: #44B4CC; }
+.ruby .punct { color: white; }
+.ruby .escape { color: white; }
+.ruby .interp { color: white; }
+.ruby .expr { color: white; }
+
+.ruby .offending { background-color: gray; }
+.ruby .linenum {
+  width: 75px;
+  padding: 0.1em 1em 0.2em 0;
+  color: #000000;
+  background-color: #FFFBD3;
+}
+
+  &lt;/style&gt;
+
+&lt;div id=&quot;rspec-header&quot;&gt;
+  &lt;h1&gt;RSpec Results&lt;/h1&gt;
+
+  &lt;div id=&quot;summary&quot;&gt;
+    &lt;p id=&quot;totals&quot;&gt;&nbsp;&lt;/p&gt;
+    &lt;p id=&quot;duration&quot;&gt;&nbsp;&lt;/p&gt;
+  &lt;/div&gt;
+&lt;/div&gt;
+
+&lt;div class=&quot;results&quot;&gt;
+&lt;div class=&quot;example_group&quot;&gt;
+  &lt;dl&gt;
+  &lt;dt id=&quot;example_group_1&quot;&gt;Dependencies for swig&lt;/dt&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('rspec-header');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('example_group_1');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;moveProgressBar('7.6');&lt;/script&gt;
+    &lt;dd class=&quot;spec not_implemented&quot;&gt;&lt;span class=&quot;not_implemented_spec_name&quot;&gt;should handle interface-files correctly (PENDING: Not Yet Implemented)&lt;/span&gt;&lt;/dd&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('rspec-header');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('example_group_1');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;moveProgressBar('15.3');&lt;/script&gt;
+    &lt;dd class=&quot;spec not_implemented&quot;&gt;&lt;span class=&quot;not_implemented_spec_name&quot;&gt;should handle depending header files correctly (PENDING: Not Yet Implemented)&lt;/span&gt;&lt;/dd&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('rspec-header');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('example_group_1');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;moveProgressBar('23.0');&lt;/script&gt;
+    &lt;dd class=&quot;spec not_implemented&quot;&gt;&lt;span class=&quot;not_implemented_spec_name&quot;&gt;the compiler should be called (PENDING: Not Yet Implemented)&lt;/span&gt;&lt;/dd&gt;
+  &lt;/dl&gt;
+&lt;/div&gt;
+&lt;div class=&quot;example_group&quot;&gt;
+  &lt;dl&gt;
+  &lt;dt id=&quot;example_group_2&quot;&gt;Dependencies for gcc&lt;/dt&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('rspec-header');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('example_group_2');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;moveProgressBar('30.7');&lt;/script&gt;
+    &lt;dd class=&quot;spec not_implemented&quot;&gt;&lt;span class=&quot;not_implemented_spec_name&quot;&gt;should handle c-files correctly (PENDING: Not Yet Implemented)&lt;/span&gt;&lt;/dd&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;moveProgressBar('38.4');&lt;/script&gt;
+    &lt;dd class=&quot;spec passed&quot;&gt;&lt;span class=&quot;passed_spec_name&quot;&gt;should handle depending header files correctly&lt;/span&gt;&lt;/dd&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;moveProgressBar('46.1');&lt;/script&gt;
+    &lt;dd class=&quot;spec passed&quot;&gt;&lt;span class=&quot;passed_spec_name&quot;&gt;link should include cleanup&lt;/span&gt;&lt;/dd&gt;
+  &lt;/dl&gt;
+&lt;/div&gt;
+&lt;div class=&quot;example_group&quot;&gt;
+  &lt;dl&gt;
+  &lt;dt id=&quot;example_group_3&quot;&gt;Config&lt;/dt&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('rspec-header');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('example_group_3');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;moveProgressBar('53.8');&lt;/script&gt;
+    &lt;dd class=&quot;spec not_implemented&quot;&gt;&lt;span class=&quot;not_implemented_spec_name&quot;&gt;should have an interface for configuring profiling, debugging, paths and so on (PENDING: Not Yet Implemented)&lt;/span&gt;&lt;/dd&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('rspec-header');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('example_group_3');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;moveProgressBar('61.5');&lt;/script&gt;
+    &lt;dd class=&quot;spec not_implemented&quot;&gt;&lt;span class=&quot;not_implemented_spec_name&quot;&gt;should handle config-scripts in correct order (PENDING: Not Yet Implemented)&lt;/span&gt;&lt;/dd&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('rspec-header');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('example_group_3');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;moveProgressBar('69.2');&lt;/script&gt;
+    &lt;dd class=&quot;spec not_implemented&quot;&gt;&lt;span class=&quot;not_implemented_spec_name&quot;&gt;should find libraries (PENDING: Not Yet Implemented)&lt;/span&gt;&lt;/dd&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('rspec-header');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('example_group_3');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;moveProgressBar('76.9');&lt;/script&gt;
+    &lt;dd class=&quot;spec not_implemented&quot;&gt;&lt;span class=&quot;not_implemented_spec_name&quot;&gt;should find programs (PENDING: Not Yet Implemented)&lt;/span&gt;&lt;/dd&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('rspec-header');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('example_group_3');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;moveProgressBar('84.6');&lt;/script&gt;
+    &lt;dd class=&quot;spec not_implemented&quot;&gt;&lt;span class=&quot;not_implemented_spec_name&quot;&gt;should check libraries for functions (PENDING: Not Yet Implemented)&lt;/span&gt;&lt;/dd&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('rspec-header');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;makeYellow('example_group_3');&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;moveProgressBar('92.3');&lt;/script&gt;
+    &lt;dd class=&quot;spec not_implemented&quot;&gt;&lt;span class=&quot;not_implemented_spec_name&quot;&gt;should have an option for using mingw (PENDING: Not Yet Implemented)&lt;/span&gt;&lt;/dd&gt;
+  &lt;/dl&gt;
+&lt;/div&gt;
+&lt;div class=&quot;example_group&quot;&gt;
+  &lt;dl&gt;
+  &lt;dt id=&quot;example_group_4&quot;&gt;Interface generation&lt;/dt&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;moveProgressBar('100.0');&lt;/script&gt;
+    &lt;dd class=&quot;spec passed&quot;&gt;&lt;span class=&quot;passed_spec_name&quot;&gt;should generate directors for all ruby-classes&lt;/span&gt;&lt;/dd&gt;
+  &lt;/dl&gt;
+&lt;/div&gt;
+&lt;script type=&quot;text/javascript&quot;&gt;document.getElementById('duration').innerHTML = &quot;Finished in &lt;strong&gt;8.36383 seconds&lt;/strong&gt;&quot;;&lt;/script&gt;
+&lt;script type=&quot;text/javascript&quot;&gt;document.getElementById('totals').innerHTML = &quot;13 examples, 0 failures, 10 pending&quot;;&lt;/script&gt;
+&lt;/div&gt;
+&lt;/div&gt;
+&lt;/body&gt;
+&lt;/html&gt;


Property changes on: antargis/trunk/rookey/spec_output.html
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Deleted: antargis/trunk/rookey/swig.cc
===================================================================
--- antargis/trunk/rookey/swig.cc	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/swig.cc	2008-03-28 16:59:36 UTC (rev 1237)
@@ -1,2029 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (<A HREF="http://www.swig.org">http://www.swig.org</A>).
- * Version 1.3.33
- * 
- * This file is not intended to be easily readable and contains a number of 
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG 
- * interface file instead. 
- * ----------------------------------------------------------------------------- */
-
-#define SWIGRUBY
-
-#ifdef __cplusplus
-template&lt;typename T&gt; class SwigValueWrapper {
-    T *tt;
-public:
-    SwigValueWrapper() : tt(0) { }
-    SwigValueWrapper(const SwigValueWrapper&lt;T&gt;&amp; rhs) : tt(new T(*rhs.tt)) { }
-    SwigValueWrapper(const T&amp; t) : tt(new T(t)) { }
-    ~SwigValueWrapper() { delete tt; } 
-    SwigValueWrapper&amp; operator=(const T&amp; t) { delete tt; tt = new T(t); return *this; }
-    operator T&amp;() const { return *tt; }
-    T *operator&amp;() { return tt; }
-private:
-    SwigValueWrapper&amp; operator=(const SwigValueWrapper&lt;T&gt;&amp; rhs);
-};
-
-template &lt;typename T&gt; T SwigValueInit() {
-  return T();
-}
-#endif
-
-/* -----------------------------------------------------------------------------
- *  This section contains generic SWIG labels for method/variable
- *  declarations/attributes, and other compiler dependent labels.
- * ----------------------------------------------------------------------------- */
-
-/* template workaround for compilers that cannot correctly implement the C++ standard */
-#ifndef SWIGTEMPLATEDISAMBIGUATOR
-# if defined(__SUNPRO_CC) &amp;&amp; (__SUNPRO_CC &lt;= 0x560)
-#  define SWIGTEMPLATEDISAMBIGUATOR template
-# elif defined(__HP_aCC)
-/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
-/* If we find a maximum version that requires this, the test would be __HP_aCC &lt;= 35500 for A.03.55 */
-#  define SWIGTEMPLATEDISAMBIGUATOR template
-# else
-#  define SWIGTEMPLATEDISAMBIGUATOR
-# endif
-#endif
-
-/* inline attribute */
-#ifndef SWIGINLINE
-# if defined(__cplusplus) || (defined(__GNUC__) &amp;&amp; !defined(__STRICT_ANSI__))
-#   define SWIGINLINE inline
-# else
-#   define SWIGINLINE
-# endif
-#endif
-
-/* attribute recognised by some compilers to avoid 'unused' warnings */
-#ifndef SWIGUNUSED
-# if defined(__GNUC__)
-#   if !(defined(__cplusplus)) || (__GNUC__ &gt; 3 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4))
-#     define SWIGUNUSED __attribute__ ((__unused__)) 
-#   else
-#     define SWIGUNUSED
-#   endif
-# elif defined(__ICC)
-#   define SWIGUNUSED __attribute__ ((__unused__)) 
-# else
-#   define SWIGUNUSED 
-# endif
-#endif
-
-#ifndef SWIGUNUSEDPARM
-# ifdef __cplusplus
-#   define SWIGUNUSEDPARM(p)
-# else
-#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
-# endif
-#endif
-
-/* internal SWIG method */
-#ifndef SWIGINTERN
-# define SWIGINTERN static SWIGUNUSED
-#endif
-
-/* internal inline SWIG method */
-#ifndef SWIGINTERNINLINE
-# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
-#endif
-
-/* exporting methods */
-#if (__GNUC__ &gt;= 4) || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4)
-#  ifndef GCC_HASCLASSVISIBILITY
-#    define GCC_HASCLASSVISIBILITY
-#  endif
-#endif
-
-#ifndef SWIGEXPORT
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   if defined(STATIC_LINKED)
-#     define SWIGEXPORT
-#   else
-#     define SWIGEXPORT __declspec(dllexport)
-#   endif
-# else
-#   if defined(__GNUC__) &amp;&amp; defined(GCC_HASCLASSVISIBILITY)
-#     define SWIGEXPORT __attribute__ ((visibility(&quot;default&quot;)))
-#   else
-#     define SWIGEXPORT
-#   endif
-# endif
-#endif
-
-/* calling conventions for Windows */
-#ifndef SWIGSTDCALL
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   define SWIGSTDCALL __stdcall
-# else
-#   define SWIGSTDCALL
-# endif 
-#endif
-
-/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
-#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) &amp;&amp; defined(_MSC_VER) &amp;&amp; !defined(_CRT_SECURE_NO_DEPRECATE)
-# define _CRT_SECURE_NO_DEPRECATE
-#endif
-
-/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
-#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) &amp;&amp; defined(_MSC_VER) &amp;&amp; !defined(_SCL_SECURE_NO_DEPRECATE)
-# define _SCL_SECURE_NO_DEPRECATE
-#endif
-
-
-/* -----------------------------------------------------------------------------
- *  This section contains generic SWIG labels for method/variable
- *  declarations/attributes, and other compiler dependent labels.
- * ----------------------------------------------------------------------------- */
-
-/* template workaround for compilers that cannot correctly implement the C++ standard */
-#ifndef SWIGTEMPLATEDISAMBIGUATOR
-# if defined(__SUNPRO_CC) &amp;&amp; (__SUNPRO_CC &lt;= 0x560)
-#  define SWIGTEMPLATEDISAMBIGUATOR template
-# elif defined(__HP_aCC)
-/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
-/* If we find a maximum version that requires this, the test would be __HP_aCC &lt;= 35500 for A.03.55 */
-#  define SWIGTEMPLATEDISAMBIGUATOR template
-# else
-#  define SWIGTEMPLATEDISAMBIGUATOR
-# endif
-#endif
-
-/* inline attribute */
-#ifndef SWIGINLINE
-# if defined(__cplusplus) || (defined(__GNUC__) &amp;&amp; !defined(__STRICT_ANSI__))
-#   define SWIGINLINE inline
-# else
-#   define SWIGINLINE
-# endif
-#endif
-
-/* attribute recognised by some compilers to avoid 'unused' warnings */
-#ifndef SWIGUNUSED
-# if defined(__GNUC__)
-#   if !(defined(__cplusplus)) || (__GNUC__ &gt; 3 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4))
-#     define SWIGUNUSED __attribute__ ((__unused__)) 
-#   else
-#     define SWIGUNUSED
-#   endif
-# elif defined(__ICC)
-#   define SWIGUNUSED __attribute__ ((__unused__)) 
-# else
-#   define SWIGUNUSED 
-# endif
-#endif
-
-#ifndef SWIGUNUSEDPARM
-# ifdef __cplusplus
-#   define SWIGUNUSEDPARM(p)
-# else
-#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
-# endif
-#endif
-
-/* internal SWIG method */
-#ifndef SWIGINTERN
-# define SWIGINTERN static SWIGUNUSED
-#endif
-
-/* internal inline SWIG method */
-#ifndef SWIGINTERNINLINE
-# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
-#endif
-
-/* exporting methods */
-#if (__GNUC__ &gt;= 4) || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4)
-#  ifndef GCC_HASCLASSVISIBILITY
-#    define GCC_HASCLASSVISIBILITY
-#  endif
-#endif
-
-#ifndef SWIGEXPORT
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   if defined(STATIC_LINKED)
-#     define SWIGEXPORT
-#   else
-#     define SWIGEXPORT __declspec(dllexport)
-#   endif
-# else
-#   if defined(__GNUC__) &amp;&amp; defined(GCC_HASCLASSVISIBILITY)
-#     define SWIGEXPORT __attribute__ ((visibility(&quot;default&quot;)))
-#   else
-#     define SWIGEXPORT
-#   endif
-# endif
-#endif
-
-/* calling conventions for Windows */
-#ifndef SWIGSTDCALL
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   define SWIGSTDCALL __stdcall
-# else
-#   define SWIGSTDCALL
-# endif 
-#endif
-
-/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
-#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) &amp;&amp; defined(_MSC_VER) &amp;&amp; !defined(_CRT_SECURE_NO_DEPRECATE)
-# define _CRT_SECURE_NO_DEPRECATE
-#endif
-
-/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
-#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) &amp;&amp; defined(_MSC_VER) &amp;&amp; !defined(_SCL_SECURE_NO_DEPRECATE)
-# define _SCL_SECURE_NO_DEPRECATE
-#endif
-
-
-/* -----------------------------------------------------------------------------
- * swigrun.swg
- *
- * This file contains generic CAPI SWIG runtime support for pointer
- * type checking.
- * ----------------------------------------------------------------------------- */
-
-/* This should only be incremented when either the layout of swig_type_info changes,
-   or for whatever reason, the runtime changes incompatibly */
-#define SWIG_RUNTIME_VERSION &quot;3&quot;
-
-/* define SWIG_TYPE_TABLE_NAME as &quot;SWIG_TYPE_TABLE&quot; */
-#ifdef SWIG_TYPE_TABLE
-# define SWIG_QUOTE_STRING(x) #x
-# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
-# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
-#else
-# define SWIG_TYPE_TABLE_NAME
-#endif
-
-/*
-  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
-  creating a static or dynamic library from the swig runtime code.
-  In 99.9% of the cases, swig just needs to declare them as 'static'.
-  
-  But only do this if is strictly necessary, ie, if you have problems
-  with your compiler or so.
-*/
-
-#ifndef SWIGRUNTIME
-# define SWIGRUNTIME SWIGINTERN
-#endif
-
-#ifndef SWIGRUNTIMEINLINE
-# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
-#endif
-
-/*  Generic buffer size */
-#ifndef SWIG_BUFFER_SIZE
-# define SWIG_BUFFER_SIZE 1024
-#endif
-
-/* Flags for pointer conversions */
-#define SWIG_POINTER_DISOWN        0x1
-
-/* Flags for new pointer objects */
-#define SWIG_POINTER_OWN           0x1
-
-
-/* 
-   Flags/methods for returning states.
-   
-   The swig conversion methods, as ConvertPtr, return and integer 
-   that tells if the conversion was successful or not. And if not,
-   an error code can be returned (see swigerrors.swg for the codes).
-   
-   Use the following macros/flags to set or process the returning
-   states.
-   
-   In old swig versions, you usually write code as:
-
-     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
-       // success code
-     } else {
-       //fail code
-     }
-
-   Now you can be more explicit as:
-
-    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
-    if (SWIG_IsOK(res)) {
-      // success code
-    } else {
-      // fail code
-    }
-
-   that seems to be the same, but now you can also do
-
-    Type *ptr;
-    int res = SWIG_ConvertPtr(obj,(void **)(&amp;ptr),ty.flags);
-    if (SWIG_IsOK(res)) {
-      // success code
-      if (SWIG_IsNewObj(res) {
-        ...
-	delete *ptr;
-      } else {
-        ...
-      }
-    } else {
-      // fail code
-    }
-    
-   I.e., now SWIG_ConvertPtr can return new objects and you can
-   identify the case and take care of the deallocation. Of course that
-   requires also to SWIG_ConvertPtr to return new result values, as
-
-      int SWIG_ConvertPtr(obj, ptr,...) {         
-        if (&lt;obj is ok&gt;) {			       
-          if (&lt;need new object&gt;) {		       
-            *ptr = &lt;ptr to new allocated object&gt;; 
-            return SWIG_NEWOBJ;		       
-          } else {				       
-            *ptr = &lt;ptr to old object&gt;;	       
-            return SWIG_OLDOBJ;		       
-          } 				       
-        } else {				       
-          return SWIG_BADOBJ;		       
-        }					       
-      }
-
-   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
-   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
-   swig errors code.
-
-   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
-
-       int food(double)
-       int fooi(int);
-
-   and you call
- 
-      food(1)   // cast rank '1'  (1 -&gt; 1.0)
-      fooi(1)   // cast rank '0'
-
-   just use the SWIG_AddCast()/SWIG_CheckState()
-
-
- */
-#define SWIG_OK                    (0) 
-#define SWIG_ERROR                 (-1)
-#define SWIG_IsOK(r)               (r &gt;= 0)
-#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
-
-/* The CastRankLimit says how many bits are used for the cast rank */
-#define SWIG_CASTRANKLIMIT         (1 &lt;&lt; 8)
-/* The NewMask denotes the object was created (using new/malloc) */
-#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  &lt;&lt; 1)
-/* The TmpMask is for in/out typemaps that use temporal objects */
-#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK &lt;&lt; 1)
-/* Simple returning values */
-#define SWIG_BADOBJ                (SWIG_ERROR)
-#define SWIG_OLDOBJ                (SWIG_OK)
-#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
-#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
-#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
-#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r &amp; ~SWIG_NEWOBJMASK) : r)
-#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) &amp;&amp; (r &amp; SWIG_NEWOBJMASK))
-#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
-#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r &amp; ~SWIG_TMPOBJMASK) : r)
-#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) &amp;&amp; (r &amp; SWIG_TMPOBJMASK))
-
-
-/* Cast-Rank Mode */
-#if defined(SWIG_CASTRANK_MODE)
-#  ifndef SWIG_TypeRank
-#    define SWIG_TypeRank             unsigned long
-#  endif
-#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
-#    define SWIG_MAXCASTRANK          (2)
-#  endif
-#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
-#  define SWIG_CastRank(r)           (r &amp; SWIG_CASTRANKMASK)
-SWIGINTERNINLINE int SWIG_AddCast(int r) { 
-  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) &lt; SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
-}
-SWIGINTERNINLINE int SWIG_CheckState(int r) { 
-  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
-}
-#else /* no cast-rank mode */
-#  define SWIG_AddCast
-#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
-#endif
-
-
-
-
-#include &lt;string.h&gt;
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-typedef void *(*swig_converter_func)(void *);
-typedef struct swig_type_info *(*swig_dycast_func)(void **);
-
-/* Structure to store inforomation on one type */
-typedef struct swig_type_info {
-  const char             *name;			/* mangled name of this type */
-  const char             *str;			/* human readable name of this type */
-  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
-  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
-  void                   *clientdata;		/* language specific type data */
-  int                    owndata;		/* flag if the structure owns the clientdata */
-} swig_type_info;
-
-/* Structure to store a type and conversion function used for casting */
-typedef struct swig_cast_info {
-  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
-  swig_converter_func     converter;		/* function to cast the void pointers */
-  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
-  struct swig_cast_info  *prev;			/* pointer to the previous cast */
-} swig_cast_info;
-
-/* Structure used to store module information
- * Each module generates one structure like this, and the runtime collects
- * all of these structures and stores them in a circularly linked list.*/
-typedef struct swig_module_info {
-  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
-  size_t                 size;		        /* Number of types in this module */
-  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
-  swig_type_info         **type_initial;	/* Array of initially generated type structures */
-  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
-  void                    *clientdata;		/* Language specific module data */
-} swig_module_info;
-
-/* 
-  Compare two type names skipping the space characters, therefore
-  &quot;char*&quot; == &quot;char *&quot; and &quot;Class&lt;int&gt;&quot; == &quot;Class&lt;int &gt;&quot;, etc.
-
-  Return 0 when the two name types are equivalent, as in
-  strncmp, but skipping ' '.
-*/
-SWIGRUNTIME int
-SWIG_TypeNameComp(const char *f1, const char *l1,
-		  const char *f2, const char *l2) {
-  for (;(f1 != l1) &amp;&amp; (f2 != l2); ++f1, ++f2) {
-    while ((*f1 == ' ') &amp;&amp; (f1 != l1)) ++f1;
-    while ((*f2 == ' ') &amp;&amp; (f2 != l2)) ++f2;
-    if (*f1 != *f2) return (*f1 &gt; *f2) ? 1 : -1;
-  }
-  return (int)((l1 - f1) - (l2 - f2));
-}
-
-/*
-  Check type equivalence in a name list like &lt;name1&gt;|&lt;name2&gt;|...
-  Return 0 if not equal, 1 if equal
-*/
-SWIGRUNTIME int
-SWIG_TypeEquiv(const char *nb, const char *tb) {
-  int equiv = 0;
-  const char* te = tb + strlen(tb);
-  const char* ne = nb;
-  while (!equiv &amp;&amp; *ne) {
-    for (nb = ne; *ne; ++ne) {
-      if (*ne == '|') break;
-    }
-    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
-    if (*ne) ++ne;
-  }
-  return equiv;
-}
-
-/*
-  Check type equivalence in a name list like &lt;name1&gt;|&lt;name2&gt;|...
-  Return 0 if equal, -1 if nb &lt; tb, 1 if nb &gt; tb
-*/
-SWIGRUNTIME int
-SWIG_TypeCompare(const char *nb, const char *tb) {
-  int equiv = 0;
-  const char* te = tb + strlen(tb);
-  const char* ne = nb;
-  while (!equiv &amp;&amp; *ne) {
-    for (nb = ne; *ne; ++ne) {
-      if (*ne == '|') break;
-    }
-    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
-    if (*ne) ++ne;
-  }
-  return equiv;
-}
-
-
-/* think of this as a c++ template&lt;&gt; or a scheme macro */
-#define SWIG_TypeCheck_Template(comparison, ty)         \
-  if (ty) {                                             \
-    swig_cast_info *iter = ty-&gt;cast;                    \
-    while (iter) {                                      \
-      if (comparison) {                                 \
-        if (iter == ty-&gt;cast) return iter;              \
-        /* Move iter to the top of the linked list */   \
-        iter-&gt;prev-&gt;next = iter-&gt;next;                  \
-        if (iter-&gt;next)                                 \
-          iter-&gt;next-&gt;prev = iter-&gt;prev;                \
-        iter-&gt;next = ty-&gt;cast;                          \
-        iter-&gt;prev = 0;                                 \
-        if (ty-&gt;cast) ty-&gt;cast-&gt;prev = iter;            \
-        ty-&gt;cast = iter;                                \
-        return iter;                                    \
-      }                                                 \
-      iter = iter-&gt;next;                                \
-    }                                                   \
-  }                                                     \
-  return 0
-
-/*
-  Check the typename
-*/
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheck(const char *c, swig_type_info *ty) {
-  SWIG_TypeCheck_Template(strcmp(iter-&gt;type-&gt;name, c) == 0, ty);
-}
-
-/* Same as previous function, except strcmp is replaced with a pointer comparison */
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
-  SWIG_TypeCheck_Template(iter-&gt;type == from, into);
-}
-
-/*
-  Cast a pointer up an inheritance hierarchy
-*/
-SWIGRUNTIMEINLINE void *
-SWIG_TypeCast(swig_cast_info *ty, void *ptr) {
-  return ((!ty) || (!ty-&gt;converter)) ? ptr : (*ty-&gt;converter)(ptr);
-}
-
-/* 
-   Dynamic pointer casting. Down an inheritance hierarchy
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
-  swig_type_info *lastty = ty;
-  if (!ty || !ty-&gt;dcast) return ty;
-  while (ty &amp;&amp; (ty-&gt;dcast)) {
-    ty = (*ty-&gt;dcast)(ptr);
-    if (ty) lastty = ty;
-  }
-  return lastty;
-}
-
-/*
-  Return the name associated with this type
-*/
-SWIGRUNTIMEINLINE const char *
-SWIG_TypeName(const swig_type_info *ty) {
-  return ty-&gt;name;
-}
-
-/*
-  Return the pretty name associated with this type,
-  that is an unmangled type name in a form presentable to the user.
-*/
-SWIGRUNTIME const char *
-SWIG_TypePrettyName(const swig_type_info *type) {
-  /* The &quot;str&quot; field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
-  if (!type) return NULL;
-  if (type-&gt;str != NULL) {
-    const char *last_name = type-&gt;str;
-    const char *s;
-    for (s = type-&gt;str; *s; s++)
-      if (*s == '|') last_name = s+1;
-    return last_name;
-  }
-  else
-    return type-&gt;name;
-}
-
-/* 
-   Set the clientdata field for a type
-*/
-SWIGRUNTIME void
-SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
-  swig_cast_info *cast = ti-&gt;cast;
-  /* if (ti-&gt;clientdata == clientdata) return; */
-  ti-&gt;clientdata = clientdata;
-  
-  while (cast) {
-    if (!cast-&gt;converter) {
-      swig_type_info *tc = cast-&gt;type;
-      if (!tc-&gt;clientdata) {
-	SWIG_TypeClientData(tc, clientdata);
-      }
-    }    
-    cast = cast-&gt;next;
-  }
-}
-SWIGRUNTIME void
-SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
-  SWIG_TypeClientData(ti, clientdata);
-  ti-&gt;owndata = 1;
-}
-  
-/*
-  Search for a swig_type_info structure only by mangled name
-  Search is a O(log #types)
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_MangledTypeQueryModule(swig_module_info *start, 
-                            swig_module_info *end, 
-		            const char *name) {
-  swig_module_info *iter = start;
-  do {
-    if (iter-&gt;size) {
-      register size_t l = 0;
-      register size_t r = iter-&gt;size - 1;
-      do {
-	/* since l+r &gt;= 0, we can (&gt;&gt; 1) instead (/ 2) */
-	register size_t i = (l + r) &gt;&gt; 1; 
-	const char *iname = iter-&gt;types[i]-&gt;name;
-	if (iname) {
-	  register int compare = strcmp(name, iname);
-	  if (compare == 0) {	    
-	    return iter-&gt;types[i];
-	  } else if (compare &lt; 0) {
-	    if (i) {
-	      r = i - 1;
-	    } else {
-	      break;
-	    }
-	  } else if (compare &gt; 0) {
-	    l = i + 1;
-	  }
-	} else {
-	  break; /* should never happen */
-	}
-      } while (l &lt;= r);
-    }
-    iter = iter-&gt;next;
-  } while (iter != end);
-  return 0;
-}
-
-/*
-  Search for a swig_type_info structure for either a mangled name or a human readable name.
-  It first searches the mangled names of the types, which is a O(log #types)
-  If a type is not found it then searches the human readable names, which is O(#types).
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeQueryModule(swig_module_info *start, 
-                     swig_module_info *end, 
-		     const char *name) {
-  /* STEP 1: Search the name field using binary search */
-  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
-  if (ret) {
-    return ret;
-  } else {
-    /* STEP 2: If the type hasn't been found, do a complete search
-       of the str field (the human readable name) */
-    swig_module_info *iter = start;
-    do {
-      register size_t i = 0;
-      for (; i &lt; iter-&gt;size; ++i) {
-	if (iter-&gt;types[i]-&gt;str &amp;&amp; (SWIG_TypeEquiv(iter-&gt;types[i]-&gt;str, name)))
-	  return iter-&gt;types[i];
-      }
-      iter = iter-&gt;next;
-    } while (iter != end);
-  }
-  
-  /* neither found a match */
-  return 0;
-}
-
-/* 
-   Pack binary data into a string
-*/
-SWIGRUNTIME char *
-SWIG_PackData(char *c, void *ptr, size_t sz) {
-  static const char hex[17] = &quot;0123456789abcdef&quot;;
-  register const unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu =  u + sz;
-  for (; u != eu; ++u) {
-    register unsigned char uu = *u;
-    *(c++) = hex[(uu &amp; 0xf0) &gt;&gt; 4];
-    *(c++) = hex[uu &amp; 0xf];
-  }
-  return c;
-}
-
-/* 
-   Unpack binary data from a string
-*/
-SWIGRUNTIME const char *
-SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
-  register unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu = u + sz;
-  for (; u != eu; ++u) {
-    register char d = *(c++);
-    register unsigned char uu;
-    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
-      uu = ((d - '0') &lt;&lt; 4);
-    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
-      uu = ((d - ('a'-10)) &lt;&lt; 4);
-    else 
-      return (char *) 0;
-    d = *(c++);
-    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
-      uu |= (d - '0');
-    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
-      uu |= (d - ('a'-10));
-    else 
-      return (char *) 0;
-    *u = uu;
-  }
-  return c;
-}
-
-/* 
-   Pack 'void *' into a string buffer.
-*/
-SWIGRUNTIME char *
-SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
-  char *r = buff;
-  if ((2*sizeof(void *) + 2) &gt; bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,&amp;ptr,sizeof(void *));
-  if (strlen(name) + 1 &gt; (bsz - (r - buff))) return 0;
-  strcpy(r,name);
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,&quot;NULL&quot;) == 0) {
-      *ptr = (void *) 0;
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sizeof(void *));
-}
-
-SWIGRUNTIME char *
-SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
-  char *r = buff;
-  size_t lname = (name ? strlen(name) : 0);
-  if ((2*sz + 2 + lname) &gt; bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,ptr,sz);
-  if (lname) {
-    strncpy(r,name,lname+1);
-  } else {
-    *r = 0;
-  }
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,&quot;NULL&quot;) == 0) {
-      memset(ptr,0,sz);
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sz);
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-/*  Errors in SWIG */
-#define  SWIG_UnknownError    	   -1 
-#define  SWIG_IOError        	   -2 
-#define  SWIG_RuntimeError   	   -3 
-#define  SWIG_IndexError     	   -4 
-#define  SWIG_TypeError      	   -5 
-#define  SWIG_DivisionByZero 	   -6 
-#define  SWIG_OverflowError  	   -7 
-#define  SWIG_SyntaxError    	   -8 
-#define  SWIG_ValueError     	   -9 
-#define  SWIG_SystemError    	   -10
-#define  SWIG_AttributeError 	   -11
-#define  SWIG_MemoryError    	   -12 
-#define  SWIG_NullReferenceError   -13
-
-
-
-#include &lt;ruby.h&gt;
-
-/* Remove global macros defined in Ruby's win32.h */
-#ifdef write
-# undef write
-#endif
-#ifdef read
-# undef read
-#endif
-
-
-/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
-#ifndef NUM2LL
-#define NUM2LL(x) NUM2LONG((x))
-#endif
-#ifndef LL2NUM
-#define LL2NUM(x) INT2NUM((long) (x))
-#endif
-#ifndef ULL2NUM
-#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
-#endif
-
-/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
-#ifndef NUM2ULL
-#ifdef HAVE_LONG_LONG
-#define NUM2ULL(x) rb_num2ull((x))
-#else
-#define NUM2ULL(x) NUM2ULONG(x)
-#endif
-#endif
-
-/* RSTRING_LEN, etc are new in Ruby 1.9, but -&gt;ptr and -&gt;len no longer work */
-/* Define these for older versions so we can just write code the new way */
-#ifndef RSTRING_LEN
-# define RSTRING_LEN(x) RSTRING(x)-&gt;len
-#endif
-#ifndef RSTRING_PTR
-# define RSTRING_PTR(x) RSTRING(x)-&gt;ptr
-#endif
-#ifndef RARRAY_LEN
-# define RARRAY_LEN(x) RARRAY(x)-&gt;len
-#endif
-#ifndef RARRAY_PTR
-# define RARRAY_PTR(x) RARRAY(x)-&gt;ptr
-#endif
-
-/*
- * Need to be very careful about how these macros are defined, especially
- * when compiling C++ code or C code with an ANSI C compiler.
- *
- * VALUEFUNC(f) is a macro used to typecast a C function that implements
- * a Ruby method so that it can be passed as an argument to API functions
- * like rb_define_method() and rb_define_singleton_method().
- *
- * VOIDFUNC(f) is a macro used to typecast a C function that implements
- * either the &quot;mark&quot; or &quot;free&quot; stuff for a Ruby Data object, so that it
- * can be passed as an argument to API functions like Data_Wrap_Struct()
- * and Data_Make_Struct().
- */
- 
-#ifdef __cplusplus
-#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
-#    define PROTECTFUNC(f) ((VALUE (*)()) f)
-#    define VALUEFUNC(f) ((VALUE (*)()) f)
-#    define VOIDFUNC(f)  ((void (*)()) f)
-#  else
-#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
-#      define PROTECTFUNC(f) ((VALUE (*)()) f)
-#      define VALUEFUNC(f) ((VALUE (*)()) f)
-#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
-#    else /* These definitions should work for Ruby 1.7+ */
-#      define PROTECTFUNC(f) ((VALUE (*)(VALUE)) f)
-#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
-#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
-#    endif
-#  endif
-#else
-#  define VALUEFUNC(f) (f)
-#  define VOIDFUNC(f) (f)
-#endif
-
-/* Don't use for expressions have side effect */
-#ifndef RB_STRING_VALUE
-#define RB_STRING_VALUE(s) (TYPE(s) == T_STRING ? (s) : (*(volatile VALUE *)&amp;(s) = rb_str_to_str(s)))
-#endif
-#ifndef StringValue
-#define StringValue(s) RB_STRING_VALUE(s)
-#endif
-#ifndef StringValuePtr
-#define StringValuePtr(s) RSTRING_PTR(RB_STRING_VALUE(s))
-#endif
-#ifndef StringValueLen
-#define StringValueLen(s) RSTRING_LEN(RB_STRING_VALUE(s))
-#endif
-#ifndef SafeStringValue
-#define SafeStringValue(v) do {\
-    StringValue(v);\
-    rb_check_safe_str(v);\
-} while (0)
-#endif
-
-#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
-#define rb_define_alloc_func(klass, func) rb_define_singleton_method((klass), &quot;new&quot;, VALUEFUNC((func)), -1)
-#define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), &quot;new&quot;)
-#endif
-
-static VALUE _mSWIG = Qnil;
-
-/* -----------------------------------------------------------------------------
- * error manipulation
- * ----------------------------------------------------------------------------- */
-
-
-/* Define some additional error types */
-#define SWIG_ObjectPreviouslyDeletedError  -100
-
-
-/* Define custom exceptions for errors that do not map to existing Ruby
-   exceptions.  Note this only works for C++ since a global cannot be
-   initialized by a funtion in C.  For C, fallback to rb_eRuntimeError.*/
-
-SWIGINTERN VALUE 
-getNullReferenceError(void) {
-  static int init = 0;
-  static VALUE rb_eNullReferenceError ;
-  if (!init) {
-    init = 1;
-    rb_eNullReferenceError = rb_define_class(&quot;NullReferenceError&quot;, rb_eRuntimeError);
-  }
-  return rb_eNullReferenceError;
-} 
-
-SWIGINTERN VALUE 
-getObjectPreviouslyDeletedError(void) {
-  static int init = 0;
-  static VALUE rb_eObjectPreviouslyDeleted ;
-  if (!init) {
-    init = 1;
-    rb_eObjectPreviouslyDeleted = rb_define_class(&quot;ObjectPreviouslyDeleted&quot;, rb_eRuntimeError);
-  }
-  return rb_eObjectPreviouslyDeleted;
-} 
-
-
-SWIGINTERN VALUE
-SWIG_Ruby_ErrorType(int SWIG_code) {
-  VALUE type;
-  switch (SWIG_code) {
-  case SWIG_MemoryError:
-    type = rb_eNoMemError;
-    break;
-  case SWIG_IOError:
-    type = rb_eIOError;
-    break;
-  case SWIG_RuntimeError:
-    type = rb_eRuntimeError;
-    break;
-  case SWIG_IndexError:
-    type = rb_eIndexError;
-    break;
-  case SWIG_TypeError:
-    type = rb_eTypeError;
-    break;
-  case SWIG_DivisionByZero:
-    type = rb_eZeroDivError;
-    break;
-  case SWIG_OverflowError:
-    type = rb_eRangeError;
-    break;
-  case SWIG_SyntaxError:
-    type = rb_eSyntaxError;
-    break;
-  case SWIG_ValueError:
-    type = rb_eArgError;
-    break;
-  case SWIG_SystemError:
-    type = rb_eFatal;
-    break;
-  case SWIG_AttributeError:
-    type = rb_eRuntimeError;
-    break;
-  case SWIG_NullReferenceError:
-    type = getNullReferenceError();
-    break;
-  case SWIG_ObjectPreviouslyDeletedError:
-    type = getObjectPreviouslyDeletedError();
-    break;
-  case SWIG_UnknownError:
-    type = rb_eRuntimeError;
-    break;
-  default:
-    type = rb_eRuntimeError;
-  }
-  return type;
-}
-
-
-/* This function is called when a user inputs a wrong argument to
-   a method.
- */
-SWIGINTERN 
-const char* Ruby_Format_TypeError( const char* msg,
-				   const char* type, 
-				   const char* name, 
-				   const int argn,
-				   VALUE input )
-{
-  char buf[128];
-  VALUE str;
-  VALUE asStr;
-  if ( msg &amp;&amp; *msg )
-    {
-      str = rb_str_new2(msg);
-    }
-  else
-    {
-      str = rb_str_new(NULL, 0);
-    }
-
-  str = rb_str_cat2( str, &quot;Expected argument &quot; );
-  sprintf( buf, &quot;%d of type &quot;, argn-1 );
-  str = rb_str_cat2( str, buf );
-  str = rb_str_cat2( str, type );
-  str = rb_str_cat2( str, &quot;, but got &quot; );
-  str = rb_str_cat2( str, rb_obj_classname(input) );
-  str = rb_str_cat2( str, &quot; &quot; );
-  asStr = rb_inspect(input);
-  if ( RSTRING_LEN(asStr) &gt; 30 )
-    {
-      str = rb_str_cat( str, StringValuePtr(asStr), 30 );
-      str = rb_str_cat2( str, &quot;...&quot; );
-    }
-  else
-    {
-      str = rb_str_append( str, asStr );
-    }
-
-  if ( name )
-    {
-      str = rb_str_cat2( str, &quot;\n\tin SWIG method '&quot; );
-      str = rb_str_cat2( str, name );
-      str = rb_str_cat2( str, &quot;'&quot; );
-    }
-
-  return StringValuePtr( str );
-}
-
-/* This function is called when an overloaded method fails */
-SWIGINTERN 
-void Ruby_Format_OverloadedError(
-				 const int argc,
-				 const int maxargs,
-				 const char* method, 
-				 const char* prototypes 
-				 )
-{
-  const char* msg = &quot;Wrong # of arguments&quot;;
-  if ( argc &lt;= maxargs ) msg = &quot;Wrong arguments&quot;;
-  rb_raise(rb_eArgError,&quot;%s for overloaded method '%s'.\n&quot;  
-	   &quot;Possible C/C++ prototypes are:\n%s&quot;,
-	   msg, method, prototypes);
-}
-
-/* -----------------------------------------------------------------------------
- * See the LICENSE file for information on copyright, usage and redistribution
- * of SWIG, and the README file for authors - <A HREF="http://www.swig.org/release.html.">http://www.swig.org/release.html.</A>
- *
- * rubytracking.swg
- *
- * This file contains support for tracking mappings from 
- * Ruby objects to C++ objects.  This functionality is needed
- * to implement mark functions for Ruby's mark and sweep
- * garbage collector.
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-/* Ruby 1.8 actually assumes the first case. */
-#if SIZEOF_VOIDP == SIZEOF_LONG
-#  define SWIG2NUM(v) LONG2NUM((unsigned long)v)
-#  define NUM2SWIG(x) (unsigned long)NUM2LONG(x)
-#elif SIZEOF_VOIDP == SIZEOF_LONG_LONG
-#  define SWIG2NUM(v) LL2NUM((unsigned long long)v)
-#  define NUM2SWIG(x) (unsigned long long)NUM2LL(x)
-#else
-#  error sizeof(void*) is not the same as long or long long
-#endif
-
-
-/* Global Ruby hash table to store Trackings from C/C++
-   structs to Ruby Objects. 
-*/
-static VALUE swig_ruby_trackings = Qnil;
-
-/* Global variable that stores a reference to the ruby
-   hash table delete function. */
-static ID swig_ruby_hash_delete;
-
-/* Setup a Ruby hash table to store Trackings */
-SWIGRUNTIME void SWIG_RubyInitializeTrackings(void) {
-  /* Create a ruby hash table to store Trackings from C++ 
-     objects to Ruby objects. */
-
-  /* Try to see if some other .so has already created a 
-     tracking hash table, which we keep hidden in an instance var
-     in the SWIG module.
-     This is done to allow multiple DSOs to share the same
-     tracking table.
-  */
-  ID trackings_id = rb_intern( &quot;@__trackings__&quot; );
-  VALUE verbose = rb_gv_get(&quot;VERBOSE&quot;);
-  rb_gv_set(&quot;VERBOSE&quot;, Qfalse);
-  swig_ruby_trackings = rb_ivar_get( _mSWIG, trackings_id );
-  rb_gv_set(&quot;VERBOSE&quot;, verbose);
-
-  /* No, it hasn't.  Create one ourselves */ 
-  if ( swig_ruby_trackings == Qnil )
-    {
-      swig_ruby_trackings = rb_hash_new();
-      rb_ivar_set( _mSWIG, trackings_id, swig_ruby_trackings );
-    }
-
-  /* Now store a reference to the hash table delete function
-     so that we only have to look it up once.*/
-  swig_ruby_hash_delete = rb_intern(&quot;delete&quot;);
-}
-
-/* Get a Ruby number to reference a pointer */
-SWIGRUNTIME VALUE SWIG_RubyPtrToReference(void* ptr) {
-  /* We cast the pointer to an unsigned long
-     and then store a reference to it using
-     a Ruby number object. */
-
-  /* Convert the pointer to a Ruby number */
-  return SWIG2NUM(ptr);
-}
-
-/* Get a Ruby number to reference an object */
-SWIGRUNTIME VALUE SWIG_RubyObjectToReference(VALUE object) {
-  /* We cast the object to an unsigned long
-     and then store a reference to it using
-     a Ruby number object. */
-
-  /* Convert the Object to a Ruby number */
-  return SWIG2NUM(object);
-}
-
-/* Get a Ruby object from a previously stored reference */
-SWIGRUNTIME VALUE SWIG_RubyReferenceToObject(VALUE reference) {
-  /* The provided Ruby number object is a reference
-     to the Ruby object we want.*/
-
-  /* Convert the Ruby number to a Ruby object */
-  return NUM2SWIG(reference);
-}
-
-/* Add a Tracking from a C/C++ struct to a Ruby object */
-SWIGRUNTIME void SWIG_RubyAddTracking(void* ptr, VALUE object) {
-  /* In a Ruby hash table we store the pointer and
-     the associated Ruby object.  The trick here is
-     that we cannot store the Ruby object directly - if
-     we do then it cannot be garbage collected.  So
-     instead we typecast it as a unsigned long and
-     convert it to a Ruby number object.*/
-
-  /* Get a reference to the pointer as a Ruby number */
-  VALUE key = SWIG_RubyPtrToReference(ptr);
-
-  /* Get a reference to the Ruby object as a Ruby number */
-  VALUE value = SWIG_RubyObjectToReference(object);
-
-  /* Store the mapping to the global hash table. */
-  rb_hash_aset(swig_ruby_trackings, key, value);
-}
-
-/* Get the Ruby object that owns the specified C/C++ struct */
-SWIGRUNTIME VALUE SWIG_RubyInstanceFor(void* ptr) {
-  /* Get a reference to the pointer as a Ruby number */
-  VALUE key = SWIG_RubyPtrToReference(ptr);
-
-  /* Now lookup the value stored in the global hash table */
-  VALUE value = rb_hash_aref(swig_ruby_trackings, key);
-	
-  if (value == Qnil) {
-    /* No object exists - return nil. */
-    return Qnil;
-  }
-  else {
-    /* Convert this value to Ruby object */
-    return SWIG_RubyReferenceToObject(value);
-  }
-}
-
-/* Remove a Tracking from a C/C++ struct to a Ruby object.  It
-   is very important to remove objects once they are destroyed
-   since the same memory address may be reused later to create
-   a new object. */
-SWIGRUNTIME void SWIG_RubyRemoveTracking(void* ptr) {
-  /* Get a reference to the pointer as a Ruby number */
-  VALUE key = SWIG_RubyPtrToReference(ptr);
-
-  /* Delete the object from the hash table by calling Ruby's
-     do this we need to call the Hash.delete method.*/
-  rb_funcall(swig_ruby_trackings, swig_ruby_hash_delete, 1, key);
-}
-
-/* This is a helper method that unlinks a Ruby object from its
-   underlying C++ object.  This is needed if the lifetime of the
-   Ruby object is longer than the C++ object */
-SWIGRUNTIME void SWIG_RubyUnlinkObjects(void* ptr) {
-  VALUE object = SWIG_RubyInstanceFor(ptr);
-
-  if (object != Qnil) {
-    DATA_PTR(object) = 0;
-  }
-}
-
-
-#ifdef __cplusplus
-}
-#endif
-
-/* -----------------------------------------------------------------------------
- * Ruby API portion that goes into the runtime
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-SWIGINTERN VALUE
-SWIG_Ruby_AppendOutput(VALUE target, VALUE o) {
-  if (NIL_P(target)) {
-    target = o;
-  } else {
-    if (TYPE(target) != T_ARRAY) {
-      VALUE o2 = target;
-      target = rb_ary_new();
-      rb_ary_push(target, o2);
-    }
-    rb_ary_push(target, o);
-  }
-  return target;
-}
-
-/* For ruby1.8.4 and earlier. */
-#ifndef RUBY_INIT_STACK
-   RUBY_EXTERN void Init_stack(VALUE* addr);
-#  define RUBY_INIT_STACK \
-   VALUE variable_in_this_stack_frame; \
-   Init_stack(&amp;variable_in_this_stack_frame);
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/* -----------------------------------------------------------------------------
- * See the LICENSE file for information on copyright, usage and redistribution
- * of SWIG, and the README file for authors - <A HREF="http://www.swig.org/release.html.">http://www.swig.org/release.html.</A>
- *
- * rubyrun.swg
- *
- * This file contains the runtime support for Ruby modules
- * and includes code for managing global variables and pointer
- * type checking.
- * ----------------------------------------------------------------------------- */
-
-/* For backward compatibility only */
-#define SWIG_POINTER_EXCEPTION  0
-
-/* for raw pointers */
-#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
-#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, own)
-#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Ruby_NewPointerObj(ptr, type, flags)
-#define SWIG_AcquirePtr(ptr, own)                       SWIG_Ruby_AcquirePtr(ptr, own)
-#define swig_owntype                                    ruby_owntype
-
-/* for raw packed data */
-#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty, flags)
-#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)
-
-/* for class or struct pointers */
-#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
-#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)
-
-/* for C or C++ function pointers */
-#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_ConvertPtr(obj, pptr, type, 0)
-#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_NewPointerObj(ptr, type, 0)
-
-/* for C++ member pointers, ie, member methods */
-#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty)
-#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)
-
-
-/* Runtime API */
-
-#define SWIG_GetModule(clientdata)                      SWIG_Ruby_GetModule()	
-#define SWIG_SetModule(clientdata, pointer) 		SWIG_Ruby_SetModule(pointer)
-
-
-/* Error manipulation */
-
-#define SWIG_ErrorType(code)                            SWIG_Ruby_ErrorType(code)               
-#define SWIG_Error(code, msg)            		rb_raise(SWIG_Ruby_ErrorType(code), msg)
-#define SWIG_fail                        		goto fail				 
-
-
-/* Ruby-specific SWIG API */
-
-#define SWIG_InitRuntime()                              SWIG_Ruby_InitRuntime()              
-#define SWIG_define_class(ty)                        	SWIG_Ruby_define_class(ty)
-#define SWIG_NewClassInstance(value, ty)             	SWIG_Ruby_NewClassInstance(value, ty)
-#define SWIG_MangleStr(value)                        	SWIG_Ruby_MangleStr(value)		  
-#define SWIG_CheckConvert(value, ty)                 	SWIG_Ruby_CheckConvert(value, ty)	  
-
-
-/* -----------------------------------------------------------------------------
- * pointers/data manipulation
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-typedef struct {
-  VALUE klass;
-  VALUE mImpl;
-  void  (*mark)(void *);
-  void  (*destroy)(void *);
-  int trackObjects;
-} swig_class;
-
-
-/* Global pointer used to keep some internal SWIG stuff */
-static VALUE _cSWIG_Pointer = Qnil;
-static VALUE swig_runtime_data_type_pointer = Qnil;
-
-/* Global IDs used to keep some internal SWIG stuff */
-static ID swig_arity_id = 0;
-static ID swig_call_id  = 0;
-
-/*
-  If your swig extension is to be run within an embedded ruby and has
-  director callbacks, you should set -DRUBY_EMBEDDED during compilation.  
-  This will reset ruby's stack frame on each entry point from the main 
-  program the first time a virtual director function is invoked (in a 
-  non-recursive way).
-  If this is not done, you run the risk of Ruby trashing the stack.
-*/
-
-#ifdef RUBY_EMBEDDED
-
-#  define SWIG_INIT_STACK                            \
-      if ( !swig_virtual_calls ) { RUBY_INIT_STACK } \
-      ++swig_virtual_calls;
-#  define SWIG_RELEASE_STACK --swig_virtual_calls;
-#  define Ruby_DirectorTypeMismatchException(x) \
-          rb_raise( rb_eTypeError, x ); return c_result;
-
-      static unsigned int swig_virtual_calls = 0;
-
-#else  /* normal non-embedded extension */
-
-#  define SWIG_INIT_STACK
-#  define SWIG_RELEASE_STACK
-#  define Ruby_DirectorTypeMismatchException(x) \
-          throw Swig::DirectorTypeMismatchException( x );
-
-#endif  /* RUBY_EMBEDDED */
-
-
-SWIGRUNTIME VALUE 
-getExceptionClass(void) {
-  static int init = 0;
-  static VALUE rubyExceptionClass ;
-  if (!init) {
-    init = 1;
-    rubyExceptionClass = rb_const_get(_mSWIG, rb_intern(&quot;Exception&quot;));
-  }
-  return rubyExceptionClass;
-} 
-
-/* This code checks to see if the Ruby object being raised as part
-   of an exception inherits from the Ruby class Exception.  If so,
-   the object is simply returned.  If not, then a new Ruby exception
-   object is created and that will be returned to Ruby.*/
-SWIGRUNTIME VALUE
-SWIG_Ruby_ExceptionType(swig_type_info *desc, VALUE obj) {
-  VALUE exceptionClass = getExceptionClass();
-  if (rb_obj_is_kind_of(obj, exceptionClass)) {
-    return obj;
-  }  else {
-    return rb_exc_new3(rb_eRuntimeError, rb_obj_as_string(obj));
-  }
-}
-
-/* Initialize Ruby runtime support */
-SWIGRUNTIME void
-SWIG_Ruby_InitRuntime(void)
-{
-  if (_mSWIG == Qnil) {
-    _mSWIG = rb_define_module(&quot;SWIG&quot;);
-    swig_call_id  = rb_intern(&quot;call&quot;);
-    swig_arity_id = rb_intern(&quot;arity&quot;);
-  }
-}
-
-/* Define Ruby class for C type */
-SWIGRUNTIME void
-SWIG_Ruby_define_class(swig_type_info *type)
-{
-  VALUE klass;
-  char *klass_name = (char *) malloc(4 + strlen(type-&gt;name) + 1);
-  sprintf(klass_name, &quot;TYPE%s&quot;, type-&gt;name);
-  if (NIL_P(_cSWIG_Pointer)) {
-    _cSWIG_Pointer = rb_define_class_under(_mSWIG, &quot;Pointer&quot;, rb_cObject);
-    rb_undef_method(CLASS_OF(_cSWIG_Pointer), &quot;new&quot;);
-  }
-  klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
-  free((void *) klass_name);
-}
-
-/* Create a new pointer object */
-SWIGRUNTIME VALUE
-SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)
-{
-  int own =  flags &amp; SWIG_POINTER_OWN; 
-  int track;
-  char *klass_name;
-  swig_class *sklass;
-  VALUE klass;
-  VALUE obj;
-  
-  if (!ptr)
-    return Qnil;
-  
-  if (type-&gt;clientdata) {
-    sklass = (swig_class *) type-&gt;clientdata;
-		
-    /* Are we tracking this class and have we already returned this Ruby object? */
-    track = sklass-&gt;trackObjects;
-    if (track) {
-      obj = SWIG_RubyInstanceFor(ptr);
-      
-      /* Check the object's type and make sure it has the correct type.
-        It might not in cases where methods do things like 
-        downcast methods. */
-      if (obj != Qnil) {
-        VALUE value = rb_iv_get(obj, &quot;@__swigtype__&quot;);
-        char* type_name = RSTRING_PTR(value);
-				
-        if (strcmp(type-&gt;name, type_name) == 0) {
-          return obj;
-        }
-      }
-    }
-
-    /* Create a new Ruby object */
-    obj = Data_Wrap_Struct(sklass-&gt;klass, VOIDFUNC(sklass-&gt;mark), 
-			   ( own ? VOIDFUNC(sklass-&gt;destroy) : 
-			     (track ? VOIDFUNC(SWIG_RubyRemoveTracking) : 0 )
-			     ), ptr);
-
-    /* If tracking is on for this class then track this object. */
-    if (track) {
-      SWIG_RubyAddTracking(ptr, obj);
-    }
-  } else {
-    klass_name = (char *) malloc(4 + strlen(type-&gt;name) + 1);
-    sprintf(klass_name, &quot;TYPE%s&quot;, type-&gt;name);
-    klass = rb_const_get(_mSWIG, rb_intern(klass_name));
-    free((void *) klass_name);
-    obj = Data_Wrap_Struct(klass, 0, 0, ptr);
-  }
-  rb_iv_set(obj, &quot;@__swigtype__&quot;, rb_str_new2(type-&gt;name));
-  
-  return obj;
-}
-
-/* Create a new class instance (always owned) */
-SWIGRUNTIME VALUE
-SWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)
-{
-  VALUE obj;
-  swig_class *sklass = (swig_class *) type-&gt;clientdata;
-  obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass-&gt;mark), VOIDFUNC(sklass-&gt;destroy), 0);
-  rb_iv_set(obj, &quot;@__swigtype__&quot;, rb_str_new2(type-&gt;name));
-  return obj;
-}
-
-/* Get type mangle from class name */
-SWIGRUNTIMEINLINE char *
-SWIG_Ruby_MangleStr(VALUE obj)
-{
-  VALUE stype = rb_iv_get(obj, &quot;@__swigtype__&quot;);
-  return StringValuePtr(stype);
-}
-
-/* Acquire a pointer value */
-typedef void (*ruby_owntype)(void*);
-
-SWIGRUNTIME ruby_owntype
-SWIG_Ruby_AcquirePtr(VALUE obj, ruby_owntype own) {
-  if (obj) {
-    ruby_owntype oldown = RDATA(obj)-&gt;dfree;
-    RDATA(obj)-&gt;dfree = own;
-    return oldown;
-  } else {
-    return 0;
-  }
-}
-
-/* Convert a pointer value */
-SWIGRUNTIME int
-SWIG_Ruby_ConvertPtrAndOwn(VALUE obj, void **ptr, swig_type_info *ty, int flags, ruby_owntype *own)
-{
-  char *c;
-  swig_cast_info *tc;
-  void *vptr = 0;
-
-  /* Grab the pointer */
-  if (NIL_P(obj)) {
-    *ptr = 0;
-    return SWIG_OK;
-  } else {
-    if (TYPE(obj) != T_DATA) {
-      return SWIG_ERROR;
-    }
-    Data_Get_Struct(obj, void, vptr);
-  }
-  
-  if (own) *own = RDATA(obj)-&gt;dfree;
-    
-  /* Check to see if the input object is giving up ownership
-     of the underlying C struct or C++ object.  If so then we
-     need to reset the destructor since the Ruby object no 
-     longer owns the underlying C++ object.*/ 
-  if (flags &amp; SWIG_POINTER_DISOWN) {
-    /* Is tracking on for this class? */
-    int track = 0;
-    if (ty &amp;&amp; ty-&gt;clientdata) {
-      swig_class *sklass = (swig_class *) ty-&gt;clientdata;
-      track = sklass-&gt;trackObjects;
-    }
-		
-    if (track) {
-      /* We are tracking objects for this class.  Thus we change the destructor
-       * to SWIG_RubyRemoveTracking.  This allows us to
-       * remove the mapping from the C++ to Ruby object
-       * when the Ruby object is garbage collected.  If we don't
-       * do this, then it is possible we will return a reference 
-       * to a Ruby object that no longer exists thereby crashing Ruby. */
-      RDATA(obj)-&gt;dfree = SWIG_RubyRemoveTracking;
-    } else {    
-      RDATA(obj)-&gt;dfree = 0;
-    }
-  }
-
-  /* Do type-checking if type info was provided */
-  if (ty) {
-    if (ty-&gt;clientdata) {
-      if (rb_obj_is_kind_of(obj, ((swig_class *) (ty-&gt;clientdata))-&gt;klass)) {
-        if (vptr == 0) {
-          /* The object has already been deleted */
-          return SWIG_ObjectPreviouslyDeletedError;
-        }
-        *ptr = vptr;
-        return SWIG_OK;
-      }
-    }
-    if ((c = SWIG_MangleStr(obj)) == NULL) {
-      return SWIG_ERROR;
-    }
-    tc = SWIG_TypeCheck(c, ty);
-    if (!tc) {
-      return SWIG_ERROR;
-    }
-    *ptr = SWIG_TypeCast(tc, vptr);
-  } else {
-    *ptr = vptr;
-  }
-  
-  return SWIG_OK;
-}
-
-/* Check convert */
-SWIGRUNTIMEINLINE int
-SWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)
-{
-  char *c = SWIG_MangleStr(obj);
-  if (!c) return 0;
-  return SWIG_TypeCheck(c,ty) != 0;
-}
-
-SWIGRUNTIME VALUE
-SWIG_Ruby_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
-  char result[1024];
-  char *r = result;
-  if ((2*sz + 1 + strlen(type-&gt;name)) &gt; 1000) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r, ptr, sz);
-  strcpy(r, type-&gt;name);
-  return rb_str_new2(result);
-}
-
-/* Convert a packed value value */
-SWIGRUNTIME int
-SWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty) {
-  swig_cast_info *tc;
-  const char  *c;
-
-  if (TYPE(obj) != T_STRING) goto type_error;
-  c = StringValuePtr(obj);
-  /* Pointer values must start with leading underscore */
-  if (*c != '_') goto type_error;
-  c++;
-  c = SWIG_UnpackData(c, ptr, sz);
-  if (ty) {
-    tc = SWIG_TypeCheck(c, ty);
-    if (!tc) goto type_error;
-  }
-  return SWIG_OK;
-
- type_error:
-  return SWIG_ERROR;
-}
-
-SWIGRUNTIME swig_module_info *
-SWIG_Ruby_GetModule(void)
-{
-  VALUE pointer;
-  swig_module_info *ret = 0;
-  VALUE verbose = rb_gv_get(&quot;VERBOSE&quot;);
-
- /* temporarily disable warnings, since the pointer check causes warnings with 'ruby -w' */
-  rb_gv_set(&quot;VERBOSE&quot;, Qfalse);
-  
-  /* first check if pointer already created */
-  pointer = rb_gv_get(&quot;$swig_runtime_data_type_pointer&quot; SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
-  if (pointer != Qnil) {
-    Data_Get_Struct(pointer, swig_module_info, ret);
-  }
-
-  /* reinstate warnings */
-  rb_gv_set(&quot;VERBOSE&quot;, verbose);
-  return ret;
-}
-
-SWIGRUNTIME void 
-SWIG_Ruby_SetModule(swig_module_info *pointer)
-{
-  /* register a new class */
-  VALUE cl = rb_define_class(&quot;swig_runtime_data&quot;, rb_cObject);
-  /* create and store the structure pointer to a global variable */
-  swig_runtime_data_type_pointer = Data_Wrap_Struct(cl, 0, 0, pointer);
-  rb_define_readonly_variable(&quot;$swig_runtime_data_type_pointer&quot; SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &amp;swig_runtime_data_type_pointer);
-}
-
-/* This function can be used to check whether a proc or method or similarly
-   callable function has been passed.  Usually used in a %typecheck, like:
-
-   %typecheck(c_callback_t, precedence=SWIG_TYPECHECK_POINTER) {
-        $result = SWIG_Ruby_isCallable( $input );
-   }
- */
-SWIGINTERN
-int SWIG_Ruby_isCallable( VALUE proc )
-{
-  if ( rb_respond_to( proc, swig_call_id ) == Qtrue )
-    return 1;
-  return 0;
-}
-
-/* This function can be used to check the arity (number of arguments)
-   a proc or method can take.  Usually used in a %typecheck.
-   Valid arities will be that equal to minimal or those &lt; 0
-   which indicate a variable number of parameters at the end.
- */
-SWIGINTERN
-int SWIG_Ruby_arity( VALUE proc, int minimal )
-{
-  if ( rb_respond_to( proc, swig_arity_id ) == Qtrue )
-    {
-      VALUE num = rb_funcall( proc, swig_arity_id, 0 );
-      int arity = NUM2INT(num);
-      if ( arity &lt; 0 &amp;&amp; (arity+1) &lt; -minimal ) return 1;
-      if ( arity == minimal ) return 1;
-      return 1;
-    }
-  return 0;
-}
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-
-#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
-
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
-
-
-
-/* -------- TYPES TABLE (BEGIN) -------- */
-
-#define SWIGTYPE_p_char swig_types[0]
-static swig_type_info *swig_types[2];
-static swig_module_info swig_module = {swig_types, 1, 0, 0, 0, 0};
-#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&amp;swig_module, &amp;swig_module, name)
-#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&amp;swig_module, &amp;swig_module, name)
-
-/* -------- TYPES TABLE (END) -------- */
-
-#define SWIG_init    Init_antargis
-#define SWIG_name    &quot;Antargis&quot;
-
-static VALUE mAntargis;
-
-#define SWIG_RUBY_THREAD_BEGIN_BLOCK
-#define SWIG_RUBY_THREAD_END_BLOCK
-
-
-#define SWIGVERSION 0x010333 
-#define SWIG_VERSION SWIGVERSION
-
-
-#define SWIG_as_voidptr(a) const_cast&lt; void * &gt;(static_cast&lt; const void * &gt;(a)) 
-#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast&lt; void** &gt;(a)) 
-
-
-#include &lt;stdexcept&gt;
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
-
-static swig_type_info _swigt__p_char = {&quot;_p_char&quot;, &quot;char *&quot;, 0, 0, (void*)0, 0};
-
-static swig_type_info *swig_type_initial[] = {
-  &amp;_swigt__p_char,
-};
-
-static swig_cast_info _swigc__p_char[] = {  {&amp;_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
-
-static swig_cast_info *swig_cast_initial[] = {
-  _swigc__p_char,
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
-
-/* -----------------------------------------------------------------------------
- * Type initialization:
- * This problem is tough by the requirement that no dynamic 
- * memory is used. Also, since swig_type_info structures store pointers to 
- * swig_cast_info structures and swig_cast_info structures store pointers back
- * to swig_type_info structures, we need some lookup code at initialization. 
- * The idea is that swig generates all the structures that are needed. 
- * The runtime then collects these partially filled structures. 
- * The SWIG_InitializeModule function takes these initial arrays out of 
- * swig_module, and does all the lookup, filling in the swig_module.types
- * array with the correct data and linking the correct swig_cast_info
- * structures together.
- *
- * The generated swig_type_info structures are assigned staticly to an initial 
- * array. We just loop through that array, and handle each type individually.
- * First we lookup if this type has been already loaded, and if so, use the
- * loaded structure instead of the generated one. Then we have to fill in the
- * cast linked list. The cast data is initially stored in something like a
- * two-dimensional array. Each row corresponds to a type (there are the same
- * number of rows as there are in the swig_type_initial array). Each entry in
- * a column is one of the swig_cast_info structures for that type.
- * The cast_initial array is actually an array of arrays, because each row has
- * a variable number of columns. So to actually build the cast linked list,
- * we find the array of casts associated with the type, and loop through it 
- * adding the casts to the list. The one last trick we need to do is making
- * sure the type pointer in the swig_cast_info struct is correct.
- *
- * First off, we lookup the cast-&gt;type name to see if it is already loaded. 
- * There are three cases to handle:
- *  1) If the cast-&gt;type has already been loaded AND the type we are adding
- *     casting info to has not been loaded (it is in this module), THEN we
- *     replace the cast-&gt;type pointer with the type pointer that has already
- *     been loaded.
- *  2) If BOTH types (the one we are adding casting info to, and the 
- *     cast-&gt;type) are loaded, THEN the cast info has already been loaded by
- *     the previous module so we just ignore it.
- *  3) Finally, if cast-&gt;type has not already been loaded, then we add that
- *     swig_cast_info to the linked list (because the cast-&gt;type) pointer will
- *     be correct.
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#if 0
-} /* c-mode */
-#endif
-#endif
-
-#if 0
-#define SWIGRUNTIME_DEBUG
-#endif
-
-
-SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
-  size_t i;
-  swig_module_info *module_head, *iter;
-  int found;
-
-  clientdata = clientdata;
-
-  /* check to see if the circular list has been setup, if not, set it up */
-  if (swig_module.next==0) {
-    /* Initialize the swig_module */
-    swig_module.type_initial = swig_type_initial;
-    swig_module.cast_initial = swig_cast_initial;
-    swig_module.next = &amp;swig_module;
-  }
-
-  /* Try and load any already created modules */
-  module_head = SWIG_GetModule(clientdata);
-  if (!module_head) {
-    /* This is the first module loaded for this interpreter */
-    /* so set the swig module into the interpreter */
-    SWIG_SetModule(clientdata, &amp;swig_module);
-    module_head = &amp;swig_module;
-  } else {
-    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
-    found=0;
-    iter=module_head;
-    do {
-      if (iter==&amp;swig_module) {
-        found=1;
-        break;
-      }
-      iter=iter-&gt;next;
-    } while (iter!= module_head);
-
-    /* if the is found in the list, then all is done and we may leave */
-    if (found) return;
-    /* otherwise we must add out module into the list */
-    swig_module.next = module_head-&gt;next;
-    module_head-&gt;next = &amp;swig_module;
-  }
-
-  /* Now work on filling in swig_module.types */
-#ifdef SWIGRUNTIME_DEBUG
-  printf(&quot;SWIG_InitializeModule: size %d\n&quot;, swig_module.size);
-#endif
-  for (i = 0; i &lt; swig_module.size; ++i) {
-    swig_type_info *type = 0;
-    swig_type_info *ret;
-    swig_cast_info *cast;
-  
-#ifdef SWIGRUNTIME_DEBUG
-    printf(&quot;SWIG_InitializeModule: type %d %s\n&quot;, i, swig_module.type_initial[i]-&gt;name);
-#endif
-
-    /* if there is another module already loaded */
-    if (swig_module.next != &amp;swig_module) {
-      type = SWIG_MangledTypeQueryModule(swig_module.next, &amp;swig_module, swig_module.type_initial[i]-&gt;name);
-    }
-    if (type) {
-      /* Overwrite clientdata field */
-#ifdef SWIGRUNTIME_DEBUG
-      printf(&quot;SWIG_InitializeModule: found type %s\n&quot;, type-&gt;name);
-#endif
-      if (swig_module.type_initial[i]-&gt;clientdata) {
-	type-&gt;clientdata = swig_module.type_initial[i]-&gt;clientdata;
-#ifdef SWIGRUNTIME_DEBUG
-      printf(&quot;SWIG_InitializeModule: found and overwrite type %s \n&quot;, type-&gt;name);
-#endif
-      }
-    } else {
-      type = swig_module.type_initial[i];
-    }
-
-    /* Insert casting types */
-    cast = swig_module.cast_initial[i];
-    while (cast-&gt;type) {
-    
-      /* Don't need to add information already in the list */
-      ret = 0;
-#ifdef SWIGRUNTIME_DEBUG
-      printf(&quot;SWIG_InitializeModule: look cast %s\n&quot;, cast-&gt;type-&gt;name);
-#endif
-      if (swig_module.next != &amp;swig_module) {
-        ret = SWIG_MangledTypeQueryModule(swig_module.next, &amp;swig_module, cast-&gt;type-&gt;name);
-#ifdef SWIGRUNTIME_DEBUG
-	if (ret) printf(&quot;SWIG_InitializeModule: found cast %s\n&quot;, ret-&gt;name);
-#endif
-      }
-      if (ret) {
-	if (type == swig_module.type_initial[i]) {
-#ifdef SWIGRUNTIME_DEBUG
-	  printf(&quot;SWIG_InitializeModule: skip old type %s\n&quot;, ret-&gt;name);
-#endif
-	  cast-&gt;type = ret;
-	  ret = 0;
-	} else {
-	  /* Check for casting already in the list */
-	  swig_cast_info *ocast = SWIG_TypeCheck(ret-&gt;name, type);
-#ifdef SWIGRUNTIME_DEBUG
-	  if (ocast) printf(&quot;SWIG_InitializeModule: skip old cast %s\n&quot;, ret-&gt;name);
-#endif
-	  if (!ocast) ret = 0;
-	}
-      }
-
-      if (!ret) {
-#ifdef SWIGRUNTIME_DEBUG
-	printf(&quot;SWIG_InitializeModule: adding cast %s\n&quot;, cast-&gt;type-&gt;name);
-#endif
-        if (type-&gt;cast) {
-          type-&gt;cast-&gt;prev = cast;
-          cast-&gt;next = type-&gt;cast;
-        }
-        type-&gt;cast = cast;
-      }
-      cast++;
-    }
-    /* Set entry in modules-&gt;types array equal to the type */
-    swig_module.types[i] = type;
-  }
-  swig_module.types[i] = 0;
-
-#ifdef SWIGRUNTIME_DEBUG
-  printf(&quot;**** SWIG_InitializeModule: Cast List ******\n&quot;);
-  for (i = 0; i &lt; swig_module.size; ++i) {
-    int j = 0;
-    swig_cast_info *cast = swig_module.cast_initial[i];
-    printf(&quot;SWIG_InitializeModule: type %d %s\n&quot;, i, swig_module.type_initial[i]-&gt;name);
-    while (cast-&gt;type) {
-      printf(&quot;SWIG_InitializeModule: cast type %s\n&quot;, cast-&gt;type-&gt;name);
-      cast++;
-      ++j;
-    }
-  printf(&quot;---- Total casts: %d\n&quot;,j);
-  }
-  printf(&quot;**** SWIG_InitializeModule: Cast List ******\n&quot;);
-#endif
-}
-
-/* This function will propagate the clientdata field of type to
-* any new swig_type_info structures that have been added into the list
-* of equivalent types.  It is like calling
-* SWIG_TypeClientData(type, clientdata) a second time.
-*/
-SWIGRUNTIME void
-SWIG_PropagateClientData(void) {
-  size_t i;
-  swig_cast_info *equiv;
-  static int init_run = 0;
-
-  if (init_run) return;
-  init_run = 1;
-
-  for (i = 0; i &lt; swig_module.size; i++) {
-    if (swig_module.types[i]-&gt;clientdata) {
-      equiv = swig_module.types[i]-&gt;cast;
-      while (equiv) {
-        if (!equiv-&gt;converter) {
-          if (equiv-&gt;type &amp;&amp; !equiv-&gt;type-&gt;clientdata)
-            SWIG_TypeClientData(equiv-&gt;type, swig_module.types[i]-&gt;clientdata);
-        }
-        equiv = equiv-&gt;next;
-      }
-    }
-  }
-}
-
-#ifdef __cplusplus
-#if 0
-{ /* c-mode */
-#endif
-}
-#endif
-
-/*
-
-*/
-#ifdef __cplusplus
-extern &quot;C&quot;
-#endif
-SWIGEXPORT void Init_antargis(void) {
-  size_t i;
-  
-  SWIG_InitRuntime();
-  mAntargis = rb_define_module(&quot;Antargis&quot;);
-  
-  SWIG_InitializeModule(0);
-  for (i = 0; i &lt; swig_module.size; i++) {
-    SWIG_define_class(swig_module.types[i]);
-  }
-  
-  SWIG_RubyInitializeTrackings();
-}
-

Modified: antargis/trunk/rookey/tasks.rb
===================================================================
--- antargis/trunk/rookey/tasks.rb	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/tasks.rb	2008-03-28 16:59:36 UTC (rev 1237)
@@ -36,7 +36,7 @@
     }
     file=target+&quot;_interface.i&quot;
     templates=[source].flatten.select{|f|f=~/i$/}
-    source=source.grep(/INCLUDE_SWIG/)
+    source=source.grep(/INCLUDE_SWIG/)+[getAGRubyObjectHeader]
     
     rule file=&gt;source do
 	    parser=CppHierarchyParser.new([source].flatten.select{|f|f=~/h$/})
@@ -71,8 +71,14 @@
 	    swigCompiler.swig(t,interface)
 	  end
 	  CLEAN &lt;&lt; output &lt;&lt; output.gsub(/\.cc?/,&quot;.h&quot;)
-	  output
+	  [output,getAGRubyObjectSource]
 	end
+  def Rookey.getAGRubyObjectSource
+    File.join(File.split(__FILE__)[0],&quot;cpp&quot;,&quot;ag_rubyobj.cc&quot;)
+  end
+  def Rookey.getAGRubyObjectHeader
+    File.join(File.split(__FILE__)[0],&quot;cpp&quot;,&quot;ag_rubyobj.h&quot;)
+  end
 	
 	def Rookey.compile(files,config=nil)
 	  files=[files].flatten

Modified: antargis/trunk/rookey/tools.rb
===================================================================
--- antargis/trunk/rookey/tools.rb	2008-03-26 19:30:10 UTC (rev 1236)
+++ antargis/trunk/rookey/tools.rb	2008-03-28 16:59:36 UTC (rev 1237)
@@ -19,24 +19,19 @@
 end
 
 module Rookey
-  module Tools
-    # creates a directory *dir* and parent-dirs if they don't exist
-		def Tools.mkdir(dir)
-		  return if File.exists?(dir)
-		  pp dir
-		  begin
-		    puts &quot;making #{dir}&quot;
-		    Dir.mkdir(dir.to_s)
-		    puts &quot;ok&quot;
-		  rescue
-		    p=File.split(dir)[0]
-		    return if p==dir
-		    Rookey.mkdir(p)
-		    begin
-		      Dir.mkdir(dir)
-		    rescue
-		    end
-		  end
-		end
-  end
+  # creates a directory *dir* and parent-dirs if they don't exist
+  def Rookey.mkdir(dir)
+	  return if File.exists?(dir)
+	  begin
+	    Dir.mkdir(dir.to_s)
+	  rescue
+	    p=File.split(dir)[0]
+	    return if p==dir
+	    Rookey.mkdir(p)
+	    begin
+	      Dir.mkdir(dir)
+	    rescue
+	    end
+	  end
+	end
 end
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000192.html">[Antargis-svn] r1236 - in antargis/trunk: . ext/3dengine ext/basic ext/game ext/gui ext/math ext/video main rookey rookey/configs rookey/docs rookey/docs/ruby rookey/docs/ruby/classes rookey/docs/ruby/classes/Array.src rookey/docs/ruby/classes/Class.src rookey/docs/ruby/classes/Rookey rookey/docs/ruby/classes/Rookey/CcacheConfig.src rookey/docs/ruby/classes/Rookey/Compiler.src rookey/docs/ruby/classes/Rookey/Config.src rookey/docs/ruby/classes/Rookey/Configurator.src rookey/docs/ruby/classes/Rookey/CppHierarchyParser.src rookey/docs/ruby/classes/Rookey/DebugConfig.src rookey/docs/ruby/classes/Rookey/GLConfig.src rookey/docs/ruby/classes/Rookey/RubyConfig.src rookey/docs/ruby/classes/Rookey/SDLConfig.src rookey/docs/ruby/classes/Rookey/Swig.src rookey/docs/ruby/classes/Rookey/SwigConfig.src rookey/docs/ruby/classes/Rookey/SwigInterfaceBuilder.src rookey/docs/ruby/classes/Rookey/Tools.src rookey/docs/ruby/classes/Rookey.src rookey/docs/ruby/files rookey/docs/ruby/files/configs rooke! y/spec ruby
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#193">[ date ]</a>
              <a href="thread.html#193">[ thread ]</a>
              <a href="subject.html#193">[ subject ]</a>
              <a href="author.html#193">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/antargis-svn">More information about the Antargis-svn
mailing list</a><br>
</body></html>
