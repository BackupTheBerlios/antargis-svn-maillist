From davidkamphausen at mail.berlios.de  Wed Aug 15 19:33:19 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Wed, 15 Aug 2007 19:33:19 +0200
Subject: [Antargis-svn] r1156 - in antargis/branches/rant: . build
	ext/3dengine ext/basic ext/game ext/gui ext/math ext/ruby
	ext/sound ext/video ruby ruby/entities ruby/tests ruby/tests/path
Message-ID: <200708151733.l7FHXJsu025590@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-08-15 19:33:15 +0200 (Wed, 15 Aug 2007)
New Revision: 1156

Added:
   antargis/branches/rant/ext/basic/ag_rtools.cc
   antargis/branches/rant/ext/basic/ag_rtools.h
   antargis/branches/rant/ruby/tests/3d_engine/
Removed:
   antargis/branches/rant/ext/ruby/ag_rtools.cc
   antargis/branches/rant/ext/ruby/ag_rtools.h
Modified:
   antargis/branches/rant/ChangeLog
   antargis/branches/rant/Rantfile
   antargis/branches/rant/build/base_tools.rb
   antargis/branches/rant/build/create_interface.rb
   antargis/branches/rant/build/platform.rb
   antargis/branches/rant/configure
   antargis/branches/rant/ext/3dengine/headers.hh
   antargis/branches/rant/ext/basic/ag_serial.cc
   antargis/branches/rant/ext/basic/ag_serial.h
   antargis/branches/rant/ext/basic/headers.hh
   antargis/branches/rant/ext/game/headers.hh
   antargis/branches/rant/ext/game/height_map.cc
   antargis/branches/rant/ext/game/height_map.h
   antargis/branches/rant/ext/game/heuristic.cc
   antargis/branches/rant/ext/game/heuristic.h
   antargis/branches/rant/ext/game/path.cc
   antargis/branches/rant/ext/game/path.h
   antargis/branches/rant/ext/game/path_data_v3.cc
   antargis/branches/rant/ext/game/path_data_v3.h
   antargis/branches/rant/ext/game/path_v2.cc
   antargis/branches/rant/ext/game/path_vector_sort.h
   antargis/branches/rant/ext/game/path_weighter.cc
   antargis/branches/rant/ext/game/path_weighter.h
   antargis/branches/rant/ext/game/templates.i
   antargis/branches/rant/ext/gui/headers.hh
   antargis/branches/rant/ext/math/ag_serial_vec.cc
   antargis/branches/rant/ext/math/ag_serial_vec.h
   antargis/branches/rant/ext/math/headers.hh
   antargis/branches/rant/ext/ruby/headers.hh
   antargis/branches/rant/ext/sound/headers.hh
   antargis/branches/rant/ext/video/headers.hh
   antargis/branches/rant/ruby/ant_hljobs.rb
   antargis/branches/rant/ruby/entities/ant_deco.rb
   antargis/branches/rant/ruby/entities/ant_hero.rb
   antargis/branches/rant/ruby/entities/ant_man.rb
   antargis/branches/rant/ruby/map.rb
   antargis/branches/rant/ruby/tests/path/fields_test2.rb
Log:
* many changes concerning path-finding


Modified: antargis/branches/rant/ChangeLog
===================================================================
--- antargis/branches/rant/ChangeLog	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ChangeLog	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,3 +1,18 @@
+
+
+
+0.2.1.2 (2007-08-09)
+	- increased performance on heuristic-computation
+	- included saving and thus caching of heuristic
+
+0.2.1.1 (about 2007-07)
+	- refactoring
+	- switched over to rant (from rake) as a build-system
+	- it's now possible to compile BoA on Windows (for Windows), that's more comfortable, because you test it there
+
+
+Very old changes:
+
 0.2
 	- major refactoring and documentation effort
 	- many bugs fixed

Modified: antargis/branches/rant/Rantfile
===================================================================
--- antargis/branches/rant/Rantfile	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/Rantfile	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,11 +1,11 @@
 import "md5"                         # md5 is needed for automatic checksum-check for changes in files
 import "autoclean"                    # autoclean includes the a simple facility for a clean-make-target
-import "package/tgz"                  # support for packaging (tar.gz, zip)
-import "package/zip"                  # support for packaging (tar.gz, zip)
+import "package/tgz"                  # support for packaging (tar.gz, zip)
+import "package/zip"                  # support for packaging (tar.gz, zip)
 import "rubydoc"
 import "c/dependencies"
 
-#gen C::Dependencies
+#gen C::Dependencies, :sources=> (sys["**/*.cc"]+sys["**/*.c"]+sys["**/*.h"]).select{|f|not (f=~/packages/ or f=~/build/)}
 
 require 'build/base_tools.rb'
 
@@ -37,7 +37,7 @@
 	["ext/video",["ext/external","ext/basic","ext/math"]+glLibs+allSDLlibs],
 	["ext/gui",["ext/basic","ext/math","ext/video"]+allSDLlibs],
 	["ext/sound",["ext/basic","-lSDL_mixer"]+sdlLibs],
-	["ext/3dengine",["ext/external","ext/basic","ext/math","ext/video"]+glLibs+sdlLibs],
+	["ext/3dengine",["ext/external","ext/basic","ext/math","ext/video","ext/gui"]+glLibs+sdlLibs],
 	["ext/game",["ext/basic","ext/math","ext/video","ext/gui","ext/3dengine"]+glLibs+sdlLibs],
 ]
 
@@ -52,7 +52,7 @@
 rubyIncDir=getConfig("archdir")
     
 # gather include-directories (separately from other cflags, so they can be used for swig later on
-var :INCLUDES => sourceDirs+[rubyIncDir,"."]
+var :INCLUDES => sourceDirs+[rubyIncDir,"."]
 
 var :INCLUDESTR => var[:INCLUDES].collect{|d|"-I#{d}"}.join(" ")+" "+externalIncludes    # build include-string (-I...)
 
@@ -105,14 +105,14 @@
 	}
 	task target => tsources do |t|
 		# build command
-		sources=t.prerequisites
+		sources=t.prerequisites
         
 		if ENV['WINDIR']
-                extlibs=extlibs.collect{|s|s.gsub(/.*lib(.*)\.so/,'-l\1')}
-                
+                extlibs=extlibs.collect{|s|s.gsub(/.*lib(.*)\.so/,'-l\1')}
                 
+                
 				#puts "SOURCES #{sources}"
-				#puts "EXTLIBS #{extlibs}"
+				#puts "EXTLIBS #{extlibs}"
 				sources=sources.select{|f|not f=~/\.so/}
 		end
 		cmd=makeCommand("LINK_SHARED",sys.expand_path(U2W(t.name)), (sources.collect{|f|sys.expand_path(f)}+extlibs).join(" "))
@@ -142,11 +142,11 @@
 	tsources+=[dir+"/"+libname+"swig.cc"]
 	tsources.collect!{|f|f.sub_ext("oo")}
 	#tsources+=["ext/lib"+makeLibName(dir)+".so"]
-	extlibs=[] #["-l"+makeLibName(dir)]
-    
+	extlibs=[] #["-l"+makeLibName(dir)]
+    
     if isWindows
-	    extlibs+=["-l"+makeLibName(dir)]
-    end
+	    extlibs+=["-l"+makeLibName(dir)]
+    end
     
 	dep.each{|d|
 		if d[0..0]!="-" and d!="ext/external"
@@ -158,8 +158,8 @@
 				extlibs+=["ext/lib"+makeLibName(dir)+".so"]
 			end
 		end
-	}
-    
+	}
+    
     puts "EXTLIBS:#{extlibs}"
     #tsources+=rubyLib
     
@@ -205,18 +205,18 @@
 	dir=getDirUnix(target)
     #puts "TARGET:#{target} DIR:#{dir}"
 	name=makeLibName(dir)
-	a=[target.sub(name+"swig.cc","interface.i")]+sys["build/*.i"]+importsForInterface(target).split(":") 
-    puts "A: #{a}"
-    puts "name: #{name}"
-    puts "dir: #{dir}"
-    puts "target: #{target}"
+	a=[target.sub(name+"swig.cc","interface.i")]+sys["build/*.i"]+importsForInterface(target).split(":") 
+    puts "A: #{a}"
+    puts "name: #{name}"
+    puts "dir: #{dir}"
+    puts "target: #{target}"
     a
 }
 
-gen Rule, /^.*swig.(cc|h)$/ => swigSrc do |t|
-
-    puts "SOURCE #{t.source} #{t.name}"
+gen Rule, /^.*swig.(cc|h)$/ => swigSrc do |t|
 
+    puts "SOURCE #{t.source} #{t.name}"
+
 	cmd=makeCommand("SWIG_CALL",sys.expand_path(t.name),"-DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR} #{sys.expand_path(t.source)}".gsub("/",Dir.separator))
 	sys cmd
 	puts
@@ -265,7 +265,7 @@
 # make rant-stand-alone
 #
 task :rantStandAlone =>[] do |t|
-	cmd="rant-import --auto build.rb"
+	cmd="rant-import --force --auto build.rb"
     sys cmd
 end
 #
@@ -286,12 +286,12 @@
 files=(sys["build/**/*"]+sys["ext/**/*"]+sys["ruby/**/*.rb"]+sys["data/**/*"]+sys["*"]).select{|f|not (f=~/~/ or f=~/.xcf/ or f=~/swig/ or f=~/packages/ or f=~/\.o/ or f=~/\.so/)}
 #puts files
 #exit
-
+
 if isWindows
-    sourcePkg=gen Package::Zip, "packages","antargis-source-"+extendCommand($config,"version"), :files => files
-else
-    sourcePkg=gen Package::Tgz, "packages","antargis-source-"+extendCommand($config,"version"), :extension => ".tar.gz", :files => files
-end
+    sourcePkg=gen Package::Zip, "packages","antargis-source-"+extendCommand($config,"version"), :files => files
+else
+    sourcePkg=gen Package::Tgz, "packages","antargis-source-"+extendCommand($config,"version"), :extension => ".tar.gz", :files => files
+end
 
 task :dist=>[:swigSources,:rantStandAlone,sourcePkg.path] do |t|
 end
@@ -300,12 +300,12 @@
 
 ###########################################
 # build source-distribution
-#
+#
 if isWindows
-    binpkg=gen Package::Zip, "packages","antargis-"+extendCommand($config,"system")+"-"+extendCommand($config,"version"), :files => (sys["ext/*.so"]+sys["ruby/**/*.rb"]+sys["data/**/*"]+sys["*"]).select{|f|not (f=~/~/ or f=~/.xcf/)}
-else
-    binpkg=gen Package::Tgz, "packages","antargis-"+extendCommand($config,"system")+"-"+extendCommand($config,"version"), :extension => ".tar.gz", :files => (sys["ext/*.so"]+sys["ruby/**/*.rb"]+sys["data/**/*"]+sys["*"]).select{|f|not (f=~/~/ or f=~/.xcf/)}
-end
+    binpkg=gen Package::Zip, "packages","antargis-"+extendCommand($config,"system")+"-"+extendCommand($config,"version"), :files => (sys["ext/*.so"]+sys["ruby/**/*.rb"]+sys["data/**/*"]+sys["*"]).select{|f|not (f=~/~/ or f=~/.xcf/)}
+else
+    binpkg=gen Package::Tgz, "packages","antargis-"+extendCommand($config,"system")+"-"+extendCommand($config,"version"), :extension => ".tar.gz", :files => (sys["ext/*.so"]+sys["ruby/**/*.rb"]+sys["data/**/*"]+sys["*"]).select{|f|not (f=~/~/ or f=~/.xcf/)}
+end
 
 task :bindist=>[:extensions,binpkg.path] do |t| #"packages/antargis-"+extendCommand($config,"version")+".tar.gz"] do |t|
 end

Modified: antargis/branches/rant/build/base_tools.rb
===================================================================
--- antargis/branches/rant/build/base_tools.rb	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/build/base_tools.rb	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,6 +1,7 @@
 #require 'mkmf'                        # mkmf holds information about the compiler-settings while compiling ruby (by the maintainer)
 
 require 'build/platform.rb'
+require 'config.rb'                   # include build-options
 
 def getDir(path)
 	# FIXME: check for windows
@@ -55,17 +56,46 @@
 	(not ENV['WINDIR'].nil?)
 end
 
+module Cmd
+	def Cmd.sys(cmd)
+		puts cmd
+		#as=`#{cmd}`
+		
+		#puts "-#{cmd}-",cmd.class
+		res=system(cmd)
+		#puts a
+		raise 1 unless res
+		
+	end
+end
 
+
 module Build
+	include Cmd
 
-	def compile(cFile)
+	def Build.includes
+		includes=Dir.glob(File.join("ext","**","*.h")).collect{|f|f.sub(/\/[^\/]*$/,"")}.uniq+[getConfig("archdir")]
+		includes.collect{|i|"-I#{i}"}.join(" ")
 	end
+
+	def Build.cflags
+		includes+" "+getConfig("CFLAGS")+" "+$config["CFLAGS"]
+	end
+
+	def Build.compile(cFile)
+		cObj=cFileToObj(cFile)
+		cmd=makeCommand("CXX_CALL",cObj,cflags+" "+cFile)
+		Cmd.sys cmd
+	end
 	
-	def link(objs,libs)
+	def Build.linkToLib(target,objs,libs)
+		cmd=makeCommand("LINK_SHARED",target,(objs+libs).join(" "))
+		Cmd.sys cmd
 	end
-end
 
-module Testing
-	def runCTest(cFile)
+	def Build.cFileToObj(filename)
+		filename.sub(/\.cc$/,".oo").sub(/\.c$/,".o")
 	end
+
 end
+

Modified: antargis/branches/rant/build/create_interface.rb
===================================================================
--- antargis/branches/rant/build/create_interface.rb	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/build/create_interface.rb	2007-08-15 17:33:15 UTC (rev 1156)
@@ -26,7 +26,7 @@
 
 
 require 'build/interface_template.rb'
-require 'build/base_tools.rb'
+require 'build/base_tools.rb'
 require 'find.rb'
 
 class MyInput
@@ -76,10 +76,10 @@
 	end
 end
 
-def getFiles(dir)
+def getFiles(dir)
     pattern=dir+"/"+"*.h"
-	files=Dir[pattern].select{|f|not f=~/swig.h/} #-[dir+Dir.separator+"swig.h"]
-    #puts "getFiles #{dir}",pattern,"--",files,"----"
+	files=Dir[pattern].select{|f|not f=~/swig.h/} #-[dir+Dir.separator+"swig.h"]
+    #puts "getFiles #{dir}",pattern,"--",files,"----"
     files  
 end
 
@@ -100,7 +100,7 @@
 
 	attr_reader :deriveList
 
-	def initialize(files,allfiles)
+	def initialize(files,allfiles)
         #puts "ParsedClasses:init()",files,"--",allfiles,"-----"
 		@rubyClasses=[]
 		@files=files.collect{|f|f.gsub(/.*\/ext\//,"ext/")}
@@ -117,15 +117,17 @@
 		@allClasses=[]
 
 		allfiles.each{|fn|
-			g=File.open(fn)
+			file=File.open(fn)
 			cn=""
-			g.each{|a|
+			content=file.read.gsub(/\/\*([^*]|\*[^\/])*\*\//,"") # /*...*/ delete comments - FIXME: // comments will be ignored!!!
+
+			content.split("\n").each{|a|
 				abak=a
 				a.gsub!("AGEXPORT","")
 				a.gsub!("EXPORT","")
 				
-				if a =~ /^class.*/ then
-					cn=a.gsub("class ","").gsub(/:.*/,"").gsub("\n","").gsub(" ","")
+				if a =~ /^ *class.*/ then
+					cn=a.gsub(/ *class /,"").gsub(/:.*/,"").gsub("\n","").gsub(" ","")
 					@allClasses << cn.gsub(";","")
 					if cn=~/^[A-Z].*/
 						if a=~ /.*public.*/ then
@@ -234,19 +236,19 @@
 
 	# in correct order
 	def getFileList
-
+
 		# build file list out of class-order (files may appear several times)
 		files=[]
 		l=@levels.values.max
 		(0..l).each{|i|
-            puts "LEVEL #{i}"
-			@levels.each{|n,level|
-				if level==i and @class2File[n]
+            puts "LEVEL #{i}"
+			@levels.each{|n,level|
+				if level==i and @class2File[n]
                     puts n
 					files << @class2File[n]
-				end
+				end
 			}
-            puts "----"
+            puts "----"
 		}
 
 		# add files of classes with unknown level
@@ -254,21 +256,21 @@
 			if @levels[c].nil? and @class2File[c]
 				files << @class2File[c]
 			end
-		}
-        puts "myfiles:", at myfiles,"---"
+		}
+        puts "myfiles:", at myfiles,"---"
         
         puts "FILES:",files,"---"
 		files=files.select{|f|@myfiles.member?(f)} # select only "my" files - those included in this directory
-        puts "FILES after select:",files,"---"
+        puts "FILES after select:",files,"---"
 		addfiles=@files-files
 		files+=addfiles                            # add files that are in other directories
-        puts "FILES (add:",files,"---"
+        puts "FILES (add:",files,"---"
 
 		# unique the array
 		if files.length>0
 			files.uniq!
-		end
-        puts "FILES (uniq):",files,"---"
+		end
+        puts "FILES (uniq):",files,"---"
 
 		files
 	end
@@ -287,9 +289,9 @@
 
 
 def generateInterfaceFile(myInput,files,addfiles)
-	filename=myInput.interfaceName
+	filename=myInput.interfaceName
 	interfaceI=File.open(filename,"w")
-	#puts filename
+	#puts filename
     #raise 1
 	interfaceI.puts interface_template(myInput.moduleName,files,myInput.swigInput,addfiles,myInput.outputDir)
 	
@@ -306,36 +308,36 @@
 	headersH.puts "#endif"
 	headersH.puts "#endif"
 	headersH.close
-end
-
-def findFilesWith(str)
-    files=[]
-    Find.find("ext") {|file|files << file}
-    files=files.select{|f|f=~/\.h$/}.select{|f|not f=~/swig.h/}.select{|f|File.open(f).read=~/#{str}/}
-    #dirs=findDirsRecursively(".")
-    #puts "findFilesWith #{str}:"
-    #puts files
-    #puts "---"
-    #exit
-    files
-    #Dir["*/*"].collect{|f|f.gsub(/\/.*/,"")}.uniq
 end
 
+def findFilesWith(str)
+    files=[]
+    Find.find("ext") {|file|files << file}
+    files=files.select{|f|f=~/\.h$/}.select{|f|not f=~/swig.h/}.select{|f|File.open(f).read=~/#{str}/}
+    #dirs=findDirsRecursively(".")
+    #puts "findFilesWith #{str}:"
+    #puts files
+    #puts "---"
+    #exit
+    files
+    #Dir["*/*"].collect{|f|f.gsub(/\/.*/,"")}.uniq
+end
 
+
 myInput=MyInput.new
 
 files=getSwigInterfaceFiles(getFiles(myInput.outputDir))
-
-
-cfiles=findFilesWith("INCLUDE_SWIG")
-#exit
 
-#parsedClasses=ParsedClasses.new(files,`find $(pwd) -name "*.h"|grep -v swig`.split("\n"))
-parsedClasses=ParsedClasses.new(files,cfiles)
+
+cfiles=findFilesWith("INCLUDE_SWIG")
+#exit
+
+#parsedClasses=ParsedClasses.new(files,`find $(pwd) -name "*.h"|grep -v swig`.split("\n"))
+parsedClasses=ParsedClasses.new(files,cfiles)
 files=parsedClasses.getFileList
 
 addfiles=[]
-myInput.swigInput.each{|inDir|
+myInput.swigInput.each{|inDir|
     puts "inDir #{inDir}"
 	pattern=getDirUnix(inDir)+"/*.h"
 	puts "PATTERN:",pattern,"!!!!"
@@ -404,11 +406,11 @@
 myClasses=parsedClasses.getMyRubyClasses
 
 file.puts <<EOT
-%{
-
-#undef write
-#undef read
+%{
 
+#undef write
+#undef read
+
 // cast-function map
 // it contains the mapping from parent-classes=>dyn-cast-functions to child-classes
 #include <string>

Modified: antargis/branches/rant/build/platform.rb
===================================================================
--- antargis/branches/rant/build/platform.rb	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/build/platform.rb	2007-08-15 17:33:15 UTC (rev 1156)
@@ -15,4 +15,5 @@
     
 else
     require 'mkmf'
+#CONFIG={"archdir"=>Dir.pwd+"/build/win32/usr/lib","CFLAGS"=>""}
 end
\ No newline at end of file

Modified: antargis/branches/rant/configure
===================================================================
--- antargis/branches/rant/configure	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/configure	2007-08-15 17:33:15 UTC (rev 1156)
@@ -2,7 +2,7 @@
 
 require 'build/configure.rb'
 
-version="0.2.1.1"
+version="0.2.1.2"
 
 puts <<EOT
 Battle of Antargis - Configuration

Modified: antargis/branches/rant/ext/3dengine/headers.hh
===================================================================
--- antargis/branches/rant/ext/3dengine/headers.hh	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/3dengine/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,60 +1,91 @@
-#ifndef __ANTARGIS_H__
-#define __ANTARGIS_H__
-#include "ext/basic/ag_config.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_geometry.h"
-#include "ext/basic/ag_main.h"
-#include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_rubyobj.h"
-#include "ext/basic/ag_serial.h"
-#include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_string_utf8.h"
-#include "ext/basic/ag_utf8.h"
-#include "ext/basic/ag_video_base.h"
-#include "ext/basic/ag_xml.h"
-#include "ext/math/ag_algebra.h"
-#include "ext/math/ag_rand.h"
-#include "ext/math/ant_frustum.h"
-#include "ext/video/ag_clip.h"
-#include "ext/video/ag_color.h"
-#include "ext/video/ag_font.h"
-#include "ext/video/ag_fontengine.h"
-#include "ext/video/ag_painter.h"
-#include "ext/video/ag_painttarget.h"
-#include "ext/video/ag_rendercontext.h"
-#include "ext/video/ag_screen.h"
-#include "ext/video/ag_surface.h"
-#include "ext/video/ag_texture.h"
-#include "ext/video/ag_texturecache.h"
-#include "ext/video/ag_video.h"
-#include "ext/3dengine/mesh_data.h"
-#include "ext/3dengine/scene_base.h"
-#include "ext/3dengine/scenenode.h"
-#include "ext/3dengine/mesh_2d_data.h"
-#include "ext/3dengine/anim_mesh_data.h"
-#include "ext/3dengine/mesh.h"
-#include "ext/3dengine/mesh_2d.h"
-#include "ext/3dengine/ant_particle.h"
-#include "ext/3dengine/scene.h"
-#include "ext/3dengine/anim_mesh.h"
-#include "ext/3dengine/ant_camera.h"
-#include "ext/3dengine/mesh_optimizer.h"
-#include "ext/3dengine/ant_projection.h"
-#ifdef SWIG
-%include "ext/3dengine/mesh_data.h"
-%include "ext/3dengine/scene_base.h"
-%include "ext/3dengine/scenenode.h"
-%include "ext/3dengine/mesh_2d_data.h"
-%include "ext/3dengine/anim_mesh_data.h"
-%include "ext/3dengine/mesh.h"
-%include "ext/3dengine/mesh_2d.h"
-%include "ext/3dengine/ant_particle.h"
-%include "ext/3dengine/scene.h"
-%include "ext/3dengine/anim_mesh.h"
-%include "ext/3dengine/ant_camera.h"
-%include "ext/3dengine/mesh_optimizer.h"
-%include "ext/3dengine/ant_projection.h"
-#endif
-#endif
+#ifndef __ANTARGIS_H__
+#define __ANTARGIS_H__
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_stringstream.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_video_base.h"
+#include "ext/basic/ag_xml.h"
+#include "ext/basic/ag_singleton.h"
+#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_geometry.h"
+#include "ext/math/ag_rand.h"
+#include "ext/math/ant_frustum.h"
+#include "ext/math/ag_algebra.h"
+#include "ext/video/ag_screen.h"
+#include "ext/video/ag_video.h"
+#include "ext/video/ag_painttarget.h"
+#include "ext/video/ag_color.h"
+#include "ext/video/ag_fontengine.h"
+#include "ext/video/ag_font.h"
+#include "ext/video/ag_surface.h"
+#include "ext/video/ag_texture.h"
+#include "ext/video/ag_rendercontext.h"
+#include "ext/video/ag_texturecache.h"
+#include "ext/video/ag_clip.h"
+#include "ext/video/ag_painter.h"
+#include "ext/gui/ag_image.h"
+#include "ext/gui/ag_listbox.h"
+#include "ext/gui/ag_edit.h"
+#include "ext/gui/ag_scroller.h"
+#include "ext/gui/ag_local.h"
+#include "ext/gui/ag_tooltip.h"
+#include "ext/gui/ag_radio.h"
+#include "ext/gui/ag_application.h"
+#include "ext/gui/ag_colorbutton.h"
+#include "ext/gui/ag_button.h"
+#include "ext/gui/ag_radiogroup.h"
+#include "ext/gui/ag_background.h"
+#include "ext/gui/ag_menuitem.h"
+#include "ext/gui/ag_screenwidget.h"
+#include "ext/gui/ag_widget.h"
+#include "ext/gui/ag_text.h"
+#include "ext/gui/ag_checkbox.h"
+#include "ext/gui/ag_table.h"
+#include "ext/gui/ag_frame.h"
+#include "ext/gui/ag_caption.h"
+#include "ext/gui/ag_combo.h"
+#include "ext/gui/ag_theme.h"
+#include "ext/gui/ag_menu.h"
+#include "ext/gui/ag_layoutfactory.h"
+#include "ext/gui/ag_window.h"
+#include "ext/gui/ag_layout.h"
+#include "ext/gui/ag_border.h"
+#include "ext/3dengine/mesh_data.h"
+#include "ext/3dengine/scene_base.h"
+#include "ext/3dengine/scenenode.h"
+#include "ext/3dengine/mesh_2d_data.h"
+#include "ext/3dengine/anim_mesh_data.h"
+#include "ext/3dengine/mesh.h"
+#include "ext/3dengine/mesh_2d.h"
+#include "ext/3dengine/ant_particle.h"
+#include "ext/3dengine/scene.h"
+#include "ext/3dengine/anim_mesh.h"
+#include "ext/3dengine/boa_3d_wireframe.h"
+#include "ext/3dengine/ag_glwidget.h"
+#include "ext/3dengine/ant_camera.h"
+#include "ext/3dengine/mesh_optimizer.h"
+#include "ext/3dengine/ant_projection.h"
+#ifdef SWIG
+%include "ext/3dengine/mesh_data.h"
+%include "ext/3dengine/scene_base.h"
+%include "ext/3dengine/scenenode.h"
+%include "ext/3dengine/mesh_2d_data.h"
+%include "ext/3dengine/anim_mesh_data.h"
+%include "ext/3dengine/mesh.h"
+%include "ext/3dengine/mesh_2d.h"
+%include "ext/3dengine/ant_particle.h"
+%include "ext/3dengine/scene.h"
+%include "ext/3dengine/anim_mesh.h"
+%include "ext/3dengine/boa_3d_wireframe.h"
+%include "ext/3dengine/ag_glwidget.h"
+%include "ext/3dengine/ant_camera.h"
+%include "ext/3dengine/mesh_optimizer.h"
+%include "ext/3dengine/ant_projection.h"
+#endif
+#endif

Copied: antargis/branches/rant/ext/basic/ag_rtools.cc (from rev 1154, antargis/branches/rant/ext/ruby/ag_rtools.cc)

Copied: antargis/branches/rant/ext/basic/ag_rtools.h (from rev 1154, antargis/branches/rant/ext/ruby/ag_rtools.h)

Modified: antargis/branches/rant/ext/basic/ag_serial.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_serial.cc	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/basic/ag_serial.cc	2007-08-15 17:33:15 UTC (rev 1156)
@@ -92,8 +92,31 @@
   return *this;
 }
 
+BinaryIn &BinaryIn::operator>>(std::string &f)
+{
+  Uint32 l;
+  (*this)>>l;
 
+  cdebug("L:"<<l);
 
+  assert(l<1000000);
+  char *s=new char[l+1];
+  char c;
+  for(Uint32 i=0;i<l;i++)
+    {
+      c=read();
+      cdebug("C:"<<(int)c);
+      s[i]=c;
+    }
+
+
+  f=std::string(s,l);
+  delete s;
+
+  return *this;
+}
+
+
 /////////////////////////////////////////////////////////////
 // BinaryOut
 /////////////////////////////////////////////////////////////
@@ -120,6 +143,15 @@
   write((u>>24)&0xFF);
   return *this;
 }
+
+BinaryOut &BinaryOut::operator<<(const Uint16 &u)
+{
+  write((u>>0 )&0xFF);
+  write((u>>8 )&0xFF);
+  return *this;
+}
+
+
 BinaryOut &BinaryOut::operator<<(const float &f)
 {
   if(sizeof(float)!=4)
@@ -147,6 +179,18 @@
   return *this;
 }
 
+
+BinaryOut &BinaryOut::operator<<(const std::string &s)
+{
+  assert(s.size()<(1L<<31));
+
+  (*this)<<Uint32(s.size());
+
+  for(size_t i=0;i<s.length();i++)
+    write(s[i]);
+  return *this;
+}
+
 /////////////////////////////////////////////////////////////
 // BinaryFileIn
 /////////////////////////////////////////////////////////////

Modified: antargis/branches/rant/ext/basic/ag_serial.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_serial.h	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/basic/ag_serial.h	2007-08-15 17:33:15 UTC (rev 1156)
@@ -24,6 +24,7 @@
   BinaryIn &operator>>(Uint32 &i);
   BinaryIn &operator>>(Uint16 &i);
   BinaryIn &operator>>(float &f);
+  BinaryIn &operator>>(std::string &f);
 };
 
 class AGEXPORT BinaryOut
@@ -36,7 +37,9 @@
 
   BinaryOut &operator<<(const Sint32 &i);
   BinaryOut &operator<<(const Uint32 &i);
+  BinaryOut &operator<<(const Uint16 &i);
   BinaryOut &operator<<(const float &f);
+  BinaryOut &operator<<(const std::string &s);
 };
 
 class AGEXPORT BinaryFileIn:public BinaryIn

Modified: antargis/branches/rant/ext/basic/headers.hh
===================================================================
--- antargis/branches/rant/ext/basic/headers.hh	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/basic/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,34 +1,34 @@
-#ifndef __ANTARGIS_H__
-#define __ANTARGIS_H__
-
-#include "ext/basic/ag_rubyobj.h"
-#include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_main.h"
-#include "ext/basic/ag_video_base.h"
-#include "ext/basic/ag_geometry.h"
-#include "ext/basic/ag_serial.h"
-#include "ext/basic/ag_config.h"
-#include "ext/basic/ag_xml.h"
-#include "ext/basic/ag_string_utf8.h"
-#include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_utf8.h"
-#ifdef SWIG
-%include "ext/basic/ag_rubyobj.h"
-%include "ext/basic/ag_messageobject.h"
-%include "ext/basic/ag_singleton.h"
-%include "ext/basic/ag_rand_base.h"
-%include "ext/basic/ag_main.h"
-%include "ext/basic/ag_video_base.h"
-%include "ext/basic/ag_geometry.h"
-%include "ext/basic/ag_serial.h"
-%include "ext/basic/ag_config.h"
-%include "ext/basic/ag_xml.h"
-%include "ext/basic/ag_string_utf8.h"
-%include "ext/basic/ag_stringstream.h"
-%include "ext/basic/ag_fs.h"
-%include "ext/basic/ag_utf8.h"
-#endif
-#endif
+#ifndef __ANTARGIS_H__
+#define __ANTARGIS_H__
+
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_singleton.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_video_base.h"
+#include "ext/basic/ag_geometry.h"
+#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_xml.h"
+#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_stringstream.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_utf8.h"
+#ifdef SWIG
+%include "ext/basic/ag_rubyobj.h"
+%include "ext/basic/ag_messageobject.h"
+%include "ext/basic/ag_singleton.h"
+%include "ext/basic/ag_rand_base.h"
+%include "ext/basic/ag_main.h"
+%include "ext/basic/ag_video_base.h"
+%include "ext/basic/ag_geometry.h"
+%include "ext/basic/ag_serial.h"
+%include "ext/basic/ag_config.h"
+%include "ext/basic/ag_xml.h"
+%include "ext/basic/ag_string_utf8.h"
+%include "ext/basic/ag_stringstream.h"
+%include "ext/basic/ag_fs.h"
+%include "ext/basic/ag_utf8.h"
+#endif
+#endif

Modified: antargis/branches/rant/ext/game/headers.hh
===================================================================
--- antargis/branches/rant/ext/game/headers.hh	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/game/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,104 +1,106 @@
-#ifndef __ANTARGIS_H__
-#define __ANTARGIS_H__
-#include "ext/basic/ag_config.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_geometry.h"
-#include "ext/basic/ag_main.h"
-#include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_rubyobj.h"
-#include "ext/basic/ag_serial.h"
-#include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_string_utf8.h"
-#include "ext/basic/ag_utf8.h"
-#include "ext/basic/ag_video_base.h"
-#include "ext/basic/ag_xml.h"
-#include "ext/math/ag_algebra.h"
-#include "ext/math/ag_rand.h"
-#include "ext/math/ant_frustum.h"
-#include "ext/video/ag_clip.h"
-#include "ext/video/ag_color.h"
-#include "ext/video/ag_font.h"
-#include "ext/video/ag_fontengine.h"
-#include "ext/video/ag_painter.h"
-#include "ext/video/ag_painttarget.h"
-#include "ext/video/ag_rendercontext.h"
-#include "ext/video/ag_screen.h"
-#include "ext/video/ag_surface.h"
-#include "ext/video/ag_texture.h"
-#include "ext/video/ag_texturecache.h"
-#include "ext/video/ag_video.h"
-#include "ext/gui/ag_application.h"
-#include "ext/gui/ag_background.h"
-#include "ext/gui/ag_border.h"
-#include "ext/gui/ag_button.h"
-#include "ext/gui/ag_caption.h"
-#include "ext/gui/ag_checkbox.h"
-#include "ext/gui/ag_colorbutton.h"
-#include "ext/gui/ag_combo.h"
-#include "ext/gui/ag_edit.h"
-#include "ext/gui/ag_frame.h"
-#include "ext/gui/ag_image.h"
-#include "ext/gui/ag_layout.h"
-#include "ext/gui/ag_layoutfactory.h"
-#include "ext/gui/ag_listbox.h"
-#include "ext/gui/ag_local.h"
-#include "ext/gui/ag_menu.h"
-#include "ext/gui/ag_menuitem.h"
-#include "ext/gui/ag_radio.h"
-#include "ext/gui/ag_radiogroup.h"
-#include "ext/gui/ag_screenwidget.h"
-#include "ext/gui/ag_scroller.h"
-#include "ext/gui/ag_table.h"
-#include "ext/gui/ag_text.h"
-#include "ext/gui/ag_theme.h"
-#include "ext/gui/ag_tooltip.h"
-#include "ext/gui/ag_widget.h"
-#include "ext/gui/ag_window.h"
-#include "ext/3dengine/anim_mesh.h"
-#include "ext/3dengine/anim_mesh_data.h"
-#include "ext/3dengine/ant_camera.h"
-#include "ext/3dengine/ant_particle.h"
-#include "ext/3dengine/ant_projection.h"
-#include "ext/3dengine/mesh.h"
-#include "ext/3dengine/mesh_2d.h"
-#include "ext/3dengine/mesh_2d_data.h"
-#include "ext/3dengine/mesh_data.h"
-#include "ext/3dengine/mesh_optimizer.h"
-#include "ext/3dengine/scene.h"
-#include "ext/3dengine/scenenode.h"
-#include "ext/3dengine/scene_base.h"
-#include "ext/game/path.h"
-#include "ext/game/path_v2.h"
-#include "ext/game/path_base.h"
-#include "ext/game/terrain.h"
-#include "ext/game/entity.h"
-#include "ext/game/water.h"
-#include "ext/game/height_map.h"
-#include "ext/game/ant_app.h"
-#include "ext/game/minimap.h"
-#include "ext/game/map.h"
-#include "ext/game/heuristic.h"
-#include "ext/game/path_weighter.h"
-#include "ext/game/jobs.h"
-#include "ext/game/resource.h"
-#include "ext/game/path_data_v3.h"
-#ifdef SWIG
-%include "ext/game/path.h"
-%include "ext/game/path_v2.h"
-%include "ext/game/path_base.h"
-%include "ext/game/terrain.h"
-%include "ext/game/entity.h"
-%include "ext/game/water.h"
-%include "ext/game/height_map.h"
-%include "ext/game/ant_app.h"
-%include "ext/game/minimap.h"
-%include "ext/game/map.h"
-%include "ext/game/heuristic.h"
-%include "ext/game/path_weighter.h"
-%include "ext/game/jobs.h"
-%include "ext/game/resource.h"
-%include "ext/game/path_data_v3.h"
-#endif
-#endif
+#ifndef __ANTARGIS_H__
+#define __ANTARGIS_H__
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_stringstream.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_video_base.h"
+#include "ext/basic/ag_xml.h"
+#include "ext/basic/ag_singleton.h"
+#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_geometry.h"
+#include "ext/math/ag_rand.h"
+#include "ext/math/ant_frustum.h"
+#include "ext/math/ag_algebra.h"
+#include "ext/video/ag_screen.h"
+#include "ext/video/ag_video.h"
+#include "ext/video/ag_painttarget.h"
+#include "ext/video/ag_color.h"
+#include "ext/video/ag_fontengine.h"
+#include "ext/video/ag_font.h"
+#include "ext/video/ag_surface.h"
+#include "ext/video/ag_texture.h"
+#include "ext/video/ag_rendercontext.h"
+#include "ext/video/ag_texturecache.h"
+#include "ext/video/ag_clip.h"
+#include "ext/video/ag_painter.h"
+#include "ext/gui/ag_image.h"
+#include "ext/gui/ag_listbox.h"
+#include "ext/gui/ag_edit.h"
+#include "ext/gui/ag_scroller.h"
+#include "ext/gui/ag_local.h"
+#include "ext/gui/ag_tooltip.h"
+#include "ext/gui/ag_radio.h"
+#include "ext/gui/ag_application.h"
+#include "ext/gui/ag_colorbutton.h"
+#include "ext/gui/ag_button.h"
+#include "ext/gui/ag_radiogroup.h"
+#include "ext/gui/ag_background.h"
+#include "ext/gui/ag_menuitem.h"
+#include "ext/gui/ag_screenwidget.h"
+#include "ext/gui/ag_widget.h"
+#include "ext/gui/ag_text.h"
+#include "ext/gui/ag_checkbox.h"
+#include "ext/gui/ag_table.h"
+#include "ext/gui/ag_frame.h"
+#include "ext/gui/ag_caption.h"
+#include "ext/gui/ag_combo.h"
+#include "ext/gui/ag_theme.h"
+#include "ext/gui/ag_menu.h"
+#include "ext/gui/ag_layoutfactory.h"
+#include "ext/gui/ag_window.h"
+#include "ext/gui/ag_layout.h"
+#include "ext/gui/ag_border.h"
+#include "ext/3dengine/scene_base.h"
+#include "ext/3dengine/scene.h"
+#include "ext/3dengine/scenenode.h"
+#include "ext/3dengine/ant_camera.h"
+#include "ext/3dengine/ag_glwidget.h"
+#include "ext/3dengine/mesh_data.h"
+#include "ext/3dengine/mesh.h"
+#include "ext/3dengine/mesh_optimizer.h"
+#include "ext/3dengine/anim_mesh.h"
+#include "ext/3dengine/anim_mesh_data.h"
+#include "ext/3dengine/boa_3d_wireframe.h"
+#include "ext/3dengine/mesh_2d.h"
+#include "ext/3dengine/mesh_2d_data.h"
+#include "ext/3dengine/ant_projection.h"
+#include "ext/3dengine/ant_particle.h"
+#include "ext/game/path.h"
+#include "ext/game/path_data_v3.h"
+#include "ext/game/path_v2.h"
+#include "ext/game/path_base.h"
+#include "ext/game/terrain.h"
+#include "ext/game/entity.h"
+#include "ext/game/water.h"
+#include "ext/game/height_map.h"
+#include "ext/game/ant_app.h"
+#include "ext/game/minimap.h"
+#include "ext/game/map.h"
+#include "ext/game/heuristic.h"
+#include "ext/game/path_weighter.h"
+#include "ext/game/jobs.h"
+#include "ext/game/resource.h"
+#ifdef SWIG
+%include "ext/game/path.h"
+%include "ext/game/path_data_v3.h"
+%include "ext/game/path_v2.h"
+%include "ext/game/path_base.h"
+%include "ext/game/terrain.h"
+%include "ext/game/entity.h"
+%include "ext/game/water.h"
+%include "ext/game/height_map.h"
+%include "ext/game/ant_app.h"
+%include "ext/game/minimap.h"
+%include "ext/game/map.h"
+%include "ext/game/heuristic.h"
+%include "ext/game/path_weighter.h"
+%include "ext/game/jobs.h"
+%include "ext/game/resource.h"
+#endif
+#endif

Modified: antargis/branches/rant/ext/game/height_map.cc
===================================================================
--- antargis/branches/rant/ext/game/height_map.cc	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/game/height_map.cc	2007-08-15 17:33:15 UTC (rev 1156)
@@ -4,6 +4,8 @@
 #include <ag_main.h>
 #include <ag_rand.h>
 
+#include <ag_rtools.h>
+
 //////////////////////////////////////////////////////////////////////////
 // HeightMap
 //////////////////////////////////////////////////////////////////////////
@@ -632,3 +634,13 @@
   if(!mTerrain)
     initTerrainMesh();
 }
+
+std::string HeightMap::hash() const
+{
+  BinaryStringOut s;
+  for(std::vector<float>::const_iterator i=mHeights.begin();i!=mHeights.end();i++)
+    s<<*i;
+
+  return rubyHash(s.getString());
+
+}

Modified: antargis/branches/rant/ext/game/height_map.h
===================================================================
--- antargis/branches/rant/ext/game/height_map.h	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/game/height_map.h	2007-08-15 17:33:15 UTC (rev 1156)
@@ -91,6 +91,8 @@
   /// to be used by initTerrainMesh() - not otherwise !!!
   void setTerrain(TerrainBase *pTerrain);
 
+  std::string hash() const;
+
  private:
 
   void checkTerrain();

Modified: antargis/branches/rant/ext/game/heuristic.cc
===================================================================
--- antargis/branches/rant/ext/game/heuristic.cc	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/game/heuristic.cc	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,78 +1,119 @@
 #include "heuristic.h"
 #include <ag_debug.h>
+#include "ag_serial_vec.h"
 
+#include <set>
 
 HeuristicFunction::Output HeuristicFunction::operator()(const Input &input) 
 {
   return (input.second-input.first).length()*1.5;
 }
 
-
-StoredHeuristicFunction::StoredHeuristicFunction(size_t res,float width):
-  a(res*res*res*res),
-  r(res),
-  w(width)
+void HeuristicFunction::printTo(BinaryOut &pOut)
 {
 }
 
-void StoredHeuristicFunction::store(Input in,Output out)
+float HeuristicFunction::get(const AGVector2 &a,const AGVector2 &b)
 {
-  size_t i=getIndex(in);
-  //  cdebug("index:"<<i);
-  //  cdebug("value:"<<out);
-  a[i]=out;
+  return (*this)(std::make_pair(a,b));
 }
 
-StoredHeuristicFunction::Output StoredHeuristicFunction::operator()(const Input &input)
+
+
+StoredHeuristicFunction::StoredHeuristicFunction()
 {
-  size_t i=getIndex(input);
-  //  cdebug("index:"<<i);
-  float v=a[i];
-  //  cdebug("value:"<<v);
-
-  return v*6;
 }
 
-size_t StoredHeuristicFunction::getIndex(const Input &in)
+StoredHeuristicFunction::StoredHeuristicFunction(BinaryIn &pIn)
 {
-  size_t a,b,c,d;
+  Uint32 s;
+  AGVector2 v;
+  Uint16 ai,bi;
+  float w;
+  pIn>>s;
+  cdebug("S:"<<s);
 
-  //  cdebug(in.first<<":::"<<in.second);
+  assert(s<10000);
 
-  a=in.first[0]*r/w;
-  b=in.first[1]*r/w;
-  c=in.second[0]*r/w;
-  d=in.second[1]*r/w;
+  std::vector<AGVector2> allVecs;
+  
+  for(size_t i=0;i<s;i++)
+    {
+      pIn>>v;
+      allVecs.push_back(v);
+      cdebug(i<<":"<<v);
+    }
 
-  a=std::min(a,r-1);
-  b=std::min(b,r-1);
-  c=std::min(c,r-1);
-  d=std::min(d,r-1);
 
-  assert(a<r);
-  assert(b<r);
-  assert(c<r);
-  assert(d<r);
+  pIn>>s;
 
-  size_t i=((a*r+b)*r+c)*r+d;
+  cdebug("S:"<<s);
 
-  //  cdebug(i);
-  return i;
+  assert(s<2000000); // sanity check
+
+  for(size_t i=0;i<s;i++)
+    {
+      pIn>>ai>>bi>>w;
+      //      cdebug("ai:"<<ai<<" bi:"<<bi<<" w:"<<w);
+      mMap.insert(std::make_pair(std::make_pair(allVecs[ai],allVecs[bi]),w));
+    }
 }
 
 
-void StoredHeuristicFunction::display()
+void StoredHeuristicFunction::store(Input in,Output out)
 {
-  for(int a=0;a<r;a++)
-    for(int b=0;b<r;b++)
-      for(int c=0;c<r;c++)
-	for(int d=0;d<r;d++)
-	  {
-	    AGVector2 p0(a*w/r,b*w/r);
-	    AGVector2 p1(c*w/r,d*w/r);
+  mMap[in]=out;
+}
 
-	    float value=operator()(std::make_pair(p0,p1));
-	    if(value>0)
-	      std::cout<<a<<","<<b<<","<<c<<","<<d<<":"<<value<<std::endl;
-	  }
+void StoredHeuristicFunction::store(const AGVector2 &from,const AGVector2 &to,float value)
+{
+  mMap[std::make_pair(from,to)]=value;
 }
+
+
+  //  void display();
+
+StoredHeuristicFunction::Output StoredHeuristicFunction::operator()(const Input &input)
+{
+  return mMap[input];
+}
+
+
+
+void StoredHeuristicFunction::printTo(BinaryOut &pOut)
+{
+  std::set<AGVector2> allVecs;
+  
+
+  for(std::map<Input,Output>::iterator i=mMap.begin();i!=mMap.end();i++)
+    {
+      allVecs.insert(i->first.first);
+      allVecs.insert(i->first.second);
+    }
+
+  std::vector<AGVector2> vecs;
+  std::copy(allVecs.begin(),allVecs.end(),std::back_inserter(vecs));
+  std::map<AGVector2,size_t> indices;
+
+  pOut<<(Uint32)vecs.size();
+
+  for(size_t i=0;i<vecs.size();i++)
+    {
+      indices[vecs[i]]=i;
+      pOut<<vecs[i];
+    }
+
+  pOut<<(Uint32)mMap.size();
+
+  for(std::map<Input,Output>::iterator i=mMap.begin();i!=mMap.end();i++)
+    {
+      AGVector2 a=i->first.first,b=i->first.second;
+      Uint16 ai=indices[a];
+      Uint16 bi=indices[b];
+      float w=i->second;
+      pOut<<ai;
+      pOut<<bi;
+      pOut<<w;
+    }
+
+}

Modified: antargis/branches/rant/ext/game/heuristic.h
===================================================================
--- antargis/branches/rant/ext/game/heuristic.h	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/game/heuristic.h	2007-08-15 17:33:15 UTC (rev 1156)
@@ -5,6 +5,8 @@
 
 #include <ag_geometry.h>
 
+#include <map>
+
 class AGEXPORT HeuristicFunction
 {
  public:
@@ -15,28 +17,33 @@
     {
     }
 
+  virtual void printTo(BinaryOut &pOut);
+
   virtual Output operator()(const Input &input);
+
+  float get(const AGVector2 &a,const AGVector2 &b);
 };
 
 class AGEXPORT StoredHeuristicFunction:public HeuristicFunction
 {
-  // FIXME: maybe store measure-count, too - and average!!!
-
-  std::vector<float> a;
-  size_t r;
-  float w;
  public:
-  StoredHeuristicFunction(size_t res,float width);
+  StoredHeuristicFunction();
+  StoredHeuristicFunction(BinaryIn &pIn);
 
   void store(Input in,Output out);
 
-  void display();
+  void store(const AGVector2 &from,const AGVector2 &to,float value);
 
+  //  void display();
+
   virtual Output operator()(const Input &input);
+
+  void printTo(BinaryOut &pOut);
+
  private:
-  size_t getIndex(const Input &in);
+  std::map<Input,Output> mMap;
+  
 };
 
-
 #endif
 

Modified: antargis/branches/rant/ext/game/path.cc
===================================================================
--- antargis/branches/rant/ext/game/path.cc	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/game/path.cc	2007-08-15 17:33:15 UTC (rev 1156)
@@ -40,6 +40,19 @@
   return m;
 }
 
+bool SimpleGraph::Node::hasEdge(Edge *e)
+{
+  for(Edges::iterator i=edges.begin();i!=edges.end();i++)
+    {
+      if(**i==*e)
+	return true;
+    }
+  return false;
+  //  EdgePtrCompare cmp;
+  //  return(std::find(edges.begin(),edges.end(),e,cmp)!=edges.end());
+}
+
+
 ///////////////////////////////////////////////////////////////////////
 // Edge
 ///////////////////////////////////////////////////////////////////////
@@ -76,6 +89,12 @@
   return a<e.a || (a==e.a && b<e.b);
 }
 
+bool SimpleGraph::Edge::operator==(const Edge &e) const
+{
+  return (a==e.a && b==e.b) || (a==e.b && b==e.a);
+}
+
+
 float SimpleGraph::Edge::maxWeight() const
 {
   return std::max(w0,w1);
@@ -345,7 +364,28 @@
   return mNodes.size();
 }
 
+size_t SimpleGraph::edges() const
+{
+  return mEdges.size();
+}
 
+std::pair<AGVector2,AGVector2> SimpleGraph::getEdgePosition(size_t i)
+{
+  assert(i<mEdges.size());
+
+  size_t j=0;
+  Edge *e=0;
+  for(EdgeSet::iterator k=mEdges.begin();k!=mEdges.end() && j<=i;k++,j++)
+    e=*k;
+
+  cdebug("i:"<<i<<"  size:"<<mEdges.size());
+  assert(e);
+
+  return std::make_pair(e->a->p,e->b->p);
+}
+
+
+
 SimpleGraph::Edge *SimpleGraph::addEdge(Node *a, Node *b,float w0,float w1)
 {
   Node *n1=a;
@@ -354,10 +394,16 @@
   assert(n2);
   Edge *e=new Edge(n1,n2,w0,w1);
 
+  assert(!n1->hasEdge(e));
+  assert(!n2->hasEdge(e));
+  //#error add check, if edge already exists
+
   n1->edges.push_back(e);
 
   n2->edges.push_back(e);
 
+  assert(e);
+
   mEdges.insert(e);
 
   return e;
@@ -498,9 +544,10 @@
 
   while(mNodes.size()>m)
     {
-      cdebug(mNodes.size()<<" vs. "<<m);
-
-      tryRemove(*mEdges.begin(),pWeighter);
+      Edge *e=*mEdges.begin();
+      cdebug(mNodes.size()<<" vs. "<<m<<" edge:"<<e);
+      assert(e);
+      tryRemove(e,pWeighter);
     }
 
 }
@@ -520,14 +567,17 @@
 {
   if(mNodes.size()<=2)
     return;
-  
 
+  assert(e);
+
   AGVector2 np=(e->a->p+e->b->p)*0.5;
   //  e->a->p=np;
 
+  // create a new node in the middle of the edge
   Node *nn=addNode(np);
 
   Edges all;
+  // collect all neighbring edges
   std::copy(e->a->edges.begin(),e->a->edges.end(),std::back_inserter(all));
   std::copy(e->b->edges.begin(),e->b->edges.end(),std::back_inserter(all));
 
@@ -535,10 +585,13 @@
 
   std::set<Edge> nedges; // collect edges and sort out doubles
 
+  // create new edges for the neighboring edges now going to the new node
   for(Edges::iterator i=all.begin();i!=all.end();i++)
     {
       if(*i!=e)
 	{
+	  if(((*i)->a==e->a && (*i)->b==e->b) || ((*i)->a==e->b && (*i)->b==e->a))
+	    continue;
 	  if((*i)->a==e->a)
 	    {
 	      // X <- a -> b
@@ -580,6 +633,8 @@
   for(Edges::iterator i=all.begin();i!=all.end();i++)
     removeEdge(*i);
 
+  removeEdge(e);
+
   //  cdebug("ok........");
   
 }
@@ -591,11 +646,33 @@
 }
 
 
+std::list<std::pair<size_t,size_t> > getPossibleNeighbors(size_t w,size_t h,const std::pair<size_t,size_t> &curPos)
+{
+  std::list<std::pair<size_t,size_t> > result;
+  int x,y,dx,dy;
+  int r=5;
+  for(x=-r+1;x<r;x++)
+    for(y=0;y<r;y++)
+      if(x>0 || y>0)
+	//	if(x!=y) // FIXME
+	  {
+	    dx=x+curPos.first;
+	    dy=y+curPos.second;
 
+	    if(dx<w-1 && dy<h-1 && dx>=0 && dy>=0)
+	      result.push_back(std::make_pair(dx,dy));
+	  }
+
+  return result;
+}
+
+
 ///////////////////////////////////////////////////////////////////////
 // Graph generation
 ///////////////////////////////////////////////////////////////////////
 
+
+
 SimpleGraph *makeGraph(HeightMap *pMap, MapPathWeighter *pWeighter,size_t res)
 {
   size_t x,y;
@@ -618,6 +695,7 @@
   for(x=0;x<w;x+=res)
     for(y=0;y<h;y+=res)
       {
+#if false
 	std::pair<size_t,size_t> p(x,y);
 	std::pair<size_t,size_t> p1(x+res,y);
 	std::pair<size_t,size_t> p2(x,y+res);
@@ -635,14 +713,52 @@
 	    if(a && b)
 	      graph->addEdge(a,b,pWeighter->weight(AGVector2(x,y),AGVector2(x,y+res)),pWeighter->weight(AGVector2(x,y+res),AGVector2(x,y)));
 	  }
+#else
+	std::pair<size_t,size_t> p(x,y);
+	std::list<std::pair<size_t,size_t> > l=getPossibleNeighbors(w,h,std::make_pair(x,y));
+	SimpleGraph::Node *a=nodes[p];
+	for(std::list<std::pair<size_t,size_t> >::iterator i=l.begin();i!=l.end();i++)
+	  {
+	    //	    cdebug(i->first<<":"<<i->second);
+	    SimpleGraph::Node *b=nodes[*i];
+	    if(a && b)
+	      {
+		graph->addEdge(a,b,pWeighter->weight(AGVector2(x,y),AGVector2(i->first,i->second)),pWeighter->weight(AGVector2(i->first,i->second),AGVector2(x,y)));
+	      }
+	  }
+#endif
+
       }
   return graph;
 
 }
 
+struct NodeInfo
+{
+  SimpleGraph::Node *node;
+
+  NodeInfo(SimpleGraph::Node *p):node(p)
+  {
+  }
+
+  bool operator<(const NodeInfo &i) const
+  {
+    bool result=false;
+    if(node->tmpWeight<i.node->tmpWeight)
+      result=true;
+    else if(node->tmpWeight==i.node->tmpWeight)
+      result=node<i.node;
+    //    cdebug("operator<:"<<node<<"("<<node->tmpWeight<<")<"<<i.node<<"("<<i.node->tmpWeight<<")  "<<result);
+    return result;
+  }
+};
+
+#if false
+
 HeuristicFunction *computeHeuristic(SimpleGraph *g)
 {
-  StoredHeuristicFunction *h=new StoredHeuristicFunction(32,g->width());
+  //  StoredHeuristicFunction *h=new StoredHeuristicFunction(32,g->width());
+  StoredHeuristicFunction *h=new StoredHeuristicFunction;
 
   size_t c=0;
 
@@ -726,6 +842,93 @@
   return h;
 }
 
+
+
+#else
+
+
+HeuristicFunction *computeHeuristic(SimpleGraph *g)
+{
+  STACKTRACE;
+  StoredHeuristicFunction *h=new StoredHeuristicFunction;
+
+  size_t c=0;
+
+  for(SimpleGraph::NodeSet::iterator i=g->mNodes.begin();i!=g->mNodes.end();i++)
+    {
+      STACKTRACE;
+
+      // clear all weights in nodes
+      for(SimpleGraph::NodeSet::iterator k=g->mNodes.begin();k!=g->mNodes.end();k++)
+	{
+	  STACKTRACE;
+
+	  (*k)->tmpWeight=0;
+	}
+
+
+      std::set<NodeInfo> weights;
+      std::list<NodeInfo> completed;
+      weights.insert(NodeInfo(*i));
+      size_t tries=0;
+      float minWeight=0;
+
+      while(weights.size())
+	{
+	  STACKTRACE;
+	  NodeInfo info=*weights.begin();
+	  weights.erase(weights.begin());
+	  
+	  SimpleGraph::Node *n=info.node;
+
+	  SimpleGraph::Node::NodeMap ns=n->getNextNodes();
+	  float old=n->tmpWeight;
+
+	  assert(old>=minWeight);
+	  minWeight=old;
+
+	  for(SimpleGraph::Node::NodeMap::iterator j=ns.begin();j!=ns.end();j++)
+	    {
+	      float now=j->first->tmpWeight;
+	      float compare=j->second+old;
+
+	      if(now==0 || (now>compare))
+		{
+		  if(now!=0)
+		    weights.erase(j->first);
+		  j->first->tmpWeight=compare;
+		  weights.insert(j->first);
+		}
+	    }
+	  completed.push_back(n);
+	  tries++;
+	}
+
+      //FIXME: store data !!
+
+      for(std::list<NodeInfo>::iterator j=completed.begin();j!=completed.end();j++)
+	{
+	  STACKTRACE;
+	  h->store(std::make_pair((*i)->p,j->node->p),j->node->tmpWeight);
+	}
+
+      h->store(std::make_pair((*i)->p,(*i)->p),0);
+
+      c++;
+      cdebug(c<<" out of "<<g->mNodes.size()<<" completed:"<<completed.size()<<" tries:"<<tries);
+    }
+
+  return h;
+}
+
+
+
+
+#endif
+
+
+
+
 ///////////////////////////////////////////////////////////////////////
 // Path
 ///////////////////////////////////////////////////////////////////////

Modified: antargis/branches/rant/ext/game/path.h
===================================================================
--- antargis/branches/rant/ext/game/path.h	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/game/path.h	2007-08-15 17:33:15 UTC (rev 1156)
@@ -92,6 +92,7 @@
     ~Edge();
 
     bool operator<(const Edge &e) const;
+    bool operator==(const Edge &e) const;
     float maxWeight() const;
 
     Node *getOther(Node *n);
@@ -107,11 +108,16 @@
   {
     AGVector2 p;
     Edges edges;
+    float tmpWeight;
+
     typedef std::map<Node*,float,NodePtrCompare> NodeMap;
     
     ~Node();
 
     NodeMap getNextNodes();
+
+    bool hasEdge(Edge *e);
+
   };
 
   struct EdgeSort
@@ -156,8 +162,19 @@
 
   float width() const;
 
+  /**
+     @return count of nodes
+  */
   size_t size() const;
 
+  /**
+     @return edge count
+  */
+  size_t edges() const;
+
+  std::pair<AGVector2,AGVector2> getEdgePosition(size_t i);
+
+
   void paint(const AGRect2& r,AGPaintTarget &t,Heuristic &heuristic);
   void paintNode(const AGRect2& r,AGPaintTarget &t,const AGVector2 &p,const AGColor &c);
 

Modified: antargis/branches/rant/ext/game/path_data_v3.cc
===================================================================
--- antargis/branches/rant/ext/game/path_data_v3.cc	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/game/path_data_v3.cc	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,27 +1,33 @@
 #include "path_data_v3.h"
 #include "path_vector_sort.h"
 
+#include <ag_profiler.h>
+
 #include <ag_debug.h>
 #include <algorithm>
 
 #include <math.h>
 
-namespace PathFinding
-{
+//namespace PathFinding
+//{
 
   Field::Field(const AGVector2 &pMiddle,size_t pID):mID(pID),
 						    mMiddle(pMiddle)
   {
   }
 
+  Field::~Field()
+  {
+  }
+
   void Field::insert(const AGVector2 &v,DistanceComputer &pDist)
   {
     mVectors.insert(v);
     mNeighbors.erase(v);
     
-    std::list<AGVector2> neighbors=pDist.getNeighbors(v);
+    std::vector<AGVector2> neighbors=pDist.getNeighbors(v);
 
-    for(std::list<AGVector2>::iterator i=neighbors.begin();i!=neighbors.end();i++)
+    for(std::vector<AGVector2>::iterator i=neighbors.begin();i!=neighbors.end();i++)
       {
 	if(mVectors.find(*i)==mVectors.end())
 	  mNeighbors.insert(*i);
@@ -44,17 +50,45 @@
     return mMiddle;
   }
 
+  std::vector<AGVector2> Field::getVectors() const
+  {
+    std::vector<AGVector2> v;
+    std::copy(mVectors.begin(),mVectors.end(),std::back_inserter(v));
+    return v;
+  }
 
+  std::vector<AGVector2> Field::getNeighbors() const
+  {
+    std::vector<AGVector2> v;
+    std::copy(mNeighbors.begin(),mNeighbors.end(),std::back_inserter(v));
+    return v;
+  }
 
 
 
 
 
+////////////////////////////////////////////////////////
+// FieldCollection
+////////////////////////////////////////////////////////
+
+
+  FieldCollection::~FieldCollection()
+  {
+  }
+
+  Field *FieldCollection::createField(const AGVector2 &pMiddle,size_t pId)
+  {
+    return new FieldWithDistances(pMiddle,pId);
+  }
+  
+
+  //
   void FieldCollection::assign(const AGVector2 &v,size_t pField,DistanceComputer &pDist)
   {
     assert(pField<mFields.size());
 
-    mFields[pField].insert(v,pDist);
+    mFields[pField]->insert(v,pDist);
     mVec2Field[v]=pField;
   }
 
@@ -62,13 +96,13 @@
   size_t FieldCollection::newField(const AGVector2 &pMiddle)
   {
     size_t id=mFields.size();
-    mFields.push_back(Field(pMiddle,id));
+    mFields.push_back(createField(pMiddle,id));
     return id;
   }
 
 Field *FieldCollection::getField(size_t pField)
 {
-  return &(mFields[pField]);
+  return mFields[pField];
 }
 
   size_t FieldCollection::getFieldId(const AGVector2 &pVector) const
@@ -86,6 +120,12 @@
     return mFields.size();
   }
 
+  void FieldCollection::mark()
+  {
+    CTRACE;
+    for(std::vector<Field*>::iterator i=mFields.begin();i!=mFields.end();i++)
+      markObject(*i);
+  }
 
 
 
@@ -108,10 +148,13 @@
 
   void assignFields(FieldCollection &pCollection,DistanceComputer &pDist,size_t pFieldCount)
   {
-    std::list<AGVector2> allVectorList=pDist.getAllPassable();
+    std::vector<AGVector2> allVectorList=pDist.getAllPassable();
 
-    float maxFieldWidth=sqrt(pDist.width()*pDist.height()/pFieldCount);
+    float maxFieldWidth=sqrt(allVectorList.size()/pFieldCount)*0.7;
 
+
+    //    maxFieldWidth=3;
+
     std::set<AGVector2> restOfVectors;
 
     std::copy(allVectorList.begin(),allVectorList.end(),std::inserter(restOfVectors,restOfVectors.begin()));
@@ -132,7 +175,7 @@
 	size_t k=0;
 	for(std::set<AGVector2,DistanceOrder>::iterator i=growField.begin();i!=growField.end() && k<30;i++,k++)
 	  {
-	    cdebug(" "<<*i<<"  "<<(*i-fieldMiddle).length());
+	    //	    cdebug(" "<<*i<<"  "<<(*i-fieldMiddle).length());
 	  }
 
 	do
@@ -157,4 +200,243 @@
 
 
 
+
+  // FieldWithDistances
+
+
+  FieldWithDistances::FieldWithDistances(const AGVector2 &pMiddle,size_t pID):
+    Field(pMiddle,pID)
+  {
+  }
+
+void FieldWithDistances::initLocalDistances(const DistanceComputer &pComputer,const std::vector<AGVector2> &pVectors)
+  {
+    STACKTRACE;
+    AGVector2 m=getMiddle();
+    std::set<AGVector2> baseVectors;
+    std::copy(pVectors.begin(),pVectors.end(),std::inserter(baseVectors,baseVectors.begin()));
+
+    std::vector<AGVector2> vectors=getVectors();
+
+    for(std::vector<AGVector2>::iterator i=vectors.begin();i!=vectors.end();i++)
+      {
+	STACKTRACE;
+	std::map<AGVector2,float> curDists;
+
+	// compute distances for paths starting at *i
+	DistanceOrder order(*i);
+	std::set<AGVector2,DistanceOrder> vecSet(order);
+	vecSet.insert(*i);
+	//	cdebug("VEC:"<<*i);
+	while(vecSet.size()>0)
+	  {
+	    STACKTRACE;
+	    AGVector2 currentVec=*vecSet.begin();
+	    vecSet.erase(vecSet.begin());
+	    std::vector<std::pair<AGVector2,float> > newVecs;
+	    {
+	      STACKTRACE;
+	      newVecs=pComputer.getAllReachableFrom(currentVec);
+	    }
+	    //	    cdebug("newVecs:"<<newVecs.size());
+	    for(std::vector<std::pair<AGVector2,float> >::iterator ni=newVecs.begin();ni!=newVecs.end();ni++)
+	      {
+		STACKTRACE;
+		// FIXME: check if in "my Field" or neighbor !!!
+		if(ni->first!=*i) // don't store initial vector
+		  {
+		    STACKTRACE;
+		    if(baseVectors.find(ni->first)!=baseVectors.end())
+		      {
+			STACKTRACE;
+			std::map<AGVector2,float>::iterator found=curDists.find(ni->first);
+			if(ni->second>0)
+			  if(found==curDists.end() || (found->second>ni->second))
+			    //			if((curDists[ni->first]>ni->second || curDists[ni->first]==0) && ni->second>0)
+			    {
+			      STACKTRACE;
+			      curDists[ni->first]=ni->second;
+			      vecSet.insert(ni->first);
+			    }
+		      }
+		  }
+	      }
+
+	  }
+	
+
+
+	// store them into the distance-field
+
+	for(std::map<AGVector2,float>::iterator di=curDists.begin();di!=curDists.end();di++)
+	  {
+	    STACKTRACE;
+	    mDistances.insert(std::make_pair(std::make_pair(*i,di->first),di->second));
+	  }
+	
+      }
+  }
+
+  // FIXME: make this const !
+  float FieldWithDistances::getDistance(const AGVector2 &a,const AGVector2 &b)
+  {
+    return mDistances[std::make_pair(a,b)];
+  }
+
+
+
+////////////////////////////////////////////////////////
+// FieldWithNeighborDistances
+////////////////////////////////////////////////////////
+FieldWithNeighborDistances::FieldWithNeighborDistances(const AGVector2 &pMiddle,size_t pID):
+  FieldWithDistances(pMiddle,pID)
+{
 }
+
+// from my a to b, that is in neighbor field
+void FieldWithNeighborDistances::setNeighborDistance(const AGVector2 &a,const AGVector2 &b,float value)
+{
+  mNeighborDistances[std::make_pair(a,b)]=value;
+}
+float FieldWithNeighborDistances::getNeighborDistance(const AGVector2 &a,const AGVector2 &b)
+{
+  return mNeighborDistances[std::make_pair(a,b)];
+}
+
+void FieldWithNeighborDistances::setFieldDistance(const AGVector2 &a,size_t pField,float value)
+{
+  mFieldDistances[std::make_pair(a,pField)]=value;
+}
+float FieldWithNeighborDistances::getFieldDistance(const AGVector2 &a,size_t pField)
+{
+  return mFieldDistances[std::make_pair(a,pField)];
+}
+
+
+
+
+
+
+
+////////////////////////////////////////////////////////
+// FieldCollectionWithDistances
+////////////////////////////////////////////////////////
+
+
+
+Field *FieldCollectionWithDistances::createField(const AGVector2 &pMiddle,size_t pId)
+{
+  return new FieldWithNeighborDistances(pMiddle,pId);
+}
+
+
+void FieldCollectionWithDistances::computeFieldNeighbors()
+{
+  if(mFieldNeighbors.size()>0)
+    return;
+  for(size_t i=0;i<getFieldCount();i++)
+    {
+      std::set<size_t> ns;
+      std::vector<AGVector2> vs=getField(i)->getNeighbors();
+      for(std::vector<AGVector2>::iterator j=vs.begin();j!=vs.end();j++)
+	{
+	  size_t id=getFieldId(*j);
+	  if(id<getFieldCount())
+	    ns.insert(id);
+	}
+      mFieldNeighbors[i]=ns;
+    }
+}
+
+std::set<size_t> FieldCollectionWithDistances::getNeighborFields(size_t fieldNum)
+{
+  return mFieldNeighbors[fieldNum];
+}
+
+
+void FieldCollectionWithDistances::computeDistances(const DistanceComputer &pDist)
+{
+
+  computeFieldNeighbors();
+
+  for(size_t fieldNum=0;fieldNum<getFieldCount();fieldNum++)
+    {
+      STACKTRACE;
+      std::set<size_t> fields;
+
+      if(true)
+	fields=getNeighborFields(fieldNum);
+      else
+	fields.insert(fieldNum);
+
+      std::vector<AGVector2> vectors;
+
+      fields.insert(fieldNum);
+
+      for(std::set<size_t>::iterator i=fields.begin();i!=fields.end();i++)
+	{
+	  assert(*i<getFieldCount());
+	  std::vector<AGVector2> tmp=getField(*i)->getVectors();
+	  std::copy(tmp.begin(),tmp.end(),std::back_inserter(vectors));
+	}
+      Field *f=getField(fieldNum);
+      FieldWithDistances *df=dynamic_cast<FieldWithDistances*>(f);
+      assert(df);
+      cdebug("FIELD:"<<fieldNum<<" vecs:"<<vectors.size());
+      df->initLocalDistances(pDist,vectors);
+    }
+
+
+
+
+  /*
+  for(size_t fieldNum=0;fieldNum<getFieldCount();fieldNum++)
+    {
+      cdebug("fieldNum:"<<fieldNum<<" of "<<getFieldCount());
+      FieldWithNeighborDistances *curField=dynamic_cast<FieldWithNeighborDistances*>(getField(fieldNum));
+      assert(curField);
+      if(curField)
+	{
+	  std::vector<AGVector2> curVectors=curField->getVectors();
+	  std::vector<AGVector2> curNeighbors=curField->getNeighbors();
+	  std::map<std::pair<AGVector2,AGVector2>,float> distances;
+	  
+	  cdebug("curVectors:"<<curVectors.size());
+	  cdebug("curNeighbors:"<<curNeighbors.size());
+
+	  for(std::vector<AGVector2>::iterator curVector=curVectors.begin();curVector!=curVectors.end();curVector++)
+	    {
+	      for(std::vector<AGVector2>::iterator curNeighbor=curNeighbors.begin();curNeighbor!=curNeighbors.end();curNeighbor++)
+		{
+		  size_t neighborField=getFieldId(*curNeighbor);
+
+		  if(neighborField<getFieldCount()) // check if field is valid
+		    {
+		      FieldWithNeighborDistances *curField2=dynamic_cast<FieldWithNeighborDistances*>(getField(neighborField));
+		      assert(curField2);
+		      if(curField2)
+			{
+			  std::vector<AGVector2> field2Vecs=curField2->getVectors();
+			  for(std::vector<AGVector2>::iterator field2Vec=field2Vecs.begin();field2Vec!=field2Vecs.end();field2Vec++)
+			    {
+			      float nDist=curField->getDistance(*curVector,*curNeighbor)+curField2->getDistance(*curNeighbor,*field2Vec);
+			      std::pair<AGVector2,AGVector2> index(*curVector,*field2Vec);
+			      float oldDist=distances[index];
+			      if(oldDist==0 || oldDist>nDist)
+				distances[index]=nDist;
+			    }
+			}
+		    }
+		}
+	    }
+	}
+    }
+
+  */
+}
+
+
+
+
+
+//}

Modified: antargis/branches/rant/ext/game/path_data_v3.h
===================================================================
--- antargis/branches/rant/ext/game/path_data_v3.h	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/game/path_data_v3.h	2007-08-15 17:33:15 UTC (rev 1156)
@@ -10,14 +10,16 @@
 #include <vector>
 #include <map>
 #include <set>
+#include <ag_rubyobj.h>
 
-namespace PathFinding
-{
+//namespace PathFinding
+//{
 
-  class AGEXPORT Field
+  class AGEXPORT Field:public AGRubyObject
   {
   public:
     Field(const AGVector2 &pMiddle,size_t pID);
+    virtual ~Field();
 
     void insert(const AGVector2 &v,DistanceComputer &pDist);
 
@@ -26,18 +28,24 @@
 
     AGVector2 getMiddle() const;
 
+    std::vector<AGVector2> getVectors() const;
+    std::vector<AGVector2> getNeighbors() const;
+
   private:
     size_t mID;
+  protected:
     std::set<AGVector2> mVectors;
 
     std::set<AGVector2> mNeighbors;
-
+  private:
     AGVector2 mMiddle;
   };
 
-  class AGEXPORT FieldCollection
+  class AGEXPORT FieldCollection:public AGRubyObject
   {
   public:
+    virtual ~FieldCollection();
+
     void assign(const AGVector2 &v,size_t pField,DistanceComputer &pDist);
     size_t newField(const AGVector2 &pMiddle);
 
@@ -47,21 +55,86 @@
 
     size_t getFieldCount() const;
 
+    void mark();
+
+  protected:
+    virtual Field *createField(const AGVector2 &pMiddle,size_t pId);
+
   private:
-    std::vector<Field> mFields;
+
+
+    std::vector<Field*> mFields;
     std::map<AGVector2,size_t> mVec2Field;
   };
 
+class AGEXPORT FieldCollectionWithDistances:public FieldCollection
+{
+ public:
+  /*
+    Does the following:
+    1) save distances from vec a => vec b (in neighboring fields) into fieldwithneighbordistances.neighbordistances
+    2) compute this.mDistances from middle to middle
+    * 3) save distances from vec a => neighbor middle from there to field x in fieldwithneighbordistances.fielddistance
+    * last is not needed necessarily
+   */
+  void computeDistances(const DistanceComputer &pDist);
 
-AGEXPORT void assignFields(FieldCollection &pCollection,DistanceComputer &pDist,size_t pFieldCount);
+  void computeFieldNeighbors();
 
+  std::set<size_t> getNeighborFields(size_t fieldNum);
 
+
+  protected:
+  virtual Field *createField(const AGVector2 &pMiddle,size_t pId);
+    
+ private:
+  std::map<size_t,size_t> mDistances;
+  std::map<size_t,std::set<size_t> > mFieldNeighbors;
+};
+
+
+  AGEXPORT void assignFields(FieldCollection &pCollection,DistanceComputer &pDist,size_t pFieldCount);
+
+
   class AGEXPORT FieldAssigner
   {
   public:
     
   };
-}
 
+  class AGEXPORT FieldWithDistances:public Field
+  {
+  public:
+    FieldWithDistances(const AGVector2 &pMiddle,size_t pID);
+
+
+    void initLocalDistances(const DistanceComputer &pComputer,const std::vector<AGVector2> &pVectors);
+    
+    float getDistance(const AGVector2 &a,const AGVector2 &b);
+
+    
+  private:
+    std::map<std::pair<AGVector2,AGVector2>,float> mDistances;
+  };
+
+class AGEXPORT FieldWithNeighborDistances:public FieldWithDistances
+{
+ public:
+  FieldWithNeighborDistances(const AGVector2 &pMiddle,size_t pID);
+
+  // from my a to b, that is in neighbor field
+  void setNeighborDistance(const AGVector2 &a,const AGVector2 &b,float value);
+  float getNeighborDistance(const AGVector2 &a,const AGVector2 &b);
+
+  void setFieldDistance(const AGVector2 &a,size_t pField,float value);
+  float getFieldDistance(const AGVector2 &a,size_t pField);
+
+ private:
+  std::map<std::pair<AGVector2,AGVector2>,float> mNeighborDistances;
+  std::map<std::pair<AGVector2,size_t>, float> mFieldDistances;
+};
+
+//}
+
 #endif
 

Modified: antargis/branches/rant/ext/game/path_v2.cc
===================================================================
--- antargis/branches/rant/ext/game/path_v2.cc	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/game/path_v2.cc	2007-08-15 17:33:15 UTC (rev 1156)
@@ -57,9 +57,9 @@
       curPos=queue.front();
       queue.pop_front();
       cDist=distances[curPos];
-      std::map<AGVector2,float> neighbors=pCalc.getAllReachableFrom(curPos);
+      std::vector<std::pair<AGVector2,float> > neighbors=pCalc.getAllReachableFrom(curPos);
 
-      for(std::map<AGVector2,float>::iterator i=neighbors.begin();i!=neighbors.end();i++)
+      for(std::vector<std::pair<AGVector2,float> >::iterator i=neighbors.begin();i!=neighbors.end();i++)
 	{
 	  nextDist=cDist+i->second;
 	  oldDist=distances[i->first];
@@ -190,11 +190,11 @@
 	  growField.erase(currentPoint);
 	  mVec2Field[currentPoint]=mFields.size();
 
-	  std::map<AGVector2,float> reachable=pCalc.getAllReachableFrom(currentPoint);
+	  std::vector<std::pair<AGVector2,float> > reachable=pCalc.getAllReachableFrom(currentPoint);
 
 	  //	  cdebug("reachable:"<<reachable.size()<<" currentPoint:"<<currentPoint);
 
-	  for(std::map<AGVector2,float>::iterator i=reachable.begin();i!=reachable.end();i++)
+	  for(std::vector<std::pair<AGVector2,float> >::iterator i=reachable.begin();i!=reachable.end();i++)
 	    {
 	      //	      cdebug("1");
 	      if(growField.find(i->first)==growField.end())

Modified: antargis/branches/rant/ext/game/path_vector_sort.h
===================================================================
--- antargis/branches/rant/ext/game/path_vector_sort.h	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/game/path_vector_sort.h	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,6 +1,8 @@
 #ifndef PATH_VECTOR_SORT_H
 #define PATH_VECTOR_SORT_H
 
+#include <ag_geometry.h>
+
 class DistanceOrder
 {
 public:
@@ -9,7 +11,14 @@
   }
   bool operator()(const AGVector2 &a,const AGVector2 &b) const
   {
-    return (a-mBase).length2()<(b-mBase).length2();
+    float la=(a-mBase).length2();
+    float lb=(b-mBase).length2();
+    if(la<lb)
+      return true;
+    if(la>lb)
+      return false;
+
+    return a<b;
   }
 private:
   AGVector2 mBase;

Modified: antargis/branches/rant/ext/game/path_weighter.cc
===================================================================
--- antargis/branches/rant/ext/game/path_weighter.cc	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/game/path_weighter.cc	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,6 +1,7 @@
 #include "path_weighter.h"
 
 #include <ag_debug.h>
+#include <ag_profiler.h>
 #include "height_map.h"
 #include <math.h>
 
@@ -56,6 +57,7 @@
 // FIXME: maybe move this to other class ?
 float DistanceComputer::simpleWeight(const AGVector2 &a,const AGVector2 &b) const
 {
+  STACKTRACE;
   float ha=mHeightMap->getHeight(a[0],a[1]);
   float hb=mHeightMap->getHeight(b[0],b[1]);
 
@@ -70,9 +72,11 @@
 /**
  * compute possible neighbors (w.r.t. to map-borders)
  */
-std::list<AGVector2> DistanceComputer::getNeighbors(const AGVector2 &p) const
+std::vector<AGVector2> DistanceComputer::getNeighbors(const AGVector2 &p) const
 {
-  std::list<AGVector2> diffList,rList;
+  STACKTRACE;
+
+  std::vector<AGVector2> diffList,rList;
   AGVector2 t;
 
   diffList.push_back(AGVector2(-stepX(),0));
@@ -80,37 +84,53 @@
   diffList.push_back(AGVector2(0,-stepY()));
   diffList.push_back(AGVector2(0,+stepY()));
 
-  for(std::list<AGVector2>::iterator i=diffList.begin();i!=diffList.end();i++)
+  /*  
+  diffList.push_back(AGVector2(-stepX(),-stepY()));
+  diffList.push_back(AGVector2(+stepX(),-stepY()));
+  diffList.push_back(AGVector2(-stepX(),+stepY()));
+  diffList.push_back(AGVector2(+stepX(),+stepY()));
+  */
+  for(std::vector<AGVector2>::iterator i=diffList.begin();i!=diffList.end();i++)
     {
       t=*i+p;
-      if(t.getX() >= beginX() &&
-	 t.getX()<=endX() && 
-	 t.getY()>=beginY() && 
-	 t.getY()<=endY())
-	rList.push_back(t);
+      {
+	STACKTRACE;
+	
+	if(t.getX() >= beginX() &&
+	   t.getX()<=endX() && 
+	   t.getY()>=beginY() && 
+	   t.getY()<=endY())
+	  rList.push_back(t);
+      }
     }
 
   return rList;
 }
 
-std::map<AGVector2,float> DistanceComputer::getAllReachableFrom(const AGVector2 &p) const
+std::vector<std::pair<AGVector2,float> > DistanceComputer::getAllReachableFrom(const AGVector2 &p) const
 {
+  STACKTRACE;
   float w;
-  std::map<AGVector2,float> rList;
-  std::list<AGVector2> nList=getNeighbors(p);
+  std::vector<std::pair<AGVector2,float> > rList;
+  std::vector<AGVector2> nList=getNeighbors(p);
 
-  for(std::list<AGVector2>::iterator i=nList.begin();i!=nList.end();i++)
+  for(std::vector<AGVector2>::iterator i=nList.begin();i!=nList.end();i++)
     {
-      w=simpleWeight(p,*i);
-      rList.insert(std::make_pair(*i,w));
+      STACKTRACE;
+
+      {
+	w=simpleWeight(p,*i);
+	STACKTRACE;
+      }
+      rList.push_back(std::make_pair(*i,w));
     }
   return rList;
 }
 
 
-std::list<AGVector2> DistanceComputer::getAllPassable() const
+std::vector<AGVector2> DistanceComputer::getAllPassable() const
 {
-  std::list<AGVector2> l;
+  std::vector<AGVector2> l;
 
   float x,y;
   AGVector2 v(x,y);

Modified: antargis/branches/rant/ext/game/path_weighter.h
===================================================================
--- antargis/branches/rant/ext/game/path_weighter.h	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/game/path_weighter.h	2007-08-15 17:33:15 UTC (rev 1156)
@@ -27,17 +27,17 @@
   float width() const;
   float height() const;
 
-  std::map<AGVector2,float> getAllReachableFrom(const AGVector2 &p) const;
+  std::vector<std::pair<AGVector2,float> > getAllReachableFrom(const AGVector2 &p) const;
 
   // compute weight for to neighboring points (from a to b)
   float simpleWeight(const AGVector2 &a,const AGVector2 &b) const;
 
   bool isPassable(const AGVector2 &pPoint) const;
 
-  std::list<AGVector2> getNeighbors(const AGVector2 &p) const;
+  std::vector<AGVector2> getNeighbors(const AGVector2 &p) const;
 
 
-  std::list<AGVector2> getAllPassable() const;
+  std::vector<AGVector2> getAllPassable() const;
 
  private:
 

Modified: antargis/branches/rant/ext/game/templates.i
===================================================================
--- antargis/branches/rant/ext/game/templates.i	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/game/templates.i	2007-08-15 17:33:15 UTC (rev 1156)
@@ -27,3 +27,4 @@
 %template(EntityVector) std::vector<AntEntityPtr>;
 %template(ResourceMap) std::map<std::string,float>;
 %template(AGResourceMap) std::map<AGString,float>;
+%template(AGVector2Pair) std::pair<AGVector2,AGVector2>;
\ No newline at end of file

Modified: antargis/branches/rant/ext/gui/headers.hh
===================================================================
--- antargis/branches/rant/ext/gui/headers.hh	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/gui/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,88 +1,88 @@
-#ifndef __ANTARGIS_H__
-#define __ANTARGIS_H__
-#include "ext/basic/ag_config.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_geometry.h"
-#include "ext/basic/ag_main.h"
-#include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_rubyobj.h"
-#include "ext/basic/ag_serial.h"
-#include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_string_utf8.h"
-#include "ext/basic/ag_utf8.h"
-#include "ext/basic/ag_video_base.h"
-#include "ext/basic/ag_xml.h"
-#include "ext/math/ag_algebra.h"
-#include "ext/math/ag_rand.h"
-#include "ext/math/ant_frustum.h"
-#include "ext/video/ag_clip.h"
-#include "ext/video/ag_color.h"
-#include "ext/video/ag_font.h"
-#include "ext/video/ag_fontengine.h"
-#include "ext/video/ag_painter.h"
-#include "ext/video/ag_painttarget.h"
-#include "ext/video/ag_rendercontext.h"
-#include "ext/video/ag_screen.h"
-#include "ext/video/ag_surface.h"
-#include "ext/video/ag_texture.h"
-#include "ext/video/ag_texturecache.h"
-#include "ext/video/ag_video.h"
-#include "ext/gui/ag_layoutfactory.h"
-#include "ext/gui/ag_widget.h"
-#include "ext/gui/ag_application.h"
-#include "ext/gui/ag_table.h"
-#include "ext/gui/ag_layout.h"
-#include "ext/gui/ag_colorbutton.h"
-#include "ext/gui/ag_image.h"
-#include "ext/gui/ag_screenwidget.h"
-#include "ext/gui/ag_listbox.h"
-#include "ext/gui/ag_frame.h"
-#include "ext/gui/ag_text.h"
-#include "ext/gui/ag_button.h"
-#include "ext/gui/ag_edit.h"
-#include "ext/gui/ag_radiogroup.h"
-#include "ext/gui/ag_scroller.h"
-#include "ext/gui/ag_tooltip.h"
-#include "ext/gui/ag_combo.h"
-#include "ext/gui/ag_menu.h"
-#include "ext/gui/ag_caption.h"
-#include "ext/gui/ag_window.h"
-#include "ext/gui/ag_checkbox.h"
-#include "ext/gui/ag_menuitem.h"
-#include "ext/gui/ag_radio.h"
-#include "ext/gui/ag_theme.h"
-#include "ext/gui/ag_border.h"
-#include "ext/gui/ag_background.h"
-#include "ext/gui/ag_local.h"
-#ifdef SWIG
-%include "ext/gui/ag_layoutfactory.h"
-%include "ext/gui/ag_widget.h"
-%include "ext/gui/ag_application.h"
-%include "ext/gui/ag_table.h"
-%include "ext/gui/ag_layout.h"
-%include "ext/gui/ag_colorbutton.h"
-%include "ext/gui/ag_image.h"
-%include "ext/gui/ag_screenwidget.h"
-%include "ext/gui/ag_listbox.h"
-%include "ext/gui/ag_frame.h"
-%include "ext/gui/ag_text.h"
-%include "ext/gui/ag_button.h"
-%include "ext/gui/ag_edit.h"
-%include "ext/gui/ag_radiogroup.h"
-%include "ext/gui/ag_scroller.h"
-%include "ext/gui/ag_tooltip.h"
-%include "ext/gui/ag_combo.h"
-%include "ext/gui/ag_menu.h"
-%include "ext/gui/ag_caption.h"
-%include "ext/gui/ag_window.h"
-%include "ext/gui/ag_checkbox.h"
-%include "ext/gui/ag_menuitem.h"
-%include "ext/gui/ag_radio.h"
-%include "ext/gui/ag_theme.h"
-%include "ext/gui/ag_border.h"
-%include "ext/gui/ag_background.h"
-%include "ext/gui/ag_local.h"
-#endif
-#endif
+#ifndef __ANTARGIS_H__
+#define __ANTARGIS_H__
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_stringstream.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_video_base.h"
+#include "ext/basic/ag_xml.h"
+#include "ext/basic/ag_singleton.h"
+#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_geometry.h"
+#include "ext/math/ag_rand.h"
+#include "ext/math/ant_frustum.h"
+#include "ext/math/ag_algebra.h"
+#include "ext/video/ag_screen.h"
+#include "ext/video/ag_video.h"
+#include "ext/video/ag_painttarget.h"
+#include "ext/video/ag_color.h"
+#include "ext/video/ag_fontengine.h"
+#include "ext/video/ag_font.h"
+#include "ext/video/ag_surface.h"
+#include "ext/video/ag_texture.h"
+#include "ext/video/ag_rendercontext.h"
+#include "ext/video/ag_texturecache.h"
+#include "ext/video/ag_clip.h"
+#include "ext/video/ag_painter.h"
+#include "ext/gui/ag_layoutfactory.h"
+#include "ext/gui/ag_widget.h"
+#include "ext/gui/ag_application.h"
+#include "ext/gui/ag_table.h"
+#include "ext/gui/ag_layout.h"
+#include "ext/gui/ag_colorbutton.h"
+#include "ext/gui/ag_image.h"
+#include "ext/gui/ag_screenwidget.h"
+#include "ext/gui/ag_listbox.h"
+#include "ext/gui/ag_frame.h"
+#include "ext/gui/ag_text.h"
+#include "ext/gui/ag_button.h"
+#include "ext/gui/ag_edit.h"
+#include "ext/gui/ag_radiogroup.h"
+#include "ext/gui/ag_scroller.h"
+#include "ext/gui/ag_tooltip.h"
+#include "ext/gui/ag_combo.h"
+#include "ext/gui/ag_menu.h"
+#include "ext/gui/ag_caption.h"
+#include "ext/gui/ag_window.h"
+#include "ext/gui/ag_checkbox.h"
+#include "ext/gui/ag_menuitem.h"
+#include "ext/gui/ag_radio.h"
+#include "ext/gui/ag_theme.h"
+#include "ext/gui/ag_border.h"
+#include "ext/gui/ag_background.h"
+#include "ext/gui/ag_local.h"
+#ifdef SWIG
+%include "ext/gui/ag_layoutfactory.h"
+%include "ext/gui/ag_widget.h"
+%include "ext/gui/ag_application.h"
+%include "ext/gui/ag_table.h"
+%include "ext/gui/ag_layout.h"
+%include "ext/gui/ag_colorbutton.h"
+%include "ext/gui/ag_image.h"
+%include "ext/gui/ag_screenwidget.h"
+%include "ext/gui/ag_listbox.h"
+%include "ext/gui/ag_frame.h"
+%include "ext/gui/ag_text.h"
+%include "ext/gui/ag_button.h"
+%include "ext/gui/ag_edit.h"
+%include "ext/gui/ag_radiogroup.h"
+%include "ext/gui/ag_scroller.h"
+%include "ext/gui/ag_tooltip.h"
+%include "ext/gui/ag_combo.h"
+%include "ext/gui/ag_menu.h"
+%include "ext/gui/ag_caption.h"
+%include "ext/gui/ag_window.h"
+%include "ext/gui/ag_checkbox.h"
+%include "ext/gui/ag_menuitem.h"
+%include "ext/gui/ag_radio.h"
+%include "ext/gui/ag_theme.h"
+%include "ext/gui/ag_border.h"
+%include "ext/gui/ag_background.h"
+%include "ext/gui/ag_local.h"
+#endif
+#endif

Modified: antargis/branches/rant/ext/math/ag_serial_vec.cc
===================================================================
--- antargis/branches/rant/ext/math/ag_serial_vec.cc	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/math/ag_serial_vec.cc	2007-08-15 17:33:15 UTC (rev 1156)
@@ -17,3 +17,19 @@
 }
 
 
+BinaryOut &operator<<(BinaryOut &o,const AGVector2 &v)
+{
+  o<<v[0]<<v[1];
+  return o;
+}
+
+BinaryOut &operator<<(BinaryOut &o,const AGVector3 &v)
+{
+  o<<v[0]<<v[1]<<v[2];
+  return o;
+}
+BinaryOut &operator<<(BinaryOut &o,const AGVector4 &v)
+{
+  o<<v[0]<<v[1]<<v[2]<<v[3];
+  return o;
+}

Modified: antargis/branches/rant/ext/math/ag_serial_vec.h
===================================================================
--- antargis/branches/rant/ext/math/ag_serial_vec.h	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/math/ag_serial_vec.h	2007-08-15 17:33:15 UTC (rev 1156)
@@ -8,5 +8,9 @@
 AGEXPORT BinaryIn &operator>>(BinaryIn &i,AGVector3 &v);
 AGEXPORT BinaryIn &operator>>(BinaryIn &i,AGVector4 &v);
 
+AGEXPORT BinaryOut &operator<<(BinaryOut &i,const AGVector2 &v);
+AGEXPORT BinaryOut &operator<<(BinaryOut &i,const AGVector3 &v);
+AGEXPORT BinaryOut &operator<<(BinaryOut &i,const AGVector4 &v);
 
+
 #endif

Modified: antargis/branches/rant/ext/math/headers.hh
===================================================================
--- antargis/branches/rant/ext/math/headers.hh	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/math/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,25 +1,25 @@
-#ifndef __ANTARGIS_H__
-#define __ANTARGIS_H__
-#include "ext/basic/ag_config.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_geometry.h"
-#include "ext/basic/ag_main.h"
-#include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_rubyobj.h"
-#include "ext/basic/ag_serial.h"
-#include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_string_utf8.h"
-#include "ext/basic/ag_utf8.h"
-#include "ext/basic/ag_video_base.h"
-#include "ext/basic/ag_xml.h"
-#include "ext/math/ag_rand.h"
-#include "ext/math/ant_frustum.h"
-#include "ext/math/ag_algebra.h"
-#ifdef SWIG
-%include "ext/math/ag_rand.h"
-%include "ext/math/ant_frustum.h"
-%include "ext/math/ag_algebra.h"
-#endif
-#endif
+#ifndef __ANTARGIS_H__
+#define __ANTARGIS_H__
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_stringstream.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_video_base.h"
+#include "ext/basic/ag_xml.h"
+#include "ext/basic/ag_singleton.h"
+#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_geometry.h"
+#include "ext/math/ag_rand.h"
+#include "ext/math/ant_frustum.h"
+#include "ext/math/ag_algebra.h"
+#ifdef SWIG
+%include "ext/math/ag_rand.h"
+%include "ext/math/ant_frustum.h"
+%include "ext/math/ag_algebra.h"
+#endif
+#endif

Deleted: antargis/branches/rant/ext/ruby/ag_rtools.cc
===================================================================
--- antargis/branches/rant/ext/ruby/ag_rtools.cc	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/ruby/ag_rtools.cc	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,29 +0,0 @@
-#include <ag_rtools.h>
-
-#include <ruby.h>
-
-#include <iostream>
-#include <sstream>
-
-std::string rubyHash(const std::string &p)
-{
-  // FIXME: TRY USING ruby's Digest::MD5::digest("xy")
-  rb_eval_string("require 'digest/md5'");
-
-  //  VALUE l=rb_gv_get("Digest::MD5");
-  //  VALUE r=rb_funcall(l,rb_intern("digest"),1,rb_str_new2(p.c_str()));
-
-  std::ostringstream os;
-  os<<"s=''; Digest::MD5::digest('"<<p<<"').each_byte{|b|s+=sprintf('%X',b)};s";
-
-  VALUE r=rb_eval_string(os.str().c_str());
-
-  std::string s;
-
-  s=STR2CSTR(r);
-
-  std::cout<<"p:"<<p<<std::endl;
-  std::cout<<"s:"<<s<<std::endl;
-
-  return s;
-}

Deleted: antargis/branches/rant/ext/ruby/ag_rtools.h
===================================================================
--- antargis/branches/rant/ext/ruby/ag_rtools.h	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/ruby/ag_rtools.h	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,10 +0,0 @@
-#ifndef AG_RTOOLS_H
-#define AG_RTOOLS_H
-
-#include <string>
-
-std::string rubyHash(const std::string &p);
-
-
-
-#endif

Modified: antargis/branches/rant/ext/ruby/headers.hh
===================================================================
--- antargis/branches/rant/ext/ruby/headers.hh	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/ruby/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,5 +1,19 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_stringstream.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_video_base.h"
+#include "ext/basic/ag_xml.h"
+#include "ext/basic/ag_singleton.h"
+#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_geometry.h"
 
 #ifdef SWIG
 

Modified: antargis/branches/rant/ext/sound/headers.hh
===================================================================
--- antargis/branches/rant/ext/sound/headers.hh	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/sound/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,21 +1,21 @@
-#ifndef __ANTARGIS_H__
-#define __ANTARGIS_H__
-#include "ext/basic/ag_config.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_geometry.h"
-#include "ext/basic/ag_main.h"
-#include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_rubyobj.h"
-#include "ext/basic/ag_serial.h"
-#include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_string_utf8.h"
-#include "ext/basic/ag_utf8.h"
-#include "ext/basic/ag_video_base.h"
-#include "ext/basic/ag_xml.h"
-#include "ext/sound/ag_mixer.h"
-#ifdef SWIG
-%include "ext/sound/ag_mixer.h"
-#endif
-#endif
+#ifndef __ANTARGIS_H__
+#define __ANTARGIS_H__
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_stringstream.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_video_base.h"
+#include "ext/basic/ag_xml.h"
+#include "ext/basic/ag_singleton.h"
+#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_geometry.h"
+#include "ext/sound/ag_mixer.h"
+#ifdef SWIG
+%include "ext/sound/ag_mixer.h"
+#endif
+#endif

Modified: antargis/branches/rant/ext/video/headers.hh
===================================================================
--- antargis/branches/rant/ext/video/headers.hh	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ext/video/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
@@ -1,46 +1,46 @@
-#ifndef __ANTARGIS_H__
-#define __ANTARGIS_H__
-#include "ext/basic/ag_config.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_geometry.h"
-#include "ext/basic/ag_main.h"
-#include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_rubyobj.h"
-#include "ext/basic/ag_serial.h"
-#include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_string_utf8.h"
-#include "ext/basic/ag_utf8.h"
-#include "ext/basic/ag_video_base.h"
-#include "ext/basic/ag_xml.h"
-#include "ext/math/ag_algebra.h"
-#include "ext/math/ag_rand.h"
-#include "ext/math/ant_frustum.h"
-#include "ext/video/ag_painttarget.h"
-#include "ext/video/ag_surface.h"
-#include "ext/video/ag_texture.h"
-#include "ext/video/ag_screen.h"
-#include "ext/video/ag_fontengine.h"
-#include "ext/video/ag_video.h"
-#include "ext/video/ag_clip.h"
-#include "ext/video/ag_rendercontext.h"
-#include "ext/video/ag_texturecache.h"
-#include "ext/video/ag_font.h"
-#include "ext/video/ag_painter.h"
-#include "ext/video/ag_color.h"
-#ifdef SWIG
-%include "ext/video/ag_painttarget.h"
-%include "ext/video/ag_surface.h"
-%include "ext/video/ag_texture.h"
-%include "ext/video/ag_screen.h"
-%include "ext/video/ag_fontengine.h"
-%include "ext/video/ag_video.h"
-%include "ext/video/ag_clip.h"
-%include "ext/video/ag_rendercontext.h"
-%include "ext/video/ag_texturecache.h"
-%include "ext/video/ag_font.h"
-%include "ext/video/ag_painter.h"
-%include "ext/video/ag_color.h"
-#endif
-#endif
+#ifndef __ANTARGIS_H__
+#define __ANTARGIS_H__
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_stringstream.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_video_base.h"
+#include "ext/basic/ag_xml.h"
+#include "ext/basic/ag_singleton.h"
+#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_geometry.h"
+#include "ext/math/ag_rand.h"
+#include "ext/math/ant_frustum.h"
+#include "ext/math/ag_algebra.h"
+#include "ext/video/ag_painttarget.h"
+#include "ext/video/ag_surface.h"
+#include "ext/video/ag_texture.h"
+#include "ext/video/ag_screen.h"
+#include "ext/video/ag_fontengine.h"
+#include "ext/video/ag_video.h"
+#include "ext/video/ag_clip.h"
+#include "ext/video/ag_rendercontext.h"
+#include "ext/video/ag_texturecache.h"
+#include "ext/video/ag_font.h"
+#include "ext/video/ag_painter.h"
+#include "ext/video/ag_color.h"
+#ifdef SWIG
+%include "ext/video/ag_painttarget.h"
+%include "ext/video/ag_surface.h"
+%include "ext/video/ag_texture.h"
+%include "ext/video/ag_screen.h"
+%include "ext/video/ag_fontengine.h"
+%include "ext/video/ag_video.h"
+%include "ext/video/ag_clip.h"
+%include "ext/video/ag_rendercontext.h"
+%include "ext/video/ag_texturecache.h"
+%include "ext/video/ag_font.h"
+%include "ext/video/ag_painter.h"
+%include "ext/video/ag_color.h"
+#endif
+#endif

Modified: antargis/branches/rant/ruby/ant_hljobs.rb
===================================================================
--- antargis/branches/rant/ruby/ant_hljobs.rb	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ruby/ant_hljobs.rb	2007-08-15 17:33:15 UTC (rev 1156)
@@ -204,7 +204,8 @@
 		@waypoints.unshift(@hero.getPos2D)
 		@waypoints.push(@pos)
 		if getMap.path
-			@waypoints=getMap.path.refinePath(@waypoints,MapPathWeighter.new(getMap))
+			puts "FIXME: ant_hljobs.rb:207"
+			#@waypoints=getMap.path.refinePath(@waypoints,MapPathWeighter.new(getMap))
 		end
 		@men=getMen
 		@moveFinished=false

Modified: antargis/branches/rant/ruby/entities/ant_deco.rb
===================================================================
--- antargis/branches/rant/ruby/entities/ant_deco.rb	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ruby/entities/ant_deco.rb	2007-08-15 17:33:15 UTC (rev 1156)
@@ -79,7 +79,7 @@
 # 			else
 				#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/ant_coach.ant2",0.08,"data/textures/models/ant_coach.png"),AGVector4.new(0,0,0,0),-50))
 # 		end
-		setMesh(createModel(:coach))
+		setMesh(AntModels.createModel(:coach))
 	end
 	def saveXML(node)
 		super

Modified: antargis/branches/rant/ruby/entities/ant_hero.rb
===================================================================
--- antargis/branches/rant/ruby/entities/ant_hero.rb	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ruby/entities/ant_hero.rb	2007-08-15 17:33:15 UTC (rev 1156)
@@ -264,7 +264,7 @@
 		case name
 			when "row"
 				setMesh
-				addMesh(createModel(:boat),AGVector3.new(0,0,0))
+				addMesh(AntModels.createModel(:boat),AGVector3.new(0,0,0))
 			when "dead"
 				setMesh(:grave_hero)
 			else

Modified: antargis/branches/rant/ruby/entities/ant_man.rb
===================================================================
--- antargis/branches/rant/ruby/entities/ant_man.rb	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ruby/entities/ant_man.rb	2007-08-15 17:33:15 UTC (rev 1156)
@@ -253,7 +253,7 @@
 			when "row"
 				mesh=setMesh("sit")
 				mesh.setAnimation("sit")
-				addMesh(createModel(:boat),AGVector3.new(0,0,0))
+				addMesh(AntModels.createModel(:boat),AGVector3.new(0,0,0))
 			when "stand","axe","pick","wood","stone","flour","corn","walk","sitdown","sit"
 				setMesh(name)
 				if ["stand","walk","sitdown","sit"].member?(name)

Modified: antargis/branches/rant/ruby/map.rb
===================================================================
--- antargis/branches/rant/ruby/map.rb	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ruby/map.rb	2007-08-15 17:33:15 UTC (rev 1156)
@@ -293,10 +293,6 @@
 		if node.getName=="trigger" then
 			@triggers.push(Trigger.new(node))
 		end
-# 		if e
-# 			e.loadXML(node)
-# 			insertEntity(e)
-# 		end
 	end
 	
 	def loadXML(n)
@@ -322,16 +318,57 @@
 
 		# add pathfinder
 		@mweighter=MapPathWeighter.new(self)
-		@sgraph=makeGraph(self, at mweighter,4)
+		@sgraph=makeGraph(self, at mweighter,2)
 		@dgraph=DecimatedGraph.new(@sgraph)
 
 		factor=0.8
-		factor=1.0-400.0/@dgraph.size
+		factor=1.0-800.0/@dgraph.size
 
+		#factor=0.4
+
+		factor=1.0-220.0/@dgraph.size
+
 		@dgraph.decimate(factor, at mweighter)
-		@heuristic=computeHeuristic(@dgraph)
-		#exit
 
+		if true # display dgraph
+			wireframe=Boa3dWireframe.new(getScene,AGVector4.new(1,0,0,1))
+			(0..(@dgraph.edges-1)).each{|i|
+				edge=@dgraph.getEdgePosition(i)
+				puts edge
+				a=edge[0]
+				b=edge[1]
+				a=AGVector3.new(a.x,a.y,getHeight(a.x,a.y)+0.05)
+				b=AGVector3.new(b.x,b.y,getHeight(b.x,b.y)+0.05)
+				wireframe.addLine(a,b)
+			}
+			getScene.addNode(wireframe)
+			#raise 1
+		end
+
+
+		#raise self.hash
+		# FIXME: insert hash here
+
+		hFilename="heuristic.test"
+
+		if File.exists?(hFilename) and false # FIXME: reenable saving
+			fin=BinaryFileIn.new(hFilename)
+			@heuristic=StoredHeuristicFunction.new(fin)
+		else
+			@heuristic=computeHeuristic(@dgraph)
+			#exit
+	
+	
+			stream=BinaryStringOut.new
+			@heuristic.printTo(stream)
+			f=File.open(hFilename,"w")
+			f.puts stream.getString
+			f.close
+		end
+
+
+		#raise "FIXME"
+
 		# FIXME: readd this when heuristics are better!!!
 		#setHeuristic(@heuristic)
 

Modified: antargis/branches/rant/ruby/tests/path/fields_test2.rb
===================================================================
--- antargis/branches/rant/ruby/tests/path/fields_test2.rb	2007-07-29 17:39:54 UTC (rev 1155)
+++ antargis/branches/rant/ruby/tests/path/fields_test2.rb	2007-08-15 17:33:15 UTC (rev 1156)
@@ -11,7 +11,7 @@
 include Antargismath
 include Antargisbasic
 
-getMain.getVideo.initVideo(640,480,32,false,false)
+getMain.getVideo.initVideo(640,480,32,false,true)
 
 w=16
 h=16
@@ -26,7 +26,8 @@
 
 
 heightMap=AntMap.new(nil,64,64)
-heightMap.loadMap("data/levels/birth/birth2.antlvl")
+heightMap.loadMap("data/levels/tutorial/tutorial2.antlvl")
+#heightMap.loadMap("data/levels/birth/birth3.antlvl")
 
 
 w=heightMap.getW
@@ -35,19 +36,24 @@
 puts "W:#{w} H:#{h}"
 #exit
 
-distComputer=DistanceComputer.new(heightMap,1)
+distComputer=DistanceComputer.new(heightMap,4)
 
-fieldCollection=FieldCollection.new
+puts "creating FieldCollection"
+fieldCollection=FieldCollectionWithDistances.new
 
-assignFields(fieldCollection,distComputer,32)
+puts "assigning Fields"
+assignFields(fieldCollection,distComputer,64)
 
-# puts "ok"
-# exit
+#fieldCollection.computeDistances
 
-# pathData=PathV3Data.new(8)
-# 
-# pathData.compute(distComputer)
+puts "initing distances for field #0"
 
+field=fieldCollection.getField(0)
+puts field
+#field.initLocalDistances(distComputer)
+
+
+
 fsize=4
 
 image=AGSurface.new(w*fsize,h*fsize)
@@ -55,38 +61,55 @@
 def getColor(i)
 	j=i%8
 	j+=1
-	#puts "J:#{j}"
 	AGColor.new((j % 2)*255, ((j /2)%2)*255, (j / 4).to_i*255) #*(255.0-(i*2)/255.0)
 end
 
 
-(0..(w-1)).each{|x|
-	(0..(h-1)).each{|y|
-		#fieldnum=pathData.getField(AGVector2.new(x,y))
-		fieldnum=fieldCollection.getFieldId(AGVector2.new(x,y))
-		if fieldnum<20000
-			#puts "field:#{fieldnum}"
-			color=getColor(fieldnum)
-			#puts "COLOR:#{color}"
-			(0..(fsize-1)).each{|dx|
-				(0..(fsize-1)).each{|dy|
-					image.putPixel(x*fsize+dx,y*fsize+dy,color)
+def displayFieldAssign(fieldCollection,image,w,h,fsize)
+	puts "DISPLAYING DATA"
+	(0..(w-1)).each{|x|
+		(0..(h-1)).each{|y|
+			fieldnum=fieldCollection.getFieldId(AGVector2.new(x,y))
+			if fieldnum<20000
+				color=getColor(fieldnum)
+				(0..(fsize-1)).each{|dx|
+					(0..(fsize-1)).each{|dy|
+						image.putPixel(x*fsize+dx,y*fsize+dy,color)
+					}
 				}
-			}
-		end
+			end
+		}
 	}
+end
+
+def displayDistanceData(field,image)
+	m=field.getMiddle
+	field.getVectors.each{|v|
+		
+		image.putPixel(v.x.to_i,v.y.to_i,AGColor.new(0xFF,0xFF,0xFF)*(1-(v-m).length*0.3))
+	}
+end
+
+def displayNeighbors(field,image)
+	field.getNeighbors.each{|v|
+		image.putPixel(v.x.to_i,v.y.to_i,AGColor.new(0xFF,0,0))
+	}
+end
+puts "COMPUTE  DISTACNES:"
+fieldCollection.computeDistances(distComputer)
+puts "\n\n\nok"
+
+#displayFieldAssign(fieldCollection,image,w,h,fsize)
+(0..(fieldCollection.getFieldCount-1)).each{|num|
+	field=fieldCollection.getField(num)
+	#field.init
+	displayDistanceData(field,image)
+	#displayNeighbors(field,image)
 }
 
 
-#texture=AGTexture.new(image)
-
 app=AGApplication.new
 imageW=AGImage.new(nil,AGRect2.new(0,0,w*fsize,h*fsize),image,false)
-#imageW.setSurface(image)
 app.setMainWidget(imageW)
 app.run
 
-#getScreen.blit(texture,AGRect2.new(0,0,w*fsize,h*fsize),AGRect2.new(0,0,w*fsize,h*fsize))
-#getScreen.flip
-
-#getMain.delay(20000)



From davidkamphausen at mail.berlios.de  Sun Aug 19 15:46:36 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 19 Aug 2007 15:46:36 +0200
Subject: [Antargis-svn] r1157 - in antargis/branches/rant: . build
	build/configs ext/3dengine ext/basic ext/game ext/game/tests
	ext/gui ext/math ext/sound ext/video ruby ruby/tests/3d_engine
Message-ID: <200708191346.l7JDkauZ021283@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-08-19 15:46:33 +0200 (Sun, 19 Aug 2007)
New Revision: 1157

Added:
   antargis/branches/rant/ext/3dengine/ag_glwidget.cc
   antargis/branches/rant/ext/3dengine/ag_glwidget.h
   antargis/branches/rant/ext/3dengine/boa_3d_wireframe.cc
   antargis/branches/rant/ext/3dengine/boa_3d_wireframe.h
   antargis/branches/rant/ext/game/tests/
   antargis/branches/rant/ext/game/tests/test_vector_sort.cc
   antargis/branches/rant/ruby/tests/3d_engine/wireframe.rb
Modified:
   antargis/branches/rant/Rantfile
   antargis/branches/rant/build/base_tools.rb
   antargis/branches/rant/build/configs/unix.rb
   antargis/branches/rant/ext/3dengine/headers.hh
   antargis/branches/rant/ext/basic/ag_rtools.cc
   antargis/branches/rant/ext/basic/ag_serial.cc
   antargis/branches/rant/ext/basic/ag_serial.h
   antargis/branches/rant/ext/basic/headers.hh
   antargis/branches/rant/ext/game/headers.hh
   antargis/branches/rant/ext/game/path.cc
   antargis/branches/rant/ext/game/path.h
   antargis/branches/rant/ext/gui/headers.hh
   antargis/branches/rant/ext/math/headers.hh
   antargis/branches/rant/ext/sound/headers.hh
   antargis/branches/rant/ext/video/ag_video.cc
   antargis/branches/rant/ext/video/headers.hh
   antargis/branches/rant/ruby/ant_hljobs.rb
   antargis/branches/rant/ruby/map.rb
Log:
* many changes for building
* added some missing files


Modified: antargis/branches/rant/Rantfile
===================================================================
--- antargis/branches/rant/Rantfile	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/Rantfile	2007-08-19 13:46:33 UTC (rev 1157)
@@ -5,8 +5,6 @@
 import "rubydoc"
 import "c/dependencies"
 
-#gen C::Dependencies, :sources=> (sys["**/*.cc"]+sys["**/*.c"]+sys["**/*.h"]).select{|f|not (f=~/packages/ or f=~/build/)}
-
 require 'build/base_tools.rb'
 
 puts "ERROR: Please run ./configure before building!" unless File.exists?("config.rb")
@@ -174,13 +172,21 @@
 	end
 }
 ###########################################
-    
 
+
+depC=lambda{|target|
+	source=target.gsub(/\.o$/,".c").gsub(/\.oo$/,".cc")
+	target=sys.expand_path(target)
+	deps=getDependencies(target)
+	#puts "MUH:"+([source]+deps).join(":::")
+	[source]+deps
+}    
+
 ###########################################
 # build c
 #
-gen Rule, '.o' => '.c' do |t|
-	cmd=makeCommand("CC_CALL",sys.expand_path(t.name),"#{var :CFLAGS} #{sys.expand_path(t.source)}")
+gen Rule, '.o' => depC do |t|
+	cmd=makeCommand("CC_CALL",sys.expand_path(t.name),"#{var :CFLAGS} #{(t.source)}")
 	sys cmd
 	puts
 end
@@ -189,8 +195,8 @@
 ###########################################
 # build c++
 #
-gen Rule, '.oo' => '.cc' do |t|
-	cmd=makeCommand("CXX_CALL",sys.expand_path(t.name),"#{var :CFLAGS} #{sys.expand_path(t.source)}")
+gen Rule, '.oo' => depC do |t|
+	cmd=makeCommand("CXX_CALL",sys.expand_path(t.name),"#{var :CFLAGS} #{(t.source)}")
 	sys cmd
 	puts
 end
@@ -205,7 +211,7 @@
 	dir=getDirUnix(target)
     #puts "TARGET:#{target} DIR:#{dir}"
 	name=makeLibName(dir)
-	a=[target.sub(name+"swig.cc","interface.i")]+sys["build/*.i"]+importsForInterface(target).split(":") 
+	a=[target.sub(/#{name}swig.*/,"interface.i")]+sys["build/*.i"]+importsForInterface(target).split(":") 
     puts "A: #{a}"
     puts "name: #{name}"
     puts "dir: #{dir}"
@@ -217,7 +223,7 @@
 
     puts "SOURCE #{t.source} #{t.name}"
 
-	cmd=makeCommand("SWIG_CALL",sys.expand_path(t.name),"-DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR} #{sys.expand_path(t.source)}".gsub("/",Dir.separator))
+	cmd=makeCommand("SWIG_CALL",sys.expand_path(t.name.gsub(/\.h$/,".cc")),"-DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR} #{sys.expand_path(t.source)}".gsub("/",Dir.separator))
 	sys cmd
 	puts
 end
@@ -339,6 +345,7 @@
 gen AutoClean, :clean
 var[:clean].include "**/marker.i"   # not needed any more - managed by Rule
 var[:clean].include "ext/*.so"
+#var[:clean].include ".deps/*"
 ###########################################
 
 

Modified: antargis/branches/rant/build/base_tools.rb
===================================================================
--- antargis/branches/rant/build/base_tools.rb	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/build/base_tools.rb	2007-08-19 13:46:33 UTC (rev 1157)
@@ -18,10 +18,32 @@
 	"antargis"+dir.split("/")[-1]
 end
 
+def makeDepName(output)
+	dep=".deps/"+output.gsub("/","_")
+end
+
+def getDependencies(output)
+	dep=makeDepName(output)
+	if File.exists?(dep)
+		content=File.open(dep).read
+		content=content.gsub(/^[^:]*:/,"")
+		files=content.gsub("\\\n","").split(" ")
+		#puts files
+		return files
+	end
+	#raise 1
+	[]
+end
+
 # build a command out of templates in config.rb
 def makeCommand(cmd,output,input)
 	#cmd.sub("?OUTPUT?",output).sub("?INPUT?",input)
-	extendCommand($config,cmd,{"OUTPUT"=>output,"INPUT"=>input})
+	begin
+		Dir.mkdir(".deps")
+	rescue
+	end
+	dep=makeDepName(output)
+	extendCommand($config,cmd,{"OUTPUT"=>output,"INPUT"=>input,"DEP"=>dep})
 end
 
 

Modified: antargis/branches/rant/build/configs/unix.rb
===================================================================
--- antargis/branches/rant/build/configs/unix.rb	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/build/configs/unix.rb	2007-08-19 13:46:33 UTC (rev 1157)
@@ -19,7 +19,7 @@
 	"INCLUDES"=>"",
     "LIBGL"=>"-lGL -lGLU",
   # call the compiler using the standard unix-style mechanism <CC> -c -o <outputname> <input0> [<input1> ...]
-	"COMPILE_PARAMS"=>" -c -o $(OUTPUT) $(INPUT)",
+	"COMPILE_PARAMS"=>" -Wp,-MD,$(DEP) -c -o $(OUTPUT) $(INPUT)",
 	# an ansi-c compiler call with parameters (using ccache if available)
 	"CC_CALL"=>"$(CCACHE) $(CC) $(COMPILE_PARAMS)",
 	# a c++ compiler call with parameters (using ccache if available)

Added: antargis/branches/rant/ext/3dengine/ag_glwidget.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/ag_glwidget.cc	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/3dengine/ag_glwidget.cc	2007-08-19 13:46:33 UTC (rev 1157)
@@ -0,0 +1,101 @@
+#include "ag_glwidget.h"
+#include "ag_debug.h"
+#include "ag_screen.h"
+#include <GL/glu.h>
+
+AGGLWidget::AGGLWidget(AGWidget *pParent,const AGRect2 &r):
+  AGWidget(pParent,r)
+{
+}
+
+void AGGLWidget::drawGL()
+{
+  
+}
+  
+void AGGLWidget::drawAll(AGPainter &p)
+{
+  beginGL();
+  drawGL();
+  endGL();
+
+  // draw children;
+  AGPainter p2(p);
+  p2.translate(getRect()[0]);
+  p2.clip(getRect().origin());
+  //  p2.transform(getRect());
+
+  std::list<AGWidget*>::reverse_iterator i=mChildren.rbegin(); // draw from back to front
+  //  AGRect2 r2=r.project(mr);
+  for(;i!=mChildren.rend();i++)
+    (*i)->drawAll(p2);
+
+}
+
+void AGGLWidget::beginGL()
+{
+  getScreen().fillRect(getRect(),AGColor(0,0,0)); // draw bg-color
+
+  glMatrixMode(GL_MODELVIEW);
+  glLoadIdentity();
+  glMatrixMode(GL_PROJECTION);
+  setPerspective(45.0,1,100);
+  glMatrixMode(GL_MODELVIEW);
+
+  AGRect2 r=getRect();
+
+  glViewport(GLint(r.x()),GLint(getScreen().getHeight()-r.y1()),GLsizei(r.w()),GLsizei(r.h()));
+  glDepthMask(true);
+  glEnable(GL_DEPTH_TEST);
+  glEnable(GL_LIGHTING);
+  
+  
+  
+}
+
+float AGGLWidget::getRatio() const
+{
+  AGRect2 r=getRect();
+  return float(r.w())/float(r.h());
+}
+
+
+void AGGLWidget::endGL()
+{
+  glDisable(GL_LIGHTING);
+  glEnable(GL_TEXTURE_2D);
+  glShadeModel(GL_SMOOTH);
+
+  glEnable(GL_DEPTH_TEST); // enable depth test
+  glDepthFunc(GL_LEQUAL); // set type depth test
+  glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // GL_NICEST // best perspective correction
+  glEnable(GL_BLEND);
+
+  glViewport( 0, 0, getScreen().getWidth(), getScreen().getHeight() );
+  glMatrixMode( GL_PROJECTION );
+  glLoadIdentity( );
+
+  gluOrtho2D(0,getScreen().getWidth(),0,getScreen().getHeight());
+
+  glMatrixMode( GL_MODELVIEW );
+  glLoadIdentity( );
+
+
+  glEnable( GL_BLEND );
+  glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
+
+  glDisable(GL_DEPTH_TEST); // enable depth test
+
+  glDepthMask(false);
+  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//NEAREST);//LINEAR);
+  glEnable(GL_COLOR_MATERIAL);
+}
+
+void AGGLWidget::setPerspective(float openAngle,float pnear,float pfar)
+{
+  glMatrixMode(GL_PROJECTION);
+  GLdouble r=getRatio();
+  gluPerspective(openAngle,r,pnear,pfar);
+  glGetFloatv(GL_PROJECTION_MATRIX, pMatrix);
+}

Added: antargis/branches/rant/ext/3dengine/ag_glwidget.h
===================================================================
--- antargis/branches/rant/ext/3dengine/ag_glwidget.h	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/3dengine/ag_glwidget.h	2007-08-19 13:46:33 UTC (rev 1157)
@@ -0,0 +1,30 @@
+#ifndef AG_GLWIDGET_H
+#define AG_GLWIDGET_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+
+#include <ag_widget.h>
+#include <ag_geometry.h>
+
+class AGEXPORT AGGLWidget:public AGWidget
+{
+ public:
+  AGGLWidget(AGWidget *pParent,const AGRect2 &r);
+
+  virtual void drawGL();
+  
+  virtual void drawAll(AGPainter &p);
+  
+  float getRatio() const;
+
+  void setPerspective(float openAngle,float near,float far);
+
+ private:
+  void beginGL();
+  void endGL();
+
+  AGMatrix4 pMatrix,mMatrix;
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/boa_3d_wireframe.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/boa_3d_wireframe.cc	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/3dengine/boa_3d_wireframe.cc	2007-08-19 13:46:33 UTC (rev 1157)
@@ -0,0 +1,61 @@
+#include "boa_3d_wireframe.h"
+#include <ag_rendercontext.h>
+#include <ag_debug.h>
+
+Boa3dWireframe::Boa3dWireframe(Scene *pScene,const AGVector4 &pColor):
+  SceneNode(pScene,AGVector4(0,0,0,0),AGBox3(AGVector3(0,0,0),AGVector3(100,100,100)))
+{
+  mColor=pColor;
+  mChanged=true;
+}
+
+void Boa3dWireframe::draw()
+{
+  //  std::cout<<"Mcdebug("<<std::endl;
+  //  CTRACE;
+  // FIXME: use vertex array ???
+  if(mChanged)
+    {
+      // update vertex array
+    }
+
+  
+  AGRenderContext c;
+  glLineWidth(3);
+
+  //  c.setDepthTest(false);
+
+  AGVector3 a(0,0,0);
+  AGVector3 b(0,0,10);
+
+  c.setColor(mColor);
+  c.begin();
+  glBegin(GL_LINES);
+ 
+  for(std::vector<Line>::iterator i=mLines.begin();i!=mLines.end();i++)
+    {
+      glVertex3fv((float*)a);
+      glVertex3fv((float*)b);
+      glVertex3fv((float*)i->a);
+      glVertex3fv((float*)i->b);
+    }
+  glEnd();
+  
+
+  
+
+}
+
+void Boa3dWireframe::addLine(const AGVector3 &a,const AGVector3 &b)
+{
+  Line line;
+  line.a=a;
+  line.b=b;
+  mLines.push_back(line);
+  mChanged=true;
+}
+
+bool Boa3dWireframe::transparent()
+{
+  return true;
+}

Added: antargis/branches/rant/ext/3dengine/boa_3d_wireframe.h
===================================================================
--- antargis/branches/rant/ext/3dengine/boa_3d_wireframe.h	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/3dengine/boa_3d_wireframe.h	2007-08-19 13:46:33 UTC (rev 1157)
@@ -0,0 +1,36 @@
+#ifndef BOA_3D_WIREFRAME_H
+#define BOA_3D_WIREFRAME_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include <scenenode.h>
+#include "vertex_array.h"
+
+class AGEXPORT Boa3dWireframe:public SceneNode
+{
+  struct Line
+  {
+    AGVector3 a,b;
+  };
+
+ public:
+  Boa3dWireframe(Scene *pScene,const AGVector4 &pColor);
+
+  void draw();
+
+  void addLine(const AGVector3 &a,const AGVector3 &b);
+
+  bool transparent();
+
+ private:
+  std::vector<Line> mLines;
+  AGVector4 mColor;
+  VertexArray mArray;
+
+  bool mChanged;
+
+};
+
+
+#endif
+

Modified: antargis/branches/rant/ext/3dengine/headers.hh
===================================================================
--- antargis/branches/rant/ext/3dengine/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/3dengine/headers.hh	2007-08-19 13:46:33 UTC (rev 1157)
@@ -1,33 +1,33 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_singleton.h"
 #include "ext/basic/ag_config.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_main.h"
-#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_string_utf8.h"
 #include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_geometry.h"
 #include "ext/basic/ag_video_base.h"
 #include "ext/basic/ag_xml.h"
-#include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_fs.h"
 #include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_geometry.h"
+#include "ext/basic/ag_rubyobj.h"
 #include "ext/math/ag_rand.h"
+#include "ext/math/ag_algebra.h"
 #include "ext/math/ant_frustum.h"
-#include "ext/math/ag_algebra.h"
+#include "ext/video/ag_rendercontext.h"
+#include "ext/video/ag_texturecache.h"
+#include "ext/video/ag_clip.h"
+#include "ext/video/ag_fontengine.h"
+#include "ext/video/ag_font.h"
+#include "ext/video/ag_video.h"
+#include "ext/video/ag_color.h"
 #include "ext/video/ag_screen.h"
-#include "ext/video/ag_video.h"
 #include "ext/video/ag_painttarget.h"
-#include "ext/video/ag_color.h"
-#include "ext/video/ag_fontengine.h"
-#include "ext/video/ag_font.h"
 #include "ext/video/ag_surface.h"
 #include "ext/video/ag_texture.h"
-#include "ext/video/ag_rendercontext.h"
-#include "ext/video/ag_texturecache.h"
-#include "ext/video/ag_clip.h"
 #include "ext/video/ag_painter.h"
 #include "ext/gui/ag_image.h"
 #include "ext/gui/ag_listbox.h"

Modified: antargis/branches/rant/ext/basic/ag_rtools.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_rtools.cc	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/basic/ag_rtools.cc	2007-08-19 13:46:33 UTC (rev 1157)
@@ -1,4 +1,5 @@
 #include <ag_rtools.h>
+#include <ag_serial.h>
 
 #include <ruby.h>
 
@@ -7,6 +8,18 @@
 
 std::string rubyHash(const std::string &p)
 {
+  rb_eval_string("require 'digest/md5'");
+  VALUE l=rb_eval_string("Digest::MD5");
+  VALUE r=rb_funcall(l,rb_intern("digest"),1,rb_str_new(p.c_str(),p.length()));
+
+  std::string s(RSTRING_PTR(r), RSTRING_LEN(r));
+
+  return binaryToHex(s,false);
+  
+}
+
+std::string rubyHashOld(const std::string &p)
+{
   // FIXME: TRY USING ruby's Digest::MD5::digest("xy")
   rb_eval_string("require 'digest/md5'");
 

Modified: antargis/branches/rant/ext/basic/ag_serial.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_serial.cc	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/basic/ag_serial.cc	2007-08-19 13:46:33 UTC (rev 1157)
@@ -378,7 +378,7 @@
 }
 
 
-std::string binaryToHex(const std::string &s)
+std::string binaryToHex(const std::string &s,bool separators)
 {
   std::ostringstream os;
   
@@ -387,7 +387,7 @@
     {
       //      cdebug(i<<":"<<(int)s[i]);
       toHexBS(s[i],os);
-      if(i>0)
+      if(i>0 && separators)
 	{
 	  if((i%32)==0)
 	    os<<std::endl;

Modified: antargis/branches/rant/ext/basic/ag_serial.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_serial.h	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/basic/ag_serial.h	2007-08-19 13:46:33 UTC (rev 1157)
@@ -102,7 +102,7 @@
   std::ostringstream os;
 };
 
-AGEXPORT std::string binaryToHex(const std::string &s);
+AGEXPORT std::string binaryToHex(const std::string &s,bool separators=true);
 AGEXPORT std::string hexToBinary(const std::string &s);
 
 #endif

Modified: antargis/branches/rant/ext/basic/headers.hh
===================================================================
--- antargis/branches/rant/ext/basic/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/basic/headers.hh	2007-08-19 13:46:33 UTC (rev 1157)
@@ -13,8 +13,8 @@
 #include "ext/basic/ag_xml.h"
 #include "ext/basic/ag_string_utf8.h"
 #include "ext/basic/ag_stringstream.h"
+#include "ext/basic/ag_utf8.h"
 #include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_utf8.h"
 #ifdef SWIG
 %include "ext/basic/ag_rubyobj.h"
 %include "ext/basic/ag_messageobject.h"
@@ -28,7 +28,7 @@
 %include "ext/basic/ag_xml.h"
 %include "ext/basic/ag_string_utf8.h"
 %include "ext/basic/ag_stringstream.h"
+%include "ext/basic/ag_utf8.h"
 %include "ext/basic/ag_fs.h"
-%include "ext/basic/ag_utf8.h"
 #endif
 #endif

Modified: antargis/branches/rant/ext/game/headers.hh
===================================================================
--- antargis/branches/rant/ext/game/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/game/headers.hh	2007-08-19 13:46:33 UTC (rev 1157)
@@ -1,33 +1,33 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_singleton.h"
 #include "ext/basic/ag_config.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_main.h"
-#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_string_utf8.h"
 #include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_geometry.h"
 #include "ext/basic/ag_video_base.h"
 #include "ext/basic/ag_xml.h"
-#include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_fs.h"
 #include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_geometry.h"
+#include "ext/basic/ag_rubyobj.h"
 #include "ext/math/ag_rand.h"
+#include "ext/math/ag_algebra.h"
 #include "ext/math/ant_frustum.h"
-#include "ext/math/ag_algebra.h"
+#include "ext/video/ag_rendercontext.h"
+#include "ext/video/ag_texturecache.h"
+#include "ext/video/ag_clip.h"
+#include "ext/video/ag_fontengine.h"
+#include "ext/video/ag_font.h"
+#include "ext/video/ag_video.h"
+#include "ext/video/ag_color.h"
 #include "ext/video/ag_screen.h"
-#include "ext/video/ag_video.h"
 #include "ext/video/ag_painttarget.h"
-#include "ext/video/ag_color.h"
-#include "ext/video/ag_fontengine.h"
-#include "ext/video/ag_font.h"
 #include "ext/video/ag_surface.h"
 #include "ext/video/ag_texture.h"
-#include "ext/video/ag_rendercontext.h"
-#include "ext/video/ag_texturecache.h"
-#include "ext/video/ag_clip.h"
 #include "ext/video/ag_painter.h"
 #include "ext/gui/ag_image.h"
 #include "ext/gui/ag_listbox.h"
@@ -56,21 +56,21 @@
 #include "ext/gui/ag_window.h"
 #include "ext/gui/ag_layout.h"
 #include "ext/gui/ag_border.h"
-#include "ext/3dengine/scene_base.h"
-#include "ext/3dengine/scene.h"
-#include "ext/3dengine/scenenode.h"
+#include "ext/3dengine/anim_mesh_data.h"
 #include "ext/3dengine/ant_camera.h"
-#include "ext/3dengine/ag_glwidget.h"
-#include "ext/3dengine/mesh_data.h"
 #include "ext/3dengine/mesh.h"
+#include "ext/3dengine/scene.h"
 #include "ext/3dengine/mesh_optimizer.h"
+#include "ext/3dengine/ant_particle.h"
+#include "ext/3dengine/mesh_2d_data.h"
+#include "ext/3dengine/mesh_2d.h"
+#include "ext/3dengine/mesh_data.h"
+#include "ext/3dengine/scene_base.h"
 #include "ext/3dengine/anim_mesh.h"
-#include "ext/3dengine/anim_mesh_data.h"
+#include "ext/3dengine/scenenode.h"
+#include "ext/3dengine/ant_projection.h"
+#include "ext/3dengine/ag_glwidget.h"
 #include "ext/3dengine/boa_3d_wireframe.h"
-#include "ext/3dengine/mesh_2d.h"
-#include "ext/3dengine/mesh_2d_data.h"
-#include "ext/3dengine/ant_projection.h"
-#include "ext/3dengine/ant_particle.h"
 #include "ext/game/path.h"
 #include "ext/game/path_data_v3.h"
 #include "ext/game/path_v2.h"

Modified: antargis/branches/rant/ext/game/path.cc
===================================================================
--- antargis/branches/rant/ext/game/path.cc	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/game/path.cc	2007-08-19 13:46:33 UTC (rev 1157)
@@ -281,7 +281,53 @@
 }
 
 
+SimpleGraph::SimpleGraph(BinaryIn &pIn)
+{
+  std::vector<AGVector2> vecs;
+  std::vector<Node*> nodes;
+  AGVector2 p;
+  size_t a,b;
+  float w0,w1;
 
+  size_t count,i;
+  pIn>>count;
+  for(i=0;i<count;i++)
+    {
+      pIn>>p;
+      vecs.push_back(p);
+      nodes.push_back(addNode(p));
+    }
+  pIn>>count;
+  for(i=0;i<count;i++)
+    {
+      pIn>>a>>b>>w0>>w1;
+      assert(a<nodes.size());
+      assert(b<nodes.size());
+      addEdge(nodes[a],nodes[b],w0,w1);
+    }
+  pIn>>mWidth;
+}
+
+void SimpleGraph::printTo(BinaryOut &pOut) const
+{
+  std::map<AGVector2,size_t> saveMap;
+  size_t j=0;
+  pOut<<mNodes.size();
+  for(NodeSet::const_iterator i=mNodes.begin();i!=mNodes.end();i++,j++)
+    {
+      pOut<<(*i)->p;
+      saveMap[(*i)->p]=j;
+    }
+  pOut<<mEdges.size();
+  for(EdgeSet::const_iterator i=mEdges.begin();i!=mEdges.end();i++)
+    {
+      pOut<<saveMap[(*i)->a->p]<<saveMap[(*i)->b->p]<<(*i)->w0<<(*i)->w1;
+    }
+
+  pOut<<mWidth;
+}
+
+
 SimpleGraph::Node *SimpleGraph::addNode(const AGVector2 &p)
 {
   Node *n=findNode(p);
@@ -378,7 +424,7 @@
   for(EdgeSet::iterator k=mEdges.begin();k!=mEdges.end() && j<=i;k++,j++)
     e=*k;
 
-  cdebug("i:"<<i<<"  size:"<<mEdges.size());
+  //  cdebug("i:"<<i<<"  size:"<<mEdges.size());
   assert(e);
 
   return std::make_pair(e->a->p,e->b->p);

Modified: antargis/branches/rant/ext/game/path.h
===================================================================
--- antargis/branches/rant/ext/game/path.h	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/game/path.h	2007-08-19 13:46:33 UTC (rev 1157)
@@ -6,6 +6,8 @@
 #include "height_map.h"
 #include "heuristic.h"
 
+#include <ag_serial.h>
+
 #include <ag_surface.h>
 
 /**
@@ -138,6 +140,7 @@
 
   SimpleGraph();
   SimpleGraph(const SimpleGraph &g);
+  SimpleGraph(BinaryIn &pIn);
 
   Node *addNode(const AGVector2 &p);
   /**
@@ -178,6 +181,7 @@
   void paint(const AGRect2& r,AGPaintTarget &t,Heuristic &heuristic);
   void paintNode(const AGRect2& r,AGPaintTarget &t,const AGVector2 &p,const AGColor &c);
 
+  void printTo(BinaryOut &os) const;
 
  protected:
 

Added: antargis/branches/rant/ext/game/tests/test_vector_sort.cc
===================================================================
--- antargis/branches/rant/ext/game/tests/test_vector_sort.cc	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/game/tests/test_vector_sort.cc	2007-08-19 13:46:33 UTC (rev 1157)
@@ -0,0 +1,43 @@
+#include "path_vector_sort.h"
+#include <ag_geometry.h>
+#include <set>
+#include <ag_debug.h>
+
+int test_vector_sort()
+{
+  AGVector2 m(2,2);
+  DistanceOrder order(m);
+  std::set<AGVector2,DistanceOrder> mset(order);
+
+  AGVector2 a(3,2);
+  AGVector2 b(3,3);
+  AGVector2 c(0,0);
+  AGVector2 d(1,2);
+
+
+  mset.insert(a);
+  mset.insert(b);
+  mset.insert(c);
+  mset.insert(d);
+
+
+  std::vector<AGVector2> v;
+
+  std::copy(mset.begin(),mset.end(),std::back_inserter(v));
+
+  /*
+  cdebug(v.size());
+
+  cdebug("0:"<<v[0]<<"  "<<d<<"  "<<(d-m).length());
+  cdebug("1:"<<v[1]<<"  "<<a<<"  "<<(a-m).length());
+  cdebug("2:"<<v[2]<<"  "<<b<<"  "<<(b-m).length());
+  cdebug("3:"<<v[3]<<"  "<<c<<"  "<<(c-m).length());
+  */
+
+  assert(v[0]==d);
+  assert(v[1]==a);
+  assert(v[2]==b);
+  assert(v[3]==c);
+
+  return 0;
+}

Modified: antargis/branches/rant/ext/gui/headers.hh
===================================================================
--- antargis/branches/rant/ext/gui/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/gui/headers.hh	2007-08-19 13:46:33 UTC (rev 1157)
@@ -1,33 +1,33 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_singleton.h"
 #include "ext/basic/ag_config.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_main.h"
-#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_string_utf8.h"
 #include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_geometry.h"
 #include "ext/basic/ag_video_base.h"
 #include "ext/basic/ag_xml.h"
-#include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_fs.h"
 #include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_geometry.h"
+#include "ext/basic/ag_rubyobj.h"
 #include "ext/math/ag_rand.h"
+#include "ext/math/ag_algebra.h"
 #include "ext/math/ant_frustum.h"
-#include "ext/math/ag_algebra.h"
+#include "ext/video/ag_rendercontext.h"
+#include "ext/video/ag_texturecache.h"
+#include "ext/video/ag_clip.h"
+#include "ext/video/ag_fontengine.h"
+#include "ext/video/ag_font.h"
+#include "ext/video/ag_video.h"
+#include "ext/video/ag_color.h"
 #include "ext/video/ag_screen.h"
-#include "ext/video/ag_video.h"
 #include "ext/video/ag_painttarget.h"
-#include "ext/video/ag_color.h"
-#include "ext/video/ag_fontengine.h"
-#include "ext/video/ag_font.h"
 #include "ext/video/ag_surface.h"
 #include "ext/video/ag_texture.h"
-#include "ext/video/ag_rendercontext.h"
-#include "ext/video/ag_texturecache.h"
-#include "ext/video/ag_clip.h"
 #include "ext/video/ag_painter.h"
 #include "ext/gui/ag_layoutfactory.h"
 #include "ext/gui/ag_widget.h"

Modified: antargis/branches/rant/ext/math/headers.hh
===================================================================
--- antargis/branches/rant/ext/math/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/math/headers.hh	2007-08-19 13:46:33 UTC (rev 1157)
@@ -1,19 +1,19 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_singleton.h"
 #include "ext/basic/ag_config.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_main.h"
-#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_string_utf8.h"
 #include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_geometry.h"
 #include "ext/basic/ag_video_base.h"
 #include "ext/basic/ag_xml.h"
-#include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_fs.h"
 #include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_geometry.h"
+#include "ext/basic/ag_rubyobj.h"
 #include "ext/math/ag_rand.h"
 #include "ext/math/ant_frustum.h"
 #include "ext/math/ag_algebra.h"

Modified: antargis/branches/rant/ext/sound/headers.hh
===================================================================
--- antargis/branches/rant/ext/sound/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/sound/headers.hh	2007-08-19 13:46:33 UTC (rev 1157)
@@ -1,19 +1,19 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_singleton.h"
 #include "ext/basic/ag_config.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_main.h"
-#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_string_utf8.h"
 #include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_geometry.h"
 #include "ext/basic/ag_video_base.h"
 #include "ext/basic/ag_xml.h"
-#include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_fs.h"
 #include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_geometry.h"
+#include "ext/basic/ag_rubyobj.h"
 #include "ext/sound/ag_mixer.h"
 #ifdef SWIG
 %include "ext/sound/ag_mixer.h"

Modified: antargis/branches/rant/ext/video/ag_video.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_video.cc	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/video/ag_video.cc	2007-08-19 13:46:33 UTC (rev 1157)
@@ -91,6 +91,7 @@
   if(!ms)
     {
       std::cerr<<"Initing video mode failed!"<<std::endl;
+      std::cerr<<"SDL:Error:"<<SDL_GetError()<<std::endl;
       exit(1);
     }
 

Modified: antargis/branches/rant/ext/video/headers.hh
===================================================================
--- antargis/branches/rant/ext/video/headers.hh	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ext/video/headers.hh	2007-08-19 13:46:33 UTC (rev 1157)
@@ -1,22 +1,22 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_singleton.h"
 #include "ext/basic/ag_config.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_main.h"
-#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_string_utf8.h"
 #include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_geometry.h"
 #include "ext/basic/ag_video_base.h"
 #include "ext/basic/ag_xml.h"
-#include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_fs.h"
 #include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_geometry.h"
+#include "ext/basic/ag_rubyobj.h"
 #include "ext/math/ag_rand.h"
+#include "ext/math/ag_algebra.h"
 #include "ext/math/ant_frustum.h"
-#include "ext/math/ag_algebra.h"
 #include "ext/video/ag_painttarget.h"
 #include "ext/video/ag_surface.h"
 #include "ext/video/ag_texture.h"

Modified: antargis/branches/rant/ruby/ant_hljobs.rb
===================================================================
--- antargis/branches/rant/ruby/ant_hljobs.rb	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ruby/ant_hljobs.rb	2007-08-19 13:46:33 UTC (rev 1157)
@@ -204,8 +204,8 @@
 		@waypoints.unshift(@hero.getPos2D)
 		@waypoints.push(@pos)
 		if getMap.path
-			puts "FIXME: ant_hljobs.rb:207"
-			#@waypoints=getMap.path.refinePath(@waypoints,MapPathWeighter.new(getMap))
+			#puts "FIXME: ant_hljobs.rb:207"
+			@waypoints=getMap.path.refinePath(@waypoints,MapPathWeighter.new(getMap))
 		end
 		@men=getMen
 		@moveFinished=false

Modified: antargis/branches/rant/ruby/map.rb
===================================================================
--- antargis/branches/rant/ruby/map.rb	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ruby/map.rb	2007-08-19 13:46:33 UTC (rev 1157)
@@ -299,9 +299,6 @@
 		@loadedEntsNum=1
 		@loadedEntities=[]
 		super(n)
-# 		puts @loadedEntities.length
-# 		puts @loadedEntsNum
-# 		raise 1
 		@loadedEntities.each{|pair|
 			node,entity=pair
 			insertEntity(entity)
@@ -309,72 +306,14 @@
 
 		@loadedEntities.each{|pair|
 			node,entity=pair
-#			loadEntityFromXML(entity,node)
 			entity.loadXML(node)
 			entity.eventMapChanged
 		}
 		
 
+		createPathfinder
 
-		# add pathfinder
-		@mweighter=MapPathWeighter.new(self)
-		@sgraph=makeGraph(self, at mweighter,2)
-		@dgraph=DecimatedGraph.new(@sgraph)
 
-		factor=0.8
-		factor=1.0-800.0/@dgraph.size
-
-		#factor=0.4
-
-		factor=1.0-220.0/@dgraph.size
-
-		@dgraph.decimate(factor, at mweighter)
-
-		if true # display dgraph
-			wireframe=Boa3dWireframe.new(getScene,AGVector4.new(1,0,0,1))
-			(0..(@dgraph.edges-1)).each{|i|
-				edge=@dgraph.getEdgePosition(i)
-				puts edge
-				a=edge[0]
-				b=edge[1]
-				a=AGVector3.new(a.x,a.y,getHeight(a.x,a.y)+0.05)
-				b=AGVector3.new(b.x,b.y,getHeight(b.x,b.y)+0.05)
-				wireframe.addLine(a,b)
-			}
-			getScene.addNode(wireframe)
-			#raise 1
-		end
-
-
-		#raise self.hash
-		# FIXME: insert hash here
-
-		hFilename="heuristic.test"
-
-		if File.exists?(hFilename) and false # FIXME: reenable saving
-			fin=BinaryFileIn.new(hFilename)
-			@heuristic=StoredHeuristicFunction.new(fin)
-		else
-			@heuristic=computeHeuristic(@dgraph)
-			#exit
-	
-	
-			stream=BinaryStringOut.new
-			@heuristic.printTo(stream)
-			f=File.open(hFilename,"w")
-			f.puts stream.getString
-			f.close
-		end
-
-
-		#raise "FIXME"
-
-		# FIXME: readd this when heuristics are better!!!
-		#setHeuristic(@heuristic)
-
-		@path=Pathfinder.new(@dgraph, at heuristic)
-
-
 		@players.each{|p|p.move(0)}
 		
 		if n.get("scriptfile").length>0 and n.get("scriptclass").length>0
@@ -539,6 +478,72 @@
 	def getLevelName
 		"L_"+ at filename.gsub(".rb","").gsub(".","_").gsub("/","_")
 	end
+
+
+
+	def createPathfinder
+
+		levelHash=self.hash # build a hash out of the height-map
+		cacheFilename=levelHash+".cache"
+
+		# cache the whole path-finding graph and heuristic computations
+		if fileExists(findFile(cacheFilename))
+			puts "LOAD PATHFINDING FROM CACHE....."
+			content=loadFile(cacheFilename)
+			stream=BinaryStringIn.new(content)
+			@dgraph=SimpleGraph.new(stream)
+			@heuristic=StoredHeuristicFunction.new(stream)
+			puts "LOAD PATHFINDING FROM CACHE-READY."
+		else
+			# build a map-height/distance weighter
+			@mweighter=MapPathWeighter.new(self)
+
+			# set initial distance of waypoints	
+			minDist=2
+			if getW*getH>128*128
+				minDist=4
+			end
+	
+			# make a path-finding graph
+			@sgraph=makeGraph(self, at mweighter,minDist)
+			# copy to a decimating graph
+			@dgraph=DecimatedGraph.new(@sgraph)
+	
+			# compute a decimation-factor
+			factor=1.0-800.0/@dgraph.size
+	
+			# debugging settings
+			#factor=0.4
+			#factor=1.0-220.0/@dgraph.size
+	
+			@dgraph.decimate(factor, at mweighter)
+	
+			# compute a distance-field and use this as a pre-computed heuristic
+			@heuristic=computeHeuristic(@dgraph)
+	
+			# save everything to the cachefile
+			stream=BinaryStringOut.new
+			@dgraph.printTo(stream)
+			@heuristic.printTo(stream)
+		
+			saveFile(cacheFilename,stream.getString)
+		end	
+		@path=Pathfinder.new(@dgraph, at heuristic)
+		
+		#displayPathfindingGraph
+	end
+	def displayPathfindingGraph
+		wireframe=Boa3dWireframe.new(getScene,AGVector4.new(1,0,0,1))
+		(0..(@dgraph.edges-1)).each{|i|
+			edge=@dgraph.getEdgePosition(i)
+			a=edge[0]
+			b=edge[1]
+			a=AGVector3.new(a.x,a.y,getHeight(a.x,a.y)+0.05)
+			b=AGVector3.new(b.x,b.y,getHeight(b.x,b.y)+0.05)
+			wireframe.addLine(a,b)
+		}
+		getScene.addNode(wireframe)
+	end
 end
 
 

Added: antargis/branches/rant/ruby/tests/3d_engine/wireframe.rb
===================================================================
--- antargis/branches/rant/ruby/tests/3d_engine/wireframe.rb	2007-08-15 17:33:15 UTC (rev 1156)
+++ antargis/branches/rant/ruby/tests/3d_engine/wireframe.rb	2007-08-19 13:46:33 UTC (rev 1157)
@@ -0,0 +1,46 @@
+#!/usr/bin/env ruby
+
+$:.push("ext")
+
+require 'antargis3dengine'
+require 'antargisgui'
+
+include Antargis3dengine
+include Antargisgui
+
+getMain.getVideo.initVideo(640,480,32,false,true)
+app=AGApplication.new
+
+
+
+class MWidget<AGGLWidget
+	def initialize(p,r)
+		super
+		@scene=Scene.new(r.width.to_i,r.height.to_i)
+
+		wireframe=Boa3dWireframe.new(@scene)
+
+		a=AGVector3.new(0,0,0)
+		b=AGVector3.new(10,0,0)
+		white=AGVector4.new(1,1,1,1)
+
+		wireframe.addLine(a,b,white)
+
+		@scene.addNode(wireframe)
+
+	end
+	def drawGL
+		@scene.draw
+	end
+
+	
+end
+
+widget=MWidget.new(nil,AGRect2.new(0,0,640,480))
+
+app.setMainWidget(widget)
+
+app.run
+
+
+


Property changes on: antargis/branches/rant/ruby/tests/3d_engine/wireframe.rb
___________________________________________________________________
Name: svn:executable
   + *



From davidkamphausen at mail.berlios.de  Sun Aug 19 20:14:44 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 19 Aug 2007 20:14:44 +0200
Subject: [Antargis-svn] r1158 - antargis/branches/rant/ruby/tests/path
Message-ID: <200708191814.l7JIEiwZ010761@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-08-19 20:14:44 +0200 (Sun, 19 Aug 2007)
New Revision: 1158

Added:
   antargis/branches/rant/ruby/tests/path/heuristic_test.rb
Log:
* added new test


Added: antargis/branches/rant/ruby/tests/path/heuristic_test.rb
===================================================================
--- antargis/branches/rant/ruby/tests/path/heuristic_test.rb	2007-08-19 13:46:33 UTC (rev 1157)
+++ antargis/branches/rant/ruby/tests/path/heuristic_test.rb	2007-08-19 18:14:44 UTC (rev 1158)
@@ -0,0 +1,38 @@
+#!/usr/bin/env ruby
+
+$:.push("ext/")
+
+require 'antargisgame'
+
+include Antargisgame
+
+f=StoredHeuristicFunction.new
+
+a=AGVector2.new(0,0)
+b=AGVector2.new(1,1)
+c=AGVector2.new(2,2)
+
+values=[
+	[a,b,3],
+	[b,c,4],
+	[c,a,5]
+]
+
+values.each{|a|
+	f.store(a[0],a[1],a[2])
+}
+
+stream=BinaryStringOut.new
+f.printTo(stream)
+
+str=stream.getString
+
+stream=BinaryStringIn.new(str)
+
+f2=StoredHeuristicFunction.new(stream)
+
+values.each{|a|
+	raise "error within #{a}" unless f2.get(a[0],a[1])==a[2] 
+}
+
+puts "ok"
\ No newline at end of file



From davidkamphausen at mail.berlios.de  Tue Aug 21 21:10:49 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Tue, 21 Aug 2007 21:10:49 +0200
Subject: [Antargis-svn] r1159 - in antargis/branches/rant: . build
	build/configs ext/basic ext/sound ext/video ruby
Message-ID: <200708211910.l7LJAnNf031807@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-08-21 21:10:47 +0200 (Tue, 21 Aug 2007)
New Revision: 1159

Added:
   antargis/branches/rant/build/config_tools.rb
   antargis/branches/rant/build/test_suite_c.rb
   antargis/branches/rant/build/testing.rb
Modified:
   antargis/branches/rant/ChangeLog
   antargis/branches/rant/Rantfile
   antargis/branches/rant/build/base_tools.rb
   antargis/branches/rant/build/configs/unix.rb
   antargis/branches/rant/build/configure.rb
   antargis/branches/rant/build/platform.rb
   antargis/branches/rant/configure
   antargis/branches/rant/ext/basic/ag_main.cc
   antargis/branches/rant/ext/basic/init.cc
   antargis/branches/rant/ext/sound/ag_mixer.cc
   antargis/branches/rant/ext/sound/init.cc
   antargis/branches/rant/ext/video/ag_video.cc
   antargis/branches/rant/ruby/antargis.rb
   antargis/branches/rant/ruby/mainmenu.rb
Log:
* some fixes
* some build-improvements
* testing


Modified: antargis/branches/rant/ChangeLog
===================================================================
--- antargis/branches/rant/ChangeLog	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/ChangeLog	2007-08-21 19:10:47 UTC (rev 1159)
@@ -1,9 +1,12 @@
 
 
 
-0.2.1.2 (2007-08-09)
+0.2.1.2 (2007-08-21)
 	- increased performance on heuristic-computation
+	- some minor cleanup of map.rb
 	- included saving and thus caching of heuristic
+	- fixed error in garbage-collection - main was not stored always, so garbage collector collected some objects too much
+  - reenabled editor
 
 0.2.1.1 (about 2007-07)
 	- refactoring

Modified: antargis/branches/rant/Rantfile
===================================================================
--- antargis/branches/rant/Rantfile	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/Rantfile	2007-08-21 19:10:47 UTC (rev 1159)
@@ -26,7 +26,7 @@
 # - an internal dependency on a directory
 # NOTE: dependencies are not automatically inherited, you have to include them yourself!
 
-rubyLib=["-l"+$config['RUBYLIB']]
+rubyLib=[$config['RUBYLIB']]
 
 sourceDeps=[
 	["ext/external",["-lz"]+sdlLibs],

Modified: antargis/branches/rant/build/base_tools.rb
===================================================================
--- antargis/branches/rant/build/base_tools.rb	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/build/base_tools.rb	2007-08-21 19:10:47 UTC (rev 1159)
@@ -1,7 +1,6 @@
-#require 'mkmf'                        # mkmf holds information about the compiler-settings while compiling ruby (by the maintainer)
-
 require 'build/platform.rb'
 require 'config.rb'                   # include build-options
+require 'build/config_tools.rb'
 
 def getDir(path)
 	# FIXME: check for windows
@@ -47,29 +46,7 @@
 end
 
 
-def extendCommandLine(config,s)
-  r=config[s]
-  return r if r.nil?
-  r.gsub(/\$\(([^\)]*)\)/) {|a|
-		n=a[2..-2] # filter "$(xy..z)" to "xy..z"
-		raise "Endless recursion in #{n}!" if n==s
-		extendCommandLine(config,n)  # replace recursive values within this form: $(...)
-	}
-end
 
-def extendCommand(config,name,map={})
-	c=config.clone
-	map.each{|k,v|
-		c[k]=v
-	}
-	extendCommandLine(c,name)
-end
-
-# the getConfig function reads out compiler-information out of the mkmf-configuration variables - these are defined in a recursive manner
-def getConfig(s)
-	extendCommand(CONFIG,s)
-end
-
 def U2W(path)
     path.gsub("/",Dir.separator)
 end

Added: antargis/branches/rant/build/config_tools.rb
===================================================================
--- antargis/branches/rant/build/config_tools.rb	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/build/config_tools.rb	2007-08-21 19:10:47 UTC (rev 1159)
@@ -0,0 +1,22 @@
+def extendCommandLine(config,s)
+  r=config[s]
+  return r if r.nil?
+  r.gsub(/\$\(([^\)]*)\)/) {|a|
+		n=a[2..-2] # filter "$(xy..z)" to "xy..z"
+		raise "Endless recursion in #{n}!" if n==s
+		extendCommandLine(config,n)  # replace recursive values within this form: $(...)
+	}
+end
+
+def extendCommand(config,name,map={})
+	c=config.clone
+	map.each{|k,v|
+		c[k]=v
+	}
+	extendCommandLine(c,name)
+end
+
+# the getConfig function reads out compiler-information out of the mkmf-configuration variables - these are defined in a recursive manner
+def getConfig(s)
+	extendCommand(CONFIG,s)
+end

Modified: antargis/branches/rant/build/configs/unix.rb
===================================================================
--- antargis/branches/rant/build/configs/unix.rb	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/build/configs/unix.rb	2007-08-21 19:10:47 UTC (rev 1159)
@@ -17,7 +17,7 @@
   "LIBS"=>"",
 	"RUBYLIB"=>"ruby1.8",
 	"INCLUDES"=>"",
-    "LIBGL"=>"-lGL -lGLU",
+  "LIBGL"=>"-lGL -lGLU",
   # call the compiler using the standard unix-style mechanism <CC> -c -o <outputname> <input0> [<input1> ...]
 	"COMPILE_PARAMS"=>" -Wp,-MD,$(DEP) -c -o $(OUTPUT) $(INPUT)",
 	# an ansi-c compiler call with parameters (using ccache if available)

Modified: antargis/branches/rant/build/configure.rb
===================================================================
--- antargis/branches/rant/build/configure.rb	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/build/configure.rb	2007-08-21 19:10:47 UTC (rev 1159)
@@ -12,6 +12,7 @@
 ##
 
 require 'build/platform.rb'
+require 'build/config_tools.rb'
 
 module CFG
 	@@options=[]
@@ -21,6 +22,7 @@
 	def CFG.addOption(name,short,help,param=nil,default=nil,&proc)
 		@@options.push({:name=>name,:short=>short,:help=>help,:proc=>proc,:param=>param,:default=>default})
 	end
+
 	def CFG.options
 		@@options
 	end
@@ -208,6 +210,11 @@
 		
 	end
 
+
+	def CFG.gatherMkmfInfo
+		CFG.set("RUBYLIB",getConfig("LIBRUBYARG_SHARED"))
+	end
+
 	def CFG.checkLibrary(libname)
 	end
 

Modified: antargis/branches/rant/build/platform.rb
===================================================================
--- antargis/branches/rant/build/platform.rb	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/build/platform.rb	2007-08-21 19:10:47 UTC (rev 1159)
@@ -1,6 +1,7 @@
 class Dir
-    @@dirSep="/"    
-    @@dirSep="\\" if ENV['WINDIR']
+	@@dirSep="/"    
+	@@dirSep="\\" if ENV['WINDIR']
+
 	def Dir.separator
 		@@dirSep
 	end
@@ -12,8 +13,6 @@
 
 if ENV['WINDIR']
     CONFIG={"archdir"=>Dir.pwd+"/build/win32/usr/lib"}
-    
 else
     require 'mkmf'
-#CONFIG={"archdir"=>Dir.pwd+"/build/win32/usr/lib","CFLAGS"=>""}
 end
\ No newline at end of file

Added: antargis/branches/rant/build/test_suite_c.rb
===================================================================
--- antargis/branches/rant/build/test_suite_c.rb	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/build/test_suite_c.rb	2007-08-21 19:10:47 UTC (rev 1159)
@@ -0,0 +1,67 @@
+require 'build/base_tools.rb'
+module Testing
+
+
+	def Testing.runCTest(file)
+		puts file
+		functions=extractFunctions(file)
+
+		writeInterfaceFile(functions)
+		files=[interfaceFile,file]
+		files.each{|f|Build.compile(f)}
+		objs=files.collect{|f|Build.cFileToObj(f)}
+
+		Build.linkToLib(libName,objs,[])
+
+	end
+private
+	def Testing.extractFunctions(file)
+		content=File.open(file,"r").read
+
+		lines=content.split("\n").select{|line|line=~/int test_[a-zA-Z_0-9]+\(\)/}
+		functions=lines.collect{|line|line.gsub(/.* test/,"test").gsub(/\(.*/,"")}
+		puts functions.join("\n")
+		functions
+	end
+
+	def Testing.libName
+		"anttesting.so"
+	end
+
+	def Testing.moduleName
+		"anttesting"
+	end
+
+	def Testing.interfaceFile
+		"tmpInterface.cc"
+	end
+
+	def Testing.writeInterfaceFile(functions)
+		f=File.open(interfaceFile,"w")
+		writeInterface(functions,f)
+		f.close
+	end
+
+	def Testing.writeInterface(functions,fileHandle)
+		funcDeclarations=functions.collect{|f|"int #{f}();"}.join("\n")
+		wrappers=functions.collect{|f|"VALUE wrap#{f}(ANYARGS)\n{\n  VALUE r=rb_intern(\"\");\n  #{f}();\n  return r;\n}"}.join("\n")
+		funcDefinitions=functions.collect{|f|"rb_define_module_function(mModule,\"#{f}\",&wrap#{f},0);"}.join("\n")
+
+		fileHandle.puts <<EOT
+
+#include <ruby.h>
+
+#{funcDeclarations}
+
+#{wrappers}
+
+void Init_#{moduleName}()
+{
+	VALUE mModule = rb_define_module("#{moduleName}");
+
+	#{funcDefinitions}
+}
+EOT
+	
+	end
+end
\ No newline at end of file

Added: antargis/branches/rant/build/testing.rb
===================================================================
--- antargis/branches/rant/build/testing.rb	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/build/testing.rb	2007-08-21 19:10:47 UTC (rev 1159)
@@ -0,0 +1,4 @@
+$:.push("build")
+
+require 'test_suite_c.rb'
+

Modified: antargis/branches/rant/configure
===================================================================
--- antargis/branches/rant/configure	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/configure	2007-08-21 19:10:47 UTC (rev 1159)
@@ -52,15 +52,15 @@
 
 if $:.join("")=~/1.8/
 	if isWindows
-		CFG.set("RUBYLIB","msvcrt-ruby18")
+		CFG.set("RUBYLIB","-lmsvcrt-ruby18")
 	else
-		CFG.set("RUBYLIB","ruby1.8")
+		CFG.set("RUBYLIB","-lruby1.8")
 	end
 else
 	if isWindows
-		CFG.set("RUBYLIB","msvcrt-ruby19")
+		CFG.set("RUBYLIB","-lmsvcrt-ruby19")
 	else
-		CFG.set("RUBYLIB","ruby1.9")
+		CFG.set("RUBYLIB","-lruby1.9")
 	end
 end
 
@@ -89,6 +89,13 @@
         CFG.set("CFLAGS",libs) if libs        
     end
 
+
+CFG.addOption("use-mkmf","",
+	"use ruby's configuration mechanism for configuration") do  ||
+		CFG.gatherMkmfInfo
+	end
+
+
 CFG.includeConfig
 
 

Modified: antargis/branches/rant/ext/basic/ag_main.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_main.cc	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/ext/basic/ag_main.cc	2007-08-21 19:10:47 UTC (rev 1159)
@@ -134,6 +134,7 @@
   static bool registered=false;
   if(!registered)
     {
+      // registered must be set here, so that we don't get into an endless recursion
       registered=true;
 
       // IMPORTANT:

Modified: antargis/branches/rant/ext/basic/init.cc
===================================================================
--- antargis/branches/rant/ext/basic/init.cc	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/ext/basic/init.cc	2007-08-21 19:10:47 UTC (rev 1159)
@@ -22,6 +22,7 @@
 
   // register main in ruby-var
 
+  // the following can't be done, because getMain is not yet exported to ruby at the point of the flow
   //  AG_NewPointerObj(result,SWIGTYPE_p_AGMain,0);
   //  rb_eval_string("include Libantargisbasic;$agMain=getMain");
 

Modified: antargis/branches/rant/ext/sound/ag_mixer.cc
===================================================================
--- antargis/branches/rant/ext/sound/ag_mixer.cc	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/ext/sound/ag_mixer.cc	2007-08-21 19:10:47 UTC (rev 1159)
@@ -293,10 +293,13 @@
 }
 AGSound::AGSound():AGMessageObject(),sigMp3Finished(this,"sigMp3Finished")
 {
-	if(getCollector())
-		getCollector()->insertGlobal(this);
-	else
-		std::cerr<<"Possible Error:getCollector()==0!"<<std::endl;
+  if(getCollector())
+    getCollector()->insertGlobal(this);
+  else
+    {
+      std::cerr<<"Error:getCollector()==0!"<<std::endl;
+      exit(1);
+    }
   REGISTER_SINGLETON(this);
   soundVol=1.0f;
 
@@ -449,6 +452,9 @@
     {
       mSoundManager=new AGSound;
     }
+
+  getMain()->getCollector()->insertGlobal(mSoundManager);
+
   return mSoundManager;
 }
 

Modified: antargis/branches/rant/ext/sound/init.cc
===================================================================
--- antargis/branches/rant/ext/sound/init.cc	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/ext/sound/init.cc	2007-08-21 19:10:47 UTC (rev 1159)
@@ -5,5 +5,5 @@
 
 AGEXPORT void AG_Init_libantargissound()
 {
-	initSoundEngine();
+  initSoundEngine();
 }

Modified: antargis/branches/rant/ext/video/ag_video.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_video.cc	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/ext/video/ag_video.cc	2007-08-21 19:10:47 UTC (rev 1159)
@@ -92,6 +92,10 @@
     {
       std::cerr<<"Initing video mode failed!"<<std::endl;
       std::cerr<<"SDL:Error:"<<SDL_GetError()<<std::endl;
+      std::cerr<<"If you experience errors here, it may be that one following is true:"<<std::endl;
+      std::cerr<<"* SDL is compiled without OpenGL support"<<std::endl;
+      std::cerr<<"* Your display has no support for GLX"<<std::endl;
+      std::cerr<<"* You're running SDL with framebuffer - instead of X"<<std::endl;
       exit(1);
     }
 

Modified: antargis/branches/rant/ruby/antargis.rb
===================================================================
--- antargis/branches/rant/ruby/antargis.rb	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/ruby/antargis.rb	2007-08-21 19:10:47 UTC (rev 1159)
@@ -282,11 +282,11 @@
 			else
 				fps=sprintf("%3.0f", at fps)
 			end
-			puts "FPS:"+fps
-			puts "pick-tris:"+getScene.getPickTriangles.to_s
+			#puts "FPS:"+fps
+			#puts "pick-tris:"+getScene.getPickTriangles.to_s
 			@statusBar.setText(_("FPS:{1}",fps.to_s))
-			puts "Tris:"+getScene.getTriangles.to_s
-			puts "MESHES:"+getScene.getDrawnMeshes.to_s
+			#puts "Tris:"+getScene.getTriangles.to_s
+			#puts "MESHES:"+getScene.getDrawnMeshes.to_s
 			@frameCount=0
 			@elapsTime=0
 			startGC

Modified: antargis/branches/rant/ruby/mainmenu.rb
===================================================================
--- antargis/branches/rant/ruby/mainmenu.rb	2007-08-19 18:14:44 UTC (rev 1158)
+++ antargis/branches/rant/ruby/mainmenu.rb	2007-08-21 19:10:47 UTC (rev 1159)
@@ -412,8 +412,8 @@
 		@frames||=0
 		@frameTime+=t
 		@frames+=1
-		if @frames>10
-			puts "FPS:#{10.0/@frameTime}"
+		if @frames>100
+			puts "FPS:#{100.0/@frameTime}"
 			@frameTime=0
 			@frames=0
 		end



From davidkamphausen at mail.berlios.de  Tue Aug 21 21:11:17 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Tue, 21 Aug 2007 21:11:17 +0200
Subject: [Antargis-svn] r1160 - antargis/branches/rant
Message-ID: <200708211911.l7LJBHXk031967@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-08-21 21:11:17 +0200 (Tue, 21 Aug 2007)
New Revision: 1160

Added:
   antargis/branches/rant/mytest.rb
Log:
A    mytest.rb


Added: antargis/branches/rant/mytest.rb
===================================================================
--- antargis/branches/rant/mytest.rb	2007-08-21 19:10:47 UTC (rev 1159)
+++ antargis/branches/rant/mytest.rb	2007-08-21 19:11:17 UTC (rev 1160)
@@ -0,0 +1,13 @@
+#!/usr/bin/env ruby
+
+require 'build/testing.rb'
+
+
+testFiles=Dir[File.join("ext/**/tests/*.cc")]
+
+
+testFiles.each{|file|
+	puts "TEST: #{file}"
+	Testing.runCTest(file)
+}
+



From davidkamphausen at mail.berlios.de  Wed Aug 22 19:49:57 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Wed, 22 Aug 2007 19:49:57 +0200
Subject: [Antargis-svn] r1161 - in antargis/branches/rant: . build
	ext/game/tests
Message-ID: <200708221749.l7MHnvYw010066@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-08-22 19:49:56 +0200 (Wed, 22 Aug 2007)
New Revision: 1161

Modified:
   antargis/branches/rant/Rantfile
   antargis/branches/rant/build/base_tools.rb
   antargis/branches/rant/build/test_suite_c.rb
   antargis/branches/rant/ext/game/tests/test_vector_sort.cc
   antargis/branches/rant/mytest.rb
Log:
* added c-testing


Modified: antargis/branches/rant/Rantfile
===================================================================
--- antargis/branches/rant/Rantfile	2007-08-21 19:11:17 UTC (rev 1160)
+++ antargis/branches/rant/Rantfile	2007-08-22 17:49:56 UTC (rev 1161)
@@ -348,4 +348,19 @@
 #var[:clean].include ".deps/*"
 ###########################################
 
+task :check_c_prgs do
+	require 'build/testing.rb'
+	
+	Cmd.setQuiet(true)
+	
+	testFiles=Dir[File.join("ext/**/tests/*.cc")]
+	
+	testFiles.each{|file|
+		Testing.runCTest(file)
+	}
+	puts Testing.getStats
 
+end
+
+task :check=> [:check_c_prgs] do
+end

Modified: antargis/branches/rant/build/base_tools.rb
===================================================================
--- antargis/branches/rant/build/base_tools.rb	2007-08-21 19:11:17 UTC (rev 1160)
+++ antargis/branches/rant/build/base_tools.rb	2007-08-22 17:49:56 UTC (rev 1161)
@@ -56,8 +56,10 @@
 end
 
 module Cmd
+	@@quiet=false 
 	def Cmd.sys(cmd)
-		puts cmd
+		
+		puts cmd if not @@quiet
 		#as=`#{cmd}`
 		
 		#puts "-#{cmd}-",cmd.class
@@ -66,6 +68,10 @@
 		raise 1 unless res
 		
 	end
+
+	def Cmd.setQuiet(flag)
+		@@quiet=flag
+	end
 end
 
 

Modified: antargis/branches/rant/build/test_suite_c.rb
===================================================================
--- antargis/branches/rant/build/test_suite_c.rb	2007-08-21 19:11:17 UTC (rev 1160)
+++ antargis/branches/rant/build/test_suite_c.rb	2007-08-22 17:49:56 UTC (rev 1161)
@@ -1,9 +1,10 @@
 require 'build/base_tools.rb'
 module Testing
+	@@stats={}
+	def Testing.runCTest(file)
+		@@stats={}
 
-
-	def Testing.runCTest(file)
-		puts file
+		puts "testing #{file}"
 		functions=extractFunctions(file)
 
 		writeInterfaceFile(functions)
@@ -11,25 +12,79 @@
 		files.each{|f|Build.compile(f)}
 		objs=files.collect{|f|Build.cFileToObj(f)}
 
-		Build.linkToLib(libName,objs,[])
+		Build.linkToLib(libName,objs,extLibs)
+		runTest(functions)
 
 	end
+
+	def Testing.getStats
+		@@stats
+	end
+
 private
+
+	def Testing.initRunEnvironment
+		if ENV["WINDIR"] and false
+      ENV["PATH"]+=";.\\ext"
+    else
+      ENV["PATH"]+=":./ext"
+		end
+		$:.push("ext")
+		ENV["LD_LIBRARY_PATH"]||=""
+		ENV["LD_LIBRARY_PATH"]+="./ext/"
+	end
+	def Testing.runTest(functions)
+		initRunEnvironment
+
+		funcCalls=functions.map{|f|"result[\"#{f}\"]=#{f}"}.join("\n")
+
+		script=<<EOT
+require '#{libName}'
+include #{moduleName}
+result={}
+#{funcCalls}
+result.each{|k,v|
+	puts "TESTING:"+k.to_s+":"+v.to_s
+}
+EOT
+		f=File.open("curtest.rb","w")
+		f.puts script
+		f.close
+		output=`ruby curtest.rb`
+
+		result=output.split("\n").select{|l|l=~/^TESTING/}.map{|l|l.gsub("TESTING:","").split(":")}
+
+		result.each{|a|
+			puts a[0]+":::"+a[1]
+			k=a[0]
+			v=a[1]=="true"
+	
+			@@stats[v]||=0
+			@@stats[v]+=1
+		}
+		
+		puts output
+	end
+
 	def Testing.extractFunctions(file)
 		content=File.open(file,"r").read
 
-		lines=content.split("\n").select{|line|line=~/int test_[a-zA-Z_0-9]+\(\)/}
+		lines=content.split("\n").select{|line|line=~/bool +test_[a-zA-Z_0-9]+\(\)/}
 		functions=lines.collect{|line|line.gsub(/.* test/,"test").gsub(/\(.*/,"")}
-		puts functions.join("\n")
 		functions
 	end
 
+	def Testing.extLibs
+		#return []
+		Dir["ext/*.so"].select{|f|not f=~/lib/}.collect{|f|f.gsub(/^ext\/(.*)\.so/,'-l\1')}-["-lanttesting"]
+	end
+
 	def Testing.libName
-		"anttesting.so"
+		"ext/anttesting.so"
 	end
 
 	def Testing.moduleName
-		"anttesting"
+		"Anttesting"
 	end
 
 	def Testing.interfaceFile
@@ -43,24 +98,26 @@
 	end
 
 	def Testing.writeInterface(functions,fileHandle)
-		funcDeclarations=functions.collect{|f|"int #{f}();"}.join("\n")
-		wrappers=functions.collect{|f|"VALUE wrap#{f}(ANYARGS)\n{\n  VALUE r=rb_intern(\"\");\n  #{f}();\n  return r;\n}"}.join("\n")
+		funcDeclarations=functions.collect{|f|"bool #{f}();"}.join("\n")
+		wrappers=functions.collect{|f|"VALUE wrap#{f}(ANYARGS)\n{\n  bool r=#{f}();\n  return (r?Qtrue:Qfalse);\n}"}.join("\n")
 		funcDefinitions=functions.collect{|f|"rb_define_module_function(mModule,\"#{f}\",&wrap#{f},0);"}.join("\n")
 
 		fileHandle.puts <<EOT
 
 #include <ruby.h>
+#include <stdio.h>
 
 #{funcDeclarations}
 
 #{wrappers}
-
-void Init_#{moduleName}()
+extern "C" {
+void Init_#{moduleName.downcase}()
 {
 	VALUE mModule = rb_define_module("#{moduleName}");
 
 	#{funcDefinitions}
 }
+}
 EOT
 	
 	end

Modified: antargis/branches/rant/ext/game/tests/test_vector_sort.cc
===================================================================
--- antargis/branches/rant/ext/game/tests/test_vector_sort.cc	2007-08-21 19:11:17 UTC (rev 1160)
+++ antargis/branches/rant/ext/game/tests/test_vector_sort.cc	2007-08-22 17:49:56 UTC (rev 1161)
@@ -3,7 +3,7 @@
 #include <set>
 #include <ag_debug.h>
 
-int test_vector_sort()
+bool test_vector_sort()
 {
   AGVector2 m(2,2);
   DistanceOrder order(m);
@@ -33,11 +33,17 @@
   cdebug("2:"<<v[2]<<"  "<<b<<"  "<<(b-m).length());
   cdebug("3:"<<v[3]<<"  "<<c<<"  "<<(c-m).length());
   */
-
+return false;
   assert(v[0]==d);
   assert(v[1]==a);
   assert(v[2]==b);
   assert(v[3]==c);
 
-  return 0;
+  return true;
 }
+
+
+bool test_my_test()
+{
+	return true;
+}

Modified: antargis/branches/rant/mytest.rb
===================================================================
--- antargis/branches/rant/mytest.rb	2007-08-21 19:11:17 UTC (rev 1160)
+++ antargis/branches/rant/mytest.rb	2007-08-22 17:49:56 UTC (rev 1161)
@@ -2,12 +2,11 @@
 
 require 'build/testing.rb'
 
+Cmd.setQuiet(true)
 
 testFiles=Dir[File.join("ext/**/tests/*.cc")]
 
-
 testFiles.each{|file|
-	puts "TEST: #{file}"
 	Testing.runCTest(file)
 }
 



From davidkamphausen at mail.berlios.de  Sat Aug 25 21:26:26 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 25 Aug 2007 21:26:26 +0200
Subject: [Antargis-svn] r1162 - in antargis/branches/rant: . build/configs
	ext/3dengine ext/game ruby
Message-ID: <200708251926.l7PJQQQc028799@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-08-25 21:26:25 +0200 (Sat, 25 Aug 2007)
New Revision: 1162

Added:
   antargis/branches/rant/ruby/ant_path.rb
Removed:
   antargis/branches/rant/ext/game/path_base.cc
   antargis/branches/rant/ext/game/path_base.h
   antargis/branches/rant/ext/game/path_v2.cc
   antargis/branches/rant/ext/game/path_v2.h
   antargis/branches/rant/ext/game/path_v3.h
Modified:
   antargis/branches/rant/Rantfile
   antargis/branches/rant/TODO
   antargis/branches/rant/build/configs/unix.rb
   antargis/branches/rant/ext/3dengine/boa_3d_wireframe.cc
   antargis/branches/rant/ext/3dengine/boa_3d_wireframe.h
   antargis/branches/rant/ext/game/path.cc
   antargis/branches/rant/ext/game/path.h
   antargis/branches/rant/ruby/ant_hljobs.rb
   antargis/branches/rant/ruby/map.rb
Log:
* combined path finder (water+normal)


Modified: antargis/branches/rant/Rantfile
===================================================================
--- antargis/branches/rant/Rantfile	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/Rantfile	2007-08-25 19:26:25 UTC (rev 1162)
@@ -221,11 +221,18 @@
 
 gen Rule, /^.*swig.(cc|h)$/ => swigSrc do |t|
 
-    puts "SOURCE #{t.source} #{t.name}"
+	puts "SOURCE #{t.source} #{t.name}"
 
 	cmd=makeCommand("SWIG_CALL",sys.expand_path(t.name.gsub(/\.h$/,".cc")),"-DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR} #{sys.expand_path(t.source)}".gsub("/",Dir.separator))
 	sys cmd
 	puts
+
+	incs="-DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR}"
+	out=".deps"+Dir.separator+sys.expand_path(t.name).gsub("/","_")
+	cmd=makeCommand("SWIGDEPS",out,incs+" "+sys.expand_path(t.name.gsub(/[0-9_a-z]*\.h$/,"interface.i")))
+	sys cmd
+	puts
+
 end
 #
 ###########################################
@@ -345,7 +352,7 @@
 gen AutoClean, :clean
 var[:clean].include "**/marker.i"   # not needed any more - managed by Rule
 var[:clean].include "ext/*.so"
-#var[:clean].include ".deps/*"
+var[:clean].include ".deps"
 ###########################################
 
 task :check_c_prgs do

Modified: antargis/branches/rant/TODO
===================================================================
--- antargis/branches/rant/TODO	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/TODO	2007-08-25 19:26:25 UTC (rev 1162)
@@ -1,3 +1,5 @@
+* introduce path-finder with water
+
 * download allinoneruby.rb
 * build allinoneruby.exe
 * put ag_sdl*.tar.gz into svn
@@ -4,9 +6,9 @@
 * put up instructions into wiki
 
 
-* docs
-* configure
-* "contrib"
- * autopackage
- * debian
- * antargis.iss
\ No newline at end of file
+* docs
+* configure
+* "contrib"
+ * autopackage
+ * debian
+ * antargis.iss

Modified: antargis/branches/rant/build/configs/unix.rb
===================================================================
--- antargis/branches/rant/build/configs/unix.rb	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/build/configs/unix.rb	2007-08-25 19:26:25 UTC (rev 1162)
@@ -29,7 +29,7 @@
 	# generate c++-code from a swig-interface file
 	"SWIG_CALL"=>"$(SWIG) -v -Wall -ruby -c++ -o $(OUTPUT) $(INPUT)",
 	# generate dependencies for swig-interface files
-	"SWIGDEPS"=>"$(SWIG) -ruby -c++ -M $(INPUT)",
+	"SWIGDEPS"=>"$(SWIG) -ruby -c++ -M $(INPUT)>$(OUTPUT)",
 
 	# generate a swig-interface-file from the c++-sources and some other pre-defined interface-files (.i)
 	# go to build/*.i or ext/*/*.i for more information

Modified: antargis/branches/rant/ext/3dengine/boa_3d_wireframe.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/boa_3d_wireframe.cc	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/ext/3dengine/boa_3d_wireframe.cc	2007-08-25 19:26:25 UTC (rev 1162)
@@ -2,8 +2,9 @@
 #include <ag_rendercontext.h>
 #include <ag_debug.h>
 
-Boa3dWireframe::Boa3dWireframe(Scene *pScene,const AGVector4 &pColor):
-  SceneNode(pScene,AGVector4(0,0,0,0),AGBox3(AGVector3(0,0,0),AGVector3(100,100,100)))
+Boa3dWireframe::Boa3dWireframe(Scene *pScene,const AGVector4 &pColor,float pWidth):
+  SceneNode(pScene,AGVector4(0,0,0,0),AGBox3(AGVector3(0,0,0),AGVector3(100,100,100))),
+  mWidth(pWidth)
 {
   mColor=pColor;
   mChanged=true;
@@ -21,7 +22,7 @@
 
   
   AGRenderContext c;
-  glLineWidth(3);
+  glLineWidth(mWidth);
 
   //  c.setDepthTest(false);
 

Modified: antargis/branches/rant/ext/3dengine/boa_3d_wireframe.h
===================================================================
--- antargis/branches/rant/ext/3dengine/boa_3d_wireframe.h	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/ext/3dengine/boa_3d_wireframe.h	2007-08-25 19:26:25 UTC (rev 1162)
@@ -14,7 +14,7 @@
   };
 
  public:
-  Boa3dWireframe(Scene *pScene,const AGVector4 &pColor);
+  Boa3dWireframe(Scene *pScene,const AGVector4 &pColor,float pWidth);
 
   void draw();
 
@@ -29,6 +29,8 @@
 
   bool mChanged;
 
+  float mWidth;
+
 };
 
 

Modified: antargis/branches/rant/ext/game/path.cc
===================================================================
--- antargis/branches/rant/ext/game/path.cc	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/ext/game/path.cc	2007-08-25 19:26:25 UTC (rev 1162)
@@ -109,83 +109,61 @@
   return 0;
 }
 
-/*
-SimpleGraph::HalfEdge *SimpleGraph::Edge::getHalfEdgeFrom(Node *n)
-{
-  HalfEdge *h;
-  if(a==n)
-    {
-      h->a=a;
-      h->b=b;
-      h->w=w0;
-    }
-  else
-    {
-      h->b=a;
-      h->a=b;
-      h->w=w1;
-    }
-  return h;
-}
-SimpleGraph::HalfEdge *SimpleGraph::Edge::getHalfEdgeTo(Node *n)
-{
-  HalfEdge *h;
-  if(a!=n)
-    {
-      h->a=a;
-      h->b=b;
-      h->w=w0;
-    }
-  else
-    {
-      h->b=a;
-      h->a=b;
-      h->w=w1;
-    }
-  return h;
-  }*/
 
-
 ///////////////////////////////////////////////////////////////////////
 // PathWeighter
 ///////////////////////////////////////////////////////////////////////
 
+PathWeighter::PathWeighter(bool pWaterPassable):mWaterPassable(pWaterPassable)
+{
+}
+
 PathWeighter::~PathWeighter()
 {
 }
 float PathWeighter::weight(float h0,float h1)
 {
   if(h0<0.3 || h1<0.3)
-    return 100000; // high weight for non-passable water ;-)
+    {
+      if(mWaterPassable)
+	{
+	  return 0;//fabs(std::max(h0,h1)-std::max(0.3f,std::min(h0,h1)));
+	}
+      else
+	return 100000; // high weight for non-passable water ;-)
+    }
 
   return fabs(h0-h1);
 }
 
+bool PathWeighter::isWaterPassable() const
+{
+  return mWaterPassable;
+}
+
 ///////////////////////////////////////////////////////////////////////
 // MapPathWeighter
 ///////////////////////////////////////////////////////////////////////
 
-MapPathWeighter::MapPathWeighter(HeightMap *pMap):
+MapPathWeighter::MapPathWeighter(HeightMap *pMap,bool pWaterPassable):
+  PathWeighter(pWaterPassable),
   mMap(pMap)
 {
 }
 float MapPathWeighter::weight(const AGVector2 &a,const AGVector2 &b)
 {
   return complexWeight(a,b);
+}
 
+/**
+   computes a weight between a and b, which can be far apart. the computed path between
+   the waypoints is linear!
 
+   \param a waypoint
+   \param b waypoint
+   \return weight
 
-  float w=(a-b).length();
-  if(w>1)
-    throw std::runtime_error("not implemented");
-  float h0=mMap->getHeight(a[0],a[1]);
-  float h1=mMap->getHeight(b[0],b[1]);
-
-  w+=weightHeight(h0,h1);
-
-  return w;
-}
-
+*/
 float MapPathWeighter::complexWeight(const AGVector2 &a,const AGVector2 &b)
 {
   // simply measure all "1 units"
@@ -223,7 +201,10 @@
 {
   float f=1; // some factor - to be estimated
 
+  if((a<0.3 && b<0.3) && isWaterPassable())
+    return 0; // water
 
+
   if(b<0.2)
     return (0.2-b)*1000;
 
@@ -236,12 +217,12 @@
     return -(b-a)*f*0.3; 
 }
 
-
-
-
 bool MapPathWeighter::accessible(const AGVector2 &a)
 {
-  //  return true;
+  // FIXME: maybe make some terrain impassable
+
+  if(isWaterPassable())
+    return true;
   float hmin=10;
   for(int x=-1;x<2;x++)
     for(int y=-1;y<2;y++)
@@ -257,6 +238,9 @@
 
 
 
+
+
+
 ///////////////////////////////////////////////////////////////////////
 // Graph
 ///////////////////////////////////////////////////////////////////////

Modified: antargis/branches/rant/ext/game/path.h
===================================================================
--- antargis/branches/rant/ext/game/path.h	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/ext/game/path.h	2007-08-25 19:26:25 UTC (rev 1162)
@@ -7,47 +7,71 @@
 #include "heuristic.h"
 
 #include <ag_serial.h>
-
 #include <ag_surface.h>
 
 /**
-   This file is WORK-IN-PROGRESS !!!!!!!!!!!!!!!!!!!!!!
-
-   The purpose is some path-finding-algorithm based upon "A-star". (A*)
+   The purpose of this file is some path-finding-algorithm based upon "A-star". (A*)
    
    Because path-finding is a somewhat hard topic, we should try some
    hierarchical approach:
    * build some graph out of the height-map - weight come from height and terrain-type (swamp and deep sand vs. plain grass)
-   * nodes that are near each other get eliminated (thrown together), if terrain connection is possible (and too much longer)
-   * several levels of this graph can be used, according to the distance that has to be gone
+   * nodes that are near each other get eliminated (thrown together), if terrain connection is possible (and not too much longer)
+   * (mayto TODO: several levels of this graph can be used, according to the distance that has to be gone)
    * for people that have boats, water can be crossed, so there has to be a different path-graph !
 
+   Computation goes as follows:
+   * You define a Path-Weighter, that weighs distances on a map (or without a map - for very simple cases (that we won't use here though))
+   * Feed this into a makeGraph(...)-call
+   * decimate the graph, if you want to
+   * compute a heuristic on the resulting-graph - e.g. the full-computed distance-field for all nodes (in StoredHeuristicFunction)
+   * create a Pathfinder-object using graph and heuristic
+   * use this Pathfinder to compute distances and pathes :-)
+
+   NOTE:
+   * Within the game these classes won't be used directly, but through the CombinedPathFinder-ruby-class
 */
 
 class Heuristic;
 
+/**
+   PathWeighter is a (not-really-used) base-class for the path-weighing-facility. It though stores, if water is
+   passable.
+   
+   FIXME: integrate PathWeighter into MapPathWeighter!
+ */
 class AGEXPORT PathWeighter:public AGRubyObject
 {
  public:
+  PathWeighter(bool pWaterPassable=false);
   virtual ~PathWeighter();
+  /// this function can be overridden - and will be
   virtual float weight(float h0,float h1);
+
+  bool isWaterPassable() const;
+ private:
+  bool mWaterPassable;
 };
 
 class AGEXPORT MapPathWeighter:public PathWeighter
 {
  public:
-  MapPathWeighter(HeightMap *pMap);
+  MapPathWeighter(HeightMap *pMap,bool pWaterPassable);
   virtual float weight(const AGVector2 &a,const AGVector2 &b);
   virtual bool accessible(const AGVector2 &a);
  private:
 
   virtual float complexWeight(const AGVector2 &a,const AGVector2 &b);
+
+  /// compute a weight for a flank. Compares the heights a and b. used by complexWeight
   virtual float weightHeight(float a,float b) const;
 
   HeightMap *mMap;
 };
 
 
+/**
+   AGVector2Sort is a simple sorting class for use in sorting containers, like map or set.
+ */
 struct AGEXPORT AGVector2Sort
 {
   public:
@@ -99,11 +123,6 @@
 
     Node *getOther(Node *n);
 
-    /*
-    HalfEdge *getHalfEdgeFrom(Node *n);
-
-    HalfEdge *getHalfEdgeTo(Node *n);
-    */
   };
 
   struct Node

Deleted: antargis/branches/rant/ext/game/path_base.cc
===================================================================
--- antargis/branches/rant/ext/game/path_base.cc	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/ext/game/path_base.cc	2007-08-25 19:26:25 UTC (rev 1162)
@@ -1,9 +0,0 @@
-#include <path_base.h>
-
-AGPathBase::~AGPathBase()
-{
-}
-float AGPathBase::weight(const AGVector2 &a,const AGVector2 &b)
-{
-  return 0;
-}

Deleted: antargis/branches/rant/ext/game/path_base.h
===================================================================
--- antargis/branches/rant/ext/game/path_base.h	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/ext/game/path_base.h	2007-08-25 19:26:25 UTC (rev 1162)
@@ -1,16 +0,0 @@
-#ifndef PATH_BASE_H
-#define PATH_BASE_H
-
-// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
-
-#include <ag_geometry.h>
-#include <ag_rubyobj.h>
-
-class AGEXPORT AGPathBase:public AGRubyObject
-{
- public:
-  virtual ~AGPathBase();
-  virtual float weight(const AGVector2 &a,const AGVector2 &b);
-};
-
-#endif

Deleted: antargis/branches/rant/ext/game/path_v2.cc
===================================================================
--- antargis/branches/rant/ext/game/path_v2.cc	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/ext/game/path_v2.cc	2007-08-25 19:26:25 UTC (rev 1162)
@@ -1,305 +0,0 @@
-#include "path_v2.h"
-#include <ag_debug.h>
-#include <ag_geometry.h>
-#include <set>
-
-
-#include "path_vector_sort.h"
-
-
-
-///////////////////////////////////////////////////////////////////////////////////
-
-
-/**
- * PathV2Data constructor - does nothing yet
- */
-PathV2Data::PathV2Data(size_t pBaseSize):mBaseSize(pBaseSize)
-{
-}
-
-
-void PathV2Data::compute(const DistanceComputer &pCalc)
-{
-  mMatrices.clear();
-
-  float x,y;
-  size_t ix,iy;
-
-  for(x=pCalc.beginX();x<=pCalc.endX();x+=pCalc.stepX())
-    {
-      for(y=pCalc.beginY();y<=pCalc.endY();y+=pCalc.stepY())
-	{
-	  AGVector2 start(x,y);
-
-	  traceFrom(pCalc,start);
-	}
-    }
-
-}
-
-
-void PathV2Data::traceFrom(const DistanceComputer &pCalc,const AGVector2 &p)
-{
-  // FIXME: maybe store directly into matrix ???
-
-  std::map<AGVector2,float> distances;
-  std::list<AGVector2> queue; // FIXME: use a distance-filter ????
-
-  float cDist,nextDist,oldDist;
-  AGVector2 curPos;
-
-  queue.push_back(p);
-  distances[p]=0;
-
-  while(queue.size()>0)
-    {
-      curPos=queue.front();
-      queue.pop_front();
-      cDist=distances[curPos];
-      std::vector<std::pair<AGVector2,float> > neighbors=pCalc.getAllReachableFrom(curPos);
-
-      for(std::vector<std::pair<AGVector2,float> >::iterator i=neighbors.begin();i!=neighbors.end();i++)
-	{
-	  nextDist=cDist+i->second;
-	  oldDist=distances[i->first];
-	  if(oldDist==0 || nextDist<oldDist)
-	    {
-	      // store in map
-	      distances[i->first]=nextDist;
-	      // push into queue
-	      queue.push_back(i->first);
-	    }
-	}
-
-    }
-
-  // ok, we're ready
-  // store into matrix
-  
-  size_t matrixWidth=size_t((pCalc.endX()-pCalc.beginX())/pCalc.stepX()+1);
-  size_t matrixHeight=size_t((pCalc.endY()-pCalc.beginY())/pCalc.stepY()+1);
-
-  AGMatrixN matrix(matrixWidth,matrixHeight);
-
-  for(std::map<AGVector2,float>::iterator i=distances.begin();i!=distances.end();i++)
-    {
-      size_t x=size_t((i->first[0]-pCalc.beginX())/pCalc.stepX());
-      size_t y=size_t((i->first[1]-pCalc.beginY())/pCalc.stepY());
-      matrix.set(x,y,i->second);
-    }
-
-  //FIXME  mMatrices.push_back(matrix);
-  
-}
-
-
-
-
-///////////////////////////////////////////////////////////////////////////////////
-
-/**
- * PathV2 constructor
- * \param pData the data that's used to compute distances - is owned by PathV2 later on!
- */
-PathV2::PathV2(PathV2Data *pData):mData(pData)
-{
-}
-
-PathV2::~PathV2()
-{
-  if(mData)
-    saveDelete(mData);
-}
-
-
-float PathV2::weight(const AGVector2 &a,const AGVector2 &b)
-{
-}
-
-void PathV2::mark()
-{
-  markObject(mData);
-}
-
-
-
-
-
-
-
-
-
-/**
- * PathV3Data constructor
- */
-
-PathV3Data::PathV3Data(size_t pFieldCount):
-  mFieldCount(pFieldCount)
-{
-}
-
-
-void PathV3Data::compute(const DistanceComputer &pCalc)
-{
-  std::vector<AGVector2> allValidPoints;
-  std::set<AGVector2> allValidPointsSet;
-  AGVector2 currentPoint;
-  float x,y;
-
-  for(x=pCalc.beginX();x<=pCalc.endX();x+=pCalc.stepX())
-    {
-      for(y=pCalc.beginY();y<=pCalc.endY();y+=pCalc.stepY())
-	{
-	  currentPoint=AGVector2(x,y);
-	  if(pCalc.isPassable(currentPoint))
-	    {
-	      allValidPoints.push_back(currentPoint);
-	    }
-	}
-    }
-
-  std::copy(allValidPoints.begin(),allValidPoints.end(),std::inserter(allValidPointsSet,allValidPointsSet.begin()));
-
-  size_t estFieldSize=allValidPoints.size()/mFieldCount;
-  // shuffle ???
-
-
-  cdebug("estFieldSize:"<<estFieldSize);
-
-  while(allValidPoints.size()>0)
-    {
-      // make new field
-      size_t randomIndex=rand()%allValidPoints.size();
-      std::set<AGVector2> currentField;
-      AGVector2 fieldMiddle=allValidPoints[randomIndex];
-
-      currentField.insert(fieldMiddle);
-      allValidPointsSet.erase(fieldMiddle);
-
-      // grow field
-      
-      DistanceOrder order(fieldMiddle);
-      std::set<AGVector2,DistanceOrder> growField(order);//(DistanceOrder(fieldMiddle));
-      //      std::set<AGVector2> growField;
-      growField.insert(fieldMiddle);
-
-      while(currentField.size()<estFieldSize && growField.size()>0)
-	{
-	  currentPoint=*growField.begin();
-	  growField.erase(currentPoint);
-	  mVec2Field[currentPoint]=mFields.size();
-
-	  std::vector<std::pair<AGVector2,float> > reachable=pCalc.getAllReachableFrom(currentPoint);
-
-	  //	  cdebug("reachable:"<<reachable.size()<<" currentPoint:"<<currentPoint);
-
-	  for(std::vector<std::pair<AGVector2,float> >::iterator i=reachable.begin();i!=reachable.end();i++)
-	    {
-	      //	      cdebug("1");
-	      if(growField.find(i->first)==growField.end())
-		{
-		  //		  cdebug("2");
-		  if(currentField.find(i->first)==currentField.end())
-		    {
-		      //		      cdebug("3");
-		      //		      cdebug("allValid:"<<allValidPointsSet.size());
-
-		      //		      for(  std::set<AGVector2>::iterator k=allValidPointsSet.begin();k!=allValidPointsSet.end();k++)
-		      //			{
-		      //			  cdebug(i->first<<":"<<*k<<":"<<(i->first==*k));
-		      //			}
-
-
-		      if(allValidPointsSet.find(i->first)!=allValidPointsSet.end())
-			{
-			  //  cdebug("4");
-			  growField.insert(i->first);
-			  currentField.insert(i->first);
-			  allValidPointsSet.erase(i->first);
-
-			  mVec2Field[i->first]=mFields.size();
-			}
-		    }
-		}
-	    }
-
-	}
-
-
-      // copy back into vector
-      allValidPoints.clear();
-      std::copy(allValidPointsSet.begin(),allValidPointsSet.end(),std::back_inserter(allValidPoints));
-      std::list<AGVector2> resultField;
-      std::copy(currentField.begin(),currentField.end(),std::back_inserter(resultField));
-      mFields.push_back(resultField);
-
-      for(std::list<AGVector2>::iterator i=resultField.begin();i!=resultField.end();i++)
-	{
-	  cdebug(*i);
-	}
-      cdebug("----");
-    }
-  
-}
-
-
-std::list<AGVector2> PathV3Data::vecList(size_t field) const
-{
-  return mFields[field];
-}
-size_t PathV3Data::fieldCount() const
-{
-  return mFields.size();
-}
-
-float PathV3Data::getDistanceFromTo(const AGVector2 &pFrom,const AGVector2 &pTo) const
-{
-  //FIXME
-  return 0;
-}
-
-
-bool PathV3Data::isInField(const AGVector2 &pPoint,size_t pField) const
-{
-  std::map<AGVector2,size_t>::const_iterator i=mVec2Field.find(pPoint);
-
-  if(i==mVec2Field.end())
-    return false; //FIXME: throw exception
-
-  return i->second==pField;
-}
-
-std::map<size_t,float> PathV3Data::getNeighbors(size_t pField) const
-{
-  std::map<size_t,float> x;
-  //FIXME: implement me
-  return x;
-}
-
-
-size_t PathV3Data::getField(const AGVector2 &a) const
-{
-  std::map<AGVector2,size_t>::const_iterator i=mVec2Field.find(a);
-
-  if(i==mVec2Field.end())
-    return -1;
-
-  return i->second;
-}
-
-float PathV3Data::directNeighbors(const AGVector2 &a,const AGVector2 &b) const
-{
-  std::map<AGVector2,std::map<AGVector2,float> >::const_iterator i=mDirectMaps.find(a);
-
-  if(i==mDirectMaps.end())
-    return -1;
-  
-  std::map<AGVector2,float>::const_iterator j=i->second.find(b);
-
-  if(j==i->second.end())
-    return -2;
-
-  return j->second;
-
-}

Deleted: antargis/branches/rant/ext/game/path_v2.h
===================================================================
--- antargis/branches/rant/ext/game/path_v2.h	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/ext/game/path_v2.h	2007-08-25 19:26:25 UTC (rev 1162)
@@ -1,89 +0,0 @@
-#ifndef PATH_V2_H
-#define PATH_V2_H
-
-// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
-
-#include <path_base.h>
-#include <ag_algebra.h>
-
-#include <map>
-
-#include "path_weighter.h"
-
-class AGEXPORT PathV3Data:public AGRubyObject
-{
- public:
-  PathV3Data(size_t pFieldCount=64);
-
-
-  void compute(const DistanceComputer &pCalc);
-
-  /**
-   * \return -1 if they're no neighbors
-   *         >0 the distance when they're neighbors somehow
-   */
-  float directNeighbors(const AGVector2 &a,const AGVector2 &b) const;
-
-  size_t getField(const AGVector2 &a) const;
-  std::map<size_t,float> getNeighbors(size_t pField) const;
-
-  bool isInField(const AGVector2 &pPoint,size_t pField) const;
-
-  // pFrom and pTo must be in neighboring fields
-  float getDistanceFromTo(const AGVector2 &pFrom,const AGVector2 &pTo) const;
-  
-
-  std::list<AGVector2> vecList(size_t field) const;
-  size_t fieldCount() const;
-
-
- private:
-  
-  size_t mFieldCount;
-
-
-  std::map<AGVector2,size_t> mVec2Field;
-  std::vector<std::list<AGVector2> > mFields;
-  std::map<AGVector2,std::map<AGVector2,float> > mDirectMaps;
-  std::map<size_t,std::map<size_t,float> > mDirectFieldMaps;
-  
-};
-
-
-class AGEXPORT PathV2Data:public AGRubyObject
-{
- public:
-  PathV2Data(size_t pBaseSize=8);
-
-  void compute(const DistanceComputer &pCalc);
-
- private:
-  void traceFrom(const DistanceComputer &pCalc,const AGVector2 &p);
-
-  
-
-  std::map<AGVector2,AGMatrixN> mMatrices;
-  size_t mBaseSize;
-};
-
-
-
-class AGEXPORT PathBase:public AGRubyObject
-{
-};
-
-class AGEXPORT PathV2:public PathBase
-{
- public:
-  PathV2(PathV2Data *pData);
-  ~PathV2();
-
-  virtual float weight(const AGVector2 &a,const AGVector2 &b);
-
-  virtual void mark();
- private:
-  
-  PathV2Data *mData;
-};
-
-#endif

Deleted: antargis/branches/rant/ext/game/path_v3.h
===================================================================
--- antargis/branches/rant/ext/game/path_v3.h	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/ext/game/path_v3.h	2007-08-25 19:26:25 UTC (rev 1162)
@@ -1,7 +0,0 @@
-#ifndef PATH_V3_H
-#define PATH_V3_H
-
-#include "path_data_v3.h"
-
-
-#endif

Modified: antargis/branches/rant/ruby/ant_hljobs.rb
===================================================================
--- antargis/branches/rant/ruby/ant_hljobs.rb	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/ruby/ant_hljobs.rb	2007-08-25 19:26:25 UTC (rev 1162)
@@ -197,7 +197,7 @@
 # 		puts hero.getPos2D,pos
 # 		puts hero.getPos2D.class,pos.class
 		if getMap.path
-			@waypoints=getMap.path.computePath(hero.getPos2D, at pos)
+			@waypoints=getMap.path.computePath(hero.getPos2D, at pos, at hero)
 		else
 			@waypoints=[]
 		end
@@ -205,7 +205,7 @@
 		@waypoints.push(@pos)
 		if getMap.path
 			#puts "FIXME: ant_hljobs.rb:207"
-			@waypoints=getMap.path.refinePath(@waypoints,MapPathWeighter.new(getMap))
+			@waypoints=getMap.path.refinePath(@waypoints, at hero)
 		end
 		@men=getMen
 		@moveFinished=false

Added: antargis/branches/rant/ruby/ant_path.rb
===================================================================
--- antargis/branches/rant/ruby/ant_path.rb	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/ruby/ant_path.rb	2007-08-25 19:26:25 UTC (rev 1162)
@@ -0,0 +1,153 @@
+
+#
+# +CombinedPathFinder+ combines the C++-implemented basic funtions with
+# heuristc and path-find to a complete-pathfinder, that reacts to the
+# abilities of the calling entity.
+# It provides:
+# * loading/saving a cache of the computed data in file named after the map's hash
+# * computing a path/a distance w.r.t. to the abilities of an entity
+# ** currently it differentiates between having a boat and not
+#
+# It uses the following C++-classes:
+# * SimpleGraph/DecimatedGraph
+# * makeGraph (which produces a SimpleGraph)
+# * StoredHeuristicFunction
+# * Pathfinder
+#
+class CombinedPathFinder
+
+	# the current available modes, in which pathes will be computed. You can add some more here
+  # but you'll have to modify the functions getPathWeighter, getMode, displayPathfindingGraph
+	MODES=[:normal,:overWater]
+
+	def initialize(map)
+		@graph={}
+		@heuristic={}
+		@path={}
+		@map=map
+
+		# check Cache
+		cacheFilename=getCacheFilename(map)
+		if fileExists(findFile(cacheFilename))
+			loadFromFile(cacheFilename)
+		else
+			computeEverything(map)
+			saveToFile(cacheFilename)
+		end
+
+		# put them together
+		MODES.each{|mode|
+			@path[mode]=Pathfinder.new(@graph[mode], at heuristic[mode])
+		}
+	end
+
+	def distance(p0,p1,entity)
+		@path[getMode(entity)].distance(p0,p1)
+	end
+
+	def computePath(p0,p1,entity)
+		@path[getMode(entity)].computePath(p0,p1)
+	end
+	def refinePath(waypoints,entity)
+		mode=getMode(entity)
+		@path[mode].refinePath(waypoints,getPathWeighter(@map,mode))
+	end
+
+
+	def displayPathfindingGraph(map,scene)
+		colors={:normal=>AGVector4.new(1,0,0,1),:overWater=>AGVector4.new(1,1,0,1)}
+		width=2
+		MODES.each{|mode|
+			wireframe=Boa3dWireframe.new(scene,colors[mode],width)
+			(0..(@graph[mode].edges-1)).each{|i|
+				edge=@graph[mode].getEdgePosition(i)
+				a=edge[0]
+				b=edge[1]
+				a=AGVector3.new(a.x,a.y,map.getHeight(a.x,a.y)+0.05)
+				b=AGVector3.new(b.x,b.y,map.getHeight(b.x,b.y)+0.05)
+				wireframe.addLine(a,b)
+			}
+			scene.addNode(wireframe)
+			width+=2
+		}
+	end
+
+private
+	# get path-finding mode for the given +entity+
+	def getMode(entity)
+		if entity.resource.get("boat")>0
+			# if entity has boat then is can cross water - FIXME: put this into an entity-based function
+			:overWater
+		else
+			:normal
+		end
+	end
+
+	def getCacheFilename(map)
+		levelHash=map.hash # build a hash out of the height-map
+		cacheFilename=levelHash+".cache"
+	end
+
+	def loadFromFile(filename)
+		content=loadFile(filename)
+		stream=BinaryStringIn.new(content)
+		MODES.each{|mode|
+			@graph[mode]=SimpleGraph.new(stream)
+			@heuristic[mode]=StoredHeuristicFunction.new(stream)
+		}
+	end
+
+	def saveToFile(filename)
+		# save everything to the cachefile
+		stream=BinaryStringOut.new
+		MODES.each{|mode|
+			@graph[mode].printTo(stream)
+			@heuristic[mode].printTo(stream)
+		}
+	
+		saveFile(filename,stream.getString)
+	end
+
+	def computeEverything(map)
+		MODES.each{|mode|computeMode(map,mode)}
+	end
+
+	def computeMode(map,mode)
+		# build a map-height/distance weighter
+		weighter=getPathWeighter(map,mode)
+
+		# set initial distance of waypoints	
+		minDist=2
+
+		begin
+			# make a path-finding graph
+			sgraph=makeGraph(map,weighter,minDist)
+			minDist*=2
+		end while(sgraph.size>2000) # use a smaller resolution, if there are too many nodes in graph
+
+		# copy to a decimating graph
+		graph=DecimatedGraph.new(sgraph)
+
+		# compute a decimation-factor
+		factor=1.0-800.0/graph.size
+
+		# debugging settings
+		#factor=0.4
+		#factor=1.0-220.0/@dgraph.size
+
+		graph.decimate(factor,weighter)
+
+		# compute a distance-field and use this as a pre-computed heuristic
+		@heuristic[mode]=computeHeuristic(graph)
+		@graph[mode]=graph
+	end
+
+	def getPathWeighter(map,mode)
+		case mode
+			when :normal
+				return MapPathWeighter.new(map,false)
+			when :overWater
+				return MapPathWeighter.new(map,true)
+		end
+	end
+end
\ No newline at end of file

Modified: antargis/branches/rant/ruby/map.rb
===================================================================
--- antargis/branches/rant/ruby/map.rb	2007-08-22 17:49:56 UTC (rev 1161)
+++ antargis/branches/rant/ruby/map.rb	2007-08-25 19:26:25 UTC (rev 1162)
@@ -23,6 +23,7 @@
 require 'ant_level.rb'
 
 require 'ant_ai.rb'
+require 'ant_path.rb'
 
 # This class prodives support for defining target-positions in a level-file.
 # These positions can be used for scripting. This way code and level-data is
@@ -480,9 +481,13 @@
 	end
 
 
-
 	def createPathfinder
+		@path=CombinedPathFinder.new(self)
+		@path.displayPathfindingGraph(self,getScene)
+	end
 
+	def createPathfinderOLD
+
 		levelHash=self.hash # build a hash out of the height-map
 		cacheFilename=levelHash+".cache"
 
@@ -532,18 +537,6 @@
 		
 		#displayPathfindingGraph
 	end
-	def displayPathfindingGraph
-		wireframe=Boa3dWireframe.new(getScene,AGVector4.new(1,0,0,1))
-		(0..(@dgraph.edges-1)).each{|i|
-			edge=@dgraph.getEdgePosition(i)
-			a=edge[0]
-			b=edge[1]
-			a=AGVector3.new(a.x,a.y,getHeight(a.x,a.y)+0.05)
-			b=AGVector3.new(b.x,b.y,getHeight(b.x,b.y)+0.05)
-			wireframe.addLine(a,b)
-		}
-		getScene.addNode(wireframe)
-	end
 end
 
 



From davidkamphausen at mail.berlios.de  Mon Aug 27 20:34:05 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Mon, 27 Aug 2007 20:34:05 +0200
Subject: [Antargis-svn] r1163 - in antargis/branches/rant: . ext/external
	ext/game ext/gui ruby ruby/entities
Message-ID: <200708271834.l7RIY5XA020646@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-08-27 20:34:04 +0200 (Mon, 27 Aug 2007)
New Revision: 1163

Added:
   antargis/branches/rant/ext/game/README
   antargis/branches/rant/ext/gui/README
   antargis/branches/rant/ruby/entities/README
Modified:
   antargis/branches/rant/INSTALL
   antargis/branches/rant/README
   antargis/branches/rant/Rantfile
   antargis/branches/rant/ext/external/README
   antargis/branches/rant/ruby/README
Log:
* documentation...


Modified: antargis/branches/rant/INSTALL
===================================================================
--- antargis/branches/rant/INSTALL	2007-08-25 19:26:25 UTC (rev 1162)
+++ antargis/branches/rant/INSTALL	2007-08-27 18:34:04 UTC (rev 1163)
@@ -1,13 +1,14 @@
-INSTALLATION of Battles of Antargis
-==========================================
+== INSTALLATION of Battles of Antargis
 Quick Start:
-1) Install ruby, libsdl, libsdl-image, libsdl-ttf, libsdl-mixer, opengl.
-	You need the developer-packages of all these libraries/programs!
-  If you want to do serious developing you should install rant, too!
+
+1) Install ruby, libsdl, libsdl-image, libsdl-ttf, libsdl-mixer, opengl. You need the developer-packages of all these libraries/programs! If you want to do serious developing you should install rant, too!
+
 2) Don't forget to install ruby1.8-dev (or ruby1.9-dev if you use ruby 1.9)
+
 3) After this step no root-privileges are needed.
-4) If you have installed rant in step 1: Run "rant" in this directory
-   Otherwise: Run "ruby build.rb" in the current directory
+
+4) If you have installed rant in step 1: Run "rant" in this directory. Otherwise: Run "ruby build.rb" in the current directory
+
 5) Run "./antargis" in this directory
 
 Essentials: Ruby, (Rant)
@@ -15,10 +16,15 @@
 
 Libraries: libSDL,libSDL_mixer libSDL_ttf, libSDL_image, opengl
 
-Links:
+== Links
 Ruby          http://www.ruby-lang.org
+
 Rant          http://rant.rubyforge.org/
+
 libSDL        http://www.libsdl.org
+
 libSDL-image  http://www.libsdl.org/projects/SDL_image
+
 libSDL-ttf    http://www.libsdl.org/projects/SDL_ttf
+
 libSDL-mixer  http://www.libsdl.org/projects/SDL_mixer

Modified: antargis/branches/rant/README
===================================================================
--- antargis/branches/rant/README	2007-08-25 19:26:25 UTC (rev 1162)
+++ antargis/branches/rant/README	2007-08-27 18:34:04 UTC (rev 1163)
@@ -18,20 +18,32 @@
 == Overview
 
 The game is devided into several parts, which have each a specified purpose.
-These parts are:
-* a graphical-user-interface (GUI) library, which is called AntargisGUI
-* a 3d-engine
-* a c++-game-engine
-* the actual game-logic in ruby
+The main difference between parts is the language, in that they're written, C++ or Ruby.
+
+The main language of BoA is Ruby. But because most low-level-libraries cannot directly be used by Ruby and
+for some things Ruby is just too slow, there are some parts of the Engine, that are written in C++.
+
+The game is parted into several layers, that shouldn't be mixed too much. These layers are:
+* external libraries (Ruby,SDL,libstdc++,...)
+* basic-lib, which includes basic functions like filesystem-access, basic geometry-processing, event-handling and so forth
+* math-lib - holding extended math-functions
+* video-lib - providing a (nearly) seamless usage of either OpenGL or plain (2D-) SDL-Mode for video-access
+* sound-lib - providing some simplified access to SDL_Mixer
+* gui-lib - a small gui-lib, that's pretty easy to use and designed for usage in games
+* 3dengine - a pretty small 3d-engine, that can be used for RTS-games (it's not designed to work for FPS or the like)
+* game-lib - basic functionality for RTS games. It includes those functions that are called frequently and thus must be pretty fast.
+
+The layers above are all done in C++. What now follows are the Ruby-parts:
 * much glue-code in ruby for menus, dialogs and the like 
+* game-logic
 
-1. On information about Antargis GUI-lib go to link:files/gui/README.html
-2. Information about Antargis game-engine can be found at link:files/src/README.html
-3. Game logic, esp. Multiplayer, AI- and level-scripting: files/ruby/README.html
+1. On information about Antargis GUI-lib go to link:files/ext/gui/README.html
+2. Information about Antargis game-engine can be found at link:files/ext/game/README.html
+3. Game logic, esp. Multiplayer, AI- and level-scripting: link:files/ruby/README.html
 
 == Installation
 
-For installation and building have a look at the INSTALL file.
+For installation and building have a look at the link:files/INSTALL.html file.
 
 Run the game by simply starting antargis:
 > ./antargis

Modified: antargis/branches/rant/Rantfile
===================================================================
--- antargis/branches/rant/Rantfile	2007-08-25 19:26:25 UTC (rev 1162)
+++ antargis/branches/rant/Rantfile	2007-08-27 18:34:04 UTC (rev 1163)
@@ -342,7 +342,8 @@
  end
 desc "Generate html documentation."
 	gen RubyDoc do |t|
-			a=sys["**/README"]+sys["ruby/**/*.rb"]
+			a=sys["**/README"]+sys["ruby/**/*.rb"]+sys["INSTALL"]
+			a=a.select{|f|not f=~/_test/}
 			t.opts = %w(--title Battles\ of\ Antargis --main README )+a
 			t.dir = "docs/ruby"
 	end

Modified: antargis/branches/rant/ext/external/README
===================================================================
--- antargis/branches/rant/ext/external/README	2007-08-25 19:26:25 UTC (rev 1162)
+++ antargis/branches/rant/ext/external/README	2007-08-27 18:34:04 UTC (rev 1163)
@@ -1,3 +1,4 @@
+== Mersenne Twister 
 This is an implementation of the Mersenne Twist pseudorandom number
 generator, including both C and C++ interfaces and a set of functions
 for generating random variates from common distributions.

Added: antargis/branches/rant/ext/game/README
===================================================================
--- antargis/branches/rant/ext/game/README	2007-08-25 19:26:25 UTC (rev 1162)
+++ antargis/branches/rant/ext/game/README	2007-08-27 18:34:04 UTC (rev 1163)
@@ -0,0 +1 @@
+== Information about the Antargis-Game-Engine 
\ No newline at end of file

Added: antargis/branches/rant/ext/gui/README
===================================================================
--- antargis/branches/rant/ext/gui/README	2007-08-25 19:26:25 UTC (rev 1162)
+++ antargis/branches/rant/ext/gui/README	2007-08-27 18:34:04 UTC (rev 1163)
@@ -0,0 +1,39 @@
+== Overview
+AntargisGUI is a C++ GUI-library, that's aimed at usage in either C++ and Ruby.
+It's based upon libSDL and OpenGL and can be run in OpenGL-mode and plain SDL-mode, too.
+However within the Antargis-game only OpenGL-mode is used.
+
+Though being quiet small(TM) AntargisGUI provides a whole bunch of features, like:
+* widgets, windows, buttons, list-boxes, combo-boxes, dialogs, checkboxes, edits (single and multiline), tooltips
+* simple event-handling
+* file-system abstraction
+* UTF-8 and localization support
+* XML-based layouts
+* extendable through either C++ and Ruby
+* basic geometry-classes (2d and 3d)
+* encryption with AES
+* themeable
+
+Because the important parts are written in C++, the main documentation in done with doxygen.
+So for more detailed information and a complete API-documentation go to link:../api/html/index.html 
+
+== Dependencies (deprecated)
+
+This library is aimed at being used by a script language like ruby or python, but it should be still
+usable in plain c++.
+
+needed libraries:
+ruby(-dev)
+swig(-dev)
+libSDL
+libSDL_image
+libSDL_ttf
+libSDL_mixer
+libphysfs
+
+you have 2 possibilities to compile it
+1) use autotools:
+  ./configure && make && make install
+2) using extconf.rb /mkmf:
+  cd src && ruby extconf.rb && make && make install
+

Modified: antargis/branches/rant/ruby/README
===================================================================
--- antargis/branches/rant/ruby/README	2007-08-25 19:26:25 UTC (rev 1162)
+++ antargis/branches/rant/ruby/README	2007-08-27 18:34:04 UTC (rev 1163)
@@ -5,4 +5,19 @@
 * basic game logic like maps, entities and jobs
 * level-scripting
 * AI-scripting
-* multi-player support
\ No newline at end of file
+* multi-player support
+
+== Entities
+The basic objects of the game, like trees, people, buildings and so forth are called entities.
+To read more about entities go here: link:files/ruby/entities/README.html
+
+== Map
+A map represents the complete world of BoA. It consists of:
+* a height-map
+* entities on the map
+* some game-logic, that holds everything in place
+
+To make things a little easier, it's implemented in several layers:
+* C++-HeightMap
+* C++-AntargisMap
+

Added: antargis/branches/rant/ruby/entities/README
===================================================================
--- antargis/branches/rant/ruby/entities/README	2007-08-25 19:26:25 UTC (rev 1162)
+++ antargis/branches/rant/ruby/entities/README	2007-08-27 18:34:04 UTC (rev 1163)
@@ -0,0 +1,18 @@
+== Entities 
+
+=== Introduction
+
+Entities are objects. There are many classes of entities, that have an entirely different behaviour.
+But they have some simple things in common:
+* each entity has an inventory (like in RP-games)
+* each entity has properties like energy or experience - no matter how reasonable this may seem ATM.
+* a low-level-job
+* it can have one (or more) mesh(es)
+* it has many different events, that are called, when certain things happen.
+
+Because events and movements for every entity are computed in each frame of the game (should be at least 25 times a second), that's pretty much to do. Because Ruby isn't that fast, these things are done in C++.
+
+So there is a basic entity-class in C++-code that's called AntEntity
+
+Above this c++-class there is a Ruby-Class named AntRubyEntity, that contains some more basic stuff, that's implemented in Ruby more easily.
+



From davidkamphausen at mail.berlios.de  Wed Aug 29 20:00:38 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Wed, 29 Aug 2007 20:00:38 +0200
Subject: [Antargis-svn] r1164 - in antargis/branches/rant: . build ruby
	ruby/entities ruby/gui
Message-ID: <200708291800.l7TI0cvk006010@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-08-29 20:00:36 +0200 (Wed, 29 Aug 2007)
New Revision: 1164

Modified:
   antargis/branches/rant/README
   antargis/branches/rant/Rantfile
   antargis/branches/rant/build/configure.rb
   antargis/branches/rant/configure
   antargis/branches/rant/ruby/README
   antargis/branches/rant/ruby/entities/entities.rb
   antargis/branches/rant/ruby/gui/ag_tools.rb
   antargis/branches/rant/ruby/intro.rb
   antargis/branches/rant/ruby/mainmenu.rb
Log:
* much more documentation


Modified: antargis/branches/rant/README
===================================================================
--- antargis/branches/rant/README	2007-08-27 18:34:04 UTC (rev 1163)
+++ antargis/branches/rant/README	2007-08-29 18:00:36 UTC (rev 1164)
@@ -37,9 +37,9 @@
 * much glue-code in ruby for menus, dialogs and the like 
 * game-logic
 
-1. On information about Antargis GUI-lib go to link:files/ext/gui/README.html
-2. Information about Antargis game-engine can be found at link:files/ext/game/README.html
-3. Game logic, esp. Multiplayer, AI- and level-scripting: link:files/ruby/README.html
+1. link:files/ext/gui/README.html - information about Antargis GUI-lib
+2. link:files/ext/game/README.html - Information about Antargis game-engine
+3. link:files/ruby/README.html - Game logic, esp. Multiplayer, AI- and level-scripting, dialogs, menus...
 
 == Installation
 
@@ -47,3 +47,7 @@
 
 Run the game by simply starting antargis:
 > ./antargis
+
+== Building
+
+For more information on how to build Antargis and how the build-process work, please refer to link:files/build/README.html

Modified: antargis/branches/rant/Rantfile
===================================================================
--- antargis/branches/rant/Rantfile	2007-08-27 18:34:04 UTC (rev 1163)
+++ antargis/branches/rant/Rantfile	2007-08-29 18:00:36 UTC (rev 1164)
@@ -342,9 +342,9 @@
  end
 desc "Generate html documentation."
 	gen RubyDoc do |t|
-			a=sys["**/README"]+sys["ruby/**/*.rb"]+sys["INSTALL"]
+			a=sys["**/README"]+sys["ruby/**/*.rb"]+sys["INSTALL"]+sys["build/*.rb"]+sys["configure"]+sys["Rantfile"]
 			a=a.select{|f|not f=~/_test/}
-			t.opts = %w(--title Battles\ of\ Antargis --main README )+a
+			t.opts = %w(--title Battles\ of\ Antargis --main README --diagram)+a
 			t.dir = "docs/ruby"
 	end
 

Modified: antargis/branches/rant/build/configure.rb
===================================================================
--- antargis/branches/rant/build/configure.rb	2007-08-27 18:34:04 UTC (rev 1163)
+++ antargis/branches/rant/build/configure.rb	2007-08-29 18:00:36 UTC (rev 1164)
@@ -1,31 +1,49 @@
 #
 # This is a library for simple build-configuration management.
-# For a brief example have a look at BoA's configure-script.
+# For a brief example have a look at BoA's configure-script (link:files/configure.html)
+# This file may contain some examples how to use this.
 # 
 # The configuration-process goes like this
-# 1) include this file
-# 2) define cmd-line-options with CFG.addOption
-# 3) add checks for programs, files, libraries (checkProgram, checkFile, checkLibrary)
-# 4) add custom-checks with addCheck(...)
-# 5) include basic-configuration functionality with CFG.includeConfig - have a look at build/configs/unix.rb for more information on this
-# 6) run the configuration with CFG.run - a config.rb file will be written 
-##
+#  1) include this file
+#  2) define cmd-line-options with CFG.addOption
+#  3) add checks for programs, files, libraries (checkProgram, checkFile, checkLibrary)
+#  4) add custom-checks with addCheck(...)
+#  5) include basic-configuration functionality with CFG.includeConfig - have a look at build/configs/unix.rb for more information on this
+#  6) run the configuration with CFG.run - a config.rb file will be written 
+#
 
 require 'build/platform.rb'
 require 'build/config_tools.rb'
 
+# the CFG-module serves with many functions that may be used in a configure script
 module CFG
 	@@options=[]
 	@@config={}
 	@@checks=[]
 
+	# add a cli-option with name *name* and short-cut *short*
+	# Example:
+	#  CFG.addOption("enable-debug","d",
+	#  	"enable debugging") do  ||
+	#  	  	CFG.set("debug",true)
+	#   end
+	# will result in an output like this:
+	#   -Battle of Antargis - Configuration
+  #   -------------------------------------------------------------------------------
+  #   --help, -h                              display help text
+	#   --enable-debug, -d                      enable debugging
+	# the given block *proc* will do whatever you define for instance setting debug to true in set configuration hash
 	def CFG.addOption(name,short,help,param=nil,default=nil,&proc)
 		@@options.push({:name=>name,:short=>short,:help=>help,:proc=>proc,:param=>param,:default=>default})
 	end
 
+	# return an array containing a hash, that describes, how the possible options will be checked
+	# have a loog at CFG.addOption
 	def CFG.options
 		@@options
 	end
+
+	# add check identified by *name*
 	def CFG.addCheck(name,needed=true,&proc)
 		@@checks << {:name=>name,:proc=>proc,:needed=>needed}
 	end
@@ -37,44 +55,8 @@
 			end
 		}
 	end
-	def CFG.parseArgs
-		ARGV.each{|arg|
-			found=false
-			# parse single arguments like "-d" or "-dgh" (like tar -xfz)
-			if arg=~/^-[a-z]+$/
-				found=true
-				# check if all characters represent a correct option
-				arg[1..-1].scan(/./){|byte|
-					found=false if @@options.select{|op|op[:short]==byte}.length==0
-				}
-				if found
-					# all were ok, so call each these options
-					arg[1..-1].scan(/./){|byte|
-						@@options.each{|op|op[:proc].call if op[:short]==byte}
-					}
-				end
-			end
-			if not found
-				# option could not yet be processed, so do a second try
-				@@options.each{|op|
-					name=op[:name]
-					ename=name.gsub("+","\\\\+")
-					#puts "ENAME:#{ename}"
-					# parse "simple" options without parameters
-					if arg=~/^--#{ename}$/ or arg=~/^-#{op[:short]}$/
-						found=true
-						op[:proc].call
-					# parse options with parameter, given like this : "-d=<somedir>" or "--dir=bladir"
-					elsif arg=~/^--#{ename}=.+/ or arg=~/^-#{op[:short]}=.+$/
-						found=true
-						op[:proc].call(arg.gsub(/^[^=]+=/,""))
-					end
-				}
-			end
-			puts "ERROR: argument '#{arg}' could not be processed!" if not found
-		}
-	end
 
+
 	def CFG.checkDefaults
 		@@options.each{|op|
 			if get(op[:name]).nil? and op[:default]
@@ -86,6 +68,7 @@
 	def CFG.run
 		parseArgs
 		checkDefaults
+		checkCompile
 		ok=runChecks
 		saveConfig if ok
 	end
@@ -125,15 +108,6 @@
 	
 	end
 
-	def CFG.toS(v)
-		case v
-			when String
-				"'"+v.to_s+"'"
-			else
-				v.to_s
-		end
-	end
-
 	def CFG.set(n,v)
 		@@config[n]=v
 	end
@@ -156,18 +130,18 @@
 		end
 	end
 
-    def CFG.getPath
-        p=ENV['PATH']
-        psep={"/"=>":","\\"=>";"}[Dir.separator]
-        #puts p,p.class,psep
-        ps=p.split(psep)
-        #puts get("prefix")
-        ps << get("prefix")+Dir.separator+"bin" if get("prefix")
-        if Dir.separator=="\\"
-            ps << (Dir.pwd+"/build/win32/usr/bin").gsub("/",Dir.separator)
-        end
-        ps
-    end
+	def CFG.getPath
+			p=ENV['PATH']
+			psep={"/"=>":","\\"=>";"}[Dir.separator]
+			#puts p,p.class,psep
+			ps=p.split(psep)
+			#puts get("prefix")
+			ps << get("prefix")+Dir.separator+"bin" if get("prefix")
+			if Dir.separator=="\\"
+					ps << (Dir.pwd+"/build/win32/usr/bin").gsub("/",Dir.separator)
+			end
+			ps
+	end
 
 	def CFG.findProgram(program)
         #program+=".exe" if Dir.separator=="\\" and not program=~/\.\{exe|com|bat\}$/
@@ -185,6 +159,7 @@
 		#`whereis #{program}`.gsub(/[^:]*: */,"").split(" ")[0]
 	end
 
+	# check if +path+ exists. Maybe we should check, if +path+ is executable
 	def CFG.testProgram(path)
 		#puts path,File.exists?(path),"--"
 			File.exists?(path)
@@ -206,6 +181,8 @@
 		end
 	end
 
+	# *FIXME: implement this*
+	# This function will test if the compiler is able to compile.
 	def CFG.checkCompile
 		
 	end
@@ -219,6 +196,59 @@
 	end
 
 
+	private
+
+	# this function parses the cli-inputs
+	#
+	# *FIXME: replace this with the standard ruby-cli-input-parser
+	def CFG.parseArgs
+		ARGV.each{|arg|
+			found=false
+			# parse single arguments like "-d" or "-dgh" (like tar -xfz)
+			if arg=~/^-[a-z]+$/
+				found=true
+				# check if all characters represent a correct option
+				arg[1..-1].scan(/./){|byte|
+					found=false if @@options.select{|op|op[:short]==byte}.length==0
+				}
+				if found
+					# all were ok, so call each these options
+					arg[1..-1].scan(/./){|byte|
+						@@options.each{|op|op[:proc].call if op[:short]==byte}
+					}
+				end
+			end
+			if not found
+				# option could not yet be processed, so do a second try
+				@@options.each{|op|
+					name=op[:name]
+					ename=name.gsub("+","\\\\+")
+					#puts "ENAME:#{ename}"
+					# parse "simple" options without parameters
+					if arg=~/^--#{ename}$/ or arg=~/^-#{op[:short]}$/
+						found=true
+						op[:proc].call
+					# parse options with parameter, given like this : "-d=<somedir>" or "--dir=bladir"
+					elsif arg=~/^--#{ename}=.+/ or arg=~/^-#{op[:short]}=.+$/
+						found=true
+						op[:proc].call(arg.gsub(/^[^=]+=/,""))
+					end
+				}
+			end
+			puts "ERROR: argument '#{arg}' could not be processed!" if not found
+		}
+	end
+
+	# convert *v* into a string. used by CFG.saveConfig to write the config.rb
+	def CFG.toS(v)
+		case v
+			when String
+				"'"+v.to_s+"'"
+			else
+				v.to_s
+		end
+	end
+
 	addOption("help","h",
 		"display help text") do
 			CFG.options.each{|op|

Modified: antargis/branches/rant/configure
===================================================================
--- antargis/branches/rant/configure	2007-08-27 18:34:04 UTC (rev 1163)
+++ antargis/branches/rant/configure	2007-08-29 18:00:36 UTC (rev 1164)
@@ -95,10 +95,8 @@
 		CFG.gatherMkmfInfo
 	end
 
-
 CFG.includeConfig
 
-
 CFG.run
 
 puts

Modified: antargis/branches/rant/ruby/README
===================================================================
--- antargis/branches/rant/ruby/README	2007-08-27 18:34:04 UTC (rev 1163)
+++ antargis/branches/rant/ruby/README	2007-08-29 18:00:36 UTC (rev 1164)
@@ -7,11 +7,22 @@
 * AI-scripting
 * multi-player support
 
-== Entities
+== Global structure
+There are several different "applications" used when playing around with BoA.
+* you begin with an intro, that's run by IntroApp
+* after that you enter the menus, which are handled by AntMenuApp. There you can:: a) start a campaign, b) a single-map or c) load a game
+
+=== Campaigns
+* For more information about campaigns go ahead to Campaign.
+* For single-maps *FIXME*
+
+== BoA's world
+
+=== Entities
 The basic objects of the game, like trees, people, buildings and so forth are called entities.
 To read more about entities go here: link:files/ruby/entities/README.html
 
-== Map
+=== Map
 A map represents the complete world of BoA. It consists of:
 * a height-map
 * entities on the map

Modified: antargis/branches/rant/ruby/entities/entities.rb
===================================================================
--- antargis/branches/rant/ruby/entities/entities.rb	2007-08-27 18:34:04 UTC (rev 1163)
+++ antargis/branches/rant/ruby/entities/entities.rb	2007-08-29 18:00:36 UTC (rev 1164)
@@ -53,6 +53,25 @@
 
 		setHunger(0) # general entities have no hunger
 	end
+
+
+	# play a sound identified by +name+. Sounds of this type shouldn't called when they were only called
+	# +minDiff+ (or less) seconds before. Note that the sound is played at the place where this entity is placed.
+	# So it's not hearable far away from it.
+	def playSound(name,minDiff=0.5)
+		scene=getMap.getScene
+		d=((scene.getCamera.dim2-getPos2D).length-INNER_VOL_SIZE)
+		vol=1
+		if d>0
+			vol=[(OUTER_VOL_SIZE-d)/OUTER_VOL_SIZE,0].max
+		end
+		AntSound.playSoundGlobal(name,vol,minDiff)
+	end
+
+	
+	# :section: Editing
+
+	# Within the editor you can change additional properties, e.g. count of men for a hero. This functions are used for this.
 	def setXMLProp(n,v)
 		@xmlProps[n]=v
 	end
@@ -63,11 +82,9 @@
 			return @xmlProps[n]
 		end
 	end
-	def experienceFull
-		super
-		self.experience=1
-	end
 
+	# :section: XML loading/saving
+
 	def preloadXML(node)
 		if node.get("birthday")!=""
 			@birthday=node.get("birthday").to_f
@@ -102,6 +119,7 @@
 	def <=>(e)
 		to_s<=>e.to_s
 	end
+
 	def menCount
 		0
 	end
@@ -140,6 +158,8 @@
 	def getMen
 		[]
 	end
+
+	
 	def setMode(mode)
 		@mode=mode
 	end
@@ -147,15 +167,6 @@
 		@mode
 	end
 
-	def playSound(name,minDiff=0.5)
-		scene=getMap.getScene
-		d=((scene.getCamera.dim2-getPos2D).length-INNER_VOL_SIZE)
-		vol=1
-		if d>0
-			vol=[(OUTER_VOL_SIZE-d)/OUTER_VOL_SIZE,0].max
-		end
-		AntSound.playSoundGlobal(name,vol,minDiff)
-	end
 
 
 	def isOnOpenWater(p=nil)
@@ -167,6 +178,10 @@
 	def isOnWater
 		getMap.getPos(getPos2D).z<0
 	end
+
+	# give name under which this entity is stored in xml. It's generated from the classname. The first character is downcased.
+	# The rest is camel-case as usual.
+	# For instace: AntShop => antShop
 	def xmlName
 		xml=self.class.to_s
 		xml=xml[0..0].downcase+xml[1..1000]
@@ -186,6 +201,14 @@
 		end
 	end
 
+	# :section: job-handling
+	# These functions add support for event-Handling within Entities' jobs. This is (will be) used for
+	# scripting and AI.
+	#	
+	# FIXME: THis should be moved somewhere else (?)
+	#
+	# For more information on scripting link:files/ruby/scripting/README.html
+
 	def newFightJob(p,target,distance)
 		@fightTarget=target
 		super
@@ -195,6 +218,8 @@
 		super
 		doEvent(:eventNewRestJob)
 	end
+
+	# :section eventHandling
 	def eventNoJob
 		super
 		doEvent(:eventNoJob)
@@ -204,23 +229,27 @@
 		doEvent(:eventJobFinished)
 	end
 
+	def experienceFull
+		super
+		self.experience=1
+	end
+
+
+	# :section: status-information
+
+	# an event-handler for resources being changed. In this case a possible view on the inventory is updated
 	def resourceChanged	
 		super
 		AntInventory.update(self)
 	end
 
+	# is this entity under attack - here this is always false, because it doesn't make sense for all entities
 	def underAttack
 		false
 	end
 
-# 	def _dump(depth)
-# 		[@uid].pack("n")
-# 	end
-# 	def _load(s)
-# 		getMap.getByUID(s.unpack("n"))
-# 	end
+	# :section: state-changes
 
-
 	def setMesh(subtype="",sym=nil)
 		if subtype.is_a?(SceneNode)
 			puts  "THIS SHOULD NOT BE USED ANY LONGER: setMesh(realMesh) !!!!!!!!!!!!"
@@ -240,6 +269,11 @@
 	end
 
 
+
+
+	# :section: deprecated
+
+
 	# FIXME: remove this - this is a backward-compability function 
 	def get
 		self

Modified: antargis/branches/rant/ruby/gui/ag_tools.rb
===================================================================
--- antargis/branches/rant/ruby/gui/ag_tools.rb	2007-08-27 18:34:04 UTC (rev 1163)
+++ antargis/branches/rant/ruby/gui/ag_tools.rb	2007-08-29 18:00:36 UTC (rev 1164)
@@ -107,6 +107,7 @@
 		return super(e)
 	end
 
+	private
 	def makeHandlerName(object,event)
 		if object.respond_to?(:getName)
 			return object.getName+":"+event.to_s

Modified: antargis/branches/rant/ruby/intro.rb
===================================================================
--- antargis/branches/rant/ruby/intro.rb	2007-08-27 18:34:04 UTC (rev 1163)
+++ antargis/branches/rant/ruby/intro.rb	2007-08-29 18:00:36 UTC (rev 1164)
@@ -3,22 +3,34 @@
 require 'ruby/antargislib.rb'
 require 'ant_local.rb'
 
-class Black<AGWidget
+# *BlackFade* fades the screen to black. This Widget is laid over other widgets and
+# draws a black rectangle with varying alpha-channel. This way you
+# can fade in and out pictures and text-displays.
+class BlackFade<AGWidget
+	# alpha-value is set to 0 by default
 	def initialize(p,r)
 		super(p,r)
 		@r=r
 		@alpha=0.0
 	end
+	# set the alpha-value *a* in range from 0.0 to 1.0
+	# the default-value is 0
 	def setAlpha(a)
 		@alpha=a
 		queryRedraw
 	end
+
+	# draws the black rectangle with set pre-set alpha-value
 	def draw(painter)
 		#painter.fillRect(@r,AGColor.new(0,0,0,0x1F))
 		painter.fillRect(@r,AGColor.new(0,0,0,(0xFF*@alpha).to_i))
 	end
 end
 
+
+# This application-class handles the display and event-handling of BoA's intro
+# It's able to display images and text-elements (that are drawn using the intro.font-Font from the theme)
+# Each image/text-element is faded-in and faded-out. While the intro runs some music-track is played
 class IntroApp<AntApplication
 	include AGHandler
 	def initialize
@@ -40,7 +52,7 @@
 		}
 		@s=0
 		@img=AGImage.new(nil,AGRect.new(0,0,getScreen.getWidth,getScreen.getHeight), at surfaces[0],false)
-		@black=Black.new(@img,AGRect.new(0,0,getScreen.getWidth,getScreen.getHeight))
+		@black=BlackFade.new(@img,AGRect.new(0,0,getScreen.getWidth,getScreen.getHeight))
 		@img.addChild(@black)
 		setMainWidget(@img)
 		@time=0
@@ -56,19 +68,29 @@
 		addHandler(getSoundManager,:sigMp3Finished,:musicEnd)
 	end
 	
+
+	# if a key was pressed, we cancel the intro playing
 	def eventKeyDown(e)
 		cancel
 		return super
 	end
 	
+	# cancel the intro
+	# resets the *@phases*
 	def cancel
 		@canceled=true
 		@phases=[0.2,0.2,2,10]
 	end	
+
+	# if the music has finished, we cancel the intro
 	def musicEnd
 		cancel
 	end
 	
+
+	# this function is called, when you press F10 to quit the application
+	# the first call cancels the intro (thus it will still fade out)
+	# the second call will quit the intro directly
 	def tryQuit
 		if @canceled
 			#getSoundManager.stopMp3
@@ -78,7 +100,11 @@
 			cancel
 		end
 	end
-	
+
+	# this function does:
+	# * increase the phase - set alpha for BlackFade-Widget
+	# * switch to newer textures/text-elements
+	# * quit the intro, when its finished
 	def checkPhase
 		#puts "#{@time}>#{@phases[@phase]}"
 		if @time>@phases[@phase]
@@ -112,6 +138,7 @@
 		@img.redraw
 	end
 	
+	# gets called in each frame (and sets a delay of 10ms between frames)
 	def eventFrame(t)
 		@time+=t
 		checkPhase
@@ -119,6 +146,7 @@
 		return true
 	end
 
+	# when a mouse-button is clicked the intro is canceled
 	def eventMouseButtonDown(e)
 		tryQuit
 		return super(e)

Modified: antargis/branches/rant/ruby/mainmenu.rb
===================================================================
--- antargis/branches/rant/ruby/mainmenu.rb	2007-08-27 18:34:04 UTC (rev 1163)
+++ antargis/branches/rant/ruby/mainmenu.rb	2007-08-29 18:00:36 UTC (rev 1164)
@@ -26,9 +26,22 @@
 require 'credits.rb'
 
 # AntMenuApp implements the whole menu-block of BoA
-# It uses the setMainWidget-function of AGApplication
-# This way the current menu can easily be exchanged.
-
+# It uses the setMainWidget-function of AGApplication to exchange
+# whole layouts of menus.
+#
+# These are the different layouts (description about each menu can be found in each of its setup-function)
+# * main - setupMain
+# * credits - setupCredits
+# * campaign - setupCampaign
+# * options - setupOptions
+# * load - setupLoadMenu
+# * single-game - setupSingle
+#
+# each layout has its own buttons and so forth. They are connected to event-handlers in the AntMenuApp-class.
+# These connections are done in the setup-functions. So any time each of the events can be handled. However
+# because at any time only one layout is displayed the other events won't be called. But you must be careful
+# not to name events the same!
+#
 class AntMenuApp <AntApplication
 	include AGHandler
 	def initialize
@@ -37,17 +50,11 @@
 		@menues=[]
 		
 		# setup all the 
-		puts "SETUPMAIN"
 		setupMain
-		puts "SETUPCREDITS"
 		setupCredits
-		puts "SETUPCAMPAIGN"
 		setupCampaign
-		puts "SETUPOPTIONS"
 		setupOptions
-		puts "SETUPLOADMENU"
 		setupLoadMenu
-		puts "SETUPSINGLE"
 		setupSingle
 		@sound=true
 
@@ -55,6 +62,10 @@
 		addHandler(getSoundManager,:sigMp3Finished,:eventMusicEnd)
 	end
 
+
+	# overrides AGWidget.setMainWidget, so that the given Widget *w* is
+	# embedded into an outer AGScreenWidget. The reason for this is
+	# redrawing AFAIK (?)
 	def setMainWidget(w)
 		if @myScreen.nil?
 			@myScreen||=AGScreenWidget.new
@@ -65,15 +76,14 @@
 		@curMainWidget=w
 	end
 	
-	def eventMusicEnd
-		if @sound
-			getSoundManager.playMp3("data/music/calm1.ogg")
-		end
-		return true
-	end
 
 
-	# MAIN MENU
+	# :section: set up the menus
+
+
+	# this function sets up the main-menu layout of out data/gui/layout/mainmenu.xml
+	# * event handlers are initialized
+	# * the MainWidget is set to this menu at startup
 	def setupMain()
 		@mainMenu=AGLayout.new(nil)
 		@mainMenu.loadXML(loadFile("data/gui/layout/mainmenu.xml"))
@@ -88,43 +98,8 @@
 		addHandler(@mainMenu.getChild("options"),:sigClick,:eventOptions)
 	end
 
-	def eventCredits(e)
-		setMainWidget(@creditsMenu)
-		return true
-	end
-	def eventSingle(e)
-		setMainWidget(@singleMenu)
-		return true
-	end
 
-	def eventTutorial(e)
-		tutCampaign=Campaign.new("data/campaigns/tutorial.xml")
-		soundOff
-		startCampaign(tutCampaign)
-		soundOn
-		return true
-	end
 
-	def eventCampaign(e)
-		setMainWidget(@campaignMenu)
-		return true
-	end
-	def eventLoadGame(e)
-		updateLoadMenu
-		setMainWidget(@loadMenu)
-		return true
-	end
-	def eventOptions(e)
-		setMainWidget(@optionsMenu)
-		return true
-	end
-	def eventQuit(e)
-		tryQuit
-		return true
-	end
-
-
-
 	# LOAD GAME MENU
 	def setupLoadMenu
 		@loadMenu=AGLayout.new(nil)
@@ -221,6 +196,48 @@
 		addHandler(@singleMenu.getChild("list"),:sigSelect,:eventLoadSelect)
 		updateSingleMenu
 	end
+
+	# OPTIONS MENU
+	def setupOptions
+		@optionsMenu=AGLayout.new(nil)
+		@optionSubMenus=["VideoOptionsMenu","AudioOptionsMenu","GameOptionsMenu"]
+		@optionsMenu.loadXML(loadFile("data/gui/layout/options.xml"))
+		@menues.push(@optionsMenu)
+		addHandler(@optionsMenu.getChild("exit"),:sigClick,:eventExit)
+		
+		addHandler(@optionsMenu.getChild("fullscreen"),:sigClick,:eventFullscreen)
+		["640","800","1024","1280","1400"].each{|n|
+			addHandler(@optionsMenu.getChild(n),:sigClick,:eventResChange)
+		}
+		#addHandler(@optionsMenu.getChild("1280"),:sigClick,:eventResChange)
+		addHandler(@optionsMenu.getChild("1400"),:sigClick,:eventResChange)
+
+		addHandler(@optionsMenu.getChild("gameOptions"),:sigClick,:eventGameOptions)
+		addHandler(@optionsMenu.getChild("videoOptions"),:sigClick,:eventVideoOptions)
+
+		addHandler(@optionsMenu.getChild("optionIntro"),:sigClick,:eventOptionsChanged)
+
+		@optionsMenu.getChild("optionIntro").setChecked(getConfig.get("intro")!="false")
+
+		# texture quality
+		texQ=@optionsMenu.getChild("textureQuality")
+		texQ.setSelected({"1"=>"high","2"=>"medium","3"=>"low",nil=>"high",""=>"high"}[getConfig.get("terrainDownScaleExp")])
+		addHandler(texQ,:sigSelect,:eventTextureQuality)
+
+		# FBO
+		@optionsMenu.getChild("UseFBO").setChecked(getConfig.get("useFBO")=="true")
+		addHandler(@optionsMenu.getChild("UseFBO"),:sigClick,:eventOptionsChanged)
+		
+		# Anim
+		@optionsMenu.getChild("UseAnim").setChecked(getConfig.get("animationType")=="true")
+		addHandler(@optionsMenu.getChild("UseAnim"),:sigClick,:eventOptionsChanged)
+
+		# particle
+		@optionsMenu.getChild("UseParticle").setChecked(getConfig.get("particleEffects")=="true")
+		addHandler(@optionsMenu.getChild("UseParticle"),:sigClick,:eventOptionsChanged)
+	end
+
+
 	
 	def eventSingleStart(e)
 
@@ -296,45 +313,6 @@
 	end
 	
 
-	# OPTIONS MENU
-	def setupOptions
-		@optionsMenu=AGLayout.new(nil)
-		@optionSubMenus=["VideoOptionsMenu","AudioOptionsMenu","GameOptionsMenu"]
-		@optionsMenu.loadXML(loadFile("data/gui/layout/options.xml"))
-		@menues.push(@optionsMenu)
-		addHandler(@optionsMenu.getChild("exit"),:sigClick,:eventExit)
-		
-		addHandler(@optionsMenu.getChild("fullscreen"),:sigClick,:eventFullscreen)
-		["640","800","1024","1280","1400"].each{|n|
-			addHandler(@optionsMenu.getChild(n),:sigClick,:eventResChange)
-		}
-		#addHandler(@optionsMenu.getChild("1280"),:sigClick,:eventResChange)
-		addHandler(@optionsMenu.getChild("1400"),:sigClick,:eventResChange)
-
-		addHandler(@optionsMenu.getChild("gameOptions"),:sigClick,:eventGameOptions)
-		addHandler(@optionsMenu.getChild("videoOptions"),:sigClick,:eventVideoOptions)
-
-		addHandler(@optionsMenu.getChild("optionIntro"),:sigClick,:eventOptionsChanged)
-
-		@optionsMenu.getChild("optionIntro").setChecked(getConfig.get("intro")!="false")
-
-		# texture quality
-		texQ=@optionsMenu.getChild("textureQuality")
-		texQ.setSelected({"1"=>"high","2"=>"medium","3"=>"low",nil=>"high",""=>"high"}[getConfig.get("terrainDownScaleExp")])
-		addHandler(texQ,:sigSelect,:eventTextureQuality)
-
-		# FBO
-		@optionsMenu.getChild("UseFBO").setChecked(getConfig.get("useFBO")=="true")
-		addHandler(@optionsMenu.getChild("UseFBO"),:sigClick,:eventOptionsChanged)
-		
-		# Anim
-		@optionsMenu.getChild("UseAnim").setChecked(getConfig.get("animationType")=="true")
-		addHandler(@optionsMenu.getChild("UseAnim"),:sigClick,:eventOptionsChanged)
-
-		# particle
-		@optionsMenu.getChild("UseParticle").setChecked(getConfig.get("particleEffects")=="true")
-		addHandler(@optionsMenu.getChild("UseParticle"),:sigClick,:eventOptionsChanged)
-	end
 	
 	def eventTextureQuality(e)
 		scale={"low"=>3,"medium"=>2,"high"=>1}[@optionsMenu.getChild("textureQuality").getSelected]
@@ -387,26 +365,14 @@
 		end
 		return true
 	end
-	def setRes(w,h)
-		getMain.initVideo(w,h,32,true,true,1024,768) #getMain.fullscreen,true)
-		getConfig.set("xRes",getMain.realWidth.to_s)
-		getConfig.set("yRes",getMain.realHeight.to_s)
-		puts getSurfaceManager.getUsedTexMem
-		#raise 1
-	end
 
 	
 
-	# all exits to mainmenu	
-	def eventExit(e)
-		setMainWidget(@mainMenu)
-		return true
-	end
-	def eventIdle
-		delay(20)
-		return true
-	end
 
+	# :section: Global Event Handlers
+
+	# simple frame-event-handler - only counts how much FPS we have
+	# and displays this on CLI
 	def eventFrame(t)
 		@frameTime||=0
 		@frames||=0
@@ -419,18 +385,105 @@
 		end
 		return true
 	end
+	# idle-event - sets a delay of 20ms
+	def eventIdle
+		delay(20)
+		return true
+	end
 
+	# quits the application (is called by the Quit-button in the main-menu
+	# current you won't be asked if this is ok.
+	def eventQuit(e)
+		tryQuit
+		return true
+	end
+
+
+	# event-handler for end of music-playing
+	# start another track (a different one)
+	def eventMusicEnd
+		if @sound
+			getSoundManager.playMp3("data/music/calm1.ogg")
+		end
+		return true
+	end
+
+	# -------------------------------
+	# :section: Menu Event Handlers
+	# -------------------------------
+
+	# called by exit-button in submenus and always exits to mainmenu	
+	def eventExit(e)
+		setMainWidget(@mainMenu)
+		return true
+	end
+
+	# -------------------------------
+	# :section: Main Menu Event Handlers
+	# -------------------------------
+	def eventCredits(e)
+		setMainWidget(@creditsMenu)
+		return true
+	end
+	def eventSingle(e)
+		setMainWidget(@singleMenu)
+		return true
+	end
+
+	# start the tutorial-campaign directly for new users, so
+	# they won't have to deal with "campaigning", where tutorial can be found, too
+	def eventTutorial(e)
+		tutCampaign=Campaign.new("data/campaigns/tutorial.xml")
+		soundOff
+		startCampaign(tutCampaign)
+		soundOn
+		return true
+	end
+
+	def eventCampaign(e)
+		setMainWidget(@campaignMenu)
+		return true
+	end
+	def eventLoadGame(e)
+		updateLoadMenu
+		setMainWidget(@loadMenu)
+		return true
+	end
+	def eventOptions(e)
+		setMainWidget(@optionsMenu)
+		return true
+	end
+
+
+	
+protected
+	# -------------------------------
+	# :section: changing settings
+	# -------------------------------
+
+	# fades the sound out
 	def soundOff
 		@sound=false
 		getSoundManager.fadeOutMusic(1000)
 	end
+
+	# if there is music running it gets stopped
+	# and eventMusicEnd is called, so that a new track is started
 	def soundOn
 		@sound=true
 		getSoundManager.stopMp3
 		eventMusicEnd
 	end	
 
-	# load menu
+	# switch to the video-resolution with pixel-width *w* and height *h*
+	def setRes(w,h)
+		getMain.initVideo(w,h,32,true,true,1024,768) #getMain.fullscreen,true)
+		getConfig.set("xRes",getMain.realWidth.to_s)
+		getConfig.set("yRes",getMain.realHeight.to_s)
+		puts getSurfaceManager.getUsedTexMem
+		#raise 1
+	end
+
 end
 
 app=AntMenuApp.new



From davidkamphausen at mail.berlios.de  Wed Aug 29 20:04:59 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Wed, 29 Aug 2007 20:04:59 +0200
Subject: [Antargis-svn] r1165 - in antargis/branches/rant: build ruby
	ruby/scripting
Message-ID: <200708291804.l7TI4xHP006240@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-08-29 20:04:59 +0200 (Wed, 29 Aug 2007)
New Revision: 1165

Added:
   antargis/branches/rant/build/README
   antargis/branches/rant/ruby/scripting/
   antargis/branches/rant/ruby/scripting/README
Log:
A    ruby/scripting
A    ruby/scripting/README
A    build/README


Added: antargis/branches/rant/build/README
===================================================================
--- antargis/branches/rant/build/README	2007-08-29 18:00:36 UTC (rev 1164)
+++ antargis/branches/rant/build/README	2007-08-29 18:04:59 UTC (rev 1165)
@@ -0,0 +1,19 @@
+== Antargis build-process
+
+BoA's building bases on http://rant.rubyforge.org
+
+It runs in two steps like most GPL-programs:
+ > ./configure
+ > rant
+
+In future releases we might include installing, too:
+ > rant install
+
+== Configure
+
+BoA's configure is totally independent of autotools - just in case in you might thought this.
+Instead it uses some proprietary functions, that you'll find in link:files/build/configure_rb.html
+
+The actual configure-script is thus written in Ruby, too.
+
+link:files/configure.html

Added: antargis/branches/rant/ruby/scripting/README
===================================================================
--- antargis/branches/rant/ruby/scripting/README	2007-08-29 18:00:36 UTC (rev 1164)
+++ antargis/branches/rant/ruby/scripting/README	2007-08-29 18:04:59 UTC (rev 1165)
@@ -0,0 +1 @@
+== Scripting documentation
\ No newline at end of file



From davidkamphausen at mail.berlios.de  Thu Aug 30 20:31:59 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Thu, 30 Aug 2007 20:31:59 +0200
Subject: [Antargis-svn] r1166 - in antargis/branches/rant: . ruby
Message-ID: <200708301831.l7UIVxls012821@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-08-30 20:31:59 +0200 (Thu, 30 Aug 2007)
New Revision: 1166

Added:
   antargis/branches/rant/ruby/debugging/
   antargis/branches/rant/ruby/multiplayer/
Modified:
   antargis/branches/rant/README
   antargis/branches/rant/ruby/README
   antargis/branches/rant/ruby/antargis.rb
   antargis/branches/rant/ruby/mainmenu.rb
   antargis/branches/rant/ruby/view.rb
Log:
* more documentation


Modified: antargis/branches/rant/README
===================================================================
--- antargis/branches/rant/README	2007-08-29 18:04:59 UTC (rev 1165)
+++ antargis/branches/rant/README	2007-08-30 18:31:59 UTC (rev 1166)
@@ -51,3 +51,7 @@
 == Building
 
 For more information on how to build Antargis and how the build-process work, please refer to link:files/build/README.html
+
+
+== Debugging
+Go to link:files/ruby/debugging/README.html
\ No newline at end of file

Modified: antargis/branches/rant/ruby/README
===================================================================
--- antargis/branches/rant/ruby/README	2007-08-29 18:04:59 UTC (rev 1165)
+++ antargis/branches/rant/ruby/README	2007-08-30 18:31:59 UTC (rev 1166)
@@ -9,8 +9,10 @@
 
 == Global structure
 There are several different "applications" used when playing around with BoA.
-* you begin with an intro, that's run by IntroApp
-* after that you enter the menus, which are handled by AntMenuApp. There you can:: a) start a campaign, b) a single-map or c) load a game
+* IntroApp - BoA always begins with an intro
+* AntMenuApp - after the intro menus are displayed. There you can:: a) start a campaign, b) a single-map or c) load a game
+* Campaign - in case you selected a campaign, this class manages the its flow
+* AntGameApp - This class handles the actual game application.
 
 === Campaigns
 * For more information about campaigns go ahead to Campaign.

Modified: antargis/branches/rant/ruby/antargis.rb
===================================================================
--- antargis/branches/rant/ruby/antargis.rb	2007-08-29 18:04:59 UTC (rev 1165)
+++ antargis/branches/rant/ruby/antargis.rb	2007-08-30 18:31:59 UTC (rev 1166)
@@ -1,5 +1,5 @@
 #!/usr/bin/env ruby
-#
+#--
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
 # game.rb
@@ -17,13 +17,10 @@
 #
 # You should have received a copy of the GNU General Public
 # License along with this program.
+#++
 #
-
-#!/usr/bin/ruby
-
-#
 # antargis.rb is the central file in antargis-level-playing.
-# it contains the main-application object for in-game looping, etc.
+# it contains the main-application class AntGameApp for in-game looping, etc.
 # most of the GUI-events are processed here.
 #
 
@@ -32,6 +29,7 @@
 $programDir=Dir.pwd+"/ruby"
 $:.push($programDir)
 $:.push($programDir+"/entities")
+$:.push($programDir+"/widgets")
 
 require 'antargislib.rb'
 require 'dialogs.rb'
@@ -42,13 +40,18 @@
 require 'storyflow.rb'
 require 'mpmap.rb'
 
+# get save path where savegames are stored
+# NOTE: this is combined with getWriteDir from ag_fs.h !
 def getSavePath
 	"savegames"
 end
 
 #
-# AntGameApp is the central class, that controls event handling of all the user interaction
-# in-game
+# AntGameApp is the central application-class in game. It controls:
+# * event handling of all the user interaction
+# * holds all the game-objects
+# * calls the advance-function in each frame
+# * it's derived from AntRubyView, which implements/manages the (3d-)displaying in-game
 #
 class AntGameApp <AntRubyView
 	attr_accessor :result
@@ -56,6 +59,23 @@
 
 	include AGHandler
 
+	# creating an AntGameApp-object needs the following parameters:
+	# * *savegameText* - this is the actual level serialized in a string (the xml-text you see when you open an .antlvl-file)
+	#   it contains the height- and terrain-map, too. This has the advantage, that everything about a level is stored in one
+	#   text and can thus be transfered easily over internet 
+	# * *w* and *h* are the width and height of the screen, which is currently needed to init the underlying GLApp-class from C++
+	#   *FIXME:* this could be replaced by a call to getMain.getVideo.getWidth and such
+	# * *loadscreen* is a LoadApp-object (or nil); if it's set that indicates that a loadscreen (a progress bar) is displayed
+	# * *connection* is a network-connection to a BoA multiplayer-server for future networking-support. link:files/ruby/multiplayer/README.html
+	#
+	# this function does all the initializing of a level:
+	# * from the super-classes: create a scene (for more go to the parent-class)
+	# * display a load-screen (and set the progress)
+	# * create a AntMpMap object
+	# * create a displaying layout from data/gui/layout/ant_layout.xml
+	# * initializes some event-handlers (glue code between level-displaying and the game-world object of type AntMpMap
+	# * load the map fom *savegameText*
+	# * setup of the hero-display-list at the top of the screen
 	def initialize(savegameText,w,h,loadscreen=nil,connection=nil)
 		super(w,h)
 
@@ -589,7 +609,6 @@
 	def selectHero(h)
 		@hero=h
 		inspectEntity(h)
-		@buttonpanel.setName(h.getName)
 		@buttonpanel.setHero(h)
 
 		for i in 0..2
@@ -615,7 +634,9 @@
 end
 
 
-# this function is only for starting a level directly (mostly for testing purpose)
+# this function is only for starting a level directly (single map from the mainmenu or from cli)
+# you can start BoA from the cli by giving a level-name directly
+# For more information on that topic please refer to link:files/ruby/debugging/README.html
 def startGame(file="savegames/savegame0.antlvl",clientConnection=nil)
 	app=nil
 	if clientConnection

Modified: antargis/branches/rant/ruby/mainmenu.rb
===================================================================
--- antargis/branches/rant/ruby/mainmenu.rb	2007-08-29 18:04:59 UTC (rev 1165)
+++ antargis/branches/rant/ruby/mainmenu.rb	2007-08-30 18:31:59 UTC (rev 1166)
@@ -1,7 +1,7 @@
-#
+#--
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
-# layout.rb
+# mainmenu.rb
 # by David Kamphausen (david.kamphausen at web.de)
 #
 # The "Antargis" project, including all files needed to compile it,
@@ -16,7 +16,7 @@
 #
 # You should have received a copy of the GNU General Public
 # License along with this program.
-#
+#++
 
 require 'ruby/antargislib.rb'
 $useMenu=true
@@ -292,6 +292,9 @@
 			i+=1
 		}
 	end
+
+	# :section: Campaign Menu Event Handlers
+
 	def eventMission(e)
 		callerName=e.getCaller.getName
 		number=callerName[8..12].to_i
@@ -312,7 +315,7 @@
 		return true
 	end
 	
-
+	# :section: Options Menu Event handlers
 	
 	def eventTextureQuality(e)
 		scale={"low"=>3,"medium"=>2,"high"=>1}[@optionsMenu.getChild("textureQuality").getSelected]
@@ -421,15 +424,17 @@
 	# -------------------------------
 	# :section: Main Menu Event Handlers
 	# -------------------------------
+	
+	# open the credits screen
 	def eventCredits(e)
 		setMainWidget(@creditsMenu)
 		return true
 	end
+	# go to the single-game selection screen
 	def eventSingle(e)
 		setMainWidget(@singleMenu)
 		return true
 	end
-
 	# start the tutorial-campaign directly for new users, so
 	# they won't have to deal with "campaigning", where tutorial can be found, too
 	def eventTutorial(e)
@@ -439,16 +444,18 @@
 		soundOn
 		return true
 	end
-
+	# go to the campaign-selection screen
 	def eventCampaign(e)
 		setMainWidget(@campaignMenu)
 		return true
 	end
+	# loading a game-screen will follow after this event
 	def eventLoadGame(e)
 		updateLoadMenu
 		setMainWidget(@loadMenu)
 		return true
 	end
+	# go to the options-screen
 	def eventOptions(e)
 		setMainWidget(@optionsMenu)
 		return true

Modified: antargis/branches/rant/ruby/view.rb
===================================================================
--- antargis/branches/rant/ruby/view.rb	2007-08-29 18:04:59 UTC (rev 1165)
+++ antargis/branches/rant/ruby/view.rb	2007-08-30 18:31:59 UTC (rev 1166)
@@ -29,6 +29,9 @@
 require 'ant_energy.rb'
 require 'terrain_2d.rb' # used in 2d-display, but needed anywhere
 
+require 'ant_buttonpanel.rb'
+require 'ant_name_display.rb'
+
 if (not MyAntargislib.opengl)
 	require 'two_d_app.rb'
 else
@@ -36,6 +39,10 @@
 	end
 end
 
+
+# AntRubyView is the central view class of antargis. It contains several sub-views like:
+# * AntButtonPanel
+# * FIXME
 class AntRubyView <AntBaseMapView
 	def initialize(w,h)
 		super(w,h)
@@ -198,148 +205,9 @@
 
 
 
-class AntButtonPanel<AGWidget
-	attr_reader :job
-	def initialize(p,r)
-		super(p,r)
-		setName("ButtonPanel")
-		puts self,self.class,respond_to?(:clearHandlers),self.is_a?(AGWidget),self.methods.join("//")
-		clearHandlers
-		@jobButtons=["doRest","doDismiss","doDropFood","doDropWeapon","doBuild"]
-		@aggButtons={"doAgg0"=>1,"doAgg1"=>2,"doAgg2"=>3}
-		@inited=false
-		@agg=1
 
-		addSignal("sigAggressionChanged")
-		addSignal("sigJobChanged")
 
-		@hero=nil
-	end
-	def setHero(h)
-		@hero=h
-	end
-	def initHandlers
-		getChild("doAgg0").setChecked(true)
-		@job="doRest"
-		@jobButtons.each {|b|
-			c=getChild(b)
-			addHandler(c,:sigClick,:eventJobSelected)
-		}
-		@aggButtons.each {|b,a|
-			c=getChild(b)
-			addHandler(c,:sigClick,:eventAggSelected)
-		}
-	end
-	def prepareDraw
-		updateJobView
-		super
-	end
-	def setName(n)
-		if getChild("heroName")
-			getChild("heroName").setText(_(n))
-		end
-	end
-	
-	def eventJobSelected(e)
-		@job=e.getCaller.getName
-		sigJobChanged(e)
-		return true
-	end
-	def eventAggSelected(e)
-		@agg=@aggButtons[e.getCaller.getName]
-		sigAggressionChanged(e)
-		return true
-	end
-	
-	def setAggression(l)
-		l=l.to_i
-		@aggButtons.each{|n,b|
-			getChild(n).setChecked((b==l))
-		}
-		@agg=l
-	end
-	def getAggression()
-		return @agg
-	end
-	def setPointing
-		@job="doPoint"
-		getChild("doFight").setChecked(true)
-	end
-private
-	def updateJobView
-		return if @hero.nil?
-		if @hero.getJob
-			i=@hero.getJob.image
-		else
-			i="data/gui/bed.png"
-		end
-		if @job!=i
-			@job=i
-			getChild("jobView").setTexture(getTextureCache.get(i))
-		end
-	end
-end
 
-# factory for buttonpanel-widget
-class AntButtonPanelCreator<AGLayoutCreator
-	def create(p,r,n)
-		setResult AntButtonPanel.new(p,r)
-	end
-end
-getLayoutFactory.addCreator("antButtonPanel",AntButtonPanelCreator.new)
-
-
-class AntNameDisplay<AGWidget
-	@@fontChangeCount=0
-
-	def initialize(p,r,hero,map)
-		super(p,r)
-		@map=map
-		@hero=hero
-		@font=getTheme.getFont("heroName.font")
-		@oldfont=@font
-		@name=@hero.getName
-		addChild(@mb=AGButton.new(self,AGRect.new(0,0,width,height),_("")))
-		
-		@mb.setEnabled(false)
-		addChild(@textWidget=AGText.new(self,AGRect.new(0,0,width,height),AGStringUtf8.new(@hero.getName), at font))
-		
-		@fonts={true=>getTheme.getFont("heroName.font"),false=>getTheme.getFont("enemyHero.font")}
-		@oldPlayer=nil
-		setCaching(true)
-	end
-
-	# enforce integer position	
-	def setRect(r)
-		super(AGRect.new(r.x.to_i,r.y.to_i,r.w.to_i,r.h.to_i))
-	end
-	
-	def getText
-		@name
-	end
-
-	def prepareDraw
-		@font=@fonts[@hero.getPlayer==@map.getPlayer]
-		if @font!=@oldfont
-			puts "#{@hero.getPlayer} #{@map.getPlayer} #{@oldPlayer}"
-			puts "#{@font} #{@oldfont}"
-			@oldPlayer=@hero.getPlayer
-			puts "font changed"
-			@@fontChangeCount||=0
-			@@fontChangeCount+=1
-			if @@fontChangeCount>20
-				raise 1
-			end
-			@oldfont=@font
-			@textWidget.setFont(@font)
-			queryRedraw
-		end
-		super
-	end
-
-	private
-end
-
 class AntInfoBox<AGLayout
 	def initialize(p,n)
 		super(p)



From davidkamphausen at mail.berlios.de  Thu Aug 30 20:32:21 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Thu, 30 Aug 2007 20:32:21 +0200
Subject: [Antargis-svn] r1167 - in antargis/branches/rant/ruby: debugging
	multiplayer widgets
Message-ID: <200708301832.l7UIWLLO012869@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-08-30 20:32:20 +0200 (Thu, 30 Aug 2007)
New Revision: 1167

Added:
   antargis/branches/rant/ruby/debugging/README
   antargis/branches/rant/ruby/multiplayer/README
   antargis/branches/rant/ruby/widgets/ant_buttonpanel.rb
   antargis/branches/rant/ruby/widgets/ant_name_display.rb
Log:
* missing files


Added: antargis/branches/rant/ruby/debugging/README
===================================================================
--- antargis/branches/rant/ruby/debugging/README	2007-08-30 18:31:59 UTC (rev 1166)
+++ antargis/branches/rant/ruby/debugging/README	2007-08-30 18:32:20 UTC (rev 1167)
@@ -0,0 +1,8 @@
+When you're debugging it's in nice, when you can start at a specific place within the game, so mustn't 
+go through all these menus and stuff. This file explains how to do this.
+
+== Running levels from CLI
+ ruby ruby/antargis.rb levels/tutorial/tutorial0
+will start the first level of the tutorial campaign.
+ ruby ruby/antargis.rb savegames/savegame0
+will start a savegame (which is normally stored in ~/.Antargis/savegames/savegame0.antlvl)
\ No newline at end of file

Added: antargis/branches/rant/ruby/multiplayer/README
===================================================================
--- antargis/branches/rant/ruby/multiplayer/README	2007-08-30 18:31:59 UTC (rev 1166)
+++ antargis/branches/rant/ruby/multiplayer/README	2007-08-30 18:32:20 UTC (rev 1167)
@@ -0,0 +1 @@
+Work in progress
\ No newline at end of file

Added: antargis/branches/rant/ruby/widgets/ant_buttonpanel.rb
===================================================================
--- antargis/branches/rant/ruby/widgets/ant_buttonpanel.rb	2007-08-30 18:31:59 UTC (rev 1166)
+++ antargis/branches/rant/ruby/widgets/ant_buttonpanel.rb	2007-08-30 18:32:20 UTC (rev 1167)
@@ -0,0 +1,132 @@
+# this file contains:
+# * AntButtonPanel - the button panel on the right of the game-screen containing the jobButtons
+# * AntButtonPanelCreator - a creator-class for AntButtonPanel (needed for layouts to create such a widget)
+
+
+# AntButtonPanel is the widget that's displayed on the top left of the screen.
+# It contains some (hl-)job-buttons, a display of the current job, the selected heroes is doing and
+# the name of this hero.
+# It's embedded through a layout into the screen and thus needs a creator class named AntButtonPanelCreator.
+#
+# Important note:
+# This class contains two signals named
+# * sigAggressionChanged
+# * sigJobChanged
+# You can attach your listeners to these to receive events when the aggression or a job is changed.
+class AntButtonPanel<AGWidget
+	attr_reader :job
+	
+
+	def initialize(p,r)
+		super(p,r)
+		setName("ButtonPanel")
+		puts self,self.class,respond_to?(:clearHandlers),self.is_a?(AGWidget),self.methods.join("//")
+		clearHandlers
+		@jobButtons=["doRest","doDismiss","doDropFood","doDropWeapon","doBuild"]
+		@aggButtons={"doAgg0"=>1,"doAgg1"=>2,"doAgg2"=>3}
+		@inited=false
+		@agg=1
+
+		addSignal("sigAggressionChanged")
+		addSignal("sigJobChanged")
+
+		@hero=nil
+	end
+
+	# set the current hero *h* of class AntHero
+	def setHero(h)
+		assert{h.is_a?(AntHero) || h.nil?}
+		@hero=h
+		if @hero
+			setName(@hero.getName)
+		else
+			setName(_("no hero"))
+		end
+	end
+
+
+	# event-handlers can't be initialized in the constructor initialize, because
+	# possible children are not yet created.
+	# *initHandlers* initializes event-handlers for the job- and aggression-selection buttons.
+	# FIXME: this function should only be called once ! may be check this
+	def initHandlers
+		getChild("doAgg0").setChecked(true)
+		@job="doRest"
+		@jobButtons.each {|b|
+			c=getChild(b)
+			addHandler(c,:sigClick,:eventJobSelected)
+		}
+		@aggButtons.each {|b,a|
+			c=getChild(b)
+			addHandler(c,:sigClick,:eventAggSelected)
+		}
+	end
+
+	# checks if the view has to be updated
+	def prepareDraw
+		updateJobView
+		super
+	end
+
+	
+	def eventJobSelected(e)
+		@job=e.getCaller.getName
+		sigJobChanged(e)
+		return true
+	end
+
+	# another aggression was selected, so put it forward to this signal *sigAggressionChanged*
+	def eventAggSelected(e)
+		@agg=@aggButtons[e.getCaller.getName]
+		sigAggressionChanged(e)
+		return true
+	end
+	
+	# force setting an aggresion 
+	# FIXME: which aggressions are ok ??? Check this in here!
+	def setAggression(l)
+		l=l.to_i
+		@aggButtons.each{|n,b|
+			getChild(n).setChecked((b==l))
+		}
+		@agg=l
+	end
+
+	# get the current aggression
+	def getAggression
+		@agg
+	end
+	def setPointing
+		@job="doPoint"
+		getChild("doFight").setChecked(true)
+	end
+private
+	def updateJobView
+		return if @hero.nil?
+		if @hero.getJob
+			i=@hero.getJob.image
+		else
+			i="data/gui/bed.png"
+		end
+		if @job!=i
+			@job=i
+			getChild("jobView").setTexture(getTextureCache.get(i))
+		end
+	end
+
+	# set another name for the hero-name-display
+	def setName(n)
+		if getChild("heroName")
+			getChild("heroName").setText(_(n))
+		end
+	end
+
+end
+
+# factory for buttonpanel-widget
+class AntButtonPanelCreator<AGLayoutCreator
+	def create(p,r,n)
+		setResult AntButtonPanel.new(p,r)
+	end
+end
+getLayoutFactory.addCreator("antButtonPanel",AntButtonPanelCreator.new)

Added: antargis/branches/rant/ruby/widgets/ant_name_display.rb
===================================================================
--- antargis/branches/rant/ruby/widgets/ant_name_display.rb	2007-08-30 18:31:59 UTC (rev 1166)
+++ antargis/branches/rant/ruby/widgets/ant_name_display.rb	2007-08-30 18:32:20 UTC (rev 1167)
@@ -0,0 +1,50 @@
+class AntNameDisplay<AGWidget
+	@@fontChangeCount=0
+
+	def initialize(p,r,hero,map)
+		super(p,r)
+		@map=map
+		@hero=hero
+		@font=getTheme.getFont("heroName.font")
+		@oldfont=@font
+		@name=@hero.getName
+		addChild(@mb=AGButton.new(self,AGRect.new(0,0,width,height),_("")))
+		
+		@mb.setEnabled(false)
+		addChild(@textWidget=AGText.new(self,AGRect.new(0,0,width,height),AGStringUtf8.new(@hero.getName), at font))
+		
+		@fonts={true=>getTheme.getFont("heroName.font"),false=>getTheme.getFont("enemyHero.font")}
+		@oldPlayer=nil
+		setCaching(true)
+	end
+
+	# enforce integer position	
+	def setRect(r)
+		super(AGRect.new(r.x.to_i,r.y.to_i,r.w.to_i,r.h.to_i))
+	end
+	
+	def getText
+		@name
+	end
+
+	def prepareDraw
+		@font=@fonts[@hero.getPlayer==@map.getPlayer]
+		if @font!=@oldfont
+			puts "#{@hero.getPlayer} #{@map.getPlayer} #{@oldPlayer}"
+			puts "#{@font} #{@oldfont}"
+			@oldPlayer=@hero.getPlayer
+			puts "font changed"
+			@@fontChangeCount||=0
+			@@fontChangeCount+=1
+			if @@fontChangeCount>20
+				raise 1
+			end
+			@oldfont=@font
+			@textWidget.setFont(@font)
+			queryRedraw
+		end
+		super
+	end
+
+	private
+end



