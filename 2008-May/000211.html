<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Antargis-svn] r1255 - in antargis/trunk: ext/basic ext/game	ext/gui ext/math ext/video rookey ruby ruby/editor/campaign	ruby/spec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/antargis-svn/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1255%20-%20in%20antargis/trunk%3A%20ext/basic%20ext/game%0A%09ext/gui%20ext/math%20ext/video%20rookey%20ruby%20ruby/editor/campaign%0A%09ruby/spec&In-Reply-To=%3C200805261822.m4QIMcM7022624%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000210.html">
   <LINK REL="Next"  HREF="000212.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Antargis-svn] r1255 - in antargis/trunk: ext/basic ext/game	ext/gui ext/math ext/video rookey ruby ruby/editor/campaign	ruby/spec</H1>
    <B>davidkamphausen at BerliOS</B> 
    <A HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1255%20-%20in%20antargis/trunk%3A%20ext/basic%20ext/game%0A%09ext/gui%20ext/math%20ext/video%20rookey%20ruby%20ruby/editor/campaign%0A%09ruby/spec&In-Reply-To=%3C200805261822.m4QIMcM7022624%40sheep.berlios.de%3E"
       TITLE="[Antargis-svn] r1255 - in antargis/trunk: ext/basic ext/game	ext/gui ext/math ext/video rookey ruby ruby/editor/campaign	ruby/spec">davidkamphausen at mail.berlios.de
       </A><BR>
    <I>Mon May 26 20:22:38 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000210.html">[Antargis-svn] r1254 - antargis/trunk/ext/math
</A></li>
        <LI>Next message: <A HREF="000212.html">[Antargis-svn] r1256 - in antargis/trunk: . ext/basic ext/game	rookey/cpp ruby ruby/jobs ruby/spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#211">[ date ]</a>
              <a href="thread.html#211">[ thread ]</a>
              <a href="subject.html#211">[ subject ]</a>
              <a href="author.html#211">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: davidkamphausen
Date: 2008-05-26 20:22:36 +0200 (Mon, 26 May 2008)
New Revision: 1255

Added:
   antargis/trunk/ruby/spec/spec_math.rb
Modified:
   antargis/trunk/ext/basic/ag_messageobject.cc
   antargis/trunk/ext/basic/ag_messageobject.h
   antargis/trunk/ext/game/minimap.cc
   antargis/trunk/ext/gui/ag_application.cc
   antargis/trunk/ext/gui/ag_widget.cc
   antargis/trunk/ext/math/ag_algebra.cc
   antargis/trunk/ext/math/templates.i
   antargis/trunk/ext/video/ag_glscreen.cc
   antargis/trunk/ext/video/ag_gltexture.cc
   antargis/trunk/ext/video/ag_projection.cc
   antargis/trunk/rookey/swig_interface_builder.rb
   antargis/trunk/ruby/ant_application.rb
   antargis/trunk/ruby/editor/campaign/drag_grid.rb
   antargis/trunk/ruby/spec/spec_game_gui.rb
   antargis/trunk/ruby/spec/spec_mouseevents.rb
   antargis/trunk/ruby/spec_helper.rb
   antargis/trunk/ruby/view.rb
Log:
Incomplete - task 12: determinant function raises problem 
<A HREF="http://localhost:3000/issues/show/12">http://localhost:3000/issues/show/12</A>
Incomplete - task 3: Minimap should be connected to glApp 
<A HREF="http://localhost:3000/issues/show/3">http://localhost:3000/issues/show/3</A>

Modified: antargis/trunk/ext/basic/ag_messageobject.cc
===================================================================
--- antargis/trunk/ext/basic/ag_messageobject.cc	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ext/basic/ag_messageobject.cc	2008-05-26 18:22:36 UTC (rev 1255)
@@ -196,6 +196,7 @@
 
 
 
+/*
 // AGSignal
 
 AGSignal::AGSignal():mCaller(0)
@@ -209,7 +210,7 @@
 AGSignal::AGSignal(AGMessageObject *pCaller):mCaller(pCaller)
   {
   }
-
+*/
 AGSignal::AGSignal(AGMessageObject *pCaller,const AGString &amp;pName):
   mName(pName),mCaller(pCaller)
     {

Modified: antargis/trunk/ext/basic/ag_messageobject.h
===================================================================
--- antargis/trunk/ext/basic/ag_messageobject.h	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ext/basic/ag_messageobject.h	2008-05-26 18:22:36 UTC (rev 1255)
@@ -166,8 +166,8 @@
 class AGEXPORT AGSignal
 {
  public:
-  AGSignal();
-  AGSignal(AGMessageObject *pCaller);
+  //AGSignal();
+  //AGSignal(AGMessageObject *pCaller);
   AGSignal(AGMessageObject *pCaller,const AGString &amp;pName);
 
   virtual ~AGSignal();

Modified: antargis/trunk/ext/game/minimap.cc
===================================================================
--- antargis/trunk/ext/game/minimap.cc	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ext/game/minimap.cc	2008-05-26 18:22:36 UTC (rev 1255)
@@ -9,13 +9,14 @@
 MiniMap::MiniMap(AGWidget *p,const AGRect2 &amp;r,AntMap *pMap):
   AGWidget(p,r),
   mMap(pMap),
-  mSurface(r.w(),r.h())
-	  {
-	    mMapBorder=24;
-	    mScene=0;
-	    mTexture=new AGTexture(mSurface);
-	    setMap(mMap);
-	  }
+  mSurface(r.w(),r.h()),
+  sigMoved(this,&quot;sigMoved&quot;)
+    {
+      mMapBorder=24;
+      mScene=0;
+      mTexture=new AGTexture(mSurface);
+      setMap(mMap);
+    }
 
 MiniMap::~MiniMap()
   {
@@ -25,14 +26,12 @@
 
 bool MiniMap::mapChangedComplete(AGEvent *e)
   {
-    //  CTRACE;
     mapChangedP(true);
     return false;
   }
 
 bool MiniMap::mapChanged(AGEvent *e)
   {
-    //  CTRACE;
     mapChangedP(false);
     return false;
   }
@@ -265,19 +264,23 @@
     AGWidget::eventMouseButtonDown(m);
 
     // eat up event - so antView, doesn't get it
+    return(hovered());
+    /*      ret
     if(m-&gt;isSDLEvent())
       if(getRect().contains(m-&gt;getRelMousePosition()))
         return true;
-    return false;
+    return false;*/
   }
 
 bool MiniMap::eventMouseClick(AGEvent *m)
   {
+    cdebug(&quot;clicked&quot;);
     AGVector2 p(m-&gt;getMousePosition()-getScreenRect()[0]);
     if(mMap==0 || mScene==0)
       return AGWidget::eventMouseClick(m);
 
     AGVector2 v(p);
+    cdebug(&quot;clicked&quot;);
 
     float w=25*getRect().w()/mMap-&gt;getW();
     float h=25*getRect().h()/mMap-&gt;getH();
@@ -294,7 +297,7 @@
       v[1]=height()-h;
 
     v=toMapCoords(v);
-
+    cdebug(&quot;sigMoved&quot;);
     mPos=v;
     sigMoved(m);
     /*

Modified: antargis/trunk/ext/gui/ag_application.cc
===================================================================
--- antargis/trunk/ext/gui/ag_application.cc	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ext/gui/ag_application.cc	2008-05-26 18:22:36 UTC (rev 1255)
@@ -42,7 +42,7 @@
 AGVector2 gAppCursorPos;
 
 AGApplication::AGApplication() :
-	sigFrameFinished(this,&quot;sigFrameFinished&quot;),
+  sigFrameFinished(this,&quot;sigFrameFinished&quot;),
   mRunning(true), mIdleCalls(true), mainWidget(0), mTooltip(0), mOverlay(0)
   {
     assertGL;
@@ -59,7 +59,7 @@
   {
     CTRACE;
     if(mainWidget)
-    	mainWidget-&gt;setApp(0);
+      mainWidget-&gt;setApp(0);
     delete mCursor;
   }
 

Modified: antargis/trunk/ext/gui/ag_widget.cc
===================================================================
--- antargis/trunk/ext/gui/ag_widget.cc	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ext/gui/ag_widget.cc	2008-05-26 18:22:36 UTC (rev 1255)
@@ -56,6 +56,7 @@
   sigMouseEnter(this,&quot;sigMouseEnter&quot;),
   sigMouseLeave(this,&quot;sigMouseLeave&quot;),
   sigClick(this,&quot;sigClick&quot;),
+  sigDragBy(this,&quot;sigDragBy&quot;),
   mApp(0),
   mRect(r),mClientWorld(r.origin()),mUseClientRect(false),
   mParent(pParent),mChildrenEventFirst(false),mChildrenDrawFirst(false),mMouseIn(false),mButtonDown(false),

Modified: antargis/trunk/ext/math/ag_algebra.cc
===================================================================
--- antargis/trunk/ext/math/ag_algebra.cc	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ext/math/ag_algebra.cc	2008-05-26 18:22:36 UTC (rev 1255)
@@ -70,7 +70,7 @@
 AGMatrixN &amp;AGMatrixN::operator+=(const AGMatrixN &amp;p)
   {
     assert(mW==p.mW &amp;&amp; mH==p.mH);
-    for(size_t x=0;x&lt;p.mW;x++)
+    for(size_t x=0;x&lt;mW;x++)
       for(size_t y=0;y&lt;mH;y++)
         {
           set(x,y,get(x,y)+p.get(x,y));
@@ -286,14 +286,15 @@
     assert(t.width()==t.height());
     if(t.width()&gt;2)
       {
-        AGMatrixN n(t.width()-1,t.height());
+        AGMatrixN n(t.width()-1,t.height()-1);
         AGMatrixN l(t.skipCol(0));
+        assert(l.width()==t.height()-1);
         float c;
         // take always first row for reduction
         for(size_t i=0;i&lt;t.height();i++)
           {
             c=(i&amp;1)?-1:1;
-            n+=t.skipRow(i)*t.get(0,i)*c;
+            n+=l.skipRow(i)*t.get(0,i)*c;
           }
         return determinant(n);
       }
@@ -304,3 +305,5 @@
         return t.get(0,0)*t.get(1,1)-t.get(1,0)*t.get(0,1);
       }
   }
+
+template float determinant&lt;AGMatrixN&gt;(const AGMatrixN&amp;p);

Modified: antargis/trunk/ext/math/templates.i
===================================================================
--- antargis/trunk/ext/math/templates.i	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ext/math/templates.i	2008-05-26 18:22:36 UTC (rev 1255)
@@ -7,3 +7,8 @@
 %template(AGRect2List) std::list&lt;AGRect2&gt;;
 %template(AGMatrixVector) std::vector&lt;AGMatrix4&gt;;
 
+%include &quot;ag_algebra.h&quot;
+
+%template(determinantAGMatrix3) determinant&lt;AGMatrix3&gt;;
+%template(determinantAGMatrix4) determinant&lt;AGMatrix4&gt;;
+%template(determinantAGMatrixN) determinant&lt;AGMatrixN&gt;;
\ No newline at end of file

Modified: antargis/trunk/ext/video/ag_glscreen.cc
===================================================================
--- antargis/trunk/ext/video/ag_glscreen.cc	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ext/video/ag_glscreen.cc	2008-05-26 18:22:36 UTC (rev 1255)
@@ -118,41 +118,41 @@
 AGGLScreen::AGGLScreen(int W,int H,int VW,int VH):
   w(VW),h(VH),
   rw(W),rh(H)
-        {
-          if(w&lt;rw)
-            w=rw;
-          if(h&lt;rh)
-            h=rh;
+          {
+            if(w&lt;rw)
+              w=rw;
+            if(h&lt;rh)
+              h=rh;
 
-          mLineWidth=2;
+            mLineWidth=2;
 
-          cdebug(&quot;w:&quot;&lt;&lt;w&lt;&lt;&quot; h:&quot;&lt;&lt;h);
+            cdebug(&quot;w:&quot;&lt;&lt;w&lt;&lt;&quot; h:&quot;&lt;&lt;h);
 
-          // init GL
-          glEnable(GL_TEXTURE_2D);
-          glShadeModel(GL_SMOOTH);
-          glClearColor(0.0f,0.0f,0.0f,0.0f); // clear bgcolor
-          glClearDepth(1.0f);      // clear depth buffer
-          glEnable(GL_DEPTH_TEST); // enable depth test
-          glDepthFunc(GL_LEQUAL); // set type depth test
-          glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // GL_NICEST // best perspective correction
-          glEnable(GL_BLEND);
+            // init GL
+            glEnable(GL_TEXTURE_2D);
+            glShadeModel(GL_SMOOTH);
+            glClearColor(0.0f,0.0f,0.0f,0.0f); // clear bgcolor
+            glClearDepth(1.0f);      // clear depth buffer
+            glEnable(GL_DEPTH_TEST); // enable depth test
+            glDepthFunc(GL_LEQUAL); // set type depth test
+            glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // GL_NICEST // best perspective correction
+            glEnable(GL_BLEND);
 
-          glViewport( 0, 0, rw, rh );
-          glMatrixMode( GL_PROJECTION );
-          glLoadIdentity( );
+            glViewport( 0, 0, rw, rh );
+            glMatrixMode( GL_PROJECTION );
+            glLoadIdentity( );
 
-          GLfloat ratio;
+            GLfloat ratio;
 
-          ratio = ( float )w / ( float )h;
+            ratio = ( float )w / ( float )h;
 
-          //  gluPerspective( 45.0f, ratio, 1.0f, 100.0f );
+            //  gluPerspective( 45.0f, ratio, 1.0f, 100.0f );
 
-          gluOrtho2D(0,w,0,h);
+            gluOrtho2D(0,w,0,h);
 
-          glMatrixMode( GL_MODELVIEW );
-          glLoadIdentity( );
-        }
+            glMatrixMode( GL_MODELVIEW );
+            glLoadIdentity( );
+          }
 
 
 
@@ -163,14 +163,14 @@
 
 AGTexture AGGLScreen::screenshot(bool frontBuffer)
   {
-	assert(0);
+    assert(0);
     AGTexture t(getWidth(),getHeight());
-    
+
     AGGLTexture *glTexture=t.glTexture();
     AGRenderContext c;
     c.setTexture(glTexture);
     c.begin();
-    
+
     if(frontBuffer)
       glReadBuffer(GL_FRONT_LEFT);
     else
@@ -194,12 +194,12 @@
     glFinish();
     assertGL;
     glCopyTexSubImage2D(glTexture-&gt;getTarget(), 
-    0,0,0,0,0,getWidth(),getHeight()); 
+        0,0,0,0,0,getWidth(),getHeight()); 
     assertGL;
     // Dootherworkprocessinghere,usingadoubleortriplebuffer 
     glReadBuffer(GL_BACK);
 
-    
+
     return t;
   }
 

Modified: antargis/trunk/ext/video/ag_gltexture.cc
===================================================================
--- antargis/trunk/ext/video/ag_gltexture.cc	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ext/video/ag_gltexture.cc	2008-05-26 18:22:36 UTC (rev 1255)
@@ -30,262 +30,262 @@
 size_t gUsedTexMemory=0;
 
 bool isPowerOf2(size_t value)
-{
-	while(value!=0)
-	{
-		cdebug(value);
-		if(value&amp;1)
-		{
-			if((value^1))
-				return false;
-			else
-				return true;
-		}
-		value&gt;&gt;=1;
+  {
+    while(value!=0)
+      {
+        cdebug(value);
+        if(value&amp;1)
+          {
+            if((value^1))
+              return false;
+            else
+              return true;
+          }
+        value&gt;&gt;=1;
 
-	}
-	return true;
-}
+      }
+    return true;
+  }
 size_t nextPowerOf2(size_t value)
-{
-	TRACE;
-	size_t c=1;
-	while(c&lt;value)
-	{
-		cdebug(c&lt;&lt;&quot;;&quot;&lt;&lt;value);
-		c&lt;&lt;=1;
-	}
-	return c;
-}
+  {
+    TRACE;
+    size_t c=1;
+    while(c&lt;value)
+      {
+        cdebug(c&lt;&lt;&quot;;&quot;&lt;&lt;value);
+        c&lt;&lt;=1;
+      }
+    return c;
+  }
 
 
 char *AGGLTexture::dmaBuffer=0;
 
 AGGLTexture::AGGLTexture(size_t W,size_t H,GLint format):w(W),h(H),d(1),m3d(false),mRectTex(false),mTarget(GL_TEXTURE_2D)
-{
-	cdebug(&quot;HUPE&quot;);
-	initDMABuffer();
-	assertGL;
-	getSurfaceManager()-&gt;registerMe(this);
-	assertGL;
-	glGenTextures( 1, &amp;mID);
-	assertGL;
-	bool inited=false;
-	mTarget=GL_TEXTURE_2D;
+  {
+    cdebug(&quot;HUPE&quot;);
+    initDMABuffer();
+    assertGL;
+    getSurfaceManager()-&gt;registerMe(this);
+    assertGL;
+    glGenTextures( 1, &amp;mID);
+    assertGL;
+    bool inited=false;
+    mTarget=GL_TEXTURE_2D;
 
-	cdebug(w&lt;&lt;&quot;:&quot;&lt;&lt;h);
-	if(!(isPowerOf2(w) &amp;&amp; isPowerOf2(h)))
-	{
-		cdebug(&quot;not power of 2&quot;);
-		if(GLEE_ARB_texture_rectangle &amp;&amp; false)
-		{
-			mTarget=GL_TEXTURE_RECTANGLE_ARB;
-		}
-		else
-		{
-			h=w=nextPowerOf2(std::max(w,h));
-		}
-	}
-	cdebug(&quot;1&quot;);
-	glEnable(mTarget);
-	cdebug(&quot;2&quot;);
-	glBindTexture( mTarget,mID);
-	assertGL;
+    cdebug(w&lt;&lt;&quot;:&quot;&lt;&lt;h);
+    if(!(isPowerOf2(w) &amp;&amp; isPowerOf2(h)))
+      {
+        cdebug(&quot;not power of 2&quot;);
+        if(GLEE_ARB_texture_rectangle &amp;&amp; false)
+          {
+            mTarget=GL_TEXTURE_RECTANGLE_ARB;
+          }
+        else
+          {
+            h=w=nextPowerOf2(std::max(w,h));
+          }
+      }
+    cdebug(&quot;1&quot;);
+    glEnable(mTarget);
+    cdebug(&quot;2&quot;);
+    glBindTexture( mTarget,mID);
+    assertGL;
 
-	size_t bufSize=w*h*4;
-	char *buffer=0;
+    size_t bufSize=w*h*4;
+    char *buffer=0;
 
-	if(false)
-	{
-		buffer=new char[bufSize];
+    if(false)
+      {
+        buffer=new char[bufSize];
 
-		assert(buffer);
-	}
-	cdebug(&quot;3&quot;);
-	if(buffer)
-		memset(buffer,0,bufSize);
-	cdebug(&quot;5&quot;);
-	cdebug(mTarget);
-	cdebug(format);
-	cdebug(&quot;rect:&quot;&lt;&lt;(mTarget==GL_TEXTURE_RECTANGLE_ARB));
-	cdebug(&quot;2d:&quot;&lt;&lt;(mTarget==GL_TEXTURE_2D));
-	cdebug(&quot;3d:&quot;&lt;&lt;(mTarget==GL_TEXTURE_3D));
-	cdebug(&quot;GL_RGBA:&quot;&lt;&lt;(format==GL_RGBA));
-	cdebug(&quot;w:&quot;&lt;&lt;w&lt;&lt;&quot; h:&quot;&lt;&lt;h);
-	cdebug(&quot;texmem:&quot;&lt;&lt;	gUsedTexMemory);
-	cdebug((void*)buffer);
-	assertGL;
-	glTexImage2D(mTarget, 0, format, w, h, 0, GL_RGBA,
-			GL_UNSIGNED_BYTE, buffer);
-	assertGL;
-	cdebug(&quot;6&quot;);
+        assert(buffer);
+      }
+    cdebug(&quot;3&quot;);
+    if(buffer)
+      memset(buffer,0,bufSize);
+    cdebug(&quot;5&quot;);
+    cdebug(mTarget);
+    cdebug(format);
+    cdebug(&quot;rect:&quot;&lt;&lt;(mTarget==GL_TEXTURE_RECTANGLE_ARB));
+    cdebug(&quot;2d:&quot;&lt;&lt;(mTarget==GL_TEXTURE_2D));
+    cdebug(&quot;3d:&quot;&lt;&lt;(mTarget==GL_TEXTURE_3D));
+    cdebug(&quot;GL_RGBA:&quot;&lt;&lt;(format==GL_RGBA));
+    cdebug(&quot;w:&quot;&lt;&lt;w&lt;&lt;&quot; h:&quot;&lt;&lt;h);
+    cdebug(&quot;texmem:&quot;&lt;&lt;gUsedTexMemory);
+    cdebug((void*)buffer);
+    assertGL;
+    glTexImage2D(mTarget, 0, format, w, h, 0, GL_RGBA,
+        GL_UNSIGNED_BYTE, buffer);
+    assertGL;
+    cdebug(&quot;6&quot;);
 
-	if(buffer)
-		delete [] buffer;
+    if(buffer)
+      delete [] buffer;
 
-	cdebug(&quot;7&quot;);
-	cdebug(&quot;W:&quot;&lt;&lt;w&lt;&lt;&quot; h:&quot;&lt;&lt;h);
-	assertGL;
-	gUsedTexMemory+=w*h*4;
+    cdebug(&quot;7&quot;);
+    cdebug(&quot;W:&quot;&lt;&lt;w&lt;&lt;&quot; h:&quot;&lt;&lt;h);
+    assertGL;
+    gUsedTexMemory+=w*h*4;
 
-	cdebug(&quot;8&quot;);
-	dbout(4,&quot;used memory:&quot;&lt;&lt;gUsedTexMemory);
+    cdebug(&quot;8&quot;);
+    dbout(4,&quot;used memory:&quot;&lt;&lt;gUsedTexMemory);
 
-	glTexParameteri(mTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-	assertGL;
-	glTexParameteri(mTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-	assertGL;
-	cdebug(&quot;9&quot;);
-}
+    glTexParameteri(mTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    assertGL;
+    glTexParameteri(mTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    assertGL;
+    cdebug(&quot;9&quot;);
+  }
 AGGLTexture::AGGLTexture(size_t W,size_t H,size_t D,GLint format):w(W),h(H),d(D),m3d(true),mRectTex(false),mTarget(GL_TEXTURE_3D)
-{
-	assertGL;
-	getSurfaceManager()-&gt;registerMe(this);
-	assertGL;
+  {
+    assertGL;
+    getSurfaceManager()-&gt;registerMe(this);
+    assertGL;
 
-	glGenTextures( 1, &amp;mID);
-	assertGL;
-	glBindTexture( mTarget,mID);
-	assertGL;
+    glGenTextures( 1, &amp;mID);
+    assertGL;
+    glBindTexture( mTarget,mID);
+    assertGL;
 
-	glTexImage3D(mTarget, 0, format, w, h, d, 0, GL_RGBA,
-			GL_UNSIGNED_BYTE, 0);
-	assertGL;
+    glTexImage3D(mTarget, 0, format, w, h, d, 0, GL_RGBA,
+        GL_UNSIGNED_BYTE, 0);
+    assertGL;
 
-	gUsedTexMemory+=w*h*d*4;
-	dbout(4,&quot;used memory:&quot;&lt;&lt;gUsedTexMemory);
+    gUsedTexMemory+=w*h*d*4;
+    dbout(4,&quot;used memory:&quot;&lt;&lt;gUsedTexMemory);
 
-	glTexParameteri(mTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-	assertGL;
-	glTexParameteri(mTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-	assertGL;
-}
+    glTexParameteri(mTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    assertGL;
+    glTexParameteri(mTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    assertGL;
+  }
 
 AGGLTexture::~AGGLTexture()
-{
-	assertGL;
-	glDeleteTextures(1,&amp;mID);
+  {
+    assertGL;
+    glDeleteTextures(1,&amp;mID);
 
-	if(m3d)
-		gUsedTexMemory-=w*h*d*4;
-	else
-		gUsedTexMemory-=w*h*4;
+    if(m3d)
+      gUsedTexMemory-=w*h*d*4;
+    else
+      gUsedTexMemory-=w*h*4;
 
-	assertGL;
-	getSurfaceManager()-&gt;deregisterMe(this);
-}
+    assertGL;
+    getSurfaceManager()-&gt;deregisterMe(this);
+  }
 
 void AGGLTexture::setSurface(AGInternalSurface *pSurface,const AGVector2 &amp;offset)
-{
-	assertGL;
-	GLint format;
+  {
+    assertGL;
+    GLint format;
 
-	SDL_Surface *surface=pSurface-&gt;surface;
+    SDL_Surface *surface=pSurface-&gt;surface;
 
-	switch(surface-&gt;format-&gt;BytesPerPixel)
-	{
-	case 3:
-		format = GL_RGB;break;
-	case 4:
-		format = GL_RGBA;break;
-	default:
-		throw std::runtime_error(&quot;Surface-format not supported for texturing!&quot;);
-	}
+    switch(surface-&gt;format-&gt;BytesPerPixel)
+      {
+    case 3:
+      format = GL_RGB;break;
+    case 4:
+      format = GL_RGBA;break;
+    default:
+      throw std::runtime_error(&quot;Surface-format not supported for texturing!&quot;);
+      }
 
-	AGRenderContext c;
-	c.setTexture(this);
-	c.begin();
-	assertGL;
+    AGRenderContext c;
+    c.setTexture(this);
+    c.begin();
+    assertGL;
 
 
-	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
-	assertGL;
-	glPixelStorei(GL_UNPACK_ROW_LENGTH,
-			surface-&gt;pitch / surface-&gt;format-&gt;BytesPerPixel);
+    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+    assertGL;
+    glPixelStorei(GL_UNPACK_ROW_LENGTH,
+        surface-&gt;pitch / surface-&gt;format-&gt;BytesPerPixel);
 
 
-	assertGL;
-	if(m3d)
-	{
-		assert(glIsEnabled(mTarget));
-		int mw=std::min(surface-&gt;w,surface-&gt;h);
-		int mh=std::max(surface-&gt;w,surface-&gt;h)/mw;
+    assertGL;
+    if(m3d)
+      {
+        assert(glIsEnabled(mTarget));
+        int mw=std::min(surface-&gt;w,surface-&gt;h);
+        int mh=std::max(surface-&gt;w,surface-&gt;h)/mw;
 
-		// FIXME: use glTexImage instead of glTexSubImage, because it makes problems
-		// on MacOSX 10.5.1 (at least on my macbook pro - godrin)
+        // FIXME: use glTexImage instead of glTexSubImage, because it makes problems
+        // on MacOSX 10.5.1 (at least on my macbook pro - godrin)
 
-		glTexImage3D(mTarget, 0, format, w, h, d, 0, GL_RGBA,
-				GL_UNSIGNED_BYTE, surface-&gt;pixels);
-		glTexSubImage3D(mTarget,0,int(offset[0]),int(offset[1]),0,
-				mw,mw,mh,format,GL_UNSIGNED_BYTE,surface-&gt;pixels);
-	}
-	else
-	{
-		assertGL;
+        glTexImage3D(mTarget, 0, format, w, h, d, 0, GL_RGBA,
+            GL_UNSIGNED_BYTE, surface-&gt;pixels);
+        glTexSubImage3D(mTarget,0,int(offset[0]),int(offset[1]),0,
+            mw,mw,mh,format,GL_UNSIGNED_BYTE,surface-&gt;pixels);
+      }
+    else
+      {
+        assertGL;
 
-		glTexSubImage2D(mTarget, 0, int(offset[0]), int(offset[1]),
-				surface-&gt;w, surface-&gt;h, format, GL_UNSIGNED_BYTE,
-				surface-&gt;pixels);
-	}
-	assertGL;
-	AGRenderContext().begin();
-}
+        glTexSubImage2D(mTarget, 0, int(offset[0]), int(offset[1]),
+            surface-&gt;w, surface-&gt;h, format, GL_UNSIGNED_BYTE,
+            surface-&gt;pixels);
+      }
+    assertGL;
+    AGRenderContext().begin();
+  }
 
 GLuint AGGLTexture::id()
-{
+  {
 
-	return mID;
-}
+    return mID;
+  }
 bool AGGLTexture::is3d() const
 {
-	return m3d;
+  return m3d;
 }
 
 size_t AGGLTexture::width() const
 {
-	return w;
+  return w;
 }
 size_t AGGLTexture::height() const
 {
-	return h;
+  return h;
 }
 size_t AGGLTexture::depth() const
 {
-	return d;
+  return d;
 }
 
 AGSurface AGGLTexture::getSurface() const
 {
-	AGSurface s(w,h*d);
-	size_t bufSize=width()*height()*4;
-	unsigned char *pixels=new unsigned char[bufSize];
+  AGSurface s(w,h*d);
+  size_t bufSize=width()*height()*4;
+  unsigned char *pixels=new unsigned char[bufSize];
 
-	glGetTexImage(mTarget,0,GL_RGBA, 
-			GL_UNSIGNED_INT_8_8_8_8_REV,pixels); 
+  glGetTexImage(mTarget,0,GL_RGBA, 
+      GL_UNSIGNED_INT_8_8_8_8_REV,pixels); 
 
-	{
-		// copy
-		TRACE;
-		int h=height()-1;
-		for(int x=0;x&lt;(int)width();x++)
-			for(int y=0;y&lt;(int)height();y++)
-			{
-				unsigned char*p=pixels+((x+(h-y)*width())*4);
-				AGColor c(p[0],p[1],p[2],p[3]);
-				s.putPixel(x,y,c);
-			}
-	}
+  {
+    // copy
+    TRACE;
+    int h=height()-1;
+    for(int x=0;x&lt;(int)width();x++)
+      for(int y=0;y&lt;(int)height();y++)
+        {
+          unsigned char*p=pixels+((x+(h-y)*width())*4);
+          AGColor c(p[0],p[1],p[2],p[3]);
+          s.putPixel(x,y,c);
+        }
+  }
 
-	return s;  
+  return s;  
 }
 
 void AGGLTexture::initDMABuffer()
-{
-	return;
-	if(!dmaBuffer)
-	{
-		size_t texbufsize=1024*1024*64;
-		dmaBuffer=new char[texbufsize];
-		glTextureRangeAPPLE(GL_TEXTURE_2D,texbufsize,dmaBuffer); 
-	}
-}
+  {
+    return;
+    if(!dmaBuffer)
+      {
+        size_t texbufsize=1024*1024*64;
+        dmaBuffer=new char[texbufsize];
+        glTextureRangeAPPLE(GL_TEXTURE_2D,texbufsize,dmaBuffer); 
+      }
+  }

Modified: antargis/trunk/ext/video/ag_projection.cc
===================================================================
--- antargis/trunk/ext/video/ag_projection.cc	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ext/video/ag_projection.cc	2008-05-26 18:22:36 UTC (rev 1255)
@@ -30,6 +30,8 @@
     AGMatrix3 m3(to.getV0());
 
     m=m3*m2*m1;
+    
+    assert(isInvertable(m));
   }
 
 AGRect2 AGProjection2D::project(const AGRect2 &amp;r) const

Modified: antargis/trunk/rookey/swig_interface_builder.rb
===================================================================
--- antargis/trunk/rookey/swig_interface_builder.rb	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/rookey/swig_interface_builder.rb	2008-05-26 18:22:36 UTC (rev 1255)
@@ -110,6 +110,12 @@
 &quot;%module(directors=\&quot;1\&quot;) #{@moduleName}
 %feature(\&quot;autodoc\&quot;,\&quot;1\&quot;);
 
+/*
+%feature(\&quot;director:except\&quot;) {
+ throw Swig::DirectorMethodException($error);
+}
+*/
+
 #{importInterfaces}
 
 #{stlIncludes}

Modified: antargis/trunk/ruby/ant_application.rb
===================================================================
--- antargis/trunk/ruby/ant_application.rb	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ruby/ant_application.rb	2008-05-26 18:22:36 UTC (rev 1255)
@@ -45,7 +45,7 @@
 # get save path where savegames are stored
 # NOTE: this is combined with getWriteDir from ag_fs.h !
 def getSavePath
-	&quot;savegames&quot;
+  &quot;savegames&quot;
 end
 
 #
@@ -56,582 +56,588 @@
 # * it's derived from AntRubyView, which implements/manages the (3d-)displaying in-game
 #
 class AntGameApp &lt;AntRubyView
-	attr_accessor :result
-	attr_reader :hero
+  attr_accessor :result
+  attr_reader :hero
 
-	include AGHandler
+  include AGHandler
 
-	# creating an AntGameApp-object needs the following parameters:
-	# * *savegameText* - this is the actual level serialized in a string (the xml-text you see when you open an .antlvl-file)
-	#   it contains the height- and terrain-map, too. This has the advantage, that everything about a level is stored in one
-	#   text and can thus be transfered easily over internet 
-	# * *w* and *h* are the width and height of the screen, which is currently needed to init the underlying GLApp-class from C++
-	#   *FIXME:* this could be replaced by a call to getMain.getVideo.getWidth and such
-	# * *loadscreen* is a LoadApp-object (or nil); if it's set that indicates that a loadscreen (a progress bar) is displayed
-	# * *connection* is a network-connection to a BoA multiplayer-server for future networking-support. link:files/ruby/multiplayer/README.html
-	#
-	# this function does all the initializing of a level:
-	# * from the super-classes: create a scene (for more go to the parent-class)
-	# * display a load-screen (and set the progress)
-	# * create a AntMpMap object
-	# * create a displaying layout from data/gui/layout/ant_layout.xml
-	# * initializes some event-handlers (glue code between level-displaying and the game-world object of type AntMpMap
-	# * load the map fom *savegameText*
-	# * setup of the hero-display-list at the top of the screen
-	def initialize(savegameText,w,h,loadscreen=nil,connection=nil)
-		super(w,h)
+  # creating an AntGameApp-object needs the following parameters:
+  # * *savegameText* - this is the actual level serialized in a string (the xml-text you see when you open an .antlvl-file)
+  #   it contains the height- and terrain-map, too. This has the advantage, that everything about a level is stored in one
+  #   text and can thus be transfered easily over internet 
+  # * *w* and *h* are the width and height of the screen, which is currently needed to init the underlying GLApp-class from C++
+  #   *FIXME:* this could be replaced by a call to getMain.getVideo.getWidth and such
+  # * *loadscreen* is a LoadApp-object (or nil); if it's set that indicates that a loadscreen (a progress bar) is displayed
+  # * *connection* is a network-connection to a BoA multiplayer-server for future networking-support. link:files/ruby/multiplayer/README.html
+  #
+  # this function does all the initializing of a level:
+  # * from the super-classes: create a scene (for more go to the parent-class)
+  # * display a load-screen (and set the progress)
+  # * create a AntMpMap object
+  # * create a displaying layout from data/gui/layout/ant_layout.xml
+  # * initializes some event-handlers (glue code between level-displaying and the game-world object of type AntMpMap
+  # * load the map fom *savegameText*
+  # * setup of the hero-display-list at the top of the screen
+  def initialize(savegameText,w,h,loadscreen=nil,connection=nil)
+    super(w,h)
 
-		@speed=1
+    @speed=1
 
-		# the result of the level - won or lost or canceled
-		@result=GameResult.new
-		$app=self
-		AntSound.setApplication(self)
-	
-		# display loading screen
-		if loadscreen
-			loadscreen.setValue(0.1)
-			loadscreen.tick
-		end
+    # the result of the level - won or lost or canceled
+    @result=GameResult.new
+    $app=self
+    AntSound.setApplication(self)
+  
+    # display loading screen
+    if loadscreen
+      loadscreen.setValue(0.1)
+      loadscreen.tick
+    end
 
-		playerName=nil
+    playerName=nil
 
-		# init network mode
-		@connection=connection
-		if connection
-			# FIXME: check, if this is a server - then don't assign playerName
-			playerName=connection.getName
-		end
+    # init network mode
+    @connection=connection
+    if connection
+      # FIXME: check, if this is a server - then don't assign playerName
+      playerName=connection.getName
+    end
 
-		# init game-engine's map
-		@map=AntMpMap.new(connection,self,getScene,32,32,playerName) # some small dummy size - gets overriden by loadMap anyway
-		if loadscreen
-			loadscreen.setValue(0.4)
-			loadscreen.tick
-		end
+    # init game-engine's map
+    @map=AntMpMap.new(connection,self,getScene,32,32,playerName) # some small dummy size - gets overriden by loadMap anyway
+    if loadscreen
+      loadscreen.setValue(0.4)
+      loadscreen.tick
+    end
 
-		# load GUI layout
-		@layout=AGLayout.new(nil)
-		@layout.setApp(self)
-		assert{@layout.getApp}
-		@layout.loadXML(loadFile(&quot;data/gui/layout/ant_layout.xml&quot;))
-	
+    # load GUI layout
+    @layout=AGLayout.new(nil)
+    @layout.setApp(self)
+    assert{@layout.getApp}
+    @layout.loadXML(loadFile(&quot;data/gui/layout/ant_layout.xml&quot;))
+  
 
-		# init pointers to different displays
-		# statusBar (FPS display)
-		@statusBar=@layout.getChild(&quot;statusBar&quot;)
-		@inventory=@layout.getChild(&quot;inventory&quot;)
-		@buttonpanel=@layout.getChild(&quot;antButtonPanel&quot;)
+    # init pointers to different displays
+    # statusBar (FPS display)
+    @statusBar=@layout.getChild(&quot;statusBar&quot;)
+    @inventory=@layout.getChild(&quot;inventory&quot;)
+    @buttonpanel=@layout.getChild(&quot;antButtonPanel&quot;)
 
-		@miniMap=@layout.getChild(&quot;miniMap&quot;)
-		@fps=0
+    @miniMap=@layout.getChild(&quot;miniMap&quot;)
+    @fps=0
 
-		setMainWidget(@layout)
-		addHandler(@layout.getChild(&quot;quit&quot;),:sigClick,:eventQuit)
-		addHandler(@layout.getChild(&quot;pause&quot;),:sigClick,:eventPause)
-		addHandler(@layout.getChild(&quot;options&quot;),:sigClick,:eventOptions)
+    setMainWidget(@layout)
+    addHandler(@layout.getChild(&quot;quit&quot;),:sigClick,:eventQuit)
+    addHandler(@layout.getChild(&quot;pause&quot;),:sigClick,:eventPause)
+    addHandler(@layout.getChild(&quot;options&quot;),:sigClick,:eventOptions)
 
-		if loadscreen
-			loadscreen.setValue(0.5)
-			loadscreen.tick
-		end
-	
-		if @miniMap
-			# connect MiniMap with Map for displaying terrain and entities
-			@miniMap.setMap(@map)
-			# connect MiniMap with Scene for displaying frustrum
-			@miniMap.setScene(getScene)
-		end
+    if loadscreen
+      loadscreen.setValue(0.5)
+      loadscreen.tick
+    end
+  
+    if @miniMap
+      # connect MiniMap with Map for displaying terrain and entities
+      @miniMap.setMap(@map)
+      # connect MiniMap with Scene for displaying frustrum
+      @miniMap.setScene(getScene)
+    end
 
-		if loadscreen
-			loadscreen.setValue(0.8)
-			loadscreen.tick()
-		end
-		
-		if savegameText &amp;&amp; savegameText.length&gt;0
-			# load a level
-			@map.loadMapFromMemory(savegameText)
-		end	
+    if loadscreen
+      loadscreen.setValue(0.8)
+      loadscreen.tick()
+    end
+    
+    if savegameText &amp;&amp; savegameText.length&gt;0
+      # load a level
+      @map.loadMapFromMemory(savegameText)
+    end  
 
-		if loadscreen
-			loadscreen.setValue(0.95)
-			loadscreen.tick
-		end
+    if loadscreen
+      loadscreen.setValue(0.95)
+      loadscreen.tick
+    end
 
-		# inventory and buttonpanel signals
-		addHandler(@inventory,:sigJobChanged,:eventInventoryJob)
-		addHandler(@buttonpanel,:sigJobChanged,:eventHeroJob)
+    # inventory and buttonpanel signals
+    addHandler(@inventory,:sigJobChanged,:eventInventoryJob)
+    addHandler(@buttonpanel,:sigJobChanged,:eventHeroJob)
 
-		setupHeroDisplay(true)
+    setupHeroDisplay(true)
 
-		# infobox is used for display a text &quot;Your hero 'xy' suffers&quot;
-		@infobox=nil
+    # infobox is used for display a text &quot;Your hero 'xy' suffers&quot;
+    @infobox=nil
 
-		# frame counting
-		@frameCount=0
-		@elapsTime=0
+    # frame counting
+    @frameCount=0
+    @elapsTime=0
+    
+    addHandler(@miniMap,:sigMoved,:eventMinimapMoved)
 
-		#setCursor(getTextureCache.get(&quot;blue_cursor.png&quot;))
-	end
+    #setCursor(getTextureCache.get(&quot;blue_cursor.png&quot;))
+  end
 
-	####################################
-	# EVENT HANDLERS
-	####################################
+  ####################################
+  # EVENT HANDLERS
+  ####################################
 
-	include AntMyEventHandler
+  include AntMyEventHandler
 
+  def eventMinimapMoved(e)
+    setCamera(@miniMap.getMapPosition)
+    true
+  end
 
-	# this handler is for the buttonpanel on the top
-	# the actions are direct ones, like rest,dimiss and so, which don't need an object to use (like fighting,taking,...)
-	def eventHeroJob(e)
-		case @buttonpanel.job
-			when &quot;doDismiss&quot;
-				# opens a query dialog &quot;do really want to do this?&quot;, that is given a block, that's executed on confirmation
-				@layout.addChild(AntQueryDialog.new(@layout,nil) {@hero.newHLDismissJob})
-			when &quot;doRest&quot;
-				if @hero
-					@hero.newHLRestJob(10)
-				end
-			when &quot;doBuild&quot;
-				@job=&quot;doBuild&quot;
-		end
-		return true
-	end
+  # this handler is for the buttonpanel on the top
+  # the actions are direct ones, like rest,dimiss and so, which don't need an object to use (like fighting,taking,...)
+  def eventHeroJob(e)
+    case @buttonpanel.job
+      when &quot;doDismiss&quot;
+        # opens a query dialog &quot;do really want to do this?&quot;, that is given a block, that's executed on confirmation
+        @layout.addChild(AntQueryDialog.new(@layout,nil) {@hero.newHLDismissJob})
+      when &quot;doRest&quot;
+        if @hero
+          @hero.newHLRestJob(10)
+        end
+      when &quot;doBuild&quot;
+        @job=&quot;doBuild&quot;
+    end
+    return true
+  end
 
-	# react to inventory-based jobs - like taking, recruiting
+  # react to inventory-based jobs - like taking, recruiting
 
-	def eventInventoryJob(e)
-		if @target.nil? #some more overview as
-			log &quot;NO TARGET SELECTED&quot;
-		else
-			case @inventory.job
-				when &quot;doRecruit&quot;
-					@hero.newHLRecruitJob(@target)
-				when &quot;doTakeFood&quot;
-					@hero.newHLTakeFoodJob(@target)
-				when &quot;doTakeWeapons&quot;
-					@hero.newHLTakeWeaponJob(@target)
-				when &quot;doConstruct&quot;
-					@hero.newHLConstructJob(@target)
-				when &quot;doUpgrade&quot;
-					@hero.upgradeMan(@target)
-				when &quot;doContinue&quot;
-					@hero.newHLBuildJob(@target,nil)
-				when &quot;doSupport&quot;
-					targetsTarget=nil
-					if @target.getJob.is_a?(AntHeroFightJob)
-						targetsTarget=@target.getJob.target
-					end
-					if targetsTarget
-						@hero.newHLFightJob(targetsTarget)
-					end
-			end
-		end
-		return true
-	end
+  def eventInventoryJob(e)
+    if @target.nil? #some more overview as
+      log &quot;NO TARGET SELECTED&quot;
+    else
+      case @inventory.job
+        when &quot;doRecruit&quot;
+          @hero.newHLRecruitJob(@target)
+        when &quot;doTakeFood&quot;
+          @hero.newHLTakeFoodJob(@target)
+        when &quot;doTakeWeapons&quot;
+          @hero.newHLTakeWeaponJob(@target)
+        when &quot;doConstruct&quot;
+          @hero.newHLConstructJob(@target)
+        when &quot;doUpgrade&quot;
+          @hero.upgradeMan(@target)
+        when &quot;doContinue&quot;
+          @hero.newHLBuildJob(@target,nil)
+        when &quot;doSupport&quot;
+          targetsTarget=nil
+          if @target.getJob.is_a?(AntHeroFightJob)
+            targetsTarget=@target.getJob.target
+          end
+          if targetsTarget
+            @hero.newHLFightJob(targetsTarget)
+          end
+      end
+    end
+    return true
+  end
 
-	def eventKeyDown(e)
+  def eventKeyDown(e)
 
-		# hero-selection by pressing F1 to F7
-		hero={	SDLK_F1=&gt;0,
-			SDLK_F2=&gt;1,
-			SDLK_F3=&gt;2,
-			SDLK_F4=&gt;3,
-			SDLK_F5=&gt;4,
-			SDLK_F6=&gt;5,
-			SDLK_F7=&gt;6}[e.getKey]
-		if hero
-			h=getHeroByNum(hero) 
-			if h
-				if @hero==h
-					focusHero(h)
-				end
-				selectHero(h)
-				return super(e)
-			end
-		end
+    # hero-selection by pressing F1 to F7
+    hero={  SDLK_F1=&gt;0,
+      SDLK_F2=&gt;1,
+      SDLK_F3=&gt;2,
+      SDLK_F4=&gt;3,
+      SDLK_F5=&gt;4,
+      SDLK_F6=&gt;5,
+      SDLK_F7=&gt;6}[e.getKey]
+    if hero
+      h=getHeroByNum(hero) 
+      if h
+        if @hero==h
+          focusHero(h)
+        end
+        selectHero(h)
+        return super(e)
+      end
+    end
 
-		
-		case e.getKey
-			when SDLK_F9 # F9 toggles panel on the right
-				if not panelVisible
-					showPanel
-				else
-					hidePanel
-				end
-			when SDLK_F8
-				@sceneEnabled=(not @sceneEnabled)
-				getScene.setEnabled(@sceneEnabled)
-			when SDLK_F1
-				hero=1
-			when SDLK_ESCAPE
-				if @hero
-					@hero.newHLRestJob(10)
-				end
-			when SDLK_PLUS
-				@speed=[@speed+1,10].min
-			when SDLK_MINUS
-				@speed=[@speed-1,0.2].max
-			
-			when SDLK_p
-				eventPause(nil)
-		end
-		return super(e)
-	end
-	
-	def eventStoryTalkFinished
-		showPanel
-		getMap.trigger(nil,Trigger.new(&quot;storyFinished&quot;))
-	end
+    
+    case e.getKey
+      when SDLK_F9 # F9 toggles panel on the right
+        if not panelVisible
+          showPanel
+        else
+          hidePanel
+        end
+      when SDLK_F8
+        @sceneEnabled=(not @sceneEnabled)
+        getScene.setEnabled(@sceneEnabled)
+      when SDLK_F1
+        hero=1
+      when SDLK_ESCAPE
+        if @hero
+          @hero.newHLRestJob(10)
+        end
+      when SDLK_PLUS
+        @speed=[@speed+1,10].min
+      when SDLK_MINUS
+        @speed=[@speed-1,0.2].max
+      
+      when SDLK_p
+        eventPause(nil)
+    end
+    return super(e)
+  end
+  
+  def eventStoryTalkFinished
+    showPanel
+    getMap.trigger(nil,Trigger.new(&quot;storyFinished&quot;))
+  end
 
-	def moveMap(time)
-		granularity=0.2
-		while time&gt;granularity
-			getMap().move(granularity)
-			time-=granularity
-		end
-		getMap().move(time)
-	end
+  def moveMap(time)
+    granularity=0.2
+    while time&gt;granularity
+      getMap().move(granularity)
+      time-=granularity
+    end
+    getMap().move(time)
+  end
 
-	def eventFrame(time)
-		super(time)
+  def eventFrame(time)
+    super(time)
 
-		# FPS display
-		if @frameCount&gt;14 then
-			@fps=@frameCount / @elapsTime
-			fps=&quot;&quot;
-			if @fps&lt;10
-				fps=sprintf(&quot;%3.2f&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at fps</A>)
-			else
-				fps=sprintf(&quot;%3.0f&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at fps</A>)
-			end
-			@statusBar.setText(_(&quot;FPS:{1}&quot;,fps.to_s))
-			@frameCount=0
-			@elapsTime=0
-			startGC
-		end
-		@frameCount+=1
-		@elapsTime+=time
+    # FPS display
+    if @frameCount&gt;14 then
+      @fps=@frameCount / @elapsTime
+      fps=&quot;&quot;
+      if @fps&lt;10
+        fps=sprintf(&quot;%3.2f&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at fps</A>)
+      else
+        fps=sprintf(&quot;%3.0f&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at fps</A>)
+      end
+      @statusBar.setText(_(&quot;FPS:{1}&quot;,fps.to_s))
+      @frameCount=0
+      @elapsTime=0
+      startGC
+    end
+    @frameCount+=1
+    @elapsTime+=time
 
 
- 		# move entities in game-engine
-		moveMap(time*@speed)
+     # move entities in game-engine
+    moveMap(time*@speed)
 
-		# advance animations
-		getScene.advance(time)
-		checkHeroEnergy
+    # advance animations
+    getScene.advance(time)
+    checkHeroEnergy
 
-		processMessages
+    processMessages
 
-		# save some CPU-power, if available
-		if @connection
-			delay(20)
-		end
+    # save some CPU-power, if available
+    if @connection
+      delay(20)
+    end
 
-		if @fps&gt;25 and isRunning
-			delay(5)
-		end
-		return true
-	end
-	
-	def eventQuit(e)
-		@layout.addChild(AntQuitDialog.new(@layout))
-		return true
-	end
-	def eventPause(e)
-		if not getMap().pause then
-			@layout.addChild(AntPauseDialog.new(@layout))
-		else
-			getMap.pause=false
-		end
-		return true
-	end
-	def eventOptions(e)
-		@layout.addChild(AntOptionsDialog.new(@layout))
-		return true
-	end
-	def eventHeroButton(e)
-		c=e.getCaller.getName
-		num=c[4..4]
-		name=@layout.getChild(&quot;HeroName#{num}&quot;).getText.to_s
-		ent=getMap.getByName(name)
-		selectHero(ent)
-		if ent==@inspect
-			focusHero(ent)
-		end
-		inspectEntity(ent)
-		return true
+    if @fps&gt;25 and isRunning
+      delay(5)
+    end
+    return true
+  end
+  
+  def eventQuit(e)
+    @layout.addChild(AntQuitDialog.new(@layout))
+    return true
+  end
+  def eventPause(e)
+    if not getMap().pause then
+      @layout.addChild(AntPauseDialog.new(@layout))
+    else
+      getMap.pause=false
+    end
+    return true
+  end
+  def eventOptions(e)
+    @layout.addChild(AntOptionsDialog.new(@layout))
+    return true
+  end
+  def eventHeroButton(e)
+    c=e.getCaller.getName
+    num=c[4..4]
+    name=@layout.getChild(&quot;HeroName#{num}&quot;).getText.to_s
+    ent=getMap.getByName(name)
+    selectHero(ent)
+    if ent==@inspect
+      focusHero(ent)
+    end
+    inspectEntity(ent)
+    return true
 
-	end
+  end
 
-	def eventAggressionChanged(e)
-		h=getSelectedHero
-		if h
-			h.setAggression(@buttonpanel.getAggression)
-		end
-		return true
-	end
+  def eventAggressionChanged(e)
+    h=getSelectedHero
+    if h
+      h.setAggression(@buttonpanel.getAggression)
+    end
+    return true
+  end
 
-	def eventEntitiesClicked(list,button)
-		resetJob
-		# find first entity that's nearest to the camera
-		ent=nil
-		list.each{|node|
-			mesh=node.node
-			if [Mesh,AnimMesh,Mesh2D].member?(mesh.class)
-				ent=getMap.getEntity(mesh)
-				break if ent
-			end
-		}
+  def eventEntitiesClicked(list,button)
+    resetJob
+    # find first entity that's nearest to the camera
+    ent=nil
+    list.each{|node|
+      mesh=node.node
+      if [Mesh,AnimMesh,Mesh2D].member?(mesh.class)
+        ent=getMap.getEntity(mesh)
+        break if ent
+      end
+    }
 
-		# if an entity was found - set new target
-		if ent
-			if ent.class==AntHero and ent.getPlayer==getMap.getPlayer
-				#@hero=ent
-				@target=ent
-				inspectEntity(ent)
-			else
-				@target=ent
-				inspectEntity(ent)
-			end
-		end
+    # if an entity was found - set new target
+    if ent
+      if ent.class==AntHero and ent.getPlayer==getMap.getPlayer
+        #@hero=ent
+        @target=ent
+        inspectEntity(ent)
+      else
+        @target=ent
+        inspectEntity(ent)
+      end
+    end
 
-		if button==1
-			# left button == select
-		elsif button==3
-			# right button == fight or goto
-			if ent==@target
-				if @target.is_a?(AntBoss)
-					if @target.getPlayer!=@hero.getPlayer
-						@hero.newHLFightJob(@target)
-						return
-					end
-				elsif @target.is_a?(AntAnimal)
-					@hero.newHLFightAnimalJob(@target)
-					return
-				end
-				# move near target
-				@hero.newHLMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,2)
-			end
-		end
-	end
+    if button==1
+      # left button == select
+    elsif button==3
+      # right button == fight or goto
+      if ent==@target
+        if @target.is_a?(AntBoss)
+          if @target.getPlayer!=@hero.getPlayer
+            @hero.newHLFightJob(@target)
+            return
+          end
+        elsif @target.is_a?(AntAnimal)
+          @hero.newHLFightAnimalJob(@target)
+          return
+        end
+        # move near target
+        @hero.newHLMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,2)
+      end
+    end
+  end
 
-	def eventMapClicked(pos,button)
-		if @job and button==1 then
-			case @job
-				when &quot;doBuild&quot;
-					buildHouse(pos.dim2)
-					@job=nil
-			end
-			resetJob
-			return
-		end
-		if @hero and button==3 then
-			# assign hero a move job
-			@hero.newHLMoveJob(0,pos,0)
-		end
-	end
+  def eventMapClicked(pos,button)
+    if @job and button==1 then
+      case @job
+        when &quot;doBuild&quot;
+          buildHouse(pos.dim2)
+          @job=nil
+      end
+      resetJob
+      return
+    end
+    if @hero and button==3 then
+      # assign hero a move job
+      @hero.newHLMoveJob(0,pos,0)
+    end
+  end
 
 
-	###############################
-	# simple functions
-	###############################
+  ###############################
+  # simple functions
+  ###############################
 
-	def getMap
-		@map
-	end
+  def getMap
+    @map
+  end
 
-	def processMessages
-		if @connection
-			while message=@connection.getMessage
-				@map.processMessage(message)
-			end
-		end
-	end
+  def processMessages
+    if @connection
+      while message=@connection.getMessage
+        @map.processMessage(message)
+      end
+    end
+  end
 
-	def buildHouse(pos)
-		@layout.addChild(AntBuildDialog.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">layout,pos, at hero</A>))
-	end
-	
-	def save
-		if $campaign
-			@layout.addChild(AntSaveCampaignDialog.new(@layout))
-		else
-			@layout.addChild(AntSaveDialog.new(@layout))
-		end
-	end
-	def load
-		@layout.addChild(AntLoadDialog.new(@layout))
-	end
-	def videoOptions
-		@layout.addChild(AntVideoOptionsDialog.new(@layout))
-	end
-	def audioOptions
-		@layout.addChild(AntAudioOptionsDialog.new(@layout))
-	end
+  def buildHouse(pos)
+    @layout.addChild(AntBuildDialog.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">layout,pos, at hero</A>))
+  end
+  
+  def save
+    if $campaign
+      @layout.addChild(AntSaveCampaignDialog.new(@layout))
+    else
+      @layout.addChild(AntSaveDialog.new(@layout))
+    end
+  end
+  def load
+    @layout.addChild(AntLoadDialog.new(@layout))
+  end
+  def videoOptions
+    @layout.addChild(AntVideoOptionsDialog.new(@layout))
+  end
+  def audioOptions
+    @layout.addChild(AntAudioOptionsDialog.new(@layout))
+  end
 
-	###############################################################
-	# Setting up of Hero displays (images, texts and eventHandlers
-	###############################################################
+  ###############################################################
+  # Setting up of Hero displays (images, texts and eventHandlers
+  ###############################################################
 
-	def setHeroImage(image,num)
-		@layout.getChild(&quot;HeroImage#{num}&quot;).setTexture(image)
-	end
-	def setHeroName(name,num)
-		@layout.getChild(&quot;HeroName#{num}&quot;).setText(_(name))
-		c=@layout.getChild(&quot;HeroBar#{num}&quot;)
-		raise 1 if c.nil?
-		c.setVisible((name!=&quot;&quot;))
-	end
-	def setHeroEnergy(hero,num)
-		@layout.getChild(&quot;HeroBar#{num}&quot;).setHero(hero)
-	end
-	def setHero(flag,num)
-		name=&quot;hero#{num}&quot;
-		c=@layout.getChild(name)
-		c.setEnabled(flag)
-		c.setVisible(flag)
-	end
-	def setupHeroDisplay(first=false)
-		#super
-		# setup Hero buttons
-		hs=getMap.getPlayer.getHeroes
-		for i in 0..5
-			if hs.length&gt;i
-				setHero(true,i)
-				setHeroName(hs[i].getName,i)
-				setHeroImage(hs[i].getImage,i)
-				setHeroEnergy(hs[i],i)
-			else
-				setHero(false,i)
-				setHeroImage(getTextureCache.get(&quot;data/gui/portraits/none.png&quot;),i)
-				setHeroName(&quot;&quot;,i)
-			end
-		end
-		# init Handlers of Buttons
-		if first
-			addHandler(@layout.getChild(&quot;antButtonPanel&quot;),:sigAggressionChanged,:eventAggressionChanged)
-			for i in 0..2
-				addHandler(@layout.getChild(&quot;hero#{i}&quot;),:sigClick,:eventHeroButton)
-			end
-			setupNames
-			
-			# center hero and select
-	 		if hs.length&gt;0
-	 			h=hs[0]
-	 			selectHero(h)
- 				focusHero(h)
-				@layout.getChild(&quot;hero0&quot;).setChecked(true)
- 			end
-			
-		end
-		checkHeroEnergy
-	end
+  def setHeroImage(image,num)
+    @layout.getChild(&quot;HeroImage#{num}&quot;).setTexture(image)
+  end
+  def setHeroName(name,num)
+    @layout.getChild(&quot;HeroName#{num}&quot;).setText(_(name))
+    c=@layout.getChild(&quot;HeroBar#{num}&quot;)
+    raise 1 if c.nil?
+    c.setVisible((name!=&quot;&quot;))
+  end
+  def setHeroEnergy(hero,num)
+    @layout.getChild(&quot;HeroBar#{num}&quot;).setHero(hero)
+  end
+  def setHero(flag,num)
+    name=&quot;hero#{num}&quot;
+    c=@layout.getChild(name)
+    c.setEnabled(flag)
+    c.setVisible(flag)
+  end
+  def setupHeroDisplay(first=false)
+    #super
+    # setup Hero buttons
+    hs=getMap.getPlayer.getHeroes
+    for i in 0..5
+      if hs.length&gt;i
+        setHero(true,i)
+        setHeroName(hs[i].getName,i)
+        setHeroImage(hs[i].getImage,i)
+        setHeroEnergy(hs[i],i)
+      else
+        setHero(false,i)
+        setHeroImage(getTextureCache.get(&quot;data/gui/portraits/none.png&quot;),i)
+        setHeroName(&quot;&quot;,i)
+      end
+    end
+    # init Handlers of Buttons
+    if first
+      addHandler(@layout.getChild(&quot;antButtonPanel&quot;),:sigAggressionChanged,:eventAggressionChanged)
+      for i in 0..2
+        addHandler(@layout.getChild(&quot;hero#{i}&quot;),:sigClick,:eventHeroButton)
+      end
+      setupNames
+      
+      # center hero and select
+       if hs.length&gt;0
+         h=hs[0]
+         selectHero(h)
+         focusHero(h)
+        @layout.getChild(&quot;hero0&quot;).setChecked(true)
+       end
+      
+    end
+    checkHeroEnergy
+  end
 
-	# updates the energy displays of the heroes (if needed)
-	def checkHeroEnergy
-		name=nil
-		# FIXME: support more than 1 hero !
-		getMap.getPlayer.getHeroes.each{|h|
-			if h.getEnergy&lt;0.3
-				name=h.getName
-			end
-		}
-		if @infobox.nil? and name
-			@layout.addChild(@infobox=AntInfoBox.new(@layout,_(&quot;Your hero {1} suffers.&quot;,name)))
-		elsif @infobox and name.nil?
-			@infobox.close
-			@infobox=nil
-		end
-	end
+  # updates the energy displays of the heroes (if needed)
+  def checkHeroEnergy
+    name=nil
+    # FIXME: support more than 1 hero !
+    getMap.getPlayer.getHeroes.each{|h|
+      if h.getEnergy&lt;0.3
+        name=h.getName
+      end
+    }
+    if @infobox.nil? and name
+      @layout.addChild(@infobox=AntInfoBox.new(@layout,_(&quot;Your hero {1} suffers.&quot;,name)))
+    elsif @infobox and name.nil?
+      @infobox.close
+      @infobox=nil
+    end
+  end
 
-	# sets a new result
-	def setResult(r)
-		@result=r
-	end
-	
-	# returns boolean about the visibility of the panel
-	def panelVisible
-		@layout.getChild(&quot;SideBar&quot;).visible
-	end
+  # sets a new result
+  def setResult(r)
+    @result=r
+  end
+  
+  # returns boolean about the visibility of the panel
+  def panelVisible
+    @layout.getChild(&quot;SideBar&quot;).visible
+  end
 
-	def showPanel
-		sideBar=@layout.getChild(&quot;SideBar&quot;)
-		sideBarRight=@layout.getChild(&quot;SideBarRight&quot;)
-		sideBar.show
-		@controls=true
-		# reset Scene's width
-		getScene.getCameraObject.setWidth((getScreen.getWidth-sideBarRight.width).to_i)
-	end
-	def hidePanel
-		@layout.getChild(&quot;SideBar&quot;).hide
-		@controls=false
-		# reset Scene's width
-		getScene.getCameraObject.setWidth(getScreen.getWidth)
-	end
+  def showPanel
+    sideBar=@layout.getChild(&quot;SideBar&quot;)
+    sideBarRight=@layout.getChild(&quot;SideBarRight&quot;)
+    sideBar.show
+    @controls=true
+    # reset Scene's width
+    getScene.getCameraObject.setWidth((getScreen.getWidth-sideBarRight.width).to_i)
+  end
+  def hidePanel
+    @layout.getChild(&quot;SideBar&quot;).hide
+    @controls=false
+    # reset Scene's width
+    getScene.getCameraObject.setWidth(getScreen.getWidth)
+  end
 
 
-	def tellStory(flow)
-		getMap.pause=true
-		hidePanel
-		if @story.nil?
-			@story=AntStoryTalk.new(@layout)
-		end
-		@layout.addChild(@story)
-		assert{@story.getApp}
-		@story.show
-		@story.setFlow(flow)
-		addHandler(@story,:sigStoryFinished,:eventStoryTalkFinished)
-	end
+  def tellStory(flow)
+    getMap.pause=true
+    hidePanel
+    if @story.nil?
+      @story=AntStoryTalk.new(@layout)
+    end
+    @layout.addChild(@story)
+    assert{@story.getApp}
+    @story.show
+    @story.setFlow(flow)
+    addHandler(@story,:sigStoryFinished,:eventStoryTalkFinished)
+  end
 
-	def inspectEntity(e)
-		if @inspect
-			#if @inspect.is_a?(AntBoss)
-				@inspect.selected=false
-			#end
-		end
-		@inspect=e
-		if @inspect
-			#if @inspect.is_a?(AntBoss)
-				@inspect.selected=true
-			#end
-		end
-		AntInventory.inspectEntity(e)
-	end
+  def inspectEntity(e)
+    if @inspect
+      #if @inspect.is_a?(AntBoss)
+        @inspect.selected=false
+      #end
+    end
+    @inspect=e
+    if @inspect
+      #if @inspect.is_a?(AntBoss)
+        @inspect.selected=true
+      #end
+    end
+    AntInventory.inspectEntity(e)
+  end
 
-	def resetJob
-		#@job=nil
-		@layout.getChild(&quot;doBuild&quot;).setChecked(false)
-	end
+  def resetJob
+    #@job=nil
+    @layout.getChild(&quot;doBuild&quot;).setChecked(false)
+  end
 
-	def getSelectedHero
-		@hero
-	end
+  def getSelectedHero
+    @hero
+  end
 
-	def selectHero(h)
-		@hero=h
-		inspectEntity(h)
-		@buttonpanel.setHero(h)
+  def selectHero(h)
+    @hero=h
+    inspectEntity(h)
+    @buttonpanel.setHero(h)
 
-		for i in 0..2
-			if @layout.getChild(&quot;HeroName#{i}&quot;).getText.to_s==h.getName
-				@layout.getChild(&quot;hero#{i}&quot;).setChecked(true)
-			end
-		end
+    for i in 0..2
+      if @layout.getChild(&quot;HeroName#{i}&quot;).getText.to_s==h.getName
+        @layout.getChild(&quot;hero#{i}&quot;).setChecked(true)
+      end
+    end
 
-		# set hero's aggression
-		@buttonpanel.setAggression(@hero.getAggression)
-	end
+    # set hero's aggression
+    @buttonpanel.setAggression(@hero.getAggression)
+  end
 
-	def getHeroByNum(n)
-		getMap.getOwnHeroes[n]
-	end
+  def getHeroByNum(n)
+    getMap.getOwnHeroes[n]
+  end
 
-	# views an information window about the entity ent
-	def viewInformation(ent)
-		win=AntInspectWindow.new(@layout,ent)
-		@layout.addChild(win)
-	end
+  # views an information window about the entity ent
+  def viewInformation(ent)
+    win=AntInspectWindow.new(@layout,ent)
+    @layout.addChild(win)
+  end
 
 end
 
@@ -640,23 +646,23 @@
 # you can start BoA from the cli by giving a level-name directly
 # For more information on that topic please refer to link:files/ruby/debugging/README.html
 def startGame(file=&quot;savegames/savegame0.antlvl&quot;,clientConnection=nil)
-	app=nil
-	if clientConnection
-		app=AntGameApp.new(file,getVideo.width,getVideo.height,nil,clientConnection)
-	else
-		app=AntGameApp.new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
-	end
-	#app.disableGC
-	app.run
-	result=app.result
-	# result all globals
-	app=nil
-	$map=nil
-	$app=nil
-	$screen=nil
-	# run garbage collector
-	startGC
-	return result
+  app=nil
+  if clientConnection
+    app=AntGameApp.new(file,getVideo.width,getVideo.height,nil,clientConnection)
+  else
+    app=AntGameApp.new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
+  end
+  #app.disableGC
+  app.run
+  result=app.result
+  # result all globals
+  app=nil
+  $map=nil
+  $app=nil
+  $screen=nil
+  # run garbage collector
+  startGC
+  return result
 end
 
 

Modified: antargis/trunk/ruby/editor/campaign/drag_grid.rb
===================================================================
--- antargis/trunk/ruby/editor/campaign/drag_grid.rb	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ruby/editor/campaign/drag_grid.rb	2008-05-26 18:22:36 UTC (rev 1255)
@@ -4,7 +4,7 @@
 # TODO:
 # * put all draggable-objects within context of DragEnvironemt
 
-setDebugLevel(0)
+#setDebugLevel(0)
 
 module Arrows
   def createArrowPolies(from,to,width)

Modified: antargis/trunk/ruby/spec/spec_game_gui.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_game_gui.rb	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ruby/spec/spec_game_gui.rb	2008-05-26 18:22:36 UTC (rev 1255)
@@ -1,15 +1,16 @@
-#if false
 
 require 'ruby/spec/level_testing.rb'
 
+if false
+
 describe &quot;Aggression buttons&quot; do
-	include LevelTesting
-	before(:all) do
-	  getTestApp(:tutorial0)
-	end
-	it &quot;should not call pp&quot; do
-		lambda {widget(&quot;doAgg0&quot;).click}.should_not cross(:pp)
-	end
+  include LevelTesting
+  before(:all) do
+    getTestApp(:tutorial0)
+  end
+  it &quot;should not call pp&quot; do
+    lambda {widget(&quot;doAgg0&quot;).click}.should_not cross(:pp)
+  end
 end
 
 describe &quot;Gui-Selecting&quot; do
@@ -19,56 +20,56 @@
       waitForStory
       clickAwayStory
     end
-	
-	it &quot;should be possible to select tower&quot; do
-		tower=entities(AntTower)[0]
-		lambda{tower.click}.should change(tower,:selected)
-	end
-	
+  
+  it &quot;should be possible to select tower&quot; do
+    tower=entities(AntTower)[0]
+    lambda{tower.click}.should change(tower,:selected)
+  end
+  
 end
 
 describe &quot;Building with gui interaction&quot; do
     include LevelTesting
     before(:all) do
       getTestApp(:tutorial3)
-	  waitForStory
-	  clickAwayStory
+    waitForStory
+    clickAwayStory
     end
-	it &quot;should start at all&quot; do
-		widget(&quot;doBuild&quot;).click
-		advance
-		clickMap(hero(&quot;Rowen&quot;).getPos2D+AGVector2.new(-5,10))
+  it &quot;should start at all&quot; do
+    widget(&quot;doBuild&quot;).click
+    advance
+    clickMap(hero(&quot;Rowen&quot;).getPos2D+AGVector2.new(-5,10))
         widget(&quot;AntTower&quot;).should be_a_kind_of(AGButton)
         widget(&quot;AntTower&quot;).click
-		hero(&quot;Rowen&quot;).getJob.should be_a_kind_of(AntHeroBuildJob)
-		advance(15)
-		map.getByType(AntBuildingSite).should have(1).item
-	end
-	it &quot;should be possible to stop and rest&quot; do
-		widget(&quot;doRest&quot;).click
+    hero(&quot;Rowen&quot;).getJob.should be_a_kind_of(AntHeroBuildJob)
+    advance(15)
+    map.getByType(AntBuildingSite).should have(1).item
+  end
+  it &quot;should be possible to stop and rest&quot; do
+    widget(&quot;doRest&quot;).click
         hero(&quot;Rowen&quot;).getJob.should_not be_a_kind_of(AntHeroBuildJob)
         hero(&quot;Rowen&quot;).getJob.should be_a_kind_of(AntHeroRestJob)
-	end
-	it &quot;should be possible to continue building a tower&quot; do
-		site=entities(AntBuildingSite)[0]
-		lambda{site.click}.should change(site,:selected)
-		widget(&quot;doContinue&quot;).click
-		hero(&quot;Rowen&quot;).getJob.should be_a_kind_of(AntHeroBuildJob)
-		advance(100)
+  end
+  it &quot;should be possible to continue building a tower&quot; do
+    site=entities(AntBuildingSite)[0]
+    lambda{site.click}.should change(site,:selected)
+    widget(&quot;doContinue&quot;).click
+    hero(&quot;Rowen&quot;).getJob.should be_a_kind_of(AntHeroBuildJob)
+    advance(100)
         hero(&quot;Rowen&quot;).getJob.should be_a_kind_of(AntHeroRestJob)
-		entities(AntBuildingSite).should have(0).items
-		entities(AntTower).should have(1).item
-		entities(AntTower)[0].getPlayer.should == hero(&quot;Rowen&quot;).getPlayer
+    entities(AntBuildingSite).should have(0).items
+    entities(AntTower).should have(1).item
+    entities(AntTower)[0].getPlayer.should == hero(&quot;Rowen&quot;).getPlayer
 
-	end
-	
-	it &quot;toggling fullscreen should'nt destroy anim-meshes&quot;
+  end
+  
+  it &quot;toggling fullscreen should'nt destroy anim-meshes&quot;
 end
 
 describe AntNameDisplay do
-	it &quot;should display a red text for enemies&quot;
-	it &quot;should display a yellow text for friends&quot;
-	it &quot;should switch text color when enemy is pwned&quot;
+  it &quot;should display a red text for enemies&quot;
+  it &quot;should display a yellow text for friends&quot;
+  it &quot;should switch text color when enemy is pwned&quot;
 end
 
 describe AntInfoBox do
@@ -79,15 +80,39 @@
       clickAwayStory
     end
 
-	it &quot;should be displayed when hero is badly hurt&quot; do
-	   widget(&quot;InfoBox&quot;).should be_nil#
-	   hero(&quot;Rowen&quot;).decEnergy(0.9)
-	   advance
+  it &quot;should be displayed when hero is badly hurt&quot; do
+     widget(&quot;InfoBox&quot;).should be_nil#
+     hero(&quot;Rowen&quot;).decEnergy(0.9)
+     advance
        widget(&quot;InfoBox&quot;).should_not be_nil
        widget(&quot;InfoBox&quot;).should be_visible
-	end
+  end
 end
 
+end
 
+describe &quot;Minimap&quot; do
+  include LevelTesting
+  before(:all) do
+    getTestApp(:tutorial0)
+    waitForStory
+    clickAwayStory
+  end
+  
+  it &quot;should be connected to the mainview&quot; do
+    curpos=@app.getScene.getCamera
+    curpos.should be_a_kind_of(AGVector4)
+    
+    newpos=@app.getScene.getCamera
+    newpos.should == curpos
+    
+    minimap=widget(&quot;miniMap&quot;)
+    minimap.should_not be_nil
+    #@app.step while true
+    click(minimap.getScreenRect.getMiddle+AGVector2.new(10,10))
+    newpos=@app.getScene.getCamera
+    newpos.should be_a_kind_of(AGVector4)
+    newpos.should_not == curpos
+  end
+end
 
-#end
\ No newline at end of file

Added: antargis/trunk/ruby/spec/spec_math.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_math.rb	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ruby/spec/spec_math.rb	2008-05-26 18:22:36 UTC (rev 1255)
@@ -0,0 +1,42 @@
+require 'ruby/spec_helper.rb'
+
+describe &quot;Determinant&quot; do
+  def makeQuadMatrix(*s)
+    len=s.length
+    w=Math::sqrt(len)
+    case w
+      when 3
+        m=AGMatrix3.new
+      when 4
+        m=AGMatrix4.new
+      else
+        m=AGMatrixN.new(w,w)
+    end
+    0.upto(w-1) {|x|
+      0.upto(w-1) {|y|
+        m.set(x,y,s[x+y*w])
+      }
+    }   
+    m
+  end
+  it &quot;should return 0 if matrix is lin.dep&quot; do
+    m=makeQuadMatrix(1,0,0,1,1,0,0,1,0)
+    determinantAGMatrix3(m).should == 0
+  end
+  
+  it &quot;should work on a 3-dim matrix&quot; do
+    m=AGMatrix3.new
+    m.set(0,0,2)
+    m.set(1,0,1)
+    m.set(2,0,1)
+    m.set(0,1,1)
+    m.set(1,1,2)
+    m.set(2,1,1)
+    m.set(0,2,1)
+    m.set(1,2,1)
+    m.set(2,2,2)
+    result=determinantAGMatrix3(m)
+    p result
+    result.should&gt;0
+  end
+end
\ No newline at end of file

Modified: antargis/trunk/ruby/spec/spec_mouseevents.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_mouseevents.rb	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ruby/spec/spec_mouseevents.rb	2008-05-26 18:22:36 UTC (rev 1255)
@@ -69,9 +69,7 @@
     
   end
   
-  it &quot;shuold handle dragging correctly&quot; do
-    @app.step while true
-  end
+  it &quot;shuold handle dragging correctly&quot;
 end
 
 describe &quot;MouseEvents on complex widgets (with scaling and hiding)&quot; do

Modified: antargis/trunk/ruby/spec_helper.rb
===================================================================
--- antargis/trunk/ruby/spec_helper.rb	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ruby/spec_helper.rb	2008-05-26 18:22:36 UTC (rev 1255)
@@ -3,7 +3,7 @@
 require 'pp'
 require 'ruby/antargislib.rb'
 
-setDebugLevel(0)
+#setDebugLevel(0)
 
 #if Object.respond_to?(:define_cmethod)
 	

Modified: antargis/trunk/ruby/view.rb
===================================================================
--- antargis/trunk/ruby/view.rb	2008-05-23 16:06:42 UTC (rev 1254)
+++ antargis/trunk/ruby/view.rb	2008-05-26 18:22:36 UTC (rev 1255)
@@ -33,10 +33,10 @@
 require 'ant_name_display.rb'
 
 if (not MyAntargislib.opengl)
-	require 'two_d_app.rb'
+  require 'two_d_app.rb'
 else
-	class AntBaseMapView&lt;GLApp
-	end
+  class AntBaseMapView&lt;GLApp
+  end
 end
 
 
@@ -46,161 +46,161 @@
 # * FIXME
 #
 class AntRubyView &lt;AntBaseMapView
-	def initialize(w,h)
-		super(w,h)
-		@mousepos=AGVector2.new(200,200)
-		@controls=true
-	end
+  def initialize(w,h)
+    super(w,h)
+    @mousepos=AGVector2.new(200,200)
+    @controls=true
+  end
 
-	def prepareDraw
-		updateNamePositions
-		super
-	end
-	def updateNamePositions
-		heroes=@map.getHeroes
-		@names.each{|k,w|
-			found=false
-			heroes.each{|hero|
-				if hero.getName==w.getText
-					w.setRect(getHeroScreenPos(hero))
-					found=true
-				end
-			}
-			if (not found)
-				w.hide
-			end
-		}
-	end
-	
-	def getHeroScreenPos(hero)
-		pos=hero.getPos3D+AGVector3.new(0,0,2)
-		sp=getScene.getPosition(AGVector4.new(pos,1))
-		return AGRect.new(sp.x-50,sp.y-55,100,27)
-	end
+  def prepareDraw
+    updateNamePositions
+    super
+  end
+  def updateNamePositions
+    heroes=@map.getHeroes
+    @names.each{|k,w|
+      found=false
+      heroes.each{|hero|
+        if hero.getName==w.getText
+          w.setRect(getHeroScreenPos(hero))
+          found=true
+        end
+      }
+      if (not found)
+        w.hide
+      end
+    }
+  end
+  
+  def getHeroScreenPos(hero)
+    pos=hero.getPos3D+AGVector3.new(0,0,2)
+    sp=getScene.getPosition(AGVector4.new(pos,1))
+    return AGRect.new(sp.x-50,sp.y-55,100,27)
+  end
 
-	def focusHero(hero)
-		setCamera(hero.getPos2D)
-	end
-	
-	def setupNames
-		heroes=@map.getHeroes
-		@names||={}
-		heroes.each{|hero|
-			name=hero.getName
-			#FIXME: readd this
-			if @names[hero].nil?
-				n=AntNameDisplay.new(@layout,getHeroScreenPos(hero)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">,hero, at map</A>)
-				@names[hero]=n
-				@layout.addChild(n)
-			end
-		}
-	end
+  def focusHero(hero)
+    setCamera(hero.getPos2D)
+  end
+  
+  def setupNames
+    heroes=@map.getHeroes
+    @names||={}
+    heroes.each{|hero|
+      name=hero.getName
+      #FIXME: readd this
+      if @names[hero].nil?
+        n=AntNameDisplay.new(@layout,getHeroScreenPos(hero)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">,hero, at map</A>)
+        @names[hero]=n
+        @layout.addChild(n)
+      end
+    }
+  end
 
-	def eventHover(list,button)
-		if list.length&gt;0
-			n=list[0]
-			mesh=n.node
-			ok=false
-			if mesh.class==Mesh or mesh.class==AnimMesh
-				ent=getMap.getEntity(mesh)
-				if ent
-					#if ent.is_a?(AntBoss) then
-						hoverEntity(ent)
-						ok=true
-					#end
-				end
-			end
-			if not ok
-				hoverEntity(nil)
-			end
-		end
-		return true
-	end
-	
-	def eventClick(list,button)
-		if (not @controls)
-			log &quot;CONTROLS DISABLED&quot;
-			return false
-		end
-		if list.length&gt;0
-			first=list[0]
-			if [TerrainPiece,WaterPiece,Terrain2DTile].member?(first.node.class)
-				eventMapClicked(first.pos,button)
-			else
-				eventEntitiesClicked(list,button)
-			end
-		end
-		return true
-	end
-	
-	def hoverEntity(e)
-		if @hover
-			#if @hover.class==AntHero or @hover.is_a?(AntHouse)
-				@hover.hovered=false
-			#end
-		end
-		@hover=e
-		if @hover
-			#if @hover.class==AntHero or @hover.is_a?(AntHouse)
-				@hover.hovered=true
-			#end
-		end
-	end
-	
-	def setCamera(p)
-		x=super(clipCamera(p))
-		AntSound.updateSoundPos(getScene)
-		x
-	end
-	def getCameraHeight(p)
-		# take some middle
-		h=0
-		(-1..1).each{|x|
-			(-1..1).each{|y|
-				h+=getMap.getHeight(p[0]+x,p[1]+y)
-			}
-		}
-		h/=9
-		h=[0,h].max
-		return h
-	end
+  def eventHover(list,button)
+    if list.length&gt;0
+      n=list[0]
+      mesh=n.node
+      ok=false
+      if mesh.class==Mesh or mesh.class==AnimMesh
+        ent=getMap.getEntity(mesh)
+        if ent
+          #if ent.is_a?(AntBoss) then
+            hoverEntity(ent)
+            ok=true
+          #end
+        end
+      end
+      if not ok
+        hoverEntity(nil)
+      end
+    end
+    return true
+  end
+  
+  def eventClick(list,button)
+    if (not @controls)
+      log &quot;CONTROLS DISABLED&quot;
+      return false
+    end
+    if list.length&gt;0
+      first=list[0]
+      if [TerrainPiece,WaterPiece,Terrain2DTile].member?(first.node.class)
+        eventMapClicked(first.pos,button)
+      else
+        eventEntitiesClicked(list,button)
+      end
+    end
+    return true
+  end
+  
+  def hoverEntity(e)
+    if @hover
+      #if @hover.class==AntHero or @hover.is_a?(AntHouse)
+        @hover.hovered=false
+      #end
+    end
+    @hover=e
+    if @hover
+      #if @hover.class==AntHero or @hover.is_a?(AntHouse)
+        @hover.hovered=true
+      #end
+    end
+  end
+  
+  def setCamera(p)
+    x=super(clipCamera(p))
+    AntSound.updateSoundPos(getScene)
+    x
+  end
+  def getCameraHeight(p)
+    # take some middle
+    h=0
+    (-1..1).each{|x|
+      (-1..1).each{|y|
+        h+=getMap.getHeight(p[0]+x,p[1]+y)
+      }
+    }
+    h/=9
+    h=[0,h].max
+    return h
+  end
 
-	def clipCamera(p)
-		AGVector2.new([31,p[0],getMap.getW-31].sort[1],[14,p[1],getMap.getH-36].sort[1])
-	end
-	def eventMouseMotion(e)
-		super
-		@mousepos=e.getMousePosition
-		return true
-	end
-	def checkMove(t)
-		if getVideo.fullscreen
-			p=@mousepos
-			m=0
-			w=20
-			s=10
-			{AGRect.new(0,m,w,getMain.getVideo.height-m*2)=&gt;AGVector2.new(-1,0),
-				AGRect.new(m,0,getMain.getVideo.width-m*2,w)=&gt;AGVector2.new(0,1),
-				AGRect.new(getMain.getVideo.width-w-1,m,w,getMain.getVideo.height-m*2)=&gt;AGVector2.new(1,0),
-				AGRect.new(m,getMain.getVideo.height-w-1,getMain.getVideo.width-m*2,w)=&gt;AGVector2.new(0,-1)}.each{|r,n|
-				if r.contains(p)
-					setCamera(getCamera+n*t*s) # FIXME: Include time
-				end
-			}
-		end
-	end
-	def eventFrame(t)
-		super
-		checkMove(t)
-		return true
-	end
+  def clipCamera(p)
+    AGVector2.new([31,p[0],getMap.getW-31].sort[1],[14,p[1],getMap.getH-36].sort[1])
+  end
+  def eventMouseMotion(e)
+    super
+    @mousepos=e.getMousePosition
+    return true
+  end
+  def checkMove(t)
+    if getVideo.fullscreen
+      p=@mousepos
+      m=0
+      w=20
+      s=10
+      {AGRect.new(0,m,w,getMain.getVideo.height-m*2)=&gt;AGVector2.new(-1,0),
+        AGRect.new(m,0,getMain.getVideo.width-m*2,w)=&gt;AGVector2.new(0,1),
+        AGRect.new(getMain.getVideo.width-w-1,m,w,getMain.getVideo.height-m*2)=&gt;AGVector2.new(1,0),
+        AGRect.new(m,getMain.getVideo.height-w-1,getMain.getVideo.width-m*2,w)=&gt;AGVector2.new(0,-1)}.each{|r,n|
+        if r.contains(p)
+          setCamera(getCamera+n*t*s) # FIXME: Include time
+        end
+      }
+    end
+  end
+  def eventFrame(t)
+    super
+    checkMove(t)
+    return true
+  end
 end
 
 # View-Widget factory
 class AntRubyViewCreator&lt;AGLayoutCreator
-	def create(parent,rect,node)
-		setResult AntRubyView.new(parent,rect,AGVector3.new(0,0,0),nil)
-	end
+  def create(parent,rect,node)
+    setResult AntRubyView.new(parent,rect,AGVector3.new(0,0,0),nil)
+  end
 end
 getLayoutFactory.addCreator(&quot;antRubyView&quot;,AntRubyViewCreator.new)
 
@@ -210,9 +210,9 @@
 
 
 class AntInfoBox&lt;AGLayout
-	def initialize(p,n)
-		super(p)
-		loadXML(loadFile(&quot;data/gui/layout/infobox.xml&quot;))
-		getChild(&quot;infotext&quot;).setText(_(n))
-	end
+  def initialize(p,n)
+    super(p)
+    loadXML(loadFile(&quot;data/gui/layout/infobox.xml&quot;))
+    getChild(&quot;infotext&quot;).setText(_(n))
+  end
 end
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000210.html">[Antargis-svn] r1254 - antargis/trunk/ext/math
</A></li>
	<LI>Next message: <A HREF="000212.html">[Antargis-svn] r1256 - in antargis/trunk: . ext/basic ext/game	rookey/cpp ruby ruby/jobs ruby/spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#211">[ date ]</a>
              <a href="thread.html#211">[ thread ]</a>
              <a href="subject.html#211">[ subject ]</a>
              <a href="author.html#211">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/antargis-svn">More information about the Antargis-svn
mailing list</a><br>
</body></html>
