<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Antargis-svn] r1248 - in antargis/trunk: . ext/game ext/gui	ext/video ruby ruby/editor/campaign ruby/spec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/antargis-svn/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1248%20-%20in%20antargis/trunk%3A%20.%20ext/game%20ext/gui%0A%09ext/video%20ruby%20ruby/editor/campaign%20ruby/spec&In-Reply-To=%3C200805191828.m4JISesw019241%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000203.html">
   <LINK REL="Next"  HREF="000205.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Antargis-svn] r1248 - in antargis/trunk: . ext/game ext/gui	ext/video ruby ruby/editor/campaign ruby/spec</H1>
    <B>davidkamphausen at BerliOS</B> 
    <A HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1248%20-%20in%20antargis/trunk%3A%20.%20ext/game%20ext/gui%0A%09ext/video%20ruby%20ruby/editor/campaign%20ruby/spec&In-Reply-To=%3C200805191828.m4JISesw019241%40sheep.berlios.de%3E"
       TITLE="[Antargis-svn] r1248 - in antargis/trunk: . ext/game ext/gui	ext/video ruby ruby/editor/campaign ruby/spec">davidkamphausen at mail.berlios.de
       </A><BR>
    <I>Mon May 19 20:28:40 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000203.html">[Antargis-svn] r1247 - in antargis/trunk: . ext/basic	rookey/configs ruby/spec
</A></li>
        <LI>Next message: <A HREF="000205.html">[Antargis-svn] r1249 - antargis/trunk/ruby/spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#204">[ date ]</a>
              <a href="thread.html#204">[ thread ]</a>
              <a href="subject.html#204">[ subject ]</a>
              <a href="author.html#204">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: davidkamphausen
Date: 2008-05-19 20:28:37 +0200 (Mon, 19 May 2008)
New Revision: 1248

Added:
   antargis/trunk/ruby/spec/spec_minimap.rb
Modified:
   antargis/trunk/.project
   antargis/trunk/ext/game/minimap.cc
   antargis/trunk/ext/game/minimap.h
   antargis/trunk/ext/gui/ag_application.cc
   antargis/trunk/ext/gui/ag_application.h
   antargis/trunk/ext/gui/ag_combo.cc
   antargis/trunk/ext/gui/ag_widget.cc
   antargis/trunk/ext/video/ag_glscreen.cc
   antargis/trunk/ext/video/ag_glscreen.h
   antargis/trunk/ext/video/ag_gltexture.cc
   antargis/trunk/ext/video/ag_gltexture.h
   antargis/trunk/ext/video/ag_rendercontext.cc
   antargis/trunk/ext/video/ag_screen.cc
   antargis/trunk/ext/video/ag_screen.h
   antargis/trunk/ext/video/ag_sdlscreen.cc
   antargis/trunk/ext/video/ag_sdlscreen.h
   antargis/trunk/ext/video/ag_sdlsurface.h
   antargis/trunk/ext/video/ag_texture.cc
   antargis/trunk/ext/video/ag_texture.h
   antargis/trunk/ext/video/ag_video.cc
   antargis/trunk/ruby/dialogs.rb
   antargis/trunk/ruby/editor/campaign/spec_campaign_editor.rb
   antargis/trunk/ruby/spec/spec_scrollingwidget.rb
   antargis/trunk/ruby/spec_helper.rb
Log:
Incomplete - task 5: Rectangular Textures 
<A HREF="http://localhost:3000/issues/show/5">http://localhost:3000/issues/show/5</A>

Modified: antargis/trunk/.project
===================================================================
--- antargis/trunk/.project	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/.project	2008-05-19 18:28:37 UTC (rev 1248)
@@ -14,27 +14,31 @@
 					&lt;value&gt;all&lt;/value&gt;
 				&lt;/dictionary&gt;
 				&lt;dictionary&gt;
-					&lt;key&gt;?name?&lt;/key&gt;
-					&lt;value&gt;&lt;/value&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.buildLocation&lt;/key&gt;
+					&lt;value&gt;${workspace_loc:/antargis}&lt;/value&gt;
 				&lt;/dictionary&gt;
 				&lt;dictionary&gt;
 					&lt;key&gt;org.eclipse.cdt.make.core.enableAutoBuild&lt;/key&gt;
 					&lt;value&gt;false&lt;/value&gt;
 				&lt;/dictionary&gt;
 				&lt;dictionary&gt;
-					&lt;key&gt;org.eclipse.cdt.make.core.buildLocation&lt;/key&gt;
-					&lt;value&gt;${workspace_loc:/antargis}&lt;/value&gt;
+					&lt;key&gt;?name?&lt;/key&gt;
+					&lt;value&gt;&lt;/value&gt;
 				&lt;/dictionary&gt;
 				&lt;dictionary&gt;
+					&lt;key&gt;?children?&lt;/key&gt;
+					&lt;value&gt;?name?=outputEntries\|?children?=?name?=entry\\\\\\\\\\\\\\\|\\\\\\\|\||&lt;/value&gt;
+				&lt;/dictionary&gt;
+				&lt;dictionary&gt;
 					&lt;key&gt;org.eclipse.cdt.make.core.enableFullBuild&lt;/key&gt;
 					&lt;value&gt;true&lt;/value&gt;
 				&lt;/dictionary&gt;
 				&lt;dictionary&gt;
-					&lt;key&gt;?children?&lt;/key&gt;
-					&lt;value&gt;?name?=outputEntries\|?children?=?name?=entry\\\\\\\\\\\\\\\|\\\\\\\|\||&lt;/value&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.enableCleanBuild&lt;/key&gt;
+					&lt;value&gt;true&lt;/value&gt;
 				&lt;/dictionary&gt;
 				&lt;dictionary&gt;
-					&lt;key&gt;org.eclipse.cdt.make.core.enableCleanBuild&lt;/key&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.append_environment&lt;/key&gt;
 					&lt;value&gt;true&lt;/value&gt;
 				&lt;/dictionary&gt;
 				&lt;dictionary&gt;
@@ -42,10 +46,6 @@
 					&lt;value&gt;clean&lt;/value&gt;
 				&lt;/dictionary&gt;
 				&lt;dictionary&gt;
-					&lt;key&gt;org.eclipse.cdt.make.core.append_environment&lt;/key&gt;
-					&lt;value&gt;true&lt;/value&gt;
-				&lt;/dictionary&gt;
-				&lt;dictionary&gt;
 					&lt;key&gt;org.eclipse.cdt.make.core.contents&lt;/key&gt;
 					&lt;value&gt;org.eclipse.cdt.make.core.activeConfigSettings&lt;/value&gt;
 				&lt;/dictionary&gt;

Modified: antargis/trunk/ext/game/minimap.cc
===================================================================
--- antargis/trunk/ext/game/minimap.cc	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/game/minimap.cc	2008-05-19 18:28:37 UTC (rev 1248)
@@ -295,18 +295,28 @@
 
     v=toMapCoords(v);
 
+    mPos=v;
+    sigMoved(m);
+    /*
     //  mScene-&gt;setCamera(AGVector4(v[0],v[1],0,0));
-    AGApplication *app=getApplication();
+    AGApplication *app=getApp();
+    assert(app);
     if(app)
       {
         GLApp *glapp=dynamic_cast&lt;GLApp*&gt;(app);
         if(glapp)
           glapp-&gt;setCamera(v);
       }
-
+*/
     return true;
   }
 
+AGVector2 MiniMap::getMapPosition() const
+{
+	return mPos;
+}
+
+
 AGVector2 MiniMap::toMapCoords(AGVector2 v) const
 {
   AGRect2 r=getRect();

Modified: antargis/trunk/ext/game/minimap.h
===================================================================
--- antargis/trunk/ext/game/minimap.h	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/game/minimap.h	2008-05-19 18:28:37 UTC (rev 1248)
@@ -40,6 +40,10 @@
 
   virtual bool eventMouseClick(AGEvent *m);
   virtual bool eventMouseButtonDown(AGEvent *m);
+  
+  AGSignal sigMoved;
+  
+  AGVector2 getMapPosition() const;
 
  private:
   // adds some fancy noise to the map display
@@ -57,6 +61,8 @@
   SceneBase *mScene;
   AGTexture *mTexture;
   AGSurface mSurface;
+  
+  AGVector2 mPos;
 };
 
 //MiniMap *toMiniMap(AGWidget *w);

Modified: antargis/trunk/ext/gui/ag_application.cc
===================================================================
--- antargis/trunk/ext/gui/ag_application.cc	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/gui/ag_application.cc	2008-05-19 18:28:37 UTC (rev 1248)
@@ -38,15 +38,15 @@
     SDL_EnableKeyRepeat(0, 0);
   }
 
-AGApplication *gApplication=0;
+//AGApplication *gApplication=0;
 
 AGVector2 gAppCursorPos;
-
+/*
 AGApplication *getApplication()
   {
     return gApplication;
   }
-
+*/
 AGApplication::AGApplication() :
   mRunning(true), mIdleCalls(true), mainWidget(0), mTooltip(0), mOverlay(0)
   {
@@ -63,6 +63,8 @@
 AGApplication::~AGApplication()
   {
     CTRACE;
+    if(mainWidget)
+    	mainWidget-&gt;setApp(0);
     delete mCursor;
   }
 
@@ -77,6 +79,7 @@
 void AGApplication::setMainWidget(AGWidget *w)
   {
     mainWidget=w;
+    mainWidget-&gt;setApp(this);
     setOverlay(0);
     if (w)
       w-&gt;redraw();
@@ -104,7 +107,7 @@
     float t;
     mRunning=true;
 
-    gApplication=this;
+    //gApplication=this;
 
     flushEventQueue();
     last=now=SDL_GetTicks();
@@ -115,7 +118,7 @@
       {
         STACKTRACE;
 
-        gApplication=this;
+        //gApplication=this;
 
           {
             // event handling
@@ -206,7 +209,7 @@
         loopCount++;
         //      dbout(2,&quot;Running:&quot;&lt;&lt;mRunning);
       }
-    gApplication=0;
+    //gApplication=0;
 
     return true;
   }
@@ -241,6 +244,7 @@
 bool AGApplication::doEvent(const SDL_Event &amp;event)
   {
     STACKTRACE;
+    CTRACE;
     SDL_Event e;
 
     // eat up old mouse motion events

Modified: antargis/trunk/ext/gui/ag_application.h
===================================================================
--- antargis/trunk/ext/gui/ag_application.h	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/gui/ag_application.h	2008-05-19 18:28:37 UTC (rev 1248)
@@ -163,7 +163,7 @@
    So it will be correct after finishing a frame, when you are
    using nested AGApplications.
 */
-AGEXPORT AGApplication *getApplication(); // returns current active application
+//AGEXPORT AGApplication *getApplication(); // returns current active application
 
 AGEXPORT void disableKeyrepeat();
 

Modified: antargis/trunk/ext/gui/ag_combo.cc
===================================================================
--- antargis/trunk/ext/gui/ag_combo.cc	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/gui/ag_combo.cc	2008-05-19 18:28:37 UTC (rev 1248)
@@ -96,7 +96,7 @@
     if(ops.size()&gt;0)
       mListBox-&gt;selectItem(mID);
 
-    getApplication()-&gt;setOverlay(mListBox);
+    getApp()-&gt;setOverlay(mListBox);
     return true;
   }
 
@@ -105,7 +105,7 @@
     CTRACE;
     mID=mListBox-&gt;getSelectedID();
     update();
-    getApplication()-&gt;setOverlay(0);
+    getApp()-&gt;setOverlay(0);
 
     sigSelect(new AGEvent(this,&quot;sigSelect&quot;));
     return true;

Modified: antargis/trunk/ext/gui/ag_widget.cc
===================================================================
--- antargis/trunk/ext/gui/ag_widget.cc	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/gui/ag_widget.cc	2008-05-19 18:28:37 UTC (rev 1248)
@@ -305,7 +305,7 @@
     if(mTooltip.length())
       {
         mTooltipWidget=new AGTooltip(getScreenRect(),mTooltip);
-        getApplication()-&gt;setTooltip(mTooltipWidget);
+        getApp()-&gt;setTooltip(mTooltipWidget);
       }
 
     return false;
@@ -314,7 +314,7 @@
   {
     if(mTooltipWidget)
       {
-        getApplication()-&gt;resetTooltip(mTooltipWidget);
+        getApp()-&gt;resetTooltip(mTooltipWidget);
         mTooltipWidget=0;
       }
     return false;
@@ -387,8 +387,17 @@
             if(was)
               {
                 e-&gt;setName(&quot;sigClick&quot;);
-                if(!isParent(getApplication()-&gt;getOverlay()))
-                  getApplication()-&gt;setOverlay(0);
+                AGApplication *app=getApp();
+                assert(app);
+                if(app)
+                  {
+                    AGWidget *overlay=getApp()-&gt;getOverlay();
+                    //if(overlay)
+                      if(!isParent(overlay))
+                        app-&gt;setOverlay(0);
+                  }
+                if(!isParent(getApp()-&gt;getOverlay())) //FIXME: crashes here
+                  getApp()-&gt;setOverlay(0);
 
                 if(canFocus())
                   gainFocus();
@@ -1177,7 +1186,7 @@
 
 void AGWidget::setApp(AGApplication *pApp)
   {
-    assert(!mApp);
+    assert((!mApp)||mApp==pApp||(pApp==0));
     mApp=pApp;
   }
 
@@ -1193,3 +1202,4 @@
 {
   return getChildRect(pWidget-&gt;getRect()).contains(pVector);
 }
+

Modified: antargis/trunk/ext/video/ag_glscreen.cc
===================================================================
--- antargis/trunk/ext/video/ag_glscreen.cc	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/video/ag_glscreen.cc	2008-05-19 18:28:37 UTC (rev 1248)
@@ -118,41 +118,41 @@
 AGGLScreen::AGGLScreen(int W,int H,int VW,int VH):
   w(VW),h(VH),
   rw(W),rh(H)
-    {
-      if(w&lt;rw)
-        w=rw;
-      if(h&lt;rh)
-        h=rh;
+        {
+          if(w&lt;rw)
+            w=rw;
+          if(h&lt;rh)
+            h=rh;
 
-      mLineWidth=2;
+          mLineWidth=2;
 
-      cdebug(&quot;w:&quot;&lt;&lt;w&lt;&lt;&quot; h:&quot;&lt;&lt;h);
+          cdebug(&quot;w:&quot;&lt;&lt;w&lt;&lt;&quot; h:&quot;&lt;&lt;h);
 
-      // init GL
-      glEnable(GL_TEXTURE_2D);
-      glShadeModel(GL_SMOOTH);
-      glClearColor(0.0f,0.0f,0.0f,0.0f); // clear bgcolor
-      glClearDepth(1.0f);      // clear depth buffer
-      glEnable(GL_DEPTH_TEST); // enable depth test
-      glDepthFunc(GL_LEQUAL); // set type depth test
-      glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // GL_NICEST // best perspective correction
-      glEnable(GL_BLEND);
+          // init GL
+          glEnable(GL_TEXTURE_2D);
+          glShadeModel(GL_SMOOTH);
+          glClearColor(0.0f,0.0f,0.0f,0.0f); // clear bgcolor
+          glClearDepth(1.0f);      // clear depth buffer
+          glEnable(GL_DEPTH_TEST); // enable depth test
+          glDepthFunc(GL_LEQUAL); // set type depth test
+          glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // GL_NICEST // best perspective correction
+          glEnable(GL_BLEND);
 
-      glViewport( 0, 0, rw, rh );
-      glMatrixMode( GL_PROJECTION );
-      glLoadIdentity( );
+          glViewport( 0, 0, rw, rh );
+          glMatrixMode( GL_PROJECTION );
+          glLoadIdentity( );
 
-      GLfloat ratio;
+          GLfloat ratio;
 
-      ratio = ( float )w / ( float )h;
+          ratio = ( float )w / ( float )h;
 
-      //  gluPerspective( 45.0f, ratio, 1.0f, 100.0f );
+          //  gluPerspective( 45.0f, ratio, 1.0f, 100.0f );
 
-      gluOrtho2D(0,w,0,h);
+          gluOrtho2D(0,w,0,h);
 
-      glMatrixMode( GL_MODELVIEW );
-      glLoadIdentity( );
-    }
+          glMatrixMode( GL_MODELVIEW );
+          glLoadIdentity( );
+        }
 
 
 
@@ -161,14 +161,60 @@
   { 
   }
 
-AGSurface AGGLScreen::screenshot(bool frontBuffer)
+AGTexture AGGLScreen::screenshot(bool frontBuffer)
   {
+	assert(0);
+    AGTexture t(getWidth(),getHeight());
+    
+    AGGLTexture *glTexture=t.glTexture();
+    AGRenderContext c;
+    c.setTexture(glTexture);
+    c.begin();
+    
+    if(frontBuffer)
+      glReadBuffer(GL_FRONT_LEFT);
+    else
+      glReadBuffer(GL_BACK);
+
+    assertGL;
+    glTexParameteri(glTexture-&gt;getTarget(), 
+        GL_TEXTURE_STORAGE_HINT_APPLE, 
+        GL_STORAGE_CACHED_APPLE); 
+    assertGL;
+    glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE,GL_TRUE); 
+    assertGL;
+
+
+    glTexParameteri(glTexture-&gt;getTarget(),GL_TEXTURE_STORAGE_HINT_APPLE, GL_STORAGE_SHARED_APPLE); 
+    assertGL;
+    glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE,GL_TRUE); 
+
+    assertGL;
+    glReadBuffer(GL_FRONT_LEFT);
+    glFinish();
+    assertGL;
+    glCopyTexSubImage2D(glTexture-&gt;getTarget(), 
+    0,0,0,0,0,getWidth(),getHeight()); 
+    assertGL;
+    // Dootherworkprocessinghere,usingadoubleortriplebuffer 
+    glReadBuffer(GL_BACK);
+
+    
+    return t;
+  }
+
+AGSurface AGGLScreen::screenshotSurface(bool frontBuffer)
+  {
     AGSurface s(getWidth(),getHeight());
 
-    //  SDL_Surface *surface=s.surface()-&gt;surface;
+    size_t bufSize=getWidth()*getHeight()*4+16;
+    glFinish();
 
-    unsigned char *buffer=new unsigned char[getWidth()*getHeight()*4+16];
+    unsigned char *buffer=new unsigned char[bufSize];
 
+    for(size_t i=0;i&lt;bufSize;i++)
+      buffer[i]=0x13;
+
     if(frontBuffer)
       //  glReadBuffer(GL_FRONT);
       glReadBuffer(GL_FRONT_LEFT);
@@ -181,10 +227,6 @@
     glPixelStorei(GL_PACK_ALIGNMENT, 1);
     assertGL;
     glPixelStorei(GL_PACK_ROW_LENGTH, getWidth());
-    //                surface-&gt;pitch / surface-&gt;format-&gt;BytesPerPixel);
-
-    //glPixelStorei(GL_PACK_SKIP_PIXELS,0);
-    //glPixelStorei(GL_PACK_SKIP_ROWS,0);
     assertGL;
 
 
@@ -192,10 +234,28 @@
       TRACE;
       cdebug(getWidth());
       cdebug(getHeight());
+      glFinish();
       glReadPixels(0,0,getWidth(),getHeight(),GL_RGBA,GL_UNSIGNED_BYTE,buffer);//s.surface()-&gt;surface);
       glReadBuffer(GL_BACK);
     }
 
+    bool changed=false;
+    bool everything0=true;
+
+    for(size_t i=0;i&lt;bufSize;i++)
+      {
+        if(buffer[i]!=0x13)
+          changed=true;
+        if(buffer[i]!=0 &amp;&amp; buffer[i]!=0x13)
+          {
+            everything0=false;
+            //cdebug(i);
+          }
+      }
+
+    cdebug(&quot;Buffer was changed:&quot;&lt;&lt;(changed?&quot;yes&quot;:&quot;no&quot;));
+    cdebug(&quot;Everything zero:&quot;&lt;&lt;(everything0?&quot;yes&quot;:&quot;no&quot;));
+
     {
       // copy
       TRACE;
@@ -211,6 +271,9 @@
 
     assertGL;
     delete [] buffer;
+
+
+
     return s;
   }
 

Modified: antargis/trunk/ext/video/ag_glscreen.h
===================================================================
--- antargis/trunk/ext/video/ag_glscreen.h	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/video/ag_glscreen.h	2008-05-19 18:28:37 UTC (rev 1248)
@@ -81,7 +81,8 @@
 
   virtual void begin(); // call before start drawing
 
-  AGSurface screenshot(bool frontBuffer=true);
+  AGSurface screenshotSurface(bool frontBuffer=true);
+  AGTexture screenshot(bool frontBuffer=true);
 
   void flip();
   virtual void update(const std::list&lt;AGRect2&gt; &amp;rs); // call this instead of flip, if you want

Modified: antargis/trunk/ext/video/ag_gltexture.cc
===================================================================
--- antargis/trunk/ext/video/ag_gltexture.cc	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/video/ag_gltexture.cc	2008-05-19 18:28:37 UTC (rev 1248)
@@ -29,146 +29,263 @@
 //FIXME: this should be static
 size_t gUsedTexMemory=0;
 
+bool isPowerOf2(size_t value)
+{
+	while(value!=0)
+	{
+		cdebug(value);
+		if(value&amp;1)
+		{
+			if((value^1))
+				return false;
+			else
+				return true;
+		}
+		value&gt;&gt;=1;
 
-AGGLTexture::AGGLTexture(size_t W,size_t H,GLint format):w(W),h(H),d(1),m3d(false)
+	}
+	return true;
+}
+size_t nextPowerOf2(size_t value)
 {
-  assertGL;
-  getSurfaceManager()-&gt;registerMe(this);
-  assertGL;
-  glGenTextures( 1, &amp;mID);
-  assertGL;
-  glBindTexture( GL_TEXTURE_2D,mID);
-  assertGL;
+	TRACE;
+	size_t c=1;
+	while(c&lt;value)
+	{
+		cdebug(c&lt;&lt;&quot;;&quot;&lt;&lt;value);
+		c&lt;&lt;=1;
+	}
+	return c;
+}
 
-  glTexImage2D(GL_TEXTURE_2D, 0, format, w, h, 0, GL_RGBA,
-      GL_UNSIGNED_BYTE, 0);
 
-  assertGL;
-  gUsedTexMemory+=w*h*4;
+char *AGGLTexture::dmaBuffer=0;
 
-  dbout(4,&quot;used memory:&quot;&lt;&lt;gUsedTexMemory);
+AGGLTexture::AGGLTexture(size_t W,size_t H,GLint format):w(W),h(H),d(1),m3d(false),mRectTex(false),mTarget(GL_TEXTURE_2D)
+{
+	cdebug(&quot;HUPE&quot;);
+	initDMABuffer();
+	assertGL;
+	getSurfaceManager()-&gt;registerMe(this);
+	assertGL;
+	glGenTextures( 1, &amp;mID);
+	assertGL;
+	bool inited=false;
+	mTarget=GL_TEXTURE_2D;
 
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-  assertGL;
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-  assertGL;
+	cdebug(w&lt;&lt;&quot;:&quot;&lt;&lt;h);
+	if(!(isPowerOf2(w) &amp;&amp; isPowerOf2(h)))
+	{
+		cdebug(&quot;not power of 2&quot;);
+		if(GLEE_ARB_texture_rectangle &amp;&amp; false)
+		{
+			mTarget=GL_TEXTURE_RECTANGLE_ARB;
+		}
+		else
+		{
+			h=w=nextPowerOf2(std::max(w,h));
+		}
+	}
+	cdebug(&quot;1&quot;);
+	glEnable(mTarget);
+	cdebug(&quot;2&quot;);
+	glBindTexture( mTarget,mID);
+	assertGL;
+
+	size_t bufSize=w*h*4;
+	char *buffer=0;
+
+	if(false)
+	{
+		buffer=new char[bufSize];
+
+		assert(buffer);
+	}
+	cdebug(&quot;3&quot;);
+	if(buffer)
+		memset(buffer,0,bufSize);
+	cdebug(&quot;5&quot;);
+	cdebug(mTarget);
+	cdebug(format);
+	cdebug(&quot;rect:&quot;&lt;&lt;(mTarget==GL_TEXTURE_RECTANGLE_ARB));
+	cdebug(&quot;2d:&quot;&lt;&lt;(mTarget==GL_TEXTURE_2D));
+	cdebug(&quot;3d:&quot;&lt;&lt;(mTarget==GL_TEXTURE_3D));
+	cdebug(&quot;GL_RGBA:&quot;&lt;&lt;(format==GL_RGBA));
+	cdebug(&quot;w:&quot;&lt;&lt;w&lt;&lt;&quot; h:&quot;&lt;&lt;h);
+	cdebug(&quot;texmem:&quot;&lt;&lt;	gUsedTexMemory);
+	cdebug((void*)buffer);
+	assertGL;
+	glTexImage2D(mTarget, 0, format, w, h, 0, GL_RGBA,
+			GL_UNSIGNED_BYTE, buffer);
+	assertGL;
+	cdebug(&quot;6&quot;);
+
+	if(buffer)
+		delete [] buffer;
+
+	cdebug(&quot;7&quot;);
+	cdebug(&quot;W:&quot;&lt;&lt;w&lt;&lt;&quot; h:&quot;&lt;&lt;h);
+	assertGL;
+	gUsedTexMemory+=w*h*4;
+
+	cdebug(&quot;8&quot;);
+	dbout(4,&quot;used memory:&quot;&lt;&lt;gUsedTexMemory);
+
+	glTexParameteri(mTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+	assertGL;
+	glTexParameteri(mTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	assertGL;
+	cdebug(&quot;9&quot;);
 }
-AGGLTexture::AGGLTexture(size_t W,size_t H,size_t D,GLint format):w(W),h(H),d(D),m3d(true)
+AGGLTexture::AGGLTexture(size_t W,size_t H,size_t D,GLint format):w(W),h(H),d(D),m3d(true),mRectTex(false),mTarget(GL_TEXTURE_3D)
 {
-  assertGL;
-  getSurfaceManager()-&gt;registerMe(this);
-  assertGL;
+	assertGL;
+	getSurfaceManager()-&gt;registerMe(this);
+	assertGL;
 
-  glGenTextures( 1, &amp;mID);
-  assertGL;
-  glBindTexture( GL_TEXTURE_3D,mID);
-  assertGL;
+	glGenTextures( 1, &amp;mID);
+	assertGL;
+	glBindTexture( mTarget,mID);
+	assertGL;
 
-  //w=h=128;
-  //d=2;
+	glTexImage3D(mTarget, 0, format, w, h, d, 0, GL_RGBA,
+			GL_UNSIGNED_BYTE, 0);
+	assertGL;
 
-  glTexImage3D(GL_TEXTURE_3D, 0, format, w, h, d, 0, GL_RGBA,
-      GL_UNSIGNED_BYTE, 0);
-  assertGL;
+	gUsedTexMemory+=w*h*d*4;
+	dbout(4,&quot;used memory:&quot;&lt;&lt;gUsedTexMemory);
 
-  gUsedTexMemory+=w*h*d*4;
-  dbout(4,&quot;used memory:&quot;&lt;&lt;gUsedTexMemory);
-
-  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-  assertGL;
-  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-  assertGL;
+	glTexParameteri(mTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+	assertGL;
+	glTexParameteri(mTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	assertGL;
 }
 
 AGGLTexture::~AGGLTexture()
-  {
-    assertGL;
-    glDeleteTextures(1,&amp;mID);
+{
+	assertGL;
+	glDeleteTextures(1,&amp;mID);
 
-    if(m3d)
-      gUsedTexMemory-=w*h*d*4;
-    else
-      gUsedTexMemory-=w*h*4;
+	if(m3d)
+		gUsedTexMemory-=w*h*d*4;
+	else
+		gUsedTexMemory-=w*h*4;
 
-    assertGL;
-    getSurfaceManager()-&gt;deregisterMe(this);
-  }
+	assertGL;
+	getSurfaceManager()-&gt;deregisterMe(this);
+}
 
 void AGGLTexture::setSurface(AGInternalSurface *pSurface,const AGVector2 &amp;offset)
-  {
-    assertGL;
-    GLint format;
+{
+	assertGL;
+	GLint format;
 
-    SDL_Surface *surface=pSurface-&gt;surface;
+	SDL_Surface *surface=pSurface-&gt;surface;
 
-    switch(surface-&gt;format-&gt;BytesPerPixel)
-    {
-    case 3:
-      format = GL_RGB;break;
-    case 4:
-      format = GL_RGBA;break;
-    default:
-      throw std::runtime_error(&quot;Surface-format not supported for texturing!&quot;);
-    }
+	switch(surface-&gt;format-&gt;BytesPerPixel)
+	{
+	case 3:
+		format = GL_RGB;break;
+	case 4:
+		format = GL_RGBA;break;
+	default:
+		throw std::runtime_error(&quot;Surface-format not supported for texturing!&quot;);
+	}
 
-    AGRenderContext c;
-    c.setTexture(this);
-    c.begin();
-    assertGL;
+	AGRenderContext c;
+	c.setTexture(this);
+	c.begin();
+	assertGL;
 
 
-    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
-    assertGL;
-    glPixelStorei(GL_UNPACK_ROW_LENGTH,
-        surface-&gt;pitch / surface-&gt;format-&gt;BytesPerPixel);
+	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+	assertGL;
+	glPixelStorei(GL_UNPACK_ROW_LENGTH,
+			surface-&gt;pitch / surface-&gt;format-&gt;BytesPerPixel);
 
 
-    assertGL;
-    if(m3d)
-      {
-        assert(glIsEnabled(GL_TEXTURE_3D));
-        int mw=std::min(surface-&gt;w,surface-&gt;h);
-        int mh=std::max(surface-&gt;w,surface-&gt;h)/mw;
+	assertGL;
+	if(m3d)
+	{
+		assert(glIsEnabled(mTarget));
+		int mw=std::min(surface-&gt;w,surface-&gt;h);
+		int mh=std::max(surface-&gt;w,surface-&gt;h)/mw;
 
-        // FIXME: use glTexImage instead of glTexSubImage, because it makes problems
-        // on MacOSX 10.5.1 (at least on my macbook pro - godrin)
+		// FIXME: use glTexImage instead of glTexSubImage, because it makes problems
+		// on MacOSX 10.5.1 (at least on my macbook pro - godrin)
 
-        glTexImage3D(GL_TEXTURE_3D, 0, format, w, h, d, 0, GL_RGBA,
-            GL_UNSIGNED_BYTE, surface-&gt;pixels);
-        glTexSubImage3D(GL_TEXTURE_3D,0,int(offset[0]),int(offset[1]),0,
-            mw,mw,mh,format,GL_UNSIGNED_BYTE,surface-&gt;pixels);
-      }
-    else
-      {
-        assertGL;
+		glTexImage3D(mTarget, 0, format, w, h, d, 0, GL_RGBA,
+				GL_UNSIGNED_BYTE, surface-&gt;pixels);
+		glTexSubImage3D(mTarget,0,int(offset[0]),int(offset[1]),0,
+				mw,mw,mh,format,GL_UNSIGNED_BYTE,surface-&gt;pixels);
+	}
+	else
+	{
+		assertGL;
 
-        glTexSubImage2D(GL_TEXTURE_2D, 0, int(offset[0]), int(offset[1]),
-            surface-&gt;w, surface-&gt;h, format, GL_UNSIGNED_BYTE,
-            surface-&gt;pixels);
-      }
-    assertGL;
-    AGRenderContext().begin();
-  }
+		glTexSubImage2D(mTarget, 0, int(offset[0]), int(offset[1]),
+				surface-&gt;w, surface-&gt;h, format, GL_UNSIGNED_BYTE,
+				surface-&gt;pixels);
+	}
+	assertGL;
+	AGRenderContext().begin();
+}
 
 GLuint AGGLTexture::id()
-  {
+{
 
-    return mID;
-  }
+	return mID;
+}
 bool AGGLTexture::is3d() const
 {
-  return m3d;
+	return m3d;
 }
 
 size_t AGGLTexture::width() const
 {
-  return w;
+	return w;
 }
 size_t AGGLTexture::height() const
 {
-  return h;
+	return h;
 }
 size_t AGGLTexture::depth() const
 {
-  return d;
+	return d;
 }
+
+AGSurface AGGLTexture::getSurface() const
+{
+	AGSurface s(w,h*d);
+	size_t bufSize=width()*height()*4;
+	unsigned char *pixels=new unsigned char[bufSize];
+
+	glGetTexImage(mTarget,0,GL_RGBA, 
+			GL_UNSIGNED_INT_8_8_8_8_REV,pixels); 
+
+	{
+		// copy
+		TRACE;
+		int h=height()-1;
+		for(int x=0;x&lt;(int)width();x++)
+			for(int y=0;y&lt;(int)height();y++)
+			{
+				unsigned char*p=pixels+((x+(h-y)*width())*4);
+				AGColor c(p[0],p[1],p[2],p[3]);
+				s.putPixel(x,y,c);
+			}
+	}
+
+	return s;  
+}
+
+void AGGLTexture::initDMABuffer()
+{
+	return;
+	if(!dmaBuffer)
+	{
+		size_t texbufsize=1024*1024*64;
+		dmaBuffer=new char[texbufsize];
+		glTextureRangeAPPLE(GL_TEXTURE_2D,texbufsize,dmaBuffer); 
+	}
+}

Modified: antargis/trunk/ext/video/ag_gltexture.h
===================================================================
--- antargis/trunk/ext/video/ag_gltexture.h	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/video/ag_gltexture.h	2008-05-19 18:28:37 UTC (rev 1248)
@@ -32,10 +32,11 @@
    You shouldn't use it directly - all functionality is provided by AGTexture.
  */
 class AGEXPORT AGGLTexture
-{
- public:
+  {
+public:
   AGGLTexture(size_t W,size_t H,GLint format=GL_RGBA);
   AGGLTexture(size_t W,size_t H,size_t D,GLint format=GL_RGBA);
+
   ~AGGLTexture();
 
   void setSurface(AGInternalSurface *pSurface,const AGVector2 &amp;offset=AGVector2(0,0));
@@ -48,14 +49,29 @@
   size_t height() const;
   size_t depth() const;
 
- private:
+  AGSurface getSurface() const;
+  
+  GLenum getTarget() const
+  {
+    return mTarget;
+  }
+
+private:
+
+  void initDMABuffer();
   size_t w,h,d;
 
   /// is this a 3d-texture?
   bool m3d;
+  bool mRectTex;
+  GLenum mTarget;
 
   GLuint mID;
-};
 
+
+  static char *dmaBuffer;
+
+  };
+
 #endif
 

Modified: antargis/trunk/ext/video/ag_rendercontext.cc
===================================================================
--- antargis/trunk/ext/video/ag_rendercontext.cc	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/video/ag_rendercontext.cc	2008-05-19 18:28:37 UTC (rev 1248)
@@ -121,14 +121,14 @@
         if(mTexture-&gt;is3d())
           {
             glDisable(GL_TEXTURE_2D);
-            glEnable(GL_TEXTURE_3D);
-            glBindTexture(GL_TEXTURE_3D,mTexture-&gt;id());
+            glEnable(mTexture-&gt;getTarget());
+            glBindTexture(mTexture-&gt;getTarget(),mTexture-&gt;id());
           }
         else
           {
             glDisable(GL_TEXTURE_3D);
-            glEnable(GL_TEXTURE_2D);
-            glBindTexture(GL_TEXTURE_2D,mTexture-&gt;id());
+            glEnable(mTexture-&gt;getTarget());
+            glBindTexture(mTexture-&gt;getTarget(),mTexture-&gt;id());
           }
       }
     else

Modified: antargis/trunk/ext/video/ag_screen.cc
===================================================================
--- antargis/trunk/ext/video/ag_screen.cc	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/video/ag_screen.cc	2008-05-19 18:28:37 UTC (rev 1248)
@@ -21,6 +21,7 @@
 #include &quot;ag_screen.h&quot;
 #include &quot;ag_debug.h&quot;
 #include &quot;ag_surface.h&quot;
+#include &quot;ag_texture.h&quot;
 
 ////////////////////////////////////////////////////////////////////////
 // AGScreen
@@ -48,8 +49,13 @@
 }
 
 
-AGSurface AGScreen::screenshot(bool frontBuffer)
+AGSurface AGScreen::screenshotSurface(bool frontBuffer)
   {
     cdebug(&quot;NOT YET IMPLEMENTED&quot;);
     return AGSurface(0,0);
   }
+AGTexture AGScreen::screenshot(bool frontBuffer)
+  {
+    cdebug(&quot;NOT YET IMPLEMENTED&quot;);
+    return AGTexture(0,0);
+  }

Modified: antargis/trunk/ext/video/ag_screen.h
===================================================================
--- antargis/trunk/ext/video/ag_screen.h	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/video/ag_screen.h	2008-05-19 18:28:37 UTC (rev 1248)
@@ -40,7 +40,8 @@
   virtual size_t getWidth() const;
   virtual size_t getHeight() const;
 
-  virtual AGSurface screenshot(bool frontBuffer=true);
+  virtual AGSurface screenshotSurface(bool frontBuffer=true);
+  virtual AGTexture screenshot(bool frontBuffer=true);
 };
 
 AGEXPORT AGScreen &amp;getScreen();

Modified: antargis/trunk/ext/video/ag_sdlscreen.cc
===================================================================
--- antargis/trunk/ext/video/ag_sdlscreen.cc	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/video/ag_sdlscreen.cc	2008-05-19 18:28:37 UTC (rev 1248)
@@ -201,9 +201,15 @@
       }
   }
 
-AGSurface AGSDLScreen::screenshot(bool frontBuffer)
+AGSurface AGSDLScreen::screenshotSurface(bool frontBuffer)
   {
     AGInternalSurface *surface=new AGInternalSurface;
     surface-&gt;surface=s;
     return AGSurface(surface).copy();
   }
+AGTexture AGSDLScreen::screenshot(bool frontBuffer)
+  {
+    AGInternalSurface *surface=new AGInternalSurface;
+    surface-&gt;surface=s;
+    return AGTexture(AGSurface(surface).copy());
+  }

Modified: antargis/trunk/ext/video/ag_sdlscreen.h
===================================================================
--- antargis/trunk/ext/video/ag_sdlscreen.h	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/video/ag_sdlscreen.h	2008-05-19 18:28:37 UTC (rev 1248)
@@ -60,7 +60,8 @@
   virtual void clip(const AGRect2 &amp;r);
   virtual void unclip();
 
-  AGSurface screenshot(bool frontBuffer=true);
+  AGSurface screenshotSurface(bool frontBuffer=true);
+  AGTexture screenshot(bool frontBuffer=true);
 
  private:
   SDL_Surface *s;

Modified: antargis/trunk/ext/video/ag_sdlsurface.h
===================================================================
--- antargis/trunk/ext/video/ag_sdlsurface.h	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/video/ag_sdlsurface.h	2008-05-19 18:28:37 UTC (rev 1248)
@@ -60,7 +60,7 @@
   virtual void clip(const AGRect2 &amp;r);
   virtual void unclip();
 
-  AGSurface screenshot(bool frontBuffer=true);
+  AGSurface screenshotSurface(bool frontBuffer=true);
 
  private:
   SDL_Surface *s;

Modified: antargis/trunk/ext/video/ag_texture.cc
===================================================================
--- antargis/trunk/ext/video/ag_texture.cc	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/video/ag_texture.cc	2008-05-19 18:28:37 UTC (rev 1248)
@@ -103,17 +103,17 @@
   }
 
 AGTexture::AGTexture(int W,int H):w(W),h(H),s(0)
-{
-  m3d=0;
-  version=0;
-  mTexture=0;
-  mSDLTexture=0;
-  mTextureUsed=false;
-  mPainting=false;
-  getSurfaceManager()-&gt;registerMe(this);
-  mCleared=true;
-  mFBO=0;
-}
+  {
+    m3d=0;
+    version=0;
+    mTexture=0;
+    mSDLTexture=0;
+    mTextureUsed=false;
+    mPainting=false;
+    getSurfaceManager()-&gt;registerMe(this);
+    mCleared=true;
+    mFBO=0;
+  }
 
 
 
@@ -207,17 +207,21 @@
 AGGLTexture *AGTexture::glTexture()
   {
     assert(opengl());
+    cdebug(mTexture);
     if(mTexture==0)
       {
         if(s)
           if(s-&gt;glTexture &amp;&amp; version==s-&gt;version)
             mTexture=s-&gt;glTexture;
+        cdebug(mTexture);
         if(!mTexture)
           {
+            cdebug(m3d);
             if(m3d)
               mTexture=new AGGLTexture(nextpow2(std::min(w,h)),nextpow2(std::min(w,h)),nextpow2(std::max(w,h)/std::min(w,h)));
             else
               mTexture=new AGGLTexture(nextpow2(w),nextpow2(h));
+            cdebug(mTexture);
             if(s)
               {
                 mTexture-&gt;setSurface(s);
@@ -343,8 +347,6 @@
 
             glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 0, 0, mTexture-&gt;width(),mTexture-&gt;height(),0);
 
-            //            getScreen().flip();
-            //            SDL_Delay(1000);
             glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
           }
 
@@ -404,10 +406,6 @@
 
 void AGTexture::blit(const AGTexture &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc)
   {
-    //  if(gUsedTexMemory&gt;20000000)
-    //    throw int();
-
-
     if(opengl())
       {
         assert(mTexture);
@@ -587,3 +585,11 @@
   {
     mCleared=true;
   }
+
+
+AGSurface AGTexture::getSurface() const
+{
+  if(mTexture)
+    return mTexture-&gt;getSurface();
+  return AGSurface();
+}

Modified: antargis/trunk/ext/video/ag_texture.h
===================================================================
--- antargis/trunk/ext/video/ag_texture.h	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/video/ag_texture.h	2008-05-19 18:28:37 UTC (rev 1248)
@@ -88,6 +88,8 @@
   bool is3d() const;
 
   void clearContent();
+  
+  AGSurface getSurface() const;
 
  private:
 

Modified: antargis/trunk/ext/video/ag_video.cc
===================================================================
--- antargis/trunk/ext/video/ag_video.cc	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ext/video/ag_video.cc	2008-05-19 18:28:37 UTC (rev 1248)
@@ -84,6 +84,9 @@
 
     if(fs)
       videoFlags|=SDL_FULLSCREEN;
+    
+    if(gl)
+      videoFlags|=SDL_DOUBLEBUF;
 
 
     cdebug(&quot;SDL_Init...&quot;);

Modified: antargis/trunk/ruby/dialogs.rb
===================================================================
--- antargis/trunk/ruby/dialogs.rb	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ruby/dialogs.rb	2008-05-19 18:28:37 UTC (rev 1248)
@@ -239,7 +239,7 @@
 def takeScreenshot
 	$app.hidePanel
 	$app.draw
-	s=getScreen.screenshot
+	s=getScreen.screenshotSurface
 	$app.showPanel
 	s
 end

Modified: antargis/trunk/ruby/editor/campaign/spec_campaign_editor.rb
===================================================================
--- antargis/trunk/ruby/editor/campaign/spec_campaign_editor.rb	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ruby/editor/campaign/spec_campaign_editor.rb	2008-05-19 18:28:37 UTC (rev 1248)
@@ -1,4 +1,4 @@
-
+if false
 require File.join(File.split(__FILE__)[0],&quot;..&quot;,&quot;..&quot;,&quot;spec_helper.rb&quot;)
 require File.join(File.split(__FILE__)[0],&quot;..&quot;,&quot;..&quot;,&quot;gui&quot;,&quot;testing.rb&quot;)
 require File.join(File.split(__FILE__)[0],&quot;drag_grid.rb&quot;)
@@ -55,4 +55,6 @@
   def grid
     getWidget(&quot;dragGrid&quot;)
   end
+end
+
 end
\ No newline at end of file

Added: antargis/trunk/ruby/spec/spec_minimap.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_minimap.rb	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ruby/spec/spec_minimap.rb	2008-05-19 18:28:37 UTC (rev 1248)
@@ -0,0 +1,3 @@
+describe &quot;MiniMap&quot; do
+	it &quot;should move the main map when clicked into&quot;
+end
\ No newline at end of file

Modified: antargis/trunk/ruby/spec/spec_scrollingwidget.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_scrollingwidget.rb	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ruby/spec/spec_scrollingwidget.rb	2008-05-19 18:28:37 UTC (rev 1248)
@@ -1,5 +1,6 @@
 require 'ruby/gui/testing.rb'
 
+if false
 class MyTestApp&lt;AGApplication
   BIGRECT=AGRect2.new(0,0,200,200)
   SMALLRECT=AGRect2.new(0,0,100,100)
@@ -49,4 +50,5 @@
     
   end
   it &quot;shouldn't draw anything when the widget is scrolled to the right lower corner&quot;
+end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/spec_helper.rb
===================================================================
--- antargis/trunk/ruby/spec_helper.rb	2008-05-14 19:00:14 UTC (rev 1247)
+++ antargis/trunk/ruby/spec_helper.rb	2008-05-19 18:28:37 UTC (rev 1248)
@@ -3,6 +3,7 @@
 require 'pp'
 require 'ruby/antargislib.rb'
 
+setDebugLevel(0)
 
 #if Object.respond_to?(:define_cmethod)
 	


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000203.html">[Antargis-svn] r1247 - in antargis/trunk: . ext/basic	rookey/configs ruby/spec
</A></li>
	<LI>Next message: <A HREF="000205.html">[Antargis-svn] r1249 - antargis/trunk/ruby/spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#204">[ date ]</a>
              <a href="thread.html#204">[ thread ]</a>
              <a href="subject.html#204">[ subject ]</a>
              <a href="author.html#204">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/antargis-svn">More information about the Antargis-svn
mailing list</a><br>
</body></html>
