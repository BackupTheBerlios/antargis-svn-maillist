<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Antargis-svn] r1262 - in antargis/trunk: . ruby ruby/ai	ruby/ai/spec ruby/editor ruby/editor/campaign	ruby/editor/spec ruby/editor/test ruby/entities ruby/jobs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/antargis-svn/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1262%20-%20in%20antargis/trunk%3A%20.%20ruby%20ruby/ai%0A%09ruby/ai/spec%20ruby/editor%20ruby/editor/campaign%0A%09ruby/editor/spec%20ruby/editor/test%20ruby/entities%20ruby/jobs&In-Reply-To=%3C200805311324.m4VDOaC8019029%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000217.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Antargis-svn] r1262 - in antargis/trunk: . ruby ruby/ai	ruby/ai/spec ruby/editor ruby/editor/campaign	ruby/editor/spec ruby/editor/test ruby/entities ruby/jobs</H1>
    <B>davidkamphausen at BerliOS</B> 
    <A HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1262%20-%20in%20antargis/trunk%3A%20.%20ruby%20ruby/ai%0A%09ruby/ai/spec%20ruby/editor%20ruby/editor/campaign%0A%09ruby/editor/spec%20ruby/editor/test%20ruby/entities%20ruby/jobs&In-Reply-To=%3C200805311324.m4VDOaC8019029%40sheep.berlios.de%3E"
       TITLE="[Antargis-svn] r1262 - in antargis/trunk: . ruby ruby/ai	ruby/ai/spec ruby/editor ruby/editor/campaign	ruby/editor/spec ruby/editor/test ruby/entities ruby/jobs">davidkamphausen at mail.berlios.de
       </A><BR>
    <I>Sat May 31 15:24:36 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000217.html">[Antargis-svn] r1261 - antargis/trunk
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#218">[ date ]</a>
              <a href="thread.html#218">[ thread ]</a>
              <a href="subject.html#218">[ subject ]</a>
              <a href="author.html#218">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: davidkamphausen
Date: 2008-05-31 15:24:27 +0200 (Sat, 31 May 2008)
New Revision: 1262

Modified:
   antargis/trunk/Rakefile
   antargis/trunk/ruby/ai/dyn_map.rb
   antargis/trunk/ruby/ai/hero_actions.rb
   antargis/trunk/ruby/ai/hero_sensors.rb
   antargis/trunk/ruby/ai/heuristic.rb
   antargis/trunk/ruby/ai/rules.rb
   antargis/trunk/ruby/ai/sensors.rb
   antargis/trunk/ruby/ai/spec/valueMapping.rb
   antargis/trunk/ruby/ai/value_map.rb
   antargis/trunk/ruby/ant_ai.rb
   antargis/trunk/ruby/ant_ai_interface.rb
   antargis/trunk/ruby/ant_ai_player.rb
   antargis/trunk/ruby/ant_ai_rules.rb
   antargis/trunk/ruby/ant_buildjob.rb
   antargis/trunk/ruby/ant_debug.rb
   antargis/trunk/ruby/ant_energy.rb
   antargis/trunk/ruby/ant_formations.rb
   antargis/trunk/ruby/ant_hljob_base.rb
   antargis/trunk/ruby/ant_hljobs.rb
   antargis/trunk/ruby/ant_inventory.rb
   antargis/trunk/ruby/ant_level.rb
   antargis/trunk/ruby/ant_local.rb
   antargis/trunk/ruby/ant_messagebox.rb
   antargis/trunk/ruby/ant_models.rb
   antargis/trunk/ruby/ant_path.rb
   antargis/trunk/ruby/ant_pcplayer.rb
   antargis/trunk/ruby/ant_player.rb
   antargis/trunk/ruby/ant_scripting.rb
   antargis/trunk/ruby/ant_sound.rb
   antargis/trunk/ruby/ant_to_xml.rb
   antargis/trunk/ruby/ant_tools.rb
   antargis/trunk/ruby/ant_trigger.rb
   antargis/trunk/ruby/antargislib.rb
   antargis/trunk/ruby/campaign.rb
   antargis/trunk/ruby/credits.rb
   antargis/trunk/ruby/editor/campaign/campaign_data.rb
   antargis/trunk/ruby/editor/campaign/drag_grid.rb
   antargis/trunk/ruby/editor/dialogs.rb
   antargis/trunk/ruby/editor/ent_list.rb
   antargis/trunk/ruby/editor/spec/spec_editor.rb
   antargis/trunk/ruby/editor/tab_layout.rb
   antargis/trunk/ruby/editor/test/player_dialog.rb
   antargis/trunk/ruby/editor_app.rb
   antargis/trunk/ruby/editview.rb
   antargis/trunk/ruby/entities/ant_animal.rb
   antargis/trunk/ruby/entities/ant_arrow.rb
   antargis/trunk/ruby/entities/ant_bakery.rb
   antargis/trunk/ruby/entities/ant_boat.rb
   antargis/trunk/ruby/entities/ant_boss.rb
   antargis/trunk/ruby/entities/ant_buildingsite.rb
   antargis/trunk/ruby/entities/ant_decal.rb
   antargis/trunk/ruby/entities/ant_deco.rb
   antargis/trunk/ruby/entities/ant_druid.rb
   antargis/trunk/ruby/entities/ant_dwelling.rb
   antargis/trunk/ruby/entities/ant_farm.rb
   antargis/trunk/ruby/entities/ant_field.rb
   antargis/trunk/ruby/entities/ant_fir.rb
   antargis/trunk/ruby/entities/ant_fire.rb
   antargis/trunk/ruby/entities/ant_fish.rb
   antargis/trunk/ruby/entities/ant_fishing_hut.rb
   antargis/trunk/ruby/entities/ant_grass.rb
   antargis/trunk/ruby/entities/ant_grave.rb
   antargis/trunk/ruby/entities/ant_hero.rb
   antargis/trunk/ruby/entities/ant_house.rb
   antargis/trunk/ruby/entities/ant_man.rb
   antargis/trunk/ruby/entities/ant_manbase.rb
   antargis/trunk/ruby/entities/ant_mill.rb
   antargis/trunk/ruby/entities/ant_mine.rb
   antargis/trunk/ruby/entities/ant_ring.rb
   antargis/trunk/ruby/entities/ant_sack.rb
   antargis/trunk/ruby/entities/ant_sheep.rb
   antargis/trunk/ruby/entities/ant_stone.rb
   antargis/trunk/ruby/entities/ant_tower.rb
   antargis/trunk/ruby/entities/ant_townhall.rb
   antargis/trunk/ruby/entities/ant_tree.rb
   antargis/trunk/ruby/entities/ant_well.rb
   antargis/trunk/ruby/jobs/ant_hljob_base.rb
Log:
Incomplete - task 20: Translations 
<A HREF="http://localhost:3000/issues/show/20">http://localhost:3000/issues/show/20</A>

Modified: antargis/trunk/Rakefile
===================================================================
--- antargis/trunk/Rakefile	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/Rakefile	2008-05-31 13:24:27 UTC (rev 1262)
@@ -35,7 +35,7 @@
   oldSystem(cmd)
 end
 
-if $rspec
+if $rspec 
   # rspec
   Spec::Rake::SpecTask.new(:spec=&gt;:default) do |t|
     t.spec_files = FileList['ruby/**/spec_*.rb'].map{|f|File.expand_path(f)}
@@ -49,6 +49,35 @@
   end
 end
 
-task :cruise =&gt; :spec do
+desc &quot;Task for cruisecontrol.rb&quot;
+  task :cruise =&gt; :spec do
 end
 
+
+namespace :spec do
+  spec_cmd = (RUBY_PLATFORM =~ /java/) ? &quot;jruby -S spec&quot; : &quot;./starter /usr/bin/spec&quot;
+  task :showall do
+    puts Dir[&quot;ruby/**/spec_*.rb&quot;].select{|f|not f=~/spec_helper.rb/}.join(&quot;\n&quot;)
+  end
+  rule /^spec:/ do |t|
+    arguments = t.name.split(':')
+    
+    file_name = arguments[1]
+    spec_name = arguments[2..-1]
+
+    spec_filename = &quot;spec_#{file_name}.rb&quot;
+    specs = Dir[&quot;ruby/**/#{spec_filename}&quot;]
+    pp specs
+    
+    if path = specs.detect { |f| spec_filename == File.basename(f) }
+      run_file_name = path
+    else
+      puts &quot;No specs found for #{t.name.inspect}&quot;
+      exit
+    end
+
+    example = &quot; -e '#{spec_name}'&quot; unless spec_name.empty?
+    
+    sh &quot;#{spec_cmd} #{run_file_name} --format html:spec_output.html --colour #{example}&quot;
+  end
+end

Modified: antargis/trunk/ruby/ai/dyn_map.rb
===================================================================
--- antargis/trunk/ruby/ai/dyn_map.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ai/dyn_map.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,4 +1,7 @@
 module AI
+# FIXME: this file is outdated or at least not used ATM 
+  if false
+    
 # This file contains a dynamic and simplified representation of the gaming world.
 # This is needed for computing the max/min-tree within the AI.
 #
@@ -21,42 +24,44 @@
 # * check if trees can be combined to forests as an object ?
 #
 #
-	class DynPlayer
-		attr_accessor :player
-		attr_reader :realPlayer
-		def initialize(player)
-			@realPlayer=player
-		end
-	end
+  class DynPlayer
+    attr_accessor :player
+    attr_reader :realPlayer
+    def initialize(player)
+      @realPlayer=player
+    end
+  end
 
-	class DynHero
-		def initialize(hero)
-			@realHero=hero
-			@pos=hero.getPos2D
-			allResources=hero.getMen.map{|man|man.resource.getAll}
+  class DynHero
+    def initialize(hero)
+      @realHero=hero
+      @pos=hero.getPos2D
+      allResources=hero.getMen.map{|man|man.resource.getAll}
 
-			@resource=allResources.inject({})
-			{|a,new|
-				new.each{|k,v|
-					a[k]||=0
-					a[k]+=v
-				}
-				a
-			}
-			@health=hero.getStrength
-			@men=hero.getMen.length
-		end
-	end
+      @resource=allResources.inject({})
+# FIXME: this was a syntax error
+#      {|a,new|
+#         new.each{|k,v|
+#           a[k]||=0
+#          a[k]+=v
+#        }
+#        a
+#      }
+      @health=hero.getStrength
+      @men=hero.getMen.length
+    end
+  end
 
-	class DynMap
-		def initialize(map)
-			@players=map.getPlayers.map{|p|DynPlayer.new(p)}
-			@heroes=map.getHeroes.map{|h|DynHero.new(h)}
-			@buildings=map.getBuildings.map{|b|DynBuilding(b)}
-			@myplayer=@players.select{|p|p.realPlayer==map.getPlayer}[0]
-			assert{@myplayer}
-			@sources=[AntTree,AntFir,AntStone,AntMine].map{|type|map.getByType(type)}.flatten.uniq.map{|e|DynSource.new(e)}
-		end
-	end
+  class DynMap
+    def initialize(map)
+      @players=map.getPlayers.map{|p|DynPlayer.new(p)}
+      @heroes=map.getHeroes.map{|h|DynHero.new(h)}
+      @buildings=map.getBuildings.map{|b|DynBuilding(b)}
+      @myplayer=@players.select{|p|p.realPlayer==map.getPlayer}[0]
+      assert{@myplayer}
+      @sources=[AntTree,AntFir,AntStone,AntMine].map{|type|map.getByType(type)}.flatten.uniq.map{|e|DynSource.new(e)}
+    end
+  end
+  end
 end
 

Modified: antargis/trunk/ruby/ai/hero_actions.rb
===================================================================
--- antargis/trunk/ruby/ai/hero_actions.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ai/hero_actions.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,53 +1,53 @@
 module AI
-	module HeroAction
-		class Base
-			attr_reader :interface
-			def initialize(interface)
-				@interface=interface
-			end
-		end
+  module HeroAction
+    class Base
+      attr_reader :interface
+      def initialize(interface)
+        @interface=interface
+      end
+    end
 
-		class GetFood&lt;Base
-			def start(hero,target)
-				puts target,target.class
-				#raise 1
-				hero.takeFood(target)
-			end
-		end
+    class GetFood&lt;Base
+      def start(hero,target)
+        puts target,target.class
+        #raise 1
+        hero.takeFood(target)
+      end
+    end
 
-		class AttackHero&lt;Base
-			def start(hero,target)
-				assert{hero!=target}
-				hero.attack(target)
-			end
-		end
+    class AttackHero&lt;Base
+      def start(hero,target)
+        assert{hero!=target}
+        hero.attack(target)
+      end
+    end
 
-		class Rest&lt;Base
-			def start(hero)
-				hero.rest(20)
-			end
-		end
+    class Rest&lt;Base
+      def start(hero)
+        hero.rest(20)
+      end
+    end
 
-		class Recruit&lt;Base
-			def start(hero,target)
-				assert{hero!=target}
-				hero.recruit(target)
-			end
-		end
+    class Recruit&lt;Base
+      def start(hero,target)
+        assert{hero!=target}
+        hero.recruit(target)
+      end
+    end
 
-		class ConstructEquipment&lt;Base
-			def start(hero,target)
-				assert{hero!=target}
-				hero.recruit(target)
-			end
-		end
+    class ConstructEquipment&lt;Base
+      def start(hero,target)
+        assert{hero!=target}
+        hero.recruit(target)
+      end
+    end
 
-		class GetEquipment&lt;Base	
-			def start(hero,target)
-				assert{hero!=target}
-				hero.takeWeapon(target)
-			end
-		end
+    class GetEquipment&lt;Base  
+      def start(hero,target)
+        assert{hero!=target}
+        hero.takeWeapon(target)
+      end
+    end
 
-	end
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ai/hero_sensors.rb
===================================================================
--- antargis/trunk/ruby/ai/hero_sensors.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ai/hero_sensors.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,159 +1,159 @@
 require 'ruby/ai/value_map.rb'
 
 module AI
-	module HeroSensor
-		NEEDED_EQUIPMENT={&quot;sword&quot;=&gt;2,
-			&quot;shield&quot;=&gt;2,
-			&quot;bow&quot;=&gt;1,
-			&quot;boat&quot;=&gt;1
-		}
+  module HeroSensor
+    NEEDED_EQUIPMENT={&quot;sword&quot;=&gt;2,
+      &quot;shield&quot;=&gt;2,
+      &quot;bow&quot;=&gt;1,
+      &quot;boat&quot;=&gt;1
+    }
 
-		class Base
-			attr_reader :interface
-			def initialize(interface)
-				@interface=interface
-			end
+    class Base
+      attr_reader :interface
+      def initialize(interface)
+        @interface=interface
+      end
 
-			def value(hero)
-				0
-			end
-		end
+      def value(hero)
+        0
+      end
+    end
 
-		class FoodOk&lt;Base
-			def value(hero)
-				puts &quot;FOODLOW:#{hero.resources[&quot;food&quot;]}&quot;
-				mapValue01(hero.resources[&quot;food&quot;]||0,1,5)
-			end
-		end
+    class FoodOk&lt;Base
+      def value(hero)
+        puts &quot;FOODLOW:#{hero.resources[&quot;food&quot;]}&quot;
+        mapValue01(hero.resources[&quot;food&quot;]||0,1,5)
+      end
+    end
 
-		class FoodLow&lt;Base
-			def value(hero)
-				puts &quot;FOODLOW:#{hero.resources[&quot;food&quot;]}&quot;
-				1-mapValue01(hero.resources[&quot;food&quot;]||0,1,5)
-			end
-		end
+    class FoodLow&lt;Base
+      def value(hero)
+        puts &quot;FOODLOW:#{hero.resources[&quot;food&quot;]}&quot;
+        1-mapValue01(hero.resources[&quot;food&quot;]||0,1,5)
+      end
+    end
 
-		class FoodNear&lt;Base
-			# BEWARE: Do not use this variable after several calls of value!
-			attr_reader :target
-			def value(hero)
-				@target=hero.findNearResource(&quot;food&quot;)
-				return 0 unless @target
-				distance=(@target.getPos-hero.getPos).length
-				puts &quot;FOODNEAR: dist:#{distance}&quot;
-				mapValue01(40-distance,0,40)
-			end
-		end
+    class FoodNear&lt;Base
+      # BEWARE: Do not use this variable after several calls of value!
+      attr_reader :target
+      def value(hero)
+        @target=hero.findNearResource(&quot;food&quot;)
+        return 0 unless @target
+        distance=(@target.getPos-hero.getPos).length
+        puts &quot;FOODNEAR: dist:#{distance}&quot;
+        mapValue01(40-distance,0,40)
+      end
+    end
 
-		# FIXME: is building reachable ??
-		class EquipmentNear&lt;Base
-			attr_reader :target
-			def value(hero)
-				assert{hero.menCount&gt;0}
-				puts &quot;--EquipmentNear--&quot;
-				needed=NEEDED_EQUIPMENT.map{|res|[res[0],[0,hero.menCount-(hero.resources[res[0]]||0)].max]}
-				howMuchIsMissing=needed.inject(0){|result,nextPair|result+nextPair[1]}
+    # FIXME: is building reachable ??
+    class EquipmentNear&lt;Base
+      attr_reader :target
+      def value(hero)
+        assert{hero.menCount&gt;0}
+        puts &quot;--EquipmentNear--&quot;
+        needed=NEEDED_EQUIPMENT.map{|res|[res[0],[0,hero.menCount-(hero.resources[res[0]]||0)].max]}
+        howMuchIsMissing=needed.inject(0){|result,nextPair|result+nextPair[1]}
 
-				houses=interface.myPlayer.getBuildings
-				return if houses.length==0
-				houseValues=houses.map{|house|[house,getResourceValue(needed,house)]}
-				selHouse=houseValues.min{|a,b|a[1]&lt;=&gt;b[1]}
+        houses=interface.myPlayer.getBuildings
+        return if houses.length==0
+        houseValues=houses.map{|house|[house,getResourceValue(needed,house)]}
+        selHouse=houseValues.min{|a,b|a[1]&lt;=&gt;b[1]}
 
-				puts selHouse,howMuchIsMissing
-				puts &quot;--&quot;
-				return 0 if selHouse[1]&gt;=howMuchIsMissing
+        puts selHouse,howMuchIsMissing
+        puts &quot;--&quot;
+        return 0 if selHouse[1]&gt;=howMuchIsMissing
 
-				@target=selHouse[0]
-				
+        @target=selHouse[0]
+        
 
-				puts needed
-				puts howMuchIsMissing
-				puts hero.menCount
-				value=howMuchIsMissing.to_f / (hero.menCount*NEEDED_EQUIPMENT.length)
-				puts value
-				puts &quot;--EquipmentNear--&quot;
-				value
-			end
+        puts needed
+        puts howMuchIsMissing
+        puts hero.menCount
+        value=howMuchIsMissing.to_f / (hero.menCount*NEEDED_EQUIPMENT.length)
+        puts value
+        puts &quot;--EquipmentNear--&quot;
+        value
+      end
 
-			# return what's missing from that house
-			def getResourceValue(needed,house)
-				puts &quot;HOUSE:#{house.getName} #{house}&quot;
-				result=needed.inject(0){|result,nextPair|
-					res,value=nextPair
-					found=house.resources[res]||0
-					puts &quot;#{res} #{res.class} #{value} #{found}&quot;
-					result+=[value-found,0].max
-				}
-					#raise 1
-				result
-			end
-		end
+      # return what's missing from that house
+      def getResourceValue(needed,house)
+        puts &quot;HOUSE:#{house.getName} #{house}&quot;
+        result=needed.inject(0){|result,nextPair|
+          res,value=nextPair
+          found=house.resources[res]||0
+          puts &quot;#{res} #{res.class} #{value} #{found}&quot;
+          result+=[value-found,0].max
+        }
+          #raise 1
+        result
+      end
+    end
 
 
-		class Strength&lt;Base
-			def value(hero)
-				strength=hero.menCount
-				puts &quot;STRENGTH #{strength}&quot;
-				val=mapValueLinear(strength,0,40) # not 0, so value is never 0
-				puts &quot;val #{val}&quot;
-				val
-			end
-		end
+    class Strength&lt;Base
+      def value(hero)
+        strength=hero.menCount
+        puts &quot;STRENGTH #{strength}&quot;
+        val=mapValueLinear(strength,0,40) # not 0, so value is never 0
+        puts &quot;val #{val}&quot;
+        val
+      end
+    end
 
-		class WeakEnemy&lt;Strength # !!
-			attr_reader :enemy
-			def value(hero)
-				# search weakest enemy - FIXME: ensure that it's reachable
-				@enemy=interface.enemyPlayers.map{|p|p.getHeroes+p.getBuildings}.flatten.min{|a,b|a.menCount&lt;=&gt;b.menCount}
-	
-				return 0 if @enemy.nil?
-				quot=super(hero) / (super(@enemy)*1.2) # expect enemy to be stronger by 20%
-				log=Math.log(quot)
-				val=mapValue01(log,-1,2)
-				puts &quot;weak: quot:#{quot} log:#{log} val:#{val}&quot;
-				val
-			end
-		end
+    class WeakEnemy&lt;Strength # !!
+      attr_reader :enemy
+      def value(hero)
+        # search weakest enemy - FIXME: ensure that it's reachable
+        @enemy=interface.enemyPlayers.map{|p|p.getHeroes+p.getBuildings}.flatten.min{|a,b|a.menCount&lt;=&gt;b.menCount}
+  
+        return 0 if @enemy.nil?
+        quot=super(hero) / (super(@enemy)*1.2) # expect enemy to be stronger by 20%
+        log=Math.log(quot)
+        val=mapValue01(log,-1,2)
+        puts &quot;weak: quot:#{quot} log:#{log} val:#{val}&quot;
+        val
+      end
+    end
 
-		class StrongBuilding&lt;Strength
-			attr_reader :target
-			def value(hero)
-				# search strongest building - FIXME: ensure that it's reachable
-				targetArray=[interface.myPlayer].map{|p|p.getHeroes+p.getBuildings}.flatten.select{|h|h!=hero}
-				@target=targetArray.max{|a,b|a.menCount&lt;=&gt;b.menCount}
-				return 0 if @target.nil?
-				strength=@target.menCount/(hero.menCount+0.001)
-				return mapValueLinear(strength,0,3)
-			end
-		end
+    class StrongBuilding&lt;Strength
+      attr_reader :target
+      def value(hero)
+        # search strongest building - FIXME: ensure that it's reachable
+        targetArray=[interface.myPlayer].map{|p|p.getHeroes+p.getBuildings}.flatten.select{|h|h!=hero}
+        @target=targetArray.max{|a,b|a.menCount&lt;=&gt;b.menCount}
+        return 0 if @target.nil?
+        strength=@target.menCount/(hero.menCount+0.001)
+        return mapValueLinear(strength,0,3)
+      end
+    end
 
-		class Tired&lt;Base
-			def value(hero)
-				1-[hero.getMorale,hero.getEnergy**2].min
-			end
-		end
-		class Hungry&lt;Base
-			def value(hero)
-				1-[hero.getFood**2].min
-			end
-		end
+    class Tired&lt;Base
+      def value(hero)
+        1-[hero.getMorale,hero.getEnergy**2].min
+      end
+    end
+    class Hungry&lt;Base
+      def value(hero)
+        1-[hero.getFood**2].min
+      end
+    end
 
-		class BadEquipment&lt;Base
-			SCALE=NEEDED_EQUIPMENT.values.inject(0){|a,b|a+b}.to_f
-			def value(hero)
-				hero.resources.map{|r,v|(NEEDED_EQUIPMENT[r]||0)*(v&gt;0?1:0)}.inject(0){|a,b|a+b}/SCALE
-			end
-		end
+    class BadEquipment&lt;Base
+      SCALE=NEEDED_EQUIPMENT.values.inject(0){|a,b|a+b}.to_f
+      def value(hero)
+        hero.resources.map{|r,v|(NEEDED_EQUIPMENT[r]||0)*(v&gt;0?1:0)}.inject(0){|a,b|a+b}/SCALE
+      end
+    end
 
-		class WorkshopNear&lt;Base
-			attr_reader :target
-			def value(hero)
-				targetArray=interface.myPlayer.getBuildings.select{|b|b.isBuildingType(&quot;AntWorkshop&quot;)}
-				@target=targetArray.max{|a,b|(a.getPos2D-hero.getPos2D).length&lt;=&gt;(b.getPos2D-hero.getPos2D).length}
-				return 0 unless @target
-				1-mapValueLinear((@target.getPos2D-hero.getPos2D).length,0,30)
-			end
-		end
+    class WorkshopNear&lt;Base
+      attr_reader :target
+      def value(hero)
+        targetArray=interface.myPlayer.getBuildings.select{|b|b.isBuildingType(&quot;AntWorkshop&quot;)}
+        @target=targetArray.max{|a,b|(a.getPos2D-hero.getPos2D).length&lt;=&gt;(b.getPos2D-hero.getPos2D).length}
+        return 0 unless @target
+        1-mapValueLinear((@target.getPos2D-hero.getPos2D).length,0,30)
+      end
+    end
 
-	end
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ai/heuristic.rb
===================================================================
--- antargis/trunk/ruby/ai/heuristic.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ai/heuristic.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -3,22 +3,22 @@
 
 
 module AI
-	class Heuristic
-		def initialize
-			classes=[
-				[AI::Rule::AttackHero,1],
-				[AI::Rule::GetFood,1]
-			]
-			@rules=classes.map{|pair|[pair[0].new,scale]}
-		end
+  class Heuristic
+    def initialize
+      classes=[
+        [AI::Rule::AttackHero,1],
+        [AI::Rule::GetFood,1]
+      ]
+      @rules=classes.map{|pair|[pair[0].new,scale]}
+    end
 
 
-		def process(hero)
-			bestRule=@rules.max{|pair|
-				rule,scale=pair
-				rule.value(hero)*scale
-			}
-			bestRule.start(hero)
-		end
-	end
+    def process(hero)
+      bestRule=@rules.max{|pair|
+        rule,scale=pair
+        rule.value(hero)*scale
+      }
+      bestRule.start(hero)
+    end
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ai/rules.rb
===================================================================
--- antargis/trunk/ruby/ai/rules.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ai/rules.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -2,120 +2,120 @@
 require 'ruby/ai/hero_actions.rb'
 
 module AI
-	module Rule
-		class Base
-			attr_reader :interface
-			def initialize(interface)
-				@interface=interface
-			end
-			def start(hero)
-			end
-			def value(hero)
-			end
-		end
+  module Rule
+    class Base
+      attr_reader :interface
+      def initialize(interface)
+        @interface=interface
+      end
+      def start(hero)
+      end
+      def value(hero)
+      end
+    end
 
-		class GetWeapon&lt;Base
-			def initialize(interface)
-				super
-				@eqNear=HeroSensor::EquipmentNear.new(interface)
-				@getEq=HeroAction::GetEquipment.new(interface)
-			end
-			def value(hero)
-				eqNear=@eqNear.value(hero)
-			end
-			def start(hero)
-				puts &quot;START WEAPONS&quot;
-				@getEq.start(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero, at eqNear.target</A>)
-			end
-		end
+    class GetWeapon&lt;Base
+      def initialize(interface)
+        super
+        @eqNear=HeroSensor::EquipmentNear.new(interface)
+        @getEq=HeroAction::GetEquipment.new(interface)
+      end
+      def value(hero)
+        eqNear=@eqNear.value(hero)
+      end
+      def start(hero)
+        puts &quot;START WEAPONS&quot;
+        @getEq.start(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero, at eqNear.target</A>)
+      end
+    end
 
-	
-		class GetFood&lt;Base
-			def initialize(interface)
-				super
-				@foodLow=HeroSensor::FoodLow.new(interface)
-				@foodNear=HeroSensor::FoodNear.new(interface)
-				@getFood=HeroAction::GetFood.new(interface)
-			end
-			def value(hero)
-				foodLow=@foodLow.value(hero)
-				foodNear=@foodNear.value(hero)
-				puts &quot;FOODLOW:#{foodLow} FOODNEAR:#{foodNear}&quot;
-				foodLow*foodNear
-			end
-			def start(hero)
-				puts &quot;START GETFOOD&quot;
-				@getFood.start(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero, at foodNear.target</A>) #.getSource(hero))
-			end
-		end
-	
-		class AttackHero&lt;Base
-			def initialize(interface)
-				super
-				@strength=HeroSensor::Strength.new(interface)
-				@weakEnemy=HeroSensor::WeakEnemy.new(interface)
-				@attackHero=HeroAction::AttackHero.new(interface)
-			end
-			def value(hero)
-				# FIXME: include sensor for multiple heroes at same place
-				@weakEnemy.value(hero)*@strength.value(hero)
-			end
-			def start(hero)
-				puts &quot;START ATTACK&quot;
-				@attackHero.start(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero, at weakEnemy.enemy</A>)
-			end
-		end
+  
+    class GetFood&lt;Base
+      def initialize(interface)
+        super
+        @foodLow=HeroSensor::FoodLow.new(interface)
+        @foodNear=HeroSensor::FoodNear.new(interface)
+        @getFood=HeroAction::GetFood.new(interface)
+      end
+      def value(hero)
+        foodLow=@foodLow.value(hero)
+        foodNear=@foodNear.value(hero)
+        puts &quot;FOODLOW:#{foodLow} FOODNEAR:#{foodNear}&quot;
+        foodLow*foodNear
+      end
+      def start(hero)
+        puts &quot;START GETFOOD&quot;
+        @getFood.start(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero, at foodNear.target</A>) #.getSource(hero))
+      end
+    end
+  
+    class AttackHero&lt;Base
+      def initialize(interface)
+        super
+        @strength=HeroSensor::Strength.new(interface)
+        @weakEnemy=HeroSensor::WeakEnemy.new(interface)
+        @attackHero=HeroAction::AttackHero.new(interface)
+      end
+      def value(hero)
+        # FIXME: include sensor for multiple heroes at same place
+        @weakEnemy.value(hero)*@strength.value(hero)
+      end
+      def start(hero)
+        puts &quot;START ATTACK&quot;
+        @attackHero.start(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero, at weakEnemy.enemy</A>)
+      end
+    end
 
-		class RecruitFromBuilding&lt;Base
-			def initialize(interface)
-				@weakEnemy=HeroSensor::WeakEnemy.new(interface)
-				@strongBuilding=HeroSensor::StrongBuilding.new(interface)
-				@recruit=HeroAction::Recruit.new(interface)
-			end
-			def value(hero)
-				# FIXME: include sensor for multiple heroes at same place
-				# FIXME: switch to strong_building AND not_insecure (attackable)
-				#Math.sqrt((<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1- at weakEnemy.value</A>(hero))*@strongBuilding.value(hero))
-				@strongBuilding.value(hero)
-			end
-			def start(hero)
-				puts &quot;TRY RECRUIT&quot;
-				@recruit.start(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero, at strongBuilding.target</A>)
-			end
-		end
+    class RecruitFromBuilding&lt;Base
+      def initialize(interface)
+        @weakEnemy=HeroSensor::WeakEnemy.new(interface)
+        @strongBuilding=HeroSensor::StrongBuilding.new(interface)
+        @recruit=HeroAction::Recruit.new(interface)
+      end
+      def value(hero)
+        # FIXME: include sensor for multiple heroes at same place
+        # FIXME: switch to strong_building AND not_insecure (attackable)
+        #Math.sqrt((<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1- at weakEnemy.value</A>(hero))*@strongBuilding.value(hero))
+        @strongBuilding.value(hero)
+      end
+      def start(hero)
+        puts &quot;TRY RECRUIT&quot;
+        @recruit.start(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero, at strongBuilding.target</A>)
+      end
+    end
 
-		class Rest&lt;Base
-			def initialize(interface)
-				super
-				@foodok=HeroSensor::FoodOk.new(interface)
-				@tired=HeroSensor::Tired.new(interface)
-				@hungry=HeroSensor::Hungry.new(interface)
-				@rest=HeroAction::Rest.new(interface)
-			end
-			def value(hero)
-				[@hungry.value(hero)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at tired.value</A>(hero),0.2].max
-				#0.2
-				#@foodok.value(hero)
-			end
-			def start(hero)
-				@rest.start(hero)
-			end
-		end
+    class Rest&lt;Base
+      def initialize(interface)
+        super
+        @foodok=HeroSensor::FoodOk.new(interface)
+        @tired=HeroSensor::Tired.new(interface)
+        @hungry=HeroSensor::Hungry.new(interface)
+        @rest=HeroAction::Rest.new(interface)
+      end
+      def value(hero)
+        [@hungry.value(hero)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at tired.value</A>(hero),0.2].max
+        #0.2
+        #@foodok.value(hero)
+      end
+      def start(hero)
+        @rest.start(hero)
+      end
+    end
 
-		class Construct&lt;Base
-			def initialize(interface)
-				super
-				@badEquipment=HeroSensor::BadEquipment.new(interface)
-				@workshopNear=HeroSensor::WorkshopNear.new(interface)
-				@construct=HeroAction::ConstructEquipment.new(interface)
-			end
-			def value(hero)
-				Math.sqrt(@badEquipment.value(hero)*@workshopNear.value(hero))
-			end
-			def start(hero)
-				@construct.start(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero, at workshopNear.target</A>)
-			end
-		end
+    class Construct&lt;Base
+      def initialize(interface)
+        super
+        @badEquipment=HeroSensor::BadEquipment.new(interface)
+        @workshopNear=HeroSensor::WorkshopNear.new(interface)
+        @construct=HeroAction::ConstructEquipment.new(interface)
+      end
+      def value(hero)
+        Math.sqrt(@badEquipment.value(hero)*@workshopNear.value(hero))
+      end
+      def start(hero)
+        @construct.start(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero, at workshopNear.target</A>)
+      end
+    end
 
-	end
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ai/sensors.rb
===================================================================
--- antargis/trunk/ruby/ai/sensors.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ai/sensors.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,100 +1,100 @@
 require 'value_map.rb'
 
 module AI
-	class Sensor
-		attr_reader :player
+  class Sensor
+    attr_reader :player
 
-		def initialize(player)
-			@player=player
-		end
-	end
+    def initialize(player)
+      @player=player
+    end
+  end
 
-	class HeroFoodSensor&lt;Sensor
-		def value
-			heroFood=player.getHeroes.map{|h|h.resources.get(&quot;food&quot;)}
+  class HeroFoodSensor&lt;Sensor
+    def value
+      heroFood=player.getHeroes.map{|h|h.resources.get(&quot;food&quot;)}
 
-			heroFood.inject(0){|a,b|a+b}
-		end
-	end
+      heroFood.inject(0){|a,b|a+b}
+    end
+  end
 
-	class StrengthSensor&lt;Sensor
-		def value
-			heroStrengths=player.getHeroes.map{|h|h.menCount}
-			heroStrengths.inject(0){|a,b|a+b}
-		end
-	end
+  class StrengthSensor&lt;Sensor
+    def value
+      heroStrengths=player.getHeroes.map{|h|h.menCount}
+      heroStrengths.inject(0){|a,b|a+b}
+    end
+  end
 
-	class BuildingCountSensor&lt;Sensor
-		def value
-			player.getBuildings.length
-		end
-	end
+  class BuildingCountSensor&lt;Sensor
+    def value
+      player.getBuildings.length
+    end
+  end
 
-	class InDangerSensor&lt;Sensor
-	end
+  class InDangerSensor&lt;Sensor
+  end
 
-	# the opposite of InDangerSensor
-	class GoodAttackPosSensor&lt;Sensor
-	end
+  # the opposite of InDangerSensor
+  class GoodAttackPosSensor&lt;Sensor
+  end
 
-	# enough resources in vicinity of buildings
-	class GoodResourceSensor&lt;Sensor
-		RESOURCES=[:wood,:stone,:ore]
-		MAX_DIST=50
-		MIN_RESOURCE=5
-		def value
-			
-			player.getBuildings.map{|building|
-				RESOURCES.map{|resource|
-					map.getNext(building,resource,MIN_RESOURCE).map{|r|
-						mapValue01(MIN_RESOURCE,r.resource.get(resource))
-					}.min
-				}
-			}
-		end
-	end
+  # enough resources in vicinity of buildings
+  class GoodResourceSensor&lt;Sensor
+    RESOURCES=[:wood,:stone,:ore]
+    MAX_DIST=50
+    MIN_RESOURCE=5
+    def value
+      
+      player.getBuildings.map{|building|
+        RESOURCES.map{|resource|
+          map.getNext(building,resource,MIN_RESOURCE).map{|r|
+            mapValue01(MIN_RESOURCE,r.resource.get(resource))
+          }.min
+        }
+      }
+    end
+  end
 
-	class CompletenessOfProdChainSensor&lt;Sensor
-		MAX_DIST=20
+  class CompletenessOfProdChainSensor&lt;Sensor
+    MAX_DIST=20
 
-		def value
-			blocks=createBlocks(player.getBuildings.map{|b|[b]})
-			blocks.map{|block|
-				completenessOfChain(block)
-			}
+    def value
+      blocks=createBlocks(player.getBuildings.map{|b|[b]})
+      blocks.map{|block|
+        completenessOfChain(block)
+      }
 
-		end
-	private
-		def completenessOfChain(block)
-			#FIXME
-		end
-		def createBlocks(blocks)
-			nblocks=blocks.inject([]){|blocklist,newBuilding|
-				added=false
-				blocklist.each{|group|
-					group.each{|currentBuilding|
-						if (currentBuilding.getPos2D-newBuilding.getPos2D).length&lt;MAX_DIST
-							blocklist=blocklist-[group]+[group+newBuilding]
-							added=true
-							break
-						end
-					}
-				}
-				blocklist+=[newBuilding] unless added
-			}
-			nblocks=createBlocks(nblocks) if nblocks.length!=blocks.length
-			nblocks
-		end
+    end
+  private
+    def completenessOfChain(block)
+      #FIXME
+    end
+    def createBlocks(blocks)
+      nblocks=blocks.inject([]){|blocklist,newBuilding|
+        added=false
+        blocklist.each{|group|
+          group.each{|currentBuilding|
+            if (currentBuilding.getPos2D-newBuilding.getPos2D).length&lt;MAX_DIST
+              blocklist=blocklist-[group]+[group+newBuilding]
+              added=true
+              break
+            end
+          }
+        }
+        blocklist+=[newBuilding] unless added
+      }
+      nblocks=createBlocks(nblocks) if nblocks.length!=blocks.length
+      nblocks
+    end
 
-	end
+  end
 
-	SENSORS=[
-		HeroFoodSensor,
-		StrengthSensor,
-		BuildingCountSensor,
-		CompletenessOfProdChainSensor
-	]	
+  SENSORS=[
+    HeroFoodSensor,
+    StrengthSensor,
+    BuildingCountSensor,
+    CompletenessOfProdChainSensor
+  ]  
 
-	
+  
 
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ai/spec/valueMapping.rb
===================================================================
--- antargis/trunk/ruby/ai/spec/valueMapping.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ai/spec/valueMapping.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -2,57 +2,57 @@
 require 'ruby/ai/value_map.rb'
 
 describe &quot;mapValue01 - mapping with min=5&quot; do
-	before(:all) do
-		@min=5
-	end
-	it &quot;should map to 0 when parameter is below min&quot; do
-		mapValue01(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at min</A>).should == 0
-		mapValue01(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">3, at min</A>).should == 0
-		mapValue01(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">4.5, at min</A>).should == 0
-	end
+  before(:all) do
+    @min=5
+  end
+  it &quot;should map to 0 when parameter is below min&quot; do
+    mapValue01(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at min</A>).should == 0
+    mapValue01(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">3, at min</A>).should == 0
+    mapValue01(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">4.5, at min</A>).should == 0
+  end
 
-	it &quot;5 in interval (0,5) should be above 0.99&quot; do
-		mapValue01(5,0,5).should &gt; 0.99
-	end
+  it &quot;5 in interval (0,5) should be above 0.99&quot; do
+    mapValue01(5,0,5).should &gt; 0.99
+  end
 
-	it &quot;should map to a value above 0.99 when parameter is really big (1000) in standard scale&quot; do
-		mapValue01(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1000, at min</A>).should &gt; 0.99
-	end
+  it &quot;should map to a value above 0.99 when parameter is really big (1000) in standard scale&quot; do
+    mapValue01(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1000, at min</A>).should &gt; 0.99
+  end
 
-	it &quot;should be ascending whatsoever&quot; do
-		arr=[5,10,20,100,200,250,1000,20000]
-		last=0
-		arr.each{|v|
-			new=mapValue01(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">v, at min</A>)
-			new.should &gt; last
-			last=new
-		}
-	end
+  it &quot;should be ascending whatsoever&quot; do
+    arr=[5,10,20,100,200,250,1000,20000]
+    last=0
+    arr.each{|v|
+      new=mapValue01(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">v, at min</A>)
+      new.should &gt; last
+      last=new
+    }
+  end
 
-	it &quot;should not map above 1 - even with 1000000000000&quot; do
-		v=mapValue01(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1000000000000, at min</A>).should &lt;= 1
-	end
-	
+  it &quot;should not map above 1 - even with 1000000000000&quot; do
+    v=mapValue01(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1000000000000, at min</A>).should &lt;= 1
+  end
+  
 end
 
 
 describe &quot;mapMinValues - mapping array to min&quot; do
-	it &quot;should map [1,4,5] to the same value regardless of the order&quot; do
-		as=[[1,4,5],[1,5,4],[5,4,1],[5,1,4],[4,1,5],[4,5,1]]
-		a=as[0]
-		v=mapMinValues(a)
-		as.each{|ca|
-			mapMinValues(ca).should == v
-		}
-	end
+  it &quot;should map [1,4,5] to the same value regardless of the order&quot; do
+    as=[[1,4,5],[1,5,4],[5,4,1],[5,1,4],[4,1,5],[4,5,1]]
+    a=as[0]
+    v=mapMinValues(a)
+    as.each{|ca|
+      mapMinValues(ca).should == v
+    }
+  end
 
-	it &quot;should map [1,5,5] below [2,5,5] (ascension)&quot; do
-		mapMinValues([1,5,5]).should &lt; mapMinValues([2,5,5])
-	end
-	it &quot;should map [5,5,5] same as [5,5] (regardless the count)&quot; do
-		mapMinValues([5,5,5]).should == mapMinValues([5,5])
-	end
-	it &quot;should map [2,3,5] below [2,4,4] (no averaging - bad min worthens the result)&quot; do
-		mapMinValues([2,3,5]).should &lt; mapMinValues([2,4,4])
-	end
+  it &quot;should map [1,5,5] below [2,5,5] (ascension)&quot; do
+    mapMinValues([1,5,5]).should &lt; mapMinValues([2,5,5])
+  end
+  it &quot;should map [5,5,5] same as [5,5] (regardless the count)&quot; do
+    mapMinValues([5,5,5]).should == mapMinValues([5,5])
+  end
+  it &quot;should map [2,3,5] below [2,4,4] (no averaging - bad min worthens the result)&quot; do
+    mapMinValues([2,3,5]).should &lt; mapMinValues([2,4,4])
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ai/value_map.rb
===================================================================
--- antargis/trunk/ruby/ai/value_map.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ai/value_map.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,22 +1,22 @@
 def mapValue01(v,min,max=1000.0)
-	factor=1000
-	n=Math.atan((v-min)/(max-min)*factor+0.0000001)/(Math::PI/2)
-	n=[0,n].max
-	#puts &quot;#{v}:#{n}&quot;
-	n
+  factor=1000
+  n=Math.atan((v-min)/(max-min)*factor+0.0000001)/(Math::PI/2)
+  n=[0,n].max
+  #puts &quot;#{v}:#{n}&quot;
+  n
 end
 
 def mapValueLinear(v,min,max)
-	n=((v-min).to_f)/(max-min)
-	puts &quot;linearmPa:#{v} #{n} (#{min} #{max}&quot;
-	[0,n,1].sort[1]
+  n=((v-min).to_f)/(max-min)
+  puts &quot;linearmPa:#{v} #{n} (#{min} #{max}&quot;
+  [0,n,1].sort[1]
 end
 
 
 def mapMinValues(values)
-	count=values.length
-	values2=values.map{|v|mapValue01(v,0)}
-	r=values2.map{|v|v}.inject(0){|a,b|a+b*b}
-	res=Math.sqrt(r)/Math.sqrt(count)
-	res
+  count=values.length
+  values2=values.map{|v|mapValue01(v,0)}
+  r=values2.map{|v|v}.inject(0){|a,b|a+b*b}
+  res=Math.sqrt(r)/Math.sqrt(count)
+  res
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_ai.rb
===================================================================
--- antargis/trunk/ruby/ant_ai.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_ai.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -32,83 +32,83 @@
 require 'ruby/ai/rules.rb'
 
 class AntBasicAI
-	attr_reader :interface
+  attr_reader :interface
 
-	# initialize any information for your AI here, but beware that this is called on reload, too.
-	# FIXME: loading and saving of AI-members!
-	def initialize(interface)
-		@interface=interface
-	end
-	# This an initializing event - this called only on new creation within a level - so it won't be
-	# called when loading a level. You can savely initialize your values here.
-	def eventInit
-	end
-	# the given hero has no job currently 
-	def eventHeroWithoutJob(hero)
-	end
-	# the given hero is attacked by the given enemy
-	def eventHeroAttacked(hero,enemy)
-	end
-	# your hero has hit a trigger - this SHOULDN'T really BE USED, because triggers are only
-	# reasonable within level-scripting (?) 
-	def eventTriggerHit(hero,triggerName)
-	end
-	# in each frame this function is called with the time that's passed. Don't use this function if you
-	# don't need to, because this hits performance rather badly!
-	def eventFrame(time)
-	end
+  # initialize any information for your AI here, but beware that this is called on reload, too.
+  # FIXME: loading and saving of AI-members!
+  def initialize(interface)
+    @interface=interface
+  end
+  # This an initializing event - this called only on new creation within a level - so it won't be
+  # called when loading a level. You can savely initialize your values here.
+  def eventInit
+  end
+  # the given hero has no job currently 
+  def eventHeroWithoutJob(hero)
+  end
+  # the given hero is attacked by the given enemy
+  def eventHeroAttacked(hero,enemy)
+  end
+  # your hero has hit a trigger - this SHOULDN'T really BE USED, because triggers are only
+  # reasonable within level-scripting (?) 
+  def eventTriggerHit(hero,triggerName)
+  end
+  # in each frame this function is called with the time that's passed. Don't use this function if you
+  # don't need to, because this hits performance rather badly!
+  def eventFrame(time)
+  end
 end
 
 class AntAttackAI&lt;AntBasicAI
-	def initialize(interface)
-		super
-		# add rules
-		@rules=[]
-		@rules.push(AIRule.new(AIEveryNthCondition.new(2),AIRestAction.new,interface))
-		@rules.push(AIRule.new(AIConditionFoodLow.new,AIGatherFoodAction.new,interface))
-		@rules.push(AIRule.new(AIEveryNthCondition.new(2),AIAttackAction.new,interface))
-		@rules.push(AIRule.new(AICondition.new,AIRestAction.new,interface)) # dummy rule - always rest
-	end
+  def initialize(interface)
+    super
+    # add rules
+    @rules=[]
+    @rules.push(AIRule.new(AIEveryNthCondition.new(2),AIRestAction.new,interface))
+    @rules.push(AIRule.new(AIConditionFoodLow.new,AIGatherFoodAction.new,interface))
+    @rules.push(AIRule.new(AIEveryNthCondition.new(2),AIAttackAction.new,interface))
+    @rules.push(AIRule.new(AICondition.new,AIRestAction.new,interface)) # dummy rule - always rest
+  end
 
-	def eventHeroWithoutJob(hero)
-		@rules.each{|r|
-			if r.value(hero)&gt;0
-				puts &quot;GO&quot;
-				r.execute(hero)
-				return
-			end
-		}
-	end
+  def eventHeroWithoutJob(hero)
+    @rules.each{|r|
+      if r.value(hero)&gt;0
+        puts &quot;GO&quot;
+        r.execute(hero)
+        return
+      end
+    }
+  end
 end
 
 class AntFuzzyAI&lt;AntBasicAI
-	def initialize(interface)
-		super
+  def initialize(interface)
+    super
 
-		classes=[
-			[AI::Rule::AttackHero,1.5],
-			[AI::Rule::GetFood,1],
-			[AI::Rule::Rest,1],
-			[AI::Rule::RecruitFromBuilding,1],
-			[AI::Rule::Construct,1],
-			[AI::Rule::GetWeapon,1],
-		]
-		@rules=classes.map{|pair|[pair[0].new(interface),pair[1]]}
-	end
+    classes=[
+      [AI::Rule::AttackHero,1.5],
+      [AI::Rule::GetFood,1],
+      [AI::Rule::Rest,1],
+      [AI::Rule::RecruitFromBuilding,1],
+      [AI::Rule::Construct,1],
+      [AI::Rule::GetWeapon,1],
+    ]
+    @rules=classes.map{|pair|[pair[0].new(interface),pair[1]]}
+  end
 
-	def eventHeroWithoutJob(hero)
-		puts &quot;eventHeroWithoutJob(hero) #{hero.getName}&quot;
-		process(hero)
-	end
+  def eventHeroWithoutJob(hero)
+    puts &quot;eventHeroWithoutJob(hero) #{hero.getName}&quot;
+    process(hero)
+  end
 
-	private
-	def process(hero)
-		bestRules=@rules.map{|r|[r,r[0].value(hero)*r[1]]}
-		puts &quot;-------&quot;
-		bestRules.each{|r|puts &quot;RULE #{r[0]} - value:#{r[1]}&quot;}
-		puts &quot;-------&quot;
-		bestRule=bestRules.max{|a,b|a[1]&lt;=&gt;b[1]}[0]
-		bestRule[0].start(hero)
-	end
+  private
+  def process(hero)
+    bestRules=@rules.map{|r|[r,r[0].value(hero)*r[1]]}
+    puts &quot;-------&quot;
+    bestRules.each{|r|puts &quot;RULE #{r[0]} - value:#{r[1]}&quot;}
+    puts &quot;-------&quot;
+    bestRule=bestRules.max{|a,b|a[1]&lt;=&gt;b[1]}[0]
+    bestRule[0].start(hero)
+  end
 end
 

Modified: antargis/trunk/ruby/ant_ai_interface.rb
===================================================================
--- antargis/trunk/ruby/ant_ai_interface.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_ai_interface.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -52,298 +52,298 @@
 # REWRITE
 
 class AIInterface
-	def initialize(map,player)
-		@map=map
-		@player=player
-	end
-	def myPlayer
-# 		puts &quot;myPlayer:&quot;
-# 		puts @player,&quot;--&quot;
-# 		puts @map.players
-# 		puts &quot;_-&quot;
-# 		puts @player.getHeroes
-# 		puts @player.getBuildings
-# 		raise 1
-		AIMyPlayer.new(@player)
-	end
-	def enemyPlayers
-		@map.players.select{|p|p!=@player}.collect{|p|AIEnemyPlayer.new(p)}
-	end
+  def initialize(map,player)
+    @map=map
+    @player=player
+  end
+  def myPlayer
+#     puts &quot;myPlayer:&quot;
+#     puts @player,&quot;--&quot;
+#     puts @map.players
+#     puts &quot;_-&quot;
+#     puts @player.getHeroes
+#     puts @player.getBuildings
+#     raise 1
+    AIMyPlayer.new(@player)
+  end
+  def enemyPlayers
+    @map.players.select{|p|p!=@player}.collect{|p|AIEnemyPlayer.new(p)}
+  end
 end
 
 class AIMyPlayer
-	def initialize(player)
-		@player=player
-	end
-	def getHeroes
-		@player.getHeroes.map{|p|AIMyHero.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p, at player</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at player.getMap</A>)}
-	end
-	def getBuildings
-		@player.getBuildings.map{|p|AIMyBuilding.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p, at player</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at player.getMap</A>)}
-	end
-	def getBosses
-		getBuildings+getHeroes
-	end
-	def getName
-		@player.getName
-	end
+  def initialize(player)
+    @player=player
+  end
+  def getHeroes
+    @player.getHeroes.map{|p|AIMyHero.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p, at player</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at player.getMap</A>)}
+  end
+  def getBuildings
+    @player.getBuildings.map{|p|AIMyBuilding.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p, at player</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at player.getMap</A>)}
+  end
+  def getBosses
+    getBuildings+getHeroes
+  end
+  def getName
+    @player.getName
+  end
 end
 
 class AIMyEntity
-	def initialize(ent,player,map)
-		@ent=ent
-		@player=player
-		@map=map
-	end
-	def resources(name=nil)
-		return unless name.is_a?(String) or name.nil?
-		if valid
-			if name.nil?
-				return @ent.resource.getAll
-			else
-				return @ent.resource.get(name)
-			end
-		else
-			return {}
-		end
-	end
-	def ==(other)
-		@ent==getRef(other)
-	end
+  def initialize(ent,player,map)
+    @ent=ent
+    @player=player
+    @map=map
+  end
+  def resources(name=nil)
+    return unless name.is_a?(String) or name.nil?
+    if valid
+      if name.nil?
+        return @ent.resource.getAll
+      else
+        return @ent.resource.get(name)
+      end
+    else
+      return {}
+    end
+  end
+  def ==(other)
+    @ent==getRef(other)
+  end
 
-	def uid
-		@ent.uid
-	end
-	def valid
-		@ent.getPlayer==@player
-	end
-	def getName
-		@ent.getName
-	end
-	def getPos
-		@ent.getPos2D
-	end
-	def getMap
-		@map
-	end
-	private
-	def getRef(t)
-		@map.getByUID(t.uid)
-	end
-	def getSource(hero,what,atleast,tries=5)
-		while tries&gt;0
-			puts &quot;search from #{hero} #{what} #{atleast}&quot;
-			e=getMap.getNext(hero,what,atleast)
-			if e.nil?
-				puts &quot;NO SOURCE&quot;
-				#return nil
-			elsif e.getPlayer and e.getPlayer==@player
-				if e.is_a?(AntHouse)
-					return AIMyBuilding.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">e, at player</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at map</A>)
-				elsif e.is_a?(AntHero)
-					return AIMyHero.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">e, at player</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at map</A>)
-				end
-# 			else
-# 				puts &quot;#{e.getPlayer} #{@player}&quot;
-# 				raise 1
-			end
-			tries-=1
-		end
-		puts &quot;OUT OF TRIES&quot;
-		return nil
-	end
+  def uid
+    @ent.uid
+  end
+  def valid
+    @ent.getPlayer==@player
+  end
+  def getName
+    @ent.getName
+  end
+  def getPos
+    @ent.getPos2D
+  end
+  def getMap
+    @map
+  end
+  private
+  def getRef(t)
+    @map.getByUID(t.uid)
+  end
+  def getSource(hero,what,atleast,tries=5)
+    while tries&gt;0
+      puts &quot;search from #{hero} #{what} #{atleast}&quot;
+      e=getMap.getNext(hero,what,atleast)
+      if e.nil?
+        puts &quot;NO SOURCE&quot;
+        #return nil
+      elsif e.getPlayer and e.getPlayer==@player
+        if e.is_a?(AntHouse)
+          return AIMyBuilding.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">e, at player</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at map</A>)
+        elsif e.is_a?(AntHero)
+          return AIMyHero.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">e, at player</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at map</A>)
+        end
+#       else
+#         puts &quot;#{e.getPlayer} #{@player}&quot;
+#         raise 1
+      end
+      tries-=1
+    end
+    puts &quot;OUT OF TRIES&quot;
+    return nil
+  end
 end
 
 class AIMyBuilding&lt;AIMyEntity
-	def menCount
-		@ent.getMen.length
-	end
-	def isBuildingType(type)
-		@ent.class.ancestors.select{|c|c.to_s==type}.length&gt;0
-	end
+  def menCount
+    @ent.getMen.length
+  end
+  def isBuildingType(type)
+    @ent.class.ancestors.select{|c|c.to_s==type}.length&gt;0
+  end
 
 end
 
 class AIMyHero&lt;AIMyEntity
-	# get the current count of troopers
-	def menCount
-		@ent.getMen.length
-	end
+  # get the current count of troopers
+  def menCount
+    @ent.getMen.length
+  end
 
-	def findNearResource(resourceName,far=10)
-		return unless resourceName.is_a?(String) and far.is_a?(Numeric)
-		atLeast=3
-		atLeast=0
-		if valid
-			return getSource(@ent,resourceName,atLeast)
-		end
-		return nil
-	end
+  def findNearResource(resourceName,far=10)
+    return unless resourceName.is_a?(String) and far.is_a?(Numeric)
+    atLeast=3
+    atLeast=0
+    if valid
+      return getSource(@ent,resourceName,atLeast)
+    end
+    return nil
+  end
 
 
-	# set the aggression level (0,1,2)
-	def setAggression(level)
-		return unless [0,1,2].member?(level)
-		if valid
-			@ent.setAggression(level)
-		end
-	end
+  # set the aggression level (0,1,2)
+  def setAggression(level)
+    return unless [0,1,2].member?(level)
+    if valid
+      @ent.setAggression(level)
+    end
+  end
 
-	# move my hero to place
-	def moveTo(place)
-		return unless place.is_a?(AGVector2)
-		if valid
-			@ent.newHLMoveJob(0,place,0)
-		end
-	end
+  # move my hero to place
+  def moveTo(place)
+    return unless place.is_a?(AGVector2)
+    if valid
+      @ent.newHLMoveJob(0,place,0)
+    end
+  end
 
-	# attack enemy target
-	def attack(target)
-		return unless target.is_a?(AIEnemy)
-		if valid and target.valid
-			r=getRef(target)
-			if r
-				@ent.newHLFightJob(r)
-			end
-		end
-	end
-	
-	# recruit from target
-	def recruit(target)
-		puts &quot;RECRUITING from #{target} #{target.class}&quot;
-		assert{getRef(target)!=@ent}
-		return unless target.is_a?(AIMyBuilding) or target.is_a?(AIMyHero)
-		if valid and target.valid
-			r=getRef(target)
-			puts &quot;ref:#{r}&quot;
-			@ent.newHLRecruitJob(r) if r
-		else
-			raise &quot;sth invalid&quot;
-		end
-	end
+  # attack enemy target
+  def attack(target)
+    return unless target.is_a?(AIEnemy)
+    if valid and target.valid
+      r=getRef(target)
+      if r
+        @ent.newHLFightJob(r)
+      end
+    end
+  end
+  
+  # recruit from target
+  def recruit(target)
+    puts &quot;RECRUITING from #{target} #{target.class}&quot;
+    assert{getRef(target)!=@ent}
+    return unless target.is_a?(AIMyBuilding) or target.is_a?(AIMyHero)
+    if valid and target.valid
+      r=getRef(target)
+      puts &quot;ref:#{r}&quot;
+      @ent.newHLRecruitJob(r) if r
+    else
+      raise &quot;sth invalid&quot;
+    end
+  end
 
-	def construct(target)
-		puts &quot;construct: #{target}&quot;
-		return unless target.is_a?(AIMyBuilding)
-		if valid and target.valid
-			r=getRef(target)
-			@ent.newHLConstructJob(r) if r
-		end
-	end
+  def construct(target)
+    puts &quot;construct: #{target}&quot;
+    return unless target.is_a?(AIMyBuilding)
+    if valid and target.valid
+      r=getRef(target)
+      @ent.newHLConstructJob(r) if r
+    end
+  end
 
-	def takeFood(target)
-		puts &quot;takeFood: #{target}&quot;
-		return unless target.is_a?(AIMyBuilding)
-		if valid and target.valid
-			r=getRef(target)
-			@ent.newHLTakeFoodJob(r) if r
-		end
-	end
+  def takeFood(target)
+    puts &quot;takeFood: #{target}&quot;
+    return unless target.is_a?(AIMyBuilding)
+    if valid and target.valid
+      r=getRef(target)
+      @ent.newHLTakeFoodJob(r) if r
+    end
+  end
 
-	def takeWeapon(target)
-		return unless target.is_a?(AIMyBuilding)
-		if valid and target.valid
-			r=getRef(target)
-			if r
-				@ent.newHLTakeWeaponJob(r)
-			end
-		end
-	end
+  def takeWeapon(target)
+    return unless target.is_a?(AIMyBuilding)
+    if valid and target.valid
+      r=getRef(target)
+      if r
+        @ent.newHLTakeWeaponJob(r)
+      end
+    end
+  end
 
-	def attackAnimal(target)
-		return unless target.is_a?(AIAnimal)
-		if valid
-			r=getRef(target)
-			if r
-				@ent.newHLFightAnimalJob(r)
-			end
-		end
-	end
+  def attackAnimal(target)
+    return unless target.is_a?(AIAnimal)
+    if valid
+      r=getRef(target)
+      if r
+        @ent.newHLFightAnimalJob(r)
+      end
+    end
+  end
 
-	def build(place,type)
-		return unless place.is_a?(AGVector2) and type.is_a?(String)
-		if valid
-			ds=getDescendantsOfClass(AntHouse)
-			@map={}
-			ds.each{|d|
-				c=getChild(d.to_s)
-				if c
-					addHandler(c,:sigClick,:eventBuild)
-					@map[d.to_s]=d
-				end
-			}
-			type=@map[type]
-			if type
-				@ent.newHLBuildJob(place,type)
-			end
-		end
-	end
+  def build(place,type)
+    return unless place.is_a?(AGVector2) and type.is_a?(String)
+    if valid
+      ds=getDescendantsOfClass(AntHouse)
+      @map={}
+      ds.each{|d|
+        c=getChild(d.to_s)
+        if c
+          addHandler(c,:sigClick,:eventBuild)
+          @map[d.to_s]=d
+        end
+      }
+      type=@map[type]
+      if type
+        @ent.newHLBuildJob(place,type)
+      end
+    end
+  end
 
-	def rest(time)
-		return unless time.is_a?(Numeric)
-		if valid and time&gt;0
-			@ent.newHLRestJob(time)
-		end
-	end
+  def rest(time)
+    return unless time.is_a?(Numeric)
+    if valid and time&gt;0
+      @ent.newHLRestJob(time)
+    end
+  end
 
-	def getMorale
-		@ent.getMorale
-	end
+  def getMorale
+    @ent.getMorale
+  end
 
-	def getEnergy
-		@ent.getEnergy
-	end
-	def getFood
-		@ent.getFood
-	end
+  def getEnergy
+    @ent.getEnergy
+  end
+  def getFood
+    @ent.getFood
+  end
 end
 
 class AIEnemyPlayer
-	def initialize(player)
-		@player=player
-	end
-	def getHeroes
-		@player.getHeroes.map{|p|AIEnemyHero.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p, at player</A>)}
-	end
-	def getBuildings
-		@player.getBuildings.map{|p|AIEnemyBuilding.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p, at player</A>)}
-	end
-	def getName
-		@player.getName
-	end
+  def initialize(player)
+    @player=player
+  end
+  def getHeroes
+    @player.getHeroes.map{|p|AIEnemyHero.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p, at player</A>)}
+  end
+  def getBuildings
+    @player.getBuildings.map{|p|AIEnemyBuilding.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p, at player</A>)}
+  end
+  def getName
+    @player.getName
+  end
 end
 
 
 class AIEnemyEntity
-	def initialize(ent,player)
-		@ent=ent
-		@player=player
-	end
-	def getName
-		@ent.getName
-	end
-	def getPos
-		@ent.getPos2D
-	end
-	def uid
-		@ent.uid
-	end
-	def valid
-		@ent.getPlayer==@player
-	end
+  def initialize(ent,player)
+    @ent=ent
+    @player=player
+  end
+  def getName
+    @ent.getName
+  end
+  def getPos
+    @ent.getPos2D
+  end
+  def uid
+    @ent.uid
+  end
+  def valid
+    @ent.getPlayer==@player
+  end
 end
 
 class AIEnemy&lt;AIEnemyEntity
 end
 
 class AIEnemyHero&lt;AIEnemy
-	def menCount
-		@ent.getMen.length
-	end
+  def menCount
+    @ent.getMen.length
+  end
 end
 
 class AIEnemyBuilding&lt;AIEnemy
-	def menCount
-		@ent.getMen.length
-	end
+  def menCount
+    @ent.getMen.length
+  end
 end

Modified: antargis/trunk/ruby/ant_ai_player.rb
===================================================================
--- antargis/trunk/ruby/ant_ai_player.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_ai_player.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,82 +1,82 @@
 class AntAIPlayer
-	attr_accessor :ai
-	def initialize(name,map)
-		@heroes=[]
-		@heronames=[]
-		@name=name
-		@map=map
-		#@name=@ai.interface.myPlayer.getName
-	end
+  attr_accessor :ai
+  def initialize(name,map)
+    @heroes=[]
+    @heronames=[]
+    @name=name
+    @map=map
+    #@name=@ai.interface.myPlayer.getName
+  end
 
-	def getMap
-		@map
-	end
+  def getMap
+    @map
+  end
 
-	def saveXML(n)
-		n.set(&quot;name&quot;,name)
-		@heroes.each{|hero|
-			c=n.addChild(&quot;hero&quot;)
-			c.set(&quot;name&quot;,hero.getName)
-		}
-	end
-	def loadXML(n)
-		@name=n.get(&quot;name&quot;)
-		children=n.getChildren(&quot;hero&quot;)
-		children.each{|c|
-			@heronames.push(c.get(&quot;name&quot;))
-		}
-	end
+  def saveXML(n)
+    n.set(&quot;name&quot;,name)
+    @heroes.each{|hero|
+      c=n.addChild(&quot;hero&quot;)
+      c.set(&quot;name&quot;,hero.getName)
+    }
+  end
+  def loadXML(n)
+    @name=n.get(&quot;name&quot;)
+    children=n.getChildren(&quot;hero&quot;)
+    children.each{|c|
+      @heronames.push(c.get(&quot;name&quot;))
+    }
+  end
 
-	def move(time)
-		if @heronames.length then
-			@heronames.each{|n|
-				ent=getMap.getByName(n)
-				if ent.is_a?(AntBoss)
-					ent.setPlayer(self)
-					@heroes.push(ent)
-				else
-					puts &quot;HERO NOT FOUND: '#{n}'&quot;
-				end
-			}
-			@heronames.clear
-		end
-		@ai.eventFrame(time)
-	end
-	def getName
-		@name
-	end
-	
-	def assignJob(hero)
-		hero.newHLRestJob(20)
-	end
-	def trigger(ent,tr)
-	end
-	def remove(hero)
-		@heroes.delete(hero)
-	end
-	def add(hero)
-		@heroes.push(hero)
-		@heroes.uniq!
-	end
-	def getHeroes
-		getBosses.select{|b|b.is_a?(AntHero)}
-	end
-	def getBuildings
-		getBosses.select{|b|b.is_a?(AntHouse)}
-	end
+  def move(time)
+    if @heronames.length then
+      @heronames.each{|n|
+        ent=getMap.getByName(n)
+        if ent.is_a?(AntBoss)
+          ent.setPlayer(self)
+          @heroes.push(ent)
+        else
+          puts &quot;HERO NOT FOUND: '#{n}'&quot;
+        end
+      }
+      @heronames.clear
+    end
+    @ai.eventFrame(time)
+  end
+  def getName
+    @name
+  end
+  
+  def assignJob(hero)
+    hero.newHLRestJob(20)
+  end
+  def trigger(ent,tr)
+  end
+  def remove(hero)
+    @heroes.delete(hero)
+  end
+  def add(hero)
+    @heroes.push(hero)
+    @heroes.uniq!
+  end
+  def getHeroes
+    getBosses.select{|b|b.is_a?(AntHero)}
+  end
+  def getBuildings
+    getBosses.select{|b|b.is_a?(AntHouse)}
+  end
 
-	def getBosses
-		@heroes.uniq!
-		@heroes.clone
-	end
+  def getBosses
+    @heroes.uniq!
+    @heroes.clone
+  end
 
 
-	def eventJobFinished(hero,lastJob)
-		if hero.is_a?(AntHero)
-			h=AIMyHero.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero,self, at map</A>)
-			raise &quot;Hero is not valid&quot; unless h.valid
-			@ai.eventHeroWithoutJob(h)
-		end
-	end
+  def eventJobFinished(hero,lastJob)
+    if hero.is_a?(AntHero)
+      h=AIMyHero.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero,self, at map</A>)
+      raise &quot;Hero is not valid&quot; unless h.valid
+      @ai.eventHeroWithoutJob(h)
+    end
+  end
 
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_ai_rules.rb
===================================================================
--- antargis/trunk/ruby/ant_ai_rules.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_ai_rules.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -26,89 +26,89 @@
 
 
 class AICondition
-	attr_accessor :interface
-	def value(hero)
-		return 1
-	end
+  attr_accessor :interface
+  def value(hero)
+    return 1
+  end
 end
 
 class AIConditionFoodLow&lt;AICondition
-	def value(hero)
-		puts &quot;FOOD LOW ???&quot;
-		if hero.resources(&quot;food&quot;)&lt;5
-			puts &quot;YES&quot;
-			if hero.findNearResource(&quot;food&quot;).nil?
-				puts &quot;BUT NOTHING NEAR!!&quot;
-				if hero.resources(&quot;food&quot;)&lt;1
-					puts &quot;TOO LAZY TO WALK _ just dying!!&quot;
-					return 1
-				end
-				return 0
-			end
-			return 1
-		else
-			puts &quot;NO&quot;
-			return 0
-		end
-	end
+  def value(hero)
+    puts &quot;FOOD LOW ???&quot;
+    if hero.resources(&quot;food&quot;)&lt;5
+      puts &quot;YES&quot;
+      if hero.findNearResource(&quot;food&quot;).nil?
+        puts &quot;BUT NOTHING NEAR!!&quot;
+        if hero.resources(&quot;food&quot;)&lt;1
+          puts &quot;TOO LAZY TO WALK _ just dying!!&quot;
+          return 1
+        end
+        return 0
+      end
+      return 1
+    else
+      puts &quot;NO&quot;
+      return 0
+    end
+  end
 end
 
 class AIEveryNthCondition&lt;AICondition
-	def initialize(nth)
-		@nth=nth
-		@v=0
-	end
-	def value(hero)
-		@v+=1
-		@v%=@nth
-		return @v==0?1:0
-	end
+  def initialize(nth)
+    @nth=nth
+    @v=0
+  end
+  def value(hero)
+    @v+=1
+    @v%=@nth
+    return @v==0?1:0
+  end
 end
 
 
 # Dummy Action - does nothing at all
 class AIAction
-	attr_accessor :interface
-	def execute(interface,hero)
-	end
+  attr_accessor :interface
+  def execute(interface,hero)
+  end
 end
 
 # get food from some building which is owned by the hero
 class AIGatherFoodAction&lt;AIAction
-	def execute(hero)
-		unit=hero.findNearResource(&quot;food&quot;)
-		puts &quot;HERO TAKES FOOD&quot;
-		hero.takeFood(unit)
-	end
+  def execute(hero)
+    unit=hero.findNearResource(&quot;food&quot;)
+    puts &quot;HERO TAKES FOOD&quot;
+    hero.takeFood(unit)
+  end
 end
 
 # rest for a second
 class AIRestAction&lt;AIAction
-	def execute(hero)
-		hero.rest(10)
-	end
+  def execute(hero)
+    hero.rest(10)
+  end
 end
 
 class AIAttackAction&lt;AIAction
-	def execute(hero)
-		e=findUsableEnemy(hero)
-		if e
-			hero.attack(e)
-		end
-	end
-	private
-	def findUsableEnemy(hero)
-		enemyPlayers=@interface.enemyPlayers
-		allEnemyHeroes=enemyPlayers.collect{|p|p.getHeroes+p.getBuildings}.flatten
-		allEnemyHeroes.sort!{|a,b|a.menCount&lt;=&gt;b.menCount}
-		e=allEnemyHeroes[0]
-		if e
-			if e.menCount&gt;hero.menCount
-				e=nil
-			end
-		end
-		e
-	end
+  def execute(hero)
+    e=findUsableEnemy(hero)
+    if e
+      hero.attack(e)
+    end
+  end
+  private
+  def findUsableEnemy(hero)
+    enemyPlayers=@interface.enemyPlayers
+    allEnemyHeroes=enemyPlayers.collect{|p|p.getHeroes+p.getBuildings}.flatten
+    allEnemyHeroes.sort!{|a,b|a.menCount&lt;=&gt;b.menCount}
+    e=allEnemyHeroes[0]
+    if e
+      if e.menCount&gt;hero.menCount
+        e=nil
+      end
+    end
+    e
+  end
 end
 
 # build up a rule out of a condition and one or more actions:
@@ -116,20 +116,20 @@
 # or
 # AIRule.new(AICondition.new,[AIRestAction.new,Someotheraction.new])
 class AIRule
-	def initialize(condition,actions,interface)
-		@c=condition
-		@a=actions
-		@c.interface=interface
-		@a.interface=interface
-	end
-	def value(hero)
-		@c.value(hero)
-	end
-	def execute(hero)
-		if @a.is_a?(Array)
-			@a.each{|a|a.execute(hero)}
-		else
-			@a.execute(hero)
-		end
-	end
+  def initialize(condition,actions,interface)
+    @c=condition
+    @a=actions
+    @c.interface=interface
+    @a.interface=interface
+  end
+  def value(hero)
+    @c.value(hero)
+  end
+  def execute(hero)
+    if @a.is_a?(Array)
+      @a.each{|a|a.execute(hero)}
+    else
+      @a.execute(hero)
+    end
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_buildjob.rb
===================================================================
--- antargis/trunk/ruby/ant_buildjob.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_buildjob.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,237 +1,237 @@
 class AntHeroBuildJob&lt;AntHeroMoveJob
-	FARTHEST_AWAY=40
+  FARTHEST_AWAY=40
 
-	attr_reader :finished
-	def initialize(hero,targetpos,building)
+  attr_reader :finished
+  def initialize(hero,targetpos,building)
 
 
-		tpos=targetpos
-		tpos=targetpos.getPos2D if targetpos.is_a?(AntBuildingSite)
-		super(hero,0,tpos,5)
-		@targetpos=tpos
-		@building=building
-		@usedmen=0
+    tpos=targetpos
+    tpos=targetpos.getPos2D if targetpos.is_a?(AntBuildingSite)
+    super(hero,0,tpos,5)
+    @targetpos=tpos
+    @building=building
+    @usedmen=0
 
-		@restype={}
-		
-		@flat=0
+    @restype={}
+    
+    @flat=0
 
-		if targetpos.is_a?(AntBuildingSite)
-			@target=targetpos
-			@building=@target.building
-		else
-			# make buildingsite
-			@target=AntBuildingSite.new(getMap)
-			@target.setPos(targetpos)
-			@target.building=building
-			getMap.insertEntity(@target)
-		end
-	end
-	def image
-		&quot;data/gui/build.png&quot;
-	end
-	def check(man)
-		if moveFinished
-			@hero.formation=AntFormationRest.new(@hero)
-			if man.is_a?(AntBoss)
-				checkEat(man)
-				if not @constructStarted
-					@men.each{|m|m.delJob}
-					@constructStarted=true
-				end
-				man.newRestJob(20) # do nothing at all
-				return
-			end
-			@constructStarted=true
-			wantmen=(@men.length-1)*@hero.getAggression/3.0
-			case man.getMode
-				when &quot;fetch&quot; # go to resource
-					res=getNeededResources
-					res,nearest=getNextWithResource(res)
-					@restype[man]=[res,nearest]
-					if nearest.nil?
-						puts &quot;resource not found! #{res}&quot;
-						man.newRestJob(5)
-					else
-						if (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">nearest.getPos2D- at target.getPos2D</A>).length&lt;FARTHEST_AWAY
-							man.newMoveJob(0,nearest.getPos2D,0.5) # near but not actually there
-							man.setMode(&quot;harvest&quot;)
-						else
-							man.newRestJob(1)
-							puts &quot;TOO FAR&quot;
-						end
-					end
-				when &quot;harvest&quot; # harvest resource
-					if (@restype[man][1].getPos2D-man.getPos2D).length&lt;3
-						man.newRestJob(2)
-						man.digResource(@restype[man][0])
-						man.setMode(&quot;collect&quot;)
-					else
-						puts &quot;WAS TOO FAR AWAY - Probably job discarded&quot;
-						man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,0)
-						man.setMode(&quot;&quot;)
-					end
-				when &quot;collect&quot; # bring back
-					# FIXME: add sub resource from nearest
-					p=@restype[man]
-					amount=[p[1].resource.get(p[0]),man.canCarry].min
-					p[1].resource.sub(p[0],amount)
-					man.resource.add(p[0],amount)
-					man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,0)
-					man.collectResource(@restype[man][0])
-					man.setMode(&quot;brought&quot;)
-				when &quot;brought&quot;
-					man.setMode(&quot;after_brought&quot;)
-					man.newRestJob(1)
-					# take all natural resources - but not food and weapons - otherwise men starve!
-					myResources.each{|r|
-						@target.resource.take(man.resource,r)
-					}
-				when &quot;after_brought&quot;
-					fpos=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at hero.getPos2D</A>)
-					man.newMoveJob(0,fpos,0)
-					man.setMode(&quot;construct_torest&quot;)
-				when &quot;goto_construct&quot;
-					man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at targetpos</A>,0)
-					man.setMode(&quot;to_construct&quot;)
-				when &quot;to_construct&quot;  # do some constructing
-					#@target.incSmoke
-					man.newRestJob(5 - @hero.getAggression*0.5) # work for 3.5-5 seconds (depending on aggression)
-					man.setMode(&quot;constructing&quot;)
-					man.playSound(&quot;construct&quot;)
-					man.setMeshState(&quot;pick&quot;) # FIXME: add hammering
-				when &quot;constructing&quot;
-					# was constructing
-					readyConstructed
-					man.incExperience(man.learnAmount)
-					#@target.decSmoke
-					man.setMode(&quot;construct_torest&quot;)
-					fpos=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at hero.getPos2D</A>)
-					man.newMoveJob(0,fpos,0)
-				when &quot;construct_torest&quot;
-					man.setMode(&quot;rest&quot;)
-					man.newRestJob(3/@hero.getAggression) # shorter pauses when aggression is higher
-					if man.getAggression&lt;3
-						checkEat(man)
-					end
-					@usedmen-=1
-				else
-					if wantmen&gt;@usedmen
-						@usedmen+=1
-						man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at targetpos</A>,0)
-						if enoughResources
-							man.setMode(&quot;goto_construct&quot;)
-						else
-							man.setMode(&quot;fetch&quot;)
-						end
-					end
-			end
-		else
-			super(man)
-		end
-	end
+    if targetpos.is_a?(AntBuildingSite)
+      @target=targetpos
+      @building=@target.building
+    else
+      # make buildingsite
+      @target=AntBuildingSite.new(getMap)
+      @target.setPos(targetpos)
+      @target.building=building
+      getMap.insertEntity(@target)
+    end
+  end
+  def image
+    &quot;data/gui/build.png&quot;
+  end
+  def check(man)
+    if moveFinished
+      @hero.formation=AntFormationRest.new(@hero)
+      if man.is_a?(AntBoss)
+        checkEat(man)
+        if not @constructStarted
+          @men.each{|m|m.delJob}
+          @constructStarted=true
+        end
+        man.newRestJob(20) # do nothing at all
+        return
+      end
+      @constructStarted=true
+      wantmen=(@men.length-1)*@hero.getAggression/3.0
+      case man.getMode
+        when &quot;fetch&quot; # go to resource
+          res=getNeededResources
+          res,nearest=getNextWithResource(res)
+          @restype[man]=[res,nearest]
+          if nearest.nil?
+            puts &quot;resource not found! #{res}&quot;
+            man.newRestJob(5)
+          else
+            if (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">nearest.getPos2D- at target.getPos2D</A>).length&lt;FARTHEST_AWAY
+              man.newMoveJob(0,nearest.getPos2D,0.5) # near but not actually there
+              man.setMode(&quot;harvest&quot;)
+            else
+              man.newRestJob(1)
+              puts &quot;TOO FAR&quot;
+            end
+          end
+        when &quot;harvest&quot; # harvest resource
+          if (@restype[man][1].getPos2D-man.getPos2D).length&lt;3
+            man.newRestJob(2)
+            man.digResource(@restype[man][0])
+            man.setMode(&quot;collect&quot;)
+          else
+            puts &quot;WAS TOO FAR AWAY - Probably job discarded&quot;
+            man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,0)
+            man.setMode(&quot;&quot;)
+          end
+        when &quot;collect&quot; # bring back
+          # FIXME: add sub resource from nearest
+          p=@restype[man]
+          amount=[p[1].resource.get(p[0]),man.canCarry].min
+          p[1].resource.sub(p[0],amount)
+          man.resource.add(p[0],amount)
+          man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,0)
+          man.collectResource(@restype[man][0])
+          man.setMode(&quot;brought&quot;)
+        when &quot;brought&quot;
+          man.setMode(&quot;after_brought&quot;)
+          man.newRestJob(1)
+          # take all natural resources - but not food and weapons - otherwise men starve!
+          myResources.each{|r|
+            @target.resource.take(man.resource,r)
+          }
+        when &quot;after_brought&quot;
+          fpos=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at hero.getPos2D</A>)
+          man.newMoveJob(0,fpos,0)
+          man.setMode(&quot;construct_torest&quot;)
+        when &quot;goto_construct&quot;
+          man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at targetpos</A>,0)
+          man.setMode(&quot;to_construct&quot;)
+        when &quot;to_construct&quot;  # do some constructing
+          #@target.incSmoke
+          man.newRestJob(5 - @hero.getAggression*0.5) # work for 3.5-5 seconds (depending on aggression)
+          man.setMode(&quot;constructing&quot;)
+          man.playSound(&quot;construct&quot;)
+          man.setMeshState(&quot;pick&quot;) # FIXME: add hammering
+        when &quot;constructing&quot;
+          # was constructing
+          readyConstructed
+          man.incExperience(man.learnAmount)
+          #@target.decSmoke
+          man.setMode(&quot;construct_torest&quot;)
+          fpos=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at hero.getPos2D</A>)
+          man.newMoveJob(0,fpos,0)
+        when &quot;construct_torest&quot;
+          man.setMode(&quot;rest&quot;)
+          man.newRestJob(3/@hero.getAggression) # shorter pauses when aggression is higher
+          if man.getAggression&lt;3
+            checkEat(man)
+          end
+          @usedmen-=1
+        else
+          if wantmen&gt;@usedmen
+            @usedmen+=1
+            man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at targetpos</A>,0)
+            if enoughResources
+              man.setMode(&quot;goto_construct&quot;)
+            else
+              man.setMode(&quot;fetch&quot;)
+            end
+          end
+      end
+    else
+      super(man)
+    end
+  end
 private
-	def myResources
-		[&quot;wood&quot;,&quot;stone&quot;]
-	end
-	def enoughResources
-		# FIXME support more resources
-		m=myResources.min{|a,b|@target.resource.get(a)&lt;=&gt;@target.resource.get(b)}
-		value=@target.resource.get(m)
-		return value&gt;5
-		#(@target.resource.get(&quot;stone&quot;)&gt;5 and @target.resource.get(&quot;wood&quot;)&gt;5)
-	end
-	def getNeededResources
-		m=myResources.sort{|a,b|@target.resource.get(a)&lt;=&gt;@target.resource.get(b)}
-		puts &quot;NEEDED: #{m}&quot;
-		return m
-	end
-	def getNextWithResource(res)
-		#goods={&quot;wood&quot;=&gt;&quot;tree&quot;,&quot;stone&quot;=&gt;&quot;stone&quot;,&quot;food&quot;=&gt;&quot;tree&quot;,&quot;coal&quot;=&gt;&quot;mine&quot;,&quot;ore&quot;=&gt;&quot;mine&quot;}
-		#enttype=goods[res]
-		ret=nil
-		res.each{|r|
-			ret=getMap.getNext(@target,r,1)
-			if not ret.nil?
-				ret=[r,ret]
-				break
-			end
-		}
+  def myResources
+    [&quot;wood&quot;,&quot;stone&quot;]
+  end
+  def enoughResources
+    # FIXME support more resources
+    m=myResources.min{|a,b|@target.resource.get(a)&lt;=&gt;@target.resource.get(b)}
+    value=@target.resource.get(m)
+    return value&gt;5
+    #(@target.resource.get(&quot;stone&quot;)&gt;5 and @target.resource.get(&quot;wood&quot;)&gt;5)
+  end
+  def getNeededResources
+    m=myResources.sort{|a,b|@target.resource.get(a)&lt;=&gt;@target.resource.get(b)}
+    puts &quot;NEEDED: #{m}&quot;
+    return m
+  end
+  def getNextWithResource(res)
+    #goods={&quot;wood&quot;=&gt;&quot;tree&quot;,&quot;stone&quot;=&gt;&quot;stone&quot;,&quot;food&quot;=&gt;&quot;tree&quot;,&quot;coal&quot;=&gt;&quot;mine&quot;,&quot;ore&quot;=&gt;&quot;mine&quot;}
+    #enttype=goods[res]
+    ret=nil
+    res.each{|r|
+      ret=getMap.getNext(@target,r,1)
+      if not ret.nil?
+        ret=[r,ret]
+        break
+      end
+    }
 
-		ret
-	end
-	def checkEat(man)
-		puts &quot;CHECKEAT&quot;
-		if man.getFood&lt;0.5
-			if man.resource.get(&quot;food&quot;)&gt;0
-				man.incFood(1)
-				man.resource.sub(&quot;food&quot;,1)
-			elsif heroHasFood
-				man.incFood(1)
-				@hero.resource.sub(&quot;food&quot;,1)
-			end
-		end
-	end
-	def heroHasFood
-		@hero.resource.get(&quot;food&quot;)&gt;0
-	end
-	def readyConstructed
+    ret
+  end
+  def checkEat(man)
+    puts &quot;CHECKEAT&quot;
+    if man.getFood&lt;0.5
+      if man.resource.get(&quot;food&quot;)&gt;0
+        man.incFood(1)
+        man.resource.sub(&quot;food&quot;,1)
+      elsif heroHasFood
+        man.incFood(1)
+        @hero.resource.sub(&quot;food&quot;,1)
+      end
+    end
+  end
+  def heroHasFood
+    @hero.resource.get(&quot;food&quot;)&gt;0
+  end
+  def readyConstructed
 
-		px=@targetpos.x.to_i+1
-		py=@targetpos.y.to_i+1
-		if @flatpositions.nil?
-			@flatpositions=[]
-			(-3..3).each{|y|
-				(-3..3).each{|x|
-					v=1-Math::sqrt(x**2+y**2)/4.0
-					v=[0,1,v*1.5].sort[1]
-					@flatpositions.push([x+px,y+py,v])
-				}
-			}
-			@flatheight=getMap.get(px,py)
-			@flatpositions.shuffle
-		end
+    px=@targetpos.x.to_i+1
+    py=@targetpos.y.to_i+1
+    if @flatpositions.nil?
+      @flatpositions=[]
+      (-3..3).each{|y|
+        (-3..3).each{|x|
+          v=1-Math::sqrt(x**2+y**2)/4.0
+          v=[0,1,v*1.5].sort[1]
+          @flatpositions.push([x+px,y+py,v])
+        }
+      }
+      @flatheight=getMap.get(px,py)
+      @flatpositions.shuffle
+    end
 
 
-		
-		if @flatpositions.length&gt;0
-			(0..1).each{|i|
-				break if @flatpositions.length==0
-				p=@flatpositions.shift
-				v=getMap.get(p[0],p[1])*(1-p[2])<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">+ at flatheight</A>*p[2]
-				getMap.set(p[0],p[1],v)
-				v=getMap.getTerrain(p[0],p[1],EARTH)*(1-p[2])+p[2]
-				getMap.setTerrain(p[0],p[1],EARTH,v)
-			}
-			getMap.endChange
-			return
-		end
+    
+    if @flatpositions.length&gt;0
+      (0..1).each{|i|
+        break if @flatpositions.length==0
+        p=@flatpositions.shift
+        v=getMap.get(p[0],p[1])*(1-p[2])<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">+ at flatheight</A>*p[2]
+        getMap.set(p[0],p[1],v)
+        v=getMap.getTerrain(p[0],p[1],EARTH)*(1-p[2])+p[2]
+        getMap.setTerrain(p[0],p[1],EARTH,v)
+      }
+      getMap.endChange
+      return
+    end
 
 
 
-		#neededResources={&quot;stone&quot;=&gt;2,&quot;wood&quot;=&gt;2} # FIXME: depends on house-type
-		neededResources=@building.buildResources
-	
-		neededResources.each{|k,v|
-			if @target.resource.get(k)&lt;v
-				return # oooooh
-			end
-		}
-		neededResources.each{|k,v|
-			@target.resource.sub(k,v)
-		}
-		@target.incProgress(@building.buildSteps)
-		
-		if @target.ready
-			# delete buildingsite and replace with building
-			getMap.removeEntity(@target)
-			house=@building.new
-			house.setPos(@targetpos)
-			getMap.insertEntity(house)
-			house.setPlayer(@hero.getPlayer)
-			house.setName(house.class.to_s.gsub(&quot;Ant&quot;,&quot;&quot;))
-			house.resource.takeAll(@target.resource) # give remaining resources to house
-			@finished=true
-		end
-	end
+    #neededResources={&quot;stone&quot;=&gt;2,&quot;wood&quot;=&gt;2} # FIXME: depends on house-type
+    neededResources=@building.buildResources
+  
+    neededResources.each{|k,v|
+      if @target.resource.get(k)&lt;v
+        return # oooooh
+      end
+    }
+    neededResources.each{|k,v|
+      @target.resource.sub(k,v)
+    }
+    @target.incProgress(@building.buildSteps)
+    
+    if @target.ready
+      # delete buildingsite and replace with building
+      getMap.removeEntity(@target)
+      house=@building.new
+      house.setPos(@targetpos)
+      getMap.insertEntity(house)
+      house.setPlayer(@hero.getPlayer)
+      house.setName(house.class.to_s.gsub(&quot;Ant&quot;,&quot;&quot;))
+      house.resource.takeAll(@target.resource) # give remaining resources to house
+      @finished=true
+    end
+  end
 end

Modified: antargis/trunk/ruby/ant_debug.rb
===================================================================
--- antargis/trunk/ruby/ant_debug.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_debug.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,33 +1,33 @@
 $debug||=false
 if $debug
-	module Kernel
-		def invoker(levels = -1)
-			st = Thread.current[:callstack]
-			st &amp;&amp; st[levels - 3]
-		end
-	end
-	
-	set_trace_func proc {|*args|
-		Thread.current[:callstack] ||=[]
-		case args[0]
-		when /call$/
-			Thread.current[:callstack].push args
-		when /return$/
-			Thread.current[:callstack].pop
-		when /line$/
-			Thread.current[:callstack].pop
-			Thread.current[:callstack].push args
-		end
-	}
-	
-	def dputs(*a)
-		i=invoker
-		t=&quot;[&quot;+i[1].to_s+&quot;:&quot;+i[2].to_s+&quot; &quot;+i[3].to_s+&quot;]&quot;
-		puts t+&quot; &quot;+a.join(&quot;;&quot;)
-	end
-	
+  module Kernel
+    def invoker(levels = -1)
+      st = Thread.current[:callstack]
+      st &amp;&amp; st[levels - 3]
+    end
+  end
+  
+  set_trace_func proc {|*args|
+    Thread.current[:callstack] ||=[]
+    case args[0]
+    when /call$/
+      Thread.current[:callstack].push args
+    when /return$/
+      Thread.current[:callstack].pop
+    when /line$/
+      Thread.current[:callstack].pop
+      Thread.current[:callstack].push args
+    end
+  }
+  
+  def dputs(*a)
+    i=invoker
+    t=&quot;[&quot;+i[1].to_s+&quot;:&quot;+i[2].to_s+&quot; &quot;+i[3].to_s+&quot;]&quot;
+    puts t+&quot; &quot;+a.join(&quot;;&quot;)
+  end
+  
 else
-	def dputs(*a)
-		puts a.join(&quot;;&quot;)
-	end
+  def dputs(*a)
+    puts a.join(&quot;;&quot;)
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_energy.rb
===================================================================
--- antargis/trunk/ruby/ant_energy.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_energy.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,101 +1,101 @@
 # Inventory view
 class AntEnergy&lt;AGWidget
-	attr_accessor :hborder
-	attr_accessor :vborder
-	def initialize(p,rect)
-		super(p,rect)
+  attr_accessor :hborder
+  attr_accessor :vborder
+  def initialize(p,rect)
+    super(p,rect)
 
-		@keys=[:energy,:morale,:food,:troops,:exp]
-		@values={}
-		@colors={}
-		@keys.each{|k|@values[k]=0}
+    @keys=[:energy,:morale,:food,:troops,:exp]
+    @values={}
+    @colors={}
+    @keys.each{|k|@values[k]=0}
 
-		@colors[:troops]=AGColor.new(0xcf,0,0)
-		@colors[:energy]=AGColor.new(0,0xcf,0)
-		@colors[:morale]=AGColor.new(&quot;#0000FF&quot;)
-		@colors[:morale_defeated]=AGColor.new(&quot;#5555ff&quot;)
-		@colors[:food]=AGColor.new(&quot;#975500&quot;)
-		@colors[:exp]=AGColor.new(&quot;#FFFFFF&quot;)
-		@hborder=0
-		@vborder=0
+    @colors[:troops]=AGColor.new(0xcf,0,0)
+    @colors[:energy]=AGColor.new(0,0xcf,0)
+    @colors[:morale]=AGColor.new(&quot;#0000FF&quot;)
+    @colors[:morale_defeated]=AGColor.new(&quot;#5555ff&quot;)
+    @colors[:food]=AGColor.new(&quot;#975500&quot;)
+    @colors[:exp]=AGColor.new(&quot;#FFFFFF&quot;)
+    @hborder=0
+    @vborder=0
 
-		#setCaching(true)
-		@hero=nil
-	end
+    #setCaching(true)
+    @hero=nil
+  end
 
-	def setHero(h)
-		@hero=h
-	end
-	
-	def eventTick(t)
-		updateValues
-		super
-	end
+  def setHero(h)
+    @hero=h
+  end
+  
+  def eventTick(t)
+    updateValues
+    super
+  end
 
-	def draw(p)
-		super
-		r=p.getRect.origin
-		w=r.width
-		h=<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">r.height- at vborder</A>
+  def draw(p)
+    super
+    r=p.getRect.origin
+    w=r.width
+    h=<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">r.height- at vborder</A>
 
-		v=@vborder/2
+    v=@vborder/2
 
-		mh=h/(@values.length*3)
-		
-		i=0
-		@keys.each{|k|
-			v=check(@values[k])
-			if v&lt;0
-				puts v
-				raise 1
-			end
-			if k==:morale and @hero.defeated
-				c=@colors[:morale_defeated]
-			else
-				c=@colors[k]
-			end
-			a0=c*0.7
-			a1=c*0.7
-			a2=c*1.0
-			a3=c*0.8
-		
-			mr=AGRect2.new(@hborder,i*mh,(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">w- at hborder</A>*2)*v,mh*2)
+    mh=h/(@values.length*3)
+    
+    i=0
+    @keys.each{|k|
+      v=check(@values[k])
+      if v&lt;0
+        puts v
+        raise 1
+      end
+      if k==:morale and @hero.defeated
+        c=@colors[:morale_defeated]
+      else
+        c=@colors[k]
+      end
+      a0=c*0.7
+      a1=c*0.7
+      a2=c*1.0
+      a3=c*0.8
+    
+      mr=AGRect2.new(@hborder,i*mh,(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">w- at hborder</A>*2)*v,mh*2)
 
-			p.drawGradient(mr,a0,a1,a2,a3)
-			i+=3
-		}
-	end
+      p.drawGradient(mr,a0,a1,a2,a3)
+      i+=3
+    }
+  end
 private
-	def check(s)
-		[0,s,1].sort[1]
-	end
-	def set(n,v)
-		o=@values[n]
-		if ((o-v).abs&gt;0.1) or (o!=v and (v==0 or v==1))
-			queryRedraw
-			@values[n]=v
-		end
-	end
-	def updateValues
-		if @hero
-			set(:<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">energy, at hero.getEnergy</A>)
-			set(:<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">morale, at hero.getMorale</A>)
-			set(:<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">troops, at hero.getMen.length</A>/60.0)
-			set(:<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">food, at hero.getFood</A>)
-			set(:<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">exp, at hero.experience</A>)
-		else
-			@values.each{|k,v|@values[k]=1}
-		end
-	end
+  def check(s)
+    [0,s,1].sort[1]
+  end
+  def set(n,v)
+    o=@values[n]
+    if ((o-v).abs&gt;0.1) or (o!=v and (v==0 or v==1))
+      queryRedraw
+      @values[n]=v
+    end
+  end
+  def updateValues
+    if @hero
+      set(:<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">energy, at hero.getEnergy</A>)
+      set(:<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">morale, at hero.getMorale</A>)
+      set(:<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">troops, at hero.getMen.length</A>/60.0)
+      set(:<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">food, at hero.getFood</A>)
+      set(:<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">exp, at hero.experience</A>)
+    else
+      @values.each{|k,v|@values[k]=1}
+    end
+  end
 end
 
 class AntEnergyCreator&lt;AGLayoutCreator
-	def create(parent,rect,node)
-		w=AntEnergy.new(parent,rect)
-		w.hborder=node.get(&quot;hborder&quot;).to_i
-		w.vborder=node.get(&quot;vborder&quot;).to_i
-		setResult w
-	end
+  def create(parent,rect,node)
+    w=AntEnergy.new(parent,rect)
+    w.hborder=node.get(&quot;hborder&quot;).to_i
+    w.vborder=node.get(&quot;vborder&quot;).to_i
+    setResult w
+  end
 end
 getLayoutFactory.addCreator(&quot;antEnergy&quot;,AntEnergyCreator.new)
 

Modified: antargis/trunk/ruby/ant_formations.rb
===================================================================
--- antargis/trunk/ruby/ant_formations.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_formations.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -19,201 +19,201 @@
 #
 
 class AntFormation
-	def initialize(boss)
-		@boss=boss
-		@cache={}
-		@sorted=nil
-		@inited=false
-		calcFormation
-	end
-	def calcFormation
-	end
-	
-	
-	def getPosition(man,pos)
-		if pos.nil?
-			raise &quot;pos nil&quot;
-		end
-		# clear cache if men have changed
-		if changedMen
-		  @cache={}
-	    end
-		if @cache.member?(man)
-			return @cache[man]+pos
-		end
-		r=getPositionReal(man)
-		if r.nil?
-			calcFormation # try to recalc formation
-			r=getPositionReal(man)
-			if r.nil?
-				if not @boss.getMen.member?(man)
-					puts &quot;/// #{man} #{@boss}&quot;
-					puts &quot;MAN:&quot;,man.uid,&quot; BOSS:&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at boss.uid</A>
-					puts &quot;MEN:&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at boss.getMen.collect</A>{|m|m.uid.to_s}.join(&quot; &quot;)
-					raise &quot;Man #{man} is not member of #{@boss}'s men!&quot;
-				end
-				raise &quot;Problem in AntFormation!&quot;
-			end
-		end
-		@cache[man]=r
-		ret= r+pos
-		puts &quot;RET:#{ret}=#{r}+#{pos}&quot;
-		ret
-	end
-	def getSortedMen
-		if @sorted.nil?
-			@sorted=sort(@boss.getMen)
-		end
-		@sorted
-	end
-	def sort(men)
-		raise &quot;not implemented&quot;
-	end
-	
+  def initialize(boss)
+    @boss=boss
+    @cache={}
+    @sorted=nil
+    @inited=false
+    calcFormation
+  end
+  def calcFormation
+  end
+  
+  
+  def getPosition(man,pos)
+    if pos.nil?
+      raise &quot;pos nil&quot;
+    end
+    # clear cache if men have changed
+    if changedMen
+      @cache={}
+      end
+    if @cache.member?(man)
+      return @cache[man]+pos
+    end
+    r=getPositionReal(man)
+    if r.nil?
+      calcFormation # try to recalc formation
+      r=getPositionReal(man)
+      if r.nil?
+        if not @boss.getMen.member?(man)
+          puts &quot;/// #{man} #{@boss}&quot;
+          puts &quot;MAN:&quot;,man.uid,&quot; BOSS:&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at boss.uid</A>
+          puts &quot;MEN:&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at boss.getMen.collect</A>{|m|m.uid.to_s}.join(&quot; &quot;)
+          raise &quot;Man #{man} is not member of #{@boss}'s men!&quot;
+        end
+        raise &quot;Problem in AntFormation!&quot;
+      end
+    end
+    @cache[man]=r
+    ret= r+pos
+    puts &quot;RET:#{ret}=#{r}+#{pos}&quot;
+    ret
+  end
+  def getSortedMen
+    if @sorted.nil?
+      @sorted=sort(@boss.getMen)
+    end
+    @sorted
+  end
+  def sort(men)
+    raise &quot;not implemented&quot;
+  end
+  
 
     def changedMen
         nmen=sort(@boss.getMen-[@boss])
         @men!=nmen
-    end	
+    end  
 end
 
 #
 # *a* has better weaponry than *b*
 def betterWeapons(a,b)
-	weapons=[&quot;bow&quot;,&quot;sword&quot;]
-	weapons.each{|w|
-		r=(a.resource.get(w)&lt;=&gt;b.resource.get(w))
-		if r!=0
-			return r
-		end
-	}
-	return 0
+  weapons=[&quot;bow&quot;,&quot;sword&quot;]
+  weapons.each{|w|
+    r=(a.resource.get(w)&lt;=&gt;b.resource.get(w))
+    if r!=0
+      return r
+    end
+  }
+  return 0
 
 end
 
 
 class AntFormationRest&lt;AntFormation
-	def initialize(boss)
-		super(boss)
-		puts &quot;new formation&quot;
-	end
+  def initialize(boss)
+    super(boss)
+    puts &quot;new formation&quot;
+  end
 
-	def calcFormation
-		puts &quot;calcFormation&quot;
-		@rpos={} # real positions as map from man to AGVector2
-		vpos={}  # virtual positions as map from man to pair of [row,line (circle)]
+  def calcFormation
+    puts &quot;calcFormation&quot;
+    @rpos={} # real positions as map from man to AGVector2
+    vpos={}  # virtual positions as map from man to pair of [row,line (circle)]
 
-		men=sort(@boss.getMen)
-		@men=men
+    men=sort(@boss.getMen)
+    @men=men
 
-		linesizes={}
-		line=1
-		row=0
-		men.delete(@boss)
-		men.each{|m|
-			vpos[m]=[row,line]
-			linesizes[line]||=0
-			linesizes[line]+=1
-			row+=1
-			if row&gt;getRowsOfLine(line)  # add check for new weapon group here
-				row-=getRowsOfLine(line)
-				line+=1
-			end
-		}
-		men.each{|m|
-			row,line=vpos[m]
-			radius=line*1.2
-			angle=row.to_f/linesizes[line]*Math::PI*2
-			puts &quot;#{m} #{row} #{line} #{angle} #{radius} #{linesizes[line]}&quot;
-			@rpos[m]=AGVector2.new(Math::cos(angle)*radius,Math::sin(angle)*radius)
-			#puts &quot;SET:#{m}&quot;
-		}
-		@rpos[@boss]=AGVector2.new(0,0)
-		if @men.length&gt;0
-			@inited=true
-		end
-		
-		@rpos.keys.each{|key|
-			puts &quot;FORMAT #{key} : #{@rpos[key]}&quot;
-		}
-		
-	end
-	def getPositionReal(man)
-		if (not @inited) or changedMen
-			calcFormation
-		end
-		return @rpos[man]
-	end
-		
-	private
-	
+    linesizes={}
+    line=1
+    row=0
+    men.delete(@boss)
+    men.each{|m|
+      vpos[m]=[row,line]
+      linesizes[line]||=0
+      linesizes[line]+=1
+      row+=1
+      if row&gt;getRowsOfLine(line)  # add check for new weapon group here
+        row-=getRowsOfLine(line)
+        line+=1
+      end
+    }
+    men.each{|m|
+      row,line=vpos[m]
+      radius=line*1.2
+      angle=row.to_f/linesizes[line]*Math::PI*2
+      puts &quot;#{m} #{row} #{line} #{angle} #{radius} #{linesizes[line]}&quot;
+      @rpos[m]=AGVector2.new(Math::cos(angle)*radius,Math::sin(angle)*radius)
+      #puts &quot;SET:#{m}&quot;
+    }
+    @rpos[@boss]=AGVector2.new(0,0)
+    if @men.length&gt;0
+      @inited=true
+    end
+    
+    @rpos.keys.each{|key|
+      puts &quot;FORMAT #{key} : #{@rpos[key]}&quot;
+    }
+    
+  end
+  def getPositionReal(man)
+    if (not @inited) or changedMen
+      calcFormation
+    end
+    return @rpos[man]
+  end
+    
+  private
+  
 
-	def getRowsOfLine(line)
-		{1=&gt;10,2=&gt;14,3=&gt;20,4=&gt;40}[line]
-	end
+  def getRowsOfLine(line)
+    {1=&gt;10,2=&gt;14,3=&gt;20,4=&gt;40}[line]
+  end
 
-	def sort(men)
-		men.sort{|a,b|betterWeapons(a,b)}
-	end
+  def sort(men)
+    men.sort{|a,b|betterWeapons(a,b)}
+  end
 
 end
 
 class AntFormationBlock&lt;AntFormation
-	def initialize(boss,dir)
-		@dir=dir
-		super(boss)
-	end
-	def calcFormation
-		boss=@boss
-		dir=@dir
-		# precalc formation and store into @rpos
-	
-		men=boss.getMen
-		# sort from back to front (lines)
-		men=sort(men)
+  def initialize(boss,dir)
+    @dir=dir
+    super(boss)
+  end
+  def calcFormation
+    boss=@boss
+    dir=@dir
+    # precalc formation and store into @rpos
+  
+    men=boss.getMen
+    # sort from back to front (lines)
+    men=sort(men)
 
-		vpos={}
-		@rpos={}
-		linesizes={}
-		line=0
-		row=0
+    vpos={}
+    @rpos={}
+    linesizes={}
+    line=0
+    row=0
 
-		rowsize=5
+    rowsize=5
 
-		normal=dir.normal
-		men.each{|m|
-			vpos[m]=[row,line]
-			
-			linesizes[line]||=0
-			linesizes[line]+=1
-			row+=1
-			if row&gt;rowsize-1 # or weapon-group changed
-				row=0
-				line+=1
-			end
-		}
-		men.each{|m|
-			row,line=vpos[m]
-			linesize=linesizes[line]
-			@rpos[m]=normal*(row-(linesize/2.0))*0.5 + dir*line*0.7
-		}
+    normal=dir.normal
+    men.each{|m|
+      vpos[m]=[row,line]
+      
+      linesizes[line]||=0
+      linesizes[line]+=1
+      row+=1
+      if row&gt;rowsize-1 # or weapon-group changed
+        row=0
+        line+=1
+      end
+    }
+    men.each{|m|
+      row,line=vpos[m]
+      linesize=linesizes[line]
+      @rpos[m]=normal*(row-(linesize/2.0))*0.5 + dir*line*0.7
+    }
 
 
-	end
-	def getPositionReal(man)
-		@rpos[man]
-	end
-	def sort(men)
-		men=men.sort{|a,b|betterWeapons(a,b)}
-		men.delete(@boss)
-		a=men[0..1]
-		b=[@boss]
-		c=men[2..-1]
-		a||=[]
-		b||=[]
-		c||=[]
-		a+b+c
-	end
+  end
+  def getPositionReal(man)
+    @rpos[man]
+  end
+  def sort(men)
+    men=men.sort{|a,b|betterWeapons(a,b)}
+    men.delete(@boss)
+    a=men[0..1]
+    b=[@boss]
+    c=men[2..-1]
+    a||=[]
+    b||=[]
+    c||=[]
+    a+b+c
+  end
 end
 
 # FIXME: not yet implemented

Modified: antargis/trunk/ruby/ant_hljob_base.rb
===================================================================
--- antargis/trunk/ruby/ant_hljob_base.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_hljob_base.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,103 +1,103 @@
 class AntNewHLJob
-	attr_reader :finished, :stopped
-	# some magic here
-	def initialize(hero)
-		@hero=hero
+  attr_reader :finished, :stopped
+  # some magic here
+  def initialize(hero)
+    @hero=hero
 
-		@finished=false
+    @finished=false
 
-		firstCall
-	end
-	def getTime
-		@hero.getMap.getTime
-	end
-	def allMen
-		if @hero.is_a?(AntHero)
-			@hero.getMen
-		else
-			@hero.getMen-[@hero]
-		end
-	end
-	def hero
-		@hero
-	end
+    firstCall
+  end
+  def getTime
+    @hero.getMap.getTime
+  end
+  def allMen
+    if @hero.is_a?(AntHero)
+      @hero.getMen
+    else
+      @hero.getMen-[@hero]
+    end
+  end
+  def hero
+    @hero
+  end
 
-	def stopJob
-		@stopped=true
-		if @state
-			call(@state,&quot;leave&quot;)
-		end
-	end
+  def stopJob
+    @stopped=true
+    if @state
+      call(@state,&quot;leave&quot;)
+    end
+  end
 
-	def check(man)
-		return if @state.nil?
-		call2(@state,&quot;assign&quot;,man)
-		while call(@state,&quot;ready&quot;)
-			call(@state,&quot;leave&quot;)
-			goToNextState
-			break if @state.nil? or @finished
-		end
-		puts &quot;FINISHED: #{@finished}&quot;
-	end
+  def check(man)
+    return if @state.nil?
+    call2(@state,&quot;assign&quot;,man)
+    while call(@state,&quot;ready&quot;)
+      call(@state,&quot;leave&quot;)
+      goToNextState
+      break if @state.nil? or @finished
+    end
+    puts &quot;FINISHED: #{@finished}&quot;
+  end
 
-	# override this one
-	def goToNextState
-		@workflow.each{|p|
-			if p[0]==@state
-				@state=p[1]
-				call(@state,&quot;enter&quot;)
-				return
-			end
-		}
-		@finished=true
-	end
+  # override this one
+  def goToNextState
+    @workflow.each{|p|
+      if p[0]==@state
+        @state=p[1]
+        call(@state,&quot;enter&quot;)
+        return
+      end
+    }
+    @finished=true
+  end
 
-	def switchToState(state)
-		call(@state,&quot;leave&quot;)
-		@state=state
-		call(@state,&quot;enter&quot;)
-	end
+  def switchToState(state)
+    call(@state,&quot;leave&quot;)
+    @state=state
+    call(@state,&quot;enter&quot;)
+  end
 
-	def firstCall
-		call(@state,&quot;enter&quot;)
-	end
+  def firstCall
+    call(@state,&quot;enter&quot;)
+  end
 
-	def call(state,event)
-		m=methodName(state,event)
-		print &quot;CALL #{hero.getName} #{state} #{event} #{m}  #{getTime} -- &quot;
-		if self.class.method_defined?(m)
-			v=send(m)
-			puts v
-			return v
-		else
-			puts &quot;UNKNOWN&quot;
-			true
-		end
-	end
-	def xmlName
-		self.class.to_s
-	end
+  def call(state,event)
+    m=methodName(state,event)
+    print &quot;CALL #{hero.getName} #{state} #{event} #{m}  #{getTime} -- &quot;
+    if self.class.method_defined?(m)
+      v=send(m)
+      puts v
+      return v
+    else
+      puts &quot;UNKNOWN&quot;
+      true
+    end
+  end
+  def xmlName
+    self.class.to_s
+  end
 
-	def call2(state,event,man)
-		m=methodName(state,event)
-		print &quot;CALL2 #{hero.getName} #{state} #{event} #{m} #{man} #{getTime} -- &quot;
-		if self.class.method_defined?(m)
-			v=send(m,man)
-			puts v
-			return v
-		else
-			puts &quot;UNKNOWN&quot;
-			true
-		end
-	end
+  def call2(state,event,man)
+    m=methodName(state,event)
+    print &quot;CALL2 #{hero.getName} #{state} #{event} #{m} #{man} #{getTime} -- &quot;
+    if self.class.method_defined?(m)
+      v=send(m,man)
+      puts v
+      return v
+    else
+      puts &quot;UNKNOWN&quot;
+      true
+    end
+  end
 
-	def methodName(state,event)
-		m=state.to_s+&quot;_&quot;+event
-		m=m[0..0].downcase+m[1..-1]
-	end
+  def methodName(state,event)
+    m=state.to_s+&quot;_&quot;+event
+    m=m[0..0].downcase+m[1..-1]
+  end
 
-	def trace
-		puts &quot;TRACE #{caller[0]} #{getTime}&quot;
-	end
-		
+  def trace
+    puts &quot;TRACE #{caller[0]} #{getTime}&quot;
+  end
+    
 end

Modified: antargis/trunk/ruby/ant_hljobs.rb
===================================================================
--- antargis/trunk/ruby/ant_hljobs.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_hljobs.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -33,155 +33,155 @@
 # Base class for high-level jobs. It contains the basic functions that're needed for usage within
 # AntBoss (AntHero and AntHouse)
 class AntHLJob
-	def undefeatedMen
-		@hero.getMen
-	end
-	def delete(man)
-		if @men
-			@men.delete(man)
-		end
-	end
-	def xmlName
-		self.class.to_s
-	end
-	def stopJob
-	end
+  def undefeatedMen
+    @hero.getMen
+  end
+  def delete(man)
+    if @men
+      @men.delete(man)
+    end
+  end
+  def xmlName
+    self.class.to_s
+  end
+  def stopJob
+  end
 
-	def getMap
-		@hero.getMap
-	end
+  def getMap
+    @hero.getMap
+  end
 
-	def saveXML(n)
-		puts &quot;SAVEXML&quot;
-		puts self
-		instance_variables.each{|name|
-			c=n.addChild(&quot;param&quot;)
-			value=instance_variable_get(name)
-			case value
-				when AntEntity
-					value=value.uid
-					type=&quot;uid&quot;
-					c.set(&quot;type&quot;,&quot;AntEntity&quot;)
-				when Array
-					if value[0].is_a?(AntEntity)
-						c.set(&quot;type&quot;,&quot;AntEntities&quot;)
-						value=value.collect{|v|v.uid.to_s}.join(&quot;,&quot;)
-					elsif value[0].is_a?(AGVector2)
-						c.set(&quot;type&quot;,&quot;AGVector2s&quot;)
-						value=value.collect{|v|v.to_s}.join(&quot;:&quot;)
-					end
-				when Hash
-					c.set(&quot;type&quot;,&quot;HashEntities&quot;)
-					value=value.collect{|k,v|
-						k.uid.to_s+&quot;=&quot;+v.uid.to_s
-					}.join(&quot;&amp;&quot;)
-					
-				when Fixnum,Float,TrueClass,FalseClass
-					c.set(&quot;type&quot;,value.class.to_s)
-				when AGVector2
-					c.set(&quot;type&quot;,&quot;AGVector2&quot;)
-				when String
-					# do nothing
-					c.set(&quot;type&quot;,&quot;String&quot;)
-				else
-					puts &quot;UNKNOWN TYPE:#{value} #{value.class} #{name}&quot;
-					
-					value=AntMarshal.dump(value)
-					raise 1
-			end
-			puts &quot;#{value} #{name}&quot;
-			c.set(&quot;name&quot;,name)
-			c.set(&quot;value&quot;,value.to_s)
-		}
-	
-		#FIXME
-	end
-	def loadXML(n)
-		n.getChildren.each{|c|
-			name=c.get(&quot;name&quot;)
-			value=c.get(&quot;value&quot;)
-			type=c.get(&quot;type&quot;)
-			if name and name!=&quot;&quot;
-				puts &quot;TYPE: #{c.get(&quot;type&quot;)}&quot;
-				case c.get(&quot;type&quot;)
-					when &quot;AntEntity&quot;
-						value=getMap.getByUID(value.to_i)
-					when &quot;HashEntities&quot;
-						vs={}
-						value=value.split(&quot;&amp;&quot;).each{|s|
-							k,v=s.split(&quot;=&quot;).collect{|u|getMap.getByUID(u.to_i)}
-							#puts &quot;K:#{k} V:#{v}&quot;
-							vs[k]=v
-						}
-						#puts vs,vs.class
-						#raise 1
-						value=vs
-					when &quot;AntEntities&quot;
-						value=value.split(&quot;,&quot;).collect{|v|getMap.getByUID(v)}
-					when &quot;AGVector2&quot;
-						x,y=value.gsub(&quot;(&quot;,&quot;&quot;).gsub(&quot;)&quot;,&quot;&quot;).split(&quot;,&quot;).collect{|v|v.to_f}
-						value=AGVector2.new(x,y)
-						puts value
-						#raise 1
-					when &quot;AGVector2s&quot;
-						a=[]
-						value.split(&quot;:&quot;).each{|v|
-							x,y=v.gsub(&quot;(&quot;,&quot;&quot;).gsub(&quot;)&quot;,&quot;&quot;).split(&quot;,&quot;).collect{|v|v.to_f}
-							a.push(AGVector2.new(x,y))
-						}
-						value=a
-						puts value
-						#raise 1
-					when &quot;Fixnum&quot;
-						value=value.to_i
-					when &quot;Float&quot;
-						value=value.to_f
-					when &quot;TrueClass&quot;
-						value=true
-					when &quot;FalseClass&quot;
-						value=false
-					when &quot;String&quot;
-						# do nothing
-					else
-						puts &quot;unknown type for #{name} #{type}&quot;
-						if c.get(&quot;value&quot;)!=&quot;&quot;
-							value=AntMarshal.load(c.get(&quot;value&quot;))
-						end
-				end
-				instance_variable_set(name,value)
-			end
-		}
-		#raise 1
-		#FIXME
-	end
-	def playSound(s)
-		@hero.playSound(s)
-	end
+  def saveXML(n)
+    puts &quot;SAVEXML&quot;
+    puts self
+    instance_variables.each{|name|
+      c=n.addChild(&quot;param&quot;)
+      value=instance_variable_get(name)
+      case value
+        when AntEntity
+          value=value.uid
+          type=&quot;uid&quot;
+          c.set(&quot;type&quot;,&quot;AntEntity&quot;)
+        when Array
+          if value[0].is_a?(AntEntity)
+            c.set(&quot;type&quot;,&quot;AntEntities&quot;)
+            value=value.collect{|v|v.uid.to_s}.join(&quot;,&quot;)
+          elsif value[0].is_a?(AGVector2)
+            c.set(&quot;type&quot;,&quot;AGVector2s&quot;)
+            value=value.collect{|v|v.to_s}.join(&quot;:&quot;)
+          end
+        when Hash
+          c.set(&quot;type&quot;,&quot;HashEntities&quot;)
+          value=value.collect{|k,v|
+            k.uid.to_s+&quot;=&quot;+v.uid.to_s
+          }.join(&quot;&amp;&quot;)
+          
+        when Fixnum,Float,TrueClass,FalseClass
+          c.set(&quot;type&quot;,value.class.to_s)
+        when AGVector2
+          c.set(&quot;type&quot;,&quot;AGVector2&quot;)
+        when String
+          # do nothing
+          c.set(&quot;type&quot;,&quot;String&quot;)
+        else
+          puts &quot;UNKNOWN TYPE:#{value} #{value.class} #{name}&quot;
+          
+          value=AntMarshal.dump(value)
+          raise 1
+      end
+      puts &quot;#{value} #{name}&quot;
+      c.set(&quot;name&quot;,name)
+      c.set(&quot;value&quot;,value.to_s)
+    }
+  
+    #FIXME
+  end
+  def loadXML(n)
+    n.getChildren.each{|c|
+      name=c.get(&quot;name&quot;)
+      value=c.get(&quot;value&quot;)
+      type=c.get(&quot;type&quot;)
+      if name and name!=&quot;&quot;
+        puts &quot;TYPE: #{c.get(&quot;type&quot;)}&quot;
+        case c.get(&quot;type&quot;)
+          when &quot;AntEntity&quot;
+            value=getMap.getByUID(value.to_i)
+          when &quot;HashEntities&quot;
+            vs={}
+            value=value.split(&quot;&amp;&quot;).each{|s|
+              k,v=s.split(&quot;=&quot;).collect{|u|getMap.getByUID(u.to_i)}
+              #puts &quot;K:#{k} V:#{v}&quot;
+              vs[k]=v
+            }
+            #puts vs,vs.class
+            #raise 1
+            value=vs
+          when &quot;AntEntities&quot;
+            value=value.split(&quot;,&quot;).collect{|v|getMap.getByUID(v)}
+          when &quot;AGVector2&quot;
+            x,y=value.gsub(&quot;(&quot;,&quot;&quot;).gsub(&quot;)&quot;,&quot;&quot;).split(&quot;,&quot;).collect{|v|v.to_f}
+            value=AGVector2.new(x,y)
+            puts value
+            #raise 1
+          when &quot;AGVector2s&quot;
+            a=[]
+            value.split(&quot;:&quot;).each{|v|
+              x,y=v.gsub(&quot;(&quot;,&quot;&quot;).gsub(&quot;)&quot;,&quot;&quot;).split(&quot;,&quot;).collect{|v|v.to_f}
+              a.push(AGVector2.new(x,y))
+            }
+            value=a
+            puts value
+            #raise 1
+          when &quot;Fixnum&quot;
+            value=value.to_i
+          when &quot;Float&quot;
+            value=value.to_f
+          when &quot;TrueClass&quot;
+            value=true
+          when &quot;FalseClass&quot;
+            value=false
+          when &quot;String&quot;
+            # do nothing
+          else
+            puts &quot;unknown type for #{name} #{type}&quot;
+            if c.get(&quot;value&quot;)!=&quot;&quot;
+              value=AntMarshal.load(c.get(&quot;value&quot;))
+            end
+        end
+        instance_variable_set(name,value)
+      end
+    }
+    #raise 1
+    #FIXME
+  end
+  def playSound(s)
+    @hero.playSound(s)
+  end
 end
 
 
 module AntHeroSitting
-	def sit(man)
- 		formationPos=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at basePos</A>)
+  def sit(man)
+     formationPos=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at basePos</A>)
 
-		diff=(man.getPos2D-formationPos)
-		dist=diff.length2
-		if dist&lt;0.1 then
-			man.setDirection(180-(@hero.getPos2D-man.getPos2D).normalized.getAngle.angle*180.0/Math::PI)
-			if man.getPos3D.z&lt;0 # under water
-				man.newRestJob(5)
-				man.setMeshState(&quot;stand&quot;)
-			elsif not [&quot;sitdown&quot;,&quot;sit&quot;].member?(man.meshState)
-				man.sitDown
-			else
-				man.newRestJob(5)
-				man.setMeshState(&quot;sit&quot;)
-			end
-		else
-			puts &quot;#{man.getPos2D} #{formationPos} #{dist} #{diff}&quot;
-			man.newMoveJob(0,formationPos,0)
-		end
-	end
+    diff=(man.getPos2D-formationPos)
+    dist=diff.length2
+    if dist&lt;0.1 then
+      man.setDirection(180-(@hero.getPos2D-man.getPos2D).normalized.getAngle.angle*180.0/Math::PI)
+      if man.getPos3D.z&lt;0 # under water
+        man.newRestJob(5)
+        man.setMeshState(&quot;stand&quot;)
+      elsif not [&quot;sitdown&quot;,&quot;sit&quot;].member?(man.meshState)
+        man.sitDown
+      else
+        man.newRestJob(5)
+        man.setMeshState(&quot;sit&quot;)
+      end
+    else
+      puts &quot;#{man.getPos2D} #{formationPos} #{dist} #{diff}&quot;
+      man.newMoveJob(0,formationPos,0)
+    end
+  end
 end
 
 #
@@ -192,449 +192,449 @@
 # 3) moveFinished is set to true and eventMoveFinished is called
 #
 class AntHeroMoveJob&lt;AntHLJob
-	def initialize(hero,prio,pos,dist,doFormat=true)
-		@hero=hero
-		@hero.delJob
-		@prio=prio
-		@pos=AGVector2.new(pos.x,pos.y)
-		@overalltarget=@pos
-		@dist=dist
-		@formatDist=0
+  def initialize(hero,prio,pos,dist,doFormat=true)
+    @hero=hero
+    @hero.delJob
+    @prio=prio
+    @pos=AGVector2.new(pos.x,pos.y)
+    @overalltarget=@pos
+    @dist=dist
+    @formatDist=0
 
-# 		puts hero.getPos2D,pos
-# 		puts hero.getPos2D.class,pos.class
-		if getMap.path
-			@waypoints=getMap.path.computePath(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero.getPos2D, at pos</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at hero</A>)
-		else
-			@waypoints=[]
-		end
-		@waypoints.unshift(@hero.getPos2D)
-		@waypoints.push(@pos)
-		if getMap.path
-			#puts &quot;FIXME: ant_hljobs.rb:207&quot;
-			@waypoints=getMap.path.refinePath(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">waypoints, at hero</A>)
-		end
-		@men=getMen
-		@moveFinished=false
+#     puts hero.getPos2D,pos
+#     puts hero.getPos2D.class,pos.class
+    if getMap.path
+      @waypoints=getMap.path.computePath(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero.getPos2D, at pos</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at hero</A>)
+    else
+      @waypoints=[]
+    end
+    @waypoints.unshift(@hero.getPos2D)
+    @waypoints.push(@pos)
+    if getMap.path
+      #puts &quot;FIXME: ant_hljobs.rb:207&quot;
+      @waypoints=getMap.path.refinePath(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">waypoints, at hero</A>)
+    end
+    @men=getMen
+    @moveFinished=false
 
-		if getMen.length&gt;0
-			startFormatting
-		else
-			startWalking
-		end
-	end
+    if getMen.length&gt;0
+      startFormatting
+    else
+      startWalking
+    end
+  end
 
-	def targetPos
-		@waypoints[0]
-	end
-	def formatDir
-		(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">targetPos- at hero.getPos2D</A>).normalized
-	end
+  def targetPos
+    @waypoints[0]
+  end
+  def formatDir
+    (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">targetPos- at hero.getPos2D</A>).normalized
+  end
 
-	def makeMessage(boss)
-		MoveMessage.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">boss,targetPos, at dist</A>)
-	end
+  def makeMessage(boss)
+    MoveMessage.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">boss,targetPos, at dist</A>)
+  end
 
-	def image
-		&quot;data/gui/move.png&quot;
-	end
-	def getMen()
-		@hero.getMen
-	end
+  def image
+    &quot;data/gui/move.png&quot;
+  end
+  def getMen()
+    @hero.getMen
+  end
 
-	def startFormatting
-		puts &quot;startFormatting:::::::::::&quot;
-		@hero.formation=AntFormationBlock.new(@hero,formatDir)
-		@men.each{|man|
-			f=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at hero.getPos2D</A>)
-			man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0,f, at formatDist</A>)
-			man.setMode(&quot;format&quot;)
-		}
-		@state=&quot;format&quot;
-		puts &quot;startFormatting.&quot;
-	end
+  def startFormatting
+    puts &quot;startFormatting:::::::::::&quot;
+    @hero.formation=AntFormationBlock.new(@hero,formatDir)
+    @men.each{|man|
+      f=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at hero.getPos2D</A>)
+      man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0,f, at formatDist</A>)
+      man.setMode(&quot;format&quot;)
+    }
+    @state=&quot;format&quot;
+    puts &quot;startFormatting.&quot;
+  end
 
-	def startWalking
-		puts &quot;startWalking:::::::::::&quot;
-		@hero.formation=AntFormationBlock.new(@hero,formatDir)
-		@pos=@waypoints.shift
-		@men.each{|m|
-			f=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">m, at pos</A>)
-			m.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0,f, at dist</A>)
-			m.setMode(&quot;moving&quot;)
-		}
-		@state=&quot;moving&quot;
-		puts &quot;startWalking.&quot;
-	end
-	def getMenState(mode)
-		@men.select{|m|m.getMode==mode}
-	end
-	def getMenMeshState(mode)
-		@hero.getMen.select{|m|m.meshState==mode}
-	end
-	def check(man)
-		if @moveFinished
-			return	
-		end
-		if @hero.getName==&quot;Rowen&quot;
-			puts &quot;CHECK #{@state} #{man.getMode} #{man} #{man.getPos2D}&quot;
-		end
-		case @state
-			when &quot;format&quot;
-				if man.getMode==&quot;format&quot;
-					man.setMode(&quot;ready&quot;)
-				end
-				if getMenState(&quot;format&quot;).length==0
-					startWalking
-				end
-			when &quot;moving&quot;
-				dputs &quot;WAYPOINTS:&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at waypoints.collect</A>{|w|w.to_s}.join(&quot; &quot;)
-				if @waypoints.length&gt;0
-					startFormatting
-				else
-					dputs &quot;FINISHED:&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at hero.getPos2D</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at pos</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at overalltarget</A>
-				
-					self.moveFinished=true
-				end
-		end
-	end
+  def startWalking
+    puts &quot;startWalking:::::::::::&quot;
+    @hero.formation=AntFormationBlock.new(@hero,formatDir)
+    @pos=@waypoints.shift
+    @men.each{|m|
+      f=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">m, at pos</A>)
+      m.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0,f, at dist</A>)
+      m.setMode(&quot;moving&quot;)
+    }
+    @state=&quot;moving&quot;
+    puts &quot;startWalking.&quot;
+  end
+  def getMenState(mode)
+    @men.select{|m|m.getMode==mode}
+  end
+  def getMenMeshState(mode)
+    @hero.getMen.select{|m|m.meshState==mode}
+  end
+  def check(man)
+    if @moveFinished
+      return  
+    end
+    if @hero.getName==&quot;Rowen&quot;
+      puts &quot;CHECK #{@state} #{man.getMode} #{man} #{man.getPos2D}&quot;
+    end
+    case @state
+      when &quot;format&quot;
+        if man.getMode==&quot;format&quot;
+          man.setMode(&quot;ready&quot;)
+        end
+        if getMenState(&quot;format&quot;).length==0
+          startWalking
+        end
+      when &quot;moving&quot;
+        dputs &quot;WAYPOINTS:&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at waypoints.collect</A>{|w|w.to_s}.join(&quot; &quot;)
+        if @waypoints.length&gt;0
+          startFormatting
+        else
+          dputs &quot;FINISHED:&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at hero.getPos2D</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at pos</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at overalltarget</A>
+        
+          self.moveFinished=true
+        end
+    end
+  end
 
-	def moveFinished
-		return @moveFinished
-	end
-	
-	def finished
-		moveFinished
-	end
+  def moveFinished
+    return @moveFinished
+  end
+  
+  def finished
+    moveFinished
+  end
 
-	def moveFinished=(b)
-		@moveFinished=b
-		if b	
-			eventMoveFinished
-		end
-	end
-	def eventMoveFinished
-	end
+  def moveFinished=(b)
+    @moveFinished=b
+    if b  
+      eventMoveFinished
+    end
+  end
+  def eventMoveFinished
+  end
 
 end
 
 class AntHeroFightJob&lt;AntHeroMoveJob
-	attr_reader :target
-	attr_accessor :fightMap
+  attr_reader :target
+  attr_accessor :fightMap
 
-	def initialize(hero,target,defend=false)
-		@men=hero.getMen
-		@hero=hero
-		initSitpositions
-		puts &quot;NEW ANTHEROFIGHT JOB #{hero.getName} #{target.getName}&quot;
+  def initialize(hero,target,defend=false)
+    @men=hero.getMen
+    @hero=hero
+    initSitpositions
+    puts &quot;NEW ANTHEROFIGHT JOB #{hero.getName} #{target.getName}&quot;
 
-		@hero=hero
-		@target=target
-		#@killStarted=false
-		#@killJobsGiven=false
-		@defend=defend
-		@hero.newRestJob(1)  #FIXME: this is an indirect method of killing actual job
-		super(hero,0,target.getPos2D,10,(not defend)) # near til 10
+    @hero=hero
+    @target=target
+    #@killStarted=false
+    #@killJobsGiven=false
+    @defend=defend
+    @hero.newRestJob(1)  #FIXME: this is an indirect method of killing actual job
+    super(hero,0,target.getPos2D,10,(not defend)) # near til 10
 
- 		if @defend or (not hero.is_a?(AntHero))
-			#@hero.newRestJob(2) # wait for 3 seconds; then set state to fight - have a look at check() for more
-			startFighting
- 		end
-		@finished=false
-	end
+     if @defend or (not hero.is_a?(AntHero))
+      #@hero.newRestJob(2) # wait for 3 seconds; then set state to fight - have a look at check() for more
+      startFighting
+     end
+    @finished=false
+  end
 
-	def makeMessage(boss)
-		FightMessage.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero.uid, at target.uid</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at defend</A>)
-	end
+  def makeMessage(boss)
+    FightMessage.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero.uid, at target.uid</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at defend</A>)
+  end
 
-	def finished
-		@finished
-	end
-	
-	def eventMoveFinished
-		puts &quot;MOVE FINISHED EVENT&quot;
-		startFighting
-	end
+  def finished
+    @finished
+  end
+  
+  def eventMoveFinished
+    puts &quot;MOVE FINISHED EVENT&quot;
+    startFighting
+  end
 
-	def check(man)
-		# check state
-		if @state==&quot;fighting&quot;
-			if getMenState(&quot;defeated&quot;).length==@men.length
-			  lost
-			end
-			if not @target.getJob.is_a?(AntHeroFightJob) # enemy gave up
-				@finished=true
-			end
-		end
+  def check(man)
+    # check state
+    if @state==&quot;fighting&quot;
+      if getMenState(&quot;defeated&quot;).length==@men.length
+        lost
+      end
+      if not @target.getJob.is_a?(AntHeroFightJob) # enemy gave up
+        @finished=true
+      end
+    end
 
-		return if @finished
+    return if @finished
 
-		puts &quot;CHECK(FIGHT) #{man} #{man.getName}&quot;
-		case @state
-			when &quot;fighting&quot;
-				if [AntMan,AntHero].member?(man.class)
-					startFightingMan(man)
-				end
-			else
-				super
-		end
-	end
+    puts &quot;CHECK(FIGHT) #{man} #{man.getName}&quot;
+    case @state
+      when &quot;fighting&quot;
+        if [AntMan,AntHero].member?(man.class)
+          startFightingMan(man)
+        end
+      else
+        super
+    end
+  end
 
-	def startFighting
-		puts &quot;--------------------&quot;
-		puts &quot;START FIGHTING #{@hero}&quot;
-		if @state==&quot;fighting&quot;
-			raise &quot;already fighting&quot;
-		end
-		@state=&quot;fighting&quot;
+  def startFighting
+    puts &quot;--------------------&quot;
+    puts &quot;START FIGHTING #{@hero}&quot;
+    if @state==&quot;fighting&quot;
+      raise &quot;already fighting&quot;
+    end
+    @state=&quot;fighting&quot;
 
-		# REALLY FIXME: these 2 calls do the same ?????
+    # REALLY FIXME: these 2 calls do the same ?????
 
 
-		#@target.eventGotHLFight(@hero)
-		@target.eventAttacked(@hero)
-		initSitpositions
+    #@target.eventGotHLFight(@hero)
+    @target.eventAttacked(@hero)
+    initSitpositions
 
-		if @fightMap.nil?
-			computeFightMap
-		end
-		
-		@hero.getMen.each{|man|
-			puts man
-			man.setMode(&quot;fight&quot;)
-			startFightingMan(man)
-		}
-		puts &quot;--------------------&quot;
-		@fightStarted=true
-	end
+    if @fightMap.nil?
+      computeFightMap
+    end
+    
+    @hero.getMen.each{|man|
+      puts man
+      man.setMode(&quot;fight&quot;)
+      startFightingMan(man)
+    }
+    puts &quot;--------------------&quot;
+    @fightStarted=true
+  end
 
-	def computeFightMap
-		@fightMap={}
-		puts &quot;mymen: #{@hero.getMen.join(&quot; &quot;)}&quot;
-		puts &quot;otheren: #{@target.getMen.join(&quot; &quot;)}&quot;
+  def computeFightMap
+    @fightMap={}
+    puts &quot;mymen: #{@hero.getMen.join(&quot; &quot;)}&quot;
+    puts &quot;otheren: #{@target.getMen.join(&quot; &quot;)}&quot;
 
-		if @target.getJob.is_a?(AntHeroFightJob)
-			map=@target.getJob.fightMap
-			if map
-				map.each{|k,v|
-					@fightMap[v]=k
-				}
-			end
-		end
-		undefeatedMen.each{|m|
-			if @fightMap[m].nil?
-				# find next enemy
-				e=findNextEnemy(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">m, at fightMap.values</A>)
+    if @target.getJob.is_a?(AntHeroFightJob)
+      map=@target.getJob.fightMap
+      if map
+        map.each{|k,v|
+          @fightMap[v]=k
+        }
+      end
+    end
+    undefeatedMen.each{|m|
+      if @fightMap[m].nil?
+        # find next enemy
+        e=findNextEnemy(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">m, at fightMap.values</A>)
 
-				@fightMap[m]=e
-			end
-		}
-		@fightMap.each{|m,e|
-			puts &quot;FIGHTMAP:#{m}:#{e}&quot;
-		}
-	end
+        @fightMap[m]=e
+      end
+    }
+    @fightMap.each{|m,e|
+      puts &quot;FIGHTMAP:#{m}:#{e}&quot;
+    }
+  end
 
-	def startFightingMan(man)
-		puts &quot;startFightingMan(man)&quot;
-		target=nil
-		if @fightStarted
-			raise &quot;Problem! Fightmap not defined&quot; if not @fightMap		
-		
-			if @target.getJob.is_a?(AntHeroFightJob)
-				if @target.getJob.undefeatedMen.member?(@fightMap[man])
-					target=@fightMap[man]
-				end
-			end
-			if target.nil?
-				# find trooper with least energy and help him
-				least=nil
-				e=1000
-				undefeatedMen.each{|m|
-					if m.getEnergy&lt;e and m!=man
-						least=m
-						e=m.getEnergy
-					end
-				}
-				target=getTargetFrom(least)
-			end
-		else
-			target=@fightMap[man]
-		end
-		if target.nil?
-			# probably won ?
-			if @target.getJob.is_a?(AntHeroFightJob)
-				puts &quot;WON????&quot;
-				puts @target.getJob.undefeatedMen
-				if @target.getJob.undefeatedMen.length==0
-					won
-					return
-				end
-			end
-			#raise &quot;PROBLEM!&quot;
-		else
-			attack(man,target)
-		end
-	end
+  def startFightingMan(man)
+    puts &quot;startFightingMan(man)&quot;
+    target=nil
+    if @fightStarted
+      raise &quot;Problem! Fightmap not defined&quot; if not @fightMap    
+    
+      if @target.getJob.is_a?(AntHeroFightJob)
+        if @target.getJob.undefeatedMen.member?(@fightMap[man])
+          target=@fightMap[man]
+        end
+      end
+      if target.nil?
+        # find trooper with least energy and help him
+        least=nil
+        e=1000
+        undefeatedMen.each{|m|
+          if m.getEnergy&lt;e and m!=man
+            least=m
+            e=m.getEnergy
+          end
+        }
+        target=getTargetFrom(least)
+      end
+    else
+      target=@fightMap[man]
+    end
+    if target.nil?
+      # probably won ?
+      if @target.getJob.is_a?(AntHeroFightJob)
+        puts &quot;WON????&quot;
+        puts @target.getJob.undefeatedMen
+        if @target.getJob.undefeatedMen.length==0
+          won
+          return
+        end
+      end
+      #raise &quot;PROBLEM!&quot;
+    else
+      attack(man,target)
+    end
+  end
 
-	def attack(man,target)
-		man.newFightJob(0,target)
-		#puts man
-		#puts &quot;#{man.getName} attacks #{target.getName}&quot;
-		if man and man.getHero and target and target.getHero
-			puts &quot;#{man.getHero.getName}(#{man.getName}) attacks #{target.getHero.getName}(#{target.getName})&quot;
-		end
-	end
+  def attack(man,target)
+    man.newFightJob(0,target)
+    #puts man
+    #puts &quot;#{man.getName} attacks #{target.getName}&quot;
+    if man and man.getHero and target and target.getHero
+      puts &quot;#{man.getHero.getName}(#{man.getName}) attacks #{target.getHero.getName}(#{target.getName})&quot;
+    end
+  end
 
-	def findNextEnemy(man,but)
-		if @target.getJob.is_a?(AntHeroFightJob)
-			tmen=@target.getJob.undefeatedMen
-		else
-			tmen=@target.getMen
-		end
-		orig=tmen
-		tmen-=but
-		if tmen.length==0
-			return orig.shuffle[0]
-		end
-		# search nearest enemy
-		dist=1000.0
-		mtarget=nil
-		tmen.each{|t|
-			if t.getEnergy&gt;0 and t.dead!=true
-				d=(t.getPos2D-man.getPos2D).length
-				if d&lt;dist
-					dist=d
-					mtarget=t
-				end
-			end
-		}
-		return mtarget
-	end
+  def findNextEnemy(man,but)
+    if @target.getJob.is_a?(AntHeroFightJob)
+      tmen=@target.getJob.undefeatedMen
+    else
+      tmen=@target.getMen
+    end
+    orig=tmen
+    tmen-=but
+    if tmen.length==0
+      return orig.shuffle[0]
+    end
+    # search nearest enemy
+    dist=1000.0
+    mtarget=nil
+    tmen.each{|t|
+      if t.getEnergy&gt;0 and t.dead!=true
+        d=(t.getPos2D-man.getPos2D).length
+        if d&lt;dist
+          dist=d
+          mtarget=t
+        end
+      end
+    }
+    return mtarget
+  end
 
-	def getTargetFrom(m)
-		raise &quot;Problem! Fightmap not defined&quot; if not @fightMap		
-		@fightMap[m]
-	end
+  def getTargetFrom(m)
+    raise &quot;Problem! Fightmap not defined&quot; if not @fightMap    
+    @fightMap[m]
+  end
 
 
-	def defeated(man)
-		playSound(&quot;ugh_end&quot;)
-		puts &quot;DEFEATED:&quot;+man.to_s
-		if man.is_a?(AntBoss)
-			lost
-			return
-		end
-		man.setMode(&quot;defeated&quot;)
-		puts @sitpos.length
-		raise &quot;no sit position&quot; if @sitpos[man].nil?
-		man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at sitpos</A>[man],0)
-	end
+  def defeated(man)
+    playSound(&quot;ugh_end&quot;)
+    puts &quot;DEFEATED:&quot;+man.to_s
+    if man.is_a?(AntBoss)
+      lost
+      return
+    end
+    man.setMode(&quot;defeated&quot;)
+    puts @sitpos.length
+    raise &quot;no sit position&quot; if @sitpos[man].nil?
+    man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at sitpos</A>[man],0)
+  end
 
-	def haveDefeated(e)
-		puts &quot;haveDefeated: #{e.getName}&quot;
-		@men.each{|m|
-			puts &quot;checking: #{m.fightTarget} #{e}&quot;
-			if m.fightTarget==e
-				puts &quot;#{m.getName} not longer attacks #{e.getName}&quot;
-				m.delJob # search other target
-			end
-		}
-		@fightMap.delete_if{|k,v|v==e}
-	end
+  def haveDefeated(e)
+    puts &quot;haveDefeated: #{e.getName}&quot;
+    @men.each{|m|
+      puts &quot;checking: #{m.fightTarget} #{e}&quot;
+      if m.fightTarget==e
+        puts &quot;#{m.getName} not longer attacks #{e.getName}&quot;
+        m.delJob # search other target
+      end
+    }
+    @fightMap.delete_if{|k,v|v==e}
+  end
 
-	def lost
-		if not @finished
-			dputs &quot;LOST!!!!!!!!!!&quot;
-			@finished=true
+  def lost
+    if not @finished
+      dputs &quot;LOST!!!!!!!!!!&quot;
+      @finished=true
 
-			if @hero.is_a?(AntHero)
-				@hero.eventHLJobFinished(self)
-				@hero.newHLMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at sitpos</A>[@hero],0)
-			end
+      if @hero.is_a?(AntHero)
+        @hero.eventHLJobFinished(self)
+        @hero.newHLMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at sitpos</A>[@hero],0)
+      end
 
-			if @target.getJob.is_a?(AntHeroFightJob)
-				@target.getJob.won
-			end
-			@hero.setOwner(@target)
-			@hero.killAllJobs
-			@target.killAllJobs
-		end
-	end
-	def won
-		if not @finished
-			dputs &quot;WON!!!!!!!!!!&quot;
-			playSound(&quot;won&quot;)
-			@finished=true
-			if @hero.is_a?(AntHero)
-				@hero.eventHLJobFinished(self)
-				@hero.newHLMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at sitpos</A>[@hero],0)
-			end
+      if @target.getJob.is_a?(AntHeroFightJob)
+        @target.getJob.won
+      end
+      @hero.setOwner(@target)
+      @hero.killAllJobs
+      @target.killAllJobs
+    end
+  end
+  def won
+    if not @finished
+      dputs &quot;WON!!!!!!!!!!&quot;
+      playSound(&quot;won&quot;)
+      @finished=true
+      if @hero.is_a?(AntHero)
+        @hero.eventHLJobFinished(self)
+        @hero.newHLMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at sitpos</A>[@hero],0)
+      end
 
-			if @target.getJob.is_a?(AntHeroFightJob)
-				@target.getJob.lost
-			end
-			@hero.killAllJobs
-			@target.killAllJobs
-		end
-	end
+      if @target.getJob.is_a?(AntHeroFightJob)
+        @target.getJob.lost
+      end
+      @hero.killAllJobs
+      @target.killAllJobs
+    end
+  end
 
-	def image
-		&quot;data/gui/sword.png&quot;
-	end
+  def image
+    &quot;data/gui/sword.png&quot;
+  end
 
 private
-	def initSitpositions
-		# gather sitting positions
-		@sitpos={}
-		@men.collect{|man|
-			@sitpos[man]=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at hero.getPos2D</A>)
-		}
-	end
+  def initSitpositions
+    # gather sitting positions
+    @sitpos={}
+    @men.collect{|man|
+      @sitpos[man]=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at hero.getPos2D</A>)
+    }
+  end
 end
 
 class AntHeroFightAnimalJob&lt;AntHeroMoveJob
-	attr_reader :target
-	def initialize(hero,target)
-		@target=target
-		super(hero,0,target.getPos2D,1,false)
-		@finished=false
-	end
-	def image
-		&quot;data/gui/sword.png&quot;
-	end
-	def check(man)
-		if moveFinished
-			case @state
-				when &quot;eat&quot;
-					man.newRestJob(10)
-					@toEat-=1
-					if @toEat&lt;=0
-						killAnimal
-						playSound
-						@finished=true
-					end
-				else
-					@state=&quot;eat&quot;
-					@men.each{|m|
-						m.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,0)
-					}
-					@toEat=@men.length
-			end
-		else
-			super
-		end
-	end
-	def playSound
-		puts &quot;FIXME: play eat sound&quot;
-	end
-	def finished
-		@finished
-	end
-	def killAnimal
-		@target.eventDie
-		@hero.resource.takeAll(@target.resource) #add(&quot;food&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at target.resource.get</A>(&quot;food&quot;))
-		#@target.resource.set(&quot;food&quot;,0)
-	end
+  attr_reader :target
+  def initialize(hero,target)
+    @target=target
+    super(hero,0,target.getPos2D,1,false)
+    @finished=false
+  end
+  def image
+    &quot;data/gui/sword.png&quot;
+  end
+  def check(man)
+    if moveFinished
+      case @state
+        when &quot;eat&quot;
+          man.newRestJob(10)
+          @toEat-=1
+          if @toEat&lt;=0
+            killAnimal
+            playSound
+            @finished=true
+          end
+        else
+          @state=&quot;eat&quot;
+          @men.each{|m|
+            m.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,0)
+          }
+          @toEat=@men.length
+      end
+    else
+      super
+    end
+  end
+  def playSound
+    puts &quot;FIXME: play eat sound&quot;
+  end
+  def finished
+    @finished
+  end
+  def killAnimal
+    @target.eventDie
+    @hero.resource.takeAll(@target.resource) #add(&quot;food&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at target.resource.get</A>(&quot;food&quot;))
+    #@target.resource.set(&quot;food&quot;,0)
+  end
 end
 
 
@@ -650,177 +650,177 @@
 # - Then he is part of the party and both return to the saved resting point.
 # - For the actual resting the AntHeroSitting-module is used 
 class AntHeroRecruitJob&lt;AntHeroMoveJob
-	include AntHeroSitting
+  include AntHeroSitting
 
-	attr_reader :finished
-	def initialize(hero,target)
-		@target=target
-		@targetMen=target.menCount
-		@want=@targetMen*hero.getAggression/3
-		@finished=false
-		@restingMen=0
-		@wantedMen=@want.to_i
-		@fetchingStarted=false
-		super(hero,0,target.getPos2D,4)
-	end
+  attr_reader :finished
+  def initialize(hero,target)
+    @target=target
+    @targetMen=target.menCount
+    @want=@targetMen*hero.getAggression/3
+    @finished=false
+    @restingMen=0
+    @wantedMen=@want.to_i
+    @fetchingStarted=false
+    super(hero,0,target.getPos2D,4)
+  end
 
-	def image
-		&quot;data/gui/recruit.png&quot;
-	end
+  def image
+    &quot;data/gui/recruit.png&quot;
+  end
 
-	def eventMoveFinished
-		doCollect
-	end
+  def eventMoveFinished
+    doCollect
+  end
 
-	def doCollect
-		@fetchingStarted=true
-		@myMap={}
-		myMen=@hero.getMen.clone.reverse # put hero at last
-		if myMen.length&gt;1
-			myMen.delete(@hero)
-		end
-		@basePos=@hero.getPos2D
-		otherMen=@target.getMen-[@target]
-		# filter men, which are too far away (&gt;10)
-		otherMen=otherMen.select{|m|(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">m.getPos2D- at hero.getPos2D</A>).length&lt;10}
-		(0..([<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">myMen.length,otherMen.length, at wantedMen</A>].min-1)).each{|i|
-			my=myMen[i]
-			other=otherMen[i]
-			@myMap[my]=other
-			my.newMoveJob(0,other,0)
-			my.setMode(&quot;fetching&quot;)
-		}
-	end
+  def doCollect
+    @fetchingStarted=true
+    @myMap={}
+    myMen=@hero.getMen.clone.reverse # put hero at last
+    if myMen.length&gt;1
+      myMen.delete(@hero)
+    end
+    @basePos=@hero.getPos2D
+    otherMen=@target.getMen-[@target]
+    # filter men, which are too far away (&gt;10)
+    otherMen=otherMen.select{|m|(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">m.getPos2D- at hero.getPos2D</A>).length&lt;10}
+    (0..([<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">myMen.length,otherMen.length, at wantedMen</A>].min-1)).each{|i|
+      my=myMen[i]
+      other=otherMen[i]
+      @myMap[my]=other
+      my.newMoveJob(0,other,0)
+      my.setMode(&quot;fetching&quot;)
+    }
+  end
 
-	def check(man)
-		if moveFinished
-			@hero.formation=AntFormationRest.new(@hero)
-			if @myMap.keys.member?(man)
-				other=@myMap[man]
-				if (man.getPos2D-other.getPos2D).length&lt;1
-					# new boss
-					@myMap.delete(man)
-					other.setBoss(@hero)
-					if man.is_a?(AntHero)
-						man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at basePos</A>,0)
-					end
-					man.setMode(&quot;ready&quot;)
-					other.setMode(&quot;ready&quot;)
-					@wantedMen-=1
-				else
-					man.newMoveJob(0,other.getPos2D,0)
-				end
-			else
-				#super
-				fp=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at basePos</A>)
-				if (man.getPos2D-fp).length&lt;0.2
-					sit(man)
-				else
-					man.newMoveJob(0,fp,0)
-				end
-			end
-		else
-			super
-		end
-		if getMenState(&quot;fetching&quot;).length==0 and @fetchingStarted and (@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero.getPos2D- at basePos</A>).length&lt;0.2
-			if getMenMeshState(&quot;sit&quot;).length&gt;=@hero.getMen.length
-				if @wantedMen==0
-					@finished=true
-				else
-				#@hero.getMen.each{|m|puts &quot;MS: #{m} #{m.meshState}&quot;}
-				#if getMenMeshState(&quot;sit&quot;).length&gt;=@hero.getMen.length
- 					doCollect
-				#end
-				end
-			end
-		end
-	end
+  def check(man)
+    if moveFinished
+      @hero.formation=AntFormationRest.new(@hero)
+      if @myMap.keys.member?(man)
+        other=@myMap[man]
+        if (man.getPos2D-other.getPos2D).length&lt;1
+          # new boss
+          @myMap.delete(man)
+          other.setBoss(@hero)
+          if man.is_a?(AntHero)
+            man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at basePos</A>,0)
+          end
+          man.setMode(&quot;ready&quot;)
+          other.setMode(&quot;ready&quot;)
+          @wantedMen-=1
+        else
+          man.newMoveJob(0,other.getPos2D,0)
+        end
+      else
+        #super
+        fp=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at basePos</A>)
+        if (man.getPos2D-fp).length&lt;0.2
+          sit(man)
+        else
+          man.newMoveJob(0,fp,0)
+        end
+      end
+    else
+      super
+    end
+    if getMenState(&quot;fetching&quot;).length==0 and @fetchingStarted and (@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero.getPos2D- at basePos</A>).length&lt;0.2
+      if getMenMeshState(&quot;sit&quot;).length&gt;=@hero.getMen.length
+        if @wantedMen==0
+          @finished=true
+        else
+        #@hero.getMen.each{|m|puts &quot;MS: #{m} #{m.meshState}&quot;}
+        #if getMenMeshState(&quot;sit&quot;).length&gt;=@hero.getMen.length
+           doCollect
+        #end
+        end
+      end
+    end
+  end
 
 end
 
 
 class AntHeroTakeJob&lt;AntHeroMoveJob
-	attr_reader :finished
-	def initialize(hero,target,what=&quot;food&quot;)
-		super(hero,0,target.getPos2D,4)
-		@what=what
-		@target=target
-		@want=@men
-		@oldpos=nil
-		@takeStarted=false
-	end
+  attr_reader :finished
+  def initialize(hero,target,what=&quot;food&quot;)
+    super(hero,0,target.getPos2D,4)
+    @what=what
+    @target=target
+    @want=@men
+    @oldpos=nil
+    @takeStarted=false
+  end
 
-	def image
-		if @what==&quot;food&quot;
-			&quot;data/gui/take_apple.png&quot;
-		else
-			&quot;data/gui/take_weapon.png&quot;
-		end
-	end
+  def image
+    if @what==&quot;food&quot;
+      &quot;data/gui/take_apple.png&quot;
+    else
+      &quot;data/gui/take_weapon.png&quot;
+    end
+  end
 
-	def check(man)
-		if moveFinished
-			if man.class==AntHero	and @oldpos.class==NilClass
-				@oldpos=man.getPos2D
-				if @takeStarted==false
-					@men.each{|m|m.delJob}
-					@takeStarted=true
-				end
-			end
-			case man.getMode
-				when &quot;takingFood&quot;
-					# take food and return
-					case @what
-						when &quot;food&quot;
-							for i in <A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at hero.getAggression</A>
-								if @target.resource.get(&quot;food&quot;)&gt;0
-									@target.resource.sub(&quot;food&quot;,1)
-									man.resource.add(&quot;food&quot;,1)
-								end
-							end
-						when &quot;weapon&quot;
-							[&quot;sword&quot;,&quot;bow&quot;,&quot;boat&quot;,&quot;shield&quot;].each{|w|
-								if @target.resource.get(w)&gt;0 and man.resource.get(w)==0 # take only if house has it and man doesn't have it
-									@target.resource.sub(w,1)
-									man.resource.add(w,1)
-								end
-							}
-						else
-							raise &quot;unknown type to take !&quot;
-					end
-					@want.delete(man)
-					if @want.length==0
-						@finished=true
-						@hero.eventHLJobFinished(self)
-						@hero.newHLMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at oldpos</A>,0)
-					end
-				else
-					man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,0)
-					man.setMode(&quot;takingFood&quot;)
-			end
-		else
-			super(man)
-		end
-	end
+  def check(man)
+    if moveFinished
+      if man.class==AntHero  and @oldpos.class==NilClass
+        @oldpos=man.getPos2D
+        if @takeStarted==false
+          @men.each{|m|m.delJob}
+          @takeStarted=true
+        end
+      end
+      case man.getMode
+        when &quot;takingFood&quot;
+          # take food and return
+          case @what
+            when &quot;food&quot;
+              for i in <A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at hero.getAggression</A>
+                if @target.resource.get(&quot;food&quot;)&gt;0
+                  @target.resource.sub(&quot;food&quot;,1)
+                  man.resource.add(&quot;food&quot;,1)
+                end
+              end
+            when &quot;weapon&quot;
+              [&quot;sword&quot;,&quot;bow&quot;,&quot;boat&quot;,&quot;shield&quot;].each{|w|
+                if @target.resource.get(w)&gt;0 and man.resource.get(w)==0 # take only if house has it and man doesn't have it
+                  @target.resource.sub(w,1)
+                  man.resource.add(w,1)
+                end
+              }
+            else
+              raise &quot;unknown type to take !&quot;
+          end
+          @want.delete(man)
+          if @want.length==0
+            @finished=true
+            @hero.eventHLJobFinished(self)
+            @hero.newHLMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at oldpos</A>,0)
+          end
+        else
+          man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,0)
+          man.setMode(&quot;takingFood&quot;)
+      end
+    else
+      super(man)
+    end
+  end
 end
 
 
 class ProductionRule
-	attr_reader :what, :from
-	def initialize(what,from)
-		@what=what
-		@from=from
-	end
+  attr_reader :what, :from
+  def initialize(what,from)
+    @what=what
+    @from=from
+  end
 end
 
 $productionRules=[
-	ProductionRule.new(&quot;rod&quot;,[[&quot;wood&quot;,1]]),
-	ProductionRule.new(&quot;steel&quot;,[[&quot;ore&quot;,1],[&quot;coal&quot;,1]]),
-	ProductionRule.new(&quot;gold&quot;,[[&quot;ore&quot;,4],[&quot;coal&quot;,1]]),
-	ProductionRule.new(&quot;boat&quot;,[[&quot;wood&quot;,2]]),
-	ProductionRule.new(&quot;shield&quot;,[[&quot;wood&quot;,1]]),
-	ProductionRule.new(&quot;bow&quot;,[[&quot;wood&quot;,1],[&quot;stone&quot;,1]]),
-	ProductionRule.new(&quot;sword&quot;,[[&quot;wood&quot;,1],[&quot;steel&quot;,1]])
+  ProductionRule.new(&quot;rod&quot;,[[&quot;wood&quot;,1]]),
+  ProductionRule.new(&quot;steel&quot;,[[&quot;ore&quot;,1],[&quot;coal&quot;,1]]),
+  ProductionRule.new(&quot;gold&quot;,[[&quot;ore&quot;,4],[&quot;coal&quot;,1]]),
+  ProductionRule.new(&quot;boat&quot;,[[&quot;wood&quot;,2]]),
+  ProductionRule.new(&quot;shield&quot;,[[&quot;wood&quot;,1]]),
+  ProductionRule.new(&quot;bow&quot;,[[&quot;wood&quot;,1],[&quot;stone&quot;,1]]),
+  ProductionRule.new(&quot;sword&quot;,[[&quot;wood&quot;,1],[&quot;steel&quot;,1]])
 ]
 
 # constructing runs like this:
@@ -830,294 +830,294 @@
 # * job finishes after some given time (20 seconds or so)
 
 class AntHeroConstructJob&lt;AntHeroMoveJob
-	attr_reader :finished
-	def initialize(hero,target)
-		super(hero,0,target.getPos2D,4)
-		@target=target
-		@usedmen=0
-		@restype={}
-		@constructStarted=false
-		@@productionRules=$productionRules # FIXME maybe exchange for different constructing types
-	end
-	def image
-		&quot;data/gui/construct.png&quot;
-	end
-	def check(man)
-		if moveFinished
-			@hero.formation=AntFormationRest.new(@hero)
-			if man.is_a?(AntBoss)
-				checkEat(man)
-				if not @constructStarted
-					@men.each{|m|m.delJob}
-					@constructStarted=true
-				end
-				man.newRestJob(20) # do nothing at all
-				return
-			end
-			@constructStarted=true
-			wantmen=(@men.length-1)*@hero.getAggression/3.0
-			case man.getMode
-				when &quot;fetch&quot; # go to resource
-					res=getNeededResources
-					res,nearest=getNextWithResource(res)
-					@restype[man]=[res,nearest]
-					if nearest.nil?
-						puts &quot;resource not found! #{res}&quot;
-						man.newRestJob(5)
-					else
-						if (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">nearest.getPos2D- at target.getPos2D</A>).length&lt;20
-							man.newMoveJob(0,nearest.getPos2D,0.5) # near but not actually there
-							man.setMode(&quot;harvest&quot;)
-						else
-							man.newRestJob(1)
-							puts &quot;TOO FAR&quot;
-						end
-					end
-				when &quot;harvest&quot; # harvest resource
-					if (@restype[man][1].getPos2D-man.getPos2D).length&lt;3
-						man.newRestJob(2)
-						man.digResource(@restype[man][0])
-						man.setMode(&quot;collect&quot;)
-					else
-						puts &quot;WAS TOO FAR AWAY - Probably job discarded&quot;
-						man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,0)
-						man.setMode(&quot;&quot;)
-					end
-				when &quot;collect&quot; # bring back
-					# FIXME: add sub resource from nearest
-					p=@restype[man]
-					amount=[p[1].resource.get(p[0]),man.canCarry].min
-					p[1].resource.sub(p[0],amount)
-					man.resource.add(p[0],amount)
-					man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,0)
-					man.collectResource(@restype[man][0])
-					man.setMode(&quot;brought&quot;)
-				when &quot;brought&quot;
-					man.setMode(&quot;after_brought&quot;)
-					man.newRestJob(1)
-					# take all natural resources - but not food and weapons - otherwise men starve!
-					myResources.each{|r|
-						@target.resource.take(man.resource,r)
-					}
-				when &quot;after_brought&quot;
-					fpos=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at hero.getPos2D</A>)
-					man.newMoveJob(0,fpos,0)
-					man.setMode(&quot;construct_torest&quot;)
-				when &quot;to_construct&quot;  # do some constructing
-					@target.incSmoke
-					man.newRestJob(5 - @hero.getAggression*0.5) # work for 3.5-5 seconds (depending on aggression)
-					man.setMode(&quot;constructing&quot;)
-					man.playSound(&quot;construct&quot;)
-				when &quot;constructing&quot;
-					# was constructing
-					readyConstructed
-					man.incExperience(man.learnAmount)
-					@target.decSmoke
-					man.setMode(&quot;construct_torest&quot;)
-					fpos=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at hero.getPos2D</A>)
-					man.newMoveJob(0,fpos,0)
-				when &quot;construct_torest&quot;
-					man.setMode(&quot;rest&quot;)
-					man.newRestJob(3/@hero.getAggression) # shorter pauses when aggression is higher
-					if man.getAggression&lt;3
-						checkEat(man)
-					end
-					@usedmen-=1
-				else
-					if wantmen&gt;@usedmen
-						@usedmen+=1
-						man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,0)
-						if enoughResources
-							man.setMode(&quot;to_construct&quot;)
-						else
-							man.setMode(&quot;fetch&quot;)
-						end
-					end
-			end
-		else
-			super(man)
-		end
-	end
+  attr_reader :finished
+  def initialize(hero,target)
+    super(hero,0,target.getPos2D,4)
+    @target=target
+    @usedmen=0
+    @restype={}
+    @constructStarted=false
+    @@productionRules=$productionRules # FIXME maybe exchange for different constructing types
+  end
+  def image
+    &quot;data/gui/construct.png&quot;
+  end
+  def check(man)
+    if moveFinished
+      @hero.formation=AntFormationRest.new(@hero)
+      if man.is_a?(AntBoss)
+        checkEat(man)
+        if not @constructStarted
+          @men.each{|m|m.delJob}
+          @constructStarted=true
+        end
+        man.newRestJob(20) # do nothing at all
+        return
+      end
+      @constructStarted=true
+      wantmen=(@men.length-1)*@hero.getAggression/3.0
+      case man.getMode
+        when &quot;fetch&quot; # go to resource
+          res=getNeededResources
+          res,nearest=getNextWithResource(res)
+          @restype[man]=[res,nearest]
+          if nearest.nil?
+            puts &quot;resource not found! #{res}&quot;
+            man.newRestJob(5)
+          else
+            if (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">nearest.getPos2D- at target.getPos2D</A>).length&lt;20
+              man.newMoveJob(0,nearest.getPos2D,0.5) # near but not actually there
+              man.setMode(&quot;harvest&quot;)
+            else
+              man.newRestJob(1)
+              puts &quot;TOO FAR&quot;
+            end
+          end
+        when &quot;harvest&quot; # harvest resource
+          if (@restype[man][1].getPos2D-man.getPos2D).length&lt;3
+            man.newRestJob(2)
+            man.digResource(@restype[man][0])
+            man.setMode(&quot;collect&quot;)
+          else
+            puts &quot;WAS TOO FAR AWAY - Probably job discarded&quot;
+            man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,0)
+            man.setMode(&quot;&quot;)
+          end
+        when &quot;collect&quot; # bring back
+          # FIXME: add sub resource from nearest
+          p=@restype[man]
+          amount=[p[1].resource.get(p[0]),man.canCarry].min
+          p[1].resource.sub(p[0],amount)
+          man.resource.add(p[0],amount)
+          man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,0)
+          man.collectResource(@restype[man][0])
+          man.setMode(&quot;brought&quot;)
+        when &quot;brought&quot;
+          man.setMode(&quot;after_brought&quot;)
+          man.newRestJob(1)
+          # take all natural resources - but not food and weapons - otherwise men starve!
+          myResources.each{|r|
+            @target.resource.take(man.resource,r)
+          }
+        when &quot;after_brought&quot;
+          fpos=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at hero.getPos2D</A>)
+          man.newMoveJob(0,fpos,0)
+          man.setMode(&quot;construct_torest&quot;)
+        when &quot;to_construct&quot;  # do some constructing
+          @target.incSmoke
+          man.newRestJob(5 - @hero.getAggression*0.5) # work for 3.5-5 seconds (depending on aggression)
+          man.setMode(&quot;constructing&quot;)
+          man.playSound(&quot;construct&quot;)
+        when &quot;constructing&quot;
+          # was constructing
+          readyConstructed
+          man.incExperience(man.learnAmount)
+          @target.decSmoke
+          man.setMode(&quot;construct_torest&quot;)
+          fpos=@hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at hero.getPos2D</A>)
+          man.newMoveJob(0,fpos,0)
+        when &quot;construct_torest&quot;
+          man.setMode(&quot;rest&quot;)
+          man.newRestJob(3/@hero.getAggression) # shorter pauses when aggression is higher
+          if man.getAggression&lt;3
+            checkEat(man)
+          end
+          @usedmen-=1
+        else
+          if wantmen&gt;@usedmen
+            @usedmen+=1
+            man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,0)
+            if enoughResources
+              man.setMode(&quot;to_construct&quot;)
+            else
+              man.setMode(&quot;fetch&quot;)
+            end
+          end
+      end
+    else
+      super(man)
+    end
+  end
 private
-	def myResources
-		[&quot;wood&quot;,&quot;stone&quot;,&quot;coal&quot;,&quot;ore&quot;]
-	end
-	def enoughResources
-		# FIXME support more resources
-		m=myResources.min{|a,b|@target.resource.get(a)&lt;=&gt;@target.resource.get(b)}
-		value=@target.resource.get(m)
-		return value&gt;5
-		#(@target.resource.get(&quot;stone&quot;)&gt;5 and @target.resource.get(&quot;wood&quot;)&gt;5)
-	end
-	def getNeededResources
-		m=myResources.sort{|a,b|@target.resource.get(a)&lt;=&gt;@target.resource.get(b)}
-		puts &quot;NEEDED: #{m}&quot;
-		return m
-	end
-	def getNextWithResource(res)
-		#goods={&quot;wood&quot;=&gt;&quot;tree&quot;,&quot;stone&quot;=&gt;&quot;stone&quot;,&quot;food&quot;=&gt;&quot;tree&quot;,&quot;coal&quot;=&gt;&quot;mine&quot;,&quot;ore&quot;=&gt;&quot;mine&quot;}
-		#enttype=goods[res]
-		ret=nil
-		res.each{|r|
-			ret=getMap.getNext(@target,r,1)
-			if not ret.nil?
-				ret=[r,ret]
-				break
-			end
-		}
+  def myResources
+    [&quot;wood&quot;,&quot;stone&quot;,&quot;coal&quot;,&quot;ore&quot;]
+  end
+  def enoughResources
+    # FIXME support more resources
+    m=myResources.min{|a,b|@target.resource.get(a)&lt;=&gt;@target.resource.get(b)}
+    value=@target.resource.get(m)
+    return value&gt;5
+    #(@target.resource.get(&quot;stone&quot;)&gt;5 and @target.resource.get(&quot;wood&quot;)&gt;5)
+  end
+  def getNeededResources
+    m=myResources.sort{|a,b|@target.resource.get(a)&lt;=&gt;@target.resource.get(b)}
+    puts &quot;NEEDED: #{m}&quot;
+    return m
+  end
+  def getNextWithResource(res)
+    #goods={&quot;wood&quot;=&gt;&quot;tree&quot;,&quot;stone&quot;=&gt;&quot;stone&quot;,&quot;food&quot;=&gt;&quot;tree&quot;,&quot;coal&quot;=&gt;&quot;mine&quot;,&quot;ore&quot;=&gt;&quot;mine&quot;}
+    #enttype=goods[res]
+    ret=nil
+    res.each{|r|
+      ret=getMap.getNext(@target,r,1)
+      if not ret.nil?
+        ret=[r,ret]
+        break
+      end
+    }
 
-		ret
-	end
-	def checkEat(man)
-		puts &quot;CHECKEAT&quot;
-		if man.getFood&lt;0.5
-			if man.resource.get(&quot;food&quot;)&gt;0
-				man.incFood(1)
-				man.resource.sub(&quot;food&quot;,1)
-			elsif heroHasFood
-				man.incFood(1)
-				@hero.resource.sub(&quot;food&quot;,1)
-			end
-		end
-	end
-	def heroHasFood
-		@hero.resource.get(&quot;food&quot;)&gt;0
-	end
-	def readyConstructed
-		# produce any
-		@@productionRules.shuffle.each{|rule|
-			ok=true
-			
-			rule.from.each{|w,n|
-				puts &quot;#{w},#{n}&quot;
-				if @target.resource.get(w)&lt;n
-					ok=false
-				end
-			}
-			if ok
-				# we found a useful production
-				rule.from.each{|w,n|@target.resource.sub(w,n)}
-				@target.resource.add(rule.what,1)
-				return #out
-			end
-		}
-		# something went wrong - we don't have enough resources - whatever
-	end
+    ret
+  end
+  def checkEat(man)
+    puts &quot;CHECKEAT&quot;
+    if man.getFood&lt;0.5
+      if man.resource.get(&quot;food&quot;)&gt;0
+        man.incFood(1)
+        man.resource.sub(&quot;food&quot;,1)
+      elsif heroHasFood
+        man.incFood(1)
+        @hero.resource.sub(&quot;food&quot;,1)
+      end
+    end
+  end
+  def heroHasFood
+    @hero.resource.get(&quot;food&quot;)&gt;0
+  end
+  def readyConstructed
+    # produce any
+    @@productionRules.shuffle.each{|rule|
+      ok=true
+      
+      rule.from.each{|w,n|
+        puts &quot;#{w},#{n}&quot;
+        if @target.resource.get(w)&lt;n
+          ok=false
+        end
+      }
+      if ok
+        # we found a useful production
+        rule.from.each{|w,n|@target.resource.sub(w,n)}
+        @target.resource.add(rule.what,1)
+        return #out
+      end
+    }
+    # something went wrong - we don't have enough resources - whatever
+  end
 end
 
 
 class AntHeroRestJob&lt;AntHLJob
-	def initialize(hero,time)
-		@hero=hero
-		@time=time
-		@hero.newRestJob(time)
-		@spreadThings=false
-		@men=hero.getMen
-		@hero.formation=AntFormationRest.new(@hero)
-		@basePos=@hero.getPos2D
-		@firstTime=true
-	end
-	def makeMessage(boss)
-		RestMessage.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">boss, at time</A>)
-	end
-	def image
-		&quot;data/gui/bed.png&quot;
-	end
-	def check(man)
-		if man.is_a?(AntHero)
-			if @firstTime
-				man.newRestJob(@time)
-				@firstTime=false
-			end
-			eat(man)
-			#spreadThings
-			return
-		end
-		case man.getMode
-			when &quot;rest_eat&quot;
-				spreadThings
-				eat(man)
-				sit(man)
-				man.setMode(&quot;rest_sit&quot;)
-			when &quot;rest_sit&quot;
-				sit(man)
-				if man.getFood&lt;0.5 and heroHasFood
-					man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at hero.getPos2D</A>,0)
-					man.setMode(&quot;rest_eat&quot;)
-				end
-			else
-				# rest_eat
-				man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at hero.getPos2D</A>,0)
-				man.setMode(&quot;rest_eat&quot;)
-		end
-	end
-	def finished
-		return (not @hero.hasJob)
-	end
+  def initialize(hero,time)
+    @hero=hero
+    @time=time
+    @hero.newRestJob(time)
+    @spreadThings=false
+    @men=hero.getMen
+    @hero.formation=AntFormationRest.new(@hero)
+    @basePos=@hero.getPos2D
+    @firstTime=true
+  end
+  def makeMessage(boss)
+    RestMessage.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">boss, at time</A>)
+  end
+  def image
+    &quot;data/gui/bed.png&quot;
+  end
+  def check(man)
+    if man.is_a?(AntHero)
+      if @firstTime
+        man.newRestJob(@time)
+        @firstTime=false
+      end
+      eat(man)
+      #spreadThings
+      return
+    end
+    case man.getMode
+      when &quot;rest_eat&quot;
+        spreadThings
+        eat(man)
+        sit(man)
+        man.setMode(&quot;rest_sit&quot;)
+      when &quot;rest_sit&quot;
+        sit(man)
+        if man.getFood&lt;0.5 and heroHasFood
+          man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at hero.getPos2D</A>,0)
+          man.setMode(&quot;rest_eat&quot;)
+        end
+      else
+        # rest_eat
+        man.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at hero.getPos2D</A>,0)
+        man.setMode(&quot;rest_eat&quot;)
+    end
+  end
+  def finished
+    return (not @hero.hasJob)
+  end
 private
-	include AntHeroSitting
-	def eat(man)
-		if man.getFood&lt;0.5
-			if man.resource.get(&quot;food&quot;)&gt;0
-				man.incFood(1)
-				man.resource.sub(&quot;food&quot;,1)
-			elsif heroHasFood
-				man.incFood(1)
-				@hero.resource.sub(&quot;food&quot;,1)
-			end
-		end
-	end
-	def heroHasFood
-		@hero.resource.get(&quot;food&quot;)&gt;0
-	end
-	def spreadThings
-		if @spreadThings==false
-			@spreadThings=true
-			all={}
-			rs=[&quot;sword&quot;,&quot;shield&quot;,&quot;bow&quot;,&quot;boat&quot;]
-			rs.each{|r|	
-				all=0
-				@men.each{|m|
-					c=m.resource.get(r)
-					all+=c
-				}
-				if all&gt;=@men.length
-					# give everyone 1 of these and put the rest on the hero
-					@men.each{|m|
-						m.resource.set(r,1)
-					}
-					@hero.resource.add(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">r,all- at men.length</A>)
-				else
-					men=@men.sort {|b,a|a.resource.get(r)&lt;=&gt;b.resource.get(r)} # sort descending
-					# put hero at first
-					men.delete(@hero)
-					men=[@hero]+men
-					men.each{|m|m.resource.set(r,0)} # reset
-					for i in 1..all # now give to those who had a weapon and to hero (at first)
-						men[i-1].resource.set(r,1)
-					end
-				end
-			}
-			# spread food equally
-			food=0
-			@men.each{|m|food+=m.resource.get(&quot;food&quot;)}
-			min=(food/@men.length).to_i
-			@men.each{|m|m.resource.set(&quot;food&quot;,min)}
-			# spread rest on first
-			food-=min*@men.length
-			for i in 1..food
-				@men[i-1].resource.add(&quot;food&quot;,1)
-			end
-		end
-	end
+  include AntHeroSitting
+  def eat(man)
+    if man.getFood&lt;0.5
+      if man.resource.get(&quot;food&quot;)&gt;0
+        man.incFood(1)
+        man.resource.sub(&quot;food&quot;,1)
+      elsif heroHasFood
+        man.incFood(1)
+        @hero.resource.sub(&quot;food&quot;,1)
+      end
+    end
+  end
+  def heroHasFood
+    @hero.resource.get(&quot;food&quot;)&gt;0
+  end
+  def spreadThings
+    if @spreadThings==false
+      @spreadThings=true
+      all={}
+      rs=[&quot;sword&quot;,&quot;shield&quot;,&quot;bow&quot;,&quot;boat&quot;]
+      rs.each{|r|  
+        all=0
+        @men.each{|m|
+          c=m.resource.get(r)
+          all+=c
+        }
+        if all&gt;=@men.length
+          # give everyone 1 of these and put the rest on the hero
+          @men.each{|m|
+            m.resource.set(r,1)
+          }
+          @hero.resource.add(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">r,all- at men.length</A>)
+        else
+          men=@men.sort {|b,a|a.resource.get(r)&lt;=&gt;b.resource.get(r)} # sort descending
+          # put hero at first
+          men.delete(@hero)
+          men=[@hero]+men
+          men.each{|m|m.resource.set(r,0)} # reset
+          for i in 1..all # now give to those who had a weapon and to hero (at first)
+            men[i-1].resource.set(r,1)
+          end
+        end
+      }
+      # spread food equally
+      food=0
+      @men.each{|m|food+=m.resource.get(&quot;food&quot;)}
+      min=(food/@men.length).to_i
+      @men.each{|m|m.resource.set(&quot;food&quot;,min)}
+      # spread rest on first
+      food-=min*@men.length
+      for i in 1..food
+        @men[i-1].resource.add(&quot;food&quot;,1)
+      end
+    end
+  end
 end
 
 class AntHouseFetchJob
-	def initialize(house)
-		@house=house
-	end
-	def check
-	end
+  def initialize(house)
+    @house=house
+  end
+  def check
+  end
 end
 
 
@@ -1125,7 +1125,7 @@
 
 
 def newHLJobs
-	return false
+  return false
 end
 
 else

Modified: antargis/trunk/ruby/ant_inventory.rb
===================================================================
--- antargis/trunk/ruby/ant_inventory.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_inventory.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,170 +1,170 @@
 # Inventory view
 class AntInventory&lt;AGWidget
-	@@inventory=nil
+  @@inventory=nil
 
-	attr_reader :job
-	def initialize(p,rect)
-		super(p,rect)
-		@@inventory=self
-		@resTypes=[&quot;wood&quot;,&quot;stone&quot;,&quot;men&quot;,&quot;food&quot;,&quot;tool&quot;,&quot;gold&quot;,&quot;boat&quot;,&quot;shield&quot;,&quot;sword&quot;,&quot;bow&quot;,&quot;coal&quot;,&quot;ore&quot;,&quot;steel&quot;,&quot;rod&quot;,&quot;fruit&quot;,&quot;corn&quot;,&quot;flour&quot;] #,&quot;bread&quot;]
-		setCaching(true)
-		@invinited=false
+  attr_reader :job
+  def initialize(p,rect)
+    super(p,rect)
+    @@inventory=self
+    @resTypes=[&quot;wood&quot;,&quot;stone&quot;,&quot;men&quot;,&quot;food&quot;,&quot;tool&quot;,&quot;gold&quot;,&quot;boat&quot;,&quot;shield&quot;,&quot;sword&quot;,&quot;bow&quot;,&quot;coal&quot;,&quot;ore&quot;,&quot;steel&quot;,&quot;rod&quot;,&quot;fruit&quot;,&quot;corn&quot;,&quot;flour&quot;] #,&quot;bread&quot;]
+    setCaching(true)
+    @invinited=false
 
-		@buttonNames=[&quot;doRecruit&quot;,&quot;doTakeFood&quot;,&quot;doTakeWeapons&quot;,&quot;doConstruct&quot;,&quot;doUpgrade&quot;,&quot;doContinue&quot;,&quot;doSupport&quot;]
+    @buttonNames=[&quot;doRecruit&quot;,&quot;doTakeFood&quot;,&quot;doTakeWeapons&quot;,&quot;doConstruct&quot;,&quot;doUpgrade&quot;,&quot;doContinue&quot;,&quot;doSupport&quot;]
 
-		addSignal(&quot;sigJobChanged&quot;)
+    addSignal(&quot;sigJobChanged&quot;)
 
-	end
+  end
 
-	def initHandlers
-		@buttonNames.each{|n|
-			addHandler(getChild(n),:sigClick,:eventJobChanged)
-		}
-		addHandler(getChild(&quot;doInspect&quot;),:sigClick,:eventInspect)
-	end
-	def eventJobChanged(e)
-		@job=e.getCaller.getName
-		sigJobChanged(e)
-		return true
-	end
+  def initHandlers
+    @buttonNames.each{|n|
+      addHandler(getChild(n),:sigClick,:eventJobChanged)
+    }
+    addHandler(getChild(&quot;doInspect&quot;),:sigClick,:eventInspect)
+  end
+  def eventJobChanged(e)
+    @job=e.getCaller.getName
+    sigJobChanged(e)
+    return true
+  end
 
-	def eventInspect
-		$app.viewInformation(@inspect)
-		return true
-	end
+  def eventInspect
+    $app.viewInformation(@inspect)
+    return true
+  end
 
-	def inspectEntity(e)
-		getChild(&quot;shutter&quot;).hide
-		if e.getName!=&quot;&quot; and (not e.getName=~/0\./)
-			setTitle(e.getName)
-		else
-			n=e.class.to_s
-			if n[0..2]==&quot;Ant&quot;
-				n.sub!(&quot;Ant&quot;,&quot;&quot;)
-			end
-			setTitle(n)
-		end
-		@inspect=e
-		getChild(&quot;InvBar&quot;).setHero(e)
-		updateInspection
-	end
+  def inspectEntity(e)
+    getChild(&quot;shutter&quot;).hide
+    if e.getName!=&quot;&quot; and (not e.getName=~/0\./)
+      setTitle(e.getName)
+    else
+      n=e.class.to_s
+      if n[0..2]==&quot;Ant&quot;
+        n.sub!(&quot;Ant&quot;,&quot;&quot;)
+      end
+      setTitle(n)
+    end
+    @inspect=e
+    getChild(&quot;InvBar&quot;).setHero(e)
+    updateInspection
+  end
 
-	def update(e)
-		if @inspect==e
-			updateInspection
-		end
-	end
+  def update(e)
+    if @inspect==e
+      updateInspection
+    end
+  end
 
-	def draw(p)
-		super
-	end
-	def getMap
-		getApp.getMap
-	end
+  def draw(p)
+    super
+  end
+  def getMap
+    getApp.getMap
+  end
 private
-	def checkFriend
-		if @inspect.nil?
-			return
-		end
-		friend=(@inspect.getPlayer==getMap.getPlayer)
-		enemy=(not friend)
-		getChild(&quot;friend_true&quot;).setVisible(friend)
-		getChild(&quot;friend_false&quot;).setVisible(enemy)
-		getChild(&quot;enemy_true&quot;).setVisible(enemy)
-		getChild(&quot;enemy_false&quot;).setVisible(friend)
-	end
-	def checkButtons
-		my=(@inspect.getPlayer==getMap.getPlayer and @inspect!=$app.hero)
-		
-		#myok=my # reenable other options when under attack
-		myok=(my and (not @inspect.underAttack))
+  def checkFriend
+    if @inspect.nil?
+      return
+    end
+    friend=(@inspect.getPlayer==getMap.getPlayer)
+    enemy=(not friend)
+    getChild(&quot;friend_true&quot;).setVisible(friend)
+    getChild(&quot;friend_false&quot;).setVisible(enemy)
+    getChild(&quot;enemy_true&quot;).setVisible(enemy)
+    getChild(&quot;enemy_false&quot;).setVisible(friend)
+  end
+  def checkButtons
+    my=(@inspect.getPlayer==getMap.getPlayer and @inspect!=$app.hero)
+    
+    #myok=my # reenable other options when under attack
+    myok=(my and (not @inspect.underAttack))
 
-		getChild(&quot;doRecruit&quot;).setVisible(((not my) or (not @inspect.underAttack)))
-		getChild(&quot;doRecruit&quot;).setEnabled(myok)
-		getChild(&quot;doTakeFood&quot;).setEnabled(myok)
-		getChild(&quot;doTakeWeapons&quot;).setEnabled(myok) # FIXME
+    getChild(&quot;doRecruit&quot;).setVisible(((not my) or (not @inspect.underAttack)))
+    getChild(&quot;doRecruit&quot;).setEnabled(myok)
+    getChild(&quot;doTakeFood&quot;).setEnabled(myok)
+    getChild(&quot;doTakeWeapons&quot;).setEnabled(myok) # FIXME
 
-		getChild(&quot;doConstruct&quot;).setVisible(@inspect.is_a?(AntHouse))
-		getChild(&quot;doUpgrade&quot;).setVisible((not @inspect.is_a?(AntHouse)))
-		getChild(&quot;doConstruct&quot;).setEnabled((my and @inspect.is_a?(AntWorkshop)))
-		getChild(&quot;doUpgrade&quot;).setEnabled((my and @inspect.experience&gt;0.95))
-		getChild(&quot;doContinue&quot;).setVisible(@inspect.is_a?(AntBuildingSite)) # FIXME!!!!!!!!!!!
-		getChild(&quot;doContinue&quot;).setEnabled(@inspect.is_a?(AntBuildingSite)) # FIXME!!!!!!!!!!!
+    getChild(&quot;doConstruct&quot;).setVisible(@inspect.is_a?(AntHouse))
+    getChild(&quot;doUpgrade&quot;).setVisible((not @inspect.is_a?(AntHouse)))
+    getChild(&quot;doConstruct&quot;).setEnabled((my and @inspect.is_a?(AntWorkshop)))
+    getChild(&quot;doUpgrade&quot;).setEnabled((my and @inspect.experience&gt;0.95))
+    getChild(&quot;doContinue&quot;).setVisible(@inspect.is_a?(AntBuildingSite)) # FIXME!!!!!!!!!!!
+    getChild(&quot;doContinue&quot;).setEnabled(@inspect.is_a?(AntBuildingSite)) # FIXME!!!!!!!!!!!
 
-		# support / hide recruit
-		getChild(&quot;doSupport&quot;).setVisible((my and @inspect.underAttack))
+    # support / hide recruit
+    getChild(&quot;doSupport&quot;).setVisible((my and @inspect.underAttack))
 
-		
-	end
+    
+  end
 
-	def setValue(name,value)
-		ok=@resTypes+[&quot;boss&quot;]
-		if ok.member?(name) then
-			w=getChild(name)
-			return if not w 
-			mv=value
-			if value.class!=String
-				mv=value.to_i.to_s
-			end
-			if w.getText.to_s!=mv
-				w.setText AGStringUtf8.new(mv)
-			end
-		end
-	end
-	def setTitle(t)
-		t=_(t)
-		c=getChild(&quot;invTitle&quot;)
-		if c.class==AGButton
-			c.setCaption(t)
-		else
-			c.setText(AGStringUtf8.new(t))
-		end
-	end
-	def updateInspection
-		if @inspect then
-			checkButtons
-			checkFriend
-			res=@inspect.resource.getAll
-			res[&quot;men&quot;]=@inspect.menCount.to_f
-			@resTypes.each{|a|
-				b=res[a]
-				b||=0
-				setValue(a,b)
-			}
-			setValue(&quot;name&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at inspect.getName</A>)
-			bossname=&quot;&quot;
-			if @inspect.methods.member?(&quot;getPlayer&quot;)
-				if @inspect.getPlayer
-					bossname=@inspect.getPlayer.getName
-				end
-			end
-			setValue(&quot;boss&quot;,bossname)
+  def setValue(name,value)
+    ok=@resTypes+[&quot;boss&quot;]
+    if ok.member?(name) then
+      w=getChild(name)
+      return if not w 
+      mv=value
+      if value.class!=String
+        mv=value.to_i.to_s
+      end
+      if w.getText.to_s!=mv
+        w.setText AGStringUtf8.new(mv)
+      end
+    end
+  end
+  def setTitle(t)
+    t=_(t)
+    c=getChild(&quot;invTitle&quot;)
+    if c.class==AGButton
+      c.setCaption(t)
+    else
+      c.setText(AGStringUtf8.new(t))
+    end
+  end
+  def updateInspection
+    if @inspect then
+      checkButtons
+      checkFriend
+      res=@inspect.resource.getAll
+      res[&quot;men&quot;]=@inspect.menCount.to_f
+      @resTypes.each{|a|
+        b=res[a]
+        b||=0
+        setValue(a,b)
+      }
+      setValue(&quot;name&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at inspect.getName</A>)
+      bossname=&quot;&quot;
+      if @inspect.methods.member?(&quot;getPlayer&quot;)
+        if @inspect.getPlayer
+          bossname=@inspect.getPlayer.getName
+        end
+      end
+      setValue(&quot;boss&quot;,bossname)
 
-			if bossname
-				if bossname==@inspect.getName or bossname==&quot;&quot;
-					getChild(&quot;minion&quot;).setText(_(&quot;Obeys nobody&quot;))
-				else
-					getChild(&quot;minion&quot;).setText(_(&quot;Obeys {1}&quot;,bossname.to_s))
-				end
-			end
-			#redraw
-		end
-	end
+      if bossname
+        if bossname==@inspect.getName or bossname==&quot;&quot;
+          getChild(&quot;minion&quot;).setText(_(&quot;Obeys nobody&quot;))
+        else
+          getChild(&quot;minion&quot;).setText(_(&quot;Obeys {1}&quot;,bossname.to_s))
+        end
+      end
+      #redraw
+    end
+  end
 
-	def AntInventory.inspectEntity(entity)
-		@@inventory.inspectEntity(entity) if @@inventory
-	end
-	def AntInventory.update(entity)
-		@@inventory.update(entity) if @@inventory
-	end
-	def AntInventory.resetPointer
-		@@inventory=nil
-	end
+  def AntInventory.inspectEntity(entity)
+    @@inventory.inspectEntity(entity) if @@inventory
+  end
+  def AntInventory.update(entity)
+    @@inventory.update(entity) if @@inventory
+  end
+  def AntInventory.resetPointer
+    @@inventory=nil
+  end
 end
 
 class AntInventoryCreator&lt;AGLayoutCreator
-	def create(parent,rect,node)
-		setResult(AntInventory.new(parent,rect))
-	end
+  def create(parent,rect,node)
+    setResult(AntInventory.new(parent,rect))
+  end
 end
 getLayoutFactory.addCreator(&quot;antInventory&quot;,AntInventoryCreator.new)

Modified: antargis/trunk/ruby/ant_level.rb
===================================================================
--- antargis/trunk/ruby/ant_level.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_level.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -31,192 +31,192 @@
 # This is the base scripting interface. Everything you want to do within level-scripting
 # can be accessed through this class and the objects you can get here. 
 class AntLevelInterface
-	# you won't be able to create such an interface within a script. It will be created for you
-	# in map.rb
-	def initialize(map,app)
-		@map=map
-		@app=app
-	end
+  # you won't be able to create such an interface within a script. It will be created for you
+  # in map.rb
+  def initialize(map,app)
+    @map=map
+    @app=app
+  end
 
-	# get interface-objects for all players. returns an array of all the players
-	def getPlayers
-		@map.players.collect{|p|AntLevelPlayer.new(p)}
-	end
+  # get interface-objects for all players. returns an array of all the players
+  def getPlayers
+    @map.players.collect{|p|AntLevelPlayer.new(p)}
+  end
 
-	def getPlayer(name)
-		return nil if not name.is_a?(String)
-		getPlayers.select{|p|p.getName==name}[0]
-	end
+  def getPlayer(name)
+    return nil if not name.is_a?(String)
+    getPlayers.select{|p|p.getName==name}[0]
+  end
 
-	def getHero(name)
-		return nil if not name.is_a?(String)
-		e=@map.getByName(name)
-		if e
-			return AntLevelHero.new(e)
-		end
-	end
+  def getHero(name)
+    return nil if not name.is_a?(String)
+    e=@map.getByName(name)
+    if e
+      return AntLevelHero.new(e)
+    end
+  end
 
-	def getTarget(name)
-		return nil if not name.is_a?(String)
-		return getMap.getTarget(name)
-	end
+  def getTarget(name)
+    return nil if not name.is_a?(String)
+    return getMap.getTarget(name)
+  end
 
-	# use this to set the level's state to &quot;won&quot;
-	def wonLevel
-		@app.setResult(GameResult.new(&quot;won&quot;))
-	end
-	# use this to set the level's state to &quot;lost&quot;
-	def lostLevel
-		@app.setResult(GameResult.new(&quot;lost&quot;))
-	end
-	# calling this function will instantly end this level
-	# please set the level's state first by calling wonLevel or lostLevel
-	# before calling this function
-	def endLevel
-		@app.tryQuit
-	end
+  # use this to set the level's state to &quot;won&quot;
+  def wonLevel
+    @app.setResult(GameResult.new(&quot;won&quot;))
+  end
+  # use this to set the level's state to &quot;lost&quot;
+  def lostLevel
+    @app.setResult(GameResult.new(&quot;lost&quot;))
+  end
+  # calling this function will instantly end this level
+  # please set the level's state first by calling wonLevel or lostLevel
+  # before calling this function
+  def endLevel
+    @app.tryQuit
+  end
 
-	# tellStory will pause the game and display some text-dialogs in the middle of the screen
-	# - flow is of type StoryFlow - go there for a examples on how to pack a story into this one
-	def tellStory(flow)
-		return unless flow.is_a?(StoryFlow)
-		@app.tellStory(flow)
-		@story=flow
-	end
+  # tellStory will pause the game and display some text-dialogs in the middle of the screen
+  # - flow is of type StoryFlow - go there for a examples on how to pack a story into this one
+  def tellStory(flow)
+    return unless flow.is_a?(StoryFlow)
+    @app.tellStory(flow)
+    @story=flow
+  end
 
-	def focusEntity(entity)
-		return unless entity.is_a?(AntLevelEntity)
-		@app.focusHero(getMap.getByName(entity.getName))
-	end
+  def focusEntity(entity)
+    return unless entity.is_a?(AntLevelEntity)
+    @app.focusHero(getMap.getByName(entity.getName))
+  end
 end
 
 class AntLevelPlayer
-	def initialize(player)
-		@player=player
-	end
-	def getHeroes
-		@player.getHeroes.map{|p|AIMyHero.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p, at player</A>)}
-	end
-	def getBuildings
-		@player.getBuildings.map{|p|AIMyBuilding.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p, at player</A>)}
-	end
-	def getName
-		@player.getName
-	end
+  def initialize(player)
+    @player=player
+  end
+  def getHeroes
+    @player.getHeroes.map{|p|AIMyHero.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p, at player</A>)}
+  end
+  def getBuildings
+    @player.getBuildings.map{|p|AIMyBuilding.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p, at player</A>)}
+  end
+  def getName
+    @player.getName
+  end
 end
 
 class AntLevelEntity
-	include AntScriptingEntityFullAccess
-	include AntScriptingEntityEnhancedAccess
-	def initialize(ent)
-		@ent=ent
-		@valid=true
-	end
-	def is_a?(pclass)
-		@ent.is_a?(pclass) or super(pclass)
-	end
-	# FIXME: check this ???
-	def valid
-		@valid
-	end
-	def ==(e)
-		return -1 unless e.is_a?(AntLevelEntity)
-		@ent==getMap.getByName(e.getName)
-	end		
-	def &lt;=&gt;(e)
-		return -1 unless e.is_a?(AntLevelEntity)
-		@ent&lt;=&gt;getMap.getByName(e.getName)
-	end
+  include AntScriptingEntityFullAccess
+  include AntScriptingEntityEnhancedAccess
+  def initialize(ent)
+    @ent=ent
+    @valid=true
+  end
+  def is_a?(pclass)
+    @ent.is_a?(pclass) or super(pclass)
+  end
+  # FIXME: check this ???
+  def valid
+    @valid
+  end
+  def ==(e)
+    return -1 unless e.is_a?(AntLevelEntity)
+    @ent==getMap.getByName(e.getName)
+  end    
+  def &lt;=&gt;(e)
+    return -1 unless e.is_a?(AntLevelEntity)
+    @ent&lt;=&gt;getMap.getByName(e.getName)
+  end
 end
 
 class AntLevelHero&lt;AntLevelEntity
-	include AntScriptingHeroFullAccess
-	def getPlayer
-		AntLevelPlayer.new(@ent.getPlayer)
-	end
+  include AntScriptingHeroFullAccess
+  def getPlayer
+    AntLevelPlayer.new(@ent.getPlayer)
+  end
 end
 
 class AntLevelJob
-	def initialize(job)
-		@job=job
-	end
-	def is_a?(pclass)
-		@job.is_a?(pclass)
-	end
-	def target
-		AntLevelEntity.new(@job.target)
-	end
+  def initialize(job)
+    @job=job
+  end
+  def is_a?(pclass)
+    @job.is_a?(pclass)
+  end
+  def target
+    AntLevelEntity.new(@job.target)
+  end
 end
 
 class AntLevelScript
-	def initialize(interface)
-		@interface=interface
-	end
-	def eventTrigger(hero,trigger)
-	end
-	def eventOwnerChanged(ent)
-	end
-	def eventHeroDied(ent)
-	end
-	def eventHLJobFinished(hero,job)
-	end
-	def eventDismissed(hero)
-	end
-	def eventLevelStarted
-	end
+  def initialize(interface)
+    @interface=interface
+  end
+  def eventTrigger(hero,trigger)
+  end
+  def eventOwnerChanged(ent)
+  end
+  def eventHeroDied(ent)
+  end
+  def eventHLJobFinished(hero,job)
+  end
+  def eventDismissed(hero)
+  end
+  def eventLevelStarted
+  end
 
-	def saveXML(node)
-		saveLocals(node)
-	end
-	def loadXML(node)
-		loadLocals(node)
-	end
-	
-	def method_missing(*s)
-		dputs &quot;method_missing:&quot;,s
-		@interface.send(*s)
-	end
+  def saveXML(node)
+    saveLocals(node)
+  end
+  def loadXML(node)
+    loadLocals(node)
+  end
+  
+  def method_missing(*s)
+    dputs &quot;method_missing:&quot;,s
+    @interface.send(*s)
+  end
 
 # maybe exchange this
 private
-	def getLocals
-		a={}
-		instance_variables.each{|v|
-			a[v]=instance_variable_get(v)
-		}
-		return a
-	end
-	def saveLocals(node)
-		getLocals.each{|n,v|
-			c=node.addChild(&quot;local&quot;)
-			if not v.is_a?(AntLevelInterface)
-				c.set(&quot;name&quot;,n)
-				c.set(&quot;type&quot;,v.class.to_s)
-				c.set(&quot;value&quot;,v.to_s)
-			end
-		}
-	end
-	def loadLocals(node)
-		node.getChildren(&quot;local&quot;).each{|c|
-			n=c.get(&quot;name&quot;)
-			v=nil
-			case c.get(&quot;type&quot;)
-				when &quot;TrueClass&quot;
-					v=true
-				when &quot;FalseClass&quot;
-					v=false
-				when &quot;Fixnum&quot;,&quot;Bignum&quot;
-					v=c.get(&quot;value&quot;).to_i
-				when &quot;Float&quot;
-					v=c.get(&quot;value&quot;).to_f
-				when &quot;String&quot;
-					v=c.get(&quot;value&quot;)
-			end
-			if v
-				instance_variable_set(n,v)
-			end
-		}
-	end
+  def getLocals
+    a={}
+    instance_variables.each{|v|
+      a[v]=instance_variable_get(v)
+    }
+    return a
+  end
+  def saveLocals(node)
+    getLocals.each{|n,v|
+      c=node.addChild(&quot;local&quot;)
+      if not v.is_a?(AntLevelInterface)
+        c.set(&quot;name&quot;,n)
+        c.set(&quot;type&quot;,v.class.to_s)
+        c.set(&quot;value&quot;,v.to_s)
+      end
+    }
+  end
+  def loadLocals(node)
+    node.getChildren(&quot;local&quot;).each{|c|
+      n=c.get(&quot;name&quot;)
+      v=nil
+      case c.get(&quot;type&quot;)
+        when &quot;TrueClass&quot;
+          v=true
+        when &quot;FalseClass&quot;
+          v=false
+        when &quot;Fixnum&quot;,&quot;Bignum&quot;
+          v=c.get(&quot;value&quot;).to_i
+        when &quot;Float&quot;
+          v=c.get(&quot;value&quot;).to_f
+        when &quot;String&quot;
+          v=c.get(&quot;value&quot;)
+      end
+      if v
+        instance_variable_set(n,v)
+      end
+    }
+  end
 
 end
 

Modified: antargis/trunk/ruby/ant_local.rb
===================================================================
--- antargis/trunk/ruby/ant_local.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_local.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -28,109 +28,109 @@
 
 $ENV=ENV
 def getLanguage
-	if $ENV[&quot;LANG&quot;]
-		$ENV[&quot;LANG&quot;].sub(/_.*/,&quot;&quot;)
-	else
-		# windows - try estimating thruogh &quot;Program Files&quot;-dir name
-		known={&quot;Programme&quot;=&gt;&quot;de&quot;,
-		 &quot;Archivos de programa&quot;=&gt;&quot;es&quot;}
-		if $ENV.has_key?(&quot;CommonProgramFiles&quot;)
-			n=$ENV[&quot;CommonProgramFiles&quot;].split(&quot;\\&quot;)[1]
-			if known[n]
-				return known[n]
-			end
-		end
-		return &quot;en&quot;
-	end
+  if $ENV[&quot;LANG&quot;]
+    $ENV[&quot;LANG&quot;].sub(/_.*/,&quot;&quot;)
+  else
+    # windows - try estimating thruogh &quot;Program Files&quot;-dir name
+    known={&quot;Programme&quot;=&gt;&quot;de&quot;,
+     &quot;Archivos de programa&quot;=&gt;&quot;es&quot;}
+    if $ENV.has_key?(&quot;CommonProgramFiles&quot;)
+      n=$ENV[&quot;CommonProgramFiles&quot;].split(&quot;\\&quot;)[1]
+      if known[n]
+        return known[n]
+      end
+    end
+    return &quot;en&quot;
+  end
 end
 
 class AntLocalizer&lt;AGLocalizer
-	def initialize(l=getLanguage)
-		super()
-		@table={}
-		@lang=l
-		read
-	end
-	def process(x)
-		x=x.to_s.gsub(&quot;\n&quot;,&quot;\\n&quot;)
-		r=myprocess(x)
-		#puts &quot;TRANSLATE: #{x} #{r.class}&quot;
-		return r
-	end
-	def myprocess(x)
-		if x.is_a?(AGStringUtf8)
-			x=x.to_s
-		end
+  def initialize(l=getLanguage)
+    super()
+    @table={}
+    @lang=l
+    read
+  end
+  def process(x)
+    x=x.to_s.gsub(&quot;\n&quot;,&quot;\\n&quot;)
+    r=myprocess(x)
+    #puts &quot;TRANSLATE: #{x} #{r.class}&quot;
+    return r
+  end
+  def myprocess(x)
+    if x.is_a?(AGStringUtf8)
+      x=x.to_s
+    end
 
-		if @table.member?(x)
-			if (not @table[x].nil?) and @table[x].length&gt;0
-				return AGStringUtf8.new(@table[x].gsub(&quot;\\n&quot;,&quot;\n&quot;))
-			end
-		end
-		x||=&quot;&quot;
-			
-		@table[x]=&quot;&quot;
-		#write
-		return AGStringUtf8.new(x.to_s)
-	end
-	def find(x)
-		process(x)
-	end
+    if @table.member?(x)
+      if (not @table[x].nil?) and @table[x].length&gt;0
+        return AGStringUtf8.new(@table[x].gsub(&quot;\\n&quot;,&quot;\n&quot;))
+      end
+    end
+    x||=&quot;&quot;
+      
+    @table[x]=&quot;&quot;
+    #write
+    return AGStringUtf8.new(x.to_s)
+  end
+  def find(x)
+    process(x)
+  end
 
-	def finalize
-		write
-	end
+  def finalize
+    write
+  end
 
 private
-	def read
-		c=loadFile(&quot;data/local/local_#{@lang}.txt&quot;)
-		c.split(&quot;\n&quot;).each{|l|
-			langc,langm=l.split(&quot;;;&quot;)
-			if langc
-				if not langm
-					langm=&quot;&quot;
-				end
-				@table[langc]=langm
-			end
-		}
-	end
-	def write
-		o=&quot;&quot;
-		# save incomplete at first
-		@table.each{|n,v|
-			if v.nil? or v.length==0
-				#puts &quot;98: #{n} -- #{v}&quot;
-				o+=n.to_s+&quot;;;&quot;+v.to_s+&quot;\n&quot;
-			end
-		}
-		@table.each{|n,v|
-			if (not v.nil?) or v.length&gt;0
-				o+=n.to_s+&quot;;;&quot;+v.to_s+&quot;\n&quot;
-			end
-		}
-		saveFile(&quot;data/local/local_#{@lang}.txt&quot;,o)
-		o=&quot;&quot;
-		#startGC # run GC because of much overhead
-	end
+  def read
+    c=loadFile(&quot;data/local/local_#{@lang}.txt&quot;)
+    c.split(&quot;\n&quot;).each{|l|
+      langc,langm=l.split(&quot;;;&quot;)
+      if langc
+        if not langm
+          langm=&quot;&quot;
+        end
+        @table[langc]=langm
+      end
+    }
+  end
+  def write
+    o=&quot;&quot;
+    # save incomplete at first
+    @table.each{|n,v|
+      if v.nil? or v.length==0
+        #puts &quot;98: #{n} -- #{v}&quot;
+        o+=n.to_s+&quot;;;&quot;+v.to_s+&quot;\n&quot;
+      end
+    }
+    @table.each{|n,v|
+      if (not v.nil?) or v.length&gt;0
+        o+=n.to_s+&quot;;;&quot;+v.to_s+&quot;\n&quot;
+      end
+    }
+    saveFile(&quot;data/local/local_#{@lang}.txt&quot;,o)
+    o=&quot;&quot;
+    #startGC # run GC because of much overhead
+  end
 end
 
 module MyLocalizer
-	# set localizer, so that it can be accessed from c++ too
-	setLocalizer(@@localizer=AntLocalizer.new) # set global due to GC
-	
-	def MyLocalizer.translate(a)
-		# FIXME:lookup
-		@@localizer.process(a)
-	end
-	def MyLocalizer.finalize
-		@@localizer.finalize
-	end
+  # set localizer, so that it can be accessed from c++ too
+  setLocalizer(@@localizer=AntLocalizer.new) # set global due to GC
+  
+  def MyLocalizer.translate(a)
+    # FIXME:lookup
+    @@localizer.process(a)
+  end
+  def MyLocalizer.finalize
+    @@localizer.finalize
+  end
 end
 def _(a,*args)
-	a=MyLocalizer.translate(a).to_s
-	(1..args.length).each{|i|
-		a.sub!(&quot;{#{i}}&quot;,args[i-1].to_s)
-	}
-	a=AGStringUtf8.new(a)
-	return a
+  a=MyLocalizer.translate(a).to_s
+  (1..args.length).each{|i|
+    a.sub!(&quot;{#{i}}&quot;,args[i-1].to_s)
+  }
+  a=AGStringUtf8.new(a)
+  return a
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_messagebox.rb
===================================================================
--- antargis/trunk/ruby/ant_messagebox.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_messagebox.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,27 +1,27 @@
 class MessageBox&lt;AntDialog
-	include AGHandler
+  include AGHandler
 
-	attr_accessor :block
-	def initialize(p,f)
-		super
-		addHandler(getChild(&quot;ok&quot;),:sigClick,:eventClick)
-		addHandler(getChild(&quot;cancel&quot;),:sigClick,:eventClick)
-	end
-	def eventClose(e)
-		puts &quot;EVENT CLOSE&quot;
-		super
-		if @block
-			@block.call(&quot;close&quot;)
-		end
-		return true
-	end
-	def eventClick(e)
-		#super
-		if @block
-			@block.call(e.getCaller.getName)
-		end
-		return false
-	end
+  attr_accessor :block
+  def initialize(p,f)
+    super
+    addHandler(getChild(&quot;ok&quot;),:sigClick,:eventClick)
+    addHandler(getChild(&quot;cancel&quot;),:sigClick,:eventClick)
+  end
+  def eventClose(e)
+    puts &quot;EVENT CLOSE&quot;
+    super
+    if @block
+      @block.call(&quot;close&quot;)
+    end
+    return true
+  end
+  def eventClick(e)
+    #super
+    if @block
+      @block.call(e.getCaller.getName)
+    end
+    return false
+  end
 end
 
 MB_OK=1
@@ -30,10 +30,10 @@
 MB_NO=8
 
 def messageBox(app,title,text,flags,&amp;block)
-	mw=app.getMainWidget
-	w=MessageBox.new(mw,&quot;data/gui/layout/messagebox.xml&quot;)
-	w.block=block
-	w.getChild(&quot;title&quot;).setText(title)
-	w.getChild(&quot;text&quot;).setText(text)
-	mw.addChild(w)
+  mw=app.getMainWidget
+  w=MessageBox.new(mw,&quot;data/gui/layout/messagebox.xml&quot;)
+  w.block=block
+  w.getChild(&quot;title&quot;).setText(title)
+  w.getChild(&quot;text&quot;).setText(text)
+  mw.addChild(w)
 end

Modified: antargis/trunk/ruby/ant_models.rb
===================================================================
--- antargis/trunk/ruby/ant_models.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_models.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -2,282 +2,282 @@
 require 'meshes/grass.rb'
 
 module AntModels
-	@@useImpostors=false
-	
-	def AntModels.getStaticModelRotation(name)
-		rot={
-			&quot;tower&quot;=&gt;-30,
-			&quot;ant_mill&quot;=&gt;-30,
-			&quot;mine2&quot;=&gt;-40,
-			&quot;workshop&quot;=&gt;-50,
-			&quot;townhall_try2&quot;=&gt;-60,
-			&quot;well&quot;=&gt;-30,
-			&quot;ant_bakery&quot;=&gt;-30,
-			&quot;ant_coach&quot;=&gt;-50,
-			&quot;livinghouse&quot;=&gt;-20,
-			&quot;farm&quot;=&gt;-30,
-		}
-	
-		if rot.member?(name)
-			return rot[name]
-		end
-		return 0
-	end
-	
-	def AntModels.getStaticModelScaling(name)
-		scales={
-			&quot;sack&quot;=&gt;0.3,
-			&quot;stub&quot;=&gt;0.04,
-			&quot;tower&quot;=&gt;3,
-			&quot;ant_mill&quot;=&gt;3.2,
-			&quot;mine2&quot;=&gt;0.2,
-			&quot;workshop&quot;=&gt;0.18,
-			&quot;townhall_try2&quot;=&gt;3.2,
-			&quot;well&quot;=&gt;0.06,
-			&quot;rip&quot;=&gt;0.3,
-			&quot;fish&quot;=&gt;0.02,
-			&quot;arrow&quot;=&gt;0.1,
-			&quot;ant_bakery&quot;=&gt;3.0,
-			&quot;boat_simple&quot;=&gt;0.12,
-			&quot;twig&quot;=&gt;0.7,
-			&quot;ant_coach&quot;=&gt;0.08,
-			&quot;druid_lp&quot;=&gt;0.08,
-			&quot;smith_lp&quot;=&gt;0.08,
-			&quot;livinghouse&quot;=&gt;0.16,
-			&quot;farm&quot;=&gt;0.2,
-			&quot;fire&quot;=&gt;0.3,
-			&quot;big_stone&quot;=&gt;0.7,
-			&quot;grave&quot;=&gt;0.2,
-			&quot;hero_lp&quot;=&gt;0.08,
-		}
-	
-		if scales.member?(name)
-			return scales[name]
-		end
-		return 1
-	end
+  @@useImpostors=false
+  
+  def AntModels.getStaticModelRotation(name)
+    rot={
+      &quot;tower&quot;=&gt;-30,
+      &quot;ant_mill&quot;=&gt;-30,
+      &quot;mine2&quot;=&gt;-40,
+      &quot;workshop&quot;=&gt;-50,
+      &quot;townhall_try2&quot;=&gt;-60,
+      &quot;well&quot;=&gt;-30,
+      &quot;ant_bakery&quot;=&gt;-30,
+      &quot;ant_coach&quot;=&gt;-50,
+      &quot;livinghouse&quot;=&gt;-20,
+      &quot;farm&quot;=&gt;-30,
+    }
+  
+    if rot.member?(name)
+      return rot[name]
+    end
+    return 0
+  end
+  
+  def AntModels.getStaticModelScaling(name)
+    scales={
+      &quot;sack&quot;=&gt;0.3,
+      &quot;stub&quot;=&gt;0.04,
+      &quot;tower&quot;=&gt;3,
+      &quot;ant_mill&quot;=&gt;3.2,
+      &quot;mine2&quot;=&gt;0.2,
+      &quot;workshop&quot;=&gt;0.18,
+      &quot;townhall_try2&quot;=&gt;3.2,
+      &quot;well&quot;=&gt;0.06,
+      &quot;rip&quot;=&gt;0.3,
+      &quot;fish&quot;=&gt;0.02,
+      &quot;arrow&quot;=&gt;0.1,
+      &quot;ant_bakery&quot;=&gt;3.0,
+      &quot;boat_simple&quot;=&gt;0.12,
+      &quot;twig&quot;=&gt;0.7,
+      &quot;ant_coach&quot;=&gt;0.08,
+      &quot;druid_lp&quot;=&gt;0.08,
+      &quot;smith_lp&quot;=&gt;0.08,
+      &quot;livinghouse&quot;=&gt;0.16,
+      &quot;farm&quot;=&gt;0.2,
+      &quot;fire&quot;=&gt;0.3,
+      &quot;big_stone&quot;=&gt;0.7,
+      &quot;grave&quot;=&gt;0.2,
+      &quot;hero_lp&quot;=&gt;0.08,
+    }
+  
+    if scales.member?(name)
+      return scales[name]
+    end
+    return 1
+  end
 
-	def AntModels.generateMesh(entity,size)
-		case entity
-			when AntBush
-				makeBushMesh(entity.getMap.getScene,size*3)
-			when AntGrass
-				makeGrassMesh(entity.getMap.getScene,size)
-			else
-				nil
-		end
-		
-	end
-	
-	def AntModels.getMeshMap
-		animMeshes={
-			:man=&gt;{
-				[]=&gt;&quot;data/models/man_e_walk.anim&quot;,
-				[&quot;wood&quot;]=&gt;&quot;data/models/man_e_wood.anim&quot;,
-				[&quot;stone&quot;,&quot;flour&quot;,&quot;corn&quot;]=&gt;&quot;data/models/man_e_stones.anim&quot;,
-				[&quot;walk&quot;,&quot;sitdown&quot;,&quot;sit&quot;,&quot;stand&quot;]=&gt;&quot;data/models/man_e_walk.anim&quot;,
-				[&quot;fight_dagger&quot;]=&gt;&quot;data/models/man_e_dagger.anim&quot;,
-				[&quot;fight_shield&quot;]=&gt;&quot;data/models/man_e_shield.anim&quot;,
-				[&quot;fight_sword&quot;]=&gt;&quot;data/models/man_e_sword.anim&quot;,
-				[&quot;fight_bow&quot;]=&gt;&quot;data/models/man_e_bow.anim&quot;,
-				[&quot;pick&quot;]=&gt;&quot;data/models/man_pick.anim&quot;,
-				[&quot;axe&quot;]=&gt;&quot;data/models/man_axe.anim&quot;,
-				[:grave]=&gt;&quot;grave&quot;,
-			},
-			:grave=&gt;{
-				[:normal]=&gt;&quot;grave&quot;,
-				[:hero]=&gt;[&quot;data/models/grave.ant2&quot;,0.2,&quot;data/textures/models/grave3.png&quot;],
-			},
-			:hero=&gt;{
-				[]=&gt;&quot;hero_lp&quot;,
-				[:grave_hero]=&gt;[&quot;data/models/grave.ant2&quot;,0.2,&quot;data/textures/models/grave3.png&quot;],
-			},
-			:sack=&gt;{
-				[]=&gt;&quot;sack&quot;
-			},
-			:tree=&gt;{
-				[]=&gt;[&quot;data/models/fir2.ant2&quot;,0.45,&quot;data/textures/models/fir5.png&quot;,false],
-				[&quot;stub&quot;]=&gt;&quot;stub&quot;,
-				[0]=&gt;[&quot;data/models/fir2.ant2&quot;,0.45,&quot;data/textures/models/fir5.png&quot;,false],
-				[1]=&gt;[&quot;data/models/fir2.ant2&quot;,0.45,&quot;data/textures/models/fir7.png&quot;,false],
-				[2]=&gt;[&quot;data/models/tree5.ant2&quot;,0.45,&quot;data/textures/models/tree3.png&quot;,false],
-				[3]=&gt;[&quot;data/models/tree5.ant2&quot;,0.45,&quot;data/textures/models/tree5.png&quot;,false],
-				[4]=&gt;[&quot;data/models/tree5.ant2&quot;,0.45,&quot;data/textures/models/tree9.png&quot;,false],
-				[5]=&gt;[&quot;data/models/tree6.ant2&quot;,0.45,&quot;data/textures/models/tree5.png&quot;,false],
-				[6]=&gt;[&quot;data/models/tree5.ant2&quot;,0.45,&quot;data/textures/models/tree10.png&quot;,false],
-				[7]=&gt;[&quot;data/models/tree_simple1.ant2&quot;,0.3,&quot;data/textures/models/tree_simple1.png&quot;],
-				[8]=&gt;[&quot;data/models/tree_simple2.ant2&quot;,0.3,&quot;data/textures/models/tree_simple1.png&quot;],
-				[9]=&gt;[&quot;data/models/tree_simple5.ant2&quot;,0.3,&quot;data/textures/models/tree_simple5.png&quot;]
-			},
-			:buildingsite=&gt;{
-				[]=&gt;[&quot;data/models/building_site0.ant2&quot;,1.7,&quot;data/textures/models/building_site0.png&quot;],
-				[0]=&gt;[&quot;data/models/building_site0.ant2&quot;,1.7,&quot;data/textures/models/building_site0.png&quot;],
-				[1]=&gt;[&quot;data/models/building_site1.ant2&quot;,1.7,&quot;data/textures/models/building_site1.png&quot;],
-				[2]=&gt;[&quot;data/models/building_site2.ant2&quot;,1.7,&quot;data/textures/models/building_site1.png&quot;],
-			},
-			:field=&gt;{
-				[]=&gt;[&quot;data/models/crop_tiny.ant2&quot;,2.2,&quot;data/textures/models/crop_tiny.png&quot;],
-				[0]=&gt;[&quot;data/models/crop_tiny.ant2&quot;,2.2,&quot;data/textures/models/crop_tiny.png&quot;],
-				[1]=&gt;[&quot;data/models/crop_small.ant2&quot;,2.2,&quot;data/textures/models/crop_green.png&quot;],
-				[2]=&gt;[&quot;data/models/crop_med.ant2&quot;,2.2,&quot;data/textures/models/crop_yellow.png&quot;],
-				[3]=&gt;[&quot;data/models/crop_high.ant2&quot;,2.2,&quot;data/textures/models/crop_gold.png&quot;]
-			},
-			:tower=&gt;{
-				[]=&gt;&quot;tower&quot;
-			},
-			:wolf=&gt;{
-				[]=&gt;&quot;ant_wolf&quot;,
-				[:rip]=&gt;&quot;rip&quot;
-			},
-			:mill=&gt;{
-				[]=&gt;&quot;ant_mill&quot;
-			},
-			:mine=&gt;{
-				[]=&gt;&quot;mine2&quot;
-			},
-			:workshop=&gt;{
-				[]=&gt;&quot;workshop&quot;
-			},
-			:townhall=&gt;{
-				[]=&gt;&quot;townhall_try2&quot;
-			},
-			:well=&gt;{
-				[]=&gt;&quot;well&quot;
-			},
-			:fish=&gt;{
-				[]=&gt;&quot;fish&quot;
-			},
-			:sheep=&gt;{
-				[]=&gt;&quot;data/models/sheep.anim&quot;,
-				[:rip]=&gt;&quot;rip&quot;
-			},
-			:arrow=&gt;{
-				[]=&gt;&quot;arrow&quot;
-			},
-			:bakery=&gt;{
-				[]=&gt;&quot;ant_bakery&quot;
-			},
-			:boat=&gt;{
-				[]=&gt;&quot;boat_simple&quot;
-			},
-			:deco=&gt;{
-				[:floor_deco]=&gt;[&quot;data/models/floor.ant2&quot;,0.5,&quot;data/textures/splats/stones1a.png&quot;],
-			},
- 			:twig=&gt;{	
- 				[]=&gt;&quot;twig&quot;
- 			},
-			:decomesh=&gt;{ # FIXME: remove this and the class, too ??
-				[]=&gt;&quot;ant_coach&quot;
-			},
-			:coach=&gt;{
-				[]=&gt;&quot;ant_coach&quot;
-			},
-			:decal=&gt;
-			{
-				[:floor_gravel]=&gt;[&quot;data/models/floor.ant2&quot;,0.8,&quot;data/textures/gravel4.png&quot;],
-			},
-			:npc=&gt;{
-				[:druid]=&gt;&quot;druid_lp&quot;,
-				[:smith]=&gt;&quot;smith_lp&quot;
-			},	
-			:dwelling=&gt;
-			{
-				[]=&gt;&quot;livinghouse&quot;
-			},
-			:farm=&gt;
-			{
-				[]=&gt;&quot;farm&quot;
-			},	
-			:fire=&gt;
-			{
-				[]=&gt;[&quot;data/models/fire.ant2&quot;,0.3,&quot;data/textures/models/fire.png&quot;],
-				[:on]=&gt;[&quot;data/models/fire.ant2&quot;,0.3,&quot;data/textures/models/fire.png&quot;],
-				[:off]=&gt;[&quot;data/models/fire.ant2&quot;,0.3,&quot;data/textures/models/fire2.png&quot;]
-			},
-			:fishinghut=&gt;
-			{
-				[]=&gt;[&quot;data/models/fishing_hut.ant2&quot;,3.2,&quot;data/textures/models/fishing_hut.png&quot;,false]
-			},
-			:stone=&gt;
-			{
-				[]=&gt;&quot;big_stone&quot;
-			},
-		}
-	end
-	
-	def AntModels.getMeshCount(entityType)
-		getMeshMap[entityType].length
-	end
-	
-	def AntModels.createModel(entity,entityType,subType=nil,angle=nil)
-		assert {entity.is_a?(AntRubyEntity)}
-		
-		generatedMesh=generateMesh(entity,subType)
-		return generatedMesh if generatedMesh
+  def AntModels.generateMesh(entity,size)
+    case entity
+      when AntBush
+        makeBushMesh(entity.getMap.getScene,size*3)
+      when AntGrass
+        makeGrassMesh(entity.getMap.getScene,size)
+      else
+        nil
+    end
+    
+  end
+  
+  def AntModels.getMeshMap
+    animMeshes={
+      :man=&gt;{
+        []=&gt;&quot;data/models/man_e_walk.anim&quot;,
+        [&quot;wood&quot;]=&gt;&quot;data/models/man_e_wood.anim&quot;,
+        [&quot;stone&quot;,&quot;flour&quot;,&quot;corn&quot;]=&gt;&quot;data/models/man_e_stones.anim&quot;,
+        [&quot;walk&quot;,&quot;sitdown&quot;,&quot;sit&quot;,&quot;stand&quot;]=&gt;&quot;data/models/man_e_walk.anim&quot;,
+        [&quot;fight_dagger&quot;]=&gt;&quot;data/models/man_e_dagger.anim&quot;,
+        [&quot;fight_shield&quot;]=&gt;&quot;data/models/man_e_shield.anim&quot;,
+        [&quot;fight_sword&quot;]=&gt;&quot;data/models/man_e_sword.anim&quot;,
+        [&quot;fight_bow&quot;]=&gt;&quot;data/models/man_e_bow.anim&quot;,
+        [&quot;pick&quot;]=&gt;&quot;data/models/man_pick.anim&quot;,
+        [&quot;axe&quot;]=&gt;&quot;data/models/man_axe.anim&quot;,
+        [:grave]=&gt;&quot;grave&quot;,
+      },
+      :grave=&gt;{
+        [:normal]=&gt;&quot;grave&quot;,
+        [:hero]=&gt;[&quot;data/models/grave.ant2&quot;,0.2,&quot;data/textures/models/grave3.png&quot;],
+      },
+      :hero=&gt;{
+        []=&gt;&quot;hero_lp&quot;,
+        [:grave_hero]=&gt;[&quot;data/models/grave.ant2&quot;,0.2,&quot;data/textures/models/grave3.png&quot;],
+      },
+      :sack=&gt;{
+        []=&gt;&quot;sack&quot;
+      },
+      :tree=&gt;{
+        []=&gt;[&quot;data/models/fir2.ant2&quot;,0.45,&quot;data/textures/models/fir5.png&quot;,false],
+        [&quot;stub&quot;]=&gt;&quot;stub&quot;,
+        [0]=&gt;[&quot;data/models/fir2.ant2&quot;,0.45,&quot;data/textures/models/fir5.png&quot;,false],
+        [1]=&gt;[&quot;data/models/fir2.ant2&quot;,0.45,&quot;data/textures/models/fir7.png&quot;,false],
+        [2]=&gt;[&quot;data/models/tree5.ant2&quot;,0.45,&quot;data/textures/models/tree3.png&quot;,false],
+        [3]=&gt;[&quot;data/models/tree5.ant2&quot;,0.45,&quot;data/textures/models/tree5.png&quot;,false],
+        [4]=&gt;[&quot;data/models/tree5.ant2&quot;,0.45,&quot;data/textures/models/tree9.png&quot;,false],
+        [5]=&gt;[&quot;data/models/tree6.ant2&quot;,0.45,&quot;data/textures/models/tree5.png&quot;,false],
+        [6]=&gt;[&quot;data/models/tree5.ant2&quot;,0.45,&quot;data/textures/models/tree10.png&quot;,false],
+        [7]=&gt;[&quot;data/models/tree_simple1.ant2&quot;,0.3,&quot;data/textures/models/tree_simple1.png&quot;],
+        [8]=&gt;[&quot;data/models/tree_simple2.ant2&quot;,0.3,&quot;data/textures/models/tree_simple1.png&quot;],
+        [9]=&gt;[&quot;data/models/tree_simple5.ant2&quot;,0.3,&quot;data/textures/models/tree_simple5.png&quot;]
+      },
+      :buildingsite=&gt;{
+        []=&gt;[&quot;data/models/building_site0.ant2&quot;,1.7,&quot;data/textures/models/building_site0.png&quot;],
+        [0]=&gt;[&quot;data/models/building_site0.ant2&quot;,1.7,&quot;data/textures/models/building_site0.png&quot;],
+        [1]=&gt;[&quot;data/models/building_site1.ant2&quot;,1.7,&quot;data/textures/models/building_site1.png&quot;],
+        [2]=&gt;[&quot;data/models/building_site2.ant2&quot;,1.7,&quot;data/textures/models/building_site1.png&quot;],
+      },
+      :field=&gt;{
+        []=&gt;[&quot;data/models/crop_tiny.ant2&quot;,2.2,&quot;data/textures/models/crop_tiny.png&quot;],
+        [0]=&gt;[&quot;data/models/crop_tiny.ant2&quot;,2.2,&quot;data/textures/models/crop_tiny.png&quot;],
+        [1]=&gt;[&quot;data/models/crop_small.ant2&quot;,2.2,&quot;data/textures/models/crop_green.png&quot;],
+        [2]=&gt;[&quot;data/models/crop_med.ant2&quot;,2.2,&quot;data/textures/models/crop_yellow.png&quot;],
+        [3]=&gt;[&quot;data/models/crop_high.ant2&quot;,2.2,&quot;data/textures/models/crop_gold.png&quot;]
+      },
+      :tower=&gt;{
+        []=&gt;&quot;tower&quot;
+      },
+      :wolf=&gt;{
+        []=&gt;&quot;ant_wolf&quot;,
+        [:rip]=&gt;&quot;rip&quot;
+      },
+      :mill=&gt;{
+        []=&gt;&quot;ant_mill&quot;
+      },
+      :mine=&gt;{
+        []=&gt;&quot;mine2&quot;
+      },
+      :workshop=&gt;{
+        []=&gt;&quot;workshop&quot;
+      },
+      :townhall=&gt;{
+        []=&gt;&quot;townhall_try2&quot;
+      },
+      :well=&gt;{
+        []=&gt;&quot;well&quot;
+      },
+      :fish=&gt;{
+        []=&gt;&quot;fish&quot;
+      },
+      :sheep=&gt;{
+        []=&gt;&quot;data/models/sheep.anim&quot;,
+        [:rip]=&gt;&quot;rip&quot;
+      },
+      :arrow=&gt;{
+        []=&gt;&quot;arrow&quot;
+      },
+      :bakery=&gt;{
+        []=&gt;&quot;ant_bakery&quot;
+      },
+      :boat=&gt;{
+        []=&gt;&quot;boat_simple&quot;
+      },
+      :deco=&gt;{
+        [:floor_deco]=&gt;[&quot;data/models/floor.ant2&quot;,0.5,&quot;data/textures/splats/stones1a.png&quot;],
+      },
+       :twig=&gt;{  
+         []=&gt;&quot;twig&quot;
+       },
+      :decomesh=&gt;{ # FIXME: remove this and the class, too ??
+        []=&gt;&quot;ant_coach&quot;
+      },
+      :coach=&gt;{
+        []=&gt;&quot;ant_coach&quot;
+      },
+      :decal=&gt;
+      {
+        [:floor_gravel]=&gt;[&quot;data/models/floor.ant2&quot;,0.8,&quot;data/textures/gravel4.png&quot;],
+      },
+      :npc=&gt;{
+        [:druid]=&gt;&quot;druid_lp&quot;,
+        [:smith]=&gt;&quot;smith_lp&quot;
+      },  
+      :dwelling=&gt;
+      {
+        []=&gt;&quot;livinghouse&quot;
+      },
+      :farm=&gt;
+      {
+        []=&gt;&quot;farm&quot;
+      },  
+      :fire=&gt;
+      {
+        []=&gt;[&quot;data/models/fire.ant2&quot;,0.3,&quot;data/textures/models/fire.png&quot;],
+        [:on]=&gt;[&quot;data/models/fire.ant2&quot;,0.3,&quot;data/textures/models/fire.png&quot;],
+        [:off]=&gt;[&quot;data/models/fire.ant2&quot;,0.3,&quot;data/textures/models/fire2.png&quot;]
+      },
+      :fishinghut=&gt;
+      {
+        []=&gt;[&quot;data/models/fishing_hut.ant2&quot;,3.2,&quot;data/textures/models/fishing_hut.png&quot;,false]
+      },
+      :stone=&gt;
+      {
+        []=&gt;&quot;big_stone&quot;
+      },
+    }
+  end
+  
+  def AntModels.getMeshCount(entityType)
+    getMeshMap[entityType].length
+  end
+  
+  def AntModels.createModel(entity,entityType,subType=nil,angle=nil)
+    assert {entity.is_a?(AntRubyEntity)}
+    
+    generatedMesh=generateMesh(entity,subType)
+    return generatedMesh if generatedMesh
 
-		assert {entityType.is_a?(Symbol)}
-		mesh=nil
-	
-		animMeshes=getMeshMap
-		#raise &quot;muh&quot; unless animMeshes.member?(entityType)
-		assert{animMeshes.keys.member?(entityType)}
-		map=animMeshes[entityType]
-	
-		map.each{|k,v|
-			if k.member?(subType) or k.length==0
-				mesh=v
-			end
-		}
-		scenenode=nil
-		if mesh
-			if mesh.is_a?(Array)
-				pp mesh
-				ant2name=mesh[0]
-				scale=mesh[1]
-				pngname=mesh[2]
-				culling=true
-				if mesh.length&gt;3
-					culling=mesh[3]
-				end
-				data=getMeshData(ant2name,scale,pngname)
-				data.setCulling(culling)
-				data.setTransparent(true)
-				name=mesh
-				angle||=getStaticModelRotation(name)
-				scenenode=Mesh.new(entity.getMap.getScene,data,AGVector4.new(0,0,0),angle)
-						
-			elsif mesh=~/anim$/
-				scenenode=AnimMesh.new(entity.getMap.getScene,getAnimMeshData(mesh))
-			else
-				ant2name=&quot;data/models/&quot;+mesh+&quot;.ant2&quot;
-				pngname=&quot;data/textures/models/&quot;+mesh+&quot;.png&quot;
-				pngname=&quot;&quot; unless fileExists(pngname)
-				name=mesh
-				angle||=getStaticModelRotation(name)
+    assert {entityType.is_a?(Symbol)}
+    mesh=nil
+  
+    animMeshes=getMeshMap
+    #raise &quot;muh&quot; unless animMeshes.member?(entityType)
+    assert{animMeshes.keys.member?(entityType)}
+    map=animMeshes[entityType]
+  
+    map.each{|k,v|
+      if k.member?(subType) or k.length==0
+        mesh=v
+      end
+    }
+    scenenode=nil
+    if mesh
+      if mesh.is_a?(Array)
+        pp mesh
+        ant2name=mesh[0]
+        scale=mesh[1]
+        pngname=mesh[2]
+        culling=true
+        if mesh.length&gt;3
+          culling=mesh[3]
+        end
+        data=getMeshData(ant2name,scale,pngname)
+        data.setCulling(culling)
+        data.setTransparent(true)
+        name=mesh
+        angle||=getStaticModelRotation(name)
+        scenenode=Mesh.new(entity.getMap.getScene,data,AGVector4.new(0,0,0),angle)
+            
+      elsif mesh=~/anim$/
+        scenenode=AnimMesh.new(entity.getMap.getScene,getAnimMeshData(mesh))
+      else
+        ant2name=&quot;data/models/&quot;+mesh+&quot;.ant2&quot;
+        pngname=&quot;data/textures/models/&quot;+mesh+&quot;.png&quot;
+        pngname=&quot;&quot; unless fileExists(pngname)
+        name=mesh
+        angle||=getStaticModelRotation(name)
 
-				s=entity.getMap.getScene
+        s=entity.getMap.getScene
 
-				data=getMeshData(ant2name,getStaticModelScaling(name),pngname)
-				v=AGVector4.new(0,0,0)
-				scenenode=Mesh.new(s,data,v,angle)
-			end
-		end
-	
-		if @@useImpostors
-			# FIXME:replace by impostor
-			if entityType!=:fish
-				return createModel(:fish)
-			end
-		end
-	
-		return scenenode
-	end
+        data=getMeshData(ant2name,getStaticModelScaling(name),pngname)
+        v=AGVector4.new(0,0,0)
+        scenenode=Mesh.new(s,data,v,angle)
+      end
+    end
+  
+    if @@useImpostors
+      # FIXME:replace by impostor
+      if entityType!=:fish
+        return createModel(:fish)
+      end
+    end
+  
+    return scenenode
+  end
 end
 
 module Libantargis
-	# dummy function - so that for meshes and animmeshes you can call setAnimation(.)
-	class Mesh
-		def setAnimation(name)
-		end
-	end
+  # dummy function - so that for meshes and animmeshes you can call setAnimation(.)
+  class Mesh
+    def setAnimation(name)
+    end
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_path.rb
===================================================================
--- antargis/trunk/ruby/ant_path.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_path.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -15,169 +15,169 @@
 # * Pathfinder
 #
 class CombinedPathFinder
-	attr_accessor :scene
+  attr_accessor :scene
 
-	# the current available modes, in which pathes will be computed. You can add some more here
+  # the current available modes, in which pathes will be computed. You can add some more here
   # but you'll have to modify the functions getPathWeighter, getMode, displayPathfindingGraph
-	MODES=[:normal,:overWater]
+  MODES=[:normal,:overWater]
 
-	def initialize(map)
-		@graph={}
-		@heuristic={}
-		@path={}
-		@map=map
+  def initialize(map)
+    @graph={}
+    @heuristic={}
+    @path={}
+    @map=map
 
-		# check Cache
-		cacheFilename=getCacheFilename(map)
-		if fileExists(findFile(cacheFilename))
-			loadFromFile(cacheFilename)
-		else
-			computeEverything(map)
-			saveToFile(cacheFilename)
-		end
+    # check Cache
+    cacheFilename=getCacheFilename(map)
+    if fileExists(findFile(cacheFilename))
+      loadFromFile(cacheFilename)
+    else
+      computeEverything(map)
+      saveToFile(cacheFilename)
+    end
 
-		# put them together
-		MODES.each{|mode|
-			@path[mode]=Pathfinder.new(@graph[mode]<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at heuristic</A>[mode])
-		}
-	end
+    # put them together
+    MODES.each{|mode|
+      @path[mode]=Pathfinder.new(@graph[mode]<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at heuristic</A>[mode])
+    }
+  end
 
-	def distance(p0,p1,entity)
-		@path[getMode(entity)].distance(p0,p1)
-	end
+  def distance(p0,p1,entity)
+    @path[getMode(entity)].distance(p0,p1)
+  end
 
-	def computePath(p0,p1,entity)
-		path=@path[getMode(entity)].computePath(p0,p1)
-		#displayPath(path)
-		path
-	end
-	def refinePath(waypoints,entity)
-		mode=getMode(entity)
-		path=@path[mode].refinePath(waypoints,getPathWeighter(@map,mode))
-		#displayPath(path,AGVector4.new(1,0,0,1))
-		path
-	end
+  def computePath(p0,p1,entity)
+    path=@path[getMode(entity)].computePath(p0,p1)
+    #displayPath(path)
+    path
+  end
+  def refinePath(waypoints,entity)
+    mode=getMode(entity)
+    path=@path[mode].refinePath(waypoints,getPathWeighter(@map,mode))
+    #displayPath(path,AGVector4.new(1,0,0,1))
+    path
+  end
 
 
-	def displayPathfindingGraph(map,scene)
-		return
-		# 		colors={:normal=&gt;AGVector4.new(1,0,0,1),:overWater=&gt;AGVector4.new(1,1,0,1)}
-		# 		width=2
-		# 		MODES.each{|mode|
-		# 			wireframe=Boa3dWireframe.new(scene,colors[mode],width)
-		# 			(0..(@graph[mode].edges-1)).each{|i|
-		# 				edge=@graph[mode].getEdgePosition(i)
-		# 				a=edge[0]
-		# 				b=edge[1]
-		# 				a=AGVector3.new(a.x,a.y,map.getHeight(a.x,a.y)+0.15)
-		# 				b=AGVector3.new(b.x,b.y,map.getHeight(b.x,b.y)+0.15)
-		# 				wireframe.addLine(a,b)
-		# 			}
-		# 			scene.addNode(wireframe)
-		# 			width+=2
-		# 		}
-	end
+  def displayPathfindingGraph(map,scene)
+    return
+    #     colors={:normal=&gt;AGVector4.new(1,0,0,1),:overWater=&gt;AGVector4.new(1,1,0,1)}
+    #     width=2
+    #     MODES.each{|mode|
+    #       wireframe=Boa3dWireframe.new(scene,colors[mode],width)
+    #       (0..(@graph[mode].edges-1)).each{|i|
+    #         edge=@graph[mode].getEdgePosition(i)
+    #         a=edge[0]
+    #         b=edge[1]
+    #         a=AGVector3.new(a.x,a.y,map.getHeight(a.x,a.y)+0.15)
+    #         b=AGVector3.new(b.x,b.y,map.getHeight(b.x,b.y)+0.15)
+    #         wireframe.addLine(a,b)
+    #       }
+    #       scene.addNode(wireframe)
+    #       width+=2
+    #     }
+  end
 
-	def displayPath(path,color=AGVector4.new(1,1,0,1))
-		if path.length&gt;2
-			width=5
-			node=Boa3dWireframe.new(@scene,color,width)
-			on=nil
-			path.each{|n|
-				if on
-					a=AGVector3.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">n.x,n.y, at map.getHeight</A>(n.x,n.y)+0.15)
-					b=AGVector3.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">on.x,on.y, at map.getHeight</A>(on.x,on.y)+0.15)
-					node.addLine(a,b)
-					pp a,b
-				end
-				on=n
-			}
-			@scene.addNode(node)
-		end
-	end
+  def displayPath(path,color=AGVector4.new(1,1,0,1))
+    if path.length&gt;2
+      width=5
+      node=Boa3dWireframe.new(@scene,color,width)
+      on=nil
+      path.each{|n|
+        if on
+          a=AGVector3.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">n.x,n.y, at map.getHeight</A>(n.x,n.y)+0.15)
+          b=AGVector3.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">on.x,on.y, at map.getHeight</A>(on.x,on.y)+0.15)
+          node.addLine(a,b)
+          pp a,b
+        end
+        on=n
+      }
+      @scene.addNode(node)
+    end
+  end
 
 private
-	# get path-finding mode for the given +entity+
-	def getMode(entity)
-		if entity.resource.get(&quot;boat&quot;)&gt;0
-			# if entity has boat then is can cross water - FIXME: put this into an entity-based function
-			:overWater
-		else
-			:normal
-		end
-	end
+  # get path-finding mode for the given +entity+
+  def getMode(entity)
+    if entity.resource.get(&quot;boat&quot;)&gt;0
+      # if entity has boat then is can cross water - FIXME: put this into an entity-based function
+      :overWater
+    else
+      :normal
+    end
+  end
 
-	def getCacheFilename(map)
-		levelHash=map.hash # build a hash out of the height-map
-		cacheFilename=levelHash+&quot;.cache&quot;
-	end
+  def getCacheFilename(map)
+    levelHash=map.hash # build a hash out of the height-map
+    cacheFilename=levelHash+&quot;.cache&quot;
+  end
 
-	def loadFromFile(filename)
-		content=loadFile(filename)
-		stream=BinaryStringIn.new(content)
-		MODES.each{|mode|
-			@graph[mode]=SimpleGraph.new(stream)
-			@heuristic[mode]=StoredHeuristicFunction.new(stream)
-		}
-	end
+  def loadFromFile(filename)
+    content=loadFile(filename)
+    stream=BinaryStringIn.new(content)
+    MODES.each{|mode|
+      @graph[mode]=SimpleGraph.new(stream)
+      @heuristic[mode]=StoredHeuristicFunction.new(stream)
+    }
+  end
 
-	def saveToFile(filename)
-		# save everything to the cachefile
-		stream=BinaryStringOut.new
-		MODES.each{|mode|
-			@graph[mode].printTo(stream)
-			@heuristic[mode].printTo(stream)
-		}
-	
-		saveFile(filename,stream.getString)
-	end
+  def saveToFile(filename)
+    # save everything to the cachefile
+    stream=BinaryStringOut.new
+    MODES.each{|mode|
+      @graph[mode].printTo(stream)
+      @heuristic[mode].printTo(stream)
+    }
+  
+    saveFile(filename,stream.getString)
+  end
 
-	def computeEverything(map)
-		MODES.each{|mode|computeMode(map,mode)}
-	end
+  def computeEverything(map)
+    MODES.each{|mode|computeMode(map,mode)}
+  end
 
-	def computeMode(map,mode)
-		# build a map-height/distance weighter
-		weighter=getPathWeighter(map,mode)
+  def computeMode(map,mode)
+    # build a map-height/distance weighter
+    weighter=getPathWeighter(map,mode)
 
-		# set initial distance of waypoints	
-		minDist=4
+    # set initial distance of waypoints  
+    minDist=4
 
-		begin
-			# make a path-finding graph
-			sgraph=makeGraph(map,weighter,minDist)
-			minDist*=2
-			puts &quot;---&quot;
-			pp minDist
-			pp sgraph.size,sgraph.edges
-		end while(sgraph.size&gt;2000) # use a smaller resolution, if there are too many nodes in graph
+    begin
+      # make a path-finding graph
+      sgraph=makeGraph(map,weighter,minDist)
+      minDist*=2
+      puts &quot;---&quot;
+      pp minDist
+      pp sgraph.size,sgraph.edges
+    end while(sgraph.size&gt;2000) # use a smaller resolution, if there are too many nodes in graph
 
-		assert {sgraph.size&gt;0}
-		assert {sgraph.edges&gt;0}
+    assert {sgraph.size&gt;0}
+    assert {sgraph.edges&gt;0}
 
-		# copy to a decimating graph
-		graph=DecimatedGraph.new(sgraph)
+    # copy to a decimating graph
+    graph=DecimatedGraph.new(sgraph)
 
-		# compute a decimation-factor
-		factor=1.0-800.0/graph.size
+    # compute a decimation-factor
+    factor=1.0-800.0/graph.size
 
-		# debugging settings
-		#factor=0.4
-		#factor=1.0-220.0/@dgraph.size
+    # debugging settings
+    #factor=0.4
+    #factor=1.0-220.0/@dgraph.size
 
-		graph.decimate(factor,weighter)
+    graph.decimate(factor,weighter)
 
-		# compute a distance-field and use this as a pre-computed heuristic
-		@heuristic[mode]=computeHeuristic(graph)
-		@graph[mode]=graph
-	end
+    # compute a distance-field and use this as a pre-computed heuristic
+    @heuristic[mode]=computeHeuristic(graph)
+    @graph[mode]=graph
+  end
 
-	def getPathWeighter(map,mode)
-		case mode
-			when :normal
-				return MapPathWeighter.new(map,false)
-			when :overWater
-				return MapPathWeighter.new(map,true)
-		end
-	end
+  def getPathWeighter(map,mode)
+    case mode
+      when :normal
+        return MapPathWeighter.new(map,false)
+      when :overWater
+        return MapPathWeighter.new(map,true)
+    end
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_pcplayer.rb
===================================================================
--- antargis/trunk/ruby/ant_pcplayer.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_pcplayer.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -3,7 +3,7 @@
 end
 
 class PCRuleNearAttack&lt;PCRule
-	
+  
 end
 
 class PCRuleTriggerAttack&lt;PCRule

Modified: antargis/trunk/ruby/ant_player.rb
===================================================================
--- antargis/trunk/ruby/ant_player.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_player.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -19,209 +19,209 @@
 #
 
 class AntPlayer
-	attr_accessor :name
-	def initialize(map,name)
-		assert{map.is_a?(AntMap)}
-		@map=map
-		@heroes=[]
-		@heronames=[]
-		@name=name
-	end
-	def eventJobFinished
-	end
-	def saveXML(n)
-		n.set(&quot;name&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at name</A>)
-		@heroes.each{|hero|
-			c=n.addChild(&quot;hero&quot;)
-			c.set(&quot;name&quot;,hero.getName)
-		}
-	end
-	def loadXML(n)
-		@name=n.get(&quot;name&quot;)
-		children=n.getChildren(&quot;hero&quot;)
-		children.each{|c|
-			@heronames.push(c.get(&quot;name&quot;))
-		}
-	end
-	def move(time)
-		if @heronames.length then
-			@heronames.each{|n|
-				ent=getMap.getByName(n)
-				if ent.is_a?(AntBoss)
-					ent.setPlayer(self)
-					@heroes.push(ent)
-				else
-					puts &quot;HERO NOT FOUND: '#{n}'&quot;
-				end
-			}
-			@heronames.clear
-		end
-	end
-	def getName
-		@name
-	end
-	
-	def assignJob(hero)
-		hero.newHLRestJob(20)
-	end
-	def trigger(ent,tr)
-	end
-	def remove(hero)
-		@heroes.delete(hero)
-	end
-	def add(hero)
-		@heroes.push(hero)
-		@heroes.uniq!
-	end
-	def getBuildings
-		getBosses.select{|boss|boss.is_a?(AntHouse)}
-	end
-	def getHeroes
-		getBosses.select{|boss|boss.is_a?(AntHero)}
-	end
-	def getBosses
-		@heroes.uniq!
-		@heroes.clone
-	end
-	def getMap
-		@map
-	end
+  attr_accessor :name
+  def initialize(map,name)
+    assert{map.is_a?(AntMap)}
+    @map=map
+    @heroes=[]
+    @heronames=[]
+    @name=name
+  end
+  def eventJobFinished
+  end
+  def saveXML(n)
+    n.set(&quot;name&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at name</A>)
+    @heroes.each{|hero|
+      c=n.addChild(&quot;hero&quot;)
+      c.set(&quot;name&quot;,hero.getName)
+    }
+  end
+  def loadXML(n)
+    @name=n.get(&quot;name&quot;)
+    children=n.getChildren(&quot;hero&quot;)
+    children.each{|c|
+      @heronames.push(c.get(&quot;name&quot;))
+    }
+  end
+  def move(time)
+    if @heronames.length then
+      @heronames.each{|n|
+        ent=getMap.getByName(n)
+        if ent.is_a?(AntBoss)
+          ent.setPlayer(self)
+          @heroes.push(ent)
+        else
+          puts &quot;HERO NOT FOUND: '#{n}'&quot;
+        end
+      }
+      @heronames.clear
+    end
+  end
+  def getName
+    @name
+  end
+  
+  def assignJob(hero)
+    hero.newHLRestJob(20)
+  end
+  def trigger(ent,tr)
+  end
+  def remove(hero)
+    @heroes.delete(hero)
+  end
+  def add(hero)
+    @heroes.push(hero)
+    @heroes.uniq!
+  end
+  def getBuildings
+    getBosses.select{|boss|boss.is_a?(AntHouse)}
+  end
+  def getHeroes
+    getBosses.select{|boss|boss.is_a?(AntHero)}
+  end
+  def getBosses
+    @heroes.uniq!
+    @heroes.clone
+  end
+  def getMap
+    @map
+  end
 end
 
 class AntHumanPlayer&lt;AntPlayer
-	def eventJobFinished(who,what)
-		puts who.to_s+&quot; is ready with is job:&quot;+what.to_s
-	end
-	def xmlName
-		return &quot;humanPlayer&quot;
-	end
-	def assignJob(hero)
-		hero.newHLRestJob(20)
-	end
+  def eventJobFinished(who,what)
+    puts who.to_s+&quot; is ready with is job:&quot;+what.to_s
+  end
+  def xmlName
+    return &quot;humanPlayer&quot;
+  end
+  def assignJob(hero)
+    hero.newHLRestJob(20)
+  end
 end
 
 class AntComputerPlayer&lt;AntPlayer
-	def initialize(map,name)
-		super
-		@doneSth={}
-	end
+  def initialize(map,name)
+    super
+    @doneSth={}
+  end
 
-	def xmlName
-		return &quot;computerPlayer&quot;
-	end
-	def eventJobFinished(who,what)
-		puts who.to_s+&quot; is ready with is job:&quot;+what.to_s
-	end
-	def assignJob(hero)
-		if enoughFood(hero)
-			hero.newHLRestJob(20)
-		end
-	end
-	
-	# simple trigger
-	def trigger(ent,tr)
-		if tr.player!=@name
-			return
-		end
-		if ent.getPlayer!=self and tr.name==&quot;attack&quot;
-			@heroes.each{|h|
-				if h.getJob.class==AntHeroRestJob
-					puts &quot;ASSIGNING!&quot;
-					h.newHLFightJob(ent)
-				end
-			}
-		end
-	end
-	def attackNextHero(hero)
-		puts &quot;ANTPLAER::assignJob&quot;
-		
-		# simply attack
-		target=getMap.getNext(hero,&quot;hero&quot;)
-		
-		if target and target.getPlayer!=self
-			hero.newHLFightJob(target)
-		else
-			house=getMap.getNext(hero,&quot;house&quot;)
-			housePos=house.getPos2D
-			heroPos=hero.getPos2D
-			diff=housePos-heroPos
-			if diff.length2&gt;150
-				hero.newHLMoveJob(0,house.getPos2D,100)
-			else
-				hero.newHLRestJob(20)
-			end
-		end
-	end
-	def getNextHome(hero)
-		getMap.getNext(hero,&quot;house&quot;)
-	end
-	def goHome(hero,home)
-		housePos=house.getPos2D
-		heroPos=hero.getPos2D
-		diff=housePos-heroPos
-		if diff.length2&gt;4
-			hero.newHLMoveJob(0,house.getPos2D,2)
-		end
-	end
-	def attack(hero,target)
-		if hero and target and target.getPlayer!=self
-			hero.newHLFightJob(target)
-		end
-	end
-	
-	def attackChecked(hero,target)
-		if [AntHeroRestJob,NilClass].member?(hero.getJob.class)
-			attack(hero,target)
-		end
-	end
-	def getNextEnemy(hero)
-		getNextEnemyX(hero,&quot;hero&quot;)
-	end
-	def getNextEnemyHouse(hero)
-		getNextEnemyX(hero,&quot;house&quot;)
-	end
+  def xmlName
+    return &quot;computerPlayer&quot;
+  end
+  def eventJobFinished(who,what)
+    puts who.to_s+&quot; is ready with is job:&quot;+what.to_s
+  end
+  def assignJob(hero)
+    if enoughFood(hero)
+      hero.newHLRestJob(20)
+    end
+  end
+  
+  # simple trigger
+  def trigger(ent,tr)
+    if tr.player!=@name
+      return
+    end
+    if ent.getPlayer!=self and tr.name==&quot;attack&quot;
+      @heroes.each{|h|
+        if h.getJob.class==AntHeroRestJob
+          puts &quot;ASSIGNING!&quot;
+          h.newHLFightJob(ent)
+        end
+      }
+    end
+  end
+  def attackNextHero(hero)
+    puts &quot;ANTPLAER::assignJob&quot;
+    
+    # simply attack
+    target=getMap.getNext(hero,&quot;hero&quot;)
+    
+    if target and target.getPlayer!=self
+      hero.newHLFightJob(target)
+    else
+      house=getMap.getNext(hero,&quot;house&quot;)
+      housePos=house.getPos2D
+      heroPos=hero.getPos2D
+      diff=housePos-heroPos
+      if diff.length2&gt;150
+        hero.newHLMoveJob(0,house.getPos2D,100)
+      else
+        hero.newHLRestJob(20)
+      end
+    end
+  end
+  def getNextHome(hero)
+    getMap.getNext(hero,&quot;house&quot;)
+  end
+  def goHome(hero,home)
+    housePos=house.getPos2D
+    heroPos=hero.getPos2D
+    diff=housePos-heroPos
+    if diff.length2&gt;4
+      hero.newHLMoveJob(0,house.getPos2D,2)
+    end
+  end
+  def attack(hero,target)
+    if hero and target and target.getPlayer!=self
+      hero.newHLFightJob(target)
+    end
+  end
+  
+  def attackChecked(hero,target)
+    if [AntHeroRestJob,NilClass].member?(hero.getJob.class)
+      attack(hero,target)
+    end
+  end
+  def getNextEnemy(hero)
+    getNextEnemyX(hero,&quot;hero&quot;)
+  end
+  def getNextEnemyHouse(hero)
+    getNextEnemyX(hero,&quot;house&quot;)
+  end
 
-	def getNextEnemyX(hero,name,tries=10)
-		while tries&gt;0
-			e=getMap.getNext(hero,name,0)
-			if e.getPlayer!=self
-				return e
-			end
-			tries-=1
-		end
-		return nil
-	end
-	
+  def getNextEnemyX(hero,name,tries=10)
+    while tries&gt;0
+      e=getMap.getNext(hero,name,0)
+      if e.getPlayer!=self
+        return e
+      end
+      tries-=1
+    end
+    return nil
+  end
+  
 
-	def enoughFood(hero)
-		if hero.resource.get(&quot;food&quot;)&lt;2
-			tryGetFood(hero)
-			return false
-		end
-		return true
-	end
-	def tryGetFood(hero)
-		foodSource=getSource(hero,&quot;food&quot;,1)
-		if foodSource.nil?
-			hero.newHLRestJob(1)
-		else
-			hero.newHLTakeFoodJob(foodSource)
-			@doneSth[hero]=true
-		end
-	end
-	def getSource(hero,what,atleast,tries=5)
-		while tries&gt;0
-			e=getMap.getNext(hero,what,atleast)
-			if e.nil?
-				puts &quot;NO SOURCE&quot;
-				#return nil
-			elsif e.getPlayer==self
-				return e
-			end
-			tries-=1
-		end
-		puts &quot;OUT OF TRIES&quot;
-	end
+  def enoughFood(hero)
+    if hero.resource.get(&quot;food&quot;)&lt;2
+      tryGetFood(hero)
+      return false
+    end
+    return true
+  end
+  def tryGetFood(hero)
+    foodSource=getSource(hero,&quot;food&quot;,1)
+    if foodSource.nil?
+      hero.newHLRestJob(1)
+    else
+      hero.newHLTakeFoodJob(foodSource)
+      @doneSth[hero]=true
+    end
+  end
+  def getSource(hero,what,atleast,tries=5)
+    while tries&gt;0
+      e=getMap.getNext(hero,what,atleast)
+      if e.nil?
+        puts &quot;NO SOURCE&quot;
+        #return nil
+      elsif e.getPlayer==self
+        return e
+      end
+      tries-=1
+    end
+    puts &quot;OUT OF TRIES&quot;
+  end
 
 end
 
@@ -229,71 +229,71 @@
 end
 
 class AntOldConqueringPlayer&lt;AntComputerPlayer
-	def initialize(map,name)
-		super
-		@mode=:rest
-	end
-	def assignJob(hero)
-		case @mode
-			when :rest
-				hero.newHLRestJob(50)
-				@mode=:fight
-			when :fight
-				attackChecked(hero,getNextEnemyHouse(hero))
-				@mode=:rest
-		end
-	end
+  def initialize(map,name)
+    super
+    @mode=:rest
+  end
+  def assignJob(hero)
+    case @mode
+      when :rest
+        hero.newHLRestJob(50)
+        @mode=:fight
+      when :fight
+        attackChecked(hero,getNextEnemyHouse(hero))
+        @mode=:rest
+    end
+  end
 end
 
 class AntConqueringPlayer&lt;AntComputerPlayer
-	def initialize(map,name)
-		super
-		@mode=:rest
-	end
-	def assignJob(hero)
-		puts &quot;-------------------------------------------------assignJob(hero)&quot;
-		puts &quot;assignJob(hero)&quot;
-		puts &quot;-------------------------------------------------assignJob(hero)&quot;
-		if @doneSth[hero]
-			hero.newHLRestJob(3)
-			@doneSth[hero]=nil
-			return
-		end
-		if enoughFood(hero)
-			if not shouldAttackEnemyHouse(hero)
-				case @mode
-					when :rest
-						hero.newHLRestJob(50)
-						@mode=:fight
-					when :fight
-						attackChecked(hero,getNextEnemyHouse(hero))
-						@mode=:rest
-				end
-			end
-		end
-	end
+  def initialize(map,name)
+    super
+    @mode=:rest
+  end
+  def assignJob(hero)
+    puts &quot;-------------------------------------------------assignJob(hero)&quot;
+    puts &quot;assignJob(hero)&quot;
+    puts &quot;-------------------------------------------------assignJob(hero)&quot;
+    if @doneSth[hero]
+      hero.newHLRestJob(3)
+      @doneSth[hero]=nil
+      return
+    end
+    if enoughFood(hero)
+      if not shouldAttackEnemyHouse(hero)
+        case @mode
+          when :rest
+            hero.newHLRestJob(50)
+            @mode=:fight
+          when :fight
+            attackChecked(hero,getNextEnemyHouse(hero))
+            @mode=:rest
+        end
+      end
+    end
+  end
 
-	def shouldAttackEnemyHouse(hero)
-		puts &quot;def attackEnemyHouse(hero)&quot;
-		house=getWeakestEnemyHouse(hero)
-		if house
-			puts &quot;HOUSE:&quot;
-			puts house
-			puts &quot;#{house.getMen.length}&lt;#{hero.getMen.length}&quot;
-			if house.getMen.length&lt;hero.getMen.length
-				puts &quot;AATTTAC&quot;
-				attack(hero,house)
-				return true
-			end
-		end
-		return false
-	end
+  def shouldAttackEnemyHouse(hero)
+    puts &quot;def attackEnemyHouse(hero)&quot;
+    house=getWeakestEnemyHouse(hero)
+    if house
+      puts &quot;HOUSE:&quot;
+      puts house
+      puts &quot;#{house.getMen.length}&lt;#{hero.getMen.length}&quot;
+      if house.getMen.length&lt;hero.getMen.length
+        puts &quot;AATTTAC&quot;
+        attack(hero,house)
+        return true
+      end
+    end
+    return false
+  end
 
-	def getWeakestEnemyHouse(hero)
-		hs=getMap.getEntities(&quot;house&quot;)
-		hs=hs.collect{|h|h.get}.select{|h|h.getPlayer!=self}.sort{|a,b|a.getMen.length&lt;=&gt;b.getMen.length}
-		hs[0]
-	end
+  def getWeakestEnemyHouse(hero)
+    hs=getMap.getEntities(&quot;house&quot;)
+    hs=hs.collect{|h|h.get}.select{|h|h.getPlayer!=self}.sort{|a,b|a.getMen.length&lt;=&gt;b.getMen.length}
+    hs[0]
+  end
 
 
 

Modified: antargis/trunk/ruby/ant_scripting.rb
===================================================================
--- antargis/trunk/ruby/ant_scripting.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_scripting.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -22,183 +22,183 @@
 # 
 
 class AntScriptingJob
-	def initialize(job)
-		@job=job
-	end
-	def is_a?(pClass)
-		return unless pClass.is_a?(Class)
-		@job.is_a?(pClass)
-	end
-	def target
-		if @job.respond_to?(:target)
-			AntLevelEntity.new(@job.target)
-		end
-	end
+  def initialize(job)
+    @job=job
+  end
+  def is_a?(pClass)
+    return unless pClass.is_a?(Class)
+    @job.is_a?(pClass)
+  end
+  def target
+    if @job.respond_to?(:target)
+      AntLevelEntity.new(@job.target)
+    end
+  end
 end
 
 module AntScriptingEntityFullAccess
-	def resources(name=nil)
-		return unless name.is_a?(String) or name.nil?
-		if valid
-			if name.nil?
-				return @ent.resource.getAll
-			else
-				return @ent.resource.get(name)
-			end
-		else
-			return {}
-		end
-	end
-	def getName
-		@ent.getName
-	end
-	def getPos
-		@ent.getPos2D
-	end
+  def resources(name=nil)
+    return unless name.is_a?(String) or name.nil?
+    if valid
+      if name.nil?
+        return @ent.resource.getAll
+      else
+        return @ent.resource.get(name)
+      end
+    else
+      return {}
+    end
+  end
+  def getName
+    @ent.getName
+  end
+  def getPos
+    @ent.getPos2D
+  end
 end
 
 module AntScriptingHeroFullAccess
-	include AntScriptingEntityFullAccess
-	def menCount
-		@ent.getMen.length
-	end
+  include AntScriptingEntityFullAccess
+  def menCount
+    @ent.getMen.length
+  end
 
-	def findNearResource(resourceName,far=10)
-		return unless resourceName.is_a?(String) and far.is_a?(Numeric)
-		atLeast=3
-		atLeast=0
-		if valid
-			return getSource(@ent,resourceName,atLeast)
-		end
-		return nil
-	end
+  def findNearResource(resourceName,far=10)
+    return unless resourceName.is_a?(String) and far.is_a?(Numeric)
+    atLeast=3
+    atLeast=0
+    if valid
+      return getSource(@ent,resourceName,atLeast)
+    end
+    return nil
+  end
 
-	def getJob
-		AntScriptingJob.new(@ent.getJob)
-	end
+  def getJob
+    AntScriptingJob.new(@ent.getJob)
+  end
 
 
-	# set the aggression level (0,1,2)
-	def setAggression(level)
-		return unless [1,2,3].member?(level)
-		if valid
-			@ent.setAggression(level)
-		end
-	end
+  # set the aggression level (0,1,2)
+  def setAggression(level)
+    return unless [1,2,3].member?(level)
+    if valid
+      @ent.setAggression(level)
+    end
+  end
 
-	# move my hero to place
-	def moveTo(place)
-		dputs &quot;MOVETO:&quot;,place,place.class
-		place=place.pos if place.is_a?(TargetPos)
-		place=place.dim2 if place.is_a?(AGVector3)
-		dputs &quot;MOVETO:&quot;,place,place.class
-		return unless place.is_a?(AGVector2)
-		if valid
-			@ent.newHLMoveJob(0,place,0)
-		end
-	end
+  # move my hero to place
+  def moveTo(place)
+    dputs &quot;MOVETO:&quot;,place,place.class
+    place=place.pos if place.is_a?(TargetPos)
+    place=place.dim2 if place.is_a?(AGVector3)
+    dputs &quot;MOVETO:&quot;,place,place.class
+    return unless place.is_a?(AGVector2)
+    if valid
+      @ent.newHLMoveJob(0,place,0)
+    end
+  end
 
-	# attack enemy target
-	def attack(target)
-		return unless target.is_a?(AIEnemy)
-		if valid and target.valid
-			r=getRef(target)
-			if r
-				@ent.newHLFightJob(r)
-			end
-		end
-	end
+  # attack enemy target
+  def attack(target)
+    return unless target.is_a?(AIEnemy)
+    if valid and target.valid
+      r=getRef(target)
+      if r
+        @ent.newHLFightJob(r)
+      end
+    end
+  end
 
-	def dismiss
-		@ent.newHLDismissJob
-	end
-	
-	# recruit from target
-	def recruit(target)
-		return unless target.is_a?(AIMyBuilding)
-		if valid and target.valid
-			r=getRef(target)
-			@ent.newHLRecruitJob(r) if r
-		end
-	end
+  def dismiss
+    @ent.newHLDismissJob
+  end
+  
+  # recruit from target
+  def recruit(target)
+    return unless target.is_a?(AIMyBuilding)
+    if valid and target.valid
+      r=getRef(target)
+      @ent.newHLRecruitJob(r) if r
+    end
+  end
 
-	def takeFood(target)
-		puts &quot;takeFood: #{target}&quot;
-		return unless target.is_a?(AIMyBuilding)
-		if valid and target.valid
-			r=getRef(target)
-			@ent.newHLTakeFoodJob(r) if r
-		end
-	end
+  def takeFood(target)
+    puts &quot;takeFood: #{target}&quot;
+    return unless target.is_a?(AIMyBuilding)
+    if valid and target.valid
+      r=getRef(target)
+      @ent.newHLTakeFoodJob(r) if r
+    end
+  end
 
-	def takeWeapon(target)
-		return unless target.is_a?(AIMyBuilding)
-		if valid and target.valid
-			r=getRef(target)
-			if r
-				@ent.newHLTakeWeaponJob(r)
-			end
-		end
-	end
+  def takeWeapon(target)
+    return unless target.is_a?(AIMyBuilding)
+    if valid and target.valid
+      r=getRef(target)
+      if r
+        @ent.newHLTakeWeaponJob(r)
+      end
+    end
+  end
 
-	def attackAnimal(target)
-		return unless target.is_a?(AIAnimal)
-		if valid
-			r=getRef(target)
-			if r
-				@ent.newHLFightAnimalJob(r)
-			end
-		end
-	end
+  def attackAnimal(target)
+    return unless target.is_a?(AIAnimal)
+    if valid
+      r=getRef(target)
+      if r
+        @ent.newHLFightAnimalJob(r)
+      end
+    end
+  end
 
-	def build(place,type)
-		return unless place.is_a?(AGVector2) and type.is_a?(String)
-		if valid
-			ds=getDescendantsOfClass(AntHouse)
-			@map={}
-			ds.each{|d|
-				c=getChild(d.to_s)
-				if c
-					addHandler(c,:sigClick,:eventBuild)
-					@map[d.to_s]=d
-				end
-			}
-			type=@map[type]
-			if type
-				@ent.newHLBuildJob(place,type)
-			end
-		end
-	end
+  def build(place,type)
+    return unless place.is_a?(AGVector2) and type.is_a?(String)
+    if valid
+      ds=getDescendantsOfClass(AntHouse)
+      @map={}
+      ds.each{|d|
+        c=getChild(d.to_s)
+        if c
+          addHandler(c,:sigClick,:eventBuild)
+          @map[d.to_s]=d
+        end
+      }
+      type=@map[type]
+      if type
+        @ent.newHLBuildJob(place,type)
+      end
+    end
+  end
 
-	def rest(time)
-		return unless time.is_a?(Numeric)
-		if valid and time&gt;0
-			@ent.newHLRestJob(time)
-		end
-	end
+  def rest(time)
+    return unless time.is_a?(Numeric)
+    if valid and time&gt;0
+      @ent.newHLRestJob(time)
+    end
+  end
 
-	def addHandler(eventName,&amp;block)
-		@ent.addHandler(eventName,&amp;block)
-	end
+  def addHandler(eventName,&amp;block)
+    @ent.addHandler(eventName,&amp;block)
+  end
 
 end
 
 module AntScriptingEntityEnhancedAccess
-	# hacking
-	def setPlayer(player)
-		return nil if not player.is_a?(AntLevelPlayer)
-		p=getMap.players.select{|p|p.getName==player.getName}[0]
-		if p
-			@ent.setPlayer(p)
-		end
-	end
+  # hacking
+  def setPlayer(player)
+    return nil if not player.is_a?(AntLevelPlayer)
+    p=getMap.players.select{|p|p.getName==player.getName}[0]
+    if p
+      @ent.setPlayer(p)
+    end
+  end
 
-	def setBoss(entity)
-		return unless entity.is_a?(AntLevelEntity)
-		@ent.setBoss(getMap.getByName(entity.getName))
-	end
+  def setBoss(entity)
+    return unless entity.is_a?(AntLevelEntity)
+    @ent.setBoss(getMap.getByName(entity.getName))
+  end
 
-# 	def getMen
-# 		@ent.getMen.collect{|e|AntLevelEntity.new(e)}
-# 	end
+#   def getMen
+#     @ent.getMen.collect{|e|AntLevelEntity.new(e)}
+#   end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_sound.rb
===================================================================
--- antargis/trunk/ruby/ant_sound.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_sound.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,137 +1,137 @@
 module AntSound
-	@@soundLastCall={}
-	@@soundInited=false
-	@@loopSounds={}
-	@@ambientSound=nil
-	@@app=nil
+  @@soundLastCall={}
+  @@soundInited=false
+  @@loopSounds={}
+  @@ambientSound=nil
+  @@app=nil
 
-	def AntSound.setApplication(app)
-		@@app=app
-	end
+  def AntSound.setApplication(app)
+    @@app=app
+  end
 
-	def AntSound.playSoundGlobal(name,volume,minDiff=0.5)
-		sounds={&quot;sheep&quot;=&gt;&quot;data/sound/sheep44.wav&quot;,
-			&quot;error&quot;=&gt;&quot;data/sound/error.wav&quot;,
-			&quot;hackaxe&quot;=&gt;&quot;data/sound/tree_chop.wav&quot;,
-			&quot;wind&quot;=&gt;&quot;data/sound/wind.wav&quot;,
-			&quot;pick&quot;=&gt;&quot;data/sound/new_pick.wav&quot;,
-			&quot;sword&quot;=&gt;&quot;data/sound/sword1.wav&quot;,
-			&quot;fire&quot;=&gt;&quot;data/sound/fire.wav&quot;,
-			&quot;ugh_end&quot;=&gt;&quot;data/sound/ugh_end.wav&quot;,
-			&quot;won&quot;=&gt;&quot;data/sound/yay.wav&quot;,
-			&quot;mylord&quot;=&gt;&quot;data/sound/yes_mylord.wav&quot;,
-			&quot;ugh&quot;=&gt;[&quot;data/sound/person_ugh2.wav&quot;,&quot;data/sound/person_ugh4.wav&quot;,&quot;data/sound/ugh.wav&quot;],
-			&quot;die&quot;=&gt;[&quot;data/sound/person_ugh1.wav&quot;,&quot;data/sound/person_ugh3.wav&quot;,&quot;data/sound/ugh2.wav&quot;],
-			&quot;construct&quot;=&gt;[&quot;data/sound/workshop.wav&quot;]
-			}
-	
-		if not @@soundLastCall.keys.member?(name)
-			@@soundLastCall[name]=-minDiff-1
-		end
-		s=sounds[name]
-		if not s
-			s=name
-		elsif s.class==Array
-			s=s.shuffle[0]
-		end
-		if s &amp;&amp; AntRubyMap.getSystemTime-@@soundLastCall[name]&gt;minDiff # at a second ago
-			if not @@soundInited
-				setNormalVolumeWave
-				@@soundInited=true
-			end
-			getSoundManager.playWave(s,volume)
-			@@soundLastCall[name]=AntRubyMap.getSystemTime
-		end
-	end
-	
-	def AntSound.playLoopSoundGlobal(id,name,pos,volume)
-		s={&quot;fire&quot;=&gt;&quot;data/sound/fire.wav&quot;}[name]
-		return nil if s.nil?
-		return nil if @@app.nil? or @@app.getScene.nil?
-	
-		d=((@@app.getScene.getCamera.dim2-pos).length-INNER_VOL_SIZE)
-		vol=1
-		if d&gt;0
-			vol=[(OUTER_VOL_SIZE-d)/OUTER_VOL_SIZE,0].max
-		end
-		handle=getSoundManager.loopPlay(s,volume*vol)
-		@@loopSounds[id]=[handle,name,pos,volume]
-		id
-	end
-	
-	def AntSound.stopLoopSound(id)
-		a=@@loopSounds[id]
-		return if a.nil?
-		getSoundManager.stopChannel(a[0])
-		@@loopSounds.delete(id)
-	end
-	def AntSound.updateSoundPos(scene)
-		@@loopSounds.each{|id,a|
-			pos=a[2]
-			d=((scene.getCamera.dim2-pos).length-INNER_VOL_SIZE)
-			vol=1
-			if d&gt;0
-				vol=[(OUTER_VOL_SIZE-d)/OUTER_VOL_SIZE,0].max
-			end
-			getSoundManager.volumeSound(a[0],a[3]*vol)
-		}
-	end
-	
-	
-	def AntSound.ambientSound(time)
-		return nil if @@app.nil?
-		if not @@ambientSound
-			@@ambientSound=getSoundManager.loopPlay(&quot;data/sound/wind_loop.wav&quot;,getVolume(&quot;ambient&quot;)*0.2)
-			getSoundManager.stopMp3
-			@@ambientMusic=getSoundManager.playMp3(&quot;data/music/in-game1.ogg&quot;)
-			#raise 1
-			getSoundManager.volumeMusic(getVolume(&quot;music&quot;))
-			#getSoundManager.playMp3(
-			#getSoundManager.playMp3(&quot;data/music/ant2.ogg&quot;)
-		end
-		if (not getSoundManager.isMusicPlaying)
-			@@ambientMusic=getSoundManager.playMp3(&quot;data/music/in-game1.ogg&quot;)
-		end
-	
-	end
-	
-	def AntSound.setNormalVolumeWave
-		getSoundManager.volumeSound(0.4*getVolume(&quot;sound&quot;))
-		getSoundManager.volumeMusic(getVolume(&quot;music&quot;))
-		@@normalVolume=true
-	end
-	def AntSound.setQuietVolumeWave
-		getSoundManager.volumeSound(0.1*getVolume(&quot;sound&quot;))
-		getSoundManager.volumeMusic(0.25*getVolume(&quot;music&quot;))
-		@@normalVolume=false
-	end
-	
-	def AntSound.updateVolumes
-		getSoundManager.volumeMusic(getVolume(&quot;music&quot;))
-		if @@normalVolume
-			setNormalVolumeWave
-		else
-			setQuietVolumeWave
-		end
-		if @@ambientSound
-			getSoundManager.stopChannel(@@ambientSound)
-			@@ambientSound=nil
-		end
-		ambientSound(1)
-	end
+  def AntSound.playSoundGlobal(name,volume,minDiff=0.5)
+    sounds={&quot;sheep&quot;=&gt;&quot;data/sound/sheep44.wav&quot;,
+      &quot;error&quot;=&gt;&quot;data/sound/error.wav&quot;,
+      &quot;hackaxe&quot;=&gt;&quot;data/sound/tree_chop.wav&quot;,
+      &quot;wind&quot;=&gt;&quot;data/sound/wind.wav&quot;,
+      &quot;pick&quot;=&gt;&quot;data/sound/new_pick.wav&quot;,
+      &quot;sword&quot;=&gt;&quot;data/sound/sword1.wav&quot;,
+      &quot;fire&quot;=&gt;&quot;data/sound/fire.wav&quot;,
+      &quot;ugh_end&quot;=&gt;&quot;data/sound/ugh_end.wav&quot;,
+      &quot;won&quot;=&gt;&quot;data/sound/yay.wav&quot;,
+      &quot;mylord&quot;=&gt;&quot;data/sound/yes_mylord.wav&quot;,
+      &quot;ugh&quot;=&gt;[&quot;data/sound/person_ugh2.wav&quot;,&quot;data/sound/person_ugh4.wav&quot;,&quot;data/sound/ugh.wav&quot;],
+      &quot;die&quot;=&gt;[&quot;data/sound/person_ugh1.wav&quot;,&quot;data/sound/person_ugh3.wav&quot;,&quot;data/sound/ugh2.wav&quot;],
+      &quot;construct&quot;=&gt;[&quot;data/sound/workshop.wav&quot;]
+      }
+  
+    if not @@soundLastCall.keys.member?(name)
+      @@soundLastCall[name]=-minDiff-1
+    end
+    s=sounds[name]
+    if not s
+      s=name
+    elsif s.class==Array
+      s=s.shuffle[0]
+    end
+    if s &amp;&amp; AntRubyMap.getSystemTime-@@soundLastCall[name]&gt;minDiff # at a second ago
+      if not @@soundInited
+        setNormalVolumeWave
+        @@soundInited=true
+      end
+      getSoundManager.playWave(s,volume)
+      @@soundLastCall[name]=AntRubyMap.getSystemTime
+    end
+  end
+  
+  def AntSound.playLoopSoundGlobal(id,name,pos,volume)
+    s={&quot;fire&quot;=&gt;&quot;data/sound/fire.wav&quot;}[name]
+    return nil if s.nil?
+    return nil if @@app.nil? or @@app.getScene.nil?
+  
+    d=((@@app.getScene.getCamera.dim2-pos).length-INNER_VOL_SIZE)
+    vol=1
+    if d&gt;0
+      vol=[(OUTER_VOL_SIZE-d)/OUTER_VOL_SIZE,0].max
+    end
+    handle=getSoundManager.loopPlay(s,volume*vol)
+    @@loopSounds[id]=[handle,name,pos,volume]
+    id
+  end
+  
+  def AntSound.stopLoopSound(id)
+    a=@@loopSounds[id]
+    return if a.nil?
+    getSoundManager.stopChannel(a[0])
+    @@loopSounds.delete(id)
+  end
+  def AntSound.updateSoundPos(scene)
+    @@loopSounds.each{|id,a|
+      pos=a[2]
+      d=((scene.getCamera.dim2-pos).length-INNER_VOL_SIZE)
+      vol=1
+      if d&gt;0
+        vol=[(OUTER_VOL_SIZE-d)/OUTER_VOL_SIZE,0].max
+      end
+      getSoundManager.volumeSound(a[0],a[3]*vol)
+    }
+  end
+  
+  
+  def AntSound.ambientSound(time)
+    return nil if @@app.nil?
+    if not @@ambientSound
+      @@ambientSound=getSoundManager.loopPlay(&quot;data/sound/wind_loop.wav&quot;,getVolume(&quot;ambient&quot;)*0.2)
+      getSoundManager.stopMp3
+      @@ambientMusic=getSoundManager.playMp3(&quot;data/music/in-game1.ogg&quot;)
+      #raise 1
+      getSoundManager.volumeMusic(getVolume(&quot;music&quot;))
+      #getSoundManager.playMp3(
+      #getSoundManager.playMp3(&quot;data/music/ant2.ogg&quot;)
+    end
+    if (not getSoundManager.isMusicPlaying)
+      @@ambientMusic=getSoundManager.playMp3(&quot;data/music/in-game1.ogg&quot;)
+    end
+  
+  end
+  
+  def AntSound.setNormalVolumeWave
+    getSoundManager.volumeSound(0.4*getVolume(&quot;sound&quot;))
+    getSoundManager.volumeMusic(getVolume(&quot;music&quot;))
+    @@normalVolume=true
+  end
+  def AntSound.setQuietVolumeWave
+    getSoundManager.volumeSound(0.1*getVolume(&quot;sound&quot;))
+    getSoundManager.volumeMusic(0.25*getVolume(&quot;music&quot;))
+    @@normalVolume=false
+  end
+  
+  def AntSound.updateVolumes
+    getSoundManager.volumeMusic(getVolume(&quot;music&quot;))
+    if @@normalVolume
+      setNormalVolumeWave
+    else
+      setQuietVolumeWave
+    end
+    if @@ambientSound
+      getSoundManager.stopChannel(@@ambientSound)
+      @@ambientSound=nil
+    end
+    ambientSound(1)
+  end
 
 private
-	def AntSound.getVolume(type)
-		v=getConfig.get(&quot;#{type}Volume&quot;)
-		if v==&quot;&quot;
-			if type==&quot;music&quot;
-				v=0.2
-			else
-				v=1
-			end
-		end
-		
-		v.to_f
-	end
+  def AntSound.getVolume(type)
+    v=getConfig.get(&quot;#{type}Volume&quot;)
+    if v==&quot;&quot;
+      if type==&quot;music&quot;
+        v=0.2
+      else
+        v=1
+      end
+    end
+    
+    v.to_f
+  end
 
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_to_xml.rb
===================================================================
--- antargis/trunk/ruby/ant_to_xml.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_to_xml.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -2,170 +2,170 @@
 include Libantargis
 
 # def addToXmlMarshal
-# 	puts caller
-# 	exit
-# 	XmlMarshal.addClass(caller)
+#   puts caller
+#   exit
+#   XmlMarshal.addClass(caller)
 # end
 # 
 # class Integer
-# 	addToXmlMarshal
+#   addToXmlMarshal
 # 
-# 	def to_xml(parentNode,myName)
-# 		n=parentNode.addChild(&quot;Integer&quot;)
-# 		n.set(&quot;name&quot;,myName)
-# 		n.set(&quot;value&quot;,to_s)
-# 		n
-# 	end
-# 	def from_xml(node)
-# 		self=node.get(&quot;value&quot;).to_i
-# 	end
+#   def to_xml(parentNode,myName)
+#     n=parentNode.addChild(&quot;Integer&quot;)
+#     n.set(&quot;name&quot;,myName)
+#     n.set(&quot;value&quot;,to_s)
+#     n
+#   end
+#   def from_xml(node)
+#     self=node.get(&quot;value&quot;).to_i
+#   end
 # end
 # 
 # class Float
-# 	def to_xml(parentNode,myName)
-# 		n=parentNode.addChild(&quot;Integer&quot;)
-# 		n.set(&quot;name&quot;,myName)
-# 		n.set(&quot;value&quot;,to_s)
-# 		n
-# 	end
-# 	def from_xml(node)
-# 		self=node.get(&quot;value&quot;).to_f
-# 	end
+#   def to_xml(parentNode,myName)
+#     n=parentNode.addChild(&quot;Integer&quot;)
+#     n.set(&quot;name&quot;,myName)
+#     n.set(&quot;value&quot;,to_s)
+#     n
+#   end
+#   def from_xml(node)
+#     self=node.get(&quot;value&quot;).to_f
+#   end
 # end
 # 
 # 
 # class String
-# 	def to_xml(parentNode,myName)
-# 		n=parentNode.addChild(&quot;String&quot;)
-# 		n.set(&quot;name&quot;,myName)
-# 		n.set(&quot;value&quot;,self)
-# 		n
-# 	end
+#   def to_xml(parentNode,myName)
+#     n=parentNode.addChild(&quot;String&quot;)
+#     n.set(&quot;name&quot;,myName)
+#     n.set(&quot;value&quot;,self)
+#     n
+#   end
 # 
-# 	def from_xml(node)
-# 		self=node.get(&quot;value&quot;)
-# 	end
+#   def from_xml(node)
+#     self=node.get(&quot;value&quot;)
+#   end
 # end
 
 # class Array
-# 	def to_xml(parentNode,myName)
-# 		n=parentNode.addChild(&quot;String&quot;)
-# 		n.set(&quot;name&quot;,myName)
-# 		n.set(&quot;value&quot;,self)
-# 		n
-# 	end
+#   def to_xml(parentNode,myName)
+#     n=parentNode.addChild(&quot;String&quot;)
+#     n.set(&quot;name&quot;,myName)
+#     n.set(&quot;value&quot;,self)
+#     n
+#   end
 # 
-# 	def from_xml(node)
-# 		self=node.get(&quot;value&quot;)
-# 	end
+#   def from_xml(node)
+#     self=node.get(&quot;value&quot;)
+#   end
 # end
 
 
 
 class XmlMarshal
-	@@classes=[]
-	
-	def XmlMarshal.dump(v,node)
-		node.set(&quot;type&quot;,v.class.to_s)
-		if v.class.method_defined?(:to_xml)
-			v.to_xml(node,&quot;&quot;)
-		else
-			case v
-				when Numeric,String
-					node.set(&quot;value&quot;,v.to_s)
-				when Array
-					v.each{|i|
-						n=node.addChild(&quot;element&quot;)
-						XmlMarshal.dump(i,n)
-					}
-				when Hash
-					v.each{|a,b|
-						p=node.addChild(&quot;pair&quot;)
-						k=p.addChild(&quot;key&quot;)
-						m=p.addChild(&quot;value&quot;)
-						XmlMarshal.dump(a,k)
-						XmlMarshal.dump(b,m)
-					}
-			end
-		end
-	end
-	def XmlMarshal.load(node)
-		v=nil
-		type=node.get(&quot;type&quot;)
-		cl=ObjectSpace.const_get(type)
-		if cl.method_defined?(:from_xml)
-			v=cl.from_xml(node)
-		else
-			case type
-				when &quot;Fixnum&quot;,&quot;Bignum&quot;
-					v=node.get(&quot;value&quot;).to_i
-				when &quot;Float&quot;
-					v=node.get(&quot;value&quot;).to_f
-				when &quot;String&quot;
-					v=node.get(&quot;value&quot;).to_s
-				when &quot;Hash&quot;
-					puts &quot;:&quot;+type
-					v={}
-					node.getChildren(&quot;pair&quot;).each{|p|
-						ks=p.getChildren(&quot;key&quot;)
-						vs=p.getChildren(&quot;value&quot;)
-						if ks.length==1 and vs.length==1
-							k=XmlMarshal.load(ks[0])
-							m=XmlMarshal.load(vs[0])
-							v[k]=m
-						end
-						
-					}
-				when &quot;Array&quot;
-					v=[]
-					node.getChildren(&quot;element&quot;).each{|e|
-						m=XmlMarshal.load(e)
-						v.push(m)
-					}
-			end
-		end
-		v
-	end
+  @@classes=[]
+  
+  def XmlMarshal.dump(v,node)
+    node.set(&quot;type&quot;,v.class.to_s)
+    if v.class.method_defined?(:to_xml)
+      v.to_xml(node,&quot;&quot;)
+    else
+      case v
+        when Numeric,String
+          node.set(&quot;value&quot;,v.to_s)
+        when Array
+          v.each{|i|
+            n=node.addChild(&quot;element&quot;)
+            XmlMarshal.dump(i,n)
+          }
+        when Hash
+          v.each{|a,b|
+            p=node.addChild(&quot;pair&quot;)
+            k=p.addChild(&quot;key&quot;)
+            m=p.addChild(&quot;value&quot;)
+            XmlMarshal.dump(a,k)
+            XmlMarshal.dump(b,m)
+          }
+      end
+    end
+  end
+  def XmlMarshal.load(node)
+    v=nil
+    type=node.get(&quot;type&quot;)
+    cl=ObjectSpace.const_get(type)
+    if cl.method_defined?(:from_xml)
+      v=cl.from_xml(node)
+    else
+      case type
+        when &quot;Fixnum&quot;,&quot;Bignum&quot;
+          v=node.get(&quot;value&quot;).to_i
+        when &quot;Float&quot;
+          v=node.get(&quot;value&quot;).to_f
+        when &quot;String&quot;
+          v=node.get(&quot;value&quot;).to_s
+        when &quot;Hash&quot;
+          puts &quot;:&quot;+type
+          v={}
+          node.getChildren(&quot;pair&quot;).each{|p|
+            ks=p.getChildren(&quot;key&quot;)
+            vs=p.getChildren(&quot;value&quot;)
+            if ks.length==1 and vs.length==1
+              k=XmlMarshal.load(ks[0])
+              m=XmlMarshal.load(vs[0])
+              v[k]=m
+            end
+            
+          }
+        when &quot;Array&quot;
+          v=[]
+          node.getChildren(&quot;element&quot;).each{|e|
+            m=XmlMarshal.load(e)
+            v.push(m)
+          }
+      end
+    end
+    v
+  end
 end
 
 
 def printDbgMy(v)
-	case v
-		when String
-			'&quot;'+v+'&quot;'
-		when Numeric
-			v.to_s
-		when Array
-			&quot;[&quot;+v.collect{|i|printDbgMy(i)}.join(&quot;,&quot;)+&quot;]&quot;
-		when Hash
-			&quot;{&quot;+v.collect{|k,v|printDbgMy(k)+&quot;=&gt;&quot;+printDbgMy(v)}.join(&quot;,&quot;)+&quot;}&quot;
-	end
+  case v
+    when String
+      '&quot;'+v+'&quot;'
+    when Numeric
+      v.to_s
+    when Array
+      &quot;[&quot;+v.collect{|i|printDbgMy(i)}.join(&quot;,&quot;)+&quot;]&quot;
+    when Hash
+      &quot;{&quot;+v.collect{|k,v|printDbgMy(k)+&quot;=&gt;&quot;+printDbgMy(v)}.join(&quot;,&quot;)+&quot;}&quot;
+  end
 end
 
 def printDbg(v)
-	puts printDbgMy(v)
+  puts printDbgMy(v)
 end
 
 def test
-	doc=Document.new
+  doc=Document.new
 
-	root=doc.root
-	
-	root.setName(&quot;root_a&quot;)
-	a={&quot;a&quot;=&gt;[1,2,3],&quot;huhu&quot;=&gt;[&quot;hallo&quot;,2.222]}
+  root=doc.root
+  
+  root.setName(&quot;root_a&quot;)
+  a={&quot;a&quot;=&gt;[1,2,3],&quot;huhu&quot;=&gt;[&quot;hallo&quot;,2.222]}
 
-	XmlMarshal.dump(a,root)
+  XmlMarshal.dump(a,root)
 
 
-	b=XmlMarshal.load(root)
+  b=XmlMarshal.load(root)
 
 
-	puts root.toString
+  puts root.toString
 
 
-	#puts b
-	printDbg(a)
-	printDbg(b)
+  #puts b
+  printDbg(a)
+  printDbg(b)
 
 end
 

Modified: antargis/trunk/ruby/ant_tools.rb
===================================================================
--- antargis/trunk/ruby/ant_tools.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_tools.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,74 +1,74 @@
 require &quot;ruby/ant_sound.rb&quot;
 
 def getMeshData(file,zoom,texture=&quot;&quot;,shadow=true)
-	id=file+&quot;:&quot;+texture
-	if not $meshes
-		$meshes={}
-	end
-	if not $meshes[id]
-		pp file,zoom,texture,shadow
-		raise &quot;Texture-file not found!&quot; unless (fileExists(texture) or texture==&quot;&quot;)
-		$meshes[id]=MeshData.new(file,zoom,texture,shadow)
-	end
-	return $meshes[id]
+  id=file+&quot;:&quot;+texture
+  if not $meshes
+    $meshes={}
+  end
+  if not $meshes[id]
+    pp file,zoom,texture,shadow
+    raise &quot;Texture-file not found!&quot; unless (fileExists(texture) or texture==&quot;&quot;)
+    $meshes[id]=MeshData.new(file,zoom,texture,shadow)
+  end
+  return $meshes[id]
 end
 
 def getAnimMeshData(file)
-	if not $meshes
-		$meshes={}
-	end
-	if not $meshes[file]
-		$meshes[file]=AnimMeshData.new(file)
-		$meshes[file].setTransform(AGMatrix4.new(Math::PI,AGVector3.new(0,0,1))*AGMatrix4.new(Math::PI/2,AGVector3.new(1,0,0)))
+  if not $meshes
+    $meshes={}
+  end
+  if not $meshes[file]
+    $meshes[file]=AnimMeshData.new(file)
+    $meshes[file].setTransform(AGMatrix4.new(Math::PI,AGVector3.new(0,0,1))*AGMatrix4.new(Math::PI/2,AGVector3.new(1,0,0)))
 
-	end
-	return $meshes[file]
+  end
+  return $meshes[file]
 end
 
 def displayError(error)
   getSoundManager.playWave([&quot;data&quot;,&quot;sound&quot;,&quot;error.wav&quot;].join(&quot;/&quot;))
-	playSound(error)
-	dputs &quot;ERROR:&quot;+error.to_s
+  playSound(error)
+  dputs &quot;ERROR:&quot;+error.to_s
 end
 
 class Set&lt;Array
-	def push(x)
-		super
-		sort!
-		uniq!
-	end
+  def push(x)
+    super
+    sort!
+    uniq!
+  end
 end
 
 def getDescendantsOfClass(p)
-	c=[]
-	ObjectSpace.each_object(Class){|a|c.push(a) if a.ancestors.member?(p)}
-	return c
+  c=[]
+  ObjectSpace.each_object(Class){|a|c.push(a) if a.ancestors.member?(p)}
+  return c
 end
 
 class Class
-	def descendants
-		getDescendantsOfClass(self)
-	end
+  def descendants
+    getDescendantsOfClass(self)
+  end
 end
 
 def trace
-	puts &quot;TRACE #{caller[0]}&quot;
+  puts &quot;TRACE #{caller[0]}&quot;
 end
 
 class AntargisException&lt;Exception
-	attr_accessor :text
-	
-	def to_s
-		super+&quot;:&quot;+text.to_s
-	end
+  attr_accessor :text
+  
+  def to_s
+    super+&quot;:&quot;+text.to_s
+  end
 end
 
 def assert(text=&quot;&quot;,&amp;block)
-	if not block.call
-		exception=AntargisException.new
-		exception.text=&quot;#{text} #{block} failed in #{caller[0]} #{block.binding}&quot;
-		raise exception
-	end
+  if not block.call
+    exception=AntargisException.new
+    exception.text=&quot;#{text} #{block} failed in #{caller[0]} #{block.binding}&quot;
+    raise exception
+  end
 end
 
 

Modified: antargis/trunk/ruby/ant_trigger.rb
===================================================================
--- antargis/trunk/ruby/ant_trigger.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/ant_trigger.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,39 +1,39 @@
 class Trigger
-	attr_reader :name, :player
-	def initialize(node)
-		if node.class==Node
-			@pos=AGVector2.new
-			@pos.loadXML(node)
-			@radius=node.get(&quot;radius&quot;).to_f
-			@name=node.get(&quot;name&quot;)
-			@circle=AGCircle2.new(AGVector2.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">pos.x, at pos.y</A>)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at radius</A>)
-			@triggerTime=AntRubyMap.getSystemTime
-			@player=node.get(&quot;player&quot;)
-			@text=node.get(&quot;text&quot;)
-		else
-			@name=node
-			@triggerTime=AntRubyMap.getSystemTime
-		end
-	end
-	def saveXML(n)
-		@pos.saveXML(n)
-		n.set(&quot;radius&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at radius.to_s</A>)
-		n.set(&quot;name&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at name</A>)
-		n.set(&quot;player&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at player</A>)
-		n.set(&quot;text&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at text</A>)
-	end
-	def check(hero)
-		if <A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">AntRubyMap.getSystemTime- at triggerTime</A>&gt;1 # wait at least a second for repeating trigger
-			p2=hero.getPos2D
-			p3=AGVector2.new(p2.x,p2.y)
-			#dputs name,&quot; &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">,p3, at pos</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at radius</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at circle.inCircle</A>(p3), (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p2- at pos</A>).length
-			if @circle.inCircle(p3)
-				getMap.trigger(hero,self)
-				@triggerTime=AntRubyMap.getSystemTime
-			end
-		end
-	end
-	def xmlName
-		&quot;trigger&quot;
-	end
+  attr_reader :name, :player
+  def initialize(node)
+    if node.class==Node
+      @pos=AGVector2.new
+      @pos.loadXML(node)
+      @radius=node.get(&quot;radius&quot;).to_f
+      @name=node.get(&quot;name&quot;)
+      @circle=AGCircle2.new(AGVector2.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">pos.x, at pos.y</A>)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at radius</A>)
+      @triggerTime=AntRubyMap.getSystemTime
+      @player=node.get(&quot;player&quot;)
+      @text=node.get(&quot;text&quot;)
+    else
+      @name=node
+      @triggerTime=AntRubyMap.getSystemTime
+    end
+  end
+  def saveXML(n)
+    @pos.saveXML(n)
+    n.set(&quot;radius&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at radius.to_s</A>)
+    n.set(&quot;name&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at name</A>)
+    n.set(&quot;player&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at player</A>)
+    n.set(&quot;text&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at text</A>)
+  end
+  def check(hero)
+    if <A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">AntRubyMap.getSystemTime- at triggerTime</A>&gt;1 # wait at least a second for repeating trigger
+      p2=hero.getPos2D
+      p3=AGVector2.new(p2.x,p2.y)
+      #dputs name,&quot; &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">,p3, at pos</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at radius</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at circle.inCircle</A>(p3), (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p2- at pos</A>).length
+      if @circle.inCircle(p3)
+        getMap.trigger(hero,self)
+        @triggerTime=AntRubyMap.getSystemTime
+      end
+    end
+  end
+  def xmlName
+    &quot;trigger&quot;
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/antargislib.rb
===================================================================
--- antargis/trunk/ruby/antargislib.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/antargislib.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -8,74 +8,74 @@
 
 
 module MyAntargisLib
-	@@antargislibinited||=false
+  @@antargislibinited||=false
 
 
- 	if not @@antargislibinited
-		@@programDir=File.expand_path(File.split(__FILE__)[0])
-		$:.push(@@programDir)
-		#$:.push(File.join(@@programDir,&quot;entities&quot;))
- 		# try suspending arts
-		if File.exists?(&quot;/usr/bin/artsshell&quot;)
-			unless ENV[&quot;PATH&quot;] =~ /^[A-Za-z]:\\.*/
-				File.popen(&quot;/usr/bin/artsshell suspend 2&gt;&amp;1&quot;).close
-			end
-		end
- 	end
+   if not @@antargislibinited
+    @@programDir=File.expand_path(File.split(__FILE__)[0])
+    $:.push(@@programDir)
+    #$:.push(File.join(@@programDir,&quot;entities&quot;))
+     # try suspending arts
+    if File.exists?(&quot;/usr/bin/artsshell&quot;)
+      unless ENV[&quot;PATH&quot;] =~ /^[A-Za-z]:\\.*/
+        File.popen(&quot;/usr/bin/artsshell suspend 2&gt;&amp;1&quot;).close
+      end
+    end
+   end
 end
 
 if $demoMode.nil?
-	$demoMode=false
-	$enableLogging=true
+  $demoMode=false
+  $enableLogging=true
 end
 
 module AntMyEventHandler
-	def getNewEvent
-		filename=File.join(getWriteDir,&quot;events.txt&quot;)
-		if $demoMode
-			if hardwareCursor
-				setCursor(getTextureCache.get(&quot;blue_cursor.png&quot;))
-			end
+  def getNewEvent
+    filename=File.join(getWriteDir,&quot;events.txt&quot;)
+    if $demoMode
+      if hardwareCursor
+        setCursor(getTextureCache.get(&quot;blue_cursor.png&quot;))
+      end
 
-			@@eventDebugging||=File.open(filename,&quot;r&quot;)
-			@@nextLine||=@@eventDebugging.readline
-			puts &quot;NEXTLINE:#{@@nextLine}&quot;
-			if @@nextLine=~/T:.*/
-				time=@@nextLine.scan(/..(.*)/)[0][0].to_f
-				puts &quot;TIME:#{time}&quot;
-				@@nextLine=nil
-				setDemoTime(time)
-				
-				return toSDLEvent(&quot;&quot;)
-			else
-				s=@@nextLine
-				@@nextLine=nil
-				return toSDLEvent(s)
-			end
-		else
-			e=super
-			if not e.nil?
-				if eventOk(e)
-					s=toString(e)
-					if $enableLogging
-						@@eventDebugging||=File.open(filename,&quot;w&quot;)
-						@@eventDebugging.puts s
-					end
-				end
-			end
-			return e
-		end
-	end
+      @@eventDebugging||=File.open(filename,&quot;r&quot;)
+      @@nextLine||=@@eventDebugging.readline
+      puts &quot;NEXTLINE:#{@@nextLine}&quot;
+      if @@nextLine=~/T:.*/
+        time=@@nextLine.scan(/..(.*)/)[0][0].to_f
+        puts &quot;TIME:#{time}&quot;
+        @@nextLine=nil
+        setDemoTime(time)
+        
+        return toSDLEvent(&quot;&quot;)
+      else
+        s=@@nextLine
+        @@nextLine=nil
+        return toSDLEvent(s)
+      end
+    else
+      e=super
+      if not e.nil?
+        if eventOk(e)
+          s=toString(e)
+          if $enableLogging
+            @@eventDebugging||=File.open(filename,&quot;w&quot;)
+            @@eventDebugging.puts s
+          end
+        end
+      end
+      return e
+    end
+  end
 
 
-	def eventPrepareFrame(t)
-		if $enableLogging and not $demoMode
-			@@eventDebugging||=File.open(&quot;events.txt&quot;,&quot;w&quot;)
-			@@eventDebugging.puts &quot;T: #{t}&quot;
-			#puts &quot;TIME #{t}&quot;
-		end
-		return false
-	end
+  def eventPrepareFrame(t)
+    if $enableLogging and not $demoMode
+      @@eventDebugging||=File.open(&quot;events.txt&quot;,&quot;w&quot;)
+      @@eventDebugging.puts &quot;T: #{t}&quot;
+      #puts &quot;TIME #{t}&quot;
+    end
+    return false
+  end
 
 end
 
@@ -84,34 +84,34 @@
   puts &quot;Antargis-module included&quot;
 rescue
   puts &quot;Antargis-module not found - trying to load .so&quot;
-	begin
-		if File.exists?(&quot;ext/antargis.so&quot;)
-			require 'ext/antargis'
+  begin
+    if File.exists?(&quot;ext/antargis.so&quot;)
+      require 'ext/antargis'
     elsif File.exists?(&quot;antargis.bundle&quot;)
       require 'antargis.bundle'
-		else
-			puts &quot;Please run 'rake' before starting this program!&quot;
-			require 'antargis'
-		end
-		include Antargis
-	rescue
-		puts &quot;I'll try to run rake for you. Please try again yourself when it doesn't work.&quot;
-		#system &quot;rake&quot;
-		puts &quot;Try starting again...&quot;
-		if File.exists?(&quot;ext/antargis.so&quot;)
-			require 'ext/antargis'
-		else
-			puts &quot;Please run 'rake' before starting this program!&quot;
-			require 'antargis'
-		end
-		include Antargis
-		puts &quot;I'll try to run rake for you. Please try again yourself when it doesn't work.&quot;
-	
-	end
+    else
+      puts &quot;Please run 'rake' before starting this program!&quot;
+      require 'antargis'
+    end
+    include Antargis
+  rescue
+    puts &quot;I'll try to run rake for you. Please try again yourself when it doesn't work.&quot;
+    #system &quot;rake&quot;
+    puts &quot;Try starting again...&quot;
+    if File.exists?(&quot;ext/antargis.so&quot;)
+      require 'ext/antargis'
+    else
+      puts &quot;Please run 'rake' before starting this program!&quot;
+      require 'antargis'
+    end
+    include Antargis
+    puts &quot;I'll try to run rake for you. Please try again yourself when it doesn't work.&quot;
+  
+  end
 end
 puts &quot;extension loaded&quot;
 
-	
+  
 require 'ruby/gui/ag_tools.rb'
 require 'ant_tools'
 require 'ant_debug.rb'
@@ -123,189 +123,189 @@
 addPath(File.join(@basePath,&quot;data&quot;))
 addPath(File.join(@basePath,&quot;data&quot;,&quot;fonts&quot;))
 
-		
+    
 module MyAntargislib
-	@@antargislibinited||=false
-	if not @@antargislibinited
-		@@antargislibinited=true
-		@@fullscreen=false
-		@@antProfiling=false
-		@@opengl=true
+  @@antargislibinited||=false
+  if not @@antargislibinited
+    @@antargislibinited=true
+    @@fullscreen=false
+    @@antProfiling=false
+    @@opengl=true
 
-		setDebugLevel(1000)
-	
-		# check options
-		ARGV.each{|arg|
-			if arg=~/--.*/ or arg=~/-.*/
-				a=arg[1..1000]
-				if arg[1..1]==&quot;-&quot;
-					a=arg[2..1000]
-				end
-				case a
-					when &quot;no-sound&quot;
-						getConfig.set(&quot;soundEnabled&quot;,&quot;false&quot;)
-					when &quot;sound&quot;
-						getConfig.set(&quot;soundEnabled&quot;,&quot;true&quot;)
-					when &quot;profile&quot;
-						require 'profile'
-						@@antProfiling=true
-					when &quot;gc-check&quot;
-						GC.stress=true
-					when &quot;intro&quot;
-						getConfig.set(&quot;intro&quot;,&quot;true&quot;)
-					when &quot;no-intro&quot;
-						getConfig.set(&quot;intro&quot;,&quot;false&quot;)
-					when &quot;fullscreen&quot;
-						@@fullscreen=true
-					when &quot;window&quot;
-						@@fullscreen=false
-					when /debug-level/
-						level=a.split(&quot;=&quot;)[1].to_i
-						setDebugLevel(level)
-					when &quot;nogl&quot;
-						@@opengl=false
-					when &quot;demo&quot;
-						$demoMode=true
-					when &quot;gui-test&quot;
-						require 'ruby/tests/gui_tests.rb'
-						@@cursorEnabled=true
-					when &quot;ruby-raise&quot;
-						setRubyRaising(true)
-					when &quot;no-3d-textures&quot;
-          	setUsing3dTextures(false)
-					when &quot;help&quot;,&quot;h&quot;
-						STDERR.puts &quot;Possible options:
-	--help         show this help message
-	
-	--fullscreen   enable fullscreen
-	--window       start in windows mode
-	
-	--profile      enables profiling output of BoA's ruby-part
-	--gc-check     enables debug mode for gc-check (GC.stress=true)
-	
-	--intro        enables the intro
-	--no-intro     disables the intro
-	
-	--sound        enables sound for now and future uses
-	--no-sound     disables sound for now and future uses
-	
-	--gui-test     tells BoA to use events.txt to produce GUI-events
+    setDebugLevel(1000)
+  
+    # check options
+    ARGV.each{|arg|
+      if arg=~/--.*/ or arg=~/-.*/
+        a=arg[1..1000]
+        if arg[1..1]==&quot;-&quot;
+          a=arg[2..1000]
+        end
+        case a
+          when &quot;no-sound&quot;
+            getConfig.set(&quot;soundEnabled&quot;,&quot;false&quot;)
+          when &quot;sound&quot;
+            getConfig.set(&quot;soundEnabled&quot;,&quot;true&quot;)
+          when &quot;profile&quot;
+            require 'profile'
+            @@antProfiling=true
+          when &quot;gc-check&quot;
+            GC.stress=true
+          when &quot;intro&quot;
+            getConfig.set(&quot;intro&quot;,&quot;true&quot;)
+          when &quot;no-intro&quot;
+            getConfig.set(&quot;intro&quot;,&quot;false&quot;)
+          when &quot;fullscreen&quot;
+            @@fullscreen=true
+          when &quot;window&quot;
+            @@fullscreen=false
+          when /debug-level/
+            level=a.split(&quot;=&quot;)[1].to_i
+            setDebugLevel(level)
+          when &quot;nogl&quot;
+            @@opengl=false
+          when &quot;demo&quot;
+            $demoMode=true
+          when &quot;gui-test&quot;
+            require 'ruby/tests/gui_tests.rb'
+            @@cursorEnabled=true
+          when &quot;ruby-raise&quot;
+            setRubyRaising(true)
+          when &quot;no-3d-textures&quot;
+            setUsing3dTextures(false)
+          when &quot;help&quot;,&quot;h&quot;
+            STDERR.puts &quot;Possible options:
+  --help         show this help message
+  
+  --fullscreen   enable fullscreen
+  --window       start in windows mode
+  
+  --profile      enables profiling output of BoA's ruby-part
+  --gc-check     enables debug mode for gc-check (GC.stress=true)
+  
+  --intro        enables the intro
+  --no-intro     disables the intro
+  
+  --sound        enables sound for now and future uses
+  --no-sound     disables sound for now and future uses
+  
+  --gui-test     tells BoA to use events.txt to produce GUI-events
 
-	--demo         enable demo mode - reading events from events.txt
+  --demo         enable demo mode - reading events from events.txt
 
-	--debug-level=x
+  --debug-level=x
 
-	--nogl         disable GL-mode (3d-acceleration) - THIS IS NOT YET FULLY SUPPORTED!!
-	--ruby-raise   raise exceptions as ruby-exceptions
+  --nogl         disable GL-mode (3d-acceleration) - THIS IS NOT YET FULLY SUPPORTED!!
+  --ruby-raise   raise exceptions as ruby-exceptions
 
-	--no-3d-textures disables 3d-textures - they're bad on some graphics chipsets (esp. Intel)
-	&quot;
-	
-						exit
-				end
-			end
-		}
-	
-	
-		@@main=getMain #AGMain.new
-		xres=1024
-		if getConfig.get(&quot;xRes&quot;)!=&quot;&quot;
-			xres=getConfig.get(&quot;xRes&quot;).to_i
-		end
-		yres=768
-		if getConfig.get(&quot;yRes&quot;)!=&quot;&quot;
-			yres=getConfig.get(&quot;yRes&quot;).to_i
-		end
-	
-	
-	
-		if not @@fullscreen
-			if getConfig.get(&quot;fullscreen&quot;)==&quot;true&quot;
-				@@fullscreen=true
-			end
-		end
-		
+  --no-3d-textures disables 3d-textures - they're bad on some graphics chipsets (esp. Intel)
+  &quot;
+  
+            exit
+        end
+      end
+    }
+  
+  
+    @@main=getMain #AGMain.new
+    xres=1024
+    if getConfig.get(&quot;xRes&quot;)!=&quot;&quot;
+      xres=getConfig.get(&quot;xRes&quot;).to_i
+    end
+    yres=768
+    if getConfig.get(&quot;yRes&quot;)!=&quot;&quot;
+      yres=getConfig.get(&quot;yRes&quot;).to_i
+    end
+  
+  
+  
+    if not @@fullscreen
+      if getConfig.get(&quot;fullscreen&quot;)==&quot;true&quot;
+        @@fullscreen=true
+      end
+    end
+    
 
-		@@noVideo||=nil	
-		if @@noVideo.nil?
-			puts &quot;initVideo...&quot;
-			getVideo.initVideo(xres,yres,32,@@fullscreen,@@opengl,1024,768)
-			puts &quot;initVideo ok&quot;
-		
-			getConfig.set(&quot;xRes&quot;,xres.to_s)
-			getConfig.set(&quot;yRes&quot;,yres.to_s)
-			getConfig.set(&quot;fullscreen&quot;,@@fullscreen.to_s)
-		
-			getVideo.setCaption(&quot;Antargis&quot;)
-			getVideo.setIcon(&quot;data/gui/editor/tower1.png&quot;)
-		end
-	end
-	def MyAntargislib.startGC
-		GC.enable
-		GC.start
-	end
+    @@noVideo||=nil  
+    if @@noVideo.nil?
+      puts &quot;initVideo...&quot;
+      getVideo.initVideo(xres,yres,32,@@fullscreen,@@opengl,1024,768)
+      puts &quot;initVideo ok&quot;
+    
+      getConfig.set(&quot;xRes&quot;,xres.to_s)
+      getConfig.set(&quot;yRes&quot;,yres.to_s)
+      getConfig.set(&quot;fullscreen&quot;,@@fullscreen.to_s)
+    
+      getVideo.setCaption(&quot;Antargis&quot;)
+      getVideo.setIcon(&quot;data/gui/editor/tower1.png&quot;)
+    end
+  end
+  def MyAntargislib.startGC
+    GC.enable
+    GC.start
+  end
 
-	def MyAntargislib.demoMode
-		$demoMove
-	end
-	def MyAntargislib.opengl
-		@@opengl
-	end
+  def MyAntargislib.demoMode
+    $demoMove
+  end
+  def MyAntargislib.opengl
+    @@opengl
+  end
 end
 
 def demoMode
-	MyAntargislib.demoMode
+  MyAntargislib.demoMode
 end
 
 #include Libantargis
 def startGC
-	MyAntargislib.startGC
+  MyAntargislib.startGC
 end
 
 class AGStringUtf8
-	alias  :oldIndex :[]
-	def [](range)
-		if range.is_a?(Range)
-			ma=range.max
-			mi=range.min
-			if self.length&gt;0
-				ma%=self.length
-				mi%=self.length
-			end
-			
-			return self.substr(mi,ma-mi+1)
-		end
-		#puts range,range.class
-		super
-	end
+  alias  :oldIndex :[]
+  def [](range)
+    if range.is_a?(Range)
+      ma=range.max
+      mi=range.min
+      if self.length&gt;0
+        ma%=self.length
+        mi%=self.length
+      end
+      
+      return self.substr(mi,ma-mi+1)
+    end
+    #puts range,range.class
+    super
+  end
 end
 
 class Logger
-	filename=File.join(getWriteDir,&quot;log.txt&quot;)
-	@@log=File.open(filename,&quot;w&quot;)
-	def self.log(*s)
-		@@log.print(&quot;[&quot;)
-		@@log.print(Time.new)
-		@@log.print(&quot;] &quot;)
-		@@log.puts(*s)
-	end
+  filename=File.join(getWriteDir,&quot;log.txt&quot;)
+  @@log=File.open(filename,&quot;w&quot;)
+  def self.log(*s)
+    @@log.print(&quot;[&quot;)
+    @@log.print(Time.new)
+    @@log.print(&quot;] &quot;)
+    @@log.puts(*s)
+  end
 end
 
 def log(*s)
-	Logger.log(*s)
+  Logger.log(*s)
 end
 
 class AntApplication&lt;AGApplication
-	include AntMyEventHandler
+  include AntMyEventHandler
 
 # # Here you can bypass some functions - if you might want to -
-# 	def delay(ms)
-# 		puts &quot;DELAY  #{ms}&quot;
-# 		return 
-# 		if not demoMode
-# 			super
-# 		end
-# 	end
+#   def delay(ms)
+#     puts &quot;DELAY  #{ms}&quot;
+#     return 
+#     if not demoMode
+#       super
+#     end
+#   end
 end
 
 

Modified: antargis/trunk/ruby/campaign.rb
===================================================================
--- antargis/trunk/ruby/campaign.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/campaign.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -12,294 +12,294 @@
 #
 
 def getCampaignFiles
-	Dir[File.join(&quot;data&quot;,&quot;campaigns&quot;,&quot;*.xml&quot;)]
+  Dir[File.join(&quot;data&quot;,&quot;campaigns&quot;,&quot;*.xml&quot;)]
 end
 
 def getCampaigns
-	$campaigns||=getCampaignFiles.collect{|f|Campaign.new(f)}.select{|f|f.enabled}.sort_by{|campaign|campaign.order}
+  $campaigns||=getCampaignFiles.collect{|f|Campaign.new(f)}.select{|f|f.enabled}.sort_by{|campaign|campaign.order}
 end
 
 class CampaignLevel
-	attr_reader :result
-	def initialize(node)
-		@level=node.get(&quot;file&quot;)
-		node.getChildren(&quot;failscene&quot;).each{|c|
-			@lostScene=CutScene.new(c)
-		}
-		@current=node.get(&quot;current&quot;)
-		if @current==&quot;&quot;
-			@current=@level
-		end
-	end
-	def save(n)
-		n.set(&quot;file&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at level</A>)
-		if @app
-			raise 'Problem - $campaign not net' if $campaign==nil
-			sname=$campaign.savename.gsub(&quot;antcmp&quot;,&quot;antlvl&quot;)
-			n.set(&quot;current&quot;,sname)
-			@app.getMap.saveMap(sname)
-		end
-	end
+  attr_reader :result
+  def initialize(node)
+    @level=node.get(&quot;file&quot;)
+    node.getChildren(&quot;failscene&quot;).each{|c|
+      @lostScene=CutScene.new(c)
+    }
+    @current=node.get(&quot;current&quot;)
+    if @current==&quot;&quot;
+      @current=@level
+    end
+  end
+  def save(n)
+    n.set(&quot;file&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at level</A>)
+    if @app
+      raise 'Problem - $campaign not net' if $campaign==nil
+      sname=$campaign.savename.gsub(&quot;antcmp&quot;,&quot;antlvl&quot;)
+      n.set(&quot;current&quot;,sname)
+      @app.getMap.saveMap(sname)
+    end
+  end
 
 
-	# this function is very similar to startGame in antargis.rb
-	# FIXME: join them
-	def play
-		loadscreen=LoadApp.new
-		loadscreen.setValue(0)
-		loadscreen.tick
-		begin
-			fileContent=loadFile(@current)
-			w=getVideo.width
-			h=getVideo.height
-			@app=AntGameApp.new(fileContent,w,h,loadscreen)
-			@app.run
-			@result=@app.result
-			@app=nil
-			getSoundManager.stopAllChannels
-		end
-		$app=nil
-		$map=nil
-		$antView=nil
-		$buttonPanel=nil
-		$inventory=nil
+  # this function is very similar to startGame in antargis.rb
+  # FIXME: join them
+  def play
+    loadscreen=LoadApp.new
+    loadscreen.setValue(0)
+    loadscreen.tick
+    begin
+      fileContent=loadFile(@current)
+      w=getVideo.width
+      h=getVideo.height
+      @app=AntGameApp.new(fileContent,w,h,loadscreen)
+      @app.run
+      @result=@app.result
+      @app=nil
+      getSoundManager.stopAllChannels
+    end
+    $app=nil
+    $map=nil
+    $antView=nil
+    $buttonPanel=nil
+    $inventory=nil
 
-		$screen=nil
-		GC.start
+    $screen=nil
+    GC.start
 
-		puts &quot;RESULT.won #{@result.won}&quot;
-		puts @result
-		
-		case @result.won
-			when &quot;lost&quot;
-				@lostScene.play
-		end
+    puts &quot;RESULT.won #{@result.won}&quot;
+    puts @result
+    
+    case @result.won
+      when &quot;lost&quot;
+        @lostScene.play
+    end
 
-	end
+  end
 
-	def result
-		@result
-	end
+  def result
+    @result
+  end
 end
 
 class CutSceneDisplay&lt;AntApplication
-	def initialize(image,text)
-		super()
-		@layout=AGLayout.new(nil)
-		@layout.loadXML(loadFile(&quot;data/gui/layout/cutscene.xml&quot;))
-		setMainWidget(@layout)
-		addHandler(@layout.getChild(&quot;continue&quot;),:sigClick,:eventQuit)
-		@text=@ctext=&quot;&quot;
-		@time=0
-		@speed=0.1
-	end
-	def eventQuit
-		if @finished
-			tryQuit
-		else
-			@ctext=@text
-			setTextForReal(@ctext)
-			@finished=true
-			#eventFrame(10000) # as if much time has passed
-		end
-		return true
-	end
-	def eventKeyDown(e)
-		eventQuit
-		return super
-	end
-	
-	def setImage(image)
-		w=@layout.getChild(&quot;image&quot;)
-		w2=@layout.getChild(&quot;imageFrame&quot;)
-		if image
-			w2.show
-			w.setSurface(image)
-		else
-			w2.hide
-		end
-	end
-	
-	def setText(text)
-		@text=_(text)
-		@ctext=&quot;&quot;
-		@time=0
-		setTextForReal(_(&quot;&quot;))
-	end
-	
-	def eventFrame(t)
-		t=[t,0.1].min
-		@time+=t
-		old=@ctext
-		while @time&gt;@speed
-			len=[@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">ctext.length+1, at text.length</A>].min.to_i
-			puts <A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">len,len.class, at ctext</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at ctext.class</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at text</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at text.class</A>
-	
-			# FIXME: map [] to substr
+  def initialize(image,text)
+    super()
+    @layout=AGLayout.new(nil)
+    @layout.loadXML(loadFile(&quot;data/gui/layout/cutscene.xml&quot;))
+    setMainWidget(@layout)
+    addHandler(@layout.getChild(&quot;continue&quot;),:sigClick,:eventQuit)
+    @text=@ctext=&quot;&quot;
+    @time=0
+    @speed=0.1
+  end
+  def eventQuit
+    if @finished
+      tryQuit
+    else
+      @ctext=@text
+      setTextForReal(@ctext)
+      @finished=true
+      #eventFrame(10000) # as if much time has passed
+    end
+    return true
+  end
+  def eventKeyDown(e)
+    eventQuit
+    return super
+  end
+  
+  def setImage(image)
+    w=@layout.getChild(&quot;image&quot;)
+    w2=@layout.getChild(&quot;imageFrame&quot;)
+    if image
+      w2.show
+      w.setSurface(image)
+    else
+      w2.hide
+    end
+  end
+  
+  def setText(text)
+    @text=_(text)
+    @ctext=&quot;&quot;
+    @time=0
+    setTextForReal(_(&quot;&quot;))
+  end
+  
+  def eventFrame(t)
+    t=[t,0.1].min
+    @time+=t
+    old=@ctext
+    while @time&gt;@speed
+      len=[@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">ctext.length+1, at text.length</A>].min.to_i
+      puts <A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">len,len.class, at ctext</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at ctext.class</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at text</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at text.class</A>
+  
+      # FIXME: map [] to substr
 
-			@ctext=@text[0..(len-1)]
-			if old==@ctext
-				break
-			end
-			if @ctext[-1..-1]!=AGStringUtf8.new(&quot; &quot;)
-				@time-=@speed
-			end
-		end
-		if old!=@ctext
-			setTextForReal(@ctext)
-			if @ctext==@text
-				@finished=true
-			end
-		end
-		delay(20)
-		return true
-	end
-	
-	private
-	def setTextForReal(text)
-		w=@layout.getChild(&quot;text&quot;)
-		if text
-			w.show
-			w.setText(text)
-		else
-			w.hide
-		end
-	end
+      @ctext=@text[0..(len-1)]
+      if old==@ctext
+        break
+      end
+      if @ctext[-1..-1]!=AGStringUtf8.new(&quot; &quot;)
+        @time-=@speed
+      end
+    end
+    if old!=@ctext
+      setTextForReal(@ctext)
+      if @ctext==@text
+        @finished=true
+      end
+    end
+    delay(20)
+    return true
+  end
+  
+  private
+  def setTextForReal(text)
+    w=@layout.getChild(&quot;text&quot;)
+    if text
+      w.show
+      w.setText(text)
+    else
+      w.hide
+    end
+  end
 end
 
 class TestClass
 end
 
 class CutScene
-	#attr_reader :finished
-	def initialize(node)
-		@screens=[]
-		node.getChildren(&quot;screen&quot;).each{|s|
-			screen={}
-			screen[:text]=&quot;&quot;
-			s.getChildren(&quot;image&quot;).each{|c|
-				imageName=c.get(&quot;filename&quot;)
-				screen[:imageName]=imageName
-				if imageName
-					screen[:image]=AGSurface.load(imageName)
-				end
-			}
-			s.getChildren(&quot;text&quot;).each{|c|
-				screen[:text]+=c.get(&quot;text&quot;)
-			}
-			@screens.push(screen)
-		}
-		#@finished=&quot;won&quot;
-	end
-	def save(n)
-		@screens.each{|s|
-			c=n.addChild(&quot;screen&quot;)
-			c.addChild(&quot;text&quot;).set(&quot;text&quot;,s[:text]) if s[:text]
-			c.addChild(&quot;image&quot;).set(&quot;filename&quot;,s[:imageName]) if s[:imageName]
-		}
-	end
-	def mytest
-		puts &quot;muh&quot;
-		#TestClass.new
-	end
-	def play
-		display=CutSceneDisplay.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">image, at text</A>)
-		@screens.each{|s|
-			display.setImage(s[:image])
-			display.setText(s[:text])
-			display.run
-		}
-		GC.start
-	end
-	def result
-		GameResult.new(&quot;won&quot;)
-	end
+  #attr_reader :finished
+  def initialize(node)
+    @screens=[]
+    node.getChildren(&quot;screen&quot;).each{|s|
+      screen={}
+      screen[:text]=&quot;&quot;
+      s.getChildren(&quot;image&quot;).each{|c|
+        imageName=c.get(&quot;filename&quot;)
+        screen[:imageName]=imageName
+        if imageName
+          screen[:image]=AGSurface.load(imageName)
+        end
+      }
+      s.getChildren(&quot;text&quot;).each{|c|
+        screen[:text]+=c.get(&quot;text&quot;)
+      }
+      @screens.push(screen)
+    }
+    #@finished=&quot;won&quot;
+  end
+  def save(n)
+    @screens.each{|s|
+      c=n.addChild(&quot;screen&quot;)
+      c.addChild(&quot;text&quot;).set(&quot;text&quot;,s[:text]) if s[:text]
+      c.addChild(&quot;image&quot;).set(&quot;filename&quot;,s[:imageName]) if s[:imageName]
+    }
+  end
+  def mytest
+    puts &quot;muh&quot;
+    #TestClass.new
+  end
+  def play
+    display=CutSceneDisplay.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">image, at text</A>)
+    @screens.each{|s|
+      display.setImage(s[:image])
+      display.setText(s[:text])
+      display.run
+    }
+    GC.start
+  end
+  def result
+    GameResult.new(&quot;won&quot;)
+  end
 end
 
 class Campaign
-	attr_reader :name, :image, :imageName, :description, :texture, :enabled, :order
-	def initialize(filename)
-		if not fileExists(filename)
-			raise &quot;file not found #{filename}&quot;
-		end
-		@doc=Document.new(filename)
-		@xmlRoot=@doc.root
-		@enabled=(@xmlRoot.get(&quot;enabled&quot;)!=&quot;false&quot;)
-		@name=@xmlRoot.get(&quot;name&quot;)
-		@order=@xmlRoot.get(&quot;order&quot;).to_i
-		@imageName=@xmlRoot.get(&quot;image&quot;)
-		@image=AGSurface.load(@imageName)
-		@texture=AGTexture.new(@image)
-		@description=@xmlRoot.get(&quot;description&quot;)
-		@partID=@xmlRoot.get(&quot;part&quot;).to_i
-		
-		@part=[]
-		@xmlRoot.getChildren.each{|c|
-			case c.getName
-				when &quot;cutscene&quot;
-					@part.push(CutScene.new(c))
-				when &quot;level&quot;
-					@part.push(CampaignLevel.new(c))
-			end
-		}
-	end
-	def savename
-		@savename
-	end
-	def save(filename)
-		@savename=filename
-		doc=Document.new
-		root=doc.root
-		root.setName(&quot;campaign&quot;)
-		root.set(&quot;name&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at name</A>)
-		root.set(&quot;image&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at imageName</A>)
-		root.set(&quot;description&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at description</A>)
-		root.set(&quot;part&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at partID.to_s</A>)
-		@part.each{|p|
-			c=nil
-			case p.class.to_s
-				when &quot;CutScene&quot;
-					c=root.addChild(&quot;cutscene&quot;)
-				when &quot;CampaignLevel&quot;
-					c=root.addChild(&quot;level&quot;)
-				else
-					raise &quot;Unknown class type:&quot;+p.class.to_s
-			end
-			p.save(c)
-		}
-		
-		saveFile(filename,doc.toString)
-	end
-	
-	def getCurrentPart
-		@part[@partID]
-	end
-	def proceed
-		@partID+=1
-		return @partID&gt;=@part.length
-	end
-	def restart
-		@partID=0
-	end
+  attr_reader :name, :image, :imageName, :description, :texture, :enabled, :order
+  def initialize(filename)
+    if not fileExists(filename)
+      raise &quot;file not found #{filename}&quot;
+    end
+    @doc=Document.new(filename)
+    @xmlRoot=@doc.root
+    @enabled=(@xmlRoot.get(&quot;enabled&quot;)!=&quot;false&quot;)
+    @name=@xmlRoot.get(&quot;name&quot;)
+    @order=@xmlRoot.get(&quot;order&quot;).to_i
+    @imageName=@xmlRoot.get(&quot;image&quot;)
+    @image=AGSurface.load(@imageName)
+    @texture=AGTexture.new(@image)
+    @description=@xmlRoot.get(&quot;description&quot;)
+    @partID=@xmlRoot.get(&quot;part&quot;).to_i
+    
+    @part=[]
+    @xmlRoot.getChildren.each{|c|
+      case c.getName
+        when &quot;cutscene&quot;
+          @part.push(CutScene.new(c))
+        when &quot;level&quot;
+          @part.push(CampaignLevel.new(c))
+      end
+    }
+  end
+  def savename
+    @savename
+  end
+  def save(filename)
+    @savename=filename
+    doc=Document.new
+    root=doc.root
+    root.setName(&quot;campaign&quot;)
+    root.set(&quot;name&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at name</A>)
+    root.set(&quot;image&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at imageName</A>)
+    root.set(&quot;description&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at description</A>)
+    root.set(&quot;part&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at partID.to_s</A>)
+    @part.each{|p|
+      c=nil
+      case p.class.to_s
+        when &quot;CutScene&quot;
+          c=root.addChild(&quot;cutscene&quot;)
+        when &quot;CampaignLevel&quot;
+          c=root.addChild(&quot;level&quot;)
+        else
+          raise &quot;Unknown class type:&quot;+p.class.to_s
+      end
+      p.save(c)
+    }
+    
+    saveFile(filename,doc.toString)
+  end
+  
+  def getCurrentPart
+    @part[@partID]
+  end
+  def proceed
+    @partID+=1
+    return @partID&gt;=@part.length
+  end
+  def restart
+    @partID=0
+  end
 end
 
 def startCampaign(campaign)
-	campaign=campaign.dup # copy
-	continueCampaign(campaign)
+  campaign=campaign.dup # copy
+  continueCampaign(campaign)
 end
 
 def continueCampaign(campaign)
-	begin
-		$campaign=campaign
-		part=campaign.getCurrentPart
-		part.play
-		if part.result.won==&quot;won&quot;
-			if campaign.proceed
-				break
-			end
-		end
-	end while part.result.won!=&quot;canceled&quot;
-	campaign.save(&quot;campaign0.antcmp&quot;) # FIXME:test save
-	$campaign=nil
-	puts &quot;EXIT CAMPAIGNING&quot;
+  begin
+    $campaign=campaign
+    part=campaign.getCurrentPart
+    part.play
+    if part.result.won==&quot;won&quot;
+      if campaign.proceed
+        break
+      end
+    end
+  end while part.result.won!=&quot;canceled&quot;
+  campaign.save(&quot;campaign0.antcmp&quot;) # FIXME:test save
+  $campaign=nil
+  puts &quot;EXIT CAMPAIGNING&quot;
 end

Modified: antargis/trunk/ruby/credits.rb
===================================================================
--- antargis/trunk/ruby/credits.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/credits.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,75 +1,75 @@
 #!/usr/bin/env ruby
 
 if ENV[&quot;_&quot;]=~/credits.rb/
-	require 'antargisgui.rb'
+  require 'antargisgui.rb'
 end
 
 class AntTicker&lt;AGWidget
-	attr_accessor :menuapp
-	def initialize(p,r,text)
-		super(p,r)
-		@text=text
-		@y=-height
-		@time=0
-		@text=text.gsub(&quot;\t&quot;,&quot;&quot;).split(&quot;\n&quot;)
-		@nfont=AGFont.new(&quot;Arial.ttf&quot;,24)
-		@cfont=AGFont.new(&quot;Arial.ttf&quot;,24)
-		@starttime=-1
-		@speed=0.03
-	end
-	def setNFont(f)
-		@nfont=f
-	end
-	def setCFont(f)
-		@cfont=f
-	end
-	def prepareDraw
-		queryRedraw
-	end
-	def draw(p)
-		now=@menuapp.getTicks
-		if @starttime&gt;0
-			@y+=(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">now- at starttime</A>)*@speed
-		end
-		@starttime=now
-		ty=0
-		
-		@text.each{|r|
-			font=nil
-			if r=~/_/	
-				#r.sub!(&quot;_&quot;,&quot;&quot;)
-				r=r[1..(r.length-1)]
-				font=@cfont
-			else
-				font=@nfont
-			end
+  attr_accessor :menuapp
+  def initialize(p,r,text)
+    super(p,r)
+    @text=text
+    @y=-height
+    @time=0
+    @text=text.gsub(&quot;\t&quot;,&quot;&quot;).split(&quot;\n&quot;)
+    @nfont=AGFont.new(&quot;Arial.ttf&quot;,24)
+    @cfont=AGFont.new(&quot;Arial.ttf&quot;,24)
+    @starttime=-1
+    @speed=0.03
+  end
+  def setNFont(f)
+    @nfont=f
+  end
+  def setCFont(f)
+    @cfont=f
+  end
+  def prepareDraw
+    queryRedraw
+  end
+  def draw(p)
+    now=@menuapp.getTicks
+    if @starttime&gt;0
+      @y+=(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">now- at starttime</A>)*@speed
+    end
+    @starttime=now
+    ty=0
+    
+    @text.each{|r|
+      font=nil
+      if r=~/_/  
+        #r.sub!(&quot;_&quot;,&quot;&quot;)
+        r=r[1..(r.length-1)]
+        font=@cfont
+      else
+        font=@nfont
+      end
 
-			r=AGStringUtf8.new(r)
+      r=AGStringUtf8.new(r)
 
-			w=font.getWidth(r)
-			tx=((width-w)/2).to_i
-			p.renderText(r,AGVector2.new(tx,(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">ty- at y</A>)),font)
-			ty+=40
-		}
-	end
+      w=font.getWidth(r)
+      tx=((width-w)/2).to_i
+      p.renderText(r,AGVector2.new(tx,(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">ty- at y</A>)),font)
+      ty+=40
+    }
+  end
 end
 
 class AntTickerCreator&lt;AGLayoutCreator
-	def create(p,r,n)
-		t=AntTicker.new(p,r,n.get(&quot;text&quot;))
-		t.setNFont(getTheme.getFont(n.get(&quot;nfont&quot;)))
-		t.setCFont(getTheme.getFont(n.get(&quot;cfont&quot;)))
-		setResult t
-	end
+  def create(p,r,n)
+    t=AntTicker.new(p,r,n.get(&quot;text&quot;))
+    t.setNFont(getTheme.getFont(n.get(&quot;nfont&quot;)))
+    t.setCFont(getTheme.getFont(n.get(&quot;cfont&quot;)))
+    setResult t
+  end
 end
 getLayoutFactory.addCreator(&quot;antTicker&quot;,AntTickerCreator.new)
 
 
 if ENV[&quot;_&quot;]=~/credits.rb/
-	m=AGMain.new(640,480,32,false,true)
-	
-	app=AGApplication.new
-	t=AntTicker.new(nil,AGRect.new(0,0,640,480),&quot;bla\nxyz\nhallo\nkjsdhdfhdf ksdfhjsdfj h\nkjsdfjs&quot;,app)
-	app.setMainWidget(t)
-	app.run
+  m=AGMain.new(640,480,32,false,true)
+  
+  app=AGApplication.new
+  t=AntTicker.new(nil,AGRect.new(0,0,640,480),&quot;bla\nxyz\nhallo\nkjsdhdfhdf ksdfhjsdfj h\nkjsdfjs&quot;,app)
+  app.setMainWidget(t)
+  app.run
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/editor/campaign/campaign_data.rb
===================================================================
--- antargis/trunk/ruby/editor/campaign/campaign_data.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/editor/campaign/campaign_data.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,6 +1,6 @@
 module CampaignEditor
-	class Data
-	  def initialize
-	  end
-	end
+  class Data
+    def initialize
+    end
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/editor/campaign/drag_grid.rb
===================================================================
--- antargis/trunk/ruby/editor/campaign/drag_grid.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/editor/campaign/drag_grid.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -291,13 +291,13 @@
     if sRect.contains(e.getRelMousePosition)
       
       getDragGrid.select(self) if getDragGrid
-	    if sRect.shrink(BORDER_WIDTH).contains(e.getRelMousePosition)
-	      startDragging
+      if sRect.shrink(BORDER_WIDTH).contains(e.getRelMousePosition)
+        startDragging
         return true
-	    elsif @lastCell
-	      startLine(e)
+      elsif @lastCell
+        startLine(e)
         return true
-	    end
+      end
     end
     r
   end
@@ -323,18 +323,18 @@
         assignCell(cell)
       elsif @lastCell
         assignCell(@lastCell)
-	    else
-	      hide
-	    end
+      else
+        hide
+      end
     elsif @lastCell
       assignCell(@lastCell)
     else
-	    hide
+      hide
     end
     
     if cell.is_a?(DragTrash)
-	    pp cell
-	    del 
+      pp cell
+      del 
     end
     @dragging=false
     true
@@ -393,9 +393,9 @@
     #endP=getPos(@endObject) if @endObject
     
     if @endObject and @startObject
-	    if @moving==false and (@endObject.visible==false or @startObject.visible==false)
-	      hide
-	    end
+      if @moving==false and (@endObject.visible==false or @startObject.visible==false)
+        hide
+      end
     end
     white=AGColor.new(0xFF,0xFF,0xFF)
     white=AGColor.new(0xFF,0xFF,0x88) if @hovered
@@ -438,8 +438,8 @@
   def eventMouseButtonDown(e)
     r=super
     if @endObject.nil?
-	    @moving=true
-	    @pos=e.getMousePosition+(getRect.getV0-getScreenRect.getV0)
+      @moving=true
+      @pos=e.getMousePosition+(getRect.getV0-getScreenRect.getV0)
     else
       if @hovered
         @endObject=nil
@@ -451,15 +451,15 @@
   def eventMouseButtonUp(e)
     r=super
     if @moving
-	    @moving=false
-	    ts=getDragEnvironment.getAllDescendants.select{|w|w.is_a?(DragBox)}.select{|cell|
-	      cell.getScreenRect.contains(e.getMousePosition)
-	    }
-	    if ts.length==0
-	      hide
-	    else
-	      @endObject=ts[0]
-	    end
+      @moving=false
+      ts=getDragEnvironment.getAllDescendants.select{|w|w.is_a?(DragBox)}.select{|cell|
+        cell.getScreenRect.contains(e.getMousePosition)
+      }
+      if ts.length==0
+        hide
+      else
+        @endObject=ts[0]
+      end
     end
     
     r
@@ -697,10 +697,10 @@
     setMainWidget(layout)
     layout.setApp(self)
     if layout.getChild(&quot;bigTable&quot;)
-	    layout.getChild(&quot;bigTable&quot;).modifyRow(1,10)
-	    env=layout.getChild(&quot;dragEnvironment&quot;)
-	    @grid=layout.getChild(&quot;dragGrid&quot;)
-	    addHandler(env,:sigClick,:eventDeselect)
+      layout.getChild(&quot;bigTable&quot;).modifyRow(1,10)
+      env=layout.getChild(&quot;dragEnvironment&quot;)
+      @grid=layout.getChild(&quot;dragGrid&quot;)
+      addHandler(env,:sigClick,:eventDeselect)
     end
     
     

Modified: antargis/trunk/ruby/editor/dialogs.rb
===================================================================
--- antargis/trunk/ruby/editor/dialogs.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/editor/dialogs.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -18,188 +18,188 @@
 # License along with this program.
 #
 class AntEditPropDialog&lt;AntDialog
-	def initialize(parent,ent,map)
-		super(parent,&quot;data/gui/layout/editpropdialog.xml&quot;)
-		@map=map
-		@ent=ent
-		menCountW=getChild(&quot;MenCount&quot;)
-		nameW=getChild(&quot;AntName&quot;)
-		menCountW.setText(AGStringUtf8.new(@ent.getXMLProp(&quot;men&quot;)))
-		nameW.setText(AGStringUtf8.new(@ent.getName))
-		
-		getChild(&quot;NpcTypeView&quot;).hide if @ent.class!=AntNPC
-		if @ent.class==AntNPC
-			@npcTypeW=getChild(&quot;NpcType&quot;)
-			@npcTypeW.setText(AGStringUtf8.new(@ent.npcType))
-		end
+  def initialize(parent,ent,map)
+    super(parent,&quot;data/gui/layout/editpropdialog.xml&quot;)
+    @map=map
+    @ent=ent
+    menCountW=getChild(&quot;MenCount&quot;)
+    nameW=getChild(&quot;AntName&quot;)
+    menCountW.setText(AGStringUtf8.new(@ent.getXMLProp(&quot;men&quot;)))
+    nameW.setText(AGStringUtf8.new(@ent.getName))
+    
+    getChild(&quot;NpcTypeView&quot;).hide if @ent.class!=AntNPC
+    if @ent.class==AntNPC
+      @npcTypeW=getChild(&quot;NpcType&quot;)
+      @npcTypeW.setText(AGStringUtf8.new(@ent.npcType))
+    end
 
-		# init player-list
-		plist=getChild(&quot;Player&quot;)
-		players=@map.players
-		playernames=[&quot;NONE&quot;]
-		playernames+=players.collect{|p|p.getName} if ent.is_a?(AntBoss)
-		playernames.each{|n|
-			plist.insertItem(n,AGStringUtf8.new(n))
-		}
-		if ent.is_a?(AntBoss)
-			if ent.getPlayer
-				plist.setSelected(ent.getPlayer.getName)
-			end
-		end
+    # init player-list
+    plist=getChild(&quot;Player&quot;)
+    players=@map.players
+    playernames=[&quot;NONE&quot;]
+    playernames+=players.collect{|p|p.getName} if ent.is_a?(AntBoss)
+    playernames.each{|n|
+      plist.insertItem(n,AGStringUtf8.new(n))
+    }
+    if ent.is_a?(AntBoss)
+      if ent.getPlayer
+        plist.setSelected(ent.getPlayer.getName)
+      end
+    end
 
 
-	end
-	def eventOk(e)
-		menCountW=getChild(&quot;MenCount&quot;)
-		nameW=getChild(&quot;AntName&quot;)
-		@ent.setName(nameW.getText.to_s)
-		@ent.setXMLProp(&quot;men&quot;,menCountW.getText.to_s)
-		close
-		@ent.npcType=@npcTypeW.getText.to_s if @ent.class==AntNPC
-		@ent.setupMesh
-		if @ent.is_a?(AntBoss)
-			name=getChild(&quot;Player&quot;).getSelected
-			@ent.setPlayer(@map.players.find{|n|n.getName==name})
-		end
-		return true
-	end
+  end
+  def eventOk(e)
+    menCountW=getChild(&quot;MenCount&quot;)
+    nameW=getChild(&quot;AntName&quot;)
+    @ent.setName(nameW.getText.to_s)
+    @ent.setXMLProp(&quot;men&quot;,menCountW.getText.to_s)
+    close
+    @ent.npcType=@npcTypeW.getText.to_s if @ent.class==AntNPC
+    @ent.setupMesh
+    if @ent.is_a?(AntBoss)
+      name=getChild(&quot;Player&quot;).getSelected
+      @ent.setPlayer(@map.players.find{|n|n.getName==name})
+    end
+    return true
+  end
 end
 
 
 class AntEditGeneratorDialog&lt;AntDialog
-	attr_reader :edits
-	def initialize(parent,params)
-		super(parent,&quot;data/gui/layout/editor_generator.xml&quot;)
-		addSignal(&quot;sigGenerate&quot;)
+  attr_reader :edits
+  def initialize(parent,params)
+    super(parent,&quot;data/gui/layout/editor_generator.xml&quot;)
+    addSignal(&quot;sigGenerate&quot;)
 
-		@params=params
-		@edits={}
+    @params=params
+    @edits={}
 
-		frame=getChild(&quot;frame&quot;)
+    frame=getChild(&quot;frame&quot;)
 
-		table=AGTable.new(frame,frame.getRect.origin)
+    table=AGTable.new(frame,frame.getRect.origin)
 
-		table.addColumn(1)
-		table.addColumn(1)
-		params.params.each{|p|
-			table.addRow(1)
-		}
-		y=0
-		#table.arrange
-		params.params.each{|p|
-			n=AGText.new(table,AGRect2.new(0,0,80,20),AGStringUtf8.new(p.to_s+&quot;:&quot;),AGFont.new(&quot;FreeSans.ttf&quot;,20))
-			#n.setAlign(AGText::RIGHT)
-			#n=AGButton.new(table,AGRect2.new(0,0,80,20),&quot;huhuhu&quot;)
-			table.addChild(0,y,n)
-			e=AGEdit.new(table,AGRect2.new(0,0,80,20))
-			edits[p]=e
-			e.setText(AGStringUtf8.new(eval(&quot;params.#{p}&quot;).to_s))
-			table.addChild(1,y,e)
+    table.addColumn(1)
+    table.addColumn(1)
+    params.params.each{|p|
+      table.addRow(1)
+    }
+    y=0
+    #table.arrange
+    params.params.each{|p|
+      n=AGText.new(table,AGRect2.new(0,0,80,20),AGStringUtf8.new(p.to_s+&quot;:&quot;),AGFont.new(&quot;FreeSans.ttf&quot;,20))
+      #n.setAlign(AGText::RIGHT)
+      #n=AGButton.new(table,AGRect2.new(0,0,80,20),&quot;huhuhu&quot;)
+      table.addChild(0,y,n)
+      e=AGEdit.new(table,AGRect2.new(0,0,80,20))
+      edits[p]=e
+      e.setText(AGStringUtf8.new(eval(&quot;params.#{p}&quot;).to_s))
+      table.addChild(1,y,e)
 
-			y+=1
-		}
-		table.arrange
+      y+=1
+    }
+    table.arrange
 
-		frame.addChild(table)
-	end
-	def eventOk(e)
-		close
-		e.setName(&quot;sigGenerate&quot;)
-		sigGenerate(e)
-		return true
-	end
+    frame.addChild(table)
+  end
+  def eventOk(e)
+    close
+    e.setName(&quot;sigGenerate&quot;)
+    sigGenerate(e)
+    return true
+  end
 end
 
 
 
 class AntPlayerEditDialog&lt;AGLayout
-	include AGHandler
-	def initialize(parent,map)
-		super(parent)
-		@map=map
-		loadXML(loadFile(&quot;data/gui/layout/editor_players_dialog.xml&quot;))
-		@players={}
-		@list=getChild(&quot;playerList&quot;)
-		initPlayerNames
-		initPlayerTypes
+  include AGHandler
+  def initialize(parent,map)
+    super(parent)
+    @map=map
+    loadXML(loadFile(&quot;data/gui/layout/editor_players_dialog.xml&quot;))
+    @players={}
+    @list=getChild(&quot;playerList&quot;)
+    initPlayerNames
+    initPlayerTypes
 
-		if @players.length&gt;0
-			eventPlayerSelected(nil)
-		end
-			
-		addHandler(@list,:sigSelect,:eventPlayerSelected)
-		addHandler(getChild(&quot;addPlayer&quot;),:sigClick,:eventAddPlayer)
-		addHandler(getChild(&quot;changePlayer&quot;),:sigClick,:eventChangePlayer)
-		addHandler(getChild(&quot;deletePlayer&quot;),:sigClick,:eventDelPlayer)
-	end
+    if @players.length&gt;0
+      eventPlayerSelected(nil)
+    end
+      
+    addHandler(@list,:sigSelect,:eventPlayerSelected)
+    addHandler(getChild(&quot;addPlayer&quot;),:sigClick,:eventAddPlayer)
+    addHandler(getChild(&quot;changePlayer&quot;),:sigClick,:eventChangePlayer)
+    addHandler(getChild(&quot;deletePlayer&quot;),:sigClick,:eventDelPlayer)
+  end
 
-	def eventPlayerSelected(e)
-		name=@list.getSelectedID
-		getChild(&quot;playerName&quot;).setText(name)
-		getChild(&quot;playerType&quot;).selectItem(@players[name].class.to_s)
-		return true
-	end
+  def eventPlayerSelected(e)
+    name=@list.getSelectedID
+    getChild(&quot;playerName&quot;).setText(name)
+    getChild(&quot;playerType&quot;).selectItem(@players[name].class.to_s)
+    return true
+  end
 
-	def eventAddPlayer(e)
-		# check if already a player of this name exists
-		name=getChild(&quot;playerName&quot;).getText
-		if @players.keys.member?(name)
-			messageBox(&quot;Error&quot;,&quot;Please enter a new player-name. This already exists!&quot;,MB_OK)
-		else
-			type=eval(getChild(&quot;playerType&quot;).getSelectedID)
-			player=type.new(@map,name)
-			@map.players.push(player)
-			initPlayerNames
-		end
-		return true
-	end
+  def eventAddPlayer(e)
+    # check if already a player of this name exists
+    name=getChild(&quot;playerName&quot;).getText
+    if @players.keys.member?(name)
+      messageBox(&quot;Error&quot;,&quot;Please enter a new player-name. This already exists!&quot;,MB_OK)
+    else
+      type=eval(getChild(&quot;playerType&quot;).getSelectedID)
+      player=type.new(@map,name)
+      @map.players.push(player)
+      initPlayerNames
+    end
+    return true
+  end
 
-	def eventChangePlayer(e)
-		name=getChild(&quot;playerName&quot;).getText
-		sel=@list.getSelectedID
-		if @players.keys.member?(name) and sel!=name
-			messageBox(&quot;Error&quot;,&quot;Please enter a new player-name. This already exists!&quot;,MB_OK)
-		else
-			@players[sel].name=name
-			type=eval(getChild(&quot;playerType&quot;).getSelectedID)
-			if type!=@players[sel].class
-				# argh, assigned new player type - delete old one and generate new
-				getMap.players.delete(@players[sel])
-				player=type.new(name)
-				getMap.players.push(player)
-			end
-			initPlayerNames
-		end
-		return true
-	end
-	
-	def eventDelPlayer(e)
-		sel=@list.getSelectedID
-		if @players[sel]
-			getMap.players.delete(@players[sel])
-			initPlayerNames
-		end
-		return true
-	end
+  def eventChangePlayer(e)
+    name=getChild(&quot;playerName&quot;).getText
+    sel=@list.getSelectedID
+    if @players.keys.member?(name) and sel!=name
+      messageBox(&quot;Error&quot;,&quot;Please enter a new player-name. This already exists!&quot;,MB_OK)
+    else
+      @players[sel].name=name
+      type=eval(getChild(&quot;playerType&quot;).getSelectedID)
+      if type!=@players[sel].class
+        # argh, assigned new player type - delete old one and generate new
+        getMap.players.delete(@players[sel])
+        player=type.new(name)
+        getMap.players.push(player)
+      end
+      initPlayerNames
+    end
+    return true
+  end
+  
+  def eventDelPlayer(e)
+    sel=@list.getSelectedID
+    if @players[sel]
+      getMap.players.delete(@players[sel])
+      initPlayerNames
+    end
+    return true
+  end
 
 private
-	def initPlayerNames
-		@list.clearList
-		@players={}
-		@map.players.each{|p|
-		  puts &quot;initPlayNames:#{p}:#{p.class}:#{p.name}:#{p.name.class}&quot;
-			@list.insertItem(p.name.to_s,p.name)
-			@players[p.name]=p
-		}
-	end
+  def initPlayerNames
+    @list.clearList
+    @players={}
+    @map.players.each{|p|
+      puts &quot;initPlayNames:#{p}:#{p.class}:#{p.name}:#{p.name.class}&quot;
+      @list.insertItem(p.name.to_s,p.name)
+      @players[p.name]=p
+    }
+  end
 
-	def initPlayerTypes
-		@types=getDescendantsOfClass(AntPlayer)
-		l=getChild(&quot;playerType&quot;)
-		l.clearList
-		@types.each{|t|
-			l.insertItem(t.to_s,AGStringUtf8.new(t.to_s))
-		}
-	end
+  def initPlayerTypes
+    @types=getDescendantsOfClass(AntPlayer)
+    l=getChild(&quot;playerType&quot;)
+    l.clearList
+    @types.each{|t|
+      l.insertItem(t.to_s,AGStringUtf8.new(t.to_s))
+    }
+  end
 end
 

Modified: antargis/trunk/ruby/editor/ent_list.rb
===================================================================
--- antargis/trunk/ruby/editor/ent_list.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/editor/ent_list.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -19,77 +19,77 @@
 #
 
 class AntEntListWidget&lt;AGWidget
-	attr_reader :entType
-	def initialize(p,r)
-		super(p,r)
-		@entType=nil
-		@classes=getDescendantsOfClass(AntRubyEntity)
-		@wptrs={}
+  attr_reader :entType
+  def initialize(p,r)
+    super(p,r)
+    @entType=nil
+    @classes=getDescendantsOfClass(AntRubyEntity)
+    @wptrs={}
 
-		group=AGRadioGroup.new(self,getRect.origin)
-		group.setName(&quot;EntListGroup&quot;)
-		addChild(group)
-		cells=(Math::sqrt(@classes.length)+1).to_i
-		table=AGTable.new(group,getRect.origin)
-		@table=table
-		(1..cells).each{|n|
-			table.addColumn(1)
-			table.addRow(1)
-		}
+    group=AGRadioGroup.new(self,getRect.origin)
+    group.setName(&quot;EntListGroup&quot;)
+    addChild(group)
+    cells=(Math::sqrt(@classes.length)+1).to_i
+    table=AGTable.new(group,getRect.origin)
+    @table=table
+    (1..cells).each{|n|
+      table.addColumn(1)
+      table.addRow(1)
+    }
 
-		i=0
-		@classes.each{|c|
-			x=i%cells
-			y=i/cells
-			n=c.to_s
-			puts &quot;#{i} #{x} #{y} #{n}&quot;
-			w=AGRadio.new(table,AGRect2.new(0,0,40,40))
-			@wptrs[c]=w
-			w.setName(n)
-			w.setTooltip(_(n))
-			addHandler(w,:sigClick,:eventSelected)
-		
-			fn=&quot;data/gui/editor/entities/#{n}.png&quot;
-			if File.exists?(fn)
-				w.setSurface(AGSurface.load(fn))
-			else
-				w.setEnabled(false)
-			end
+    i=0
+    @classes.each{|c|
+      x=i%cells
+      y=i/cells
+      n=c.to_s
+      puts &quot;#{i} #{x} #{y} #{n}&quot;
+      w=AGRadio.new(table,AGRect2.new(0,0,40,40))
+      @wptrs[c]=w
+      w.setName(n)
+      w.setTooltip(_(n))
+      addHandler(w,:sigClick,:eventSelected)
+    
+      fn=&quot;data/gui/editor/entities/#{n}.png&quot;
+      if File.exists?(fn)
+        w.setSurface(AGSurface.load(fn))
+      else
+        w.setEnabled(false)
+      end
 
-			table.addChild(x,y,w)
-			i+=1
-		}
-		table.arrange
-		group.addChild(table)
+      table.addChild(x,y,w)
+      i+=1
+    }
+    table.arrange
+    group.addChild(table)
 
-		setCaching(true)
-		addSignal(&quot;sigSelected&quot;)
-	end
-	def eventSelected(e)
-		c=eval(e.getCaller.getName)
-		@entType=c
-		@selWidget=e.getCaller
-		sigSelected(e)
-		return true
-	end
-	def entType=(c)
-		@wptrs[c].setChecked(true)
-		@entType=c
-	end
-	def deselect
-		if @selWidget
-			@selWidget.deselect
-		end
-	end
+    setCaching(true)
+    addSignal(&quot;sigSelected&quot;)
+  end
+  def eventSelected(e)
+    c=eval(e.getCaller.getName)
+    @entType=c
+    @selWidget=e.getCaller
+    sigSelected(e)
+    return true
+  end
+  def entType=(c)
+    @wptrs[c].setChecked(true)
+    @entType=c
+  end
+  def deselect
+    if @selWidget
+      @selWidget.deselect
+    end
+  end
 end
 
 class AntEntListCreator&lt;AGLayoutCreator
-	def create(parent,rect,node)
-		e=AntEntListWidget.new(parent,rect)
-		e.setName(node.get(&quot;name&quot;))
-		puts node.get(&quot;name&quot;)
-		setResult e
-	end
+  def create(parent,rect,node)
+    e=AntEntListWidget.new(parent,rect)
+    e.setName(node.get(&quot;name&quot;))
+    puts node.get(&quot;name&quot;)
+    setResult e
+  end
 end
 getLayoutFactory.addCreator(&quot;antEntList&quot;,AntEntListCreator.new)
 

Modified: antargis/trunk/ruby/editor/spec/spec_editor.rb
===================================================================
--- antargis/trunk/ruby/editor/spec/spec_editor.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/editor/spec/spec_editor.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -8,77 +8,77 @@
 
 
 describe &quot;MapEditor&quot; do
-	include GuiTest
-	before(:all) do
-		@app=makeTestAppClass(AntEditorApp).new(1024,768)
-		@mainWidget=@app.getMainWidget
-		@app.step
-	end
-	it &quot;should run&quot; do
-		1.should == 1
-	end
+  include GuiTest
+  before(:all) do
+    @app=makeTestAppClass(AntEditorApp).new(1024,768)
+    @mainWidget=@app.getMainWidget
+    @app.step
+  end
+  it &quot;should run&quot; do
+    1.should == 1
+  end
 
-	it &quot;should create a clear map when using the new-dialog&quot; do
-		new=widget(&quot;new&quot;)
-		new.visible.should be_true
-		new.click
-		dialog=widget(&quot;NewDialog&quot;)
-		dialog.visible.should be_true
+  it &quot;should create a clear map when using the new-dialog&quot; do
+    new=widget(&quot;new&quot;)
+    new.visible.should be_true
+    new.click
+    dialog=widget(&quot;NewDialog&quot;)
+    dialog.visible.should be_true
 
-		okButton=dialog.child(&quot;ok&quot;)
-		okButton.visible.should be_true
-		okButton.click
-		@app.step
-		widget(&quot;NewDialog&quot;).valid.should be_false
-		@app.step
-	end
+    okButton=dialog.child(&quot;ok&quot;)
+    okButton.visible.should be_true
+    okButton.click
+    @app.step
+    widget(&quot;NewDialog&quot;).valid.should be_false
+    @app.step
+  end
 
-	it &quot;should add trees to the empty map&quot; do
-		entitiesButton=widget(&quot;entities&quot;)
-		entitiesButton.should be_a_kind_of(AGRadio)
-		entitiesButton.click
-		entitiesList=widget(&quot;entitiesTab&quot;)
-		entitiesList.should be_an_instance_of(AntEntListWidget)
-		entitiesList.should be_visible
-		fir=entitiesList.child(&quot;AntFir&quot;)
-		fir.should be_an_instance_of(AGRadio)
-		fir.isChecked.should be_false
-		fir.click
-		entitiesList.entType.should == AntFir
-		@app.getMap.should have_exactly(0).getAllEntities
-		clickScreen(700,200)
-		@app.getMap.should have_exactly(1).getAllEntities
-		clickScreen(710,210)
-		@app.getMap.should have_exactly(2).getAllEntities
-	end
-	it &quot;should display the player-dialog&quot; do
-		playerButton=widget(&quot;playerButton&quot;)
-		playerButton.should be_an_instance_of(AGButton)
-		playerButton.click
-		playerDialog=widget(&quot;PlayersDialog&quot;)
-		playerDialog.should be_visible
-	end
+  it &quot;should add trees to the empty map&quot; do
+    entitiesButton=widget(&quot;entities&quot;)
+    entitiesButton.should be_a_kind_of(AGRadio)
+    entitiesButton.click
+    entitiesList=widget(&quot;entitiesTab&quot;)
+    entitiesList.should be_an_instance_of(AntEntListWidget)
+    entitiesList.should be_visible
+    fir=entitiesList.child(&quot;AntFir&quot;)
+    fir.should be_an_instance_of(AGRadio)
+    fir.isChecked.should be_false
+    fir.click
+    entitiesList.entType.should == AntFir
+    @app.getMap.should have_exactly(0).getAllEntities
+    clickScreen(700,200)
+    @app.getMap.should have_exactly(1).getAllEntities
+    clickScreen(710,210)
+    @app.getMap.should have_exactly(2).getAllEntities
+  end
+  it &quot;should display the player-dialog&quot; do
+    playerButton=widget(&quot;playerButton&quot;)
+    playerButton.should be_an_instance_of(AGButton)
+    playerButton.click
+    playerDialog=widget(&quot;PlayersDialog&quot;)
+    playerDialog.should be_visible
+  end
 
-	it &quot;should be ok to save&quot; do
+  it &quot;should be ok to save&quot; do
 
 
-		widget(&quot;saveButton&quot;).click
+    widget(&quot;saveButton&quot;).click
 
 
-		saveDialog=widget(&quot;SaveDialog&quot;)
+    saveDialog=widget(&quot;SaveDialog&quot;)
 
 
-		saveDialog.should be_a_kind_of(AGWidget)
-		saveDialog.should be_visible
-		filename=saveDialog.child(&quot;Filename&quot;)
-		filename.should be_a_kind_of(AGEdit)
-		filename.setText(AGStringUtf8.new(&quot;mytestfile&quot;))
-		okButton=saveDialog.child(&quot;ok&quot;)
-		okButton.should be_a_kind_of(AGButton)
-		okButton.click
-		File.should be_exists(getWriteDir+&quot;/data/levels/mytestfile.png&quot;)
-		File.should be_exists(getWriteDir+&quot;/data/levels/mytestfile.antlvl&quot;)
-	end
+    saveDialog.should be_a_kind_of(AGWidget)
+    saveDialog.should be_visible
+    filename=saveDialog.child(&quot;Filename&quot;)
+    filename.should be_a_kind_of(AGEdit)
+    filename.setText(AGStringUtf8.new(&quot;mytestfile&quot;))
+    okButton=saveDialog.child(&quot;ok&quot;)
+    okButton.should be_a_kind_of(AGButton)
+    okButton.click
+    File.should be_exists(getWriteDir+&quot;/data/levels/mytestfile.png&quot;)
+    File.should be_exists(getWriteDir+&quot;/data/levels/mytestfile.antlvl&quot;)
+  end
 
 
 end

Modified: antargis/trunk/ruby/editor/tab_layout.rb
===================================================================
--- antargis/trunk/ruby/editor/tab_layout.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/editor/tab_layout.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -19,35 +19,35 @@
 #
 
 class AntTabLayout&lt;AGTable
-	def initialize(p,r)
-		super
-		@s=AGSurface.load(&quot;data/gui/buttontest3.png&quot;)
-		@sw=@s.width/3
-		@sh=@s.height/3
-		@ts={}
-		(0..2).each{|x|
-			(0..2).each{|y|
-				@ts[[x,y]]=AGTexture.new(@s.getSubSurface(x*@s.width/3,y*@s.height/3))
-			}
-		}
-	end
-	def draw(p)
-		p.blit(@ts[[0,0]],AGRect2.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0,0, at sw</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at sh</A>))
-	end
+  def initialize(p,r)
+    super
+    @s=AGSurface.load(&quot;data/gui/buttontest3.png&quot;)
+    @sw=@s.width/3
+    @sh=@s.height/3
+    @ts={}
+    (0..2).each{|x|
+      (0..2).each{|y|
+        @ts[[x,y]]=AGTexture.new(@s.getSubSurface(x*@s.width/3,y*@s.height/3))
+      }
+    }
+  end
+  def draw(p)
+    p.blit(@ts[[0,0]],AGRect2.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0,0, at sw</A><A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at sh</A>))
+  end
 end
 
 
 class AntTabLayoutCreator&lt;AGLayoutCreator
-	def initialize()
-		super(&quot;antTabLayout&quot;)
-	end
-	def create(parent,rect,node)
-		e=AntTabLayout.new(parent,rect)
-		e.setName(node.get(&quot;name&quot;))
-		puts node.get(&quot;name&quot;)
-		#raise 1
-		return e
-	end
+  def initialize()
+    super(&quot;antTabLayout&quot;)
+  end
+  def create(parent,rect,node)
+    e=AntTabLayout.new(parent,rect)
+    e.setName(node.get(&quot;name&quot;))
+    puts node.get(&quot;name&quot;)
+    #raise 1
+    return e
+  end
 end
 
 

Modified: antargis/trunk/ruby/editor/test/player_dialog.rb
===================================================================
--- antargis/trunk/ruby/editor/test/player_dialog.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/editor/test/player_dialog.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -9,63 +9,63 @@
 
 
 class DialogTest&lt;Test::Unit::TestCase
-	include GuiTest
-	def setup
-		@app=makeTestAppClass(AntEditorApp).new(1024,768)
-		@mainWidget=@app.getMainWidget
-		@app.step
-	end
-	def test_simplerun
-		newdialog
-		addtree
- 		playerdialog
-	end
+  include GuiTest
+  def setup
+    @app=makeTestAppClass(AntEditorApp).new(1024,768)
+    @mainWidget=@app.getMainWidget
+    @app.step
+  end
+  def test_simplerun
+    newdialog
+    addtree
+     playerdialog
+  end
 private
- 	def checkGlobals
- 		assert($map.nil?,&quot;$map is nil&quot;)
- 	end
-	def newdialog
-		new=widget(&quot;new&quot;)
-		assert(new.visible)
-		new.click
-		dialog=widget(&quot;NewDialog&quot;)
-		assert(dialog.visible,&quot;NewDialog is not visible after clicking 'new'&quot;)
+   def checkGlobals
+     assert($map.nil?,&quot;$map is nil&quot;)
+   end
+  def newdialog
+    new=widget(&quot;new&quot;)
+    assert(new.visible)
+    new.click
+    dialog=widget(&quot;NewDialog&quot;)
+    assert(dialog.visible,&quot;NewDialog is not visible after clicking 'new'&quot;)
 
-		okButton=dialog.child(&quot;ok&quot;)
-		assert(okButton.visible,&quot;ok-button in NewDialog is not visible&quot;)
-		okButton.click
-		@app.step
-		assert((not widget(&quot;NewDialog&quot;).valid),&quot;new dialog is not registered anymore&quot;)
-		@app.step
-	end
-	def addtree
-		entitiesButton=widget(&quot;entities&quot;)
-		assert(entitiesButton.is_a?(AGRadio),&quot;Button named 'entities' is a radio-button&quot;)
-		entitiesButton.click
-		entitiesList=widget(&quot;entitiesTab&quot;)
-		assert(entitiesList.is_a?(AntEntListWidget),&quot;Entity List is named 'entitiesTab'&quot;)
-		assert(entitiesList.visible,&quot;entity list is visible&quot;)
-		fir=entitiesList.child(&quot;AntFir&quot;)
-		assert(fir.is_a?(AGRadio),&quot;fir button is a radio-button&quot;)
-		assert((not fir.isChecked),&quot;Fir button is not checked&quot;)
-		fir.click
-		assert(entitiesList.entType==AntFir,&quot;Fir button is checked&quot;)
-		clickScreen(700,200)
-		assert(@app.getMap.getAllEntities.length==1,&quot;there's one entity!&quot;)
-		clickScreen(710,210)
-		assert(@app.getMap.getAllEntities.length==2,&quot;there're two entities!&quot;)
-	end
-	def playerdialog
-		playerButton=widget(&quot;playerButton&quot;)
-		assert(playerButton.is_a?(AGButton),&quot;playerButton is a button&quot;)
-		playerButton.click
-		playerDialog=widget(&quot;PlayersDialog&quot;)
-		assert(playerDialog.visible,&quot;player dialog is visible&quot;)
-	end
+    okButton=dialog.child(&quot;ok&quot;)
+    assert(okButton.visible,&quot;ok-button in NewDialog is not visible&quot;)
+    okButton.click
+    @app.step
+    assert((not widget(&quot;NewDialog&quot;).valid),&quot;new dialog is not registered anymore&quot;)
+    @app.step
+  end
+  def addtree
+    entitiesButton=widget(&quot;entities&quot;)
+    assert(entitiesButton.is_a?(AGRadio),&quot;Button named 'entities' is a radio-button&quot;)
+    entitiesButton.click
+    entitiesList=widget(&quot;entitiesTab&quot;)
+    assert(entitiesList.is_a?(AntEntListWidget),&quot;Entity List is named 'entitiesTab'&quot;)
+    assert(entitiesList.visible,&quot;entity list is visible&quot;)
+    fir=entitiesList.child(&quot;AntFir&quot;)
+    assert(fir.is_a?(AGRadio),&quot;fir button is a radio-button&quot;)
+    assert((not fir.isChecked),&quot;Fir button is not checked&quot;)
+    fir.click
+    assert(entitiesList.entType==AntFir,&quot;Fir button is checked&quot;)
+    clickScreen(700,200)
+    assert(@app.getMap.getAllEntities.length==1,&quot;there's one entity!&quot;)
+    clickScreen(710,210)
+    assert(@app.getMap.getAllEntities.length==2,&quot;there're two entities!&quot;)
+  end
+  def playerdialog
+    playerButton=widget(&quot;playerButton&quot;)
+    assert(playerButton.is_a?(AGButton),&quot;playerButton is a button&quot;)
+    playerButton.click
+    playerDialog=widget(&quot;PlayersDialog&quot;)
+    assert(playerDialog.visible,&quot;player dialog is visible&quot;)
+  end
 
-	def clickScreen(x,y)
-		@app.eventMouseButtonDown(newEvent(@app,&quot;&quot;,toSDLEvent(&quot;SDL_MOUSEBUTTONDOWN:0:1:1:#{x.to_i}:#{y.to_i}&quot;)))
-		@app.eventMouseButtonUp(newEvent(@app,&quot;&quot;,toSDLEvent(&quot;SDL_MOUSEBUTTONUP:0:1:1:#{x.to_i}:#{y.to_i}&quot;)))
-	end
+  def clickScreen(x,y)
+    @app.eventMouseButtonDown(newEvent(@app,&quot;&quot;,toSDLEvent(&quot;SDL_MOUSEBUTTONDOWN:0:1:1:#{x.to_i}:#{y.to_i}&quot;)))
+    @app.eventMouseButtonUp(newEvent(@app,&quot;&quot;,toSDLEvent(&quot;SDL_MOUSEBUTTONUP:0:1:1:#{x.to_i}:#{y.to_i}&quot;)))
+  end
 end
 

Modified: antargis/trunk/ruby/editor_app.rb
===================================================================
--- antargis/trunk/ruby/editor_app.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/editor_app.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -25,7 +25,7 @@
 # add programdir to path
 $:.push($programDir)
 [&quot;entities&quot;,&quot;widgets&quot;].each{|subdir|
-	$:.push(File.join($programDir,subdir))
+  $:.push(File.join($programDir,subdir))
 }
 
 require 'antargislib.rb'
@@ -40,97 +40,97 @@
 
 
 def getSavePath
-	&quot;data/levels&quot;
+  &quot;data/levels&quot;
 end
 
 class AntEditorApp &lt; AntRubyEditView
-	def initialize(sw,sh)
-		super(sw,sh,nil)
-		$app=self	
-		@map=AntRubyMap.new(self,getScene,128,128)
-		@map.setHeight(-0.5)
+  def initialize(sw,sh)
+    super(sw,sh,nil)
+    $app=self  
+    @map=AntRubyMap.new(self,getScene,128,128)
+    @map.setHeight(-0.5)
 
-		addHandler(@layout.getChild(&quot;quit&quot;),:sigClick,:eventQuit)
-		
-		addHandler(@layout.getChild(&quot;doGen&quot;),:sigClick,:eventGenerateDialog)
+    addHandler(@layout.getChild(&quot;quit&quot;),:sigClick,:eventQuit)
+    
+    addHandler(@layout.getChild(&quot;doGen&quot;),:sigClick,:eventGenerateDialog)
 
-		addHandler(@layout.getChild(&quot;loadButton&quot;),:sigClick,:load)
-		addHandler(@layout.getChild(&quot;saveButton&quot;),:sigClick,:save)
+    addHandler(@layout.getChild(&quot;loadButton&quot;),:sigClick,:load)
+    addHandler(@layout.getChild(&quot;saveButton&quot;),:sigClick,:save)
 
-		addHandler(@layout.getChild(&quot;playerButton&quot;),:sigClick,:editPlayers)
-		
-		@miniMap=@layout.getChild(&quot;miniMap&quot;)
-		@miniMap.setMap(getMap)
-		@miniMap.setScene(getScene)
-		
-		$screen=@layout
-		
-		#eventGenerate
-	end
+    addHandler(@layout.getChild(&quot;playerButton&quot;),:sigClick,:editPlayers)
+    
+    @miniMap=@layout.getChild(&quot;miniMap&quot;)
+    @miniMap.setMap(getMap)
+    @miniMap.setScene(getScene)
+    
+    $screen=@layout
+    
+    #eventGenerate
+  end
 
-	def getMap
-		@map
-	end
+  def getMap
+    @map
+  end
 
-	def eventGenerateDialog
-		@layout.addChild(dialog=AntEditGeneratorDialog.new(@layout,GeneratorParameters.new))
-		addHandler(dialog,:sigGenerate,:eventGenerate)
-		@generatorDialog=dialog
-	end
-	def eventGenerate
-		map=getMap
-		getMap.setHeight(-0.5)
-		ps=GeneratorParameters.new
-		ps.readFromDialog(@generatorDialog)
+  def eventGenerateDialog
+    @layout.addChild(dialog=AntEditGeneratorDialog.new(@layout,GeneratorParameters.new))
+    addHandler(dialog,:sigGenerate,:eventGenerate)
+    @generatorDialog=dialog
+  end
+  def eventGenerate
+    map=getMap
+    getMap.setHeight(-0.5)
+    ps=GeneratorParameters.new
+    ps.readFromDialog(@generatorDialog)
 
-		if true
-			generateMap(getMap,ps)
-		end
-		return true
-	end
-	
-	def eventFrame(time)
-		super(time)
-		getScene.advance(time)
-		return true
-	end
-	
-	def eventIdle
-		delay(20)
-		return true
-	end
-	
-	# signals	
-	def eventQuit(e)
-		@layout.addChild(AntQuitDialog.new(@layout))
-		return true
-	end
-	def eventPause(e)
-		if not getMap().paused then
-			@layout.addChild(AntPauseDialog.new(@layout))
-		else
-			getMap().unpause
-		end
-		return true
-	end
-	def eventOptions(e)
-		@layout.addChild(AntOptionsDialog.new(@layout))
-		return true
-	end
+    if true
+      generateMap(getMap,ps)
+    end
+    return true
+  end
+  
+  def eventFrame(time)
+    super(time)
+    getScene.advance(time)
+    return true
+  end
+  
+  def eventIdle
+    delay(20)
+    return true
+  end
+  
+  # signals  
+  def eventQuit(e)
+    @layout.addChild(AntQuitDialog.new(@layout))
+    return true
+  end
+  def eventPause(e)
+    if not getMap().paused then
+      @layout.addChild(AntPauseDialog.new(@layout))
+    else
+      getMap().unpause
+    end
+    return true
+  end
+  def eventOptions(e)
+    @layout.addChild(AntOptionsDialog.new(@layout))
+    return true
+  end
 
-	def editPlayers
-		@layout.addChild(AntPlayerEditDialog.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">layout, at map</A>))
-		return true
-	end
-	
-	def enableEdit
-		toEditIsoView(@layout.getChild(&quot;mainView&quot;)).toggleEdit
-	end
-	def save
-		@layout.addChild(AntSaveDialog.new(@layout))
-	end
-	def load
-		@layout.addChild(AntLoadDialog.new(@layout))
-	end
-	
+  def editPlayers
+    @layout.addChild(AntPlayerEditDialog.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">layout, at map</A>))
+    return true
+  end
+  
+  def enableEdit
+    toEditIsoView(@layout.getChild(&quot;mainView&quot;)).toggleEdit
+  end
+  def save
+    @layout.addChild(AntSaveDialog.new(@layout))
+  end
+  def load
+    @layout.addChild(AntLoadDialog.new(@layout))
+  end
+  
 end

Modified: antargis/trunk/ruby/editview.rb
===================================================================
--- antargis/trunk/ruby/editview.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/editview.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -22,365 +22,365 @@
 require 'editor/ent_list.rb'
 
 class AntRubyEditView&lt;GLApp
-	include AGHandler
-	def initialize(w,h,map)
-		super(w,h)
-		#$map=map
-		@map=map
-		@size=3
-		$scene=getScene
-	
-		@layout=AGLayout.new(nil)
+  include AGHandler
+  def initialize(w,h,map)
+    super(w,h)
+    #$map=map
+    @map=map
+    @size=3
+    $scene=getScene
+  
+    @layout=AGLayout.new(nil)
 
-		@layout.setApp(self)
-		@layout.loadXML(loadFile(&quot;data/gui/layout/edit_layout.xml&quot;))
-		
-		setMainWidget(@layout)
-		@mainWidget=@layout
-		addHandler(@layout.getChild(&quot;allWater&quot;),:sigClick,:eventAllWater)
-		addHandler(@layout.getChild(&quot;allGrass&quot;),:sigClick,:eventAllGrass)
-		
-		addHandler(@layout.getChild(&quot;rubber&quot;),:sigClick,:eventRubber)
+    @layout.setApp(self)
+    @layout.loadXML(loadFile(&quot;data/gui/layout/edit_layout.xml&quot;))
+    
+    setMainWidget(@layout)
+    @mainWidget=@layout
+    addHandler(@layout.getChild(&quot;allWater&quot;),:sigClick,:eventAllWater)
+    addHandler(@layout.getChild(&quot;allGrass&quot;),:sigClick,:eventAllGrass)
+    
+    addHandler(@layout.getChild(&quot;rubber&quot;),:sigClick,:eventRubber)
 
-		addHandler(@layout.getChild(&quot;entitiesTab&quot;),:sigSelected,:eventEntitySelected)
+    addHandler(@layout.getChild(&quot;entitiesTab&quot;),:sigSelected,:eventEntitySelected)
 
-		addHandler(@layout.getChild(&quot;pointer&quot;),:sigClick,:eventPointer)
-		
-		[1,2,3,5,10,15].each{|s|addHandler(@layout.getChild(&quot;edit#{s}&quot;),:sigClick,:eventSize)}
-		[&quot;editHeight&quot;,&quot;editWater&quot;,&quot;editSand&quot;,&quot;editGround&quot;,&quot;editGrass&quot;,&quot;editGrass2&quot;,&quot;editForest&quot;,&quot;editRock&quot;].each{|n|
-			addHandler(@layout.getChild(n),:sigClick,:eventSelectEdit)
-		}
-		[1,2,3].each{|h|addHandler(@layout.getChild(&quot;hard#{h}&quot;),:sigClick,:eventHard)}
-		
-		@hard=2
-		@layout.getChild(&quot;hard2&quot;).setChecked(true)
-		
-		addHandler(@layout.getChild(&quot;terrain&quot;),:sigClick,:eventTabSelect)
-		addHandler(@layout.getChild(&quot;entities&quot;),:sigClick,:eventTabSelect)
-		
-		addHandler(@layout.getChild(&quot;new&quot;),:sigClick,:eventNewMap)
-		@buttonlayout=@layout
-		@modifiers={}
-		@modifiers[&quot;terrain&quot;]=&quot;editHeight&quot;
-		@modifiers[&quot;entities&quot;]=&quot;addEntity&quot;
-		@type=AntHero
-		@layout.getChild(&quot;editHeight&quot;).setChecked(true)
-		@layout.getChild(&quot;entitiesTab&quot;).entType=AntHero
-		setTab(&quot;terrain&quot;)
-		puts &quot;EditView inizalizing ready.&quot;
-	end
-	
-	def eventNewMap
-		if not @newDialog
-			@layout.addChild(@newDialog=AGLayout.new(@layout))
-			@newDialog.loadXML(loadFile(&quot;data/gui/layout/newdialog.xml&quot;))
-			addHandler(@newDialog.getChild(&quot;ok&quot;),:sigClick,:eventNewMapEnd)
-			addHandler(@newDialog.getChild(&quot;cancel&quot;),:sigClick,:eventNewMapEnd)
-			addHandler(@newDialog.getChild(&quot;window&quot;),:sigClose,:eventNewMapEnd)
-		end
-		GC.start
-		return true
-	end
-	
-	def eventNewMapEnd(e)
-		name=e.getCaller.getName
-		d=@newDialog
-		@newDialog=nil
-		if d
-			@layout.removeChild(d)
-			#d.close
-			if name==&quot;ok&quot;
-				w=d.getChild(&quot;width&quot;).getText.to_s.to_i
-				h=d.getChild(&quot;height&quot;).getText.to_s.to_i
-				
-				if w and h
-					w=2**(Math::log(w)/Math::log(2)).to_i
-					h=2**(Math::log(h)/Math::log(2)).to_i
-					if w&gt;=16 and h&gt;=16
-						getMap.newMap(w,h)
-						getMap.setHeight(-0.5)
-					end
-				end
-			end
-			@map.mapChanged
-		end
-		return true
-	end
-	
-	def setTab(name)
-		[&quot;terrain&quot;,&quot;entities&quot;].each{|e|
-			if e==name
-				w=@buttonlayout.getChild(e+&quot;Tab&quot;)
-				if w
-					w.show
-				end
-				w=@buttonlayout.getChild(e)
-				w.setChecked(true)
-			else
-				w=@buttonlayout.getChild(e+&quot;Tab&quot;)
-				if w
-					w.hide
-				end
-				w=@buttonlayout.getChild(e)
-				w.setChecked(false)
-			end
-		}
-		@modifier=@modifiers[name]
-	end
-	
-	def eventTabSelect(e)
-		setTab(e.getCaller.getName)
-		return true
-	end
-		
-	def eventClick(list,button)
-		puts &quot;eventClick&quot;
-		puts &quot;------------------&quot;
-		puts &quot;list-size:&quot;+(list.length.to_s)
-		if list.length&gt;0
-			if @modifier
-				puts @modifier
-				send(@modifier,list,button)
-			end
-		end
-		puts &quot;back from eventClick&quot;
-		#super(list)
-		return true
-	end
-	def editHeight(list,button)
-	
-		diff={1=&gt;0.5, 2=&gt;1, 3=&gt;1.5}[@hard]
-	
-		list.each{|c|
-			if isTerrain(c.node)
-				puts &quot;TERRAIN:&quot;
-				puts c.node
-				puts @terrain
-				x=c.pos.x.to_i
-				y=c.pos.y.to_i
-				middle=@map.get(x,y)
-				if button==1
-					middle+=diff
-				elsif button==3 #right
-					middle-=diff
-				end
-				for dx in (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x- at size</A>)..(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at size</A>)
-					for dy in (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">y- at size</A>)..(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">y+ at size</A>)
-						if dx&gt;=0 and dx&lt;=@map.getW and dy&gt;=0 and dy&lt;=@map.getH
-							d=Math::sqrt((dx-x)**2+(dy-y)**2)
-							v=1-(d/(@size))
-							v=[1,[0,v].max].min
-							ov=@map.get(dx,dy)
-							cv=middle*v+ov*(1-v)
-							@map.set(dx,dy,cv)
-						end
-					end
-				end
-				puts &quot;MAP CHANGED...&quot;
-				@map.mapChanged
-				puts &quot;MAP CHANGED!&quot;
-			end
-		}
-	end
-	
-	def editGrass(list,button)
-		list.each{|c|
-			if isTerrain(c.node)
-				puts &quot;TERRAIN:&quot;
-				puts c.node
-				puts @terrain
-				x=c.pos.x.to_i
-				y=c.pos.y.to_i
-				middle=@map.getGrass(x,y)
-				if button==1
-					middle+=0.1
-				elsif button==3 #right
-					middle-=0.1
-				end
-				for dx in (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x- at size</A>)..(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at size</A>)
-					for dy in (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">y- at size</A>)..(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">y+ at size</A>)
-						if dx&gt;=0 and dx&lt;=@map.getW and dy&gt;=0 and dy&lt;=@map.getH
-							d=Math::sqrt((dx-x)**2+(dy-y)**2)
-							v=1-(d/(@size))
-							v=[[0,v].max,1].min
-							ov=@map.getGrass(dx,dy)
-							cv=middle*v+ov*(1-v)
-							@map.setGrass(dx,dy,cv)
-						end
-					end
-				end
-				@map.mapChanged
-			end
-		}
-	end
-	def editTerrain(list,button)
-		tt={&quot;editWater&quot;=&gt;WATER,&quot;editSand&quot;=&gt;SAND,&quot;editGround&quot;=&gt;EARTH,&quot;editGrass&quot;=&gt;GRASS,&quot;editGrass2&quot;=&gt;GRASS2,&quot;editForest&quot;=&gt;FOREST,&quot;editRock&quot;=&gt;ROCK}[@terrainType]
-		h={1=&gt;0.3,2=&gt;0.6,3=&gt;1}[@hard]
-		list.each{|c|
-			if isTerrain(c.node)
-				x=c.pos.x.to_i
-				y=c.pos.y.to_i
-				for dx in (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x- at size</A>)..(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at size</A>)
-					for dy in (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">y- at size</A>)..(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">y+ at size</A>)
-						if dx&gt;=0 and dx&lt;=@map.getW and dy&gt;=0 and dy&lt;=@map.getH
-							d=Math::sqrt((dx-x)**2+(dy-y)**2)
-							v=1-(d/(@size))
-							puts v,v.class
-							v=[[0,v].max,1].min
-							dputs dx,dx.class,dy,dy.class,tt,tt.class
-							ov=@map.getTerrain(dx,dy,tt)
-							cv=[ov+v*h,1].min
-							@map.setTerrain(dx,dy,tt,cv)
-							printf &quot;EDIT:%d,%d,%d,%f\n&quot;,dx,dy,tt,cv
-						end
-					end
-				end
-				@map.mapChanged
-			end
-		}
-	end
-	
-	def eventSelectEdit(e)
-		name=e.getCaller.getName
-		if name==&quot;editHeight&quot;
-			@modifier=e.getCaller.getName
-		else
-			@modifier=&quot;editTerrain&quot;
-			@terrainType=e.getCaller.getName
-		end
-		@modifiers[&quot;terrain&quot;]=@modifier
-		return true
-	end
-	
-	def eventSize(e)
-		@size=e.getCaller.getName[4..10].to_i
-		return true
-	end
-	def eventHard(e)
-		@hard=e.getCaller.getName[4..10].to_i
-		return true
-	end
-	
-	def eventPointer
-		@modifier=&quot;edit&quot;
-		#@layout.getChild(&quot;entitiesTab&quot;).deselect
-		return true
-	end
-	
-	def eventRubber
-		@modifier=&quot;doRubber&quot;
-		#@layout.getChild(&quot;entitiesTab&quot;).deselect
-		return true
-	end
+    addHandler(@layout.getChild(&quot;pointer&quot;),:sigClick,:eventPointer)
+    
+    [1,2,3,5,10,15].each{|s|addHandler(@layout.getChild(&quot;edit#{s}&quot;),:sigClick,:eventSize)}
+    [&quot;editHeight&quot;,&quot;editWater&quot;,&quot;editSand&quot;,&quot;editGround&quot;,&quot;editGrass&quot;,&quot;editGrass2&quot;,&quot;editForest&quot;,&quot;editRock&quot;].each{|n|
+      addHandler(@layout.getChild(n),:sigClick,:eventSelectEdit)
+    }
+    [1,2,3].each{|h|addHandler(@layout.getChild(&quot;hard#{h}&quot;),:sigClick,:eventHard)}
+    
+    @hard=2
+    @layout.getChild(&quot;hard2&quot;).setChecked(true)
+    
+    addHandler(@layout.getChild(&quot;terrain&quot;),:sigClick,:eventTabSelect)
+    addHandler(@layout.getChild(&quot;entities&quot;),:sigClick,:eventTabSelect)
+    
+    addHandler(@layout.getChild(&quot;new&quot;),:sigClick,:eventNewMap)
+    @buttonlayout=@layout
+    @modifiers={}
+    @modifiers[&quot;terrain&quot;]=&quot;editHeight&quot;
+    @modifiers[&quot;entities&quot;]=&quot;addEntity&quot;
+    @type=AntHero
+    @layout.getChild(&quot;editHeight&quot;).setChecked(true)
+    @layout.getChild(&quot;entitiesTab&quot;).entType=AntHero
+    setTab(&quot;terrain&quot;)
+    puts &quot;EditView inizalizing ready.&quot;
+  end
+  
+  def eventNewMap
+    if not @newDialog
+      @layout.addChild(@newDialog=AGLayout.new(@layout))
+      @newDialog.loadXML(loadFile(&quot;data/gui/layout/newdialog.xml&quot;))
+      addHandler(@newDialog.getChild(&quot;ok&quot;),:sigClick,:eventNewMapEnd)
+      addHandler(@newDialog.getChild(&quot;cancel&quot;),:sigClick,:eventNewMapEnd)
+      addHandler(@newDialog.getChild(&quot;window&quot;),:sigClose,:eventNewMapEnd)
+    end
+    GC.start
+    return true
+  end
+  
+  def eventNewMapEnd(e)
+    name=e.getCaller.getName
+    d=@newDialog
+    @newDialog=nil
+    if d
+      @layout.removeChild(d)
+      #d.close
+      if name==&quot;ok&quot;
+        w=d.getChild(&quot;width&quot;).getText.to_s.to_i
+        h=d.getChild(&quot;height&quot;).getText.to_s.to_i
+        
+        if w and h
+          w=2**(Math::log(w)/Math::log(2)).to_i
+          h=2**(Math::log(h)/Math::log(2)).to_i
+          if w&gt;=16 and h&gt;=16
+            getMap.newMap(w,h)
+            getMap.setHeight(-0.5)
+          end
+        end
+      end
+      @map.mapChanged
+    end
+    return true
+  end
+  
+  def setTab(name)
+    [&quot;terrain&quot;,&quot;entities&quot;].each{|e|
+      if e==name
+        w=@buttonlayout.getChild(e+&quot;Tab&quot;)
+        if w
+          w.show
+        end
+        w=@buttonlayout.getChild(e)
+        w.setChecked(true)
+      else
+        w=@buttonlayout.getChild(e+&quot;Tab&quot;)
+        if w
+          w.hide
+        end
+        w=@buttonlayout.getChild(e)
+        w.setChecked(false)
+      end
+    }
+    @modifier=@modifiers[name]
+  end
+  
+  def eventTabSelect(e)
+    setTab(e.getCaller.getName)
+    return true
+  end
+    
+  def eventClick(list,button)
+    puts &quot;eventClick&quot;
+    puts &quot;------------------&quot;
+    puts &quot;list-size:&quot;+(list.length.to_s)
+    if list.length&gt;0
+      if @modifier
+        puts @modifier
+        send(@modifier,list,button)
+      end
+    end
+    puts &quot;back from eventClick&quot;
+    #super(list)
+    return true
+  end
+  def editHeight(list,button)
+  
+    diff={1=&gt;0.5, 2=&gt;1, 3=&gt;1.5}[@hard]
+  
+    list.each{|c|
+      if isTerrain(c.node)
+        puts &quot;TERRAIN:&quot;
+        puts c.node
+        puts @terrain
+        x=c.pos.x.to_i
+        y=c.pos.y.to_i
+        middle=@map.get(x,y)
+        if button==1
+          middle+=diff
+        elsif button==3 #right
+          middle-=diff
+        end
+        for dx in (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x- at size</A>)..(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at size</A>)
+          for dy in (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">y- at size</A>)..(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">y+ at size</A>)
+            if dx&gt;=0 and dx&lt;=@map.getW and dy&gt;=0 and dy&lt;=@map.getH
+              d=Math::sqrt((dx-x)**2+(dy-y)**2)
+              v=1-(d/(@size))
+              v=[1,[0,v].max].min
+              ov=@map.get(dx,dy)
+              cv=middle*v+ov*(1-v)
+              @map.set(dx,dy,cv)
+            end
+          end
+        end
+        puts &quot;MAP CHANGED...&quot;
+        @map.mapChanged
+        puts &quot;MAP CHANGED!&quot;
+      end
+    }
+  end
+  
+  def editGrass(list,button)
+    list.each{|c|
+      if isTerrain(c.node)
+        puts &quot;TERRAIN:&quot;
+        puts c.node
+        puts @terrain
+        x=c.pos.x.to_i
+        y=c.pos.y.to_i
+        middle=@map.getGrass(x,y)
+        if button==1
+          middle+=0.1
+        elsif button==3 #right
+          middle-=0.1
+        end
+        for dx in (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x- at size</A>)..(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at size</A>)
+          for dy in (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">y- at size</A>)..(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">y+ at size</A>)
+            if dx&gt;=0 and dx&lt;=@map.getW and dy&gt;=0 and dy&lt;=@map.getH
+              d=Math::sqrt((dx-x)**2+(dy-y)**2)
+              v=1-(d/(@size))
+              v=[[0,v].max,1].min
+              ov=@map.getGrass(dx,dy)
+              cv=middle*v+ov*(1-v)
+              @map.setGrass(dx,dy,cv)
+            end
+          end
+        end
+        @map.mapChanged
+      end
+    }
+  end
+  def editTerrain(list,button)
+    tt={&quot;editWater&quot;=&gt;WATER,&quot;editSand&quot;=&gt;SAND,&quot;editGround&quot;=&gt;EARTH,&quot;editGrass&quot;=&gt;GRASS,&quot;editGrass2&quot;=&gt;GRASS2,&quot;editForest&quot;=&gt;FOREST,&quot;editRock&quot;=&gt;ROCK}[@terrainType]
+    h={1=&gt;0.3,2=&gt;0.6,3=&gt;1}[@hard]
+    list.each{|c|
+      if isTerrain(c.node)
+        x=c.pos.x.to_i
+        y=c.pos.y.to_i
+        for dx in (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x- at size</A>)..(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at size</A>)
+          for dy in (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">y- at size</A>)..(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">y+ at size</A>)
+            if dx&gt;=0 and dx&lt;=@map.getW and dy&gt;=0 and dy&lt;=@map.getH
+              d=Math::sqrt((dx-x)**2+(dy-y)**2)
+              v=1-(d/(@size))
+              puts v,v.class
+              v=[[0,v].max,1].min
+              dputs dx,dx.class,dy,dy.class,tt,tt.class
+              ov=@map.getTerrain(dx,dy,tt)
+              cv=[ov+v*h,1].min
+              @map.setTerrain(dx,dy,tt,cv)
+              printf &quot;EDIT:%d,%d,%d,%f\n&quot;,dx,dy,tt,cv
+            end
+          end
+        end
+        @map.mapChanged
+      end
+    }
+  end
+  
+  def eventSelectEdit(e)
+    name=e.getCaller.getName
+    if name==&quot;editHeight&quot;
+      @modifier=e.getCaller.getName
+    else
+      @modifier=&quot;editTerrain&quot;
+      @terrainType=e.getCaller.getName
+    end
+    @modifiers[&quot;terrain&quot;]=@modifier
+    return true
+  end
+  
+  def eventSize(e)
+    @size=e.getCaller.getName[4..10].to_i
+    return true
+  end
+  def eventHard(e)
+    @hard=e.getCaller.getName[4..10].to_i
+    return true
+  end
+  
+  def eventPointer
+    @modifier=&quot;edit&quot;
+    #@layout.getChild(&quot;entitiesTab&quot;).deselect
+    return true
+  end
+  
+  def eventRubber
+    @modifier=&quot;doRubber&quot;
+    #@layout.getChild(&quot;entitiesTab&quot;).deselect
+    return true
+  end
 
-	def eventEntitySelected(e)
-		c=@layout.getChild(&quot;entitiesTab&quot;).entType
-		if not c.nil?
-			@modifier=&quot;addEntity&quot;
-			@type=c
-			@layout.getChild(&quot;rubber&quot;).setChecked(false)
-			@layout.getChild(&quot;pointer&quot;).setChecked(false)
-		end
-		return true
-	end
-	
-	
-	def isTerrain(node)
-	  # Terrain is for testign purpose only
-	  [TerrainPiece,WaterPiece,Terrain].member?(node.class)
-	end
-	
-	def addEntity(list,button)
-		pos=nil
-		list.each{|c|
-		  puts &quot;LIST #{c} #{c.node}&quot;
-			if isTerrain(c.node)
-				pos=c.pos
-			end
-		}
-		if not pos
-			return
-		end
-		puts &quot;ADDENTITY&quot;
+  def eventEntitySelected(e)
+    c=@layout.getChild(&quot;entitiesTab&quot;).entType
+    if not c.nil?
+      @modifier=&quot;addEntity&quot;
+      @type=c
+      @layout.getChild(&quot;rubber&quot;).setChecked(false)
+      @layout.getChild(&quot;pointer&quot;).setChecked(false)
+    end
+    return true
+  end
+  
+  
+  def isTerrain(node)
+    # Terrain is for testign purpose only
+    [TerrainPiece,WaterPiece,Terrain].member?(node.class)
+  end
+  
+  def addEntity(list,button)
+    pos=nil
+    list.each{|c|
+      puts &quot;LIST #{c} #{c.node}&quot;
+      if isTerrain(c.node)
+        pos=c.pos
+      end
+    }
+    if not pos
+      return
+    end
+    puts &quot;ADDENTITY&quot;
     entity=nil
-		dorand=true
-		if @type==AntDeco
-			entity=@type.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">map, at decoType</A>)
-			if @decoType==&quot;floor&quot; or @decoType==&quot;block&quot;
-				dorand=false
-			end
-		elsif @type==AntHero
-			entity=@type.new(@map)
-			entity.setAppearance(@appearance)
-		else
-			entity=@type.new(@map)
-		end
+    dorand=true
+    if @type==AntDeco
+      entity=@type.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">map, at decoType</A>)
+      if @decoType==&quot;floor&quot; or @decoType==&quot;block&quot;
+        dorand=false
+      end
+    elsif @type==AntHero
+      entity=@type.new(@map)
+      entity.setAppearance(@appearance)
+    else
+      entity=@type.new(@map)
+    end
     puts &quot;SETPOS #{pos.x} #{pos.y}&quot;
-		entity.setPos(AGVector2.new(pos.x,pos.y))
-		getMap.insertEntity(entity)
-	end
+    entity.setPos(AGVector2.new(pos.x,pos.y))
+    getMap.insertEntity(entity)
+  end
 
-	def setupNames
-	end
-	
-	def edit(meshes,button)
-		meshes.each{|res|
-			node=res.node
-			puts &quot;NODE:&quot;
-			puts node
-			if node.is_a?(MeshBase)
-				ent=getMap.getEntity(node)
-				if ent
-					editProperties(ent)
-				end
-			end
-		}
-	end
-	
-	def getMarkerPos
-		if @markerPos
-			return @markerPos
-		else
-			return super()
-		end
-	end
-	
-	def editProperties(ent)
-		d=AntEditPropDialog.new($<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">screen,ent, at map</A>)
-		$screen.addChild(d)
-	end
-	
-	def doRubber(list,button)
-		puts &quot;DOING RUBBER&quot;
-		list.each{|res|
-			mesh=res.node
-			if mesh.is_a?(MeshBase)
-				ent=getMap.getEntity(mesh)
-				if ent
-					getMap.removeEntity(ent)
-				else
-					puts &quot;NOT FOUND!&quot;
-				end
-				break
-			end
-		}
-		getMap.move(0)
-	end
-	
-	def eventAllWater
-		getMap.setHeight(-0.5)
-		return true
-	end
-	def eventAllGrass
-		getMap.setHeight(1.0)
-		return true
-	end
-	def hidePanel
-		@mainWidget.hide
-	end	
-	def showPanel
-		@mainWidget.show
-	end	
-	
+  def setupNames
+  end
+  
+  def edit(meshes,button)
+    meshes.each{|res|
+      node=res.node
+      puts &quot;NODE:&quot;
+      puts node
+      if node.is_a?(MeshBase)
+        ent=getMap.getEntity(node)
+        if ent
+          editProperties(ent)
+        end
+      end
+    }
+  end
+  
+  def getMarkerPos
+    if @markerPos
+      return @markerPos
+    else
+      return super()
+    end
+  end
+  
+  def editProperties(ent)
+    d=AntEditPropDialog.new($<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">screen,ent, at map</A>)
+    $screen.addChild(d)
+  end
+  
+  def doRubber(list,button)
+    puts &quot;DOING RUBBER&quot;
+    list.each{|res|
+      mesh=res.node
+      if mesh.is_a?(MeshBase)
+        ent=getMap.getEntity(mesh)
+        if ent
+          getMap.removeEntity(ent)
+        else
+          puts &quot;NOT FOUND!&quot;
+        end
+        break
+      end
+    }
+    getMap.move(0)
+  end
+  
+  def eventAllWater
+    getMap.setHeight(-0.5)
+    return true
+  end
+  def eventAllGrass
+    getMap.setHeight(1.0)
+    return true
+  end
+  def hidePanel
+    @mainWidget.hide
+  end  
+  def showPanel
+    @mainWidget.show
+  end  
+  
 end
 

Modified: antargis/trunk/ruby/entities/ant_animal.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_animal.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_animal.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,35 +1,35 @@
 # some very simple base-class for animals. contains really nothing.
 class AntAnimal&lt;AntRubyEntity
-	def initialize(map)
-		super
-	end
-	def AntAnimal.xmlName
-		&quot;&quot;
-	end
+  def initialize(map)
+    super
+  end
+  def AntAnimal.xmlName
+    &quot;&quot;
+  end
 protected
-	# give Birth every 40th call
-	# returns true, if birth given
-	# at most 50 entities of a special type will be created
-	def giveBirth
-		@lastBirth||=getRand*40
+  # give Birth every 40th call
+  # returns true, if birth given
+  # at most 50 entities of a special type will be created
+  def giveBirth
+    @lastBirth||=getRand*40
 
-		@lastBirth+=1
-		# BIRTHRATE is here:
-		if @lastBirth&gt;40 then
-			fishList=getMap.getAllByType(self.class)
-			return if fishList.length&gt;50
-			# make child
-			#puts &quot;A FISH IS BORN&quot;
-			fish=self.class.new(getMap)
-			fish.setPos(getPos2D)
-			getMap.insertEntity(fish)
-			getMap.endChange
-			newRestJob(2)
-			@lastBirth=-getRand()*10
-			puts &quot;GIVE BIRTH&quot;
-			return true
-		end
-		false
-	end
+    @lastBirth+=1
+    # BIRTHRATE is here:
+    if @lastBirth&gt;40 then
+      fishList=getMap.getAllByType(self.class)
+      return if fishList.length&gt;50
+      # make child
+      #puts &quot;A FISH IS BORN&quot;
+      fish=self.class.new(getMap)
+      fish.setPos(getPos2D)
+      getMap.insertEntity(fish)
+      getMap.endChange
+      newRestJob(2)
+      @lastBirth=-getRand()*10
+      puts &quot;GIVE BIRTH&quot;
+      return true
+    end
+    false
+  end
 end
 

Modified: antargis/trunk/ruby/entities/ant_arrow.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_arrow.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_arrow.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -23,14 +23,14 @@
 # FIXME: Maybe this should be moved to plain C++ in a kind of ParticleSystem with meshes.
 
 class AntArrow&lt;AntRubyEntity
-	def initialize(map)
-		super(map)
-		@typeID=(getRand*2).to_i
-		setMesh
-		setSpeed(10)
-	end
-	def eventNoJob
-		getMap.removeEntity(self)
-	end
+  def initialize(map)
+    super(map)
+    @typeID=(getRand*2).to_i
+    setMesh
+    setSpeed(10)
+  end
+  def eventNoJob
+    getMap.removeEntity(self)
+  end
 end
 

Modified: antargis/trunk/ruby/entities/ant_bakery.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_bakery.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_bakery.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,55 +1,55 @@
 #FIXME
 
 class AntBakery&lt;AntHouse
-	def initialize(map)
-		super
-		@type=3
-		setProvide(&quot;food&quot;,true)
-		@defeated=[]
-		@atHome=[]
-		@lastBirth=0
-		@smoke=0
-		setDirection(-30)
-	end
-	
-	def setupMesh
-		return if getScene.nil?
-		setMesh
-		p=AGVector3.new(0,1.6,2.2)
-		addMesh(@smokeMesh=AntParticle.new(getMap.getScene,5),p)
-		checkSmoke
-	end
+  def initialize(map)
+    super
+    @type=3
+    setProvide(&quot;food&quot;,true)
+    @defeated=[]
+    @atHome=[]
+    @lastBirth=0
+    @smoke=0
+    setDirection(-30)
+  end
+  
+  def setupMesh
+    return if getScene.nil?
+    setMesh
+    p=AGVector3.new(0,1.6,2.2)
+    addMesh(@smokeMesh=AntParticle.new(getMap.getScene,5),p)
+    checkSmoke
+  end
 
-	def neededStock
-		{&quot;food&quot;=&gt;15,&quot;flour&quot;=&gt;15}
-	end
+  def neededStock
+    {&quot;food&quot;=&gt;15,&quot;flour&quot;=&gt;15}
+  end
 
-	def process
-		if resource.get(&quot;flour&quot;)&gt;0 and resource.get(&quot;food&quot;)&lt;60
-			amount=[resource.get(&quot;flour&quot;),1].min
-			resource.sub(&quot;flour&quot;,amount)
-			resource.add(&quot;food&quot;,amount*2)
-			@smoke=1
-			checkSmoke
-		else
-			@smoke=0
-			checkSmoke
-		end
-	end
-	def houseType
-		&quot;bakery&quot;
-	end
+  def process
+    if resource.get(&quot;flour&quot;)&gt;0 and resource.get(&quot;food&quot;)&lt;60
+      amount=[resource.get(&quot;flour&quot;),1].min
+      resource.sub(&quot;flour&quot;,amount)
+      resource.add(&quot;food&quot;,amount*2)
+      @smoke=1
+      checkSmoke
+    else
+      @smoke=0
+      checkSmoke
+    end
+  end
+  def houseType
+    &quot;bakery&quot;
+  end
 private
-	# checks if smoke should be displayed
-	def checkSmoke
-		return if getScene.nil?
-		if @smokeMesh
-			if @smoke
-				@smokeMesh.setEnabled((@smoke&gt;0))
-			else
-				@smokeMesh.setEnabled(false)
-			end
-		end
-	end
+  # checks if smoke should be displayed
+  def checkSmoke
+    return if getScene.nil?
+    if @smokeMesh
+      if @smoke
+        @smokeMesh.setEnabled((@smoke&gt;0))
+      else
+        @smokeMesh.setEnabled(false)
+      end
+    end
+  end
 
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_boat.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_boat.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_boat.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,15 +1,15 @@
 def getBoatMeshData
-	getMeshData(&quot;data/models/boat_simple.ant2&quot;,0.12,&quot;data/textures/models/boat_simple.png&quot;)
+  getMeshData(&quot;data/models/boat_simple.ant2&quot;,0.12,&quot;data/textures/models/boat_simple.png&quot;)
 end
 
 # A boat lying around - for rowing this is not used!
 class AntBoat&lt;AntRubyEntity
-	def initialize(map)
-		super
-		setupMesh
-	end
+  def initialize(map)
+    super
+    setupMesh
+  end
 private
-	def setupMesh
-		setMesh
-	end
+  def setupMesh
+    setMesh
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_boss.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_boss.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_boss.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -24,303 +24,303 @@
 
 
 class AntBoss&lt;AntRubyEntity
-	attr_accessor :formation
+  attr_accessor :formation
 
-	attr_accessor :hlJobMode
+  attr_accessor :hlJobMode
 
-	def initialize(map)
-		super(map)
-		@men=[]
-		@hlJobMode={}
-		@job=nil
-		@createMen=0
-		@selected=@hovered=false
-		@formation=nil
-		setProvide(&quot;boss&quot;,true)
-		setupMeshBoss
-		setAggression(3)
-	end
-	def loadXML(node)
-		super(node)
-		if node.get(&quot;men&quot;)!=&quot;&quot; then
-			if node.get(&quot;men&quot;)!=&quot;&quot;
-				@createMen=node.get(&quot;men&quot;).to_i
-			end
-		end
+  def initialize(map)
+    super(map)
+    @men=[]
+    @hlJobMode={}
+    @job=nil
+    @createMen=0
+    @selected=@hovered=false
+    @formation=nil
+    setProvide(&quot;boss&quot;,true)
+    setupMeshBoss
+    setAggression(3)
+  end
+  def loadXML(node)
+    super(node)
+    if node.get(&quot;men&quot;)!=&quot;&quot; then
+      if node.get(&quot;men&quot;)!=&quot;&quot;
+        @createMen=node.get(&quot;men&quot;).to_i
+      end
+    end
     node.getChildren(&quot;hljob&quot;).each{|hlnode|
       @job=XMLLoader.loadXML(self,hlnode)
     }
     
     if false
-		node.getChildren(&quot;hljob&quot;).each{|n|
-			t=n.get(&quot;type&quot;)
-			case t
-				when &quot;AntHeroMoveJob&quot;
-					@job=AntHeroMoveJob.new(self,0,AGVector2.new(0,0),0)
-				when &quot;AntHeroRestJob&quot;
-					@job=AntHeroRestJob.new(self,10)
-				when &quot;AntHeroRecruitJob&quot;
-					target=n.getChildren.select{|c|c.get(&quot;name&quot;)==&quot;@target&quot;}[0]
-					if target
-						target=getMap.getByUID(target.get(&quot;value&quot;))
-					
-						@job=AntHeroRecruitJob.new(self,target)
-					else
-						raise &quot;target missing in saved AntHeroRecruitJob&quot;
-					end
-				else
-					# FIXME!!!
-					raise &quot;unknown job: #{t}&quot;
-			end
-			@job.loadXML(n)
-		}
+    node.getChildren(&quot;hljob&quot;).each{|n|
+      t=n.get(&quot;type&quot;)
+      case t
+        when &quot;AntHeroMoveJob&quot;
+          @job=AntHeroMoveJob.new(self,0,AGVector2.new(0,0),0)
+        when &quot;AntHeroRestJob&quot;
+          @job=AntHeroRestJob.new(self,10)
+        when &quot;AntHeroRecruitJob&quot;
+          target=n.getChildren.select{|c|c.get(&quot;name&quot;)==&quot;@target&quot;}[0]
+          if target
+            target=getMap.getByUID(target.get(&quot;value&quot;))
+          
+            @job=AntHeroRecruitJob.new(self,target)
+          else
+            raise &quot;target missing in saved AntHeroRecruitJob&quot;
+          end
+        else
+          # FIXME!!!
+          raise &quot;unknown job: #{t}&quot;
+      end
+      @job.loadXML(n)
+    }
     end
-		setAggression(getAggression) # update aggression of men
-	end
+    setAggression(getAggression) # update aggression of men
+  end
 # for recruiting
-	def takeMan
-		men=@men.select{|m|not m.is_a?(AntBoss)}
-		if men.length==0
-			return nil
-		end
-		m=men[-1]
-		removeMan(m)
-		return m
-	end
-		
-	def getJob
-		@job
-	end
-	
-	def hasHLJob
-		@job and (not @job.is_a?(AntHeroRestJob))
-	end
-	
-	def menCount
-		@men=@men.uniq
-		return @men.length
-	end
-	
-	def eventNoJob
-		checkHLJobEnd(self)
- 		checkCreateMen
-	end
+  def takeMan
+    men=@men.select{|m|not m.is_a?(AntBoss)}
+    if men.length==0
+      return nil
+    end
+    m=men[-1]
+    removeMan(m)
+    return m
+  end
+    
+  def getJob
+    @job
+  end
+  
+  def hasHLJob
+    @job and (not @job.is_a?(AntHeroRestJob))
+  end
+  
+  def menCount
+    @men=@men.uniq
+    return @men.length
+  end
+  
+  def eventNoJob
+    checkHLJobEnd(self)
+     checkCreateMen
+  end
 
-	def checkCreateMen
-		if @createMen&gt;0
-			for i in 0..(@createMen-1) do
-				man=AntMan.new(getMap)
-				getMap.insertEntity(man)
-				man.setPos(getPos2D)
-				man.setBoss(self)
-			end
-			#getMap.endChange
-			@createMen=0
-		end
-	end
-	
-	def gotNewJob()
-	end
-	
-	def newHLDefendJob(target)
-		puts &quot;DEFEND!!! #{self.getName} from #{target.getName}&quot;
-		if @job
-			if @job.is_a?(AntHeroFightJob)
-				puts &quot;I'm alread fighting!&quot;
-				return false # already fighting
-			end
-		end
-		@job=AntHeroFightJob.new(self,target,true) # FIXME: change this, so that fighting is stopped as soon as other stops
-		assignJob2All
-		return true
-	end
-	def newHLRestJob(time)
-		@job=AntHeroRestJob.new(self,time)
-	end
-	
-	def getMen
-		@men.clone
-	end
-	
-	def signUp(man)
-		if not @men.member?(man) then	
-			@men.push(man)
-			man.setAggression(getAggression)
+  def checkCreateMen
+    if @createMen&gt;0
+      for i in 0..(@createMen-1) do
+        man=AntMan.new(getMap)
+        getMap.insertEntity(man)
+        man.setPos(getPos2D)
+        man.setBoss(self)
+      end
+      #getMap.endChange
+      @createMen=0
+    end
+  end
+  
+  def gotNewJob()
+  end
+  
+  def newHLDefendJob(target)
+    puts &quot;DEFEND!!! #{self.getName} from #{target.getName}&quot;
+    if @job
+      if @job.is_a?(AntHeroFightJob)
+        puts &quot;I'm alread fighting!&quot;
+        return false # already fighting
+      end
+    end
+    @job=AntHeroFightJob.new(self,target,true) # FIXME: change this, so that fighting is stopped as soon as other stops
+    assignJob2All
+    return true
+  end
+  def newHLRestJob(time)
+    @job=AntHeroRestJob.new(self,time)
+  end
+  
+  def getMen
+    @men.clone
+  end
+  
+  def signUp(man)
+    if not @men.member?(man) then  
+      @men.push(man)
+      man.setAggression(getAggression)
       # FIXME: is this to be moved somewhere else ???
-#			if @job.is_a?(AntHeroRestJob)
-#				newHLRestJob(1)
-#			elsif @job
-#				@job.check(man)
-#			end
-		end
-		resourceChanged
-	end
-	
-	def removeMan(man)
-		@men.delete(man)
-		if @job
-			@job.delete(man)
-		end
-		resourceChanged
-		#raise 1
-	end
-	
-	def setPlayer(player)
-		if @player
-			@player.remove(self)
-		end
-		@player=player
-		if @player
-			@player.add(self)
-		end
-	end
-	def getPlayer
-		@player
-	end
-	
-# 	def eventGotHLFight(hero)
-# 		newHLDefendJob(hero)
-# 		return
-# 	end
+#      if @job.is_a?(AntHeroRestJob)
+#        newHLRestJob(1)
+#      elsif @job
+#        @job.check(man)
+#      end
+    end
+    resourceChanged
+  end
+  
+  def removeMan(man)
+    @men.delete(man)
+    if @job
+      @job.delete(man)
+    end
+    resourceChanged
+    #raise 1
+  end
+  
+  def setPlayer(player)
+    if @player
+      @player.remove(self)
+    end
+    @player=player
+    if @player
+      @player.add(self)
+    end
+  end
+  def getPlayer
+    @player
+  end
+  
+#   def eventGotHLFight(hero)
+#     newHLDefendJob(hero)
+#     return
+#   end
 
-	def eventAttacked(by)
-		ret=newHLDefendJob(by)
-		AntInventory.update(self)
-		ret
-	end
-	
-	def eventManDefeated(man)
-		dputs &quot;AntBoss:eventManDefeated: #{man} #{man.getName}&quot;
-		if @job and @job.class==AntHeroFightJob
-			@job.defeated(man)
-		end
-	end
+  def eventAttacked(by)
+    ret=newHLDefendJob(by)
+    AntInventory.update(self)
+    ret
+  end
+  
+  def eventManDefeated(man)
+    dputs &quot;AntBoss:eventManDefeated: #{man} #{man.getName}&quot;
+    if @job and @job.class==AntHeroFightJob
+      @job.defeated(man)
+    end
+  end
 
-	def getBossEnergy
-		if @job and @job.class==AntHeroFightJob
-			return @job.getEnergy
-		else
-			e=0
-			@men.each{|m|e+=m.getMorale}
-			return e*0.1
-		end
-	end
+  def getBossEnergy
+    if @job and @job.class==AntHeroFightJob
+      return @job.getEnergy
+    else
+      e=0
+      @men.each{|m|e+=m.getMorale}
+      return e*0.1
+    end
+  end
 
-	def underAttack
-		(@job.is_a?(AntHeroFightJob) and (not @job.finished))
-	end
+  def underAttack
+    (@job.is_a?(AntHeroFightJob) and (not @job.finished))
+  end
 
 
-	def setOwner(owner)
-		@owner=owner
-		if @player
-			@player.remove(self)
-		end
-		@player=owner.getPlayer
-		if @player
-			@player.add(self)
-		end
-		getMap.eventOwnerChanged(self)
-		AntInventory.update(self)
-	end
-	def getOwner
-		@owner
-	end
-	
-	def assignJob2All
-	  assert{@job}
+  def setOwner(owner)
+    @owner=owner
+    if @player
+      @player.remove(self)
+    end
+    @player=owner.getPlayer
+    if @player
+      @player.add(self)
+    end
+    getMap.eventOwnerChanged(self)
+    AntInventory.update(self)
+  end
+  def getOwner
+    @owner
+  end
+  
+  def assignJob2All
+    assert{@job}
     @job.firstCall
-		if getMap
-			getMap.eventNewJobAssignedToBoss(self) if getMap.respond_to?(:eventNewJobAssignedToBoss)
-		end
+    if getMap
+      getMap.eventNewJobAssignedToBoss(self) if getMap.respond_to?(:eventNewJobAssignedToBoss)
+    end
 
-		begin
-		# discard reassigning in this case
-		return if ObjectSpace.const_get(:AntNewHLJob)
-		rescue
-		end
+    begin
+    # discard reassigning in this case
+    return if ObjectSpace.const_get(:AntNewHLJob)
+    rescue
+    end
 
-		@men.each{|man|
-			man.delJob
-			assignJob(man)
-		}
-	end
-	def killAllJobs
-		@men.each{|man|man.delJob}
-	end
-	
-	
-	# ring mesh
-	def setupMesh
-	end
-	
-	
-	def getRing
-		makeBigRingMesh
-	end
+    @men.each{|man|
+      man.delJob
+      assignJob(man)
+    }
+  end
+  def killAllJobs
+    @men.each{|man|man.delJob}
+  end
+  
+  
+  # ring mesh
+  def setupMesh
+  end
+  
+  
+  def getRing
+    makeBigRingMesh
+  end
 
 
-	def setupMeshBoss
-		setupMesh
-		setupRing
-	end
+  def setupMeshBoss
+    setupMesh
+    setupRing
+  end
 
 
-	def eventHLJobFinished(job)
-		puts &quot;eventHLJobFinished(job) #{self}&quot;
-		getMap.eventHLJobFinished(self,job)
-		doEvent(:eventHLJobFinished)
-	end
+  def eventHLJobFinished(job)
+    puts &quot;eventHLJobFinished(job) #{self}&quot;
+    getMap.eventHLJobFinished(self,job)
+    doEvent(:eventHLJobFinished)
+  end
 
-	def checkHLJobEnd(man)
-		if @job
-			if man
-				@job.check(man)
-			end
-			if @job.finished then 
-				job=@job
-				@job=nil 
-				eventHLJobFinished(job)
-				if @player
-					@player.eventJobFinished(self,job)
-				end
-			end
-		end
-		if @job==nil
-			noHLJob
-		end
-	end
-	def setAggression(a)
-		super
-		getMen.select{|m|(not m.is_a?(AntBoss))}.each{|m|m.setAggression(a)}
-	end
+  def checkHLJobEnd(man)
+    if @job
+      if man
+        @job.check(man)
+      end
+      if @job.finished then 
+        job=@job
+        @job=nil 
+        eventHLJobFinished(job)
+        if @player
+          @player.eventJobFinished(self,job)
+        end
+      end
+    end
+    if @job==nil
+      noHLJob
+    end
+  end
+  def setAggression(a)
+    super
+    getMen.select{|m|(not m.is_a?(AntBoss))}.each{|m|m.setAggression(a)}
+  end
 
-	def getFormation(man,pos=nil)
-		if @formation.nil?
-			getPos2D
-		else
-			return @formation.getPosition(man,pos)
-		end
-	end
+  def getFormation(man,pos=nil)
+    if @formation.nil?
+      getPos2D
+    else
+      return @formation.getPosition(man,pos)
+    end
+  end
 
-	def eventHaveDefeated(e)
-		if newHLJobs
-			eventNoJob
-			return
-		end
-		puts &quot;#{getName} has defeated #{e.getName}&quot;
-		if @job.is_a?(AntHeroFightJob)
-			@job.haveDefeated(e)
-		end
-	end
-	def saveXML(node)
-		super
-		if @job
-			n=node.addChild(&quot;hljob&quot;)
-			n.set(&quot;type&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at job.xmlName</A>)
-			@job.saveXML(n)
-		end
-	end
+  def eventHaveDefeated(e)
+    if newHLJobs
+      eventNoJob
+      return
+    end
+    puts &quot;#{getName} has defeated #{e.getName}&quot;
+    if @job.is_a?(AntHeroFightJob)
+      @job.haveDefeated(e)
+    end
+  end
+  def saveXML(node)
+    super
+    if @job
+      n=node.addChild(&quot;hljob&quot;)
+      n.set(&quot;type&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at job.xmlName</A>)
+      @job.saveXML(n)
+    end
+  end
 
 end
 

Modified: antargis/trunk/ruby/entities/ant_buildingsite.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_buildingsite.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_buildingsite.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,57 +1,57 @@
 
 class AntBuildingSite&lt;AntRubyEntity
-	attr_accessor :building
-	def initialize(map)
-		super(map)
-		@progress=0
-		#init fieldMeshes-var
-		setupMesh
-		newRestJob(300) # wait at least 5:00 minutes
-		@doneSth=true
-	end
+  attr_accessor :building
+  def initialize(map)
+    super(map)
+    @progress=0
+    #init fieldMeshes-var
+    setupMesh
+    newRestJob(300) # wait at least 5:00 minutes
+    @doneSth=true
+  end
 
-	def incProgress(steps)
-		@steps=steps
-		o=@progress.to_i
-		@progress+=(1.0/steps)*getStepCount
-		pp @progress
-		if o!=@progress.to_i
-			setupMesh
-		end
-		@doneSth=true
-	end
-	def ready
-		@progress&gt;AntModels.getMeshCount(:buildingsite)
-	end
+  def incProgress(steps)
+    @steps=steps
+    o=@progress.to_i
+    @progress+=(1.0/steps)*getStepCount
+    pp @progress
+    if o!=@progress.to_i
+      setupMesh
+    end
+    @doneSth=true
+  end
+  def ready
+    @progress&gt;AntModels.getMeshCount(:buildingsite)
+  end
 
-	# removes building site if nothing was done in some time
-	def eventJobFinished
-		if @doneSth
-			newRestJob(30) # wait another 30 seconds
-		else
-			getMap.removeEntity(self) # remove building site
-		end
-		@doneSth=false
-	end
+  # removes building site if nothing was done in some time
+  def eventJobFinished
+    if @doneSth
+      newRestJob(30) # wait another 30 seconds
+    else
+      getMap.removeEntity(self) # remove building site
+    end
+    @doneSth=false
+  end
 
-	def getDescription
-		a=_(building.to_s.gsub(&quot;Ant&quot;,&quot;&quot;))
-		d=_(&quot;This will be a {1}.&quot;,a)
-		if @steps
-			b=((getStepCount-1)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">- at progress</A>)*@steps/(getStepCount-1)
-			b=b.to_i.to_s
-			d+=_(&quot;It will be ready after {1} more steps.&quot;,b)
-		end
-		d
-	end
+  def getDescription
+    a=_(building.to_s.gsub(&quot;Ant&quot;,&quot;&quot;))
+    d=_(&quot;This will be a {1}.&quot;,a)
+    if @steps
+      b=((getStepCount-1)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">- at progress</A>)*@steps/(getStepCount-1)
+      b=b.to_i.to_s
+      d+=_(&quot;It will be ready after {1} more steps.&quot;,b)
+    end
+    d
+  end
 
-#	private
-	def setupMesh
-		pp @progress.to_i
-		setMesh(@progress.to_i)
-	end
+#  private
+  def setupMesh
+    pp @progress.to_i
+    setMesh(@progress.to_i)
+  end
 
-	def getStepCount
-		AntModels.getMeshCount(:buildingsite)
-	end
+  def getStepCount
+    AntModels.getMeshCount(:buildingsite)
+  end
 end

Modified: antargis/trunk/ruby/entities/ant_decal.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_decal.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_decal.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -19,22 +19,22 @@
 #
 
 class AntDecal&lt;AntRubyEntity
-	def initialize(map)
-		super(map)
-		@typeID=(getRand()*2).to_i
-		setProvide(&quot;decal&quot;,true)
-		setMesh(:floor_gravel)
-	end
-	def setTreeType(t)
-		@typeID=t
-	end
-	def saveXML(node)
-		super(node)
-		node.set(&quot;typeID&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at typeID.to_s</A>)
-	end
-	def loadXML(node)
-		super(node)
-		@typeID=node.get(&quot;typeID&quot;).to_i
-	end
+  def initialize(map)
+    super(map)
+    @typeID=(getRand()*2).to_i
+    setProvide(&quot;decal&quot;,true)
+    setMesh(:floor_gravel)
+  end
+  def setTreeType(t)
+    @typeID=t
+  end
+  def saveXML(node)
+    super(node)
+    node.set(&quot;typeID&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at typeID.to_s</A>)
+  end
+  def loadXML(node)
+    super(node)
+    @typeID=node.get(&quot;typeID&quot;).to_i
+  end
 end
 

Modified: antargis/trunk/ruby/entities/ant_deco.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_deco.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_deco.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -19,70 +19,70 @@
 #
 
 class AntDeco&lt;AntRubyEntity
-	def initialize(map,decoType=nil)
-		super(map)
-		@decoType=decoType
-		if @decoType==nil
-			a=[&quot;flower1a&quot;,&quot;flower2a&quot;,&quot;twig&quot;,&quot;gravel&quot;,&quot;small_bush&quot;,&quot;hole&quot;,&quot;grass4&quot;,&quot;grass4a&quot;,&quot;grass4b&quot;,&quot;gravel_big&quot;,&quot;gravel_big2&quot;,&quot;rock1&quot;]
-			r=(getRand()*a.size).to_i
-			@decoType=a[r]
-		else
-			b={&quot;coach&quot;=&gt;[&quot;coach2&quot;],
-					&quot;flower&quot;=&gt;[&quot;flower1a&quot;,&quot;flower2a&quot;],
-					&quot;gravel&quot;=&gt;[&quot;gravel&quot;,&quot;gravel_big&quot;,&quot;gravel_big2&quot;],
-					&quot;hole&quot;=&gt;[&quot;hole&quot;],
-					&quot;twig&quot;=&gt;[&quot;twig&quot;],
-					&quot;rock&quot;=&gt;[&quot;rock1&quot;],
-					&quot;grassLight&quot;=&gt;[&quot;grass4a&quot;,&quot;grass4b&quot;,&quot;grass4&quot;],
-					&quot;floor&quot;=&gt;[&quot;floor2&quot;],
-					&quot;path&quot;=&gt;[&quot;path&quot;],
-					&quot;block&quot;=&gt;[&quot;block2&quot;],
-					&quot;grassGreen&quot;=&gt;[&quot;grass3&quot;]}
-			a=b[@decoType]
-			r=(getRand()*a.size).to_i
-			@decoType=a[r]
-		end
-		setProvide(&quot;deco&quot;,true)
-		setMesh(:floor_deco)
-		#setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/floor.ant2&quot;,0.5,&quot;data/textures/splats/stones1a.png&quot;,false),AGVector4.new(0,0,0,0),0))
-	end
-	def setDecoType(t)
-		@typeID=t
-	end
-	def saveXML(node)
-		super(node)
-		node.set(&quot;decoType&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at decoType</A>)
-	end
-	def loadXML(node)
-		super(node)
-		@decoType=node.get(&quot;decoType&quot;)
-		#@typeID=node.get(&quot;typeID&quot;).to_i
-	end
+  def initialize(map,decoType=nil)
+    super(map)
+    @decoType=decoType
+    if @decoType==nil
+      a=[&quot;flower1a&quot;,&quot;flower2a&quot;,&quot;twig&quot;,&quot;gravel&quot;,&quot;small_bush&quot;,&quot;hole&quot;,&quot;grass4&quot;,&quot;grass4a&quot;,&quot;grass4b&quot;,&quot;gravel_big&quot;,&quot;gravel_big2&quot;,&quot;rock1&quot;]
+      r=(getRand()*a.size).to_i
+      @decoType=a[r]
+    else
+      b={&quot;coach&quot;=&gt;[&quot;coach2&quot;],
+          &quot;flower&quot;=&gt;[&quot;flower1a&quot;,&quot;flower2a&quot;],
+          &quot;gravel&quot;=&gt;[&quot;gravel&quot;,&quot;gravel_big&quot;,&quot;gravel_big2&quot;],
+          &quot;hole&quot;=&gt;[&quot;hole&quot;],
+          &quot;twig&quot;=&gt;[&quot;twig&quot;],
+          &quot;rock&quot;=&gt;[&quot;rock1&quot;],
+          &quot;grassLight&quot;=&gt;[&quot;grass4a&quot;,&quot;grass4b&quot;,&quot;grass4&quot;],
+          &quot;floor&quot;=&gt;[&quot;floor2&quot;],
+          &quot;path&quot;=&gt;[&quot;path&quot;],
+          &quot;block&quot;=&gt;[&quot;block2&quot;],
+          &quot;grassGreen&quot;=&gt;[&quot;grass3&quot;]}
+      a=b[@decoType]
+      r=(getRand()*a.size).to_i
+      @decoType=a[r]
+    end
+    setProvide(&quot;deco&quot;,true)
+    setMesh(:floor_deco)
+    #setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/floor.ant2&quot;,0.5,&quot;data/textures/splats/stones1a.png&quot;,false),AGVector4.new(0,0,0,0),0))
+  end
+  def setDecoType(t)
+    @typeID=t
+  end
+  def saveXML(node)
+    super(node)
+    node.set(&quot;decoType&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at decoType</A>)
+  end
+  def loadXML(node)
+    super(node)
+    @decoType=node.get(&quot;decoType&quot;)
+    #@typeID=node.get(&quot;typeID&quot;).to_i
+  end
 end
 
 class AntTwig&lt;AntRubyEntity
-	def initialize(map)
-		super
-		@typeID=(getRand()*2).to_i
-		#setType(&quot;twig&quot;)
-		#setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/twig.ant2&quot;,0.7),AGVector4.new(0,0,0,0),getRand*360))
-		mesh=setMesh
-		mesh.setRotation(getRand*360)
-	end
+  def initialize(map)
+    super
+    @typeID=(getRand()*2).to_i
+    #setType(&quot;twig&quot;)
+    #setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/twig.ant2&quot;,0.7),AGVector4.new(0,0,0,0),getRand*360))
+    mesh=setMesh
+    mesh.setRotation(getRand*360)
+  end
 end
 
 class AntDecoMesh&lt;AntRubyEntity
-	def initialize(map,name=&quot;coach&quot;)
-		super(map)
-		@name=name
-		setMesh
-		#setMesh(AntModels.createModel(self,:coach))
-	end
-	def saveXML(node)
-		super
-		node.set(&quot;meshName&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at name</A>)
-	end
-	def loadXML(node)
-		super
-	end
+  def initialize(map,name=&quot;coach&quot;)
+    super(map)
+    @name=name
+    setMesh
+    #setMesh(AntModels.createModel(self,:coach))
+  end
+  def saveXML(node)
+    super
+    node.set(&quot;meshName&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at name</A>)
+  end
+  def loadXML(node)
+    super
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_druid.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_druid.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_druid.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,34 +1,34 @@
 class AntNPC&lt;AntRubyEntity
-	attr_accessor :npcType
-	def initialize(map)
-		super
-		setProvide(&quot;NPC&quot;,true)
-		@npcType=&quot;smith&quot; #druid&quot;
-		setupMesh
-	end
-	def resourceChanged
-		super
-		setupMesh
-	end
-	
-	def saveXML(node)
-		node.set(&quot;npcType&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at npcType</A>)
-		super
-	end
-	def loadXML(node)
-		@npcType=node.get(&quot;npcType&quot;)
-		super
-		setupMesh
-	end
-	
-	def setupMesh
-		case @npcType
-			when &quot;smith&quot;
-				setMesh(:smith)
-	 			#setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/smith_lp.ant2&quot;,0.08,&quot;data/textures/models/smith_lp.png&quot;),AGVector4.new(0,0,0,0),0))
-			else
-				setMesh(:druid)
-	 			#setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/druid_lp.ant2&quot;,0.08,&quot;data/textures/models/druid_lp.png&quot;),AGVector4.new(0,0,0,0),0))
-		end
-	end
+  attr_accessor :npcType
+  def initialize(map)
+    super
+    setProvide(&quot;NPC&quot;,true)
+    @npcType=&quot;smith&quot; #druid&quot;
+    setupMesh
+  end
+  def resourceChanged
+    super
+    setupMesh
+  end
+  
+  def saveXML(node)
+    node.set(&quot;npcType&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at npcType</A>)
+    super
+  end
+  def loadXML(node)
+    @npcType=node.get(&quot;npcType&quot;)
+    super
+    setupMesh
+  end
+  
+  def setupMesh
+    case @npcType
+      when &quot;smith&quot;
+        setMesh(:smith)
+         #setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/smith_lp.ant2&quot;,0.08,&quot;data/textures/models/smith_lp.png&quot;),AGVector4.new(0,0,0,0),0))
+      else
+        setMesh(:druid)
+         #setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/druid_lp.ant2&quot;,0.08,&quot;data/textures/models/druid_lp.png&quot;),AGVector4.new(0,0,0,0),0))
+    end
+  end
 end

Modified: antargis/trunk/ruby/entities/ant_dwelling.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_dwelling.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_dwelling.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -3,53 +3,53 @@
 
 # A dwelling has zero or more residents. Whenever there some residents they will reproduce themselves.
 class AntDwelling&lt;AntHouse
-	def initialize(map)
-		super
-		setProvide(&quot;dwelling&quot;,true)
-		@lastBirth=0
-		setDirection(-20)
-	end
+  def initialize(map)
+    super
+    setProvide(&quot;dwelling&quot;,true)
+    @lastBirth=0
+    setDirection(-20)
+  end
 
-	# when my job is finished check for a new birth
-	def eventJobFinished
-		super
-		checkBirth
-	end
+  # when my job is finished check for a new birth
+  def eventJobFinished
+    super
+    checkBirth
+  end
 
-	# setup the mesh
-	def setupMesh
-		setMesh
-	end
+  # setup the mesh
+  def setupMesh
+    setMesh
+  end
 
 protected
-	def neededStock
-		{&quot;food&quot;=&gt;15}
-	end
+  def neededStock
+    {&quot;food&quot;=&gt;15}
+  end
 
-	def houseType
-		&quot;dwelling&quot;
-	end
-	
+  def houseType
+    &quot;dwelling&quot;
+  end
+  
 private
-	def checkBirth
-		# only men, which are at home can add to birth rate
-		@lastBirth+=[@atHome.length+resource.get(&quot;food&quot;)/3,10].min
-		if @lastBirth&gt;BIRTHING_TIME then
-			man=AntMan.new
-			getMap.insertEntity(man)
-			man.setPos(getPos2D)
-			man.setBoss(self)
-			#getMap.endChange
-			@lastBirth=-BIRTHING_TIME
-		end
+  def checkBirth
+    # only men, which are at home can add to birth rate
+    @lastBirth+=[@atHome.length+resource.get(&quot;food&quot;)/3,10].min
+    if @lastBirth&gt;BIRTHING_TIME then
+      man=AntMan.new
+      getMap.insertEntity(man)
+      man.setPos(getPos2D)
+      man.setBoss(self)
+      #getMap.endChange
+      @lastBirth=-BIRTHING_TIME
+    end
 
-		while getMen.length&gt;MAX_RESIDENTS
-			m=getMen
-			m[0..4].each{|man|
-				man.setBoss(nil)
-			}
-		end
-	end
-	
+    while getMen.length&gt;MAX_RESIDENTS
+      m=getMen
+      m[0..4].each{|man|
+        man.setBoss(nil)
+      }
+    end
+  end
+  
 end
 

Modified: antargis/trunk/ruby/entities/ant_farm.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_farm.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_farm.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -22,70 +22,70 @@
 #    - farming (wheat)
 
 class AntFarm&lt;AntHouse
-	def initialize(map)
-		super
-		@type=3
-		setProvide(&quot;food&quot;,true)
-		setProvide(&quot;corn&quot;,true)
-		@defeated=[]
-		@atHome=[]
-		@lastBirth=0
-		@fields=[]
-		setDirection(-30)
-	end
-	
-	def setupMesh
-		setMesh
-	end
+  def initialize(map)
+    super
+    @type=3
+    setProvide(&quot;food&quot;,true)
+    setProvide(&quot;corn&quot;,true)
+    @defeated=[]
+    @atHome=[]
+    @lastBirth=0
+    @fields=[]
+    setDirection(-30)
+  end
+  
+  def setupMesh
+    setMesh
+  end
 
-	def neededStock
-		{&quot;fruit&quot;=&gt;15,&quot;crop&quot;=&gt;15}
-	end
+  def neededStock
+    {&quot;fruit&quot;=&gt;15,&quot;crop&quot;=&gt;15}
+  end
 
-	def assignJob(e)
-		if @job.nil?
-			if e.getMode==&quot;makeField&quot;
-				pos=e.getPos2D
-				f=AntField.new(getMap)
-				f.setPos(pos)
-				getMap.insertEntity(f)
-				puts &quot;INSERT ENT #{@fields.length}&quot;
-				#getMap.endChange
-				@fields.push(f)
-				f.farm=self
-				e.setMode(&quot;&quot;)
-				e.newMoveJob(0,getPos2D,0)
-				return
-			elsif @fields.length&lt;7
-				e.setMode(&quot;makeField&quot;)
-				angle=getRand*360
-				radius=getRand*3+6
-				e.newMoveJob(0,getPos2D+AGVector2.new(AGAngle.new(angle))*radius,0)
-				return
-			end
-		end
-		super
-	end
+  def assignJob(e)
+    if @job.nil?
+      if e.getMode==&quot;makeField&quot;
+        pos=e.getPos2D
+        f=AntField.new(getMap)
+        f.setPos(pos)
+        getMap.insertEntity(f)
+        puts &quot;INSERT ENT #{@fields.length}&quot;
+        #getMap.endChange
+        @fields.push(f)
+        f.farm=self
+        e.setMode(&quot;&quot;)
+        e.newMoveJob(0,getPos2D,0)
+        return
+      elsif @fields.length&lt;7
+        e.setMode(&quot;makeField&quot;)
+        angle=getRand*360
+        radius=getRand*3+6
+        e.newMoveJob(0,getPos2D+AGVector2.new(AGAngle.new(angle))*radius,0)
+        return
+      end
+    end
+    super
+  end
 
-	def removeField(f)
-		@fields.delete(f)
-		getMap.removeEntity(f)
-		#getMap.endChange
-	end
+  def removeField(f)
+    @fields.delete(f)
+    getMap.removeEntity(f)
+    #getMap.endChange
+  end
 
-	def process
-		if resource.get(&quot;fruit&quot;)&gt;0 and resource.get(&quot;food&quot;)&lt;15
-			amount=[resource.get(&quot;fruit&quot;),3].min
-			resource.add(&quot;food&quot;,amount)
-			resource.sub(&quot;fruit&quot;,amount)
-		end
-		if resource.get(&quot;crop&quot;)&gt;0 and resource.get(&quot;corn&quot;)&lt;15
-			amount=[resource.get(&quot;crop&quot;),3].min
-			resource.add(&quot;corn&quot;,amount)
-			resource.sub(&quot;crop&quot;,amount)
-		end
-	end
-	def houseType
-		&quot;farm&quot;
-	end
+  def process
+    if resource.get(&quot;fruit&quot;)&gt;0 and resource.get(&quot;food&quot;)&lt;15
+      amount=[resource.get(&quot;fruit&quot;),3].min
+      resource.add(&quot;food&quot;,amount)
+      resource.sub(&quot;fruit&quot;,amount)
+    end
+    if resource.get(&quot;crop&quot;)&gt;0 and resource.get(&quot;corn&quot;)&lt;15
+      amount=[resource.get(&quot;crop&quot;),3].min
+      resource.add(&quot;corn&quot;,amount)
+      resource.sub(&quot;crop&quot;,amount)
+    end
+  end
+  def houseType
+    &quot;farm&quot;
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_field.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_field.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_field.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,43 +1,43 @@
 class AntField&lt;AntRubyEntity
-	attr_accessor :farm
-	def initialize(map)
-		super
-		setProvide(&quot;field&quot;,true)
-		@size=0
-		#init fieldMeshes-var
-		@max=AntModels.getMeshCount(:field)-1
-		setupMesh
-		@growTime=20
-		@begin=true
-		newRestJob(@growTime)
-	end
-	def resourceChanged
-		if @size==@max
-			if resource.get(&quot;crop&quot;)==0
-				if @farm
-					@farm.removeField(self)
-					return
-				end
-			end
-		end
-		setupMesh
-		super
-	end
+  attr_accessor :farm
+  def initialize(map)
+    super
+    setProvide(&quot;field&quot;,true)
+    @size=0
+    #init fieldMeshes-var
+    @max=AntModels.getMeshCount(:field)-1
+    setupMesh
+    @growTime=20
+    @begin=true
+    newRestJob(@growTime)
+  end
+  def resourceChanged
+    if @size==@max
+      if resource.get(&quot;crop&quot;)==0
+        if @farm
+          @farm.removeField(self)
+          return
+        end
+      end
+    end
+    setupMesh
+    super
+  end
 
-	def eventNoJob
-		@size=[@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">max, at size+1</A>].min
-		if @size==@max and @begin
-			setProvide(&quot;crop&quot;,true)
-			resource.set(&quot;crop&quot;,5)
-			@begin=false
-		end
-		newRestJob(@growTime)
-		resourceChanged
-	end
-	
-	
-	private
-	def setupMesh
-		setMesh(@size)
-	end
+  def eventNoJob
+    @size=[@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">max, at size+1</A>].min
+    if @size==@max and @begin
+      setProvide(&quot;crop&quot;,true)
+      resource.set(&quot;crop&quot;,5)
+      @begin=false
+    end
+    newRestJob(@growTime)
+    resourceChanged
+  end
+  
+  
+  private
+  def setupMesh
+    setMesh(@size)
+  end
 end

Modified: antargis/trunk/ruby/entities/ant_fir.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_fir.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_fir.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -22,74 +22,74 @@
 
 # really nothing special here - just a &quot;grouper&quot;
 class AntBaseTree&lt;AntRubyEntity
-	def initialize(map)
-		super
-		#setType(&quot;tree&quot;)
-		setProvide(&quot;tree&quot;,true)
-	end
-	def resourceChanged
-		super
-		setupMesh if respond_to?(:setupMesh)
-	end
+  def initialize(map)
+    super
+    #setType(&quot;tree&quot;)
+    setProvide(&quot;tree&quot;,true)
+  end
+  def resourceChanged
+    super
+    setupMesh if respond_to?(:setupMesh)
+  end
 end
 
 # a fir
 class AntFir&lt;AntBaseTree
-	def initialize(map)
-		super
-		setProvide(&quot;fir&quot;,true)
-		setProvide(&quot;wood&quot;,true)
-		resource.set(&quot;wood&quot;,25)
+  def initialize(map)
+    super
+    setProvide(&quot;fir&quot;,true)
+    setProvide(&quot;wood&quot;,true)
+    resource.set(&quot;wood&quot;,25)
 
-		setupMesh
-	end
+    setupMesh
+  end
 
-	def resourceChanged
-		if resource.get(&quot;wood&quot;)&lt;=0
-			@typeID=-1
-			setProvide(&quot;wood&quot;,false)
-		end
-		super
-	end
+  def resourceChanged
+    if resource.get(&quot;wood&quot;)&lt;=0
+      @typeID=-1
+      setProvide(&quot;wood&quot;,false)
+    end
+    super
+  end
 
-	
+  
 protected
-	def setupMesh
-		#if resource.get(&quot;wood&quot;)&lt;=0
-		#	data=getMeshData(&quot;data/models/stub.ant2&quot;,0.04,&quot;data/textures/models/stub.png&quot;)
-# 		setMesh(Mesh.new(getMap.getScene,meshData,AGVector4.new,0))
-# 	end
+  def setupMesh
+    #if resource.get(&quot;wood&quot;)&lt;=0
+    #  data=getMeshData(&quot;data/models/stub.ant2&quot;,0.04,&quot;data/textures/models/stub.png&quot;)
+#     setMesh(Mesh.new(getMap.getScene,meshData,AGVector4.new,0))
+#   end
 # private
-# 	def meshData
-		typeId=&quot;stub&quot;
-		if resource.get(&quot;wood&quot;)&gt;0
-			typeId=1
-# 			data=getMeshData(&quot;data/models/stub.ant2&quot;,0.04,&quot;data/textures/models/stub.png&quot;)
-# 		else
-# 			data=getMeshData(&quot;data/models/fir2.ant2&quot;,0.45,&quot;data/textures/models/fir7.png&quot;)
-		end
-		setMesh(typeId,:tree)
-		#data.setTransparent(true)
-		#data.setCulling(false) # patch for old trees
+#   def meshData
+    typeId=&quot;stub&quot;
+    if resource.get(&quot;wood&quot;)&gt;0
+      typeId=1
+#       data=getMeshData(&quot;data/models/stub.ant2&quot;,0.04,&quot;data/textures/models/stub.png&quot;)
+#     else
+#       data=getMeshData(&quot;data/models/fir2.ant2&quot;,0.45,&quot;data/textures/models/fir7.png&quot;)
+    end
+    setMesh(typeId,:tree)
+    #data.setTransparent(true)
+    #data.setCulling(false) # patch for old trees
 
-# 		return data
-	end
+#     return data
+  end
 end
 
 # # a birch representing a tree without fruit
 # class AntBirch&lt;AntBaseTree
-# 	def initialize()
-# 		super(AGVector2.new(0,0))
-# 	
-# 		setupMesh
-# 	end
-# 	
+#   def initialize()
+#     super(AGVector2.new(0,0))
+#   
+#     setupMesh
+#   end
+#   
 # protected
-# 	def setupMesh
-# 		if MyAntargislib.opengl
-# 			setMesh(makeBirchTreeMesh)
-# 		else
-# 			puts &quot;NO BIRCHES WITHOUT GL ATM&quot;
-# 		end
-# 	end
+#   def setupMesh
+#     if MyAntargislib.opengl
+#       setMesh(makeBirchTreeMesh)
+#     else
+#       puts &quot;NO BIRCHES WITHOUT GL ATM&quot;
+#     end
+#   end
 # end

Modified: antargis/trunk/ruby/entities/ant_fire.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_fire.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_fire.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,43 +1,43 @@
 class AntFire&lt;AntRubyEntity
-	def initialize(map)
-		super
-		mp=AGVector3.new(0,0,0)
-		setMesh(:on)
-		if MyAntargislib.opengl and getScene
-			@smokeMesh=AntParticle.new(getMap.getScene,4)
-			addMesh(@smokeMesh,mp)
-			smoke=AntParticle.new(getMap.getScene,40)
-			smoke.setFire(true)
-			smoke.setMaxTime(0.8)
-			addMesh(smoke,mp)
-		end
-		#setPos(getAGVector2.new(p.x,p.y))
-		@enabled=true
-	end
-	def disable
-		return unless getScene
-		setMesh(:off)
-		if MyAntargislib.opengl
-			#setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/fire.ant2&quot;,0.3,&quot;data/textures/models/fire2.png&quot;),AGVector4.new(0,0,0),0))
-			getMap.getScene.addNode(@smokeMesh) # FIXME: dirty hack - solve this another way!!!
-			addMesh(@smokeMesh,AGVector3.new(0,0,0))
-			@smokeMesh.setEnabled(false)
-		end
-		@enabled=false
-	end
-	def loadXML(n)
-		disable  # disable because hero makes new fire anyway
-	end
-	def eventNoJob
-		if @enabled
-			newRestJob(10)
-		else
-			if @dead
-				getMap.removeEntity(self)
-			else
-				@dead=true
-				newRestJob(30)
-			end
-		end
-	end
+  def initialize(map)
+    super
+    mp=AGVector3.new(0,0,0)
+    setMesh(:on)
+    if MyAntargislib.opengl and getScene
+      @smokeMesh=AntParticle.new(getMap.getScene,4)
+      addMesh(@smokeMesh,mp)
+      smoke=AntParticle.new(getMap.getScene,40)
+      smoke.setFire(true)
+      smoke.setMaxTime(0.8)
+      addMesh(smoke,mp)
+    end
+    #setPos(getAGVector2.new(p.x,p.y))
+    @enabled=true
+  end
+  def disable
+    return unless getScene
+    setMesh(:off)
+    if MyAntargislib.opengl
+      #setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/fire.ant2&quot;,0.3,&quot;data/textures/models/fire2.png&quot;),AGVector4.new(0,0,0),0))
+      getMap.getScene.addNode(@smokeMesh) # FIXME: dirty hack - solve this another way!!!
+      addMesh(@smokeMesh,AGVector3.new(0,0,0))
+      @smokeMesh.setEnabled(false)
+    end
+    @enabled=false
+  end
+  def loadXML(n)
+    disable  # disable because hero makes new fire anyway
+  end
+  def eventNoJob
+    if @enabled
+      newRestJob(10)
+    else
+      if @dead
+        getMap.removeEntity(self)
+      else
+        @dead=true
+        newRestJob(30)
+      end
+    end
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_fish.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_fish.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_fish.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -19,80 +19,80 @@
 #
 
 def getFishMeshData
-	getMeshData(&quot;data/models/fish.ant2&quot;,0.02,&quot;data/textures/models/fish.png&quot;)
+  getMeshData(&quot;data/models/fish.ant2&quot;,0.02,&quot;data/textures/models/fish.png&quot;)
 end
 
 class AntFish&lt;AntAnimal
-	def initialize(map)
-		super
-		setProvide(&quot;fish&quot;,true)
-		setSpeed 0.6
-		@foodAdd=0
+  def initialize(map)
+    super
+    setProvide(&quot;fish&quot;,true)
+    setSpeed 0.6
+    @foodAdd=0
 
-		setOnGround(false)
-		setPos(AGVector3.new(0,0,-0.3))
+    setOnGround(false)
+    setPos(AGVector3.new(0,0,-0.3))
 
-		setMesh
+    setMesh
 
-		resource.set(&quot;food&quot;,1)
-	end
-	def saveXML(node)
-		super(node)
-	end
-	def loadXML(node)
-		super(node)
-	end
-	def eventNoJob
-		eventJobFinished
-	end
-	def eventJobFinished
-		super
+    resource.set(&quot;food&quot;,1)
+  end
+  def saveXML(node)
+    super(node)
+  end
+  def loadXML(node)
+    super(node)
+  end
+  def eventNoJob
+    eventJobFinished
+  end
+  def eventJobFinished
+    super
 
-		if @dead
-			newRestJob(30)
-			if @alreadyDead
-				getMap.removeEntity(self)
-			end
-			@alreadyDead=true
-	
-			return
-		end
+    if @dead
+      newRestJob(30)
+      if @alreadyDead
+        getMap.removeEntity(self)
+      end
+      @alreadyDead=true
+  
+      return
+    end
 
-		if (not giveBirth)
-			setPos(AGVector3.new(getPos2D,-0.3))
-			newMoveJob(0,getTargetPos,0)
-			setMeshState(&quot;go&quot;)
-		end
+    if (not giveBirth)
+      setPos(AGVector3.new(getPos2D,-0.3))
+      newMoveJob(0,getTargetPos,0)
+      setMeshState(&quot;go&quot;)
+    end
 
-		@foodAdd+=1
-		#puts &quot;FOOOOOD #{@foodAdd}&quot;
-		if @foodAdd&gt;3 and resource.get(&quot;food&quot;)&lt;10
-			resource.add(&quot;food&quot;,1)
-			@foodAdd=0
-		end
+    @foodAdd+=1
+    #puts &quot;FOOOOOD #{@foodAdd}&quot;
+    if @foodAdd&gt;3 and resource.get(&quot;food&quot;)&lt;10
+      resource.add(&quot;food&quot;,1)
+      @foodAdd=0
+    end
 
-	end
-	
-	def getTargetPos
-		p=getPos2D
-		tries=10
-		# assure that sheep doesn't walk into water
-		while tries&gt;0 do
-			d=AGVector2.new(getRand-0.5,getRand-0.5).normalized*2
-			t=p+d
-			t=getMap.truncPos(t)
-			tries-=1
-			if getMap.getHeight(t.x,t.y)&lt;0
-				return t
-			end
-		end 
-		return p
-	end
-	def setMeshState(s)
-		#getFirstMesh.setAnimation(s)
-	end
-	def getName
-		&quot;Fish&quot;
-	end
+  end
+  
+  def getTargetPos
+    p=getPos2D
+    tries=10
+    # assure that sheep doesn't walk into water
+    while tries&gt;0 do
+      d=AGVector2.new(getRand-0.5,getRand-0.5).normalized*2
+      t=p+d
+      t=getMap.truncPos(t)
+      tries-=1
+      if getMap.getHeight(t.x,t.y)&lt;0
+        return t
+      end
+    end 
+    return p
+  end
+  def setMeshState(s)
+    #getFirstMesh.setAnimation(s)
+  end
+  def getName
+    &quot;Fish&quot;
+  end
 private
 end

Modified: antargis/trunk/ruby/entities/ant_fishing_hut.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_fishing_hut.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_fishing_hut.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,37 +1,37 @@
 
 class AntFishingHut&lt;AntHouse
-	def initialize(map)
-		super
-		@type=3
-		setProvide(&quot;food&quot;,true)
-		@defeated=[]
-		@atHome=[]
-		@lastBirth=0
-		setDirection(-30)
-	end
-	
-	def setupMesh
-		setMesh
+  def initialize(map)
+    super
+    @type=3
+    setProvide(&quot;food&quot;,true)
+    @defeated=[]
+    @atHome=[]
+    @lastBirth=0
+    setDirection(-30)
+  end
+  
+  def setupMesh
+    setMesh
 # 
 # 
-# 		data=getMeshData(&quot;data/models/fishing_hut.ant2&quot;,3.2,&quot;data/textures/models/fishing_hut.png&quot;)
-# 		data.setTransparent(true)
-# 		mesh=Mesh.new(getMap.getScene,data,AGVector4.new(0,0,0),-30)
-# 		setMesh(mesh)
-	end
+#     data=getMeshData(&quot;data/models/fishing_hut.ant2&quot;,3.2,&quot;data/textures/models/fishing_hut.png&quot;)
+#     data.setTransparent(true)
+#     mesh=Mesh.new(getMap.getScene,data,AGVector4.new(0,0,0),-30)
+#     setMesh(mesh)
+  end
 
-	def neededStock
-		{&quot;fish&quot;=&gt;20,&quot;food&quot;=&gt;10}
-	end
+  def neededStock
+    {&quot;fish&quot;=&gt;20,&quot;food&quot;=&gt;10}
+  end
 
-	def process
-		if resource.get(&quot;fish&quot;)&gt;0 and resource.get(&quot;food&quot;)&lt;10
-			amount=[resource.get(&quot;fish&quot;),1].min
-			resource.sub(&quot;fish&quot;,amount)
-			resource.add(&quot;food&quot;,amount*2)
-		end
-	end
-	def houseType
-		&quot;mill&quot;
-	end
+  def process
+    if resource.get(&quot;fish&quot;)&gt;0 and resource.get(&quot;food&quot;)&lt;10
+      amount=[resource.get(&quot;fish&quot;),1].min
+      resource.sub(&quot;fish&quot;,amount)
+      resource.add(&quot;food&quot;,amount*2)
+    end
+  end
+  def houseType
+    &quot;mill&quot;
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_grass.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_grass.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_grass.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,60 +1,60 @@
 
 
 class AntGrass&lt;AntRubyEntity
-	def initialize(map,high=false)
-		super(map)
-		setProvide(&quot;grass&quot;,true)
-		if high
-			@size=getRand*0.25+0.5
-		else
-			@size=getRand*0.25+0.25
-		end
-		setupMesh
-	end
-	def resourceChanged
-		super
-		setupMesh
-	end
-	
-	
-	private
-	def setupMesh
-		#return setMesh(@sze)
-		if MyAntargislib.opengl
-			setMesh(@size) #makeGrassMesh(@size))
-		else
-			puts &quot;PROBLEM: NO GRASS WITHOUT GL!&quot;
-		end
-	end
+  def initialize(map,high=false)
+    super(map)
+    setProvide(&quot;grass&quot;,true)
+    if high
+      @size=getRand*0.25+0.5
+    else
+      @size=getRand*0.25+0.25
+    end
+    setupMesh
+  end
+  def resourceChanged
+    super
+    setupMesh
+  end
+  
+  
+  private
+  def setupMesh
+    #return setMesh(@sze)
+    if MyAntargislib.opengl
+      setMesh(@size) #makeGrassMesh(@size))
+    else
+      puts &quot;PROBLEM: NO GRASS WITHOUT GL!&quot;
+    end
+  end
 end
 
 class AntHighGrass&lt;AntGrass
-	def initialize(map)
-		super(map,true)
-	end
+  def initialize(map)
+    super(map,true)
+  end
 end
 
 
 class AntBush&lt;AntRubyEntity
-	def initialize(map)
-		super
-		setProvide(&quot;bush&quot;,true)
-		@size=getRand*0.25+0.25
-		setupMesh
-	end
-	def resourceChanged
-		setupMesh
-		super
-	end
-	
-	private
-	def setupMesh
-		if MyAntargislib.opengl
-			setMesh(@size) #makeBushMesh(@size*3))
-		else
-			puts &quot;PROBLEM: NO GRASS WITHOUT GL!&quot;
-		end
-	end
+  def initialize(map)
+    super
+    setProvide(&quot;bush&quot;,true)
+    @size=getRand*0.25+0.25
+    setupMesh
+  end
+  def resourceChanged
+    setupMesh
+    super
+  end
+  
+  private
+  def setupMesh
+    if MyAntargislib.opengl
+      setMesh(@size) #makeBushMesh(@size*3))
+    else
+      puts &quot;PROBLEM: NO GRASS WITHOUT GL!&quot;
+    end
+  end
 end
 
 

Modified: antargis/trunk/ruby/entities/ant_grave.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_grave.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_grave.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,25 +1,25 @@
 class AntGrave&lt;AntRubyEntity
-	TYPES=[:normal,:hero]
+  TYPES=[:normal,:hero]
 
-	def initialize(map)
-		super
-		@type=:normal
-		setMesh(@type)
-		@waited=false
-	end
-	def type=(type)
-		if TYPES.member?(type)
-			@type=type
-			setMesh(@type)
-		end
-	end
-	def eventNoJob
-		if @waited
-			getMap.removeEntity(self)
-			return
-		else
-			newRestJob(40)
-			@waited=true
-		end
-	end
+  def initialize(map)
+    super
+    @type=:normal
+    setMesh(@type)
+    @waited=false
+  end
+  def type=(type)
+    if TYPES.member?(type)
+      @type=type
+      setMesh(@type)
+    end
+  end
+  def eventNoJob
+    if @waited
+      getMap.removeEntity(self)
+      return
+    else
+      newRestJob(40)
+      @waited=true
+    end
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_hero.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_hero.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_hero.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -26,332 +26,332 @@
 require 'ant_manbase.rb'
 
 class AntHero&lt;AntBoss
-	include AntManBase
+  include AntManBase
 
-	attr_reader :meshState, :dead
-	def initialize(map)
-		super
-		@men.push(self)
-		setProvide(&quot;hero&quot;,true)
-		@appearance=&quot;hero&quot;
-		getMap.setLight(self)
-		setMinimapColor(AGColor.new(0xFF,0,0))
-		@meshStand=&quot;stand&quot;
-		self.age=(getRand*20+20)
-		setHunger(0.006)
-	end
-	def setAppearance(a)
-		@appearance=a
-	end
-	
-	def saveXML(node)
-		super(node)
-		node.set(&quot;appearance&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at appearance.to_s</A>)
-	end
-	def loadXML(node)
-		super(node)
-		@appearance=node.get(&quot;appearance&quot;)
-		if @appearance==&quot;&quot;
-			@appearance=&quot;hero&quot;
-		end
-		@portrait=node.get(&quot;portrait&quot;)
+  attr_reader :meshState, :dead
+  def initialize(map)
+    super
+    @men.push(self)
+    setProvide(&quot;hero&quot;,true)
+    @appearance=&quot;hero&quot;
+    getMap.setLight(self)
+    setMinimapColor(AGColor.new(0xFF,0,0))
+    @meshStand=&quot;stand&quot;
+    self.age=(getRand*20+20)
+    setHunger(0.006)
+  end
+  def setAppearance(a)
+    @appearance=a
+  end
+  
+  def saveXML(node)
+    super(node)
+    node.set(&quot;appearance&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at appearance.to_s</A>)
+  end
+  def loadXML(node)
+    super(node)
+    @appearance=node.get(&quot;appearance&quot;)
+    if @appearance==&quot;&quot;
+      @appearance=&quot;hero&quot;
+    end
+    @portrait=node.get(&quot;portrait&quot;)
 
-		if node.get(&quot;primary&quot;)==&quot;true&quot;
-			#setMoraleHealSpeed=1000
-			setMoraleFlag(false)
-		end
-	end
-	
-	def noHLJob
-		if @player
-			@player.assignJob(self)
-			#stopFireSound
-		else
-			# no player , so simply rest - to infinity (or at least 5 seconds)
-			newHLRestJob(5)
-		end
-	end
-	
-	def startFireSound
-		if not @fireSound
-			#dputs &quot;STARTING FIRE&quot;
-			@fireSound=AntSound.playLoopSoundGlobal(self,&quot;fire&quot;,getPos2D,0.4)
-			#dputs @fireSound
-		end
-	end	
-	def stopFireSound
-		if @fireSound
-			#dputs &quot;STOPPED&quot;
-			#dputs @job
-			if @job.class==AntHeroRestJob
-				#raise &quot;bla&quot;
-			end
-			AntSound.stopLoopSound(self)
-			#getSoundManager.stopChannel(@fireSound)
-			@fireSound=nil
-		end
-	end
+    if node.get(&quot;primary&quot;)==&quot;true&quot;
+      #setMoraleHealSpeed=1000
+      setMoraleFlag(false)
+    end
+  end
+  
+  def noHLJob
+    if @player
+      @player.assignJob(self)
+      #stopFireSound
+    else
+      # no player , so simply rest - to infinity (or at least 5 seconds)
+      newHLRestJob(5)
+    end
+  end
+  
+  def startFireSound
+    if not @fireSound
+      #dputs &quot;STARTING FIRE&quot;
+      @fireSound=AntSound.playLoopSoundGlobal(self,&quot;fire&quot;,getPos2D,0.4)
+      #dputs @fireSound
+    end
+  end  
+  def stopFireSound
+    if @fireSound
+      #dputs &quot;STOPPED&quot;
+      #dputs @job
+      if @job.class==AntHeroRestJob
+        #raise &quot;bla&quot;
+      end
+      AntSound.stopLoopSound(self)
+      #getSoundManager.stopChannel(@fireSound)
+      @fireSound=nil
+    end
+  end
 
-	def newFightJob(d,ptarget)
-		checkResources
-		super
-		@moving=true
-		setMeshState(&quot;fight&quot;)
-	end
-	
-	def newHLRestJob(time)
-		@job.stopJob if @job
-		@job=nil
-		setFire(true)
-		super(time)
-		assignJob2All
-	end
-	
-	def assignJob(man)
-		checkHLJobEnd(man)
-	end	
-	def moveHome(man)
-		if @formation.nil?
-			raise &quot;formation is nil!&quot;
-		end
-		pos=@formation.getPosition(man)
-# 		pos=getSitFormation(man)
-		if (man.getPos2D-pos).length&gt;1
-			man.newMoveJob(0,pos,0)
-		else
-			man.newRestJob(2)
-		end
-	end
-	
-	
-	def newHLMoveJob(prio,pos,dist)
-		@job.stopJob if @job
-		@job=AntHeroMoveJob.new(self,prio,pos,dist)
-		assignJob2All
-	end
-	def newHLRecruitJob(target)
-		assert{target!=self}
-		@job.stopJob if @job
-		@job=AntHeroRecruitJob.new(self,target)
-		assignJob2All
-	end
-	def newHLConstructJob(target)
-		@job.stopJob if @job
-		@job=AntHeroConstructJob.new(self,target)
-		assignJob2All
-	end
-	def newHLTakeFoodJob(target)
-		@job.stopJob if @job
-		#puts &quot;take food job #{self} #{target}&quot;
-		@job=AntHeroTakeJob.new(self,target,&quot;food&quot;)
-		assignJob2All
-	end
-	def newHLTakeWeaponJob(target)
-		@job.stopJob if @job
-		@job=AntHeroTakeJob.new(self,target,&quot;weapon&quot;)
-		assignJob2All
-	end
-	def newHLFightJob(target)
-		@job.stopJob if @job
-		@job=AntHeroFightJob.new(self,target)
-		assignJob2All
-	end
-	def newHLFightAnimalJob(target)
-		@job.stopJob if @job
-		@job=AntHeroFightAnimalJob.new(self,target)
-		assignJob2All
-	end
-	def newHLBuildJob(pos,type)
-		@job.stopJob if @job
+  def newFightJob(d,ptarget)
+    checkResources
+    super
+    @moving=true
+    setMeshState(&quot;fight&quot;)
+  end
+  
+  def newHLRestJob(time)
+    @job.stopJob if @job
+    @job=nil
+    setFire(true)
+    super(time)
+    assignJob2All
+  end
+  
+  def assignJob(man)
+    checkHLJobEnd(man)
+  end  
+  def moveHome(man)
+    if @formation.nil?
+      raise &quot;formation is nil!&quot;
+    end
+    pos=@formation.getPosition(man)
+#     pos=getSitFormation(man)
+    if (man.getPos2D-pos).length&gt;1
+      man.newMoveJob(0,pos,0)
+    else
+      man.newRestJob(2)
+    end
+  end
+  
+  
+  def newHLMoveJob(prio,pos,dist)
+    @job.stopJob if @job
+    @job=AntHeroMoveJob.new(self,prio,pos,dist)
+    assignJob2All
+  end
+  def newHLRecruitJob(target)
+    assert{target!=self}
+    @job.stopJob if @job
+    @job=AntHeroRecruitJob.new(self,target)
+    assignJob2All
+  end
+  def newHLConstructJob(target)
+    @job.stopJob if @job
+    @job=AntHeroConstructJob.new(self,target)
+    assignJob2All
+  end
+  def newHLTakeFoodJob(target)
+    @job.stopJob if @job
+    #puts &quot;take food job #{self} #{target}&quot;
+    @job=AntHeroTakeJob.new(self,target,&quot;food&quot;)
+    assignJob2All
+  end
+  def newHLTakeWeaponJob(target)
+    @job.stopJob if @job
+    @job=AntHeroTakeJob.new(self,target,&quot;weapon&quot;)
+    assignJob2All
+  end
+  def newHLFightJob(target)
+    @job.stopJob if @job
+    @job=AntHeroFightJob.new(self,target)
+    assignJob2All
+  end
+  def newHLFightAnimalJob(target)
+    @job.stopJob if @job
+    @job=AntHeroFightAnimalJob.new(self,target)
+    assignJob2All
+  end
+  def newHLBuildJob(pos,type)
+    @job.stopJob if @job
     
     if pos.is_a?(AGVector2) or pos.is_a?(AGVector3) 
-	    if getMap.getHeight(pos[0],pos[1])&lt;=0
-	      # TODO: should view an error message
-	      messageBox(getMap.getApp,_(&quot;Warning&quot;),_(&quot;You can't build on water.&quot;),MB_OK)
-	      return
-	    end
+      if getMap.getHeight(pos[0],pos[1])&lt;=0
+        # TODO: should view an error message
+        messageBox(getMap.getApp,_(&quot;Warning&quot;),_(&quot;You can't build on water.&quot;),MB_OK)
+        return
+      end
     end
     
-		puts &quot;POSHL:#{pos} #{pos.class}&quot;
-		if pos.is_a?(AGVector2) or pos.is_a?(AGVector3)
-			assert{pos.is_a?(AGVector2) or pos.is_a?(AGVector3)}
-			target=AntBuildingSite.new(getMap)
-			target.setPos(pos)
-			target.building=type
-			getMap.insertEntity(target)
-			@job=AntHeroBuildJob.new(self,target) #pos,type)
-		else
-			assert{pos.is_a?(AntBuildingSite)}
-			@job=AntHeroBuildJob.new(self,pos)
-		end
-		assignJob2All
-	end
-	
-	def newHLDismissJob()
-		@job.stopJob if @job
-		@job=nil
-		agg=getAggression
-		men=@men.select{|m|not m.is_a?(AntHero)} # exclude hero
-		c=(men.length-1)*agg/3
-			
-		men=men[0..c]
-		men.each{|m|
-			# seek new boss
-			b=getMap.getNextList(m,&quot;house&quot;,0).collect{|e|log e,e.class;e.get}.select{|e|e.getPlayer==getPlayer}.shuffle[0]
-			if b
-				m.setBoss(b)
-			else
-				m.setNoBoss
-			end
-			@men.delete(m)
-			m.delJob
-		}
-		getMap.eventHLDismissed(self)
-	end
-	
-	def upgradeMan(man)
-		# copy properties through xml-node	
-		xmlnode=Node.new(&quot;test&quot;)
-		man.setNoBoss
-		man.saveXML(xmlnode)
-		@@tmpName||=1
-		@@tmpName+=1
-		man.setName(&quot;xxxxxxxx #{@@tmpName}&quot;) # reset name - so there's some distinction
-					
-		nhero=AntHero.new
-		nhero.preloadXML(xmlnode)
-		nhero.loadXML(xmlnode)
-		nhero.eventMapChanged
-		removeMan(man)
-		getMap.removeEntity(man)
-		getMap.insertEntity(nhero)
-		#getMap.endChange # commit
-		nhero.newRestJob(0)
-		newHLRestJob(1)
-		#nhero.setName(&quot;Sir &quot;+nhero.getName)
-		nhero.setOwner(self)
-		nhero.experience=0
-	end
-	
-	
-	def setFire(flag)
-		#puts &quot;setFire #{flag}&quot;
-		if flag
-			if getPos3D.z&gt;0 # won't start fire in water!!
-				if not @fire
-					@fire=AntFire.new(getMap)
-					@fire.setPos(getPos3D+AGVector3.new(0.7,0,0))
-					getMap.insertEntity(@fire)
-				end
-				startFireSound
-			end
-		else
-			#raise 1
-			if @fire
-				@fire.disable
-				@fire=false
-			end
-			stopFireSound
-		end
-	end
+    puts &quot;POSHL:#{pos} #{pos.class}&quot;
+    if pos.is_a?(AGVector2) or pos.is_a?(AGVector3)
+      assert{pos.is_a?(AGVector2) or pos.is_a?(AGVector3)}
+      target=AntBuildingSite.new(getMap)
+      target.setPos(pos)
+      target.building=type
+      getMap.insertEntity(target)
+      @job=AntHeroBuildJob.new(self,target) #pos,type)
+    else
+      assert{pos.is_a?(AntBuildingSite)}
+      @job=AntHeroBuildJob.new(self,pos)
+    end
+    assignJob2All
+  end
+  
+  def newHLDismissJob()
+    @job.stopJob if @job
+    @job=nil
+    agg=getAggression
+    men=@men.select{|m|not m.is_a?(AntHero)} # exclude hero
+    c=(men.length-1)*agg/3
+      
+    men=men[0..c]
+    men.each{|m|
+      # seek new boss
+      b=getMap.getNextList(m,&quot;house&quot;,0).collect{|e|log e,e.class;e.get}.select{|e|e.getPlayer==getPlayer}.shuffle[0]
+      if b
+        m.setBoss(b)
+      else
+        m.setNoBoss
+      end
+      @men.delete(m)
+      m.delJob
+    }
+    getMap.eventHLDismissed(self)
+  end
+  
+  def upgradeMan(man)
+    # copy properties through xml-node  
+    xmlnode=Node.new(&quot;test&quot;)
+    man.setNoBoss
+    man.saveXML(xmlnode)
+    @@tmpName||=1
+    @@tmpName+=1
+    man.setName(&quot;xxxxxxxx #{@@tmpName}&quot;) # reset name - so there's some distinction
+          
+    nhero=AntHero.new
+    nhero.preloadXML(xmlnode)
+    nhero.loadXML(xmlnode)
+    nhero.eventMapChanged
+    removeMan(man)
+    getMap.removeEntity(man)
+    getMap.insertEntity(nhero)
+    #getMap.endChange # commit
+    nhero.newRestJob(0)
+    newHLRestJob(1)
+    #nhero.setName(&quot;Sir &quot;+nhero.getName)
+    nhero.setOwner(self)
+    nhero.experience=0
+  end
+  
+  
+  def setFire(flag)
+    #puts &quot;setFire #{flag}&quot;
+    if flag
+      if getPos3D.z&gt;0 # won't start fire in water!!
+        if not @fire
+          @fire=AntFire.new(getMap)
+          @fire.setPos(getPos3D+AGVector3.new(0.7,0,0))
+          getMap.insertEntity(@fire)
+        end
+        startFireSound
+      end
+    else
+      #raise 1
+      if @fire
+        @fire.disable
+        @fire=false
+      end
+      stopFireSound
+    end
+  end
 
-	def eventAttacked(by)
-		#puts &quot;eventAttacked #{by}&quot;
-		super
-	end
-	
-	def assignJob2All
-		super
-		#puts &quot;ASSIGN JOB 2 All #{self}&quot;
-		#puts &quot;---&quot;
-		if @job.class!=AntHeroRestJob
-			setFire(false)
-		end
-		doEvent(:newJobAssigned)
-		#puts &quot;ASSIGN JOB ready.&quot;
-	end
+  def eventAttacked(by)
+    #puts &quot;eventAttacked #{by}&quot;
+    super
+  end
+  
+  def assignJob2All
+    super
+    #puts &quot;ASSIGN JOB 2 All #{self}&quot;
+    #puts &quot;---&quot;
+    if @job.class!=AntHeroRestJob
+      setFire(false)
+    end
+    doEvent(:newJobAssigned)
+    #puts &quot;ASSIGN JOB ready.&quot;
+  end
 
-	def setMeshState(name)
+  def setMeshState(name)
 
-		if name==&quot;row&quot;
-			name=&quot;walk&quot;
-		end
+    if name==&quot;row&quot;
+      name=&quot;walk&quot;
+    end
 
-		@origMeshState=name
-		name=checkOnWater(name)
-		@meshState=name
-		dir=getDirection
-		case name
-			when &quot;row&quot;
-				setMesh
-				addMesh(AntModels.createModel(self,:boat),AGVector3.new(0,0,0))
-			when &quot;dead&quot;
-				setMesh(:grave_hero)
-			else
-				setMesh
-		end
-		setDirection(dir)
-		setupRing
+    @origMeshState=name
+    name=checkOnWater(name)
+    @meshState=name
+    dir=getDirection
+    case name
+      when &quot;row&quot;
+        setMesh
+        addMesh(AntModels.createModel(self,:boat),AGVector3.new(0,0,0))
+      when &quot;dead&quot;
+        setMesh(:grave_hero)
+      else
+        setMesh
+    end
+    setDirection(dir)
+    setupRing
 
-	end
+  end
 
 
 
- 	def setupMesh
-		setMeshState(&quot;normal&quot;)
-	end
-	def getRing
-		makeRingMesh
-	end
+   def setupMesh
+    setMeshState(&quot;normal&quot;)
+  end
+  def getRing
+    makeRingMesh
+  end
 
-	def getHero
-		self
-	end
+  def getHero
+    self
+  end
 
-	def getImage
-		@portrait||=&quot;&quot;
-		r=nil
+  def getImage
+    @portrait||=&quot;&quot;
+    r=nil
 
-		filename=&quot;&quot;
-		if @portrait.length!=0
-			filename=@portrait
-			#r=getTextureCache.get(@portrait)
-		else
-			log &quot;no portrait defined&quot;
-			filename=&quot;data/gui/portraits/#{getName}.png&quot;
-		end
-		if fileExists(filename)
-			r=getTextureCache.get(filename)
-		else
-			r=getTextureCache.get(&quot;data/gui/portraits/none.png&quot;)
-		end
+    filename=&quot;&quot;
+    if @portrait.length!=0
+      filename=@portrait
+      #r=getTextureCache.get(@portrait)
+    else
+      log &quot;no portrait defined&quot;
+      filename=&quot;data/gui/portraits/#{getName}.png&quot;
+    end
+    if fileExists(filename)
+      r=getTextureCache.get(filename)
+    else
+      r=getTextureCache.get(&quot;data/gui/portraits/none.png&quot;)
+    end
 
-		return r
-	end
-	def getDescription
-		nameage=_(&quot;This is {1}. He is {2} years old.&quot;,getName,age)
-		support=nil
-		if getMen.length==1
-			support=_(&quot;Nobody supports him.&quot;)
-		else
-			support=_(&quot;{1} men support him.&quot;,getMen.length-1)
-		end
-		nameage+&quot; &quot;+support
-	end
+    return r
+  end
+  def getDescription
+    nameage=_(&quot;This is {1}. He is {2} years old.&quot;,getName,age)
+    support=nil
+    if getMen.length==1
+      support=_(&quot;Nobody supports him.&quot;)
+    else
+      support=_(&quot;{1} men support him.&quot;,getMen.length-1)
+    end
+    nameage+&quot; &quot;+support
+  end
 
-	def spreadResources
-		# FIXME
-	end
+  def spreadResources
+    # FIXME
+  end
 
-	def eventDie
-		super
-		setFire(false)
-		@job=nil
-		if @player
-			@player.remove(self)
-		end
-		getMap.eventHeroDied(self)
-	end
+  def eventDie
+    super
+    setFire(false)
+    @job=nil
+    if @player
+      @player.remove(self)
+    end
+    getMap.eventHeroDied(self)
+  end
 
 end
 

Modified: antargis/trunk/ruby/entities/ant_house.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_house.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_house.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -22,26 +22,26 @@
 require 'ant_tools.rb'
 
 class AntFlag&lt;AntRubyEntity
-	def initialize(map)
-		super
-		setProvide(&quot;flag&quot;,true)
-		@age=0
-	end
-	def getTexture
-		return &quot;flag&quot;
-	end
+  def initialize(map)
+    super
+    setProvide(&quot;flag&quot;,true)
+    @age=0
+  end
+  def getTexture
+    return &quot;flag&quot;
+  end
 end
 
 
 # AntVillage is only some small interface for reproducing &quot;village&quot; type of behaviour
 class AntVillage
-	attr_reader :houses
-	def initialize(name,map)
-		@houses=map.getHousesOfVillage(name)		
-	end
-	def getTrooperCount
-		@houses.collect{|h|h.getMen.length}.inject{|a,b|a+b}
-	end
+  attr_reader :houses
+  def initialize(name,map)
+    @houses=map.getHousesOfVillage(name)    
+  end
+  def getTrooperCount
+    @houses.collect{|h|h.getMen.length}.inject{|a,b|a+b}
+  end
 end
 
 # AntHouse is the base class for all building types
@@ -49,324 +49,324 @@
 # * defending
 # * fetching resources
 class AntHouse&lt;AntBoss
-	attr_reader :village
+  attr_reader :village
 
-	def AntHouse.buildSteps
-		20
-	end
-	def AntHouse.buildResources
-		{&quot;stone&quot;=&gt;2,&quot;wood&quot;=&gt;2}
-	end
+  def AntHouse.buildSteps
+    20
+  end
+  def AntHouse.buildResources
+    {&quot;stone&quot;=&gt;2,&quot;wood&quot;=&gt;2}
+  end
 
 
-	def initialize(map)
-		super
-		@type=3
-		setProvide(&quot;house&quot;,true)
-		@defeated=[]
-		@atHome=Set.new
-		setMinimapColor(AGColor.new(0x55,0x55,0x55))
-		setMinimapSize(5)
+  def initialize(map)
+    super
+    @type=3
+    setProvide(&quot;house&quot;,true)
+    @defeated=[]
+    @atHome=Set.new
+    setMinimapColor(AGColor.new(0x55,0x55,0x55))
+    setMinimapSize(5)
 
-		@mode=&quot;&quot;
-		@village=&quot;&quot;		
-	end
-	
-	def removeMan(man)
-		@atHome.delete(man)
-		super
-	end
-	################################
-	# Viewing,etc.
-	################################
-	
-	######################################
-	# EVENTS
-	######################################
-	
-	def eventJobFinished
-		#checkBirth
-		newRestJob(2)
-		if @job
-			checkHLJobEnd(self)
-		else
-			process
-		end
-	end
+    @mode=&quot;&quot;
+    @village=&quot;&quot;    
+  end
+  
+  def removeMan(man)
+    @atHome.delete(man)
+    super
+  end
+  ################################
+  # Viewing,etc.
+  ################################
+  
+  ######################################
+  # EVENTS
+  ######################################
+  
+  def eventJobFinished
+    #checkBirth
+    newRestJob(2)
+    if @job
+      checkHLJobEnd(self)
+    else
+      process
+    end
+  end
 
-	def process
-	end
-	
-	def eventGotHLFight(hero)
-		puts &quot;IGNORING eventGotHLFight in ant_house&quot;
-	end
-	
-	def eventAttacked(by)
-		return unless super
-		# FIXME: defend as village
-		if @village and @village.length
-			v=AntVillage.new(@village,getMap)
-			if v
-				v.houses.each{|h|
-					if h!=self
-						h.eventAttacked(by)
-					end
-				}
-			end
-		end
-	end
-	
-	def moveHome(man)
-		pos=getPos2D
-		if (man.getPos2D-pos).length&gt;1
-			man.newMoveJob(0,pos,0)
-		else
-			man.newRestJob(2)
-		end
+  def process
+  end
+  
+  def eventGotHLFight(hero)
+    puts &quot;IGNORING eventGotHLFight in ant_house&quot;
+  end
+  
+  def eventAttacked(by)
+    return unless super
+    # FIXME: defend as village
+    if @village and @village.length
+      v=AntVillage.new(@village,getMap)
+      if v
+        v.houses.each{|h|
+          if h!=self
+            h.eventAttacked(by)
+          end
+        }
+      end
+    end
+  end
+  
+  def moveHome(man)
+    pos=getPos2D
+    if (man.getPos2D-pos).length&gt;1
+      man.newMoveJob(0,pos,0)
+    else
+      man.newRestJob(2)
+    end
 
-	end
-	
-	def eventNoJob
-		super
-		eventJobFinished
-	end
-	
-	def noHLJob
-	end
-	
-	def setOwner(owner)
-		super(owner)
-		addFlag(owner)
-	end
-	
-		
-	def assignJob(e)
-		if @job==nil then
-			normalFetching(e)
-		else
-			checkHLJobEnd(e)
-		end
-	end
-	
-	# does assign job, too
-	def checkHLJobEnd(man)
-		if @job
-			@job.check(man) 
-			if @job.finished then 
-				if @player
-					@player.eventJobFinished(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">self, at job</A>)
-				end
-				@job=nil 
-			end
-		end
-	end
+  end
+  
+  def eventNoJob
+    super
+    eventJobFinished
+  end
+  
+  def noHLJob
+  end
+  
+  def setOwner(owner)
+    super(owner)
+    addFlag(owner)
+  end
+  
+    
+  def assignJob(e)
+    if @job==nil then
+      normalFetching(e)
+    else
+      checkHLJobEnd(e)
+    end
+  end
+  
+  # does assign job, too
+  def checkHLJobEnd(man)
+    if @job
+      @job.check(man) 
+      if @job.finished then 
+        if @player
+          @player.eventJobFinished(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">self, at job</A>)
+        end
+        @job=nil 
+      end
+    end
+  end
 
-	# &quot;normalFetching&quot; is the current implementation for fetching resources of any kind
-	# this includes:
-	# * go to tree
-	# * chop tree
-	# * carry goods home
-	# * rest some time
-	# e: an entity - should be a man of this house
-	def normalFetching(e)
-		if atHome(e) then
-			@atHome.push(e)
-			if checkFood(e)
-				e.newRestJob(3) # wait some time
-				return
-			end
-			if e.getMode==&quot;resting&quot;
-				e.setMode(&quot;&quot;)
-				e.setMeshState(&quot;stand&quot;)
-				# is home:
-				# 1) take everything from inventory
-				resource.takeAll(e.resource)
-				resourceChanged
-				# 2) give job
-				need=neededStock
-				fetchForStock(need,e)
-			else
-				e.setMode(&quot;resting&quot;)
-				e.newRestJob(5+getRand)
-			end	
-		elsif e.getMode=~/fetching/
-			# check if target is somehow to far away
-			if (e.target.getPos2D-e.getPos2D).length&gt;2
-				e.setMode(&quot;homing&quot;)
-				e.newMoveJob(0,getPos2D,0)
-				return
-			end
-			res=e.getMode.gsub(/.* /,&quot;&quot;)
-			e.digResource(res)
-			e.setMode(&quot;digging &quot;+res)
-		elsif e.getMode=~/digging/
-			# digging ready - take home
-			e.newMoveJob(0,getPos2D,0)
-			res=e.getMode.gsub(/.* /,&quot;&quot;)
-			e.setMode(&quot;homing&quot;)
-			# take resource
-			return if e.target.nil? # FIXME: error while loading
-			e.collectResource(res)
-			amount=[e.target.resource.get(res),e.canCarry].min
-			e.target.resource.sub(res,amount)
-			e.target.resourceChanged
-			e.resource.add(res,amount)
-		elsif e.getMode==&quot;homing&quot;
-			e.newRestJob(1) # always rest a little
-			e.setMode(&quot;&quot;)
-		else
-			# is anywhere - come home
-			e.newMoveJob(0,getPos2D,0)#,false)
-		end
-	end
-	
-	# says if entity is at home
-	def atHome(entity)
-		pd=entity.getPos2D-getPos2D
-		n=pd.length2 #norm2
-		return n&lt;1
-	end
-	
-	def neededStock
-		{&quot;wood&quot;=&gt;15,&quot;stone&quot;=&gt;15,&quot;food&quot;=&gt;15}
-	end
+  # &quot;normalFetching&quot; is the current implementation for fetching resources of any kind
+  # this includes:
+  # * go to tree
+  # * chop tree
+  # * carry goods home
+  # * rest some time
+  # e: an entity - should be a man of this house
+  def normalFetching(e)
+    if atHome(e) then
+      @atHome.push(e)
+      if checkFood(e)
+        e.newRestJob(3) # wait some time
+        return
+      end
+      if e.getMode==&quot;resting&quot;
+        e.setMode(&quot;&quot;)
+        e.setMeshState(&quot;stand&quot;)
+        # is home:
+        # 1) take everything from inventory
+        resource.takeAll(e.resource)
+        resourceChanged
+        # 2) give job
+        need=neededStock
+        fetchForStock(need,e)
+      else
+        e.setMode(&quot;resting&quot;)
+        e.newRestJob(5+getRand)
+      end  
+    elsif e.getMode=~/fetching/
+      # check if target is somehow to far away
+      if (e.target.getPos2D-e.getPos2D).length&gt;2
+        e.setMode(&quot;homing&quot;)
+        e.newMoveJob(0,getPos2D,0)
+        return
+      end
+      res=e.getMode.gsub(/.* /,&quot;&quot;)
+      e.digResource(res)
+      e.setMode(&quot;digging &quot;+res)
+    elsif e.getMode=~/digging/
+      # digging ready - take home
+      e.newMoveJob(0,getPos2D,0)
+      res=e.getMode.gsub(/.* /,&quot;&quot;)
+      e.setMode(&quot;homing&quot;)
+      # take resource
+      return if e.target.nil? # FIXME: error while loading
+      e.collectResource(res)
+      amount=[e.target.resource.get(res),e.canCarry].min
+      e.target.resource.sub(res,amount)
+      e.target.resourceChanged
+      e.resource.add(res,amount)
+    elsif e.getMode==&quot;homing&quot;
+      e.newRestJob(1) # always rest a little
+      e.setMode(&quot;&quot;)
+    else
+      # is anywhere - come home
+      e.newMoveJob(0,getPos2D,0)#,false)
+    end
+  end
+  
+  # says if entity is at home
+  def atHome(entity)
+    pd=entity.getPos2D-getPos2D
+    n=pd.length2 #norm2
+    return n&lt;1
+  end
+  
+  def neededStock
+    {&quot;wood&quot;=&gt;15,&quot;stone&quot;=&gt;15,&quot;food&quot;=&gt;15}
+  end
 
 
-# 	# assigns ent a job for fetching good from a enttype
-# 	def fetch(good,ent)
-# 		tent=getMap.getNext(self,good,1)
-# 		if tent == nil then
-# 			puts &quot;nothing found&quot;
-# 			ent.newRestJob(4)
-# 		else
-# 			puts &quot;#{tent.getPlayer} #{getPlayer}&quot;
-# 			if tent.getPlayer!=getPlayer and (not tent.getPlayer.nil?)
-# 			else
-# 				ent.newMoveJob(0,tent.getPos2D,0.5)
-# 				ent.setMode(&quot;fetching &quot;+good)
-# 				@atHome.delete(ent)
-# 				ent.target=tent
-# 				ent.setVisible(true)
-# 			end
-# 		end
-# 	end
+#   # assigns ent a job for fetching good from a enttype
+#   def fetch(good,ent)
+#     tent=getMap.getNext(self,good,1)
+#     if tent == nil then
+#       puts &quot;nothing found&quot;
+#       ent.newRestJob(4)
+#     else
+#       puts &quot;#{tent.getPlayer} #{getPlayer}&quot;
+#       if tent.getPlayer!=getPlayer and (not tent.getPlayer.nil?)
+#       else
+#         ent.newMoveJob(0,tent.getPos2D,0.5)
+#         ent.setMode(&quot;fetching &quot;+good)
+#         @atHome.delete(ent)
+#         ent.target=tent
+#         ent.setVisible(true)
+#       end
+#     end
+#   end
 
-	# assigns ent a job for fetching good from a enttype
-	def fetchForStock(need,ent)
-		#puts &quot;fetchForStock&quot;
-		needmap=need
-		need=need.to_a
-		need=need.shuffle
+  # assigns ent a job for fetching good from a enttype
+  def fetchForStock(need,ent)
+    #puts &quot;fetchForStock&quot;
+    needmap=need
+    need=need.to_a
+    need=need.shuffle
 
-		# FIXME: check need and has !
+    # FIXME: check need and has !
 
-		oneed=need
+    oneed=need
 
-		need.collect!{|a|a[1]-=resource.get(a[0]) ; a}
-		need=need.sort!{|a,b|b[1]&lt;=&gt;a[1]} # sort descending in array
+    need.collect!{|a|a[1]-=resource.get(a[0]) ; a}
+    need=need.sort!{|a,b|b[1]&lt;=&gt;a[1]} # sort descending in array
 
-		factor=2
-		if @mode==&quot;rest&quot;
-			factor=1
-		end
-		need.each{|goodArray|
-			good=goodArray[0]
-			if goodArray[1]&gt;0 or (goodArray[1]&gt;-needmap[good]*0.5 and @mode==&quot;fetch&quot;) 
-				@mode=&quot;fetch&quot;
-				tent=nil
-				if good==&quot;food&quot;
-					tent=getMap.getNext(self,good,11) # don't take away food
-				else
-					tent=getMap.getNext(self,good,1)
-				end
-			
-				if tent
-					if tent.getPlayer!=getPlayer and (not tent.getPlayer.nil?)
-					else
-						ent.newMoveJob(0,tent.getPos2D,0.5)
-						ent.setMode(&quot;fetching &quot;+good)
-						@atHome.delete(ent)
-						ent.target=tent
-						ent.setVisible(true)
-						return
-					end
-				end
-			end
-			#raise 1 if good==&quot;crop&quot;
-		}
-		@mode=&quot;rest&quot;
-		ent.newRestJob(5) # do nothing for a longer time
-	end
+    factor=2
+    if @mode==&quot;rest&quot;
+      factor=1
+    end
+    need.each{|goodArray|
+      good=goodArray[0]
+      if goodArray[1]&gt;0 or (goodArray[1]&gt;-needmap[good]*0.5 and @mode==&quot;fetch&quot;) 
+        @mode=&quot;fetch&quot;
+        tent=nil
+        if good==&quot;food&quot;
+          tent=getMap.getNext(self,good,11) # don't take away food
+        else
+          tent=getMap.getNext(self,good,1)
+        end
+      
+        if tent
+          if tent.getPlayer!=getPlayer and (not tent.getPlayer.nil?)
+          else
+            ent.newMoveJob(0,tent.getPos2D,0.5)
+            ent.setMode(&quot;fetching &quot;+good)
+            @atHome.delete(ent)
+            ent.target=tent
+            ent.setVisible(true)
+            return
+          end
+        end
+      end
+      #raise 1 if good==&quot;crop&quot;
+    }
+    @mode=&quot;rest&quot;
+    ent.newRestJob(5) # do nothing for a longer time
+  end
 
-	
-	########################################
-	# LOADING &amp; SAVING
-	########################################
-	
-	def loadXML(node)
-		super(node)
-		setPos(getPos2D) # set to ground
-		if getName==&quot;&quot;
-			setName(getRand.to_s)
-		end
-		@village=node.get(&quot;village&quot;)
-	end	
+  
+  ########################################
+  # LOADING &amp; SAVING
+  ########################################
+  
+  def loadXML(node)
+    super(node)
+    setPos(getPos2D) # set to ground
+    if getName==&quot;&quot;
+      setName(getRand.to_s)
+    end
+    @village=node.get(&quot;village&quot;)
+  end  
 
-	def saveXML(node)
-		super
-		node.set(&quot;village&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at village</A>)
-	end
+  def saveXML(node)
+    super
+    node.set(&quot;village&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at village</A>)
+  end
 
 
-	# get a description for displaying in the info-box
-	def getDescription
-		m=&quot;man&quot;
-		home=_(&quot;{1} of them are at home.&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at atHome.uniq.length</A>)
-		if getMen.length&gt;1
-			m=&quot;men&quot;
-		end
+  # get a description for displaying in the info-box
+  def getDescription
+    m=&quot;man&quot;
+    home=_(&quot;{1} of them are at home.&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at atHome.uniq.length</A>)
+    if getMen.length&gt;1
+      m=&quot;men&quot;
+    end
 
-		r=_(&quot;This is a {1}. It was build {2} years ago. Currently {3} {4} live here.&quot;,_(houseType),age,getMen.length,_(m))+home
+    r=_(&quot;This is a {1}. It was build {2} years ago. Currently {3} {4} live here.&quot;,_(houseType),age,getMen.length,_(m))+home
 
-		morale=0
-		@men.each{|m|morale+=m.getMorale}
-		if @men.length&gt;0
-			morale/=@men.length
-		end
-		if morale&gt;0.8
-			s=_(&quot;in good mood.&quot;)
-		elsif morale&gt;0.5
-			s=_(&quot;content.&quot;)
-		elsif morale&gt;0.2
-			s=_(&quot;discontent.&quot;)
-		else
-			s=_(&quot;bad tempered.&quot;)
-		end
-		r+=_(&quot;They are {1}&quot;,_(s))
-		r
-	end
+    morale=0
+    @men.each{|m|morale+=m.getMorale}
+    if @men.length&gt;0
+      morale/=@men.length
+    end
+    if morale&gt;0.8
+      s=_(&quot;in good mood.&quot;)
+    elsif morale&gt;0.5
+      s=_(&quot;content.&quot;)
+    elsif morale&gt;0.2
+      s=_(&quot;discontent.&quot;)
+    else
+      s=_(&quot;bad tempered.&quot;)
+    end
+    r+=_(&quot;They are {1}&quot;,_(s))
+    r
+  end
 
 protected
-	def houseType
-		&quot;house&quot;
-	end
+  def houseType
+    &quot;house&quot;
+  end
 
 private
-	# check if my man has enough food otherwise I'll feed him
-	def checkFood(man)
-		if man.getFood&lt;0.5
-			# eat
-			if resource.get(&quot;food&quot;)&gt;1
-				man.incFood(1)
-				resource.sub(&quot;food&quot;,1)
-				return true
-			end
-		end
-		return false
-	end
+  # check if my man has enough food otherwise I'll feed him
+  def checkFood(man)
+    if man.getFood&lt;0.5
+      # eat
+      if resource.get(&quot;food&quot;)&gt;1
+        man.incFood(1)
+        resource.sub(&quot;food&quot;,1)
+        return true
+      end
+    end
+    return false
+  end
 
-	# add a new flag when owner has changed - currently not implemented
-	def addFlag(owner)
-	end
+  # add a new flag when owner has changed - currently not implemented
+  def addFlag(owner)
+  end
 
 end

Modified: antargis/trunk/ruby/entities/ant_man.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_man.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_man.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -22,343 +22,343 @@
 require 'ant_config.rb'
 
 def genName
-	nstart=[&quot;Ban&quot;,&quot;Gor&quot;,&quot;Bal&quot;,&quot;Da&quot;,&quot;Arg&quot;,&quot;Ol&quot;,&quot;Gar&quot;,&quot;Hek&quot;,&quot;Gav&quot;]
-	nend=[&quot;dor&quot;,&quot;in&quot;,&quot;and&quot;,&quot;or&quot;,&quot;tor&quot;,&quot;ain&quot;,&quot;yn&quot;]
-	nstart.shuffle[0]+nend.shuffle[0]
+  nstart=[&quot;Ban&quot;,&quot;Gor&quot;,&quot;Bal&quot;,&quot;Da&quot;,&quot;Arg&quot;,&quot;Ol&quot;,&quot;Gar&quot;,&quot;Hek&quot;,&quot;Gav&quot;]
+  nend=[&quot;dor&quot;,&quot;in&quot;,&quot;and&quot;,&quot;or&quot;,&quot;tor&quot;,&quot;ain&quot;,&quot;yn&quot;]
+  nstart.shuffle[0]+nend.shuffle[0]
 end
 
 
 class AntMan&lt;AntRubyEntity
-	include AntManBase
+  include AntManBase
 
-	attr_reader :meshState, :dead
-	attr_accessor :target
+  attr_reader :meshState, :dead
+  attr_accessor :target
 
-	attr_accessor :hlJobMode
-	
-	def initialize(map)
-		super
+  attr_accessor :hlJobMode
+  
+  def initialize(map)
+    super
 
-		@hlJobMode={}
+    @hlJobMode={}
 
-		setProvide(&quot;man&quot;,true)
-		@signed=false
-		@dead=false
-		@fighting=false
-		@bossName=&quot;&quot;
-		@boss=nil
-		setMeshState(&quot;walk&quot;)
-		@mode=&quot;wait&quot;
-		setMinimapColor(AGColor.new(0x77,0x77,0x77))
-		setName(genName)
+    setProvide(&quot;man&quot;,true)
+    @signed=false
+    @dead=false
+    @fighting=false
+    @bossName=&quot;&quot;
+    @boss=nil
+    setMeshState(&quot;walk&quot;)
+    @mode=&quot;wait&quot;
+    setMinimapColor(AGColor.new(0x77,0x77,0x77))
+    setName(genName)
 
-		#resource.set(&quot;sword&quot;,1)
-		checkResources
-		self.age=(getRand*20+15)
-		setHunger(0.006)
-	end
-	
-	##########################
-	# EVENTS
-	##########################
-	def eventNoJob
-		super
-		eventJobFinished
-	end
-	
-	
-	# Job was finished
-	# 1) if no energy or dead: simDeath
-	def eventJobFinished
-		setVisible(true)
-		super
-		if getEnergy==0 or @dead then
-			simDeath
-			return
-		end
-		
-		setFighting(false)
-		
-		if @boss.nil?
-			if @bossName==&quot;&quot; then
-			
-				house=getMap.getNext(self,&quot;house&quot;)
-				if house
-					houseName=house.getName
-					if houseName==&quot;&quot; then
-						dputs &quot;ERROR House has no name!&quot;
-						exit
-					end
-					@bossName=houseName
-					newRestJob(getRand*2)
-					#house=getMap.getRuby(house)
-					house.signUp(self)
-					@signed=true
-				end
-			else
-				boss=getMap.getByName(@bossName)
-				if not boss
-					@bossName=&quot;&quot;
-					return
-				end
-				@boss=boss
-			end
-			puts &quot;BOSS:#{@boss}&quot;
-		end
-		if @boss and not @signed then
-			@boss.signUp(self)
-			@signed=true
-		end
-		if @boss
-			@boss.assignJob(self)
-		end
-	end	
+    #resource.set(&quot;sword&quot;,1)
+    checkResources
+    self.age=(getRand*20+15)
+    setHunger(0.006)
+  end
+  
+  ##########################
+  # EVENTS
+  ##########################
+  def eventNoJob
+    super
+    eventJobFinished
+  end
+  
+  
+  # Job was finished
+  # 1) if no energy or dead: simDeath
+  def eventJobFinished
+    setVisible(true)
+    super
+    if getEnergy==0 or @dead then
+      simDeath
+      return
+    end
+    
+    setFighting(false)
+    
+    if @boss.nil?
+      if @bossName==&quot;&quot; then
+      
+        house=getMap.getNext(self,&quot;house&quot;)
+        if house
+          houseName=house.getName
+          if houseName==&quot;&quot; then
+            dputs &quot;ERROR House has no name!&quot;
+            exit
+          end
+          @bossName=houseName
+          newRestJob(getRand*2)
+          #house=getMap.getRuby(house)
+          house.signUp(self)
+          @signed=true
+        end
+      else
+        boss=getMap.getByName(@bossName)
+        if not boss
+          @bossName=&quot;&quot;
+          return
+        end
+        @boss=boss
+      end
+      puts &quot;BOSS:#{@boss}&quot;
+    end
+    if @boss and not @signed then
+      @boss.signUp(self)
+      @signed=true
+    end
+    if @boss
+      @boss.assignJob(self)
+    end
+  end  
 
-	def eventHaveDefeated(e)
-		if newHLJobs
-			eventNoJob
-		else
-			@boss.eventHaveDefeated(e)
-		end
-	end
+  def eventHaveDefeated(e)
+    if newHLJobs
+      eventNoJob
+    else
+      @boss.eventHaveDefeated(e)
+    end
+  end
 
-	def getPlayer
-		if @boss
-			@boss.getPlayer
-		else
-			nil
-		end
-	end
+  def getPlayer
+    if @boss
+      @boss.getPlayer
+    else
+      nil
+    end
+  end
 
-	##########################
-	# setBoss
-	##########################
-	def setNoBoss()
-		if @boss
-			@boss.removeMan(self)
-		end
-		@bossName=&quot;&quot;
-		@boss=nil
-	end
-	
-	def setBoss(hero)
-		return if @boss==hero
-		if @boss
-			@boss.removeMan(self)
-			@boss=nil
-		end
-		if hero.nil?
-			setNoBoss
-			return	
-		end
-		@bossName=hero.getName
-		@boss=hero
-		hero.signUp(self)
-	end
+  ##########################
+  # setBoss
+  ##########################
+  def setNoBoss()
+    if @boss
+      @boss.removeMan(self)
+    end
+    @bossName=&quot;&quot;
+    @boss=nil
+  end
+  
+  def setBoss(hero)
+    return if @boss==hero
+    if @boss
+      @boss.removeMan(self)
+      @boss=nil
+    end
+    if hero.nil?
+      setNoBoss
+      return  
+    end
+    @bossName=hero.getName
+    @boss=hero
+    hero.signUp(self)
+  end
 
-	
-	def checkHideAtHome
-		if @boss
-			if @boss.methods.member?(&quot;atHome&quot;) and @boss.class!=AntHero
-				if @boss.atHome(self)
-					return true
-				end
-			end
-		end
-		return false
-	end
-	
-	def newRestJob(time,working=false)
-		vis=checkHideAtHome
-		setStandAnim
-		super(time,working)
-	end
-	
-	def newFightJob(d,ptarget)
-		checkResources
-		super
-		@moving=true
-		setMeshState(&quot;fight&quot;)
-	end
-	
-	def newFetchJob(p,target,r)
-		super
-		setGoAnim
-	end
+  
+  def checkHideAtHome
+    if @boss
+      if @boss.methods.member?(&quot;atHome&quot;) and @boss.class!=AntHero
+        if @boss.atHome(self)
+          return true
+        end
+      end
+    end
+    return false
+  end
+  
+  def newRestJob(time,working=false)
+    vis=checkHideAtHome
+    setStandAnim
+    super(time,working)
+  end
+  
+  def newFightJob(d,ptarget)
+    checkResources
+    super
+    @moving=true
+    setMeshState(&quot;fight&quot;)
+  end
+  
+  def newFetchJob(p,target,r)
+    super
+    setGoAnim
+  end
 
-	def newMoveJob(p,target,n)
-		if isOnWater and isOnOpenWater(target) and (not haveBoat)
-			newRestJob(2)
-			return
-		end
+  def newMoveJob(p,target,n)
+    if isOnWater and isOnOpenWater(target) and (not haveBoat)
+      newRestJob(2)
+      return
+    end
 
-		super
-		setGoAnim
-	end
-	
-	def setGoAnim
-		setMeshState(&quot;walk&quot;)
-	end
-	
-	def setStandAnim
-		setMeshState(&quot;stand&quot;)
-	end
-	
-	def setFighting(v)
-		@fighting=v
-	end
+    super
+    setGoAnim
+  end
+  
+  def setGoAnim
+    setMeshState(&quot;walk&quot;)
+  end
+  
+  def setStandAnim
+    setMeshState(&quot;stand&quot;)
+  end
+  
+  def setFighting(v)
+    @fighting=v
+  end
 
-	def getWeapon
-		if resource.get(&quot;bow&quot;)&gt;0
-			return &quot;bow&quot;
-		end
-		if resource.get(&quot;sword&quot;)==0
-			return &quot;dagger&quot;
-		elsif resource.get(&quot;shield&quot;)==0
-			&quot;sword&quot;
-		else
-			&quot;shield&quot;
-		end
-	end
+  def getWeapon
+    if resource.get(&quot;bow&quot;)&gt;0
+      return &quot;bow&quot;
+    end
+    if resource.get(&quot;sword&quot;)==0
+      return &quot;dagger&quot;
+    elsif resource.get(&quot;shield&quot;)==0
+      &quot;sword&quot;
+    else
+      &quot;shield&quot;
+    end
+  end
 
-	def setMeshState(name)
-		# FIXME: get MeshState somehow from job and resource-contents ???
-		if name==&quot;row&quot;
-			name=&quot;walk&quot;
-		end
+  def setMeshState(name)
+    # FIXME: get MeshState somehow from job and resource-contents ???
+    if name==&quot;row&quot;
+      name=&quot;walk&quot;
+    end
 
 
-		if @meshState==&quot;dead&quot;
-			puts &quot;ERROR in setMeshState&quot;
-			puts name
-		end
-		@origMeshState=name
-		name=checkOnWater(name)
-		@meshState=name
-		dir=getDirection
-		case name
-			when &quot;fight&quot;
-				if @moving
-					setMesh(&quot;walk&quot;)
-					getFirstMesh.setAnimation(&quot;walk&quot;)
-				else
-					#	raise 1
-					puts &quot;name:#{name}&quot;
-					assert{[&quot;dagger&quot;,&quot;shield&quot;,&quot;sword&quot;,&quot;bow&quot;].member?(getWeapon)}
-					setMesh(&quot;fight_&quot;+getWeapon)
-				end
-			when &quot;dead&quot;
-				setMesh(:grave)
-			when &quot;row&quot;
-				mesh=setMesh(&quot;sit&quot;)
-				mesh.setAnimation(&quot;sit&quot;)
-				addMesh(AntModels.createModel(self,:boat),AGVector3.new(0,0,0))
-			when &quot;stand&quot;,&quot;axe&quot;,&quot;pick&quot;,&quot;wood&quot;,&quot;stone&quot;,&quot;flour&quot;,&quot;corn&quot;,&quot;walk&quot;,&quot;sitdown&quot;,&quot;sit&quot;
-				setMesh(name)
-				if [&quot;stand&quot;,&quot;walk&quot;,&quot;sitdown&quot;,&quot;sit&quot;].member?(name)
-					getFirstMesh.setAnimation(name)
-				end
-		end
-		setDirection(dir)
-	end
+    if @meshState==&quot;dead&quot;
+      puts &quot;ERROR in setMeshState&quot;
+      puts name
+    end
+    @origMeshState=name
+    name=checkOnWater(name)
+    @meshState=name
+    dir=getDirection
+    case name
+      when &quot;fight&quot;
+        if @moving
+          setMesh(&quot;walk&quot;)
+          getFirstMesh.setAnimation(&quot;walk&quot;)
+        else
+          #  raise 1
+          puts &quot;name:#{name}&quot;
+          assert{[&quot;dagger&quot;,&quot;shield&quot;,&quot;sword&quot;,&quot;bow&quot;].member?(getWeapon)}
+          setMesh(&quot;fight_&quot;+getWeapon)
+        end
+      when &quot;dead&quot;
+        setMesh(:grave)
+      when &quot;row&quot;
+        mesh=setMesh(&quot;sit&quot;)
+        mesh.setAnimation(&quot;sit&quot;)
+        addMesh(AntModels.createModel(self,:boat),AGVector3.new(0,0,0))
+      when &quot;stand&quot;,&quot;axe&quot;,&quot;pick&quot;,&quot;wood&quot;,&quot;stone&quot;,&quot;flour&quot;,&quot;corn&quot;,&quot;walk&quot;,&quot;sitdown&quot;,&quot;sit&quot;
+        setMesh(name)
+        if [&quot;stand&quot;,&quot;walk&quot;,&quot;sitdown&quot;,&quot;sit&quot;].member?(name)
+          getFirstMesh.setAnimation(name)
+        end
+    end
+    setDirection(dir)
+  end
 
 
-	def digResource(res)
-		newRestJob(2+getRand,true)
-		case res
-			when &quot;wood&quot;
-				setMeshState(&quot;axe&quot;)
-			when &quot;fruit&quot;
-				setMeshState(&quot;stand&quot;)
-			else
-				setMeshState(&quot;pick&quot;)
-		end
-	end
+  def digResource(res)
+    newRestJob(2+getRand,true)
+    case res
+      when &quot;wood&quot;
+        setMeshState(&quot;axe&quot;)
+      when &quot;fruit&quot;
+        setMeshState(&quot;stand&quot;)
+      else
+        setMeshState(&quot;pick&quot;)
+    end
+  end
 
-	def collectResource(res)
-		case res	
-			when &quot;wood&quot;
-				setMeshState(&quot;wood&quot;)
-			when &quot;stone&quot;,&quot;ore&quot;,&quot;coal&quot;,&quot;food&quot;,&quot;corn&quot;,&quot;crop&quot;,&quot;flour&quot; # FIXME new animation for other resources
-				setMeshState(&quot;stone&quot;)
-		end
-	end
+  def collectResource(res)
+    case res  
+      when &quot;wood&quot;
+        setMeshState(&quot;wood&quot;)
+      when &quot;stone&quot;,&quot;ore&quot;,&quot;coal&quot;,&quot;food&quot;,&quot;corn&quot;,&quot;crop&quot;,&quot;flour&quot; # FIXME new animation for other resources
+        setMeshState(&quot;stone&quot;)
+    end
+  end
 
-	def eventStartMoving
-		@moving=true
-		setMeshState(@meshState)
-		eventJobFinished # call, so that hl-job finish is checked
-	end
-	def eventStartFighting
-		@moving=false
-		setMeshState(@meshState)
-	end
-	
-	def canCarry
-		3
-	end
+  def eventStartMoving
+    @moving=true
+    setMeshState(@meshState)
+    eventJobFinished # call, so that hl-job finish is checked
+  end
+  def eventStartFighting
+    @moving=false
+    setMeshState(@meshState)
+  end
+  
+  def canCarry
+    3
+  end
 
-	def getHero
-		@boss
-	end
-	
-	def saveXML(node)
-		super(node)
-		node.set(&quot;bossName&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at bossName</A>)
-		if @target
-			node.set(&quot;targetEntity&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at target.uid.to_s</A>)
-		end
-	end
-	def preloadXML(node)
-		super
-		@bossName=node.get(&quot;bossName&quot;)
-	end
+  def getHero
+    @boss
+  end
+  
+  def saveXML(node)
+    super(node)
+    node.set(&quot;bossName&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at bossName</A>)
+    if @target
+      node.set(&quot;targetEntity&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at target.uid.to_s</A>)
+    end
+  end
+  def preloadXML(node)
+    super
+    @bossName=node.get(&quot;bossName&quot;)
+  end
 
-	def loadXML(node)
-		super(node)
-		if @bossName!=&quot;&quot;
-			boss=getMap.getByName(@bossName)
-			if boss
-				@boss=boss
-				@boss.signUp(self)
-				@signed=true
-			end
-		end
+  def loadXML(node)
+    super(node)
+    if @bossName!=&quot;&quot;
+      boss=getMap.getByName(@bossName)
+      if boss
+        @boss=boss
+        @boss.signUp(self)
+        @signed=true
+      end
+    end
 
-		if getMap.getPos(getPos2D).z&gt;0
-			setOnWater(false)
-		end
-		if node.get(&quot;targetEntity&quot;)!=&quot;&quot;
-			@target=getMap.getByUID(node.get(&quot;targetEntity&quot;).to_i)
-		end
-	end
-	
-	def animationEvent(name)
-		case name
-			when &quot;hackaxe&quot;,&quot;pick&quot;,&quot;sword&quot;
-				playSound(name)
-			when &quot;ugh&quot;
-				playSound(name)
-			else
-				super
-				#playSound(name)
-		end
-	end
+    if getMap.getPos(getPos2D).z&gt;0
+      setOnWater(false)
+    end
+    if node.get(&quot;targetEntity&quot;)!=&quot;&quot;
+      @target=getMap.getByUID(node.get(&quot;targetEntity&quot;).to_i)
+    end
+  end
+  
+  def animationEvent(name)
+    case name
+      when &quot;hackaxe&quot;,&quot;pick&quot;,&quot;sword&quot;
+        playSound(name)
+      when &quot;ugh&quot;
+        playSound(name)
+      else
+        super
+        #playSound(name)
+    end
+  end
 
-	def eventMoraleLow
-		if @boss
-			setNoBoss
-		end
-	end
-	def getDescription
-		if @boss.nil?
-			bname=_(&quot;nobody&quot;)
-		else
-			bname=@boss.getName
-		end
-		_(&quot;This is {1}. He is {2} years old.&quot;,getName,age)+_(&quot;He obeys {1}.&quot;,bname)
-	end
+  def eventMoraleLow
+    if @boss
+      setNoBoss
+    end
+  end
+  def getDescription
+    if @boss.nil?
+      bname=_(&quot;nobody&quot;)
+    else
+      bname=@boss.getName
+    end
+    _(&quot;This is {1}. He is {2} years old.&quot;,getName,age)+_(&quot;He obeys {1}.&quot;,bname)
+  end
 private
 end
 
-	
\ No newline at end of file
+  
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_manbase.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_manbase.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_manbase.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -24,25 +24,25 @@
 # there is no AntAngel mesh.
 class AntAngel&lt;AntRubyEntity
 
-	def initialize(map)
-		super
-		setProvide(&quot;angel&quot;,true)
-		@age=0
-	end
-	# simply move mesh up
-	# FIXME:
-	# this is very slow - should be removed and replaced by a MoveJob(3d)
-	def move(time)
-		p=getPos3D
-		p.y+=time*20
-		setPos(p)
-		@age+=time
-		if @age&gt;10 then # 10 seconds old
-			# discard
-			getMap.removeEntity(self)
-			#getMap.endChange
-		end
-	end
+  def initialize(map)
+    super
+    setProvide(&quot;angel&quot;,true)
+    @age=0
+  end
+  # simply move mesh up
+  # FIXME:
+  # this is very slow - should be removed and replaced by a MoveJob(3d)
+  def move(time)
+    p=getPos3D
+    p.y+=time*20
+    setPos(p)
+    @age+=time
+    if @age&gt;10 then # 10 seconds old
+      # discard
+      getMap.removeEntity(self)
+      #getMap.endChange
+    end
+  end
 end
 
 # AntManBase is a base-class/module for all men (including heroes)
@@ -53,211 +53,211 @@
 # * shooting arrows
 module AntManBase
 
-	# call this to make a man sitdown
-	# * animation is played
-	# * setMeshState is needed for this
-	def sitDown
-		newRestJob(0.4)
-		setMeshState(&quot;sitdown&quot;)
-	end
+  # call this to make a man sitdown
+  # * animation is played
+  # * setMeshState is needed for this
+  def sitDown
+    newRestJob(0.4)
+    setMeshState(&quot;sitdown&quot;)
+  end
 
-	def lookTo(p)
-		setDirection(180-(p-getPos2D).normalized.getAngle.angle*180.0/Math::PI)
-	end
+  def lookTo(p)
+    setDirection(180-(p-getPos2D).normalized.getAngle.angle*180.0/Math::PI)
+  end
 
-	def walkTo(p)
-		p=p.getPos2D if p.is_a?(AntEntity)
-		newMoveJob(0,p,0)
-	end
-	
-	def standStill
-		newRestJob(2)
-		setMeshState(&quot;stand&quot;)
-	end
+  def walkTo(p)
+    p=p.getPos2D if p.is_a?(AntEntity)
+    newMoveJob(0,p,0)
+  end
+  
+  def standStill
+    newRestJob(2)
+    setMeshState(&quot;stand&quot;)
+  end
 
-	def standStillShort
-		newRestJob(0.1)
-		setMeshState(&quot;stand&quot;)
-	end
+  def standStillShort
+    newRestJob(0.1)
+    setMeshState(&quot;stand&quot;)
+  end
 
-	def sitStill
-		checkEat
-		newRestJob(2)
-		setMeshState(&quot;sit&quot;)
-	end
+  def sitStill
+    checkEat
+    newRestJob(2)
+    setMeshState(&quot;sit&quot;)
+  end
 
 
-	# overrides newFightJob from AntEntity
-	# fighting distance is assigned 1 or 10 
-	# depending on the man having a bow
-	def newFightJob(p,target)
-		if resource.get(&quot;bow&quot;)&gt;0
-			super(p,target,10)
-		else
-			super(p,target,1)
-		end
-	end
+  # overrides newFightJob from AntEntity
+  # fighting distance is assigned 1 or 10 
+  # depending on the man having a bow
+  def newFightJob(p,target)
+    if resource.get(&quot;bow&quot;)&gt;0
+      super(p,target,10)
+    else
+      super(p,target,1)
+    end
+  end
 
-	def eventDefeated
-		# FIXME: check, if this ok !!!! /HLJobs
-		if newHLJobs
-			hlJobMode[:defeated]=true
-			eventNoJob
-			return
-		end
+  def eventDefeated
+    # FIXME: check, if this ok !!!! /HLJobs
+    if newHLJobs
+      hlJobMode[:defeated]=true
+      eventNoJob
+      return
+    end
 
 
-		if is_a?(AntBoss)
-			eventManDefeated(self)
-		elsif @boss then
-			@boss.eventManDefeated(self)
-		end
-	end
-	def eventNoJob
-		if @meshState==&quot;dead&quot;
-			if @mdead
-				getMap.removeEntity(self)
-				return
-			else
-				newRestJob(20)
-				@mdead=true
-				return
-			end
-		end
-		super
-	end
+    if is_a?(AntBoss)
+      eventManDefeated(self)
+    elsif @boss then
+      @boss.eventManDefeated(self)
+    end
+  end
+  def eventNoJob
+    if @meshState==&quot;dead&quot;
+      if @mdead
+        getMap.removeEntity(self)
+        return
+      else
+        newRestJob(20)
+        @mdead=true
+        return
+      end
+    end
+    super
+  end
 
-	def eventDie
-		super
-		simDeath
-	end
+  def eventDie
+    super
+    simDeath
+  end
 
 
-	# simulate death:
-	#   - transfer appearance to gravestone
-	#   - start angel
-	def simDeath
-		playSound(&quot;die&quot;)
-		if @boss
-			@boss.removeMan(self)
-		end
+  # simulate death:
+  #   - transfer appearance to gravestone
+  #   - start angel
+  def simDeath
+    playSound(&quot;die&quot;)
+    if @boss
+      @boss.removeMan(self)
+    end
 
-		# add grave
-		grave=AntGrave.new(getMap)
-		grave.type=:hero if self.is_a?(AntHero)
-		grave.setPos(getPos2D)
-		getMap.insertEntity(grave)
+    # add grave
+    grave=AntGrave.new(getMap)
+    grave.type=:hero if self.is_a?(AntHero)
+    grave.setPos(getPos2D)
+    getMap.insertEntity(grave)
 
-		# remove myself
-		getMap.removeEntity(self)
+    # remove myself
+    getMap.removeEntity(self)
 
-		# add sack if resources not empty
-		if not self.resource.empty
-			sack=AntSack.new(getMap)
-			sack.setPos(getPos2D+AGVector2.new(0.3,-0.3))
-			getMap.insertEntity(sack)
-			sack.resource.takeAll(self.resource)
-			sack.resourceChanged
-		end
+    # add sack if resources not empty
+    if not self.resource.empty
+      sack=AntSack.new(getMap)
+      sack.setPos(getPos2D+AGVector2.new(0.3,-0.3))
+      getMap.insertEntity(sack)
+      sack.resource.takeAll(self.resource)
+      sack.resourceChanged
+    end
 
-	end
+  end
 
 
-	def shouldFight
-		canFight
-	end
+  def shouldFight
+    canFight
+  end
 
-	def checkOnWater(name)
-		z=getMap.getPos(getPos2D).z
-		if isOnWater
-			# under water
-			if name=~/sit/ and not isOnOpenWater
-				name=&quot;stand&quot;
-				setOnWater(false)
-			end
-			if isOnOpenWater and haveBoat
-				puts &quot;onOpenWater&quot;
-				setOnWater(true)
-				name=&quot;row&quot;
-			end
-		else
-			setOnWater(false)
-		end
-		name
-	end
+  def checkOnWater(name)
+    z=getMap.getPos(getPos2D).z
+    if isOnWater
+      # under water
+      if name=~/sit/ and not isOnOpenWater
+        name=&quot;stand&quot;
+        setOnWater(false)
+      end
+      if isOnOpenWater and haveBoat
+        puts &quot;onOpenWater&quot;
+        setOnWater(true)
+        name=&quot;row&quot;
+      end
+    else
+      setOnWater(false)
+    end
+    name
+  end
 
-	def checkResources
-		# FIXME: maybe make hero a little stronger ???
-		#        or even make experienced men stronger ???
-		if resource.get(&quot;bow&quot;)&gt;0
-			setStrength(0.03)
-			setMoraleStrength(0.04)
-		elsif resource.get(&quot;sword&quot;)&gt;0
-			setStrength(0.024)
-			setMoraleStrength(0.03)
-		else
-			setStrength(0.015)
-			setMoraleStrength(0.02)
-		end
-		if resource.get(&quot;shield&quot;)==0
-			setDefense(1)
-		else
-			setDefense(1.5)
-		end
-	end
+  def checkResources
+    # FIXME: maybe make hero a little stronger ???
+    #        or even make experienced men stronger ???
+    if resource.get(&quot;bow&quot;)&gt;0
+      setStrength(0.03)
+      setMoraleStrength(0.04)
+    elsif resource.get(&quot;sword&quot;)&gt;0
+      setStrength(0.024)
+      setMoraleStrength(0.03)
+    else
+      setStrength(0.015)
+      setMoraleStrength(0.02)
+    end
+    if resource.get(&quot;shield&quot;)==0
+      setDefense(1)
+    else
+      setDefense(1.5)
+    end
+  end
 
-	def eventHitWaterMark(fromAbove)
-		#raise 1
-		log &quot;eventHitWaterMark(#{fromAbove})&quot;
-		#setOnWater(fromAbove)
-		if fromAbove
-			if haveBoat
-				setMeshState(&quot;row&quot;)
-				return true
-			else
-				# stop job
-				delJob
-				p=getMap.getNextPlaceAbove(getPos2D,-0.2)
-				newMoveJob(0,p,0)
-				delJob
-				return false
-			end
-		else
-			setOnWater(false)
-			setPos(getMap.getPos(getPos2D))
-			setMeshState(@origMeshState)
-			return true
-		end
-	end
+  def eventHitWaterMark(fromAbove)
+    #raise 1
+    log &quot;eventHitWaterMark(#{fromAbove})&quot;
+    #setOnWater(fromAbove)
+    if fromAbove
+      if haveBoat
+        setMeshState(&quot;row&quot;)
+        return true
+      else
+        # stop job
+        delJob
+        p=getMap.getNextPlaceAbove(getPos2D,-0.2)
+        newMoveJob(0,p,0)
+        delJob
+        return false
+      end
+    else
+      setOnWater(false)
+      setPos(getMap.getPos(getPos2D))
+      setMeshState(@origMeshState)
+      return true
+    end
+  end
 
-	def animationEvent(name)
-		case name
-			when &quot;bow&quot;
-				arrow=AntArrow.new(getMap)
-				arrow.setPos(getPos3D+AGVector3.new(0,0,1))
-				pos=@fightTarget.getPos3D+AGVector3.new(0,0,1)
-				arrow.newMoveJob(0,pos,0) #@target.getPos2D,0)
-				getMap.insertEntity(arrow)
-		end
-	end
-	def checkEat
-		log &quot;CHECKEAT&quot;
-		if getFood&lt;0.5
-			if resource.get(&quot;food&quot;)&gt;0
-				incFood(1)
-				resource.sub(&quot;food&quot;,1)
-			end
-		end
-	end
+  def animationEvent(name)
+    case name
+      when &quot;bow&quot;
+        arrow=AntArrow.new(getMap)
+        arrow.setPos(getPos3D+AGVector3.new(0,0,1))
+        pos=@fightTarget.getPos3D+AGVector3.new(0,0,1)
+        arrow.newMoveJob(0,pos,0) #@target.getPos2D,0)
+        getMap.insertEntity(arrow)
+    end
+  end
+  def checkEat
+    log &quot;CHECKEAT&quot;
+    if getFood&lt;0.5
+      if resource.get(&quot;food&quot;)&gt;0
+        incFood(1)
+        resource.sub(&quot;food&quot;,1)
+      end
+    end
+  end
 
 protected
-	def haveBoat
-		resource.get(&quot;boat&quot;)&gt;=1
-	end
+  def haveBoat
+    resource.get(&quot;boat&quot;)&gt;=1
+  end
 
 private
-	def sendAngel
-		# FIXME: create mesh for angels ??
-		return # do not send angels - they don't have meshes anyway
-	end
+  def sendAngel
+    # FIXME: create mesh for angels ??
+    return # do not send angels - they don't have meshes anyway
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_mill.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_mill.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_mill.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,32 +1,32 @@
 class AntMill&lt;AntHouse
-	def initialize(map)
-		super
-		@type=3
-		setProvide(&quot;flour&quot;,true)
-		@defeated=[]
-		@atHome=[]
-		@lastBirth=0
-		setDirection(-30)
-	end
-	
-	def setupMesh
-		setMesh
-#		mesh=Mesh.new(getMap.getScene,getMeshData(&quot;data/models/ant_mill.ant2&quot;,3.2,&quot;data/textures/models/ant_mill.png&quot;),AGVector4.new(0,0,0),-30)
-#		setMesh(mesh)
-	end
+  def initialize(map)
+    super
+    @type=3
+    setProvide(&quot;flour&quot;,true)
+    @defeated=[]
+    @atHome=[]
+    @lastBirth=0
+    setDirection(-30)
+  end
+  
+  def setupMesh
+    setMesh
+#    mesh=Mesh.new(getMap.getScene,getMeshData(&quot;data/models/ant_mill.ant2&quot;,3.2,&quot;data/textures/models/ant_mill.png&quot;),AGVector4.new(0,0,0),-30)
+#    setMesh(mesh)
+  end
 
-	def neededStock
-		{&quot;food&quot;=&gt;20,&quot;corn&quot;=&gt;30}
-	end
+  def neededStock
+    {&quot;food&quot;=&gt;20,&quot;corn&quot;=&gt;30}
+  end
 
-	def process
-		if resource.get(&quot;corn&quot;)&gt;0 and resource.get(&quot;flour&quot;)&lt;30
-			amount=[resource.get(&quot;corn&quot;),1].min
-			resource.sub(&quot;corn&quot;,amount)
-			resource.add(&quot;flour&quot;,amount*2)
-		end
-	end
-	def houseType
-		&quot;mill&quot;
-	end
+  def process
+    if resource.get(&quot;corn&quot;)&gt;0 and resource.get(&quot;flour&quot;)&lt;30
+      amount=[resource.get(&quot;corn&quot;),1].min
+      resource.sub(&quot;corn&quot;,amount)
+      resource.add(&quot;flour&quot;,amount*2)
+    end
+  end
+  def houseType
+    &quot;mill&quot;
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_mine.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_mine.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_mine.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -20,27 +20,27 @@
 
 
 class AntMine&lt;AntRubyEntity
-	def initialize(map)
-		super
-		setProvide(&quot;coal&quot;,true)
-		setProvide(&quot;ore&quot;,true)
-		@angle=getRand*360
-		
-		setMinimapColor(AGColor.new(0,0,0))
-	
-		resource.set(&quot;ore&quot;,500)
-		resource.set(&quot;coal&quot;,500)
-		setupMesh
-	end
-	def resourceChanged
-		setupMesh
-		super
-	end
-	
-	private
-	def setupMesh
-		setMesh
-		#setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/mine2.ant2&quot;,0.2,&quot;data/textures/models/mine.png&quot;),AGVector4.new(0,0,0),-40))
-	end
+  def initialize(map)
+    super
+    setProvide(&quot;coal&quot;,true)
+    setProvide(&quot;ore&quot;,true)
+    @angle=getRand*360
+    
+    setMinimapColor(AGColor.new(0,0,0))
+  
+    resource.set(&quot;ore&quot;,500)
+    resource.set(&quot;coal&quot;,500)
+    setupMesh
+  end
+  def resourceChanged
+    setupMesh
+    super
+  end
+  
+  private
+  def setupMesh
+    setMesh
+    #setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/mine2.ant2&quot;,0.2,&quot;data/textures/models/mine.png&quot;),AGVector4.new(0,0,0),-40))
+  end
 end
 

Modified: antargis/trunk/ruby/entities/ant_ring.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_ring.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_ring.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,93 +1,93 @@
 module RingData
-	@@ringdata=nil
-	def RingData.getRingData(w=1)
-		@@ringdata||=[]
-		if @@ringdata[w]
-			return @@ringdata[w]
-		end
-	
-		opt=MeshOptimizer.new
-		mv0=MeshVertex.new
-		mv1=MeshVertex.new
-		mv2=MeshVertex.new
-		mv3=MeshVertex.new
-		
-		c=AGVector4.new(1,1,1,1) #0.6,0.7,1,1) #0.9)
-		mv0.c=c
-		mv1.c=c
-		mv2.c=c
-		mv3.c=c
-		
-		mv0.t=AGVector2.new(0,0)
-		mv1.t=AGVector2.new(1,0)
-		mv2.t=AGVector2.new(1,1)
-		mv3.t=AGVector2.new(0,1)
-		
-		#w=size
-		h=0.1
-		
-		mv0.v=AGVector4.new(-w,-w,h)
-		mv1.v=AGVector4.new(w,-w,h)
-		mv2.v=AGVector4.new(w,w,h)
-		mv3.v=AGVector4.new(-w,w,h)
-		
-		mv0.n=AGVector3.new(0,-1,0)
-		mv1.n=AGVector3.new(0,-1,0)
-		mv2.n=AGVector3.new(0,-1,0)
-		mv3.n=AGVector3.new(0,-1,0)
-		
-		opt.add(mv0)
-		opt.add(mv1)
-		opt.add(mv2)
-		
-		opt.add(mv0)
-		opt.add(mv2)
-		opt.add(mv3)
-		
-		@@ringdata[w]=MeshData.new(opt.getArray,&quot;data/textures/ring.png&quot;,false)
-		@@ringdata[w].setOverdraw(true)
-		@@ringdata[w].setColors(false)
-		@@ringdata[w].setPickable(false)
-		@@ringdata[w].setLighting(false)
-		return @@ringdata[w]
-	end
+  @@ringdata=nil
+  def RingData.getRingData(w=1)
+    @@ringdata||=[]
+    if @@ringdata[w]
+      return @@ringdata[w]
+    end
+  
+    opt=MeshOptimizer.new
+    mv0=MeshVertex.new
+    mv1=MeshVertex.new
+    mv2=MeshVertex.new
+    mv3=MeshVertex.new
+    
+    c=AGVector4.new(1,1,1,1) #0.6,0.7,1,1) #0.9)
+    mv0.c=c
+    mv1.c=c
+    mv2.c=c
+    mv3.c=c
+    
+    mv0.t=AGVector2.new(0,0)
+    mv1.t=AGVector2.new(1,0)
+    mv2.t=AGVector2.new(1,1)
+    mv3.t=AGVector2.new(0,1)
+    
+    #w=size
+    h=0.1
+    
+    mv0.v=AGVector4.new(-w,-w,h)
+    mv1.v=AGVector4.new(w,-w,h)
+    mv2.v=AGVector4.new(w,w,h)
+    mv3.v=AGVector4.new(-w,w,h)
+    
+    mv0.n=AGVector3.new(0,-1,0)
+    mv1.n=AGVector3.new(0,-1,0)
+    mv2.n=AGVector3.new(0,-1,0)
+    mv3.n=AGVector3.new(0,-1,0)
+    
+    opt.add(mv0)
+    opt.add(mv1)
+    opt.add(mv2)
+    
+    opt.add(mv0)
+    opt.add(mv2)
+    opt.add(mv3)
+    
+    @@ringdata[w]=MeshData.new(opt.getArray,&quot;data/textures/ring.png&quot;,false)
+    @@ringdata[w].setOverdraw(true)
+    @@ringdata[w].setColors(false)
+    @@ringdata[w].setPickable(false)
+    @@ringdata[w].setLighting(false)
+    return @@ringdata[w]
+  end
 end
 
 class ColoredMesh&lt;Mesh
-	def initialize(scene,data,pos,angle)
-		super
-		@t=0
-		@c0=AGVector4.new(0.6,0.6,0.6,1)
-		@c1=AGVector4.new(0.8,0.8,0.8,1)
-	end
-	def setRingColor(c)
-		@c0=c
-		@c1=c*1.2
-		@c1.setW(1)
-	end
-	def advance(time)
-		super
-		@t+=time
-		v=(Math::cos(@t*5)+1)/2
-		setColor(@c0*<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">v+ at c1</A>*(1-v))
-	end
+  def initialize(scene,data,pos,angle)
+    super
+    @t=0
+    @c0=AGVector4.new(0.6,0.6,0.6,1)
+    @c1=AGVector4.new(0.8,0.8,0.8,1)
+  end
+  def setRingColor(c)
+    @c0=c
+    @c1=c*1.2
+    @c1.setW(1)
+  end
+  def advance(time)
+    super
+    @t+=time
+    v=(Math::cos(@t*5)+1)/2
+    setColor(@c0*<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">v+ at c1</A>*(1-v))
+  end
 end
 
 
 def makeRingMesh
-	return nil if getMap.getScene.nil?
-	return AntModels.createModel(:sack) if not opengl # FIXME
-	mesh=ColoredMesh.new(getMap.getScene,RingData.getRingData,AGVector4.new(0,0,0,0),0)
-	mesh.setOrder(RING_Z)
-	return mesh
+  return nil if getMap.getScene.nil?
+  return AntModels.createModel(:sack) if not opengl # FIXME
+  mesh=ColoredMesh.new(getMap.getScene,RingData.getRingData,AGVector4.new(0,0,0,0),0)
+  mesh.setOrder(RING_Z)
+  return mesh
 end
 
 def makeBigRingMesh
-	return nil if getMap.getScene.nil?
-	return AntModels.createModel(:sack) if not opengl # FIXME
-	mesh=ColoredMesh.new(getMap.getScene,RingData.getRingData(4),AGVector4.new(0,0,0,0),0)
-	mesh.setOrder(RING_Z)
-	return mesh
+  return nil if getMap.getScene.nil?
+  return AntModels.createModel(:sack) if not opengl # FIXME
+  mesh=ColoredMesh.new(getMap.getScene,RingData.getRingData(4),AGVector4.new(0,0,0,0),0)
+  mesh.setOrder(RING_Z)
+  return mesh
 end
 
 

Modified: antargis/trunk/ruby/entities/ant_sack.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_sack.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_sack.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -7,22 +7,22 @@
 # TODO: Find a better name for AntAnimal
 #
 class AntSack&lt;AntAnimal
-	def initialize(map)
-		super
-		setMesh
-		@enabled=true
-		@storeGood=[&quot;food&quot;,&quot;tool&quot;,&quot;corn&quot;,&quot;stone&quot;,&quot;wood&quot;]
-	end
-	# is called by a finished KillAnimal-hl-job
-	def eventDie
-		getMap.removeEntity(self)
-	end
-	
-	# TODO: move this function to a module, which is included by AntHouse,AntTree and such, too.
-	def resourceChanged
-		@storeGood.each{|r|
-			setProvide(r,resource.get(r)&gt;0)
-		}
-		super
-	end
+  def initialize(map)
+    super
+    setMesh
+    @enabled=true
+    @storeGood=[&quot;food&quot;,&quot;tool&quot;,&quot;corn&quot;,&quot;stone&quot;,&quot;wood&quot;]
+  end
+  # is called by a finished KillAnimal-hl-job
+  def eventDie
+    getMap.removeEntity(self)
+  end
+  
+  # TODO: move this function to a module, which is included by AntHouse,AntTree and such, too.
+  def resourceChanged
+    @storeGood.each{|r|
+      setProvide(r,resource.get(r)&gt;0)
+    }
+    super
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_sheep.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_sheep.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_sheep.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -21,90 +21,90 @@
 require 'ant_animal.rb'
 
 class AntSheep&lt;AntAnimal
-	def initialize(map)
-		super
-		setProvide(&quot;sheep&quot;,true)
-		setSpeed 0.4
-		@foodAdd=0
-		
-		setMesh
+  def initialize(map)
+    super
+    setProvide(&quot;sheep&quot;,true)
+    setSpeed 0.4
+    @foodAdd=0
+    
+    setMesh
 
-		resource.set(&quot;food&quot;,1)
-	end
-	def eventNoJob
-		eventJobFinished
-	end
-	def eventJobFinished
-		super
+    resource.set(&quot;food&quot;,1)
+  end
+  def eventNoJob
+    eventJobFinished
+  end
+  def eventJobFinished
+    super
 
-		if @dead
-			newRestJob(30)
-			if @alreadyDead
-				getMap.removeEntity(self)
-			end
-			@alreadyDead=true
-	
-			return
-		end
+    if @dead
+      newRestJob(30)
+      if @alreadyDead
+        getMap.removeEntity(self)
+      end
+      @alreadyDead=true
+  
+      return
+    end
 
-		if (not giveBirth)
-# 		# BIRTHRATE is here:
-# 		if @lastBirth&gt;40 then
-# 			# make child
-# 			puts &quot;A SHEEP IS BORN&quot;
-# 			sheep=AntSheep.new
-# 			sheep.setPos(getPos2D)
-# 			getMap.insertEntity(sheep)
-# 			#getMap.endChange
-# 			newRestJob(2)
-# 			@lastBirth=-getRand*10
-			if getRand&lt;0.5 then
-				newMoveJob(0,getTargetPos,0)
-				setMeshState(&quot;go&quot;)
-			else
-				newRestJob(3)
-				setMeshState(&quot;eat&quot;)
-				playSound(&quot;sheep&quot;)
-			end
-		end
+    if (not giveBirth)
+#     # BIRTHRATE is here:
+#     if @lastBirth&gt;40 then
+#       # make child
+#       puts &quot;A SHEEP IS BORN&quot;
+#       sheep=AntSheep.new
+#       sheep.setPos(getPos2D)
+#       getMap.insertEntity(sheep)
+#       #getMap.endChange
+#       newRestJob(2)
+#       @lastBirth=-getRand*10
+      if getRand&lt;0.5 then
+        newMoveJob(0,getTargetPos,0)
+        setMeshState(&quot;go&quot;)
+      else
+        newRestJob(3)
+        setMeshState(&quot;eat&quot;)
+        playSound(&quot;sheep&quot;)
+      end
+    end
 
-		@foodAdd+=1
-		#puts &quot;FOOOOOD #{@foodAdd}&quot;
-		if @foodAdd&gt;3 and resource.get(&quot;food&quot;)&lt;10
-			#puts &quot;RESOURCE: #{resource.get(&quot;food&quot;)}&quot;
-			resource.add(&quot;food&quot;,1)
-			#puts &quot;RESOURCE: #{resource.get(&quot;food&quot;)}&quot;
-			@foodAdd=0
-		end
-	end
-	
-	def getTargetPos
-		p=getPos2D
-		tries=10
-		# assure that sheep doesn't walk into water
-		while tries&gt;0 do
-			d=AGVector2.new(getRand-0.5,getRand-0.5).normalized*2
-			t=p+d
-			t=getMap.truncPos(t)
-			tries-=1
-			if getMap.getHeight(t.x,t.y)&gt;0
-				return t
-			end
-		end 
-		return p
-	end
-	def setMeshState(s)
-		getFirstMesh.setAnimation(s)
-	end
-	def getName
-		return &quot;Corpse&quot; if @dead
-		&quot;Sheep&quot;
-	end
-	def eventDie
-		setMesh(:rip)
-		#setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/rip.ant2&quot;,0.3,&quot;data/textures/models/rip.png&quot;),AGVector4.new(0,0,0,0),0))
-		setProvide(&quot;sheep&quot;,false)
-		@dead=true
-		newRestJob(1)
-	end
+    @foodAdd+=1
+    #puts &quot;FOOOOOD #{@foodAdd}&quot;
+    if @foodAdd&gt;3 and resource.get(&quot;food&quot;)&lt;10
+      #puts &quot;RESOURCE: #{resource.get(&quot;food&quot;)}&quot;
+      resource.add(&quot;food&quot;,1)
+      #puts &quot;RESOURCE: #{resource.get(&quot;food&quot;)}&quot;
+      @foodAdd=0
+    end
+  end
+  
+  def getTargetPos
+    p=getPos2D
+    tries=10
+    # assure that sheep doesn't walk into water
+    while tries&gt;0 do
+      d=AGVector2.new(getRand-0.5,getRand-0.5).normalized*2
+      t=p+d
+      t=getMap.truncPos(t)
+      tries-=1
+      if getMap.getHeight(t.x,t.y)&gt;0
+        return t
+      end
+    end 
+    return p
+  end
+  def setMeshState(s)
+    getFirstMesh.setAnimation(s)
+  end
+  def getName
+    return &quot;Corpse&quot; if @dead
+    &quot;Sheep&quot;
+  end
+  def eventDie
+    setMesh(:rip)
+    #setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/rip.ant2&quot;,0.3,&quot;data/textures/models/rip.png&quot;),AGVector4.new(0,0,0,0),0))
+    setProvide(&quot;sheep&quot;,false)
+    @dead=true
+    newRestJob(1)
+  end
 end

Modified: antargis/trunk/ruby/entities/ant_stone.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_stone.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_stone.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -19,28 +19,28 @@
 #
 
 class AntStone&lt;AntRubyEntity
-	def initialize(map)
-		super
-		@typeID=(getRand*2).to_i
-		setProvide(&quot;stone&quot;,true)
-		#setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/big_stone.ant2&quot;,0.7,&quot;data/textures/models/big_stone.png&quot;),AGVector4.new(0,0,0,0),getRand*360))
-		mesh=setMesh
-		mesh.setRotation(getRand*360)
-		resource.set(&quot;stone&quot;,500)
-	end
-	def setTreeType(t)
-		@typeID=t
-	end
-	def getTexture
-		return &quot;deco&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">+ at typeID.to_s+</A>&quot;.png&quot;
-	end
-	def saveXML(node)
-		super(node)
-		node.set(&quot;typeID&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at typeID.to_s</A>)
-	end
-	def loadXML(node)
-		super(node)
-		@typeID=node.get(&quot;typeID&quot;).to_i
-	end
+  def initialize(map)
+    super
+    @typeID=(getRand*2).to_i
+    setProvide(&quot;stone&quot;,true)
+    #setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/big_stone.ant2&quot;,0.7,&quot;data/textures/models/big_stone.png&quot;),AGVector4.new(0,0,0,0),getRand*360))
+    mesh=setMesh
+    mesh.setRotation(getRand*360)
+    resource.set(&quot;stone&quot;,500)
+  end
+  def setTreeType(t)
+    @typeID=t
+  end
+  def getTexture
+    return &quot;deco&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">+ at typeID.to_s+</A>&quot;.png&quot;
+  end
+  def saveXML(node)
+    super(node)
+    node.set(&quot;typeID&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at typeID.to_s</A>)
+  end
+  def loadXML(node)
+    super(node)
+    @typeID=node.get(&quot;typeID&quot;).to_i
+  end
 end
 

Modified: antargis/trunk/ruby/entities/ant_tower.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_tower.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_tower.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,61 +1,61 @@
 class AntTower&lt;AntHouse
-	def initialize(map)
-		super
-		setProvide(&quot;tower&quot;,true)
-		setMinimapColor(AGColor.new(0x22,0x22,0x22))
-		setMinimapSize(6)
+  def initialize(map)
+    super
+    setProvide(&quot;tower&quot;,true)
+    setMinimapColor(AGColor.new(0x22,0x22,0x22))
+    setMinimapSize(6)
 
-		@storeGood=[&quot;food&quot;,&quot;tool&quot;,&quot;corn&quot;,&quot;stone&quot;,&quot;wood&quot;]
-	end
-	
-	def setupMesh
-		setMesh
-	end	
-	
+    @storeGood=[&quot;food&quot;,&quot;tool&quot;,&quot;corn&quot;,&quot;stone&quot;,&quot;wood&quot;]
+  end
+  
+  def setupMesh
+    setMesh
+  end  
+  
 
-	def neededStock
-		{&quot;fruit&quot;=&gt;15,&quot;stone&quot;=&gt;15,&quot;wood&quot;=&gt;15}
-	end
+  def neededStock
+    {&quot;fruit&quot;=&gt;15,&quot;stone&quot;=&gt;15,&quot;wood&quot;=&gt;15}
+  end
 
-	def resourceChanged
-		@storeGood.each{|r|
-			#puts &quot;#{self} #{r} #{resource.get(r)} #{getName}&quot;
-			setProvide(r,resource.get(r)&gt;0)
-			#puts provides(r)
-		}
-		super
-	end
+  def resourceChanged
+    @storeGood.each{|r|
+      #puts &quot;#{self} #{r} #{resource.get(r)} #{getName}&quot;
+      setProvide(r,resource.get(r)&gt;0)
+      #puts provides(r)
+    }
+    super
+  end
 
-	###############################
-	# FLAG support
-	###############################
-	
-	# override this for reseting the flag's position
-	def setPos(p)
-		super(p)
-		if @flag then
-			p=getPos3D
-			p.y+=290
-			p.z-=150
-			@flag.setPos(p)
-		end
-	end
-	
-	def addFlag(owner)
-		@flag=AntFlag.new(getMap)
-		setPos(getPos2D) # reset flag position
-		getMap.insertEntity(@flag)
-	end
+  ###############################
+  # FLAG support
+  ###############################
+  
+  # override this for reseting the flag's position
+  def setPos(p)
+    super(p)
+    if @flag then
+      p=getPos3D
+      p.y+=290
+      p.z-=150
+      @flag.setPos(p)
+    end
+  end
+  
+  def addFlag(owner)
+    @flag=AntFlag.new(getMap)
+    setPos(getPos2D) # reset flag position
+    getMap.insertEntity(@flag)
+  end
 
-	def houseType
-		&quot;keep&quot;
-	end
+  def houseType
+    &quot;keep&quot;
+  end
 
-	def process
-		if resource.get(&quot;fruit&quot;)&gt;0 and resource.get(&quot;food&quot;)&lt;15
-			amount=[resource.get(&quot;fruit&quot;),3].min
-			resource.add(&quot;food&quot;,amount)
-			resource.sub(&quot;fruit&quot;,amount)
-		end
-	end
+  def process
+    if resource.get(&quot;fruit&quot;)&gt;0 and resource.get(&quot;food&quot;)&lt;15
+      amount=[resource.get(&quot;fruit&quot;),3].min
+      resource.add(&quot;food&quot;,amount)
+      resource.sub(&quot;fruit&quot;,amount)
+    end
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_townhall.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_townhall.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_townhall.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -22,34 +22,34 @@
 #    - farming (wheat)
 
 class AntTownHall&lt;AntHouse
-	def initialize(map)
-		super
-		@type=3
-		@defeated=[]
-		@atHome=[]
-		setDirection(-10)
-	
-		@storeGood=[&quot;food&quot;,&quot;tool&quot;,&quot;corn&quot;]
-	end
-	
-	def setupMesh
-		setMesh
-	end
+  def initialize(map)
+    super
+    @type=3
+    @defeated=[]
+    @atHome=[]
+    setDirection(-10)
+  
+    @storeGood=[&quot;food&quot;,&quot;tool&quot;,&quot;corn&quot;]
+  end
+  
+  def setupMesh
+    setMesh
+  end
 
-	def resourceChanged
-		@storeGood.each{|r|
-			setProvide(r,resource.get(r)&gt;0)
-		}
-		super
-	end
+  def resourceChanged
+    @storeGood.each{|r|
+      setProvide(r,resource.get(r)&gt;0)
+    }
+    super
+  end
 
-	def neededStock
-		s={}
-		@storeGood.each{|r|s[r]=15}
-		s
-	end
+  def neededStock
+    s={}
+    @storeGood.each{|r|s[r]=15}
+    s
+  end
 
-	def houseType
-		&quot;townhall&quot;
-	end
+  def houseType
+    &quot;townhall&quot;
+  end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_tree.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_tree.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_tree.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -22,77 +22,77 @@
 
 
 class AntTree&lt;AntRubyEntity
-	def initialize(map,typeID=nil)
-		super(map)
-		@typeID=typeID
-		#@typeID||=(getRand*getTreeTypes.length).to_i
-		@typeID||=(getRand*(AntModels.getMeshCount(:tree)-1)).to_i
-		setProvide(&quot;wood&quot;,true)
-		setProvide(&quot;fruit&quot;,true)
-		@angle=getRand*360
-		
-		@maxApples=100
-		setMinimapColor(AGColor.new(0,0x77,0))
-	
-		resource.set(&quot;fruit&quot;,5)
-		resource.set(&quot;wood&quot;,20)
-		resourceChanged
-	end
-	def resourceChanged
-		if resource.get(&quot;wood&quot;)&lt;=0
-			@typeID=-1
-			setProvide(&quot;fruit&quot;,false)
-			setProvide(&quot;wood&quot;,false)
-		end
-		setupMesh
-		super
-	end
-	
-	def setTreeType(t)
-		@typeID=t
-	end
-	def saveXML(node)
-		super(node)
-		node.set(&quot;typeID&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at typeID.to_s</A>)
-	end
-	def loadXML(node)
-		super(node)
-		@typeID=node.get(&quot;typeID&quot;).to_i
-		setupMesh
-	end
-	
-	def eventNoJob
-		# grow apples
-		resource.set(&quot;fruit&quot;,[resource.get(&quot;fruit&quot;)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">+1.7, at maxApples</A>].min)
-		resourceChanged
-		newRestJob(20)
-	end
-	
-	private
-	def setupMesh
-		typeId=&quot;stub&quot;
-		if @typeID&gt;=0
-			typeId=@typeID%10
-		end
-		mesh=setMesh(typeId)
-		
-		mesh.setRotation(@angle) if mesh
-	end
+  def initialize(map,typeID=nil)
+    super(map)
+    @typeID=typeID
+    #@typeID||=(getRand*getTreeTypes.length).to_i
+    @typeID||=(getRand*(AntModels.getMeshCount(:tree)-1)).to_i
+    setProvide(&quot;wood&quot;,true)
+    setProvide(&quot;fruit&quot;,true)
+    @angle=getRand*360
+    
+    @maxApples=100
+    setMinimapColor(AGColor.new(0,0x77,0))
+  
+    resource.set(&quot;fruit&quot;,5)
+    resource.set(&quot;wood&quot;,20)
+    resourceChanged
+  end
+  def resourceChanged
+    if resource.get(&quot;wood&quot;)&lt;=0
+      @typeID=-1
+      setProvide(&quot;fruit&quot;,false)
+      setProvide(&quot;wood&quot;,false)
+    end
+    setupMesh
+    super
+  end
+  
+  def setTreeType(t)
+    @typeID=t
+  end
+  def saveXML(node)
+    super(node)
+    node.set(&quot;typeID&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at typeID.to_s</A>)
+  end
+  def loadXML(node)
+    super(node)
+    @typeID=node.get(&quot;typeID&quot;).to_i
+    setupMesh
+  end
+  
+  def eventNoJob
+    # grow apples
+    resource.set(&quot;fruit&quot;,[resource.get(&quot;fruit&quot;)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">+1.7, at maxApples</A>].min)
+    resourceChanged
+    newRestJob(20)
+  end
+  
+  private
+  def setupMesh
+    typeId=&quot;stub&quot;
+    if @typeID&gt;=0
+      typeId=@typeID%10
+    end
+    mesh=setMesh(typeId)
+    
+    mesh.setRotation(@angle) if mesh
+  end
 
-	# an old function for display apples - this is too costly
-	def setupApples
-		@crownMiddle=AGVector3.new(0,0,3)
-		@crownRadius=1.3
-		@applePos=[]
-		for i in <A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at maxApples</A>
-			va=(getRand-0.5)*Math::PI
-			ha=(getRand+1)*Math::PI  # only on front side
-			z=@crownRadius*Math::sin(va)
-			rest=Math::sqrt(@crownRadius**2-z**2)
-			y=Math::sin(ha)*rest
-			x=Math::cos(ha)*rest
-			@applePos.push(AGVector3.new(x,y,z)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">+ at crownMiddle</A>)
-		end
-	end
+  # an old function for display apples - this is too costly
+  def setupApples
+    @crownMiddle=AGVector3.new(0,0,3)
+    @crownRadius=1.3
+    @applePos=[]
+    for i in <A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at maxApples</A>
+      va=(getRand-0.5)*Math::PI
+      ha=(getRand+1)*Math::PI  # only on front side
+      z=@crownRadius*Math::sin(va)
+      rest=Math::sqrt(@crownRadius**2-z**2)
+      y=Math::sin(ha)*rest
+      x=Math::cos(ha)*rest
+      @applePos.push(AGVector3.new(x,y,z)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">+ at crownMiddle</A>)
+    end
+  end
 end
 

Modified: antargis/trunk/ruby/entities/ant_well.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_well.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/entities/ant_well.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -1,21 +1,21 @@
 
 
 class AntWell&lt;AntRubyEntity
-	def initialize(map)
-		super
-		@type=3
-		setProvide(&quot;water&quot;,true)
-		@defeated=[]
-		@atHome=[]
-		@lastBirth=0
-		setDirection(-30)
-		resource.set(&quot;water&quot;,1000)
-		setupMesh
-	end
-	
-	def setupMesh
-		setMesh
-	end
+  def initialize(map)
+    super
+    @type=3
+    setProvide(&quot;water&quot;,true)
+    @defeated=[]
+    @atHome=[]
+    @lastBirth=0
+    setDirection(-30)
+    resource.set(&quot;water&quot;,1000)
+    setupMesh
+  end
+  
+  def setupMesh
+    setMesh
+  end
 
 
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/jobs/ant_hljob_base.rb
===================================================================
--- antargis/trunk/ruby/jobs/ant_hljob_base.rb	2008-05-31 06:11:34 UTC (rev 1261)
+++ antargis/trunk/ruby/jobs/ant_hljob_base.rb	2008-05-31 13:24:27 UTC (rev 1262)
@@ -3,18 +3,18 @@
 class AntNewHLJob&lt;BaseMachine
   include XMLSaver
   
-	attr_reader :finished, :stopped
-	# some magic here
-	def initialize(hero,startState=nil)
-		super(startState)
-		@hero=hero
-		assert{not @hero.nil?}
+  attr_reader :finished, :stopped
+  # some magic here
+  def initialize(hero,startState=nil)
+    super(startState)
+    @hero=hero
+    assert{not @hero.nil?}
 
-		@finished=false
+    @finished=false
 
     # FIXME: is this to be moved somewhere else ?
-		#firstCall
-	end
+    #firstCall
+  end
   
   def xmlName
     self.class.to_s
@@ -27,72 +27,72 @@
     #end
   #end
 
-	def getTime
-		@hero.getMap.getTime
-	end
+  def getTime
+    @hero.getMap.getTime
+  end
 
-	def allMen
-		if @hero.is_a?(AntHero)
-			@hero.getMen
-		else
-			@hero.getMen-[@hero]
-		end
-	end
+  def allMen
+    if @hero.is_a?(AntHero)
+      @hero.getMen
+    else
+      @hero.getMen-[@hero]
+    end
+  end
 
-	def hero
-		@hero
-	end
+  def hero
+    @hero
+  end
 
-	def getMap
-		hero.getMap
-	end
-	
-	def getRand
-		@hero.getRand
-	end
+  def getMap
+    hero.getMap
+  end
+  
+  def getRand
+    @hero.getRand
+  end
 
-	def stopJob
-		@stopped=true
-		stateCall(&quot;leave&quot;)
-	end
+  def stopJob
+    @stopped=true
+    stateCall(&quot;leave&quot;)
+  end
 
-	def check(man)
-	  assert{self.started}
-		#raise 1
-		if @state.nil?
-			@finished=true
-			return
-		end
-		#raise 1
-		stateCall(&quot;assign&quot;,man)
-		advance
-		@finished=ready
-	end
+  def check(man)
+    assert{self.started}
+    #raise 1
+    if @state.nil?
+      @finished=true
+      return
+    end
+    #raise 1
+    stateCall(&quot;assign&quot;,man)
+    advance
+    @finished=ready
+  end
 
-	def delete(man)
-		puts &quot;IGNORING AntNewHLJob::delete(#{man})&quot;
-		if man==@hero
-			puts &quot;STOPPING JOB - because hero died&quot;
-			@finished=true
-			@state=nil
-		end
-	end
+  def delete(man)
+    puts &quot;IGNORING AntNewHLJob::delete(#{man})&quot;
+    if man==@hero
+      puts &quot;STOPPING JOB - because hero died&quot;
+      @finished=true
+      @state=nil
+    end
+  end
 
 
-	def trace
-		return
-# 		if @hero.nil?
-# 			puts &quot;TRACE #{caller[0]} #{self}&quot;
-# 		else
-# 			puts &quot;TRACE #{caller[0]} #{self} #{hero} #{getTime}&quot;
-# 		end
-	end
+  def trace
+    return
+#     if @hero.nil?
+#       puts &quot;TRACE #{caller[0]} #{self}&quot;
+#     else
+#       puts &quot;TRACE #{caller[0]} #{self} #{hero} #{getTime}&quot;
+#     end
+  end
 
-	def kill
-		stateCall(&quot;kill&quot;)
-	end
+  def kill
+    stateCall(&quot;kill&quot;)
+  end
 
-	def loadXML(node)
-		puts &quot;FIXME !!!!!!!!!!!!!!!! AntNewHLJob::loadXML&quot;
-	end
+  def loadXML(node)
+    puts &quot;FIXME !!!!!!!!!!!!!!!! AntNewHLJob::loadXML&quot;
+  end
 end


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000217.html">[Antargis-svn] r1261 - antargis/trunk
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#218">[ date ]</a>
              <a href="thread.html#218">[ thread ]</a>
              <a href="subject.html#218">[ subject ]</a>
              <a href="author.html#218">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/antargis-svn">More information about the Antargis-svn
mailing list</a><br>
</body></html>
