<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Antargis-svn] r1230 - in antargis/trunk: . build/swig/tests	data/levels/tutorial ext/3dengine ext/basic ext/game ext/gui	main ruby ruby/entities ruby/jobs ruby/meshes ruby/spec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/antargis-svn/2008-February/index.html" >
   <LINK REL="made" HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1230%20-%20in%20antargis/trunk%3A%20.%20build/swig/tests%0A%09data/levels/tutorial%20ext/3dengine%20ext/basic%20ext/game%20ext/gui%0A%09main%20ruby%20ruby/entities%20ruby/jobs%20ruby/meshes%20ruby/spec&In-Reply-To=%3C200802241905.m1OJ5Z0r002003%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000186.html">
   <LINK REL="Next"  HREF="000188.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Antargis-svn] r1230 - in antargis/trunk: . build/swig/tests	data/levels/tutorial ext/3dengine ext/basic ext/game ext/gui	main ruby ruby/entities ruby/jobs ruby/meshes ruby/spec</H1>
    <B>davidkamphausen at BerliOS</B> 
    <A HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1230%20-%20in%20antargis/trunk%3A%20.%20build/swig/tests%0A%09data/levels/tutorial%20ext/3dengine%20ext/basic%20ext/game%20ext/gui%0A%09main%20ruby%20ruby/entities%20ruby/jobs%20ruby/meshes%20ruby/spec&In-Reply-To=%3C200802241905.m1OJ5Z0r002003%40sheep.berlios.de%3E"
       TITLE="[Antargis-svn] r1230 - in antargis/trunk: . build/swig/tests	data/levels/tutorial ext/3dengine ext/basic ext/game ext/gui	main ruby ruby/entities ruby/jobs ruby/meshes ruby/spec">davidkamphausen at mail.berlios.de
       </A><BR>
    <I>Sun Feb 24 20:05:35 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000186.html">[Antargis-svn] r1229 - in antargis/trunk: . ext ext/3dengine	ext/game ext/video main ruby ruby/entities ruby/gui ruby/jobs	ruby/spec ruby/widgets
</A></li>
        <LI>Next message: <A HREF="000188.html">[Antargis-svn] r1231 - antargis/trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#187">[ date ]</a>
              <a href="thread.html#187">[ thread ]</a>
              <a href="subject.html#187">[ subject ]</a>
              <a href="author.html#187">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: davidkamphausen
Date: 2008-02-24 20:05:29 +0100 (Sun, 24 Feb 2008)
New Revision: 1230

Added:
   antargis/trunk/.project
   antargis/trunk/ext/basic/ag_message.h
   antargis/trunk/ruby/garbage/
   antargis/trunk/ruby/spec/spec_coding_style.rb
   antargis/trunk/ruby/spec/spec_entity.rb
   antargis/trunk/ruby/spec/spec_gc.rb
   antargis/trunk/ruby/spec/spec_geometry.rb
   antargis/trunk/ruby/spec/spec_map.rb
Removed:
   antargis/trunk/Rantfile
   antargis/trunk/ruby/spec/geometry.rb
   antargis/trunk/ruby/spec/map.rb
Modified:
   antargis/trunk/Rakefile
   antargis/trunk/build/swig/tests/test.cc
   antargis/trunk/data/levels/tutorial/tutorial0.antlvl
   antargis/trunk/ext/3dengine/anim_mesh.cc
   antargis/trunk/ext/3dengine/anim_mesh_data.cc
   antargis/trunk/ext/3dengine/ant_camera.cc
   antargis/trunk/ext/3dengine/ant_particle.cc
   antargis/trunk/ext/3dengine/ant_renderer.cc
   antargis/trunk/ext/3dengine/glsl.cc
   antargis/trunk/ext/3dengine/mesh.cc
   antargis/trunk/ext/3dengine/mesh_data.cc
   antargis/trunk/ext/3dengine/mesh_optimizer.cc
   antargis/trunk/ext/3dengine/scene.cc
   antargis/trunk/ext/3dengine/scene_2d.cc
   antargis/trunk/ext/3dengine/scene_base.cc
   antargis/trunk/ext/basic/ag_config.cc
   antargis/trunk/ext/basic/ag_fs.cc
   antargis/trunk/ext/basic/ag_geometry.cc
   antargis/trunk/ext/basic/ag_geometry.h
   antargis/trunk/ext/basic/ag_kill.cc
   antargis/trunk/ext/basic/ag_rubyobj.cc
   antargis/trunk/ext/basic/ag_rubyobj.h
   antargis/trunk/ext/basic/ag_string_utf8.h
   antargis/trunk/ext/game/map.cc
   antargis/trunk/ext/gui/ag_application.cc
   antargis/trunk/ext/gui/ag_button.cc
   antargis/trunk/main/Rakefile
   antargis/trunk/ruby/ant_messagebox.rb
   antargis/trunk/ruby/ant_mock.rb
   antargis/trunk/ruby/entities/ant_hero.rb
   antargis/trunk/ruby/entities/ant_sack.rb
   antargis/trunk/ruby/jobs/ant_hljob_states.rb
   antargis/trunk/ruby/jobs/ant_new_hljobs.rb
   antargis/trunk/ruby/map.rb
   antargis/trunk/ruby/meshes/grass.rb
   antargis/trunk/ruby/spec/level_testing.rb
   antargis/trunk/ruby/spec/spec_game_gui.rb
   antargis/trunk/ruby/spec/spec_hljobs.rb
   antargis/trunk/ruby/spec/spec_menu.rb
   antargis/trunk/ruby/spec/spec_run_tutorial.rb
Log:
* many new specs
* several bugfixes

Added: antargis/trunk/.project
===================================================================
--- antargis/trunk/.project	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/.project	2008-02-24 19:05:29 UTC (rev 1230)
@@ -0,0 +1,82 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;projectDescription&gt;
+	&lt;name&gt;antargis&lt;/name&gt;
+	&lt;comment&gt;&lt;/comment&gt;
+	&lt;projects&gt;
+	&lt;/projects&gt;
+	&lt;buildSpec&gt;
+		&lt;buildCommand&gt;
+			&lt;name&gt;org.eclipse.cdt.managedbuilder.core.genmakebuilder&lt;/name&gt;
+			&lt;triggers&gt;clean,full,incremental,&lt;/triggers&gt;
+			&lt;arguments&gt;
+				&lt;dictionary&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.fullBuildTarget&lt;/key&gt;
+					&lt;value&gt;all&lt;/value&gt;
+				&lt;/dictionary&gt;
+				&lt;dictionary&gt;
+					&lt;key&gt;?name?&lt;/key&gt;
+					&lt;value&gt;&lt;/value&gt;
+				&lt;/dictionary&gt;
+				&lt;dictionary&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.enableAutoBuild&lt;/key&gt;
+					&lt;value&gt;false&lt;/value&gt;
+				&lt;/dictionary&gt;
+				&lt;dictionary&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.buildLocation&lt;/key&gt;
+					&lt;value&gt;${workspace_loc:/antargis/Debug}&lt;/value&gt;
+				&lt;/dictionary&gt;
+				&lt;dictionary&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.enableFullBuild&lt;/key&gt;
+					&lt;value&gt;true&lt;/value&gt;
+				&lt;/dictionary&gt;
+				&lt;dictionary&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.enableCleanBuild&lt;/key&gt;
+					&lt;value&gt;true&lt;/value&gt;
+				&lt;/dictionary&gt;
+				&lt;dictionary&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.cleanBuildTarget&lt;/key&gt;
+					&lt;value&gt;clean&lt;/value&gt;
+				&lt;/dictionary&gt;
+				&lt;dictionary&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.append_environment&lt;/key&gt;
+					&lt;value&gt;true&lt;/value&gt;
+				&lt;/dictionary&gt;
+				&lt;dictionary&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.contents&lt;/key&gt;
+					&lt;value&gt;org.eclipse.cdt.make.core.activeConfigSettings&lt;/value&gt;
+				&lt;/dictionary&gt;
+				&lt;dictionary&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.useDefaultBuildCmd&lt;/key&gt;
+					&lt;value&gt;false&lt;/value&gt;
+				&lt;/dictionary&gt;
+				&lt;dictionary&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.buildArguments&lt;/key&gt;
+					&lt;value&gt;&lt;/value&gt;
+				&lt;/dictionary&gt;
+				&lt;dictionary&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.buildCommand&lt;/key&gt;
+					&lt;value&gt;rake&lt;/value&gt;
+				&lt;/dictionary&gt;
+				&lt;dictionary&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.autoBuildTarget&lt;/key&gt;
+					&lt;value&gt;all&lt;/value&gt;
+				&lt;/dictionary&gt;
+				&lt;dictionary&gt;
+					&lt;key&gt;org.eclipse.cdt.make.core.stopOnError&lt;/key&gt;
+					&lt;value&gt;true&lt;/value&gt;
+				&lt;/dictionary&gt;
+			&lt;/arguments&gt;
+		&lt;/buildCommand&gt;
+		&lt;buildCommand&gt;
+			&lt;name&gt;org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder&lt;/name&gt;
+			&lt;arguments&gt;
+			&lt;/arguments&gt;
+		&lt;/buildCommand&gt;
+	&lt;/buildSpec&gt;
+	&lt;natures&gt;
+		&lt;nature&gt;org.eclipse.cdt.core.cnature&lt;/nature&gt;
+		&lt;nature&gt;org.eclipse.cdt.managedbuilder.core.ScannerConfigNature&lt;/nature&gt;
+		&lt;nature&gt;org.eclipse.cdt.core.ccnature&lt;/nature&gt;
+		&lt;nature&gt;org.eclipse.cdt.managedbuilder.core.managedBuildNature&lt;/nature&gt;
+	&lt;/natures&gt;
+&lt;/projectDescription&gt;

Modified: antargis/trunk/Rakefile
===================================================================
--- antargis/trunk/Rakefile	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/Rakefile	2008-02-24 19:05:29 UTC (rev 1230)
@@ -132,3 +132,6 @@
 desc &quot;Build all&quot;
 task :default=&gt;[:starterPrg,:library] do
 end
+
+task :all=&gt;:default do
+end
\ No newline at end of file

Deleted: antargis/trunk/Rantfile
===================================================================
--- antargis/trunk/Rantfile	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/Rantfile	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,400 +0,0 @@
-import &quot;md5&quot;                         # md5 is needed for automatic checksum-check for changes in files
-import &quot;autoclean&quot;                    # autoclean includes the a simple facility for a clean-make-target
-import &quot;package/tgz&quot;                  # support for packaging (tar.gz, zip)
-import &quot;package/zip&quot;                  # support for packaging (tar.gz, zip)
-import &quot;rubydoc&quot;
-import &quot;c/dependencies&quot;
-require 'pp'
-
-puts &quot;ERROR: Please run ./configure before building!&quot; unless File.exists?(&quot;config.rb&quot;)
-
-begin
-system 'echo &quot;doing this for you now...&quot;;ruby configure' unless File.exists?(&quot;config.rb&quot;)
-rescue;end
-
-require 'config.rb'                   # include build-options
-require 'build/base_tools.rb'
-
-
-
-# get library-dependencies for libSDL
-sdlLibs=$config['LIBS'].split(&quot; &quot;)
-
-allSDLlibs=sdlLibs+[&quot;-lSDL_image&quot;,&quot;-lSDL_ttf&quot;,&quot;-lpng&quot;]
-glLibs=$config[&quot;LIBGL&quot;].split(&quot; &quot;)
-
-# configure source-directories.
-# DLLs will be build for each directory and in the given order.
-# on the left the directory containing the sources is given
-# on the right the dependencies, which can be one of the following:
-# - an external library, which then marked by &quot;-l&quot; in front, like &quot;-lz&quot; for the z-library
-# - an internal dependency on a directory
-# NOTE: dependencies are not automatically inherited, you have to include them yourself!
-
-rubyLib=[$config['RUBYLIB']]
-
-sourceDeps=[
-	[&quot;ext/external&quot;,[&quot;-lz&quot;]+sdlLibs],
-	[&quot;ext/basic&quot;,[&quot;ext/external&quot;,&quot;-lz&quot;]+sdlLibs+rubyLib],
-	[&quot;ext/math&quot;,[&quot;ext/external&quot;,&quot;ext/basic&quot;]],
-	[&quot;ext/video&quot;,[&quot;ext/external&quot;,&quot;ext/basic&quot;,&quot;ext/math&quot;]+glLibs+allSDLlibs],
-	[&quot;ext/gui&quot;,[&quot;ext/basic&quot;,&quot;ext/math&quot;,&quot;ext/video&quot;]+allSDLlibs],
-	[&quot;ext/sound&quot;,[&quot;ext/basic&quot;,&quot;-lSDL_mixer&quot;]+sdlLibs],
-	[&quot;ext/3dengine&quot;,[&quot;ext/external&quot;,&quot;ext/basic&quot;,&quot;ext/math&quot;,&quot;ext/video&quot;,&quot;ext/gui&quot;]+glLibs+sdlLibs],
-	[&quot;ext/game&quot;,[&quot;ext/basic&quot;,&quot;ext/math&quot;,&quot;ext/video&quot;,&quot;ext/gui&quot;,&quot;ext/3dengine&quot;]+glLibs+sdlLibs],
-]
-
-$sourceDeps=sourceDeps
-
-sourceDirs=sourceDeps.collect{|a|a[0]}    # collect dirs containing source (in the correct order !)
-
-externalIncludes=$config['CFLAGS']
-#externalIncludes+=`sdl-config --cflags`.gsub(&quot;\n&quot;,&quot;&quot;)
-
-# sitearchdir - include in usr/local
-rubyIncDir=getConfig(&quot;archdir&quot;)
-    
-# gather include-directories (separately from other cflags, so they can be used for swig later on
-var :INCLUDES =&gt; sourceDirs+[rubyIncDir,&quot;.&quot;]
-
-var :INCLUDESTR =&gt; var[:INCLUDES].collect{|d|&quot;-I#{d}&quot;}.join(&quot; &quot;)+&quot; &quot;+externalIncludes    # build include-string (-I...)
-
-
-# configure cflags out of config.rb
-cflags=&quot;&quot;
-cflags+=&quot; -DGCDEBUG&quot; if $config[&quot;gcdebug&quot;]   # enable debuggin of garbage-collection
-cflags+=&quot; -g -O0&quot;    if $config[&quot;debug&quot;]     # disable optimizations for better debugging
-cflags+=&quot; -DNDEBUG -DMNDEBUG&quot;  if not $config[&quot;debug&quot;] # disable debug-output
-cflags+=&quot; -O0 -g&quot;       unless $config[&quot;debug&quot;] # enable optimizations
-#cflags+=&quot; -O2&quot;       unless $config[&quot;debug&quot;] # enable optimizations
-cflags+=&quot; -DMPROFILE&quot; if $config[&quot;profile&quot;]  # enable profiling
-
-
-# FIXME: discard this before submiting to SVN
-cflags+=&quot; -g -O0&quot;
-	
-
-var :CFLAGS =&gt; var[:INCLUDESTR]+cflags          # store cflags in &quot;var&quot; for later read-out while compiling
-
-var.env %w(CC CFLAGS)                           # get cflags from environment
-
-###########################################
-# all-target
-buildLibs=sourceDirs.collect{|d|&quot;ext/&quot;+&quot;lib&quot;+makeLibName(d)+&quot;.so&quot;}
-interfaceLibs=sourceDirs[1..-1].collect{|d|&quot;ext/&quot;+makeLibName(d)+&quot;.so&quot;} # exclude &quot;ext/external&quot;
-allTargets = buildLibs + interfaceLibs
-task :all =&gt; allTargets
-#
-###########################################
-
-
-
-   
-
-###########################################
-# build libraries (without swig)
-#
-sourceDeps.each{|pair|
-	dir,dep=pair                                                               # get directory and dependencies
-	target=&quot;ext/&quot;+&quot;lib&quot;+makeLibName(dir)+&quot;.so&quot;                    # make library name like &quot;ext/libantargisgui.so&quot;
-	tsources=Dir[dir+&quot;/*.cc&quot;].select{|f|not f=~/swig/}            # get all *.cc files (without the swig-generated file)
-	tsources.collect!{|f|f.sub_ext(&quot;oo&quot;)}                                      # translate the .cc files to .oo
-	tsources+=Dir[dir+&quot;/*.c&quot;].collect!{|f|f.sub_ext(&quot;o&quot;)}         # add *.c files if there are any
-	extlibs=[]
-    
-    #puts &quot;TARGET:&quot;,target
-    #puts &quot;TSOURCES:&quot;,tsources
-    
-	dep.each{|d|
-		if d[0..0]==&quot;-&quot;
-			extlibs &lt;&lt; d                                                           # gather external libraries (-lz)
-		else
-			extlibs+=[&quot;ext/lib&quot;+makeLibName(d)+&quot;.so&quot;]             # gather internal deps like (ext/libantargisbasic.so)
-		end
-	}
-	task target =&gt; tsources do |t|
-		# build command
-		sources=t.prerequisites
-        
-		if ENV['WINDIR']
-                extlibs=extlibs.collect{|s|s.gsub(/.*lib(.*)\.so/,'-l\1')}
-                
-                
-				#puts &quot;SOURCES #{sources}&quot;
-				#puts &quot;EXTLIBS #{extlibs}&quot;
-				sources=sources.select{|f|not f=~/\.so/}
-		end
-		cmd=makeCommand(&quot;LINK_SHARED&quot;,sys.expand_path(U2W(t.name)), (sources.collect{|f|sys.expand_path(f)}+extlibs).join(&quot; &quot;))
-        #puts &quot;------&quot;,cmd,&quot;--------------!&quot;
-		sys cmd
-		puts
-		if isWindows
-				sys &quot;copy #{sys.expand_path(t.name).gsub(&quot;/&quot;,Dir.separator)}.a #{sys.expand_path(t.name).sub(/\.so/,&quot;.dll&quot;).gsub(&quot;/&quot;,Dir.separator)}.a&quot;
-				puts
-		end
-	end
-}
-#
-###########################################
-
-
-###########################################
-# build extension libraries
-#
-sourceDeps.each{|pair|
-	dir,dep=pair
-	libname=makeLibName(dir)
-	target=&quot;ext/&quot;+makeLibName(dir)+&quot;.so&quot;
-
-	# FIXME:re-include this
-	tsources=[]
-	tsources+=[dir+&quot;/&quot;+libname+&quot;swig.cc&quot;]
-	tsources.collect!{|f|f.sub_ext(&quot;oo&quot;)}
-	#tsources+=[&quot;ext/lib&quot;+makeLibName(dir)+&quot;.so&quot;]
-	extlibs=[] #[&quot;-l&quot;+makeLibName(dir)]
-    
-    if isWindows
-	    extlibs+=[&quot;-l&quot;+makeLibName(dir)]
-    end
-    
-	dep.each{|d|
-		if d[0..0]!=&quot;-&quot; and d!=&quot;ext/external&quot;
-			if isWindows
-				extlibs+=[&quot;-l&quot;+makeLibName(d)]
-			else
-				# take some direct path instead ???
-				#tsources+=[&quot;ext/lib&quot;+makeLibName(dir)+&quot;.so&quot;]
-				extlibs+=[&quot;ext/lib&quot;+makeLibName(dir)+&quot;.so&quot;]
-			end
-		end
-	}
-    
-    puts &quot;EXTLIBS:#{extlibs}&quot;
-    #tsources+=rubyLib
-    
-    #puts &quot;TARGET:&quot;,target
-    #puts &quot;SOURES:&quot;,tsources
-    #puts &quot;---&quot;
-	task target =&gt; tsources do |t|
-		cmd=makeCommand(&quot;LINK_SHARED&quot;,sys.expand_path(t.name), (t.prerequisites.collect{|f|sys.expand_path(f)}+extlibs+rubyLib).join(&quot; &quot;))
-        #puts &quot;------&quot;,cmd,&quot;--------------!&quot;
-		sys cmd
-		puts
-	end
-}
-###########################################
-
-
-depC=lambda{|target|
-	source=target.gsub(/\.o$/,&quot;.c&quot;).gsub(/\.oo$/,&quot;.cc&quot;)
-	target=sys.expand_path(target)
-	deps=getDependencies(target)
-	#puts &quot;MUH:&quot;+([source]+deps).join(&quot;:::&quot;)
-	[source]+deps
-}    
-
-###########################################
-# build c
-#
-gen Rule, '.o' =&gt; depC do |t|
-	cmd=makeCommand(&quot;CC_CALL&quot;,sys.expand_path(t.name),&quot;#{var :CFLAGS} #{(t.source)}&quot;)
-	sys cmd
-	puts
-end
-###########################################
-
-###########################################
-# build c++
-#
-gen Rule, '.oo' =&gt; depC do |t|
-	cmd=makeCommand(&quot;CXX_CALL&quot;,sys.expand_path(t.name),&quot;#{var :CFLAGS} #{sys.expand_path(t.source)}&quot;)
-	sys cmd
-	puts
-end
-#
-###########################################
-
-
-###########################################
-# swig - interfacing for ruby
-#
-swigSrc = lambda { |target| 
-	dir=getDirUnix(target)
-    #puts &quot;TARGET:#{target} DIR:#{dir}&quot;
-	name=makeLibName(dir)
-	a=[target.sub(/#{name}swig.*/,&quot;interface.i&quot;)]+sys[&quot;build/*.i&quot;]+importsForInterface(target).split(&quot;:&quot;) 
-    puts &quot;A: #{a}&quot;
-    puts &quot;name: #{name}&quot;
-    puts &quot;dir: #{dir}&quot;
-    puts &quot;target: #{target}&quot;
-    a
-}
-
-gen Rule, /^.*swig.(cc|h)$/ =&gt; swigSrc do |t|
-
-	puts &quot;SOURCE #{t.source} #{t.name}&quot;
-
-	#tsource=sys.expand_path(t.source)
-	tsource=t.source
-
-	#tname=sys.expand_path(t.name.gsub(/\.h$/,&quot;.cc&quot;))
-	tname=t.name.gsub(/\.h$/,&quot;.cc&quot;)
-
-	cmd=makeCommand(&quot;SWIG_CALL&quot;,tname,&quot;-DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR} #{tsource}&quot;.gsub(&quot;/&quot;,Dir.separator))
-	sys cmd
-	puts
-
-	incs=&quot;-DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR}&quot;
-	out=&quot;.deps&quot;+Dir.separator+sys.expand_path(t.name).gsub(&quot;/&quot;,&quot;_&quot;)
-	cmd=makeCommand(&quot;SWIGDEPS&quot;,out,incs+&quot; &quot;+t.name.gsub(/[0-9_a-z]*\.(h|cc)$/,&quot;interface.i&quot;))
-	sys cmd
-	puts
-
-end
-#
-###########################################
-
-
-
-###########################################
-# interface-files for swig
-#
-
-def importsForInterface(name)
-#puts &quot;?==&quot;
-	#puts &quot;importsForInterface:#{name}&quot;
-	$sourceDeps.each{|t|
-		if name=~/#{t[0]}/
-			return t[1].select{|f|not f=~/-.*/}.select{|f|not f=~/external/}.collect{|f|f+&quot;/interface.i&quot;}.join(&quot;:&quot;)
-		end
-	}
-	return &quot;&quot;
-end
-
-interfaceSrc = lambda { |target| 
-	list=Dir[getDirUnix(target)+&quot;/&quot;+&quot;*.h&quot;].select{|f|not f=~/swig.h/}+Dir[&quot;build/*.rb&quot;] # FIXME:replace
-	list+=importsForInterface(target).split(&quot;:&quot;)
-	list
-}
-
-gen Rule, /^.*interface.i$/ =&gt; interfaceSrc do |t|
-	# FIXME: remove expand_ath ???
-    cmd=makeCommand(&quot;CREATEINTERFACE&quot;,getDirUnix(sys.expand_path(t.name)),importsForInterface(t.name))
-	sys cmd
-end
-#
-###########################################
-
-###########################################
-# make swig-sources
-#
-task :swigSources =&gt;sourceDirs.select{|d|not d=~/external/}.collect{|d|d+&quot;/&quot;+makeLibName(d)+&quot;swig.cc&quot;} do
-end
-#
-###########################################
-
-###########################################
-# make rant-stand-alone
-#
-task :rantStandAlone =&gt;[] do |t|
-	cmd=&quot;rant-import --force --auto build.rb&quot;
-    sys cmd
-end
-#
-###########################################
-
-###########################################
-# build extensions
-#
-task :extensions=&gt;allTargets do |t|
-end
-#
-###########################################
-
-
-###########################################
-# build source-distribution
-#
-files=(sys[&quot;build/**/*&quot;]+sys[&quot;ext/**/*&quot;]+sys[&quot;ruby/**/*.rb&quot;]+sys[&quot;data/**/*&quot;]+sys[&quot;*&quot;]).select{|f|not (f=~/~/ or f=~/.xcf/ or f=~/swig/ or f=~/packages/ or f=~/\.o/ or f=~/\.so/)}
-#puts files
-#exit
-
-if isWindows
-    sourcePkg=gen Package::Zip, &quot;packages&quot;,&quot;antargis-source-&quot;+extendCommand($config,&quot;version&quot;), :files =&gt; files
-else
-    sourcePkg=gen Package::Tgz, &quot;packages&quot;,&quot;antargis-source-&quot;+extendCommand($config,&quot;version&quot;), :extension =&gt; &quot;.tar.gz&quot;, :files =&gt; files
-end
-
-task :dist=&gt;[:swigSources,:rantStandAlone,sourcePkg.path] do |t|
-end
-#
-###########################################
-
-###########################################
-# build source-distribution
-#
-if isWindows
-    binpkg=gen Package::Zip, &quot;packages&quot;,&quot;antargis-&quot;+extendCommand($config,&quot;system&quot;)+&quot;-&quot;+extendCommand($config,&quot;version&quot;), :files =&gt; (sys[&quot;ext/*.so&quot;]+sys[&quot;ruby/**/*.rb&quot;]+sys[&quot;data/**/*&quot;]+sys[&quot;*&quot;]).select{|f|not (f=~/~/ or f=~/.xcf/)}
-else
-    binpkg=gen Package::Tgz, &quot;packages&quot;,&quot;antargis-&quot;+extendCommand($config,&quot;system&quot;)+&quot;-&quot;+extendCommand($config,&quot;version&quot;), :extension =&gt; &quot;.tar.gz&quot;, :files =&gt; (sys[&quot;ext/*.so&quot;]+sys[&quot;ruby/**/*.rb&quot;]+sys[&quot;data/**/*&quot;]+sys[&quot;*&quot;]).select{|f|not (f=~/~/ or f=~/.xcf/)}
-end
-
-task :bindist=&gt;[:extensions,binpkg.path] do |t| #&quot;packages/antargis-&quot;+extendCommand($config,&quot;version&quot;)+&quot;.tar.gz&quot;] do |t|
-end
-#
-###########################################
-
-# # build documentation
-# task :doc do
-# 	puts &quot;running doxygen&quot;
-# 	`doxygen Doxyfile`
-# 	rubies=`find -name &quot;*.rb&quot;`.split(&quot;\n&quot;).select{|f|not (f=~/(contrib|skat|test)/)}.join(&quot; &quot;)
-# 	readmes=`find -name &quot;README&quot;`.split(&quot;\n&quot;).select{|f|not (f=~/(contrib|skat|test)/)}.join(&quot; &quot;)
-# 	headers=`find -name &quot;*.h&quot;`.split(&quot;\n&quot;).select{|f|not (f=~/(contrib|skat|test)/)}.join(&quot; &quot;)
-# 	`rdoc -m README --op docs/ruby #{rubies} #{readmes}` # --exclude &quot;(\\.cc|\\.c|skat|test\/|contrib)&quot;`
-# end
-
-desc &quot;Generate html documentation for c++-sources&quot;
-task :doxygen=&gt;[] do |t|
-			# run doxygen in here
- 			`doxygen build/Doxyfile`
- end
-desc &quot;Generate html documentation.&quot;
-	gen RubyDoc do |t|
-			a=sys[&quot;**/README&quot;]+sys[&quot;ruby/**/*.rb&quot;]+sys[&quot;INSTALL&quot;]+sys[&quot;build/*.rb&quot;]+sys[&quot;configure&quot;]+sys[&quot;Rantfile&quot;]
-			a=a.select{|f|not f=~/_test/}
-			t.opts = %w(--title Battles\ of\ Antargis --main README --diagram)+a
-			t.dir = &quot;docs/ruby&quot;
-	end
-
-###########################################
-# configure - clean-task
-gen AutoClean, :clean
-var[:clean].include &quot;**/marker.i&quot;   # not needed any more - managed by Rule
-var[:clean].include &quot;ext/*.so&quot;
-var[:clean].include &quot;.deps&quot;
-###########################################
-
-task :check_c_prgs do
-	require 'build/testing.rb'
-	
-	Cmd.setQuiet(true)
-	
-	testFiles=Dir[File.join(&quot;ext/**/tests/*.cc&quot;)]
-	
-	testFiles.each{|file|
-		Testing.runCTest(file)
-	}
-	puts Testing.getStats
-
-end
-
-task :check=&gt; [:check_c_prgs] do
-end
-
-
-task :spec do
- 	cmd=&quot;find ruby -name \&quot;*.rb\&quot;|grep spec|xargs spec -f h&gt;test.html&quot;
-	`#{cmd}`
-end
-

Modified: antargis/trunk/build/swig/tests/test.cc
===================================================================
--- antargis/trunk/build/swig/tests/test.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/build/swig/tests/test.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -3,53 +3,53 @@
 
 A::A(const AGString &amp;a):m(a)
 {
-	std::cout&lt;&lt;&quot;A::A:&quot;&lt;&lt;a&lt;&lt;std::endl;
+  std::cout&lt;&lt;&quot;A::A:&quot;&lt;&lt;a&lt;&lt;std::endl;
 }
 void A::callTest(const AGString &amp;a)
-{
-	std::cout&lt;&lt;&quot;A::callTest:&quot;&lt;&lt;a&lt;&lt;std::endl;
-}
+  {
+    std::cout&lt;&lt;&quot;A::callTest:&quot;&lt;&lt;a&lt;&lt;std::endl;
+  }
 
 AGString A::returnTest() const
 {
-	return &quot;returnTest&quot;;
+  return &quot;returnTest&quot;;
 }
 
 AGString A::virtReturnTest()
-{
-	return &quot;virtReturnTest&quot;;
-}
+  {
+    return &quot;virtReturnTest&quot;;
+  }
 
 const AGString &amp;A::virtReturnTest2() const
 {
-	return m;
+  return m;
 }
 
 void A::callVirt()
-{
-	std::cout&lt;&lt;virtReturnTest()&lt;&lt;std::endl;
-}
+  {
+    std::cout&lt;&lt;virtReturnTest()&lt;&lt;std::endl;
+  }
 
 void A::callTest2(AGString &amp;a)
-{
-	a=&quot;ksjklkjdslkj&quot;;
-}
+  {
+    a=&quot;ksjklkjdslkj&quot;;
+  }
 
 void A::ptrTest(A *a)
-{
-	std::cout&lt;&lt;a-&gt;m&lt;&lt;std::endl;
-}
+  {
+    std::cout&lt;&lt;a-&gt;m&lt;&lt;std::endl;
+  }
 
 
 
 C::C(const AGString &amp;a):A(a)
 {
-	std::cout&lt;&lt;&quot;C::C:&quot;&lt;&lt;a&lt;&lt;std::endl;
+  std::cout&lt;&lt;&quot;C::C:&quot;&lt;&lt;a&lt;&lt;std::endl;
 }
 
 
 
 AGString C::virtReturnTest()
-{
-	return &quot;virtReturnTest2&quot;;
-}
+  {
+    return &quot;virtReturnTest2&quot;;
+  }

Modified: antargis/trunk/data/levels/tutorial/tutorial0.antlvl
===================================================================
--- antargis/trunk/data/levels/tutorial/tutorial0.antlvl	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/data/levels/tutorial/tutorial0.antlvl	2008-02-24 19:05:29 UTC (rev 1230)
@@ -3,7 +3,7 @@
     &lt;position x=&quot;56.642&quot; y=&quot;51.0992&quot; z=&quot;1.78436&quot;/&gt;
 		&lt;resource food=&quot;30&quot; stone=&quot;50&quot;/&gt;
   &lt;/antTower&gt;
-  &lt;antHero aggression=&quot;3&quot; appearance=&quot;hero&quot; energy=&quot;1&quot; healSpeed=&quot;0.1&quot; morale=&quot;1&quot; name=&quot;&quot; onGround=&quot;true&quot; name=&quot;Rowen&quot; primary=&quot;true&quot;&gt;
+  &lt;antHero aggression=&quot;1&quot; appearance=&quot;hero&quot; energy=&quot;1&quot; healSpeed=&quot;0.1&quot; morale=&quot;1&quot; name=&quot;&quot; onGround=&quot;true&quot; name=&quot;Rowen&quot; primary=&quot;true&quot;&gt;
     &lt;position x=&quot;64.4641&quot; y=&quot;51.154&quot; z=&quot;2.22674&quot;/&gt;
 		&lt;resource food=&quot;10&quot;/&gt;
   &lt;/antHero&gt;

Modified: antargis/trunk/ext/3dengine/anim_mesh.cc
===================================================================
--- antargis/trunk/ext/3dengine/anim_mesh.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/anim_mesh.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -16,54 +16,54 @@
 
 
 void setRotation(AGMatrix4 &amp;m,const AGVector3 &amp;angles)
-{
-  double cr = cos( angles[0] );
-  double sr = sin( angles[0] );
-  double cp = cos( angles[1] );
-  double sp = sin( angles[1] );
-  double cy = cos( angles[2] );
-  double sy = sin( angles[2] );
-  // FIXME: maybe the coord must be switched
+  {
+    double cr = cos( angles[0] );
+    double sr = sin( angles[0] );
+    double cp = cos( angles[1] );
+    double sp = sin( angles[1] );
+    double cy = cos( angles[2] );
+    double sy = sin( angles[2] );
+    // FIXME: maybe the coord must be switched
 
-  m.set(0,0,( float )( cp*cy ));
-  m.set(0,1,( float )( cp*sy ));
-  m.set(0,2,( float )( -sp ));
+    m.set(0,0,( float )( cp*cy ));
+    m.set(0,1,( float )( cp*sy ));
+    m.set(0,2,( float )( -sp ));
     double srsp = sr*sp;
-  double crsp = cr*sp;
+    double crsp = cr*sp;
 
-  m.set(1,0,( float )( srsp*cy-cr*sy ));
-  m.set(1,1,( float )( srsp*sy+cr*cy ));
-  m.set(1,2,( float )( sr*cp ));
-  
-  m.set(2,0,( float )( crsp*cy+sr*sy ));
-  m.set(2,1,( float )( crsp*sy-sr*cy ));
-  m.set(2,2,( float )( cr*cp ));
+    m.set(1,0,( float )( srsp*cy-cr*sy ));
+    m.set(1,1,( float )( srsp*sy+cr*cy ));
+    m.set(1,2,( float )( sr*cp ));
 
-}
+    m.set(2,0,( float )( crsp*cy+sr*sy ));
+    m.set(2,1,( float )( crsp*sy-sr*cy ));
+    m.set(2,2,( float )( cr*cp ));
 
+  }
+
 void setTranslation(AGMatrix4 &amp;m,const AGVector3 &amp;t)
-{
-  m.set(3,0,t[0]);
-  m.set(3,1,t[1]);
-  m.set(3,2,t[2]);
-}
+  {
+    m.set(3,0,t[0]);
+    m.set(3,1,t[1]);
+    m.set(3,2,t[2]);
+  }
 
 
 void inverseRotate(AGVector3 &amp;v, const AGMatrix4 &amp;m )
-{
-  AGVector3 n;
-  n[0]=v[0]*m.get(0,0) + v[1]*m.get(0,1) + v[2]*m.get(0,2);
-  n[1]=v[0]*m.get(1,0) + v[1]*m.get(1,1) + v[2]*m.get(1,2);
-  n[2]=v[0]*m.get(2,0) + v[1]*m.get(2,1) + v[2]*m.get(2,2);
-  v=n;
-}
+  {
+    AGVector3 n;
+    n[0]=v[0]*m.get(0,0) + v[1]*m.get(0,1) + v[2]*m.get(0,2);
+    n[1]=v[0]*m.get(1,0) + v[1]*m.get(1,1) + v[2]*m.get(1,2);
+    n[2]=v[0]*m.get(2,0) + v[1]*m.get(2,1) + v[2]*m.get(2,2);
+    v=n;
+  }
 
 void inverseTranslate(AGVector3 &amp;v, const AGMatrix4 &amp;m )
-{
-  v[0]-=m.get(3,0);
-  v[1]-=m.get(3,1);
-  v[2]-=m.get(3,2);
-}
+  {
+    v[0]-=m.get(3,0);
+    v[1]-=m.get(3,1);
+    v[2]-=m.get(3,2);
+  }
 
 
 
@@ -75,292 +75,292 @@
 AnimMesh::AnimMesh(Scene *pScene,AnimMeshData *data):
   MeshBase(pScene,AGVector4(),data-&gt;bbox()),
   mData(data),mMatrices(data-&gt;bones.size()+1),mShaderMatrices(20)
-{
-  curKey=0;
-  mTime=0;
-  
-  assert(mData-&gt;mAnimations.size()&gt;0);
-  mAnimName=mData-&gt;mAnimations.begin()-&gt;first;
-  mAnimation=&amp;mData-&gt;mAnimations.begin()-&gt;second;
+  {
+    curKey=0;
+    mTime=0;
 
-  mEntity=0;
-  setOrder(MESH_Z);
+    assert(mData-&gt;mAnimations.size()&gt;0);
+    mAnimName=mData-&gt;mAnimations.begin()-&gt;first;
+    mAnimation=&amp;mData-&gt;mAnimations.begin()-&gt;second;
 
-}
+    mEntity=0;
+    setOrder(MESH_Z);
 
+  }
+
 AnimMesh::~AnimMesh()
-{
-  //  CTRACE;
-}
+  {
+    //  CTRACE;
+  }
 
 void AnimMesh::setEntity(AntEntity *e)
-{
-  mEntity=e;
-}
+  {
+    mEntity=e;
+  }
 
 
 void AnimMesh::drawDepth()
-{
-  STACKTRACE;
-  drawPrivate(false,false);
-}
+  {
+    STACKTRACE;
+    drawPrivate(false,false);
+  }
 
 void AnimMesh::draw()
-{
-  STACKTRACE;
-  //return;
-  drawPrivate(true,false);
-}
+  {
+    STACKTRACE;
+    //return;
+    drawPrivate(true,false);
+  }
 void AnimMesh::drawPick()
-{
-  STACKTRACE;
-  drawPrivate(false,true);
-}
+  {
+    STACKTRACE;
+    drawPrivate(false,true);
+  }
 
 
 void AnimMesh::drawPrivate(bool textured, bool mem)
-{
-  assertGL;
-  AGRenderContext c;
-  if(textured)
-    {
-      c.setTexture(mData-&gt;mTexture.glTexture());
-      
-      c.setLighting(true);
-    }
-  c.begin();
-  glPushMatrix();
+  {
+    assertGL;
+    AGRenderContext c;
+    if(textured)
+      {
+        c.setTexture(mData-&gt;mTexture.glTexture());
 
-  AGVector4 p=getPos();
-  glTranslatef(p[0],p[1],p[2]);
-  glRotatef(mRot[3],mRot[0],mRot[1],mRot[2]);
+        c.setLighting(true);
+      }
+    c.begin();
+    glPushMatrix();
 
-  bool pick=mem&amp;&amp;(!textured);
+    AGVector4 p=getPos();
+    glTranslatef(p[0],p[1],p[2]);
+    glRotatef(mRot[3],mRot[0],mRot[1],mRot[2]);
 
+    bool pick=mem&amp;&amp;(!textured);
 
-  if(useShaderAnimation() &amp;&amp; !pick)
-    {
-      glMultMatrixf(mData-&gt;getTransform());
-      if(textured)
-	{
-	  mData-&gt;animShader.enable();
 
-	  mData-&gt;animShader.sendUniform(&quot;matrices&quot;,mShaderMatrices);
-	  
-	  //	  mData-&gt;mArrayDepth.setColors(false);
-	  mData-&gt;mArray.draw();
+    if(useShaderAnimation() &amp;&amp; !pick)
+      {
+        glMultMatrixf(mData-&gt;getTransform());
+        if(textured)
+          {
+            mData-&gt;animShader.enable();
 
-	  mData-&gt;animShader.disable();
+            mData-&gt;animShader.sendUniform(&quot;matrices&quot;,mShaderMatrices);
 
-	}
-      else if(mem)
-	{
-	  mData-&gt;mArray.drawPick();
-	}
-      else
-	{
-	  mData-&gt;animShaderDepth.enable();
+            //mData-&gt;mArrayDepth.setColors(false);
+            mData-&gt;mArray.draw();
 
-	  mData-&gt;animShaderDepth.sendUniform(&quot;matrices&quot;,mShaderMatrices);
+            mData-&gt;animShader.disable();
 
-	  mData-&gt;mArrayDepth.setColors(false);
+          }
+        else if(mem)
+          {
+            mData-&gt;mArray.drawPick();
+          }
+        else
+          {
+            mData-&gt;animShaderDepth.enable();
 
-	  mData-&gt;mArrayDepth.draw(); // FIXME: drawDepth makes some problems here
+            mData-&gt;animShaderDepth.sendUniform(&quot;matrices&quot;,mShaderMatrices);
 
-	  mData-&gt;animShaderDepth.disable();
-	}
-    }
+            mData-&gt;mArrayDepth.setColors(false);
 
-  else if(!mData-&gt;animate)
-    {
-      glBegin(GL_TRIANGLES);
-      
-      // for a start do a simple drawing 
-      for(std::vector&lt;size_t&gt;::iterator i=mData-&gt;indices.begin();i!=mData-&gt;indices.end();i++)
-	{
-	  AGMatrix4 m(mData-&gt;getTransform());
-	  AGVector3 p((m*AGVector4(mData-&gt;pos[*i],1)).dim3());
-	  if(textured)
-	    {
-	      AGVector3 n((m*AGVector4(mData-&gt;normal[*i],0)).dim3());
-	      
-	      glNormal3fv(n);
-	      glTexCoord2fv(mData-&gt;uv[*i]);
-	    }
-	  glVertex3fv(p);
-	  
-	}
-      
-      glEnd();
-    }
-  else
-    {
+            mData-&gt;mArrayDepth.draw(); // FIXME: drawDepth makes some problems here
 
-      // paint with transform
+            mData-&gt;animShaderDepth.disable();
+          }
+      }
 
-      glMultMatrixf(mData-&gt;getTransform());
+    else if(!mData-&gt;animate)
+      {
+        glBegin(GL_TRIANGLES);
 
-      glBegin(GL_TRIANGLES);
-      
-      // for a start do a simple drawing 
-      for(std::vector&lt;size_t&gt;::iterator i=mData-&gt;indices.begin();i!=mData-&gt;indices.end();i++)
-	{
-	  int b=mData-&gt;bone[*i];
-	  AGMatrix4 m;
-	  if(b&gt;=0)
-	    {
-	      m=mMatrices[b];
-	    }
-	  AGVector3 p((m*AGVector4(mData-&gt;pos[*i],1)).dim3());
-	  if(textured)
-	    {
-	      AGVector3 n((m*AGVector4(mData-&gt;normal[*i],0)).dim3());
-	      
-	      glNormal3fv(n);
-	      glTexCoord2fv(mData-&gt;uv[*i]);
-	    }
-	  glVertex3fv(p);
-	}
-      
-      glEnd();
+        // for a start do a simple drawing 
+        for(std::vector&lt;size_t&gt;::iterator i=mData-&gt;indices.begin();i!=mData-&gt;indices.end();i++)
+          {
+            AGMatrix4 m(mData-&gt;getTransform());
+            AGVector3 p((m*AGVector4(mData-&gt;pos[*i],1)).dim3());
+            if(textured)
+              {
+                AGVector3 n((m*AGVector4(mData-&gt;normal[*i],0)).dim3());
 
+                glNormal3fv(n);
+                glTexCoord2fv(mData-&gt;uv[*i]);
+              }
+            glVertex3fv(p);
 
-    }
-  
-  glPopMatrix();
-  assertGL;
-}
+          }
 
+        glEnd();
+      }
+    else
+      {
+
+        // paint with transform
+
+        glMultMatrixf(mData-&gt;getTransform());
+
+        glBegin(GL_TRIANGLES);
+
+        // for a start do a simple drawing 
+        for(std::vector&lt;size_t&gt;::iterator i=mData-&gt;indices.begin();i!=mData-&gt;indices.end();i++)
+          {
+            int b=mData-&gt;bone[*i];
+            AGMatrix4 m;
+            if(b&gt;=0)
+              {
+                m=mMatrices[b];
+              }
+            AGVector3 p((m*AGVector4(mData-&gt;pos[*i],1)).dim3());
+            if(textured)
+              {
+                AGVector3 n((m*AGVector4(mData-&gt;normal[*i],0)).dim3());
+
+                glNormal3fv(n);
+                glTexCoord2fv(mData-&gt;uv[*i]);
+              }
+            glVertex3fv(p);
+          }
+
+        glEnd();
+
+
+      }
+
+    glPopMatrix();
+    assertGL;
+  }
+
 void AnimMesh::advance(float time)
-{
-  if(!mData-&gt;animate)
-    return;
-  float oldTime=mTime;
+  {
+    if(!mData-&gt;animate)
+      return;
+    float oldTime=mTime;
 
-  mTime+=mAnimation-&gt;fps*time;
+    mTime+=mAnimation-&gt;fps*time;
 
-  if(mAnimation-&gt;len&gt;0)
-    {
-      if(mAnimation-&gt;loop)
-	while(mTime&gt;mAnimation-&gt;end)
-	  mTime-=mAnimation-&gt;len;
-      else
-	mTime=std::min(mTime,mAnimation-&gt;end);
-    }
-  else
-    mTime=mAnimation-&gt;begin;
+    if(mAnimation-&gt;len&gt;0)
+      {
+        if(mAnimation-&gt;loop)
+          while(mTime&gt;mAnimation-&gt;end)
+            mTime-=mAnimation-&gt;len;
+        else
+          mTime=std::min(mTime,mAnimation-&gt;end);
+      }
+    else
+      mTime=mAnimation-&gt;begin;
 
-  mTime=std::max(mTime,mAnimation-&gt;begin);
+    mTime=std::max(mTime,mAnimation-&gt;begin);
 
-  //  cdebug(mAnimName&lt;&lt;&quot;  &quot;&lt;&lt;mTime&lt;&lt;&quot;  &quot;&lt;&lt;mAnimation-&gt;len&lt;&lt;&quot; &quot;&lt;&lt;mAnimation-&gt;begin&lt;&lt;&quot; &quot;&lt;&lt;mAnimation-&gt;end);
+    //  cdebug(mAnimName&lt;&lt;&quot;  &quot;&lt;&lt;mTime&lt;&lt;&quot;  &quot;&lt;&lt;mAnimation-&gt;len&lt;&lt;&quot; &quot;&lt;&lt;mAnimation-&gt;begin&lt;&lt;&quot; &quot;&lt;&lt;mAnimation-&gt;end);
 
 
-  // check events
-  if(mEntity &amp;&amp; mData-&gt;frameEvents.size())
-    {
-      if(oldTime&gt;mTime)
-	{
-	  for(std::map&lt;int,AGString&gt;::iterator i=mData-&gt;frameEvents.begin();i!=mData-&gt;frameEvents.end();i++)
-	    if(i-&gt;first&gt;=oldTime || i-&gt;first&lt;mTime)
-	      mEntity-&gt;animationEvent(i-&gt;second);
-	}
-      else
-	{
-	  for(std::map&lt;int,AGString&gt;::iterator i=mData-&gt;frameEvents.begin();i!=mData-&gt;frameEvents.end();i++)
-	    {
-	      if(i-&gt;first&gt;=oldTime &amp;&amp; i-&gt;first&lt;mTime)
-		mEntity-&gt;animationEvent(i-&gt;second);
-	    }
-	}
+    // check events
+    if(mEntity &amp;&amp; mData-&gt;frameEvents.size())
+      {
+        if(oldTime&gt;mTime)
+          {
+            for(std::map&lt;int,AGString&gt;::iterator i=mData-&gt;frameEvents.begin();i!=mData-&gt;frameEvents.end();i++)
+              if(i-&gt;first&gt;=oldTime || i-&gt;first&lt;mTime)
+                mEntity-&gt;animationEvent(i-&gt;second);
+          }
+        else
+          {
+            for(std::map&lt;int,AGString&gt;::iterator i=mData-&gt;frameEvents.begin();i!=mData-&gt;frameEvents.end();i++)
+              {
+                if(i-&gt;first&gt;=oldTime &amp;&amp; i-&gt;first&lt;mTime)
+                  mEntity-&gt;animationEvent(i-&gt;second);
+              }
+          }
 
-    }
+      }
 
 
-  update();
-}
+    update();
+  }
 
 void AnimMesh::update()
-{
-  // this doesn't take much of rendering-time
-  // calculate 
-  
-  while(mTime&gt;mData-&gt;animTime)
-    mTime-=mData-&gt;animTime;
-  
-  for(size_t k=0;k&lt;mData-&gt;bones.size();k++)
-    {
-      Bone *bone=mData-&gt;bones[k];
-      AGMatrix4 final(bone-&gt;mRelative);
-      AGMatrix4 trans;
-      AGVector3 rot,pos;
+  {
+    // this doesn't take much of rendering-time
+    // calculate 
 
-      // first get surrounding keyframes (rot &amp; trans) for this bone 
-      // and calculate ri0,ri1 and ti0,ti1 (1-ti0 == ti1)
+    while(mTime&gt;mData-&gt;animTime)
+      mTime-=mData-&gt;animTime;
 
-      rot=bone-&gt;interpolateRot(mTime);
-      pos=bone-&gt;interpolateTrans(mTime);
+    for(size_t k=0;k&lt;mData-&gt;bones.size();k++)
+      {
+        Bone *bone=mData-&gt;bones[k];
+        AGMatrix4 final(bone-&gt;mRelative);
+        AGMatrix4 trans;
+        AGVector3 rot,pos;
 
-      ::setRotation(trans,rot);
-      setTranslation(trans,pos);
-      
-      
-      final=final*trans;
-      
-      if(mData-&gt;bones[k]-&gt;parent)
-	final=mMatrices[mData-&gt;bones[k]-&gt;parent-&gt;id]*final;
-      
-      mMatrices[k]=final;
-    }
-  mMatrices[mData-&gt;bones.size()]=AGMatrix4();
+        // first get surrounding keyframes (rot &amp; trans) for this bone 
+        // and calculate ri0,ri1 and ti0,ti1 (1-ti0 == ti1)
 
-  for(size_t k=0;k&lt;mData-&gt;bones.size();k++)
-    mShaderMatrices[k]=mData-&gt;getTransform()*mMatrices[k];
-  mShaderMatrices[mData-&gt;bones.size()]=mData-&gt;getTransform()*mMatrices[mData-&gt;bones.size()];
+        rot=bone-&gt;interpolateRot(mTime);
+        pos=bone-&gt;interpolateTrans(mTime);
 
+        ::setRotation(trans,rot);
+        setTranslation(trans,pos);
 
-  for(size_t k=0;k&lt;mData-&gt;bones.size();k++)
-    mShaderMatrices[k]=mMatrices[k];
 
-  mShaderMatrices[mData-&gt;bones.size()]=mMatrices[mData-&gt;bones.size()];
-}
+        final=final*trans;
 
+        if(mData-&gt;bones[k]-&gt;parent)
+          final=mMatrices[mData-&gt;bones[k]-&gt;parent-&gt;id]*final;
 
+        mMatrices[k]=final;
+      }
+    mMatrices[mData-&gt;bones.size()]=AGMatrix4();
+
+    for(size_t k=0;k&lt;mData-&gt;bones.size();k++)
+      mShaderMatrices[k]=mData-&gt;getTransform()*mMatrices[k];
+    mShaderMatrices[mData-&gt;bones.size()]=mData-&gt;getTransform()*mMatrices[mData-&gt;bones.size()];
+
+
+    for(size_t k=0;k&lt;mData-&gt;bones.size();k++)
+      mShaderMatrices[k]=mMatrices[k];
+
+    mShaderMatrices[mData-&gt;bones.size()]=mMatrices[mData-&gt;bones.size()];
+  }
+
+
 AnimMeshData *AnimMesh::getData()
-{
-  return mData;
-}
+  {
+    return mData;
+  }
 
 
 void AnimMesh::setTransform(const AGMatrix4 &amp;m)
-{
-  mTransform=m;
-  assert(mData);
-  mComplete=mData-&gt;getTransform()*mTransform;
-}
+  {
+    mTransform=m;
+    assert(mData);
+    mComplete=mData-&gt;getTransform()*mTransform;
+  }
 
 void AnimMesh::setPos(const AGVector3 &amp;p)
-{
-  SceneNode::setPos(p);
+  {
+    SceneNode::setPos(p);
 
-  mTransform=AGMatrix4(mRot[3],mRot.dim3())*AGMatrix4(getPos());//p);//mPos);
+    mTransform=AGMatrix4(mRot[3],mRot.dim3())*AGMatrix4(getPos());//p);//mPos);
 
-  assert(mData);
-  mComplete=mData-&gt;getTransform()*mTransform;
-}
+    assert(mData);
+    mComplete=mData-&gt;getTransform()*mTransform;
+  }
 void AnimMesh::setRotation(const AGVector3 &amp;r,float a)
-{
-  mRot=AGVector4(r,a);
+  {
+    mRot=AGVector4(r,a);
 
-  mTransform=AGMatrix4(a,r)*AGMatrix4(getPos());
+    mTransform=AGMatrix4(a,r)*AGMatrix4(getPos());
 
-  assert(mData);
-  mComplete=mData-&gt;getTransform()*mTransform;
-}
+    assert(mData);
+    mComplete=mData-&gt;getTransform()*mTransform;
+  }
 
 void AnimMesh::setRotation(float r)
-{
-  setRotation(AGVector3(0,0,1),r+180);
-}
+  {
+    setRotation(AGVector3(0,0,1),r+180);
+  }
 
 AGString AnimMesh::getAnimation() const
 {
@@ -368,25 +368,25 @@
 }
 
 bool AnimMesh::setAnimation(const AGString &amp;pName)
-{
-  if(mAnimName==pName)
+  {
+    if(mAnimName==pName)
+      return true;
+    if(mData-&gt;mAnimations.find(pName)==mData-&gt;mAnimations.end())
+      {
+        cdebug(AGString(&quot;Animation &quot;)+pName+&quot; is known here!&quot;);
+        return false;
+      }
+
+    mAnimation=&amp;(mData-&gt;mAnimations[pName]);
+    mAnimName=pName;
+    mTime=mAnimation-&gt;begin;
     return true;
-  if(mData-&gt;mAnimations.find(pName)==mData-&gt;mAnimations.end())
-    {
-      cdebug(AGString(&quot;Animation &quot;)+pName+&quot; is known here!&quot;);
-      return false;
-    }
+  }
 
-  mAnimation=&amp;(mData-&gt;mAnimations[pName]);
-  mAnimName=pName;
-  mTime=mAnimation-&gt;begin;
-  return true;
-}
-
 void AnimMesh::mark()
-{
-  markObject(mData);
-}
+  {
+    markObject(mData);
+  }
 
 size_t AnimMesh::getTriangles() const
 {

Modified: antargis/trunk/ext/3dengine/anim_mesh_data.cc
===================================================================
--- antargis/trunk/ext/3dengine/anim_mesh_data.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/anim_mesh_data.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -12,50 +12,50 @@
 
 
 bool useAnimation()
-{
-  bool anim=getConfig()-&gt;get(&quot;animationType&quot;)!=&quot;false&quot;;
-  getConfig()-&gt;set(&quot;animationType&quot;,anim?&quot;true&quot;:&quot;false&quot;);
-  return anim;
-}
+  {
+    bool anim=getConfig()-&gt;get(&quot;animationType&quot;)!=&quot;false&quot;;
+    getConfig()-&gt;set(&quot;animationType&quot;,anim?&quot;true&quot;:&quot;false&quot;);
+    return anim;
+  }
 
 bool useShaderAnimation()
-{
-  return glslOk() &amp;&amp; GLEE_ARB_vertex_buffer_object; // doesn't work with vbos
-}
+  {
+    return glslOk() &amp;&amp; GLEE_ARB_vertex_buffer_object; // doesn't work with vbos
+  }
 
 AGVector3 Bone::interpolate(const std::vector&lt;KeyFrame&gt; &amp;frames,float t)
-{
-  size_t i;
-  for(i=0;i&lt;frames.size();i++)
-    {
-      if(frames.size()&gt;i+1)
-	{
-	  if(frames[i+1].time&gt;t)
-	    break;
-	}
-      else
-	break;
-    }
-  size_t j=i+1;
-  if(j&gt;=frames.size())
-    return frames[i].v;
-  
-  float t0=frames[i].time;
-  float t1=frames[j].time;
+  {
+    size_t i;
+    for(i=0;i&lt;frames.size();i++)
+      {
+        if(frames.size()&gt;i+1)
+          {
+            if(frames[i+1].time&gt;t)
+              break;
+          }
+        else
+          break;
+      }
+    size_t j=i+1;
+    if(j&gt;=frames.size())
+      return frames[i].v;
 
-  float i0=(t-t0)/(t1-t0);
-  float i1=1-i0;
+    float t0=frames[i].time;
+    float t1=frames[j].time;
 
-  return frames[i].v*i1 + frames[j].v*i0;
-}
+    float i0=(t-t0)/(t1-t0);
+    float i1=1-i0;
+
+    return frames[i].v*i1 + frames[j].v*i0;
+  }
 AGVector3 Bone::interpolateRot(float t)
-{
-  return interpolate(rFrames,t);
-}
+  {
+    return interpolate(rFrames,t);
+  }
 AGVector3 Bone::interpolateTrans(float t)
-{
-  return interpolate(tFrames,t);
-}
+  {
+    return interpolate(tFrames,t);
+  }
 
 
 
@@ -65,70 +65,70 @@
   animShaderDepth(&quot;data/shaders/anim_depth.vert&quot;,&quot;data/shaders/anim_depth.frag&quot;),
   mArray(&amp;animShader),
   mArrayDepth(&amp;animShaderDepth)
-{
-  Document doc(xmlfile);
+  {
+    Document doc(xmlfile);
 
-  Node &amp;root=doc.root();
+    Node &amp;root=doc.root();
 
-  events=false;
+    events=false;
 
-  animate=true;
-  if(root.get(&quot;debug&quot;)==&quot;true&quot;)
-    animate=false;
-  if(!useAnimation())
-    animate=false;
+    animate=true;
+    if(root.get(&quot;debug&quot;)==&quot;true&quot;)
+      animate=false;
+    if(!useAnimation())
+      animate=false;
 
-  cdebug(&quot;loading from:&quot;&lt;&lt;root.get(&quot;model&quot;));
+    cdebug(&quot;loading from:&quot;&lt;&lt;root.get(&quot;model&quot;));
 
-  loadAnt3(loadFile(root.get(&quot;model&quot;)),root.get(&quot;scale&quot;).toFloat(),root.get(&quot;texture&quot;));
-  
-  // load animations
-  
-  cdebug(&quot;animTime:&quot;&lt;&lt;animTime);
+    loadAnt3(loadFile(root.get(&quot;model&quot;)),root.get(&quot;scale&quot;).toFloat(),root.get(&quot;texture&quot;));
 
-  Node::NodeVector anims=root.getChildren(&quot;animation&quot;);
-  for(Node::NodeVector::iterator i=anims.begin();i!=anims.end();i++)
-    {
-      float begin=(*i)-&gt;get(&quot;begin&quot;).toFloat()-1;
-      float end=(*i)-&gt;get(&quot;end&quot;).toFloat()-1;
-      float fps=(*i)-&gt;get(&quot;fps&quot;).toFloat();
-      assert(fps&gt;0);
-      assert(begin&gt;=0);
-      assert(begin&lt;animTime);
-      assert(begin&lt;=end);
-      assert(end&lt;animTime);
-      mAnimations[(*i)-&gt;get(&quot;name&quot;)]=Animation(begin,end,fps);
+    // load animations
 
-      mAnimations[(*i)-&gt;get(&quot;name&quot;)].loop=((*i)-&gt;get(&quot;loop&quot;)!=&quot;false&quot;);
+    cdebug(&quot;animTime:&quot;&lt;&lt;animTime);
 
-      // parse events
-      Node::NodeVector enodes=(*i)-&gt;getChildren(&quot;event&quot;);
-      for(Node::NodeVector::iterator j=enodes.begin();j!=enodes.end();j++)
-	{
-	  frameEvents.insert(std::make_pair((*j)-&gt;get(&quot;frame&quot;).toInt(),(*j)-&gt;get(&quot;name&quot;)));
-	}
-      
-    }
+    Node::NodeVector anims=root.getChildren(&quot;animation&quot;);
+    for(Node::NodeVector::iterator i=anims.begin();i!=anims.end();i++)
+      {
+        float begin=(*i)-&gt;get(&quot;begin&quot;).toFloat()-1;
+        float end=(*i)-&gt;get(&quot;end&quot;).toFloat()-1;
+        float fps=(*i)-&gt;get(&quot;fps&quot;).toFloat();
+        assert(fps&gt;0);
+        assert(begin&gt;=0);
+        assert(begin&lt;animTime);
+        assert(begin&lt;=end);
+        assert(end&lt;animTime);
+        mAnimations[(*i)-&gt;get(&quot;name&quot;)]=Animation(begin,end,fps);
 
-  if(anims.size()==0)
-    {
-      std::cerr&lt;&lt;&quot;There are no animations in &quot;&lt;&lt;xmlfile&lt;&lt;std::endl;
-      throw std::string(&quot;no animations found in xmlfile&quot;);
-    }
-  mName=AGString(xmlfile);
-}
+        mAnimations[(*i)-&gt;get(&quot;name&quot;)].loop=((*i)-&gt;get(&quot;loop&quot;)!=&quot;false&quot;);
 
+        // parse events
+        Node::NodeVector enodes=(*i)-&gt;getChildren(&quot;event&quot;);
+        for(Node::NodeVector::iterator j=enodes.begin();j!=enodes.end();j++)
+          {
+            frameEvents.insert(std::make_pair((*j)-&gt;get(&quot;frame&quot;).toInt(),(*j)-&gt;get(&quot;name&quot;)));
+          }
+
+      }
+
+    if(anims.size()==0)
+      {
+        std::cerr&lt;&lt;&quot;There are no animations in &quot;&lt;&lt;xmlfile&lt;&lt;std::endl;
+        throw std::string(&quot;no animations found in xmlfile&quot;);
+      }
+    mName=AGString(xmlfile);
+  }
+
 AnimMeshData::~AnimMeshData()
-{
-  CTRACE;
-  cdebug(mName);
+  {
+    CTRACE;
+    cdebug(mName);
 
-  // delete bones
-  for(std::vector&lt;Bone*&gt;::iterator i=bones.begin();i!=bones.end();++i)
-    delete *i;
+    // delete bones
+    for(std::vector&lt;Bone*&gt;::iterator i=bones.begin();i!=bones.end();++i)
+      delete *i;
 
 
-}
+  }
 
 AGBox3 AnimMeshData::bbox() const
 {
@@ -136,131 +136,131 @@
 }
 
 void AnimMeshData::setEvents(bool e)
-{
-  events=e;
-}
+  {
+    events=e;
+  }
 
 
 int getMeshDownScale()
-{
-  int s=1;
-  AGString n=&quot;meshDownScaleExp&quot;;
+  {
+    int s=1;
+    AGString n=&quot;meshDownScaleExp&quot;;
 
-  if(getConfig()-&gt;get(n)!=&quot;&quot;)
-    s=getConfig()-&gt;get(n).toInt();
-  
-  getConfig()-&gt;set(n,AGString(s));
+    if(getConfig()-&gt;get(n)!=&quot;&quot;)
+      s=getConfig()-&gt;get(n).toInt();
 
-  return s;
+    getConfig()-&gt;set(n,AGString(s));
 
-}
+    return s;
 
+  }
+
 void AnimMeshData::loadAnt3(const AGData &amp;instr,float scale,const AGFilename &amp;tex)
-{
-  mTexture=getTextureCache()-&gt;get(tex,getMeshDownScale());
-  BinaryStringIn l(instr);
+  {
+    mTexture=getTextureCache()-&gt;get(tex,getMeshDownScale());
+    BinaryStringIn l(instr);
 
-  Uint32 vs,ts;
+    Uint32 vs,ts;
 
-  l&gt;&gt;vs;
-  for(Uint32 i=0;i&lt;vs;i++)
-    {
-      float x,y,z,tx,ty,nx,ny,nz;
-      Sint32 boneID;
-      l&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;tx&gt;&gt;ty&gt;&gt;boneID&gt;&gt;nx&gt;&gt;ny&gt;&gt;nz;
+    l&gt;&gt;vs;
+    for(Uint32 i=0;i&lt;vs;i++)
+      {
+        float x,y,z,tx,ty,nx,ny,nz;
+        Sint32 boneID;
+        l&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;tx&gt;&gt;ty&gt;&gt;boneID&gt;&gt;nx&gt;&gt;ny&gt;&gt;nz;
 
-      AGVector3 v(x,y,z);
-      v*=scale;
-      mBBox.include(v);
-      pos.push_back(v);
-      uv.push_back(AGVector2(tx,1-ty));
-      normal.push_back(AGVector3(nx,ny,nz));
-      bone.push_back(boneID);
-    }
+        AGVector3 v(x,y,z);
+        v*=scale;
+        mBBox.include(v);
+        pos.push_back(v);
+        uv.push_back(AGVector2(tx,1-ty));
+        normal.push_back(AGVector3(nx,ny,nz));
+        bone.push_back(boneID);
+      }
 
-  l&gt;&gt;ts;
-  Uint32 index;
-  for(Uint32 i=0;i&lt;ts*3;i++)
-    {
-      l&gt;&gt;index;
-      indices.push_back(index);
-    }
+    l&gt;&gt;ts;
+    Uint32 index;
+    for(Uint32 i=0;i&lt;ts*3;i++)
+      {
+        l&gt;&gt;index;
+        indices.push_back(index);
+      }
 
-  Uint32 nbones,frames;
-  l&gt;&gt;frames&gt;&gt;nbones;
+    Uint32 nbones,frames;
+    l&gt;&gt;frames&gt;&gt;nbones;
 
-  for(size_t k=0;k&lt;bone.size();k++)
-    {
-      if(bone[k]==-1)
-	{
-	  bonef.push_back(nbones);
-	  boneui.push_back(nbones);
-	}
-      else
-	{
-	  bonef.push_back(bone[k]);
-	  boneui.push_back(bone[k]);
-	}
-    }
+    for(size_t k=0;k&lt;bone.size();k++)
+      {
+        if(bone[k]==-1)
+          {
+            bonef.push_back(nbones);
+            boneui.push_back(nbones);
+          }
+        else
+          {
+            bonef.push_back(bone[k]);
+            boneui.push_back(bone[k]);
+          }
+      }
 
 
-  animTime=frames;
+    animTime=frames;
 
-  for(Uint32 i=0;i&lt;nbones;i++)
-    {
-      float x,y,z,rx,ry,rz;
-      Sint32 parent;
-      l&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;rx&gt;&gt;ry&gt;&gt;rz&gt;&gt;parent;
-      Bone *bone=new Bone;
-      bone-&gt;id=i;
-      bone-&gt;pos=AGVector3(x,y,z)*scale;
-      bone-&gt;rot=AGVector3(rx,ry,rz);
-      if(parent&lt;0)
-	bone-&gt;parent=0;
-      else
-	{
-	  assert(parent&lt;(int)i);
-	  bone-&gt;parent=bones[parent];
-	}
+    for(Uint32 i=0;i&lt;nbones;i++)
+      {
+        float x,y,z,rx,ry,rz;
+        Sint32 parent;
+        l&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;rx&gt;&gt;ry&gt;&gt;rz&gt;&gt;parent;
+        Bone *bone=new Bone;
+        bone-&gt;id=i;
+        bone-&gt;pos=AGVector3(x,y,z)*scale;
+        bone-&gt;rot=AGVector3(rx,ry,rz);
+        if(parent&lt;0)
+          bone-&gt;parent=0;
+        else
+          {
+            assert(parent&lt;(int)i);
+            bone-&gt;parent=bones[parent];
+          }
 
-      // read rot-frames
-      Sint32 frames;
-      l&gt;&gt;frames;
-      KeyFrame frame;
-      for(Sint32 r=0;r&lt;frames;r++)
-	{
-	  float x,y,z,t;
-	  l&gt;&gt;t&gt;&gt;x&gt;&gt;y&gt;&gt;z;
-	  frame.time=t;
-	  frame.v=AGVector3(x,y,z);
-	  bone-&gt;rFrames.push_back(frame);
-	}
+        // read rot-frames
+        Sint32 frames;
+        l&gt;&gt;frames;
+        KeyFrame frame;
+        for(Sint32 r=0;r&lt;frames;r++)
+          {
+            float x,y,z,t;
+            l&gt;&gt;t&gt;&gt;x&gt;&gt;y&gt;&gt;z;
+            frame.time=t;
+            frame.v=AGVector3(x,y,z);
+            bone-&gt;rFrames.push_back(frame);
+          }
 
-      l&gt;&gt;frames;
-      for(Sint32 r=0;r&lt;frames;r++)
-	{
-	  float x,y,z,t;
-	  l&gt;&gt;t&gt;&gt;x&gt;&gt;y&gt;&gt;z;
-	  frame.time=t;
-	  frame.v=AGVector3(x,y,z)*scale;
-	  bone-&gt;tFrames.push_back(frame);
-	}
+        l&gt;&gt;frames;
+        for(Sint32 r=0;r&lt;frames;r++)
+          {
+            float x,y,z,t;
+            l&gt;&gt;t&gt;&gt;x&gt;&gt;y&gt;&gt;z;
+            frame.time=t;
+            frame.v=AGVector3(x,y,z)*scale;
+            bone-&gt;tFrames.push_back(frame);
+          }
 
 
 
-      bones.push_back(bone);
-    }
+        bones.push_back(bone);
+      }
 
-  if(animate)
-    setupJoints();
+    if(animate)
+      setupJoints();
 
-  setupArray();
-}
+    setupArray();
+  }
 
 void AnimMeshData::setTransform(const AGMatrix4 &amp;m)
-{
-  mBase=m;
-}
+  {
+    mBase=m;
+  }
 
 const AGMatrix4 &amp;AnimMeshData::getTransform() const
 {
@@ -269,62 +269,62 @@
 
 
 void AnimMeshData::setupJoints()
-{
-  for (std::vector&lt;Bone*&gt;::iterator i = bones.begin(); i!=bones.end(); i++ )
-    {
-      Bone&amp; joint = **i;
+  {
+    for (std::vector&lt;Bone*&gt;::iterator i = bones.begin(); i!=bones.end(); i++ )
+      {
+        Bone&amp; joint = **i;
 
-      setRotation(joint.mRelative, joint.rot);
-      setTranslation(joint.mRelative, joint.pos);
+        setRotation(joint.mRelative, joint.rot);
+        setTranslation(joint.mRelative, joint.pos);
 
-      if(joint.parent)
-	joint.mAbsolute=joint.parent-&gt;mAbsolute*joint.mRelative;
-      else
-	joint.mAbsolute=joint.mRelative;
+        if(joint.parent)
+          joint.mAbsolute=joint.parent-&gt;mAbsolute*joint.mRelative;
+        else
+          joint.mAbsolute=joint.mRelative;
 
-    }
+      }
 
-  for (size_t i=0;i&lt;pos.size();i++)
-    {
-      if(bone[i]!=-1)
-	{
-	  AGMatrix4 m(bones[bone[i]]-&gt;mAbsolute);
-	  AGVector3 test=pos[i];
-	  inverseTranslate(pos[i],m);
-	  inverseRotate(pos[i],m);
+    for (size_t i=0;i&lt;pos.size();i++)
+      {
+        if(bone[i]!=-1)
+          {
+            AGMatrix4 m(bones[bone[i]]-&gt;mAbsolute);
+            AGVector3 test=pos[i];
+            inverseTranslate(pos[i],m);
+            inverseRotate(pos[i],m);
 
-	  // normals
-	  inverseRotate(normal[i],m);
-	}
-    }
-}
+            // normals
+            inverseRotate(normal[i],m);
+          }
+      }
+  }
 
 
 void AnimMeshData::setupArray()
-{
-  for(size_t i=0;i&lt;pos.size();i++)
-    mArray.addVertex(AGVector4(pos[i],1),AGVector4(1,1,1,1),normal[i],uv[i]);
-  for(size_t i=0;i&lt;indices.size();i+=3)
-    mArray.addTriangle(indices[i],indices[i+1],indices[i+2]);
+  {
+    for(size_t i=0;i&lt;pos.size();i++)
+      mArray.addVertex(AGVector4(pos[i],1),AGVector4(1,1,1,1),normal[i],uv[i]);
+    for(size_t i=0;i&lt;indices.size();i+=3)
+      mArray.addTriangle(indices[i],indices[i+1],indices[i+2]);
 
-  // set boneIDs
-  mArray.addAttribute(&quot;bones&quot;,bonef);
-  //  mArray.addAttribute(&quot;ibones&quot;,boneui);
+    // set boneIDs
+    mArray.addAttribute(&quot;bones&quot;,bonef);
+    //  mArray.addAttribute(&quot;ibones&quot;,boneui);
 
 
 
 
-  for(size_t i=0;i&lt;pos.size();i++)
-    mArrayDepth.addVertex(AGVector4(pos[i],1),AGVector4(1,1,1,1),normal[i],uv[i]);
-  for(size_t i=0;i&lt;indices.size();i+=3)
-    mArrayDepth.addTriangle(indices[i],indices[i+1],indices[i+2]);
+    for(size_t i=0;i&lt;pos.size();i++)
+      mArrayDepth.addVertex(AGVector4(pos[i],1),AGVector4(1,1,1,1),normal[i],uv[i]);
+    for(size_t i=0;i&lt;indices.size();i+=3)
+      mArrayDepth.addTriangle(indices[i],indices[i+1],indices[i+2]);
 
-  // set boneIDs
-  mArrayDepth.addAttribute(&quot;bones&quot;,bonef);
-  //  mArrayDepth.addAttribute(&quot;ibones&quot;,boneui);
+    // set boneIDs
+    mArrayDepth.addAttribute(&quot;bones&quot;,bonef);
+    //  mArrayDepth.addAttribute(&quot;ibones&quot;,boneui);
 
 
-}
+  }
 
 std::vector&lt;std::string&gt; AnimMeshData::getAnimations() const
 {

Modified: antargis/trunk/ext/3dengine/ant_camera.cc
===================================================================
--- antargis/trunk/ext/3dengine/ant_camera.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/ant_camera.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -20,161 +20,160 @@
 
 #include &quot;ant_camera.h&quot;
 #include &quot;ant_renderer.h&quot;
-#include &lt;GL/gl.h&gt;
-#include &lt;GL/glu.h&gt;
+#include &lt;SDL_opengl.h&gt;
 #include &lt;math.h&gt;
 
 #include &quot;ag_debug.h&quot;
 
 AntCamera::AntCamera(int w,int h)
-{
-  mWidth=w;
-  mHeight=h;
+  {
+    mWidth=w;
+    mHeight=h;
 
-  cameraPosition=AGVector4(0,-20,20);
-  lightPosition=AGVector4( -25, -50, 60,1);
-  scenePosition=AGVector4(0,0,0,1);
+    cameraPosition=AGVector4(0,-20,20);
+    lightPosition=AGVector4( -25, -50, 60,1);
+    scenePosition=AGVector4(0,0,0,1);
 
-  cameraPosition=AGVector4(0,-15,15);
+    cameraPosition=AGVector4(0,-15,15);
 
-  mPSM=false;
-  updateMatrices();
-}
+    mPSM=false;
+    updateMatrices();
+  }
 
 void AntCamera::incCameraDistance()
-{
-  float d=cameraPosition[2]+0.3;
+  {
+    float d=cameraPosition[2]+0.3;
 
-  d=std::min(d,20.0f);
-  cameraPosition=AGVector4(0,-d,d);
-  updateMatrices();
-}
+    d=std::min(d,20.0f);
+    cameraPosition=AGVector4(0,-d,d);
+    updateMatrices();
+  }
 void AntCamera::decCameraDistance()
-{
-  float d=cameraPosition[2]-0.3;
+  {
+    float d=cameraPosition[2]-0.3;
 
-  d=std::max(d,12.0f);
-  cameraPosition=AGVector4(0,-d,d);
-  updateMatrices();
-}
+    d=std::max(d,12.0f);
+    cameraPosition=AGVector4(0,-d,d);
+    updateMatrices();
+  }
 
 
 void AntCamera::updateMatrices()
-{
+  {
 
-  // 1. init camera view matrix
-  glMatrixMode(GL_MODELVIEW);
-  glLoadIdentity();
-  gluLookAt(cameraPosition[0]+scenePosition[0],cameraPosition[1]+scenePosition[1],cameraPosition[2]+scenePosition[2],
-	    scenePosition[0],scenePosition[1],scenePosition[2],
-	    0,0,1);
-  glGetFloatv(GL_MODELVIEW_MATRIX, cameraView);
-  
-  // 2. init camera projection matrix
-  
-  glMatrixMode(GL_PROJECTION);
-  glLoadIdentity();
-  gluPerspective(45.0f, ((float)mWidth)/mHeight, 3.0f, 63.0f);
-  glGetFloatv(GL_PROJECTION_MATRIX, cameraProjection);
-  glMatrixMode(GL_MODELVIEW);
-  if(mPSM)
-    {
-      // PSM
-      // calculation of lightposition is somehow crappy
+    // 1. init camera view matrix
+    glMatrixMode(GL_MODELVIEW);
+    glLoadIdentity();
+    gluLookAt(cameraPosition[0]+scenePosition[0],cameraPosition[1]+scenePosition[1],cameraPosition[2]+scenePosition[2],
+        scenePosition[0],scenePosition[1],scenePosition[2],
+        0,0,1);
+    glGetFloatv(GL_MODELVIEW_MATRIX, cameraView);
 
+    // 2. init camera projection matrix
 
-      // PSMs
-      //  lightPosition=AGVector4( -2.0, -3, 5.1,1)*100;
-      
-      // light View Matrix
-      glLoadIdentity();
-      
-      AGVector4 lp=lightPosition;
-      //    lp[
-      lp[3]=1;
-      lp=cameraProjection*cameraView*lp;
-      
-      lp/=lp[3];
-      
-      // it is something like (12,-10,10)
-      
-      
-      
-      
-      lp=AGVector4(-0.5,1.5,-0.5,1); // should be something like this 
-      lp*=100;
-      
-      
-      //lp=AGVector4(-2,2,-2,1);
-      gluLookAt(lp[0], lp[1], lp[2],
-		0,0,0,
-		0.0f, 1.0f, 0.0f);
-      glGetFloatv(GL_MODELVIEW_MATRIX, lightView);
-      
-      lightView=lightView*cameraProjection*cameraView;
-      // light projection Matrix
-      glLoadIdentity();
-      //    glOrtho(-10,10,-15,20,10,1000);
-      cdebug(lp.toString());
-      float s2=sqrt(2.0f);
-      float ldist=lp.length3();
-      
-      glOrtho(-s2,s2,-s2,s2,ldist-2*s2,ldist+10);//1,10);//ldist-2*s2,ldist+10*s2);
-      
-      
-      //very old:glOrtho(-1,2,-1.5,3,700,750);
-      //      glOrtho(-1,2,-1,1,2,8);
-      
-      glGetFloatv(GL_MODELVIEW_MATRIX, lightProjection);
-    }
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    gluPerspective(45.0f, ((float)mWidth)/mHeight, 3.0f, 63.0f);
+    glGetFloatv(GL_PROJECTION_MATRIX, cameraProjection);
+    glMatrixMode(GL_MODELVIEW);
+    if(mPSM)
+      {
+        // PSM
+        // calculation of lightposition is somehow crappy
 
-    {
-      //  lightPosition=AGVector4( -1.0, -3, 5.1,1);
-      
-      // calc light view,too
-      // light View Matrix
-      glLoadIdentity();
-      gluLookAt(lightPosition[0]+scenePosition[0], lightPosition[1]+scenePosition[1], lightPosition[2]+scenePosition[2],
-		scenePosition[0],scenePosition[1],scenePosition[2],
-		0.0f, 0.0f, 1.0f);
-      glGetFloatv(GL_MODELVIEW_MATRIX, lightView);
-      
-      
-      // light projection Matrix
-      glLoadIdentity();
-      
-	{
+
+        // PSMs
+        //  lightPosition=AGVector4( -2.0, -3, 5.1,1)*100;
+
+        // light View Matrix
+        glLoadIdentity();
+
+        AGVector4 lp=lightPosition;
+        //    lp[
+        lp[3]=1;
+        lp=cameraProjection*cameraView*lp;
+
+        lp/=lp[3];
+
+        // it is something like (12,-10,10)
+
+
+
+
+        lp=AGVector4(-0.5,1.5,-0.5,1); // should be something like this 
+        lp*=100;
+
+
+        //lp=AGVector4(-2,2,-2,1);
+        gluLookAt(lp[0], lp[1], lp[2],
+            0,0,0,
+            0.0f, 1.0f, 0.0f);
+        glGetFloatv(GL_MODELVIEW_MATRIX, lightView);
+
+        lightView=lightView*cameraProjection*cameraView;
+        // light projection Matrix
+        glLoadIdentity();
+        //    glOrtho(-10,10,-15,20,10,1000);
+        cdebug(lp.toString());
+        float s2=sqrt(2.0f);
+        float ldist=lp.length3();
+
+        glOrtho(-s2,s2,-s2,s2,ldist-2*s2,ldist+10);//1,10);//ldist-2*s2,ldist+10*s2);
+
+
+        //very old:glOrtho(-1,2,-1.5,3,700,750);
+        //      glOrtho(-1,2,-1,1,2,8);
+
+        glGetFloatv(GL_MODELVIEW_MATRIX, lightProjection);
+      }
+
+      {
+        //  lightPosition=AGVector4( -1.0, -3, 5.1,1);
+
+        // calc light view,too
+        // light View Matrix
+        glLoadIdentity();
+        gluLookAt(lightPosition[0]+scenePosition[0], lightPosition[1]+scenePosition[1], lightPosition[2]+scenePosition[2],
+            scenePosition[0],scenePosition[1],scenePosition[2],
+            0.0f, 0.0f, 1.0f);
+        glGetFloatv(GL_MODELVIEW_MATRIX, lightView);
+
+
+        // light projection Matrix
+        glLoadIdentity();
+
+          {
 #warning &quot;add some decent calculation here&quot;
-	  // use getFrustum for estimating a good light-frustum
+            // use getFrustum for estimating a good light-frustum
 
-	  float near0=20,near1=60;
-	  float far0=20,far1=110;
+            float near0=20,near1=60;
+            float far0=20,far1=110;
 
-	  float mnear=sqrt(near0*near0+near1*near1);
-	  float mfar=sqrt(far0*far0+far1*far1);
-	  
-	  float left=-25;
-	  float right=14;
-	  float bottom=-15;
-	  float top=14;
+            float mnear=sqrt(near0*near0+near1*near1);
+            float mfar=sqrt(far0*far0+far1*far1);
 
-	  if(getRenderer()-&gt;badShadowMap())
-	    top=bottom+(top-bottom)*1024.0f/768.0f;
+            float left=-25;
+            float right=14;
+            float bottom=-15;
+            float top=14;
 
-	  glFrustum(left, right, bottom, top,
-		    mnear,mfar);
+            if(getRenderer()-&gt;badShadowMap())
+              top=bottom+(top-bottom)*1024.0f/768.0f;
 
-	}
-      
-      glGetFloatv(GL_MODELVIEW_MATRIX, lightProjection);
-    }
+            glFrustum(left, right, bottom, top,
+                mnear,mfar);
 
-    // viewport
-  glMatrixMode(GL_MODELVIEW);
-    
-}
+          }
 
+          glGetFloatv(GL_MODELVIEW_MATRIX, lightProjection);
+      }
 
+      // viewport
+      glMatrixMode(GL_MODELVIEW);
+
+  }
+
+
 Viewport AntCamera::getViewport() const
 {
   Viewport p;
@@ -194,10 +193,10 @@
 }
 
 void AntCamera::setPosition(const AGVector3 &amp;p)
-{
-  scenePosition=AGVector4(p,1);
-  updateMatrices();
-}
+  {
+    scenePosition=AGVector4(p,1);
+    updateMatrices();
+  }
 
 AGVector4 AntCamera::getCameraPosition() const
 {
@@ -231,9 +230,9 @@
 AGMatrix4 AntCamera::getLightComplete() const
 {
   float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
-		0.0f, 0.5f, 0.0f, 0.0f,
-		0.0f, 0.0f, 0.5f, 0.0f,
-		0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
+      0.0f, 0.5f, 0.0f, 0.0f,
+      0.0f, 0.0f, 0.5f, 0.0f,
+      0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
   static AGMatrix4 biasMatrix(bias);
   return biasMatrix*lightProjection*lightView;
 }
@@ -257,12 +256,12 @@
 }
 
 void AntCamera::setWidth(int w)
-{
-  mWidth=w;
-  updateMatrices();
-}
+  {
+    mWidth=w;
+    updateMatrices();
+  }
 void AntCamera::setHeight(int h)
-{
-  mHeight=h;
-  updateMatrices();
-}
+  {
+    mHeight=h;
+    updateMatrices();
+  }

Modified: antargis/trunk/ext/3dengine/ant_particle.cc
===================================================================
--- antargis/trunk/ext/3dengine/ant_particle.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/ant_particle.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -13,190 +13,190 @@
 
 // small caching fct, so that lookup is not that long???
 bool particleEnabled()
-{
-  long ts=getMain()-&gt;getTicks();
-  if(getMain()-&gt;getTicks()-lastParticleTest&gt;1000)
-    {
-      gParticle=getConfig()-&gt;get(&quot;particleEffects&quot;)!=&quot;false&quot;;
-      lastParticleTest=ts;
-      getConfig()-&gt;set(&quot;particleEffects&quot;,gParticle?&quot;true&quot;:&quot;false&quot;);
-    }
+  {
+    long ts=getMain()-&gt;getTicks();
+    if(getMain()-&gt;getTicks()-lastParticleTest&gt;1000)
+      {
+        gParticle=getConfig()-&gt;get(&quot;particleEffects&quot;)!=&quot;false&quot;;
+        lastParticleTest=ts;
+        getConfig()-&gt;set(&quot;particleEffects&quot;,gParticle?&quot;true&quot;:&quot;false&quot;);
+      }
 
-  return gParticle;
-}
+    return gParticle;
+  }
 
 float randf()
-{
-  return (rand()%10000)/10000.0;
-}
+  {
+    return (rand()%10000)/10000.0;
+  }
 
 AntParticle::AntParticle(Scene *pScene,float f):
   SceneNode(pScene,AGVector4(),AGBox3(AGVector3(-0.5,-0.5,0),AGVector3(1,1,10)))
-{
-  maxtime=20;
+  {
+    maxtime=20;
 
-  mtime=0;
-  freq=f;
-  stime=1/freq;
-  if(videoInited())
-    mTexture=getTextureCache()-&gt;get(&quot;data/textures/point.png&quot;);
-  fire=false;
-  setOrder(PARTICLE_Z);
-  enabled=true;
-}
+    mtime=0;
+    freq=f;
+    stime=1/freq;
+    if(videoInited())
+      mTexture=getTextureCache()-&gt;get(&quot;data/textures/point.png&quot;);
+    fire=false;
+    setOrder(PARTICLE_Z);
+    enabled=true;
+  }
 
 AntParticle::~AntParticle()
-{
-  for(std::list&lt;Piece*&gt;::iterator i=mPieces.begin();i!=mPieces.end();i++)
-    delete *i;
-  mPieces.clear();
+  {
+    for(std::list&lt;Piece*&gt;::iterator i=mPieces.begin();i!=mPieces.end();i++)
+      delete *i;
+    mPieces.clear();
 
-}
+  }
 
 void AntParticle::setFire(bool f)
-{
-  fire=f;
-}
+  {
+    fire=f;
+  }
 
 void AntParticle::setMaxTime(float m)
-{
-  maxtime=m;
-}
+  {
+    maxtime=m;
+  }
 
 void AntParticle::advance(float time)
-{
-  STACKTRACE;
-  if(!particleEnabled())
-    return;
-  //  return;
-  // advance pieces
-  for(std::list&lt;Piece*&gt;::iterator i=mPieces.begin();i!=mPieces.end();i++)
-    {
-      (*i)-&gt;lived+=time;
-      // move
-      (*i)-&gt;pos+=(*i)-&gt;speed*time;
-    }
-  // delete old pieces
-  while(mPieces.size())
-    {
-      if(mPieces.back()-&gt;lived&gt;maxtime)
-	{
-	  delete mPieces.back();
-	  mPieces.pop_back();
-	}
-      else
-	break;
-    }
+  {
+    STACKTRACE;
+    if(!particleEnabled())
+      return;
+    //  return;
+    // advance pieces
+    for(std::list&lt;Piece*&gt;::iterator i=mPieces.begin();i!=mPieces.end();i++)
+      {
+        (*i)-&gt;lived+=time;
+        // move
+        (*i)-&gt;pos+=(*i)-&gt;speed*time;
+      }
+    // delete old pieces
+    while(mPieces.size())
+      {
+        if(mPieces.back()-&gt;lived&gt;maxtime)
+          {
+            delete mPieces.back();
+            mPieces.pop_back();
+          }
+        else
+          break;
+      }
 
-  if(!enabled)
-    return;
+    if(!enabled)
+      return;
 
-  // create new piece
-  mtime+=time;
+    // create new piece
+    mtime+=time;
 
-  float timevar=1;
+    float timevar=1;
 
-  if(mtime&gt;stime)
-    {
-      Piece *ps=new Piece;
+    if(mtime&gt;stime)
+      {
+        Piece *ps=new Piece;
 
-      if(fire)
-	{
-	  ps-&gt;pos=getPos().dim3();
-	  ps-&gt;lived=-timevar*randf();
-	  ps-&gt;light=randf()*0.8+0.2;//5+0.5;
-	  ps-&gt;size=randf()*0.05+0.1;
-	  ps-&gt;speed=AGVector3(randf()*0.4-0.2,0,1+randf()*0.5);
-	  ps-&gt;color=AGVector3(1,1,0);
-	}
-      else
-	{
-	  ps-&gt;pos=getPos().dim3();
-	  ps-&gt;lived=-timevar*randf();
-	  ps-&gt;light=randf()*0.2+0.2;//5+0.5;
-	  ps-&gt;size=randf()*0.1+0.2;
-	  ps-&gt;speed=AGVector3(randf()*0.01,0,0.2+randf()*0.1);
-	  ps-&gt;color=AGVector3(1,1,1);
-	}
-      mPieces.push_front(ps);
-      mtime-=stime;
-	  
-    }
-}
+        if(fire)
+          {
+            ps-&gt;pos=getPos().dim3();
+            ps-&gt;lived=-timevar*randf();
+            ps-&gt;light=randf()*0.8+0.2;//5+0.5;
+            ps-&gt;size=randf()*0.05+0.1;
+            ps-&gt;speed=AGVector3(randf()*0.4-0.2,0,1+randf()*0.5);
+            ps-&gt;color=AGVector3(1,1,0);
+          }
+        else
+          {
+            ps-&gt;pos=getPos().dim3();
+            ps-&gt;lived=-timevar*randf();
+            ps-&gt;light=randf()*0.2+0.2;//5+0.5;
+            ps-&gt;size=randf()*0.1+0.2;
+            ps-&gt;speed=AGVector3(randf()*0.01,0,0.2+randf()*0.1);
+            ps-&gt;color=AGVector3(1,1,1);
+          }
+        mPieces.push_front(ps);
+        mtime-=stime;
 
+      }
+  }
+
 void AntParticle::draw()
-{
-  STACKTRACE;
+  {
+    STACKTRACE;
 
-  if(!particleEnabled())
-    return;
+    if(!particleEnabled())
+      return;
 
-  AGVector3 dir=getRenderer()-&gt;getCurrentScene()-&gt;getCameraDirTo(getPos().dim3());
+    AGVector3 dir=getRenderer()-&gt;getCurrentScene()-&gt;getCameraDirTo(getPos().dim3());
 
-  AGVector3 pdown(0,0,-1);
-  AGVector3 side=dir%pdown;
-  AGVector3 up=side%dir;
+    AGVector3 pdown(0,0,-1);
+    AGVector3 side=dir%pdown;
+    AGVector3 up=side%dir;
 
-  side.normalize();
-  up.normalize();
+    side.normalize();
+    up.normalize();
 
-  AGRenderContext c;
-  c.setAlpha(0,GL_NONE);
-  c.setDepthWrite(false);
-  c.setTexture(mTexture.glTexture());
-  c.setColor(AGVector4(1,1,1,1));
-  c.begin();
+    AGRenderContext c;
+    c.setAlpha(0,GL_NONE);
+    c.setDepthWrite(false);
+    c.setTexture(mTexture.glTexture());
+    c.setColor(AGVector4(1,1,1,1));
+    c.begin();
 
-  glBegin(GL_QUADS);
+    glBegin(GL_QUADS);
 
-  float a,s,l;
-  AGVector4 color;
+    float a,s,l;
+    AGVector4 color;
 
-  for(std::list&lt;Piece*&gt;::iterator i=mPieces.begin();i!=mPieces.end();i++)
-    {
-      a=1;
-      if(!fire)
-	if((*i)-&gt;lived&lt;1)
-	  a=(*i)-&gt;lived;
-      
-      a=std::min(maxtime-(*i)-&gt;lived,a);
+    for(std::list&lt;Piece*&gt;::iterator i=mPieces.begin();i!=mPieces.end();i++)
+      {
+        a=1;
+        if(!fire)
+          if((*i)-&gt;lived&lt;1)
+            a=(*i)-&gt;lived;
 
-      l=(*i)-&gt;light;
-      s=(*i)-&gt;size;
-      color=AGVector4((*i)-&gt;color[0]*l,(*i)-&gt;color[1]*l,(*i)-&gt;color[2]*l,a);
-      if(fire)
-	{
-	  float x=maxtime/(*i)-&gt;lived;
-	  x=std::max(std::min(x,1.0f),0.0f);
-	  (*i)-&gt;color=AGVector3(1,0,0)*x+AGVector3(1,1,0)*(1-x);
-	}
-      else
-	{
-	  if((*i)-&gt;lived&lt;3)
-	    s*=(*i)-&gt;lived/3;
-	}
-      glColor4fv(color);
-      glTexCoord2f(0,0);
-      glVertex3fv((*i)-&gt;pos+(AGVector3(0,0,0)-side+up)*s);
+        a=std::min(maxtime-(*i)-&gt;lived,a);
 
-      glColor4fv(color);
-      glTexCoord2f(1,0);
-      glVertex3fv((*i)-&gt;pos+(side+up)*s);
+        l=(*i)-&gt;light;
+        s=(*i)-&gt;size;
+        color=AGVector4((*i)-&gt;color[0]*l,(*i)-&gt;color[1]*l,(*i)-&gt;color[2]*l,a);
+        if(fire)
+          {
+            float x=maxtime/(*i)-&gt;lived;
+            x=std::max(std::min(x,1.0f),0.0f);
+            (*i)-&gt;color=AGVector3(1,0,0)*x+AGVector3(1,1,0)*(1-x);
+          }
+        else
+          {
+            if((*i)-&gt;lived&lt;3)
+              s*=(*i)-&gt;lived/3;
+          }
+        glColor4fv(color);
+        glTexCoord2f(0,0);
+        glVertex3fv((*i)-&gt;pos+(AGVector3(0,0,0)-side+up)*s);
 
-      glColor4fv(color);
-      glTexCoord2f(1,1);
-      glVertex3fv((*i)-&gt;pos+(side-up)*s);
-      
-      glColor4fv(color);
-      glTexCoord2f(0,1);
-      glVertex3fv((*i)-&gt;pos+(AGVector3(0,0,0)-side-up)*s);
+        glColor4fv(color);
+        glTexCoord2f(1,0);
+        glVertex3fv((*i)-&gt;pos+(side+up)*s);
 
-    }
-  glEnd();
-  
-}
+        glColor4fv(color);
+        glTexCoord2f(1,1);
+        glVertex3fv((*i)-&gt;pos+(side-up)*s);
 
+        glColor4fv(color);
+        glTexCoord2f(0,1);
+        glVertex3fv((*i)-&gt;pos+(AGVector3(0,0,0)-side-up)*s);
+
+      }
+    glEnd();
+
+  }
+
 void AntParticle::setEnabled(bool f)
-{
-  enabled=f;
-}
+  {
+    enabled=f;
+  }

Modified: antargis/trunk/ext/3dengine/ant_renderer.cc
===================================================================
--- antargis/trunk/ext/3dengine/ant_renderer.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/ant_renderer.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -13,23 +13,23 @@
   mCanMultitexture(-1),
   mCanShadow(-1),
   mCanGLSL(-1)
-{
-  mFBO=0;
-  CTRACE;
-  GLeeInit(); // this call is essential for letting glee work
-  assert(gRenderer==0);
-  gRenderer=this;
-  mScene=0;
-  
-  AGString shadowType=getConfig()-&gt;get(&quot;shadowType&quot;);
-  if(shadowType==&quot;big&quot; || shadowType==&quot;&quot;)
-    shadowMapSize=1024;
-  else if(shadowType==&quot;small&quot;)
-    shadowMapSize=512;
-  else
-    shadowMapSize=0;
+  {
+    mFBO=0;
+    CTRACE;
+    GLeeInit(); // this call is essential for letting glee work
+    assert(gRenderer==0);
+    gRenderer=this;
+    mScene=0;
 
-  switch(shadowMapSize)
+    AGString shadowType=getConfig()-&gt;get(&quot;shadowType&quot;);
+    if(shadowType==&quot;big&quot; || shadowType==&quot;&quot;)
+      shadowMapSize=1024;
+    else if(shadowType==&quot;small&quot;)
+      shadowMapSize=512;
+    else
+      shadowMapSize=0;
+
+    switch(shadowMapSize)
     {
     case 0:
       getConfig()-&gt;set(&quot;shadowType&quot;,&quot;none&quot;);break;
@@ -38,332 +38,332 @@
     case 1024:
       getConfig()-&gt;set(&quot;shadowType&quot;,&quot;big&quot;);break;
     }
-  
 
-  shadowInited=false;
 
-  if(!GLEE_EXT_texture3D)
-    std::cerr&lt;&lt;&quot;Sorry, Battles of Antargis won't work properly without GL_EXT_texture3D extension!&quot;&lt;&lt;std::endl;
-}
+    shadowInited=false;
 
+    if(!GLEE_EXT_texture3D)
+      std::cerr&lt;&lt;&quot;Sorry, Battles of Antargis won't work properly without GL_EXT_texture3D extension!&quot;&lt;&lt;std::endl;
+  }
+
 Renderer::~Renderer()
-{
-  cdebug(&quot;gRenderer:&quot;&lt;&lt;gRenderer);
-  assert(gRenderer==this);
-  gRenderer=0;
-  delete mFBO;
-}
+  {
+    cdebug(&quot;gRenderer:&quot;&lt;&lt;gRenderer);
+    assert(gRenderer==this);
+    gRenderer=0;
+    delete mFBO;
+  }
 
 bool Renderer::canMultitexture()
-{
-  if(mCanMultitexture&lt;0)
-    mCanMultitexture=GLEE_ARB_multitexture;
-  return mCanMultitexture;
-}
+  {
+    if(mCanMultitexture&lt;0)
+      mCanMultitexture=GLEE_ARB_multitexture;
+    return mCanMultitexture;
+  }
 
 bool Renderer::canShadow()
-{
-  if(mCanShadow&lt;0)
-    mCanShadow=(GLEE_ARB_shadow &amp;&amp; GLEE_ARB_shadow_ambient);
-  return mCanShadow &amp;&amp; shadowMapSize&gt;0;
-}
+  {
+    if(mCanShadow&lt;0)
+      mCanShadow=(GLEE_ARB_shadow &amp;&amp; GLEE_ARB_shadow_ambient);
+    return mCanShadow &amp;&amp; shadowMapSize&gt;0;
+  }
 
 bool Renderer::canGLSL()
-{
-  if(mCanGLSL&lt;0)
-    mCanGLSL=(GLEE_ARB_vertex_shader &amp;&amp; GLEE_ARB_fragment_shader &amp;&amp; GLEE_ARB_shading_language_100);
-  return mCanGLSL;
-}
+  {
+    if(mCanGLSL&lt;0)
+      mCanGLSL=(GLEE_ARB_vertex_shader &amp;&amp; GLEE_ARB_fragment_shader &amp;&amp; GLEE_ARB_shading_language_100);
+    return mCanGLSL;
+  }
 
 void Renderer::setCurrentScene(Scene *scene)
-{
-  mScene=scene;
-}
+  {
+    mScene=scene;
+  }
 
 Scene *Renderer::getCurrentScene()
-{
-  assert(mScene);
-  return mScene;
-}
+  {
+    assert(mScene);
+    return mScene;
+  }
 
 GLint Renderer::getShadowUnit()
-{
-  assert(canMultitexture());
-  return 3;
-}
+  {
+    assert(canMultitexture());
+    return 3;
+  }
 GLint Renderer::getNormalUnit()
-{
-  if(canMultitexture())
-    return 0;
-  else
-    return 0;
-}
+  {
+    if(canMultitexture())
+      return 0;
+    else
+      return 0;
+  }
 
 void Renderer::initShadowTexture()
-{
-  if(!canShadow())
-    return;
+  {
+    if(!canShadow())
+      return;
 
-  if(shadowInited)
-    return;
+    if(shadowInited)
+      return;
 
-  CTRACE;
-  glGenTextures(1, &amp;shadowMapTexture);
-  glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
-  //  glTexImage2D(   GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, shadowMapSize, shadowMapSize, 0,
-  //		  GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, NULL);
-  glTexImage2D(   GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT16, shadowMapSize, shadowMapSize, 0,
-		  GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, NULL);
-  assertGL;
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //NEAREST);
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); //NEAREST);
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-  
-  glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
+    CTRACE;
+    glGenTextures(1, &amp;shadowMapTexture);
+    glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
+    //  glTexImage2D(   GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, shadowMapSize, shadowMapSize, 0,
+    //  GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, NULL);
+    glTexImage2D(   GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT16, shadowMapSize, shadowMapSize, 0,
+        GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, NULL);
+    assertGL;
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); //NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
 
-  shadowInited=true;
+    glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
 
-  if(canFBO())
-    {
-      mFBO=new AGFBO(shadowMapTexture,shadowMapSize,shadowMapSize);//,true);
-    }
+    shadowInited=true;
 
-}
+    if(canFBO())
+      {
+        mFBO=new AGFBO(shadowMapTexture,shadowMapSize,shadowMapSize);//,true);
+      }
 
+  }
+
 void Renderer::beginShadowComputation()
-{
-  if(!shadowInited)
-    initShadowTexture();
+  {
+    if(!shadowInited)
+      initShadowTexture();
 
-  if(mFBO)
-    {
-      mFBO-&gt;beginDraw();
-    }
+    if(mFBO)
+      {
+        mFBO-&gt;beginDraw();
+      }
 
-  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  assertGL;
-  
-  
-  glMatrixMode(GL_PROJECTION);
-  glLoadMatrixf(getCurrentScene()-&gt;getLightProj());
-  
-  glMatrixMode(GL_MODELVIEW);
-  glLoadMatrixf(getCurrentScene()-&gt;getLightView());
-  
-  //Use viewport the same size as the shadow map
-  glViewport(0, 0, shadowMapSize, shadowMapSize);
-  
-  //Draw back faces into the shadow map
-  glCullFace(GL_FRONT);
-  glEnable(GL_CULL_FACE);
-  
-  //Disable color writes, and use flat shading for speed
-  glShadeModel(GL_FLAT);
-  glColorMask(0, 0, 0, 0);
-  
-  //Draw the scene
-  // Offset the drawing a little back, so that slopy surfaces don't get shadowed
-  glEnable(GL_POLYGON_OFFSET_FILL);
-  glPolygonOffset(1,1); // was 1,1
+    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+    assertGL;
 
-  assertGL;
 
-}
+    glMatrixMode(GL_PROJECTION);
+    glLoadMatrixf(getCurrentScene()-&gt;getLightProj());
+
+    glMatrixMode(GL_MODELVIEW);
+    glLoadMatrixf(getCurrentScene()-&gt;getLightView());
+
+    //Use viewport the same size as the shadow map
+    glViewport(0, 0, shadowMapSize, shadowMapSize);
+
+    //Draw back faces into the shadow map
+    glCullFace(GL_FRONT);
+    glEnable(GL_CULL_FACE);
+
+    //Disable color writes, and use flat shading for speed
+    glShadeModel(GL_FLAT);
+    glColorMask(0, 0, 0, 0);
+
+    //Draw the scene
+    // Offset the drawing a little back, so that slopy surfaces don't get shadowed
+    glEnable(GL_POLYGON_OFFSET_FILL);
+    glPolygonOffset(1,1); // was 1,1
+
+    assertGL;
+
+  }
 void Renderer::endShadowComputation()
-{
-  glDisable(GL_POLYGON_OFFSET_FILL);
-  assertGL;
-  //Read the depth buffer into the shadow map texture
-  glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
-  assertGL;
+  {
+    glDisable(GL_POLYGON_OFFSET_FILL);
+    assertGL;
+    //Read the depth buffer into the shadow map texture
+    glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
+    assertGL;
 
-  /// @todo switch to FBOs - this should bring an improvement of 17 to 19 fps
+    /// @todo switch to FBOs - this should bring an improvement of 17 to 19 fps
 
     if(mFBO)
       {
-	mFBO-&gt;endDraw();
+        mFBO-&gt;endDraw();
       }
     else
       {
-	glReadBuffer(GL_BACK);
-	
-	glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, 0, 0, shadowMapSize, shadowMapSize,0);
-	
-	glReadBuffer(GL_FRONT);
+        glReadBuffer(GL_BACK);
+
+        glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, 0, 0, shadowMapSize, shadowMapSize,0);
+
+        glReadBuffer(GL_FRONT);
       }
 
-  assertGL;
+    assertGL;
 
 
-  //restore states
-  assertGL;
-  glCullFace(GL_BACK);
-  
-  glShadeModel(GL_SMOOTH);
-  glColorMask(1, 1, 1, 1);
-}
+    //restore states
+    assertGL;
+    glCullFace(GL_BACK);
 
+    glShadeModel(GL_SMOOTH);
+    glColorMask(1, 1, 1, 1);
+  }
 
+
 void Renderer::beginShadowDrawing()
-{
-  glActiveTexture(getShadowUnit());
+  {
+    glActiveTexture(getShadowUnit());
 
-  glMatrixMode(GL_MODELVIEW);
-  // draw a flat shadow over 
-  //  glDisable(GL_LIGHTING);
-  //  glEnable(GL_COLOR_MATERIAL);
-  assertGL;
-  
+    glMatrixMode(GL_MODELVIEW);
+    // draw a flat shadow over 
+    //  glDisable(GL_LIGHTING);
+    //  glEnable(GL_COLOR_MATERIAL);
+    assertGL;
 
-  if(usePlainGL)
-    {
-      //Calculate texture matrix for projection
-      //This matrix takes us from eye space to the light's clip space
-      //It is postmultiplied by the inverse of the current view matrix when specifying texgen
-      float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
-		    0.0f, 0.5f, 0.0f, 0.0f,
-		    0.0f, 0.0f, 0.5f, 0.0f,
-		    0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
-      static AGMatrix4 biasMatrix(bias);
-      AGMatrix4 textureMatrix=biasMatrix * getCurrentScene()-&gt;getLightProj() * getCurrentScene()-&gt;getLightView();
-      
-      //Set up texture coordinate generation.
-      glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
-      assertGL;
-      glTexGenfv(GL_S, GL_EYE_PLANE, textureMatrix.getRow(0));
-      assertGL;
-      glEnable(GL_TEXTURE_GEN_S);
-      assertGL;
-      
-      glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
-      assertGL;
-      glTexGenfv(GL_T, GL_EYE_PLANE, textureMatrix.getRow(1));
-      assertGL;
-      glEnable(GL_TEXTURE_GEN_T);
-      assertGL;
-      
-      glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
-      assertGL;
-      glTexGenfv(GL_R, GL_EYE_PLANE, textureMatrix.getRow(2));
-      assertGL;
-      glEnable(GL_TEXTURE_GEN_R);
-      
-      assertGL;
-      glTexGeni(GL_Q, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
-      assertGL;
-      glTexGenfv(GL_Q, GL_EYE_PLANE, textureMatrix.getRow(3));
-      assertGL;
-      glEnable(GL_TEXTURE_GEN_Q);
-      assertGL;
-    }
-  
-  //Bind &amp; enable shadow map texture
-  glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
-  glEnable(GL_TEXTURE_2D);
-  
-  //Enable shadow comparison
-  assertGL;
 
-  if(usePlainGL)
-    {
-            
+    if(usePlainGL)
+      {
+        //Calculate texture matrix for projection
+        //This matrix takes us from eye space to the light's clip space
+        //It is postmultiplied by the inverse of the current view matrix when specifying texgen
+        float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
+            0.0f, 0.5f, 0.0f, 0.0f,
+            0.0f, 0.0f, 0.5f, 0.0f,
+            0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
+        static AGMatrix4 biasMatrix(bias);
+        AGMatrix4 textureMatrix=biasMatrix * getCurrentScene()-&gt;getLightProj() * getCurrentScene()-&gt;getLightView();
+
+        //Set up texture coordinate generation.
+        glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+        assertGL;
+        glTexGenfv(GL_S, GL_EYE_PLANE, textureMatrix.getRow(0));
+        assertGL;
+        glEnable(GL_TEXTURE_GEN_S);
+        assertGL;
+
+        glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+        assertGL;
+        glTexGenfv(GL_T, GL_EYE_PLANE, textureMatrix.getRow(1));
+        assertGL;
+        glEnable(GL_TEXTURE_GEN_T);
+        assertGL;
+
+        glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+        assertGL;
+        glTexGenfv(GL_R, GL_EYE_PLANE, textureMatrix.getRow(2));
+        assertGL;
+        glEnable(GL_TEXTURE_GEN_R);
+
+        assertGL;
+        glTexGeni(GL_Q, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+        assertGL;
+        glTexGenfv(GL_Q, GL_EYE_PLANE, textureMatrix.getRow(3));
+        assertGL;
+        glEnable(GL_TEXTURE_GEN_Q);
+        assertGL;
+      }
+
+    //Bind &amp; enable shadow map texture
+    glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
+    glEnable(GL_TEXTURE_2D);
+
+    //Enable shadow comparison
+    assertGL;
+
+    if(usePlainGL)
+      {
+
 #ifndef OLD_SHADOW
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE);
-      assertGL;
-      //Shadow comparison should be true (ie not in shadow) if r&lt;=texture
-      //        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL);
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL); // not needed ???
-      assertGL;
-      
-      //Shadow comparison should generate an INTENSITY result
-      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
-      assertGL;
-      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE);//INTENSITY);
-      assertGL;
-      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 1.0f-0.3f);//shadowAlpha);
-      assertGL;
-      //      glColor4f(0,0,0,0.3);
-      assertGL;
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE);
+        assertGL;
+        //Shadow comparison should be true (ie not in shadow) if r&lt;=texture
+        //        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL); // not needed ???
+        assertGL;
 
-      //      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+        //Shadow comparison should generate an INTENSITY result
+        glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
+        assertGL;
+        glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE);//INTENSITY);
+        assertGL;
+        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 1.0f-0.3f);//shadowAlpha);
+        assertGL;
+        //      glColor4f(0,0,0,0.3);
+        assertGL;
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 
+        //      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+
 #else
-      glEnable(GL_TEXTURE_2D);
-      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE, GL_INTENSITY);  //set this to a &quot;depth texture&quot;
-      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 0.5f);      //set the compare fail value
+        glEnable(GL_TEXTURE_2D);
+        glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE, GL_INTENSITY);  //set this to a &quot;depth texture&quot;
+        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 0.5f);      //set the compare fail value
 
-      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-      
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE_ARB);
+        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
 
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE_ARB);
 
 
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL); // not needed ???
-      assertGL;
-      
-      //Shadow comparison should generate an INTENSITY result
-      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
-      assertGL;
-      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE);//INTENSITY);
 
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL); // not needed ???
+        assertGL;
 
+        //Shadow comparison should generate an INTENSITY result
+        glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
+        assertGL;
+        glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE);//INTENSITY);
 
+
+
         // Set up the eye plane for projecting the shadow map on the scene
 
 #endif
-      //Set alpha test to discard false comparisons
-      //  glAlphaFunc(GL_GREATER,0.99f);//LEQUAL, 0.999f);
-      //      glAlphaFunc(GL_GEQUAL, 0.99f);
-      //      glDisable(GL_ALPHA_TEST);
+        //Set alpha test to discard false comparisons
+        //  glAlphaFunc(GL_GREATER,0.99f);//LEQUAL, 0.999f);
+        //      glAlphaFunc(GL_GEQUAL, 0.99f);
+        //      glDisable(GL_ALPHA_TEST);
 
-      
-    }
 
-  glActiveTexture(getNormalUnit());
-  assertGL;
+      }
 
-}
+    glActiveTexture(getNormalUnit());
+    assertGL;
+
+  }
 void Renderer::endShadowDrawing()
-{
-  assertGL;
+  {
+    assertGL;
 
-  glDisable(GL_POLYGON_OFFSET_FILL);
+    glDisable(GL_POLYGON_OFFSET_FILL);
 
-  glActiveTexture(getShadowUnit());
-  glBindTexture(GL_TEXTURE_2D,0);
+    glActiveTexture(getShadowUnit());
+    glBindTexture(GL_TEXTURE_2D,0);
 
-  if(usePlainGL)
-    {
-      glDisable(GL_ALPHA_TEST);
-      glDisable(GL_TEXTURE_GEN_S);
-      glDisable(GL_TEXTURE_GEN_T);
-      glDisable(GL_TEXTURE_GEN_R);
-      glDisable(GL_TEXTURE_GEN_Q);
-    }
-  glActiveTexture(getNormalUnit());
-  assertGL;
+    if(usePlainGL)
+      {
+        glDisable(GL_ALPHA_TEST);
+        glDisable(GL_TEXTURE_GEN_S);
+        glDisable(GL_TEXTURE_GEN_T);
+        glDisable(GL_TEXTURE_GEN_R);
+        glDisable(GL_TEXTURE_GEN_Q);
+      }
+    glActiveTexture(getNormalUnit());
+    assertGL;
 
-}
+  }
 
 
 bool Renderer::badShadowMap()
-{
-  return shadowMapSize==1024;
-}
+  {
+    return shadowMapSize==1024;
+  }
 
 
 Renderer *getRenderer()
-{
-  if(!gRenderer)
-    {
-      gRenderer=new Renderer;
-      REGISTER_SINGLETON(gRenderer);
-    }
-  assert(gRenderer);
-  return gRenderer;
-}
+  {
+    if(!gRenderer)
+      {
+        gRenderer=new Renderer;
+        REGISTER_SINGLETON(gRenderer);
+      }
+    assert(gRenderer);
+    return gRenderer;
+  }

Modified: antargis/trunk/ext/3dengine/glsl.cc
===================================================================
--- antargis/trunk/ext/3dengine/glsl.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/glsl.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -31,7 +31,7 @@
     }
   return i-&gt;second;
 }
-*/
+ */
 
 bool glslOk();
 
@@ -40,58 +40,58 @@
 
 
 AntVertexProgram::AntVertexProgram(const std::string &amp;pFile)
-{
-  //  CTRACE;
-  if(glslOk())
-    {
-      vertexShader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
-      std::string s=loadFile(pFile);
-      
-      const char*a=s.c_str();
-      const GLcharARB**x=&a;
-      glShaderSourceARB(vertexShader, 1, x,NULL);
-      glCompileShaderARB(vertexShader);
-      printInfoLog(vertexShader);
-      
-    }
-}
+  {
+    //  CTRACE;
+    if(glslOk())
+      {
+        vertexShader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
+        std::string s=loadFile(pFile);
 
+        const char*a=s.c_str();
+        const GLcharARB**x=&a;
+        glShaderSourceARB(vertexShader, 1, x,NULL);
+        glCompileShaderARB(vertexShader);
+        printInfoLog(vertexShader);
+
+      }
+  }
+
 AntVertexProgram::~AntVertexProgram()
-{
-  CTRACE;
-  if(glslOk() &amp;&amp; !hasQuit())
-    glDeleteObjectARB(vertexShader);
-}
+  {
+    CTRACE;
+    if(glslOk() &amp;&amp; !hasQuit())
+      glDeleteObjectARB(vertexShader);
+  }
 
 AntFragProgram::AntFragProgram(const std::string &amp;pFile)
-{
-  mValid=false;
-  //  CTRACE;
-  if(glslOk() &amp;&amp; pFile.length()&gt;0)
-    {
-      fragShader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
-      std::string s=loadFile(pFile);
-      const char*a=s.c_str();
-      const GLcharARB**x=&a;
-      glShaderSourceARB(fragShader, 1, x,NULL);
-      glCompileShaderARB(fragShader);
-      printInfoLog(fragShader);
-      mValid=true;
-      
-    }
-}
+  {
+    mValid=false;
+    //  CTRACE;
+    if(glslOk() &amp;&amp; pFile.length()&gt;0)
+      {
+        fragShader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
+        std::string s=loadFile(pFile);
+        const char*a=s.c_str();
+        const GLcharARB**x=&a;
+        glShaderSourceARB(fragShader, 1, x,NULL);
+        glCompileShaderARB(fragShader);
+        printInfoLog(fragShader);
+        mValid=true;
 
+      }
+  }
+
 AntFragProgram::AntFragProgram()
-{
-  mValid=false;
-}
+  {
+    mValid=false;
+  }
 
 AntFragProgram::~AntFragProgram()
-{
-  CTRACE;
-  if(glslOk() &amp;&amp; !hasQuit())
-    glDeleteObjectARB(fragShader);
-}
+  {
+    CTRACE;
+    if(glslOk() &amp;&amp; !hasQuit())
+      glDeleteObjectARB(fragShader);
+  }
 
 
 bool AntFragProgram::valid() const
@@ -104,184 +104,184 @@
   //  vertex(getVertexProgram(pVertexFile)),frag(getFragProgram(pFragFile))
   mVertexFile(pVertexFile),mFragFile(pFragFile),
   vertex(0),frag(0)
-{
-  //  CTRACE;
-  on=false;
-  matrixBuf=new float[16*100];
-  name=pVertexFile+&quot;:&quot;+pFragFile;
+  {
+    //  CTRACE;
+    on=false;
+    matrixBuf=new float[16*100];
+    name=pVertexFile+&quot;:&quot;+pFragFile;
 
-  init();
-}
+    init();
+  }
 
 AntShaderProgram::~AntShaderProgram()
-{
-  takeDown();
+  {
+    takeDown();
 
-  delete [] matrixBuf;
-}
+    delete [] matrixBuf;
+  }
 
 void AntShaderProgram::onScreenUp()
-{
-  CTRACE;
-  init();
-}
+  {
+    CTRACE;
+    init();
+  }
 void AntShaderProgram::onScreenDown()
-{
-  CTRACE;
-  takeDown();
-}
+  {
+    CTRACE;
+    takeDown();
+  }
 
 
 void AntShaderProgram::init()
-{
- if(glslOk())
-    {
-	  locations.clear();
-	  attrs.clear();
-      vertex=new AntVertexProgram(mVertexFile);
-      frag=new AntFragProgram(mFragFile);
+  {
+    if(glslOk())
+      {
+        locations.clear();
+        attrs.clear();
+        vertex=new AntVertexProgram(mVertexFile);
+        frag=new AntFragProgram(mFragFile);
 
-      p = glCreateProgramObjectARB();
-      glAttachObjectARB(p,vertex-&gt;vertexShader);
-      if(frag-&gt;valid())
-	glAttachObjectARB(p,frag-&gt;fragShader);
-      
-      glLinkProgramARB(p);
-      printInfoLog(p);
+        p = glCreateProgramObjectARB();
+        glAttachObjectARB(p,vertex-&gt;vertexShader);
+        if(frag-&gt;valid())
+          glAttachObjectARB(p,frag-&gt;fragShader);
 
-      assert(p);
-    }
-}
+        glLinkProgramARB(p);
+        printInfoLog(p);
 
+        assert(p);
+      }
+  }
+
 void AntShaderProgram::takeDown()
-{
-  disable();
-  CTRACE;
-  //  cdebug(&quot;name:&quot;&lt;&lt;name);
-  if(glslOk() &amp;&amp; !hasQuit())
-    glDeleteObjectARB(p);
-  //  cdebug(&quot;name:&quot;&lt;&lt;name);
-  delete vertex;
-  delete frag;
-  locations.clear();
-}
+  {
+    disable();
+    CTRACE;
+    //  cdebug(&quot;name:&quot;&lt;&lt;name);
+    if(glslOk() &amp;&amp; !hasQuit())
+      glDeleteObjectARB(p);
+    //  cdebug(&quot;name:&quot;&lt;&lt;name);
+    delete vertex;
+    delete frag;
+    locations.clear();
+  }
 
 
 
 void AntShaderProgram::enable()
-{
-  if(glslOk())
-    {
-      glUseProgramObjectARB(p);
-      on=true;
-    }
-}
+  {
+    if(glslOk())
+      {
+        glUseProgramObjectARB(p);
+        on=true;
+      }
+  }
 void AntShaderProgram::disable()
-{
-  if(glslOk())
-    {
-      glUseProgramObjectARB(0);
-      on=false;
-    }
-}
+  {
+    if(glslOk())
+      {
+        glUseProgramObjectARB(0);
+        on=false;
+      }
+  }
 
 void AntShaderProgram::update(float time)
-{
-  if(glslOk())
-    {
-      enable();
-      doUpdate(time);
-      disable();
-    }
-}
+  {
+    if(glslOk())
+      {
+        enable();
+        doUpdate(time);
+        disable();
+      }
+  }
 
 void AntShaderProgram::doUpdate(float time)
-{
-}
+  {
+  }
 
 void AntShaderProgram::sendUniform(const std::string &amp;pName,int i)
-{
-  glUniform1iARB(getLoc(pName),i);
-}
+  {
+    glUniform1iARB(getLoc(pName),i);
+  }
 void AntShaderProgram::sendUniform(const std::string &amp;pName,float f)
-{
-  glUniform1fARB(getLoc(pName),f);
-}
+  {
+    glUniform1fARB(getLoc(pName),f);
+  }
 void AntShaderProgram::sendUniform(const std::string &amp;pName,const AGVector3 &amp;m)
-{
-  glUniform3fARB(getLoc(pName),m[0],m[1],m[2]);
-}
+  {
+    glUniform3fARB(getLoc(pName),m[0],m[1],m[2]);
+  }
 void AntShaderProgram::sendUniform(const std::string &amp;pName,const AGVector4 &amp;m)
-{
-  glUniform4fARB(getLoc(pName),m[0],m[1],m[2],m[3]);
-}
+  {
+    glUniform4fARB(getLoc(pName),m[0],m[1],m[2],m[3]);
+  }
 void AntShaderProgram::sendUniform(const std::string &amp;pName,const AGMatrix4 &amp;m)
-{
-  glUniformMatrix4fvARB(getLoc(pName),1,false,m);
-}
+  {
+    glUniformMatrix4fvARB(getLoc(pName),1,false,m);
+  }
 void AntShaderProgram::sendUniform(const std::string &amp;pName,const std::vector&lt;AGMatrix4&gt; &amp;m)
-{
-  assert(m.size()&lt;100);
-  float *p=matrixBuf;
+  {
+    assert(m.size()&lt;100);
+    float *p=matrixBuf;
 
-  for(size_t i=0;i&lt;m.size();i++)
-    {
-      const float *s=m[i];
-      for(size_t j=0;j&lt;16;j++)
-	*(p++)=*(s++);
-    }
-  assertGL;
-  glUniformMatrix4fvARB(getLoc(pName),m.size(),false,matrixBuf);
-  assertGL;
-}
+    for(size_t i=0;i&lt;m.size();i++)
+      {
+        const float *s=m[i];
+        for(size_t j=0;j&lt;16;j++)
+          *(p++)=*(s++);
+      }
+    assertGL;
+    glUniformMatrix4fvARB(getLoc(pName),m.size(),false,matrixBuf);
+    assertGL;
+  }
 
 GLint AntShaderProgram::getLoc(const std::string &amp;pName)
-{
-  // register only once !
-  
-  std::map&lt;std::string,GLint&gt;::iterator i=locations.find(pName);
-  if(i!=locations.end())
-    return i-&gt;second;
-  
-  GLint k=glGetUniformLocationARB(p,pName.c_str());
-  locations.insert(std::make_pair(pName,k));
-  return k;
-}
+  {
+    // register only once !
 
+    std::map&lt;std::string,GLint&gt;::iterator i=locations.find(pName);
+    if(i!=locations.end())
+      return i-&gt;second;
+
+    GLint k=glGetUniformLocationARB(p,pName.c_str());
+    locations.insert(std::make_pair(pName,k));
+    return k;
+  }
+
 GLint AntShaderProgram::getAttr(const std::string &amp;pName)
-{
-  //  TRACE;
-  // register only once !
-  assert(on);
-  std::map&lt;std::string,GLint&gt;::iterator i=attrs.find(pName);
-  if(i!=attrs.end())
-    return i-&gt;second;
-  
-  assertGL;
-  GLint k=glGetAttribLocationARB(p,pName.c_str());
-  //  cdebug(&quot;k:&quot;&lt;&lt;k);
-  if(k&lt;0)
-    {
-      cdebug(&quot;ERROR:attribute could be get! Maybe it was not defined in the vertex-shader? :&quot;&lt;&lt;pName);
-    }
-  assertGL;
-  attrs.insert(std::make_pair(pName,k));
-  return k;
-}
+  {
+    //  TRACE;
+    // register only once !
+    assert(on);
+    std::map&lt;std::string,GLint&gt;::iterator i=attrs.find(pName);
+    if(i!=attrs.end())
+      return i-&gt;second;
 
+    assertGL;
+    GLint k=glGetAttribLocationARB(p,pName.c_str());
+    //  cdebug(&quot;k:&quot;&lt;&lt;k);
+    if(k&lt;0)
+      {
+        cdebug(&quot;ERROR:attribute could be get! Maybe it was not defined in the vertex-shader? :&quot;&lt;&lt;pName);
+      }
+    assertGL;
+    attrs.insert(std::make_pair(pName,k));
+    return k;
+  }
+
 void AntShaderProgram::sendAttribute(const std::string &amp;pName,const std::vector&lt;float&gt; &amp;vf)
-{
-  assertGL;
-  GLint loc=getAttr(pName);
-  assertGL;
-  glEnableClientState(GL_VERTEX_ARRAY);
-  assertGL;
-  glEnableVertexAttribArrayARB(loc); // add array
-  assertGL;
+  {
+    assertGL;
+    GLint loc=getAttr(pName);
+    assertGL;
+    glEnableClientState(GL_VERTEX_ARRAY);
+    assertGL;
+    glEnableVertexAttribArrayARB(loc); // add array
+    assertGL;
 
-  glVertexAttribPointerARB(loc,1,GL_FLOAT,0,0,&amp;vf[0]); // set attributes (for each vertex an attribute)
-  assertGL;
-}
+    glVertexAttribPointerARB(loc,1,GL_FLOAT,0,0,&amp;vf[0]); // set attributes (for each vertex an attribute)
+    assertGL;
+  }
 
 
 
@@ -290,61 +290,61 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 AntShadowShader::AntShadowShader(const std::string &amp;pVertexFile,const std::string &amp;pFragFile):
-	AntShaderProgram(pVertexFile,pFragFile)
-{
-}
+  AntShaderProgram(pVertexFile,pFragFile)
+  {
+  }
 
 void AntShadowShader::doUpdate(float time)
-{
-  if(glslOk())
-    {
-      Renderer *r=getRenderer();
-      sendUniform(&quot;shadowTex&quot;,r-&gt;getShadowUnit());
-      sendUniform(&quot;normalTex&quot;,r-&gt;getNormalUnit());
-      sendUniform(&quot;lightComplete&quot;,r-&gt;getCurrentScene()-&gt;getLightComplete());
-    }
-}
+  {
+    if(glslOk())
+      {
+        Renderer *r=getRenderer();
+        sendUniform(&quot;shadowTex&quot;,r-&gt;getShadowUnit());
+        sendUniform(&quot;normalTex&quot;,r-&gt;getNormalUnit());
+        sendUniform(&quot;lightComplete&quot;,r-&gt;getCurrentScene()-&gt;getLightComplete());
+      }
+  }
 
 
 void AntShadowShader::enable()
-{
-  AntShaderProgram::enable();
-  if(glslOk())
-    {
-      Scene *scene=getRenderer()-&gt;getCurrentScene();
+  {
+    AntShaderProgram::enable();
+    if(glslOk())
+      {
+        Scene *scene=getRenderer()-&gt;getCurrentScene();
 
-      glActiveTexture(getRenderer()-&gt;getShadowUnit()); // shadow unit
+        glActiveTexture(getRenderer()-&gt;getShadowUnit()); // shadow unit
 
-      glMatrixMode(GL_TEXTURE);
-      glPushMatrix();
+        glMatrixMode(GL_TEXTURE);
+        glPushMatrix();
 
-      // FIXME: move bias to frag-shader, as this shall reduce z-fighting
-      float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
-		0.0f, 0.5f, 0.0f, 0.0f,
-		0.0f, 0.0f, 0.5f, 0.0f,
-		0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
-      glLoadMatrixf(bias);
+        // FIXME: move bias to frag-shader, as this shall reduce z-fighting
+        float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
+            0.0f, 0.5f, 0.0f, 0.0f,
+            0.0f, 0.0f, 0.5f, 0.0f,
+            0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
+        glLoadMatrixf(bias);
 
-      glMultMatrixf(scene-&gt;getLightProj());
-      glMultMatrixf(scene-&gt;getLightView());
+        glMultMatrixf(scene-&gt;getLightProj());
+        glMultMatrixf(scene-&gt;getLightView());
 
-      glActiveTexture(getRenderer()-&gt;getNormalUnit()); // tex unit
+        glActiveTexture(getRenderer()-&gt;getNormalUnit()); // tex unit
 
-      glMatrixMode(GL_MODELVIEW);
-    }
-}
+        glMatrixMode(GL_MODELVIEW);
+      }
+  }
 void AntShadowShader::disable()
-{
-  AntShaderProgram::disable();
-  if(glslOk())
-    {
-      glActiveTexture(getRenderer()-&gt;getShadowUnit()); // shadow unit
-      glMatrixMode(GL_TEXTURE);
-      glPopMatrix();
-      glMatrixMode(GL_MODELVIEW);
-      glActiveTexture(getRenderer()-&gt;getNormalUnit()); // tex unit
-    }
-}
+  {
+    AntShaderProgram::disable();
+    if(glslOk())
+      {
+        glActiveTexture(getRenderer()-&gt;getShadowUnit()); // shadow unit
+        glMatrixMode(GL_TEXTURE);
+        glPopMatrix();
+        glMatrixMode(GL_MODELVIEW);
+        glActiveTexture(getRenderer()-&gt;getNormalUnit()); // tex unit
+      }
+  }
 
 
 ///////////////////////////////////////////////////////////////////////////
@@ -355,18 +355,18 @@
 
 AntWaterShader::AntWaterShader():
   AntShaderProgram(&quot;data/shaders/simplewater.vert&quot;,&quot;data/shaders/simplewater.frag&quot;)
-{
-}
+  {
+  }
 void AntWaterShader::doUpdate(float time)
-{
-  if(glslOk())
-    {
-      AntShaderProgram::doUpdate(time);
-      
-      t+=time;
-      sendUniform(&quot;time&quot;, t);
-    }
-}
+  {
+    if(glslOk())
+      {
+        AntShaderProgram::doUpdate(time);
 
+        t+=time;
+        sendUniform(&quot;time&quot;, t);
+      }
+  }
 
 
+

Modified: antargis/trunk/ext/3dengine/mesh.cc
===================================================================
--- antargis/trunk/ext/3dengine/mesh.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/mesh.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -16,61 +16,61 @@
 
 Mesh::Mesh(Scene *pScene):
   MeshBase(pScene,AGVector4(),AGBox3())
-{
-  mData=0;
-  mRotation=0;
-  setOrder(MESH_Z);
-  mColor=AGVector4(1,1,1,1);
-  mVisible=true;
-}
+  {
+    mData=0;
+    mRotation=0;
+    setOrder(MESH_Z);
+    mColor=AGVector4(1,1,1,1);
+    mVisible=true;
+  }
 
 Mesh::Mesh(Scene *pScene,MeshData &amp;data,const AGVector4 &amp;pPos,float pRot):
   MeshBase(pScene,pPos,data.bbox())
-{
-  mData=&data;
-  mRotation=pRot;
-  setOrder(MESH_Z);
-  mColor=AGVector4(1,1,1,1);
-  mVisible=true;
-}
+  {
+    mData=&data;
+    mRotation=pRot;
+    setOrder(MESH_Z);
+    mColor=AGVector4(1,1,1,1);
+    mVisible=true;
+  }
 
 Mesh::~Mesh()
-{
-}
+  {
+  }
 
 void Mesh::draw()
-{
-  STACKTRACE;
-  if(!mVisible)
-    return;
+  {
+    STACKTRACE;
+    if(!mVisible)
+      return;
 
-  begin();
-  if(mData)
-    {
-      mData-&gt;draw(mColor);
-    }
-  end();
-}
+    begin();
+    if(mData)
+      {
+        mData-&gt;draw(mColor);
+      }
+    end();
+  }
 void Mesh::drawDepth()
-{
-  STACKTRACE;
-  if(!mVisible)
-    return;
-  begin();
-  if(mData)
-    mData-&gt;drawDepth();
-  end();
-}
+  {
+    STACKTRACE;
+    if(!mVisible)
+      return;
+    begin();
+    if(mData)
+      mData-&gt;drawDepth();
+    end();
+  }
 void Mesh::drawShadow()
-{
-  STACKTRACE;
-  if(!mVisible)
-    return;
-  begin();
-  if(mData)
-    mData-&gt;drawShadow();
-  end();
-}
+  {
+    STACKTRACE;
+    if(!mVisible)
+      return;
+    begin();
+    if(mData)
+      mData-&gt;drawShadow();
+    end();
+  }
 
 size_t Mesh::getTriangles() const
 {
@@ -80,18 +80,18 @@
 }
 
 void Mesh::begin()
-{
-  assertGL;
+  {
+    assertGL;
 
-  glPushMatrix();
-  AGVector4 p=getPos();
-  glTranslatef(p[0],p[1],p[2]);
-  glRotatef(mRotation,0.0,0.0,1.0);
-}
+    glPushMatrix();
+    AGVector4 p=getPos();
+    glTranslatef(p[0],p[1],p[2]);
+    glRotatef(mRotation,0.0,0.0,1.0);
+  }
 void Mesh::end()
-{
-  glPopMatrix();
-}
+  {
+    glPopMatrix();
+  }
 
 
 AGVector4 Mesh::lineHit(const AGLine3 &amp;pLine) const
@@ -101,59 +101,59 @@
   AGMatrix4 rot(-mRotation*M_PI/180.0,AGVector3(0,0,1));
   AGMatrix4 tr(-getPos());
   AGMatrix4 complete=rot*tr;
-  
+
   AGVector4 p0(pLine.getV0(),1);
   AGVector4 p1(pLine.getV1(),1);
-  
+
   p0=complete*p0;
   p1=complete*p1;
   return mData-&gt;lineHit(AGLine3(AGVector3(p0[0],p0[1],p0[2]),
-				AGVector3(p1[0],p1[1],p1[2])))+AGVector4(getPos().dim3(),0);
+      AGVector3(p1[0],p1[1],p1[2])))+AGVector4(getPos().dim3(),0);
 }
 
 void Mesh::setRotation(float r)
-{
-  mRotation=r;
-}
+  {
+    mRotation=r;
+  }
 
 MeshData *Mesh::getData()
-{
-  return mData;
-}
+  {
+    return mData;
+  }
 
 void Mesh::drawPick()
-{
-  STACKTRACE;
+  {
+    STACKTRACE;
 
-  if(!mVisible)
-    return;
-  begin();
+    if(!mVisible)
+      return;
+    begin();
 
-  if(mData)
-    mData-&gt;drawPick();
-  end();
-}
+    if(mData)
+      mData-&gt;drawPick();
+    end();
+  }
 
 
 bool Mesh::transparent()
-{
-  assert(mData);
-  return mData-&gt;transparent();
-}
+  {
+    assert(mData);
+    return mData-&gt;transparent();
+  }
 
 
 void Mesh::mark()
-{
-  markObject(getData());
-}
+  {
+    markObject(getData());
+  }
 
 
 void Mesh::setColor(const AGVector4 &amp;pColor)
-{
-  mColor=pColor;
-}
+  {
+    mColor=pColor;
+  }
 void Mesh::setVisible(bool v)
-{
-  mVisible=v;
-}
+  {
+    mVisible=v;
+  }
 

Modified: antargis/trunk/ext/3dengine/mesh_data.cc
===================================================================
--- antargis/trunk/ext/3dengine/mesh_data.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/mesh_data.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -53,78 +53,65 @@
       mTexture=getTextureCache()-&gt;get(pTexture,getMeshDownScale());
       mWithTexture=true;
     }
-  
+
   MeshVertex mVertices[4];
   MeshOptimizer opt;
   bool withTex=filename.find(&quot;.ant2&quot;)!=filename.npos;
 
   BinaryFileIn f(filename);
   /*
-  
+
   FILE *f=fopen(filename.c_str(),&quot;rb&quot;);
   assert(f);
   fread(&amp;meshes,sizeof(Uint16),1,f);*/
 
   f&gt;&gt;meshes;
-  
+
   for(;meshes&gt;0;meshes--)
     {
       f&gt;&gt;faces;
       //      fread(&amp;faces,sizeof(Uint16),1,f);
-      
+
       for(Uint16 i=0;i&lt;faces;i++)
-	{
-	  //  fread(&amp;vertices,sizeof(Uint16),1,f);
-	  f&gt;&gt;vertices;
-	  assert(vertices&lt;=4);
-	  for(Uint16 j=0;j&lt;vertices;j++)
-	    {
-	      AGVector3 v,n,c;
-	      f&gt;&gt;v;
-	      mVertices[j].v=AGVector4(v,1);
-	      f&gt;&gt;n;
-	      mVertices[j].n=n;
-	      f&gt;&gt;c; // load here first, as mVertices[.].c is a AGVector4
-	      mVertices[j].c=AGVector4(c,1);
-	      if(withTex)
-		f&gt;&gt;mVertices[j].t;
+        {
+          //  fread(&amp;vertices,sizeof(Uint16),1,f);
+          f&gt;&gt;vertices;
+          assert(vertices&lt;=4);
+          for(Uint16 j=0;j&lt;vertices;j++)
+            {
+              AGVector3 v,n,c;
+              f&gt;&gt;v;
+              mVertices[j].v=AGVector4(v,1);
+              f&gt;&gt;n;
+              mVertices[j].n=n;
+              f&gt;&gt;c; // load here first, as mVertices[.].c is a AGVector4
+              mVertices[j].c=AGVector4(c,1);
+              if(withTex)
+                f&gt;&gt;mVertices[j].t;
 
-	      mVertices[j].t[1]=1-mVertices[j].t[1];
+              mVertices[j].t[1]=1-mVertices[j].t[1];
 
-	      mVertices[j].v*=zoom;
-	      mVertices[j].v[3]=1;
+              mVertices[j].v*=zoom;
+              mVertices[j].v[3]=1;
 
-	      mBBox.include(mVertices[j].v.dim3());
-	      /*
-	      fread(mVertices[j].v,sizeof(float),3,f);
-	      fread(mVertices[j].n,sizeof(float),3,f);
-	      fread(mVertices[j].c,sizeof(float),3,f);
-	      if(withTex)
-		fread(mVertices[j].t,sizeof(float),2,f);
-	      mVertices[j].t[1]=1-mVertices[j].t[1];
-
-	      mVertices[j].v*=zoom;
-	      mVertices[j].v[3]=1;
-
-	      mBBox.include(mVertices[j].v.dim3());
-	      */
-	    }
-	  if(vertices==3)
-	    {
-	      opt.add(mVertices[0]);
-	      opt.add(mVertices[1]);
-	      opt.add(mVertices[2]);
-	    }
-	  else
-	    {
-	      opt.add(mVertices[0]);
-	      opt.add(mVertices[1]);
-	      opt.add(mVertices[2]);
-	      opt.add(mVertices[0]);
-	      opt.add(mVertices[2]);
-	      opt.add(mVertices[3]);
-	    }
-	}
+              mBBox.include(mVertices[j].v.dim3());
+            }
+          if(vertices==3)
+            {
+              opt.add(mVertices[0]);
+              opt.add(mVertices[1]);
+              opt.add(mVertices[2]);
+            }
+          else
+            {
+              opt.add(mVertices[0]);
+              opt.add(mVertices[1]);
+              opt.add(mVertices[2]);
+              opt.add(mVertices[0]);
+              opt.add(mVertices[2]);
+              opt.add(mVertices[3]);
+            }
+        }
     }
   //  fclose(f);
   mShadow=pShadow;
@@ -138,24 +125,24 @@
 }
 
 MeshData::~MeshData()
-{
-  //  TRACE;
-}
+  {
+    //  TRACE;
+  }
 
 bool MeshData::transparent()
-{
-  return mTransparent;
-}
+  {
+    return mTransparent;
+  }
 
 void MeshData::setTransparent(bool p)
-{
-  mTransparent=p;
-}
+  {
+    mTransparent=p;
+  }
 
 void MeshData::setLighting(bool l)
-{
-  mLighting=l;
-}
+  {
+    mLighting=l;
+  }
 
 AGBox3 MeshData::bbox() const
 {
@@ -164,158 +151,158 @@
 
 
 void MeshData::save(const std::string &amp;pFilename)
-{
-  FILE *f=fopen(pFilename.c_str(),&quot;wb&quot;);
+  {
+    FILE *f=fopen(pFilename.c_str(),&quot;wb&quot;);
 
-  size_t meshes=1;
-  size_t vertices=3;
-  size_t faces=mArray.getTriangles();
+    size_t meshes=1;
+    size_t vertices=3;
+    size_t faces=mArray.getTriangles();
 
-  // meshes
-  fwrite(&amp;meshes,sizeof(Uint16),1,f);
+    // meshes
+    fwrite(&amp;meshes,sizeof(Uint16),1,f);
 
-  // faces
-  fwrite(&amp;faces,sizeof(Uint16),1,f);
-  for(size_t i=0;i&lt;faces;i++)
-    {
-      fwrite(&amp;vertices,sizeof(Uint16),1,f);
-      for(size_t k=0;k&lt;vertices;k++)
-	{
-	  size_t j=mArray.getIndex(i*vertices+k);
-	  fwrite(mArray.getVertex(j),sizeof(float),3,f);
-	  fwrite(mArray.getNormal(j),sizeof(float),3,f);
-	  fwrite(mArray.getColor(j),sizeof(float),3,f);
-	  fwrite(mArray.getTexCoord(j),sizeof(float),2,f);
-	}
-    }
+    // faces
+    fwrite(&amp;faces,sizeof(Uint16),1,f);
+    for(size_t i=0;i&lt;faces;i++)
+      {
+        fwrite(&amp;vertices,sizeof(Uint16),1,f);
+        for(size_t k=0;k&lt;vertices;k++)
+          {
+            size_t j=mArray.getIndex(i*vertices+k);
+            fwrite(mArray.getVertex(j),sizeof(float),3,f);
+            fwrite(mArray.getNormal(j),sizeof(float),3,f);
+            fwrite(mArray.getColor(j),sizeof(float),3,f);
+            fwrite(mArray.getTexCoord(j),sizeof(float),2,f);
+          }
+      }
 
-  fclose(f);
-}
+    fclose(f);
+  }
 
 
 void MeshData::setOverdraw(bool o)
-{
-  overdraw=o;
-}
+  {
+    overdraw=o;
+  }
 
 void MeshData::drawPick()
-{
-  if(mPickable)
-    mArray.drawPick();
-}
+  {
+    if(mPickable)
+      mArray.drawPick();
+  }
 #ifdef OLD
 void MeshData::draw()
-{
-  if(!mShadow)
-    glDepthMask(false);
+  {
+    if(!mShadow)
+      glDepthMask(false);
 
-  if(mTransparent)
-    glDisable(GL_CULL_FACE);
+    if(mTransparent)
+      glDisable(GL_CULL_FACE);
 
-  glEnable(GL_ALPHA_TEST);
-  glAlphaFunc(GL_GREATER,0.9);
+    glEnable(GL_ALPHA_TEST);
+    glAlphaFunc(GL_GREATER,0.9);
 
 
-  if(mLighting)
-    glEnable(GL_LIGHTING);
-  else
-    glDisable(GL_LIGHTING);
+    if(mLighting)
+      glEnable(GL_LIGHTING);
+    else
+      glDisable(GL_LIGHTING);
 
-  glBindTexture(GL_TEXTURE_2D,0);
-  glEnable(GL_COLOR_MATERIAL);
-  glColorMaterial(GL_FRONT,GL_AMBIENT_AND_DIFFUSE);
-  
+    glBindTexture(GL_TEXTURE_2D,0);
+    glEnable(GL_COLOR_MATERIAL);
+    glColorMaterial(GL_FRONT,GL_AMBIENT_AND_DIFFUSE);
 
-  if(mWithTexture)
-    glBindTexture(GL_TEXTURE_2D,mTexture.getTextureID());
 
-  if(mTransparent)
-    {
-      glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);//_MIPMAP_LINEAR);//NEAREST);//GL_LINEAR);
+    if(mWithTexture)
+      glBindTexture(GL_TEXTURE_2D,mTexture.getTextureID());
 
-      //      glDisable(GL_LIGHTING);
-      glAlphaFunc(GL_GREATER,0.4f);
-      glEnable(GL_ALPHA_TEST);
-    }
-  if(overdraw)
-    {
-      glDisable(GL_ALPHA_TEST);
-      glDisable(GL_DEPTH_TEST);
-    }
-  mArray.setColors(drawColors);
-  mArray.draw();
-  if(overdraw)
-    {
-      glEnable(GL_DEPTH_TEST);
-      glEnable(GL_ALPHA_TEST);
-    }
-  if(mTransparent)
-    {
-      glAlphaFunc(GL_GREATER,0.9f);
-      glEnable(GL_LIGHTING);
-    }
-  //    glEnable(GL_ALPHA_TEST);
+    if(mTransparent)
+      {
+        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);//_MIPMAP_LINEAR);//NEAREST);//GL_LINEAR);
 
+        //      glDisable(GL_LIGHTING);
+        glAlphaFunc(GL_GREATER,0.4f);
+        glEnable(GL_ALPHA_TEST);
+      }
+    if(overdraw)
+      {
+        glDisable(GL_ALPHA_TEST);
+        glDisable(GL_DEPTH_TEST);
+      }
+    mArray.setColors(drawColors);
+    mArray.draw();
+    if(overdraw)
+      {
+        glEnable(GL_DEPTH_TEST);
+        glEnable(GL_ALPHA_TEST);
+      }
+    if(mTransparent)
+      {
+        glAlphaFunc(GL_GREATER,0.9f);
+        glEnable(GL_LIGHTING);
+      }
+    //    glEnable(GL_ALPHA_TEST);
 
-  glBindTexture(GL_TEXTURE_2D,0);
-  if(!mShadow)
-    glDepthMask(true);
 
-  glDisable(GL_ALPHA_TEST);
-  if(mTransparent)
-    glEnable(GL_CULL_FACE);
-}
+    glBindTexture(GL_TEXTURE_2D,0);
+    if(!mShadow)
+      glDepthMask(true);
+
+    glDisable(GL_ALPHA_TEST);
+    if(mTransparent)
+      glEnable(GL_CULL_FACE);
+  }
 #else
 
 void MeshData::setCulling(bool c)
-{
-  mCulling=c;
-}
+  {
+    mCulling=c;
+  }
 
 
 void MeshData::draw(const AGVector4 &amp;pColor)
-{
-  AGRenderContext c;
-  
-  if(!mShadow)
-    c.setDepthWrite(false);
+  {
+    AGRenderContext c;
 
-  //  if(mTransparent)
-  c.setCulling(mCulling);
+    if(!mShadow)
+      c.setDepthWrite(false);
 
-  c.setAlpha(0.9,GL_GREATER);
+    //  if(mTransparent)
+    c.setCulling(mCulling);
 
-  c.setLighting(mLighting);
+    c.setAlpha(0.9,GL_GREATER);
 
-  if(pColor!=AGVector4(1,1,1,1))
-    c.setColor(pColor);
+    c.setLighting(mLighting);
 
-  if(mWithTexture)
-    c.setTexture(mTexture.glTexture());
+    if(pColor!=AGVector4(1,1,1,1))
+      c.setColor(pColor);
 
-  if(mTransparent)
-    {
-      mTexture.setFilter(GL_LINEAR,GL_LINEAR);
-      c.setAlpha(0.4f,GL_GREATER);
-    }
-  if(overdraw)
-    {
-      c.setDepthWrite(false);
-      c.setDepthTest(false);
-      c.setAlpha(0,GL_NONE);
-    }
-  c.begin();
-  mArray.setColors(drawColors);
-  mArray.draw();
-}
+    if(mWithTexture)
+      c.setTexture(mTexture.glTexture());
 
+    if(mTransparent)
+      {
+        mTexture.setFilter(GL_LINEAR,GL_LINEAR);
+        c.setAlpha(0.4f,GL_GREATER);
+      }
+    if(overdraw)
+      {
+        c.setDepthWrite(false);
+        c.setDepthTest(false);
+        c.setAlpha(0,GL_NONE);
+      }
+    c.begin();
+    mArray.setColors(drawColors);
+    mArray.draw();
+  }
+
 #endif
 
 
 void MeshData::setColors(bool c)
-{
-  drawColors=c;
-}
+  {
+    drawColors=c;
+  }
 
 size_t MeshData::getTriangles() const
 {
@@ -323,69 +310,69 @@
 }
 
 void MeshData::drawShadow()
-{
-  if(mTransparent)
-    glDisable(GL_CULL_FACE);
+  {
+    if(mTransparent)
+      glDisable(GL_CULL_FACE);
 
-  drawDepth();
+    drawDepth();
 
-  if(mTransparent)
-    glEnable(GL_CULL_FACE);
-}
+    if(mTransparent)
+      glEnable(GL_CULL_FACE);
+  }
 void MeshData::drawDepth()
-{
-  assertGL;
-  AGRenderContext c;
-  if(mTransparent)
-    {
-      c.setCulling(false);
-      c.setAlpha(0.9f,GL_GREATER);
-      c.setTexture(mTexture.glTexture());
-      /*
+  {
+    assertGL;
+    AGRenderContext c;
+    if(mTransparent)
+      {
+        c.setCulling(false);
+        c.setAlpha(0.9f,GL_GREATER);
+        c.setTexture(mTexture.glTexture());
+        /*
       glDisable(GL_CULL_FACE);
       //      throw int();
 
       glBindTexture(GL_TEXTURE_2D,mTexture.getTextureID());
       glEnable(GL_ALPHA_TEST);
       glAlphaFunc(GL_GREATER,0.9f);
-      */
-      //      cdebug(&quot;muh&quot;);
-    }
-  c.begin();
-  assertGL;
-  if(mShadow)
+         */
+        //      cdebug(&quot;muh&quot;);
+      }
+    c.begin();
+    assertGL;
+    if(mShadow)
+      {
+        mArray.setColors(false);
+        mArray.draw();
+        mArray.setColors(true);
+      }
+    /*  if(mTransparent)
     {
-      mArray.setColors(false);
-      mArray.draw();
-      mArray.setColors(true);
-    }
-  /*  if(mTransparent)
-    {
       glEnable(GL_CULL_FACE);
       glBindTexture(GL_TEXTURE_2D,0);
       }*/
-}
+  }
 
 void MeshData::texCoordFromPos(float scale)
-{
-  for(size_t i=0;i&lt;mArray.getTriangles()*3;i++)
-    {
-      size_t j=mArray.getIndex(i);
+  {
+    for(size_t i=0;i&lt;mArray.getTriangles()*3;i++)
+      {
+        size_t j=mArray.getIndex(i);
 
-      AGVector4 v=mArray.getVertex(j);
-      AGVector2 t(v[0]+v[1],v[2]);
-      mArray.setTexCoord(j,t*scale);
-    }
-}
+        AGVector4 v=mArray.getVertex(j);
+        AGVector2 t(v[0]+v[1],v[2]);
+        mArray.setTexCoord(j,t*scale);
+      }
+  }
 
 void MeshData::setPickable(bool p)
-{
-  mPickable=p;
-}
+  {
+    mPickable=p;
+  }
 
 void MeshData::makeInstances(const std::vector&lt;AGMatrix4&gt; &amp;ts)
-{
-  VertexArray *va=::makeInstances(mArray,ts);
-  mArray=*va;
-  delete va;
-}
+  {
+    VertexArray *va=::makeInstances(mArray,ts);
+    mArray=*va;
+    delete va;
+  }

Modified: antargis/trunk/ext/3dengine/mesh_optimizer.cc
===================================================================
--- antargis/trunk/ext/3dengine/mesh_optimizer.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/mesh_optimizer.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -13,56 +13,56 @@
   for(i=0;i&lt;3;i++)
     if(v[i]&lt;p.v[i])
       return true;
-  
+
   for(i=0;i&lt;4;i++)
     if(c[i]&lt;p.c[i])
       return true;
-  
+
   for(i=0;i&lt;3;i++) 
     if(n[i]&lt;p.n[i]) 
       return true; 
-  
+
   for(i=0;i&lt;2;i++)
     if(t[i]&lt;p.t[i]) 
       return true;
-  
-    return false;
+
+  return false;
 }
 
 
 MeshOptimizer::MeshOptimizer()
-{
-  saved=0;
-}
+  {
+    saved=0;
+  }
 void MeshOptimizer::add(const MeshVertex &amp;v)
-{
-  size_t index=mVertices.size();
-  std::map&lt;MeshVertex,int&gt;::iterator i=mMap.find(v);
-  if(i!=mMap.end())
-    {
-      saved++;
-      index=i-&gt;second;
-    }
-  else
-    {
-      mVertices.push_back(v);
-      mMap[v]=index;
-    }
-  assert(index&lt;mVertices.size());
-  mIndices.push_back(index);
-  return;
-}
+  {
+    size_t index=mVertices.size();
+    std::map&lt;MeshVertex,int&gt;::iterator i=mMap.find(v);
+    if(i!=mMap.end())
+      {
+        saved++;
+        index=i-&gt;second;
+      }
+    else
+      {
+        mVertices.push_back(v);
+        mMap[v]=index;
+      }
+    assert(index&lt;mVertices.size());
+    mIndices.push_back(index);
+    return;
+  }
 
 
 struct MeshTriangle
 {
   size_t i0,i1,i2;
   MeshTriangle(size_t p0,size_t p1,size_t p2)
-  {
-    i0=p0;
-    i1=p1;
-    i2=p2;
-  }
+    {
+      i0=p0;
+      i1=p1;
+      i2=p2;
+    }
 
   bool operator&lt;(const MeshTriangle &amp;t) const;
 };
@@ -86,90 +86,90 @@
 
 
 VertexArray MeshOptimizer::getArray()
-{
-  CTRACE;
-  VertexArray a;
-  for(size_t i=0;i&lt;mVertices.size();i++)
-    {
-      MeshVertex v=mVertices[i];
-      a.addVertex(v.v,v.c,v.n,v.t);
-    }
+  {
+    CTRACE;
+    VertexArray a;
+    for(size_t i=0;i&lt;mVertices.size();i++)
+      {
+        MeshVertex v=mVertices[i];
+        a.addVertex(v.v,v.c,v.n,v.t);
+      }
 
-  std::vector&lt;MeshTriangle&gt; tris;
-  for(size_t i=0;i&lt;mIndices.size();i+=3)
-    {
-      tris.push_back(MeshTriangle(mIndices[i],mIndices[i+1],mIndices[i+2]));
-    }  
-  sort(tris.begin(),tris.end(),TriCompare(this,AGVector3(0,-10,10)));
+    std::vector&lt;MeshTriangle&gt; tris;
+    for(size_t i=0;i&lt;mIndices.size();i+=3)
+      {
+        tris.push_back(MeshTriangle(mIndices[i],mIndices[i+1],mIndices[i+2]));
+      }  
+    sort(tris.begin(),tris.end(),TriCompare(this,AGVector3(0,-10,10)));
 
-  for(std::vector&lt;MeshTriangle&gt;::iterator i=tris.begin();i!=tris.end();i++)
-    a.addTriangle(i-&gt;i0,i-&gt;i1,i-&gt;i2);
+    for(std::vector&lt;MeshTriangle&gt;::iterator i=tris.begin();i!=tris.end();i++)
+      a.addTriangle(i-&gt;i0,i-&gt;i1,i-&gt;i2);
 
 
-  if(mIndices.size()==0)
-    cdebug(&quot;NO TRIANGLES FOUND!&quot;);
-  cdebug(&quot;SAVED:&quot;&lt;&lt;1.0f-float(saved)/mIndices.size());
-  return a;
-}
+    if(mIndices.size()==0)
+      cdebug(&quot;NO TRIANGLES FOUND!&quot;);
+    cdebug(&quot;SAVED:&quot;&lt;&lt;1.0f-float(saved)/mIndices.size());
+    return a;
+  }
 
 AGVector4 MeshOptimizer::getV(size_t i)
-{
-  return mVertices[i].v;
-}
+  {
+    return mVertices[i].v;
+  }
 
 
 MeshOptimizer loadFromText(const std::string &amp;pText, bool withTex, float zoom)
-{
-  MeshOptimizer opt;
-  MeshVertex mVertices[4];
+  {
+    MeshOptimizer opt;
+    MeshVertex mVertices[4];
 
-  BinaryStringIn in(pText);
+    BinaryStringIn in(pText);
 
-  Uint16 meshes,faces,vertices;
-  AGVector3 v;
+    Uint16 meshes,faces,vertices;
+    AGVector3 v;
 
-  in&gt;&gt;meshes;
-  cdebug(&quot;meshes:&quot;&lt;&lt;meshes);
-  for(;meshes&gt;0;meshes--)
-    {
-      in&gt;&gt;faces;
-      cdebug(&quot;faces:&quot;&lt;&lt;faces);
-      for(Uint16 i=0;i&lt;faces;i++)
-	{
-	  in&gt;&gt;vertices;
-	  cdebug(&quot;vs:&quot;&lt;&lt;vertices);
-	  assert(vertices&lt;=4);
-	  for(Uint16 j=0;j&lt;vertices;j++)
-	    {
-	      in&gt;&gt;v;
-	      mVertices[j].v=AGVector4(v,1);
-	      //	      cdebug(&quot;v:&quot;&lt;&lt;mVertices[j].v.toString());
-	      in&gt;&gt;mVertices[j].n;
-	      in&gt;&gt;v;
-	      mVertices[j].c=AGVector4(v,1);
-	      if(withTex)
-		in&gt;&gt;mVertices[j].t;
-	      mVertices[j].v*=zoom;
-	      mVertices[j].v[3]=1;
-	    }
-	  if(vertices==3)
-	    {
-	      opt.add(mVertices[0]);
-	      opt.add(mVertices[1]);
-	      opt.add(mVertices[2]);
-	    }
-	  else
-	    {
-	      opt.add(mVertices[0]);
-	      opt.add(mVertices[1]);
-	      opt.add(mVertices[2]);
-	      opt.add(mVertices[0]);
-	      opt.add(mVertices[2]);
-	      opt.add(mVertices[3]);
-	    }
-	}
-    }
+    in&gt;&gt;meshes;
+    cdebug(&quot;meshes:&quot;&lt;&lt;meshes);
+    for(;meshes&gt;0;meshes--)
+      {
+        in&gt;&gt;faces;
+        cdebug(&quot;faces:&quot;&lt;&lt;faces);
+        for(Uint16 i=0;i&lt;faces;i++)
+          {
+            in&gt;&gt;vertices;
+            cdebug(&quot;vs:&quot;&lt;&lt;vertices);
+            assert(vertices&lt;=4);
+            for(Uint16 j=0;j&lt;vertices;j++)
+              {
+                in&gt;&gt;v;
+                mVertices[j].v=AGVector4(v,1);
+                // cdebug(&quot;v:&quot;&lt;&lt;mVertices[j].v.toString());
+                in&gt;&gt;mVertices[j].n;
+                in&gt;&gt;v;
+                mVertices[j].c=AGVector4(v,1);
+                if(withTex)
+                  in&gt;&gt;mVertices[j].t;
+                mVertices[j].v*=zoom;
+                mVertices[j].v[3]=1;
+              }
+            if(vertices==3)
+              {
+                opt.add(mVertices[0]);
+                opt.add(mVertices[1]);
+                opt.add(mVertices[2]);
+              }
+            else
+              {
+                opt.add(mVertices[0]);
+                opt.add(mVertices[1]);
+                opt.add(mVertices[2]);
+                opt.add(mVertices[0]);
+                opt.add(mVertices[2]);
+                opt.add(mVertices[3]);
+              }
+          }
+      }
 
 
-  return opt;
-}
+    return opt;
+  }

Modified: antargis/trunk/ext/3dengine/scene.cc
===================================================================
--- antargis/trunk/ext/3dengine/scene.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/scene.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,8 +1,9 @@
 #include &quot;ant_renderer.h&quot;
 #include &quot;scene.h&quot;
 
-#include &lt;GL/gl.h&gt;
-#include &lt;GL/glu.h&gt;
+#include &lt;SDL_opengl.h&gt;
+//#include &lt;GL/gl.h&gt;
+//#include &lt;GL/glu.h&gt;
 
 #include &lt;ag_debug.h&gt;
 #include &lt;ag_vdebug.h&gt;
@@ -26,29 +27,29 @@
 
 Scene::Scene(int w,int h):
   SceneBase(w,h)
-{
-  white=AGVector4(1,1,1,1);
-  black=AGVector4(0,0,0,1);
-  
-  GLeeInit();
+  {
+    white=AGVector4(1,1,1,1);
+    black=AGVector4(0,0,0,1);
 
-  cdebug(&quot;SHADOW:&quot;&lt;&lt;(int)GLEE_ARB_shadow);
-  cdebug(&quot;SHADOW_AMB:&quot;&lt;&lt;(int)GLEE_ARB_shadow_ambient);
-  
-  if(getRenderer()-&gt;canShadow())
-    mShadow=1;
-  else
-    mShadow=0;
-  
-  mRubyObject=false;
-  mEnabled=true;
+    GLeeInit();
 
-}
+    cdebug(&quot;SHADOW:&quot;&lt;&lt;(int)GLEE_ARB_shadow);
+    cdebug(&quot;SHADOW_AMB:&quot;&lt;&lt;(int)GLEE_ARB_shadow_ambient);
 
+    if(getRenderer()-&gt;canShadow())
+      mShadow=1;
+    else
+      mShadow=0;
 
+    mRubyObject=false;
+    mEnabled=true;
+
+  }
+
+
 Scene::~Scene()
-{
-}
+  {
+  }
 
 size_t Scene::getDrawnMeshes() const
 {
@@ -67,45 +68,45 @@
 
 
 void Scene::draw()
-{
-  if(!mEnabled)
-    return;
-  AGRenderContext c;
-  c.begin(); // reset gl-state
+  {
+    if(!mEnabled)
+      return;
+    AGRenderContext c;
+    c.begin(); // reset gl-state
 
-  getRenderer()-&gt;setCurrentScene(this);
-  assertGL;
+    getRenderer()-&gt;setCurrentScene(this);
+    assertGL;
 
-  mMeshes=0;
-  mTriangles=0;
-  mPickTriangles=0;
+    mMeshes=0;
+    mTriangles=0;
+    mPickTriangles=0;
 
-  for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
-    (*i)-&gt;sort(AGVector4(mCamera.getPosition(),1));
-  
-  if(mShadow)
-    {
-      calcShadowMap();
-      initScene();
-      drawShadow();
-    }
-  else
-    {
-      initScene();
-      drawScene();
-    }
+    for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
+      (*i)-&gt;sort(AGVector4(mCamera.getPosition(),1));
 
-  getRenderer()-&gt;setCurrentScene(0);
-}
+    if(mShadow)
+      {
+        calcShadowMap();
+        initScene();
+        drawShadow();
+      }
+    else
+      {
+        initScene();
+        drawScene();
+      }
 
+    getRenderer()-&gt;setCurrentScene(0);
+  }
+
 void Scene::setShadow(int v)
-{
-  if(getRenderer()-&gt;canShadow())
-    {
-      mShadow=v;
-      cdebug(mShadow);
-    }
-}
+  {
+    if(getRenderer()-&gt;canShadow())
+      {
+        mShadow=v;
+        cdebug(mShadow);
+      }
+  }
 int Scene::getShadow() const
 {
   return mShadow;
@@ -115,227 +116,227 @@
 
 
 SceneNodeList Scene::getCurrentNodes()
-{
-  STACKTRACE;
-  AGVector2 p=mCamera.getPosition().dim2();
-  SceneNodeList l=mTree-&gt;get(AGRect2(p+AGVector2(-30,-30),p+AGVector2(30,30)));
+  {
+    STACKTRACE;
+    AGVector2 p=mCamera.getPosition().dim2();
+    SceneNodeList l=mTree-&gt;get(AGRect2(p+AGVector2(-30,-30),p+AGVector2(30,30)));
 
-  for(SceneNodeList::iterator i=l.begin();i!=l.end();i++)
-    {
-      if(mNodeSet.find(*i)==mNodeSet.end())
-	cdebug(&quot;ERROR:&quot;&lt;&lt;*i);
-      assert(mNodeSet.find(*i)!=mNodeSet.end());
-    }
-  return l;
-}
+    for(SceneNodeList::iterator i=l.begin();i!=l.end();i++)
+      {
+        if(mNodeSet.find(*i)==mNodeSet.end())
+          cdebug(&quot;ERROR:&quot;&lt;&lt;*i);
+        assert(mNodeSet.find(*i)!=mNodeSet.end());
+      }
+    return l;
+  }
 
 
 void Scene::calcShadowMap()
-{
-  STACKTRACE;
-  assertGL;
-  //  AGMatrix4 frustum=getFrustum();
-  size_t shadowMeshes=0;
-
-  getRenderer()-&gt;beginShadowComputation();
-
   {
     STACKTRACE;
-    SceneNodeList l=getCurrentNodes();
-    Nodes sorted;
-    std::copy(l.rbegin(),l.rend(),std::back_inserter(sorted));
-    
+    assertGL;
+    //  AGMatrix4 frustum=getFrustum();
+    size_t shadowMeshes=0;
 
-    {
-      // apply frustrum culling
-      AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
-      for(Nodes::iterator i=sorted.begin();i!=sorted.end();)
-	{
-	  if(cFrustum.collides((*i)-&gt;bbox()))
-	    i++;
-	  else
-	    i=sorted.erase(i);
-	}
-    }
+    getRenderer()-&gt;beginShadowComputation();
 
-    sort(sorted.begin(),sorted.end(),SortOrder());
-      
-    for(Nodes::iterator i=sorted.begin();i!=sorted.end();i++)
       {
-	{
-	  if((*i)-&gt;visible())
-	    {
-	      (*i)-&gt;drawDepth();
-	      mTriangles+=(*i)-&gt;getTriangles();
-	      shadowMeshes++;
-	    }
-	}
-    }
+        STACKTRACE;
+        SceneNodeList l=getCurrentNodes();
+        Nodes sorted;
+        std::copy(l.rbegin(),l.rend(),std::back_inserter(sorted));
+
+
+          {
+            // apply frustrum culling
+            AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
+            for(Nodes::iterator i=sorted.begin();i!=sorted.end();)
+              {
+                if(cFrustum.collides((*i)-&gt;bbox()))
+                  i++;
+                else
+                  i=sorted.erase(i);
+              }
+          }
+
+          sort(sorted.begin(),sorted.end(),SortOrder());
+
+          for(Nodes::iterator i=sorted.begin();i!=sorted.end();i++)
+            {
+                {
+                  if((*i)-&gt;visible())
+                    {
+                      (*i)-&gt;drawDepth();
+                      mTriangles+=(*i)-&gt;getTriangles();
+                      shadowMeshes++;
+                    }
+                }
+            }
+      }
+      //  cdebug(&quot;shadowMeshes:&quot;&lt;&lt;shadowMeshes);
+
+      getRenderer()-&gt;endShadowComputation();
+      assertGL;
   }
-  //  cdebug(&quot;shadowMeshes:&quot;&lt;&lt;shadowMeshes);
 
-  getRenderer()-&gt;endShadowComputation();
-  assertGL;
-}
-
 /**
    setups up lighting and gl-matrices (projection and such)
-*/
+ */
 void Scene::initScene()
-{
-  glClear(GL_DEPTH_BUFFER_BIT);
-  
-  glMatrixMode(GL_PROJECTION);
-  glLoadMatrixf(mCamera.getProjection());
-  
-  glMatrixMode(GL_MODELVIEW);
-  glLoadIdentity();
+  {
+    glClear(GL_DEPTH_BUFFER_BIT);
 
-  float xfactor=float(getVideo()-&gt;realWidth())/getVideo()-&gt;width();
-  float yfactor=float(getVideo()-&gt;realHeight())/getVideo()-&gt;height();
-  
-  glViewport(0, 0,(GLint)(mCamera.getWidth()*xfactor), (GLint)(mCamera.getHeight()*yfactor));
-  
-  //Use dim light to represent shadowed areas
+    glMatrixMode(GL_PROJECTION);
+    glLoadMatrixf(mCamera.getProjection());
 
-  AGVector4 l=mCamera.getLightPosition();
-  l[3]=1;
+    glMatrixMode(GL_MODELVIEW);
+    glLoadIdentity();
 
-  glLightfv(GL_LIGHT1, GL_POSITION, l);
-  glLightfv(GL_LIGHT1, GL_AMBIENT, AGVector4(0.1,0.1,0.1,1));//white*0.05f);
-  glLightfv(GL_LIGHT1, GL_DIFFUSE, AGVector4(0.3,0.3,0.3,1));//white*0.3f);//*0.2f);
-  glLightfv(GL_LIGHT1, GL_SPECULAR, black);
-  glEnable(GL_LIGHT1);
+    float xfactor=float(getVideo()-&gt;realWidth())/getVideo()-&gt;width();
+    float yfactor=float(getVideo()-&gt;realHeight())/getVideo()-&gt;height();
 
-  AGVector4 lightPosition2=AGVector4( 0, 0, -50,1);
+    glViewport(0, 0,(GLint)(mCamera.getWidth()*xfactor), (GLint)(mCamera.getHeight()*yfactor));
 
-  //  glLightfv(GL_LIGHT2, GL_POSITION, lightPosition2+scenePosition);
-  glLightfv(GL_LIGHT2, GL_AMBIENT, black);
-  glLightfv(GL_LIGHT2, GL_DIFFUSE, AGVector4(0.7,0.7,0.7,1));//white*0.7f);//*0.2f);
-  glLightfv(GL_LIGHT2, GL_SPECULAR, white);
-  glLightfv(GL_LIGHT2, GL_SPOT_DIRECTION, AGVector4(0,0,-1,0));
-  glLightf(GL_LIGHT2,GL_LINEAR_ATTENUATION,0);
-  glLightf(GL_LIGHT2,GL_QUADRATIC_ATTENUATION,0);
-  glLightf(GL_LIGHT2,GL_CONSTANT_ATTENUATION,0);
-  glEnable(GL_LIGHT2);
+    //Use dim light to represent shadowed areas
 
+    AGVector4 l=mCamera.getLightPosition();
+    l[3]=1;
 
+    glLightfv(GL_LIGHT1, GL_POSITION, l);
+    glLightfv(GL_LIGHT1, GL_AMBIENT, AGVector4(0.1,0.1,0.1,1));//white*0.05f);
+    glLightfv(GL_LIGHT1, GL_DIFFUSE, AGVector4(0.3,0.3,0.3,1));//white*0.3f);//*0.2f);
+    glLightfv(GL_LIGHT1, GL_SPECULAR, black);
+    glEnable(GL_LIGHT1);
 
-  glEnable(GL_LIGHTING);
+    AGVector4 lightPosition2=AGVector4( 0, 0, -50,1);
 
-  glDisable(GL_LIGHT0);
-  glDisable(GL_LIGHT3);
-  glDisable(GL_LIGHT4);
-  glDisable(GL_LIGHT5);
+    //  glLightfv(GL_LIGHT2, GL_POSITION, lightPosition2+scenePosition);
+    glLightfv(GL_LIGHT2, GL_AMBIENT, black);
+    glLightfv(GL_LIGHT2, GL_DIFFUSE, AGVector4(0.7,0.7,0.7,1));//white*0.7f);//*0.2f);
+    glLightfv(GL_LIGHT2, GL_SPECULAR, white);
+    glLightfv(GL_LIGHT2, GL_SPOT_DIRECTION, AGVector4(0,0,-1,0));
+    glLightf(GL_LIGHT2,GL_LINEAR_ATTENUATION,0);
+    glLightf(GL_LIGHT2,GL_QUADRATIC_ATTENUATION,0);
+    glLightf(GL_LIGHT2,GL_CONSTANT_ATTENUATION,0);
+    glEnable(GL_LIGHT2);
 
-  //  glLoadMatrixf(cameraViewMatrix);
-  glLoadMatrixf(mCamera.getModelview());
-}
 
+
+    glEnable(GL_LIGHTING);
+
+    glDisable(GL_LIGHT0);
+    glDisable(GL_LIGHT3);
+    glDisable(GL_LIGHT4);
+    glDisable(GL_LIGHT5);
+
+    //  glLoadMatrixf(cameraViewMatrix);
+    glLoadMatrixf(mCamera.getModelview());
+  }
+
 #ifdef TEST_DL
 static GLuint displayList=0;
 static bool dlInited=false;
 #endif
 
 void Scene::drawScene()
-{
+  {
 #ifdef TEST_DL
-  // this was for testing only - to check if display-lists are any good.
-  // it seems they are comparable with VBOs - the problem is that they're inflexible
-  // please leave this code, so we have some example, if we happen to use this again at a later stage
+    // this was for testing only - to check if display-lists are any good.
+    // it seems they are comparable with VBOs - the problem is that they're inflexible
+    // please leave this code, so we have some example, if we happen to use this again at a later stage
 
-  if(dlInited)
-    {
-      glCallList(displayList);
-    }
-  else
-    {
-      dlInited=true;
-      displayList=glGenLists(1);
-      glNewList(displayList,GL_COMPILE);
+    if(dlInited)
+      {
+        glCallList(displayList);
+      }
+    else
+      {
+        dlInited=true;
+        displayList=glGenLists(1);
+        glNewList(displayList,GL_COMPILE);
 #endif
 
-  STACKTRACE; 
+        STACKTRACE; 
 
-  // this is used for frustum cullin
-  AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
-  
-  //2nd pass - Draw from camera's point of view
+        // this is used for frustum cullin
+        AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
 
-  // draw scene with texturing and so
+        //2nd pass - Draw from camera's point of view
 
-  int drawn=0;
+        // draw scene with texturing and so
 
-  SceneNodeList l=getCurrentNodes();
-  Nodes sorted;
-  std::copy(l.begin(),l.end(),std::back_inserter(sorted));
+        int drawn=0;
 
-  {
-    STACKTRACE;
-    for(Nodes::iterator i=sorted.begin();i!=sorted.end();)
-      {
-	if(cFrustum.collides((*i)-&gt;bbox()))
-	  i++;
-	else
-	  i=sorted.erase(i);
-      }
-  }
+        SceneNodeList l=getCurrentNodes();
+        Nodes sorted;
+        std::copy(l.begin(),l.end(),std::back_inserter(sorted));
 
-  sort(sorted.begin(),sorted.end(),SortOrder());
-  // draw opaque objects first, from front to back
-  for(Nodes::iterator i=sorted.begin();i!=sorted.end();i++)
-    {
-      if(!(*i)-&gt;transparent())
-	{
-	  if((*i)-&gt;visible())
-	    {
-	      (*i)-&gt;draw();
-	      mTriangles+=(*i)-&gt;getTriangles();
-	      drawn++;
-	      mMeshes++;
-	    }
-	}
-    }
-  sort(sorted.begin(),sorted.end(),SortDistance(mCamera.getCameraPosition().dim3()));
-  // draw transparent ones next from back to front
-  for(Nodes::reverse_iterator i=sorted.rbegin();i!=sorted.rend();i++)
-    {
-      if((*i)-&gt;transparent())
-	{
-	  if((*i)-&gt;visible())
-	    {
-	      (*i)-&gt;draw();
-	      mTriangles+=(*i)-&gt;getTriangles();
-	      drawn++;
-	      mMeshes++;
-	    }
-	}
-    }
+          {
+            STACKTRACE;
+            for(Nodes::iterator i=sorted.begin();i!=sorted.end();)
+              {
+                if(cFrustum.collides((*i)-&gt;bbox()))
+                  i++;
+                else
+                  i=sorted.erase(i);
+              }
+          }
 
+          sort(sorted.begin(),sorted.end(),SortOrder());
+          // draw opaque objects first, from front to back
+          for(Nodes::iterator i=sorted.begin();i!=sorted.end();i++)
+            {
+              if(!(*i)-&gt;transparent())
+                {
+                  if((*i)-&gt;visible())
+                    {
+                      (*i)-&gt;draw();
+                      mTriangles+=(*i)-&gt;getTriangles();
+                      drawn++;
+                      mMeshes++;
+                    }
+                }
+            }
+          sort(sorted.begin(),sorted.end(),SortDistance(mCamera.getCameraPosition().dim3()));
+          // draw transparent ones next from back to front
+          for(Nodes::reverse_iterator i=sorted.rbegin();i!=sorted.rend();i++)
+            {
+              if((*i)-&gt;transparent())
+                {
+                  if((*i)-&gt;visible())
+                    {
+                      (*i)-&gt;draw();
+                      mTriangles+=(*i)-&gt;getTriangles();
+                      drawn++;
+                      mMeshes++;
+                    }
+                }
+            }
+
 #ifdef TEST_DL
-  glEndList();
-  glCallList(displayList);
-    }
+          glEndList();
+          glCallList(displayList);
+      }
 #endif
 
-}
+  }
 
 
 /// deprecated function - this is done in one pass with &quot;normal&quot; drawing
 /// it was used to paint the shadow afterwards in a 3rd pass
 void Scene::drawShadow()
-{
-  assertGL;
+  {
+    assertGL;
 
-  getRenderer()-&gt;beginShadowDrawing();
-  
-  drawScene();
+    getRenderer()-&gt;beginShadowDrawing();
 
-  getRenderer()-&gt;endShadowDrawing();
+    drawScene();
 
-  assertGL;
-}
+    getRenderer()-&gt;endShadowDrawing();
 
+    assertGL;
+  }
+
 AGVector3 Scene::getCameraDirTo(const AGVector3 &amp;p) const
 {
   return mCamera.getCameraPosition().dim3()-p;
@@ -344,144 +345,144 @@
 /** pickDraw is used for picking ;-)
     it draws all the objects with opengl
     and not using texturing, shaders and such - if I'm right here??
-*/
+ */
 void Scene::pickDraw()
-{
-  STACKTRACE;
-  GLuint name=1;
-  pickNames.clear();
+  {
+    STACKTRACE;
+    GLuint name=1;
+    pickNames.clear();
 
-  AGMatrix4 frustum=cameraPickMatrix*mCamera.getModelview();
+    AGMatrix4 frustum=cameraPickMatrix*mCamera.getModelview();
 
-  AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
-  
-  SceneNodeList l=getCurrentNodes();
+    AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
 
-  for(SceneNodeList::iterator i=l.begin();i!=l.end();i++)
-    {
-      STACKTRACE;
-      if((*i)-&gt;visible() &amp;&amp; (*i)-&gt;bbox().collides(frustum))
-	if(cFrustum.collides((*i)-&gt;bbox()))
-	  {
-	    STACKTRACE;
-	    glPushName(name);
-	    (*i)-&gt;drawPick();
-	    glPopName();
-	    pickNames.insert(std::make_pair(name,*i));
-	    name++;
-	    mPickTriangles+=(*i)-&gt;getTriangles();
-	  }
-    }
+    SceneNodeList l=getCurrentNodes();
 
-  glEnable(GL_CULL_FACE);
-}
+    for(SceneNodeList::iterator i=l.begin();i!=l.end();i++)
+      {
+        STACKTRACE;
+        if((*i)-&gt;visible() &amp;&amp; (*i)-&gt;bbox().collides(frustum))
+          if(cFrustum.collides((*i)-&gt;bbox()))
+            {
+              STACKTRACE;
+              glPushName(name);
+              (*i)-&gt;drawPick();
+              glPopName();
+              pickNames.insert(std::make_pair(name,*i));
+              name++;
+              mPickTriangles+=(*i)-&gt;getTriangles();
+            }
+      }
 
+    glEnable(GL_CULL_FACE);
+  }
+
 /// this a global function - use this for picking!
 /// x and y are in screen-coordinates in normal fashion
 /// so (0,0) is the top left corner and (1023,767) bottom right.
 /// the same for w and h
 PickResult Scene::pick(float x,float y,float w,float h)
-{
-  STACKTRACE;
-  size_t bufsize=4000;
-  GLuint buffer[bufsize+1];
-  
-  glSelectBuffer(bufsize,buffer);
-  glRenderMode(GL_SELECT);
-  
-  glMatrixMode(GL_PROJECTION);
-  glPushMatrix();
-  glLoadIdentity();
-  
-  assertGL;
-  gluPickMatrix(x,mCamera.getHeight()-y,h,w,getViewport());
+  {
+    STACKTRACE;
+    size_t bufsize=4000;
+    GLuint buffer[bufsize+1];
 
-  assertGL;
-  
-  glMultMatrixf(mCamera.getProjection());
-  glGetFloatv(GL_PROJECTION_MATRIX, cameraPickMatrix);
-  assertGL;
-  
-  glMatrixMode(GL_MODELVIEW);
-  glPushMatrix();
-  glLoadIdentity();
+    glSelectBuffer(bufsize,buffer);
+    glRenderMode(GL_SELECT);
 
-  glMultMatrixf(mCamera.getModelview());
-  glInitNames();
-  assertGL;
+    glMatrixMode(GL_PROJECTION);
+    glPushMatrix();
+    glLoadIdentity();
 
-  pickDraw();
-  assertGL;
-  
-  
-  // back to normality
-  glPopMatrix();
-  glMatrixMode(GL_PROJECTION);
-  glPopMatrix();
-  glMatrixMode(GL_MODELVIEW);
-  glFlush();
-  assertGL;
-  
-  int hits=glRenderMode(GL_RENDER);
-  assertGL;
-  PickResult r=processHits(hits,buffer,x+w/2,mCamera.getHeight()-(y+h/2));
-  std::sort(r.begin(),r.end());
-  return r;
-}
+    assertGL;
+    gluPickMatrix(x,mCamera.getHeight()-y,h,w,getViewport());
 
+    assertGL;
+
+    glMultMatrixf(mCamera.getProjection());
+    glGetFloatv(GL_PROJECTION_MATRIX, cameraPickMatrix);
+    assertGL;
+
+    glMatrixMode(GL_MODELVIEW);
+    glPushMatrix();
+    glLoadIdentity();
+
+    glMultMatrixf(mCamera.getModelview());
+    glInitNames();
+    assertGL;
+
+    pickDraw();
+    assertGL;
+
+
+    // back to normality
+    glPopMatrix();
+    glMatrixMode(GL_PROJECTION);
+    glPopMatrix();
+    glMatrixMode(GL_MODELVIEW);
+    glFlush();
+    assertGL;
+
+    int hits=glRenderMode(GL_RENDER);
+    assertGL;
+    PickResult r=processHits(hits,buffer,x+w/2,mCamera.getHeight()-(y+h/2));
+    std::sort(r.begin(),r.end());
+    return r;
+  }
+
 /// helper function for gettin PickResult from opengl's buffers
 PickResult Scene::processHits (int hits, GLuint *buffer,float px,float py)
-{
-  STACKTRACE;
-  PickResult result;
-  if(hits==0)
-    return result;
+  {
+    STACKTRACE;
+    PickResult result;
+    if(hits==0)
+      return result;
 
-   unsigned int i, j;
-   GLuint names, *ptr, minZ,*ptrNames, numberOfNames;
+    unsigned int i, j;
+    GLuint names, *ptr, minZ,*ptrNames, numberOfNames;
 
-   ptr = (GLuint *) buffer;
-   minZ = 0xffffffff;
-   for (i = 0; i &lt; (unsigned int)hits; i++) { 
+    ptr = (GLuint *) buffer;
+    minZ = 0xffffffff;
+    for (i = 0; i &lt; (unsigned int)hits; i++) { 
       names = *ptr;
       ptr++;
       if (*ptr &lt; minZ) {
-	numberOfNames = names;
-	minZ = *ptr;
+        numberOfNames = names;
+        minZ = *ptr;
 
-	ptrNames = ptr+2;
+        ptrNames = ptr+2;
 
-	GLuint *mptr=ptrNames;
-	for(j=0;j&lt;numberOfNames;j++,mptr++)
-	  {
-	    PickNode n;
-	    n.node=pickNames[*mptr];
-	    n.camDist=minZ/float(0xFFFFFFFF); // (0-1)
+        GLuint *mptr=ptrNames;
+        for(j=0;j&lt;numberOfNames;j++,mptr++)
+          {
+            PickNode n;
+            n.node=pickNames[*mptr];
+            n.camDist=minZ/float(0xFFFFFFFF); // (0-1)
 
-	    // get world-position
-	    GLdouble x,y,z;
+            // get world-position
+            GLdouble x,y,z;
 
-	    GLdouble modelview[16],projection[16];
-	    for(size_t i=0;i&lt;16;i++)
-	      {
-		modelview[i]=((float*)mCamera.getModelview())[i];
-		projection[i]=((float*)cameraPickMatrix)[i];
-	      }
+            GLdouble modelview[16],projection[16];
+            for(size_t i=0;i&lt;16;i++)
+              {
+                modelview[i]=((float*)mCamera.getModelview())[i];
+                projection[i]=((float*)cameraPickMatrix)[i];
+              }
 
-	    gluUnProject(px,py,n.camDist,modelview,projection,getViewport(),&amp;x,&amp;y,&amp;z);
-	    n.pos=AGVector4(x,y,z,1);
-	    n.camDist=(n.pos-mCamera.getCameraPosition()).length3();
+            gluUnProject(px,py,n.camDist,modelview,projection,getViewport(),&amp;x,&amp;y,&amp;z);
+            n.pos=AGVector4(x,y,z,1);
+            n.camDist=(n.pos-mCamera.getCameraPosition()).length3();
 
-	    result.push_back(n);
-	  }
+            result.push_back(n);
+          }
 
       }
-      
+
       ptr += names+2;
-   }
+    }
 
-   return result;
-}
+    return result;
+  }
 
 
 Viewport Scene::getViewport() const
@@ -509,7 +510,7 @@
 AGVector2 Scene::getPosition(const AGVector4 &amp;v) const
 {
   GLdouble x,y,z;
-  
+
   GLdouble modelview[16],projection[16];
   for(size_t i=0;i&lt;16;i++)
     {
@@ -524,13 +525,13 @@
 
 
 void Scene::setEnabled(bool p)
-{
-  mEnabled=p;
-}
+  {
+    mEnabled=p;
+  }
 
 
 void Scene::advance(float time)
-{
-  if(mEnabled)
-    SceneBase::advance(time);
-}
+  {
+    if(mEnabled)
+      SceneBase::advance(time);
+  }

Modified: antargis/trunk/ext/3dengine/scene_2d.cc
===================================================================
--- antargis/trunk/ext/3dengine/scene_2d.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/scene_2d.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -7,61 +7,61 @@
 
 Scene2D::Scene2D(int w,int h):
   SceneBase(w,h),mPainter(0)
-{
-}
+  {
+  }
 
 Scene2D::~Scene2D()
-{
-}
+  {
+  }
 
 void Scene2D::draw()
-{
-  // FIXME
-  
-  SceneNodeList nodeList=getCurrentNodes();
-  Nodes ns;
-  std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
+  {
+    // FIXME
 
+    SceneNodeList nodeList=getCurrentNodes();
+    Nodes ns;
+    std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
 
-  sort(ns.begin(),ns.end(),SortYCoord());
 
-  //FIXME:sort!!
+    sort(ns.begin(),ns.end(),SortYCoord());
 
-  for(Nodes::iterator i=ns.begin();i!=ns.end();i++)
-    (*i)-&gt;draw();
-}
+    //FIXME:sort!!
 
+    for(Nodes::iterator i=ns.begin();i!=ns.end();i++)
+      (*i)-&gt;draw();
+  }
+
 PickResult Scene2D::pick(float x,float y,float w,float h)
-{
-  PickResult result;
-  SceneNodeList nodeList=getCurrentNodes();
+  {
+    PickResult result;
+    SceneNodeList nodeList=getCurrentNodes();
 
-  Nodes ns;
-  std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
-  sort(ns.begin(),ns.end(),SortOrder());
+    Nodes ns;
+    std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
+    sort(ns.begin(),ns.end(),SortOrder());
 
-  for(Nodes::reverse_iterator i=ns.rbegin();i!=ns.rend();i++)
-    {
-      Mesh2D*m=dynamic_cast&lt;Mesh2D*&gt;(*i);
-      if(m)
-	{
-	  if(m-&gt;hit(AGVector2(x,y)))
-	    {
-	      PickNode node;
-	      node.pos=m-&gt;getPos();
-	      node.node=m;
-	      node.camDist=0;
+    for(Nodes::reverse_iterator i=ns.rbegin();i!=ns.rend();i++)
+      {
+        Mesh2D*m=dynamic_cast&lt;Mesh2D*&gt;(*i);
+        if(m)
+          {
+            if(m-&gt;hit(AGVector2(x,y)))
+              {
+                PickNode node;
+                node.pos=m-&gt;getPos();
+                node.node=m;
+                node.camDist=0;
 
-	      cdebug(&quot;hit:&quot;&lt;&lt;node.pos&lt;&lt;&quot;   &quot;&lt;&lt;node.node);
-	      result.push_back(node);
-	    }
-	}
-    }
-  
+                cdebug(&quot;hit:&quot;&lt;&lt;node.pos&lt;&lt;&quot;   &quot;&lt;&lt;node.node);
+                result.push_back(node);
+              }
+          }
+      }
 
-  return result;
-}
 
+    return result;
+  }
+
 AGVector2 Scene2D::getPosition(const AGVector4 &amp;v) const
 {
   // FIXME: include camera !!
@@ -86,37 +86,37 @@
 }
 
 SceneNodeList Scene2D::getCurrentNodes()
-{
-  //  cdebug(&quot;FIXME&quot;);
+  {
+    //  cdebug(&quot;FIXME&quot;);
 
-  SceneNodeList l;
-  std::copy(mNodes.begin(),mNodes.end(),std::back_inserter(l));
+    SceneNodeList l;
+    std::copy(mNodes.begin(),mNodes.end(),std::back_inserter(l));
 
-  //  throw std::runtime_error(&quot;FIXME&quot;);
-  return l;
-}
+    //  throw std::runtime_error(&quot;FIXME&quot;);
+    return l;
+  }
 
 //void setEnabled(bool p);
 
 void Scene2D::setPainter(AGPainter *p)
-{
-  CTRACE;
-  assert(mPainter==0);
-  mPainter=p;
-}
+  {
+    CTRACE;
+    assert(mPainter==0);
+    mPainter=p;
+  }
 void Scene2D::discardPainter()
-{
-  CTRACE;
-  assert(mPainter!=0);
-  mPainter=0;
-}
+  {
+    CTRACE;
+    assert(mPainter!=0);
+    mPainter=0;
+  }
 
 AGPainter *Scene2D::getPainter()
-{
-  CTRACE;
-  assert(mPainter);
-  return mPainter;
-}
+  {
+    CTRACE;
+    assert(mPainter);
+    return mPainter;
+  }
 
 
 #endif

Modified: antargis/trunk/ext/3dengine/scene_base.cc
===================================================================
--- antargis/trunk/ext/3dengine/scene_base.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/scene_base.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -7,112 +7,110 @@
 SceneBase::SceneBase(int w,int h):
   mTree(new QuadTree&lt;SceneNode&gt;(AGRect2(AGVector2(),AGVector2(w,h)))),
   mCamera(w,h)
-{
-}
+  {
+  }
 
 
 SceneBase::~SceneBase()
-{
-  // tell nodes, that I'm no longer there :-)
-  for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
-    (*i)-&gt;resetScene(); 
+  {
+    // tell nodes, that I'm no longer there :-)
+    for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
+      (*i)-&gt;resetScene(); 
 
-  delete mTree;
-}
+    delete mTree;
+  }
 
 
 
 
 
 void SceneBase::addNode(SceneNode *node)
-{
-  //  std::cout&lt;&lt;&quot;addNode:(this:&quot;&lt;&lt;this&lt;&lt;&quot;) &quot;&lt;&lt;node&lt;&lt;&quot;  &quot;&lt;&lt;typeid(*node).name()&lt;&lt;std::endl;
-  if(mNodeSet.find(node)==mNodeSet.end())
-    {
-      node-&gt;setScene(this);
+  {
+    //  std::cout&lt;&lt;&quot;addNode:(this:&quot;&lt;&lt;this&lt;&lt;&quot;) &quot;&lt;&lt;node&lt;&lt;&quot;  &quot;&lt;&lt;typeid(*node).name()&lt;&lt;std::endl;
+    if(mNodeSet.find(node)==mNodeSet.end())
+      {
+        node-&gt;setScene(this);
 
-      mNodes.push_back(node);
-      mNodeSet.insert(node);
-      assert(node-&gt;getScene()==this);
-      mTree-&gt;insert(node);
-    }
-}
+        mNodes.push_back(node);
+        mNodeSet.insert(node);
+        assert(node-&gt;getScene()==this);
+        mTree-&gt;insert(node);
+      }
+  }
 
 
 
 void SceneBase::updatePos(SceneNode *node)
-{
-  if(mNodeSet.find(node)==mNodeSet.end())
-    throw std::string(&quot;Dont know about this!&quot;);
-  mTree-&gt;insert(node);
-}
+  {
+    if(mNodeSet.find(node)==mNodeSet.end())
+      throw std::string(&quot;Dont know about this!&quot;);
+    mTree-&gt;insert(node);
+  }
 
 void SceneBase::prepareUpdate(SceneNode *node)
-{
-  if(mNodeSet.find(node)==mNodeSet.end())
-    throw std::string(&quot;Dont know about this!&quot;);
-  mTree-&gt;remove(node);
-}
+  {
+    if(mNodeSet.find(node)==mNodeSet.end())
+      throw std::string(&quot;Dont know about this!&quot;);
+    mTree-&gt;remove(node);
+  }
 
 
 void SceneBase::removeNode(SceneNode *node)
-{
-  //  std::cout&lt;&lt;&quot;remove node:&quot;&lt;&lt;node&lt;&lt;std::endl;
-  if(mNodeSet.find(node)!=mNodeSet.end())
-    {
-      Nodes::iterator i=std::find(mNodes.begin(),mNodes.end(),node);
-      mNodes.erase(i);
-      mNodeSet.erase(node);
-      assert(node-&gt;getScene()==this);
-      node-&gt;resetScene();
-      bool ok=(mTree-&gt;remove(node));
-      assert(ok);
-    }
-  else
-    {
-      throw std::runtime_error(&quot;Trying to remove unknown node&quot;);
-    }
-}
+  {
+    //  std::cout&lt;&lt;&quot;remove node:&quot;&lt;&lt;node&lt;&lt;std::endl;
+    if(mNodeSet.find(node)!=mNodeSet.end())
+      {
+        Nodes::iterator i=std::find(mNodes.begin(),mNodes.end(),node);
+        mNodes.erase(i);
+        mNodeSet.erase(node);
+        assert(node-&gt;getScene()==this);
+        node-&gt;resetScene();
+        bool ok=(mTree-&gt;remove(node));
+        assert(ok);
+      }
+    else
+      {
+        throw std::runtime_error(&quot;Trying to remove unknown node&quot;);
+      }
+  }
 
 void SceneBase::clear()
-{
-  for(std::vector&lt;SceneNode*&gt;::iterator i=mNodes.begin();i!=mNodes.end();i++)
-    {
-      assert((*i)-&gt;getScene()==this);
-      (*i)-&gt;resetScene();
-    }
-  TRACE;
-  mNodes.clear();
-  mNodeSet.clear();
-  mTree-&gt;clear();
-}
+  {
+    for(std::vector&lt;SceneNode*&gt;::iterator i=mNodes.begin();i!=mNodes.end();i++)
+      {
+        assert((*i)-&gt;getScene()==this);
+        (*i)-&gt;resetScene();
+      }
+    TRACE;
+    mNodes.clear();
+    mNodeSet.clear();
+    mTree-&gt;clear();
+  }
 
-  // (mx,my,0)
+// (mx,my,0)
 void SceneBase::setCamera(AGVector4 v)
-{
-  mCamera.setPosition(v.dim3());
-}
+  {
+    mCamera.setPosition(v.dim3());
+  }
 
 void SceneBase::advance(float time)
-{
-  STACKTRACE; 
+  {
+    STACKTRACE; 
 
-  //  if(!mEnabled)
-  //    return;
-  // advance only in view
+    //  if(!mEnabled)
+    //    return;
+    // advance only in view
 
-  SceneNodeList l=getCurrentNodes();
+    SceneNodeList l=getCurrentNodes();
 
-  for(SceneNodeList::iterator i=l.begin();i!=l.end();i++)
-    {
-      if((*i)-&gt;visible())
-	{
-	  //	  std::cout&lt;&lt;(*i)&lt;&lt;std::endl;
-	  //	  std::cout&lt;&lt;(typeid(**i).name())&lt;&lt;std::endl;
-	  (*i)-&gt;advance(time);
-	}
-    }
-}
+    for(SceneNodeList::iterator i=l.begin();i!=l.end();i++)
+      {
+        if((*i)-&gt;visible())
+          {
+            (*i)-&gt;advance(time);
+          }
+      }
+  }
 
 float SceneBase::width() const
 {
@@ -124,16 +122,16 @@
 }
 
 void SceneBase::mark()
-{
-  //  std::cout&lt;&lt;&quot;SceneBase::mark()&quot;&lt;&lt;std::endl;
-  SceneBase::Nodes::iterator i=mNodes.begin();
+  {
+    //  std::cout&lt;&lt;&quot;SceneBase::mark()&quot;&lt;&lt;std::endl;
+    SceneBase::Nodes::iterator i=mNodes.begin();
 
-  for(;i!=mNodes.end();i++)
-    {
-      //  std::cout&lt;&lt;&quot;scenebase-mark:&quot;&lt;&lt; this&lt;&lt;&quot;  &quot;&lt;&lt;*i&lt;&lt;std::endl;
-      markObject(*i);
-    }
-}
+    for(;i!=mNodes.end();i++)
+      {
+        //  std::cout&lt;&lt;&quot;scenebase-mark:&quot;&lt;&lt; this&lt;&lt;&quot;  &quot;&lt;&lt;*i&lt;&lt;std::endl;
+        markObject(*i);
+      }
+  }
 
 AGVector4 SceneBase::getCamera() const
 {
@@ -141,12 +139,12 @@
 }
 
 AntCamera &amp;SceneBase::getCameraObject()
-{
-  return mCamera;
-}
+  {
+    return mCamera;
+  }
 
 SceneNodeList SceneBase::getCurrentNodes()
-{
-  throw std::runtime_error(&quot;not implemented!&quot;);
-  return SceneNodeList();
-}
+  {
+    throw std::runtime_error(&quot;not implemented!&quot;);
+    return SceneNodeList();
+  }

Modified: antargis/trunk/ext/basic/ag_config.cc
===================================================================
--- antargis/trunk/ext/basic/ag_config.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_config.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,54 +1,46 @@
 #include &quot;ag_config.h&quot;
 #include &quot;ag_xml.h&quot;
 
+// TODO: AGConfig should switch to a ruby-based configuration (maybe YAML)
+// TODO: commenting should be possible !! (no overwriting)
+
 AGConfig::AGConfig()
-{
-  Document doc(&quot;config.xml&quot;);
+  {
+    Document doc(&quot;config.xml&quot;);
 
-  Node &amp;root=doc.root();
-  AGString comment;
-  for(Node::iterator i=root.begin();i!=root.end();i++)
-    {
-      if((*i)-&gt;get(&quot;name&quot;)==&quot;&quot;)
-	{
-	  AGString c=(*i)-&gt;getContent();
-	  if(c.substr(0,4)==&quot;&lt;!--&quot;)
-	    {
-	      comment=c;
-	      //	      cdebug(&quot;comment:&quot;&lt;&lt;comment);
-	    }
-	  else
-	    {
-	      //	      cdebug(&quot;no comment.&quot;&lt;&lt;c);
-	    }
-	}
-      else
-	{
-	  singleValue[(*i)-&gt;get(&quot;name&quot;)]=(*i)-&gt;get(&quot;value&quot;);
-	  comments[(*i)-&gt;get(&quot;name&quot;)]=comment;
-	  //	  cdebug((*i)-&gt;get(&quot;name&quot;)&lt;&lt;&quot;:&quot;&lt;&lt;(*i)-&gt;get(&quot;value&quot;)&lt;&lt;&quot;:&quot;&lt;&lt;comment);
-	  comment=&quot;&quot;;
-	}
-    }
+    Node &amp;root=doc.root();
+    AGString comment;
+    for(Node::iterator i=root.begin();i!=root.end();i++)
+      {
+        if((*i)-&gt;get(&quot;name&quot;)==&quot;&quot;)
+          {
+            AGString c=(*i)-&gt;getContent();
+            if(c.substr(0,4)==&quot;&lt;!--&quot;)
+              {
+                comment=c;
+              }
+          }
+        else
+          {
+            singleValue[(*i)-&gt;get(&quot;name&quot;)]=(*i)-&gt;get(&quot;value&quot;);
+            comments[(*i)-&gt;get(&quot;name&quot;)]=comment;
+            comment=&quot;&quot;;
+          }
+      }
+    //  writeToDisc();
+  }
 
-  //  cdebug(&quot;singleValues:&quot;&lt;&lt;singleValue.size());
-
-  //  std::cerr&lt;&lt;doc.toString()&lt;&lt;std::endl;
-
-  //  writeToDisc();
-}
-
 AGString AGConfig::get(const AGString &amp;pValue,const AGString &amp;pDefault,const AGString &amp;pComment)
-{
-  AGString v=get(pValue);
-  if(v==&quot;&quot;)
-    {
-      comments[pValue]=pComment;
-      set(pValue,pDefault);
-      v=pDefault;
-    }
-  return v;
-}
+  {
+    AGString v=get(pValue);
+    if(v==&quot;&quot;)
+      {
+        comments[pValue]=pComment;
+        set(pValue,pDefault);
+        v=pDefault;
+      }
+    return v;
+  }
 
 
 
@@ -62,49 +54,49 @@
 }
 
 void AGConfig::set(const AGString &amp;pName,const AGString &amp;pValue)
-{
-	AGString old=singleValue[pName];
-	if(old!=pValue)
-	{
-		singleValue[pName]=pValue;
-		writeToDisc();
-	}
-}
+  {
+    AGString old=singleValue[pName];
+    if(old!=pValue)
+      {
+        singleValue[pName]=pValue;
+        writeToDisc();
+      }
+  }
 
 void AGConfig::writeToDisc()
-{
-  Document doc;
-  Node &amp;root=doc.root();
-  root.setName(&quot;config&quot;);
-  for(std::map&lt;AGString,AGString&gt;::const_iterator i=singleValue.begin();i!=singleValue.end();i++)
-    {
-      if(comments[i-&gt;first]!=&quot;&quot;)
-	{
-	  Node &amp;n=root.addChild(&quot;&quot;);
-	  n.setContent(AGString(&quot;\n&quot;)+comments[i-&gt;first]+&quot;\n&quot;);
-	}
+  {
+    Document doc;
+    Node &amp;root=doc.root();
+    root.setName(&quot;config&quot;);
+    for(std::map&lt;AGString,AGString&gt;::const_iterator i=singleValue.begin();i!=singleValue.end();i++)
+      {
+        if(comments[i-&gt;first]!=&quot;&quot;)
+          {
+            Node &amp;n=root.addChild(&quot;&quot;);
+            n.setContent(AGString(&quot;\n&quot;)+comments[i-&gt;first]+&quot;\n&quot;);
+          }
 
-      Node &amp;n=root.addChild(&quot;option&quot;);
-      n.set(&quot;name&quot;,i-&gt;first);
-      n.set(&quot;value&quot;,i-&gt;second);
-    }
+        Node &amp;n=root.addChild(&quot;option&quot;);
+        n.set(&quot;name&quot;,i-&gt;first);
+        n.set(&quot;value&quot;,i-&gt;second);
+      }
 
-  saveFile(&quot;config.xml&quot;,doc.toString(true));
-}
+    saveFile(&quot;config.xml&quot;,doc.toString(true));
+  }
 
 
 
 AGConfig *gConfig=0;
 AGConfig *getConfig()
-{
-  if(!gConfig)
-    gConfig=new AGConfig;
-  return gConfig;
-}
+  {
+    if(!gConfig)
+      gConfig=new AGConfig;
+    return gConfig;
+  }
 
 void updateConfig()
-{
-  delete gConfig;
-  gConfig=0;
-  //  getConfig();
-}
+  {
+    delete gConfig;
+    gConfig=0;
+    //  getConfig();
+  }

Modified: antargis/trunk/ext/basic/ag_fs.cc
===================================================================
--- antargis/trunk/ext/basic/ag_fs.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_fs.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -18,6 +18,9 @@
  * License along with this program.
  */
 
+
+// TODO: Code-review !!!
+
 #include &lt;string&gt;
 #include &lt;list&gt;
 #include &lt;assert.h&gt;
@@ -42,348 +45,348 @@
 static std::list&lt;AGFilename&gt; mFsPaths;
 
 void addPath(const AGFilename &amp;pName)
-{
-  mFsPaths.push_back(pName);
+  {
+    mFsPaths.push_back(pName);
 #ifdef USE_PHYSFS
-  TRACE;
-  PHYSFS_addToSearchPath(pName.c_str(),1);
-  char **p=PHYSFS_getSearchPath();
-  for(;*p;p++)
-    {
-      dbout(0,*p);
+    TRACE;
+    PHYSFS_addToSearchPath(pName.c_str(),1);
+    char **p=PHYSFS_getSearchPath();
+    for(;*p;p++)
+      {
+        dbout(0,*p);
 
-    }
+      }
 #endif
-  updateConfig();
-}
+    updateConfig();
+  }
 
 void addPathFront(const AGFilename &amp;pName)
-{
-  mFsPaths.push_front(pName);
+  {
+    mFsPaths.push_front(pName);
 #ifdef USE_PHYSFS
-  TRACE;
-  PHYSFS_addToSearchPath(pName.c_str(),1);
-  char **p=PHYSFS_getSearchPath();
-  for(;*p;p++)
-    {
-      dbout(0,*p);
+    TRACE;
+    PHYSFS_addToSearchPath(pName.c_str(),1);
+    char **p=PHYSFS_getSearchPath();
+    for(;*p;p++)
+      {
+        dbout(0,*p);
 
-    }
+      }
 #endif
-  updateConfig();
-}
+    updateConfig();
+  }
 
 
 void initFS(const char *argv0)
-{
+  {
 #ifdef USE_PHYSFS
-  TRACE;
-  PHYSFS_init(argv0);
-  PHYSFS_setSaneConfig(&quot;Antargis&quot;,&quot;Antargis&quot;,&quot;ZIP&quot;,false,false);
-  FSinited=true;
-  const char *wp=PHYSFS_getWriteDir();
-  dbout(0,&quot;writedir:&quot;&lt;&lt;wp);
+    TRACE;
+    PHYSFS_init(argv0);
+    PHYSFS_setSaneConfig(&quot;Antargis&quot;,&quot;Antargis&quot;,&quot;ZIP&quot;,false,false);
+    FSinited=true;
+    const char *wp=PHYSFS_getWriteDir();
+    dbout(0,&quot;writedir:&quot;&lt;&lt;wp);
 
-  dbout(0,&quot;searchpath:&quot;);
+    dbout(0,&quot;searchpath:&quot;);
 
-  PHYSFS_addToSearchPath(&quot;./data/&quot;,1);
-  PHYSFS_addToSearchPath(&quot;/usr/share/antargisgui/&quot;,1);
-  PHYSFS_addToSearchPath(&quot;/usr/share/antargisgui/pics&quot;,1);
-  PHYSFS_addToSearchPath(&quot;/usr/local/share/antargisgui/&quot;,1);
-  PHYSFS_addToSearchPath(&quot;/usr/local/share/antargisgui/pics&quot;,1);
-  PHYSFS_addToSearchPath(&quot;./&quot;,1);
-  PHYSFS_addToSearchPath(&quot;../&quot;,1);
+    PHYSFS_addToSearchPath(&quot;./data/&quot;,1);
+    PHYSFS_addToSearchPath(&quot;/usr/share/antargisgui/&quot;,1);
+    PHYSFS_addToSearchPath(&quot;/usr/share/antargisgui/pics&quot;,1);
+    PHYSFS_addToSearchPath(&quot;/usr/local/share/antargisgui/&quot;,1);
+    PHYSFS_addToSearchPath(&quot;/usr/local/share/antargisgui/pics&quot;,1);
+    PHYSFS_addToSearchPath(&quot;./&quot;,1);
+    PHYSFS_addToSearchPath(&quot;../&quot;,1);
 
-  char **p=PHYSFS_getSearchPath();
-  for(;*p;p++)
-    {
-      dbout(0,*p);
+    char **p=PHYSFS_getSearchPath();
+    for(;*p;p++)
+      {
+        dbout(0,*p);
 
-    }
+      }
 
-  dbout(0,&quot;--&quot;);
+    dbout(0,&quot;--&quot;);
 
 #endif
-  addPath(&quot;data&quot;);
-  addPath(&quot;data/fonts&quot;);
+    addPath(&quot;data&quot;);
+    addPath(&quot;data/fonts&quot;);
 #ifndef WIN32
-  addPath(&quot;/usr/local/share/antargisgui/pics&quot;);
-  addPath(&quot;/usr/local/share/antargisgui&quot;);
-  addPath(&quot;/usr/share/fonts/truetype/freefont/&quot;);
+    addPath(&quot;/usr/local/share/antargisgui/pics&quot;);
+    addPath(&quot;/usr/local/share/antargisgui&quot;);
+    addPath(&quot;/usr/share/fonts/truetype/freefont/&quot;);
 #endif
-  addPath(getWriteDir());
+    addPath(getWriteDir());
 #ifdef WIN32
-  addPath(&quot;c:/Windows/Fonts/&quot;);
+    addPath(&quot;c:/Windows/Fonts/&quot;);
 #endif
-}
+  }
 
 void checkDir(const std::string &amp;s)
-{
+  {
 #ifdef WIN32
-  DWORD rc = CreateDirectory(s.c_str(), NULL);
-  DWORD le;
-  if(rc==0)
-    {
-	  le=GetLastError();
-	  if(le==ERROR_ALREADY_EXISTS)
-		{
-		   // dir exists -ok
-		}
-	  else
-	  {
-		  dbout(0,&quot;could not create dir:&quot;&lt;&lt;s);
-		  dbout(0,&quot;rc:&quot;&lt;&lt;rc);
-		  throw std::runtime_error(&quot;could not create dir&quot;);
-		}
-    }
+    DWORD rc = CreateDirectory(s.c_str(), NULL);
+    DWORD le;
+    if(rc==0)
+      {
+        le=GetLastError();
+        if(le==ERROR_ALREADY_EXISTS)
+          {
+            // dir exists -ok
+          }
+        else
+          {
+            dbout(0,&quot;could not create dir:&quot;&lt;&lt;s);
+            dbout(0,&quot;rc:&quot;&lt;&lt;rc);
+            throw std::runtime_error(&quot;could not create dir&quot;);
+          }
+      }
 #else
-  int rc;
-  errno = 0;
-  rc = mkdir(s.c_str(), S_IRWXU);
-  if(rc==-1)
-    {
-      switch(errno)
-	{
-	case EEXIST:
-	  return; // everything's fine - directory exists already;
-	case EACCES: 
-	  return; // probably exists - we don't have access
-	default:
-	  dbout(0,&quot;could not create dir:&quot;&lt;&lt;s);
-	  throw std::runtime_error(&quot;could not create dir&quot;);
-	}
-    }
+    int rc;
+    errno = 0;
+    rc = mkdir(s.c_str(), S_IRWXU);
+    if(rc==-1)
+      {
+        switch(errno)
+        {
+        case EEXIST:
+          return; // everything's fine - directory exists already;
+        case EACCES: 
+          return; // probably exists - we don't have access
+        default:
+          dbout(0,&quot;could not create dir:&quot;&lt;&lt;s);
+          throw std::runtime_error(&quot;could not create dir&quot;);
+        }
+      }
 #endif
-}
+  }
 
 void checkParentDirs(const std::string &amp;s)
-{
+  {
 #ifdef WIN32
-  std::string sep=&quot;\\&quot;;
+    std::string sep=&quot;\\&quot;;
 #else
-  std::string sep=&quot;/&quot;;
+    std::string sep=&quot;/&quot;;
 #endif
-  std::vector&lt;std::string&gt; a=split(sep,s);
+    std::vector&lt;std::string&gt; a=split(sep,s);
 
-  a.pop_back();
+    a.pop_back();
 
-  std::ostringstream os;
-  for(std::vector&lt;std::string&gt;::iterator i=a.begin();i!=a.end();++i)
-    {
-      if(i-&gt;length()==0)
-		continue;
-      if(i!=a.begin())
-		os&lt;&lt;sep;
-      os&lt;&lt;*i;
-      if(os.str().find(sep)!=std::string::npos)
-		checkDir(os.str());
-    }
-}
+    std::ostringstream os;
+    for(std::vector&lt;std::string&gt;::iterator i=a.begin();i!=a.end();++i)
+      {
+        if(i-&gt;length()==0)
+          continue;
+        if(i!=a.begin())
+          os&lt;&lt;sep;
+        os&lt;&lt;*i;
+        if(os.str().find(sep)!=std::string::npos)
+          checkDir(os.str());
+      }
+  }
 
 AGFilename checkFileName(AGFilename s)
-{
+  {
 #ifdef WIN32
-  if(s.length()&gt;300)
-	throw std::runtime_error(&quot;possible segfault???&quot;);
-  s=replace(s,&quot;/&quot;,&quot;\\&quot;);
-  s=replace(s,&quot;\\\\&quot;,&quot;\\&quot;); // prevent windows from searching on network
+    if(s.length()&gt;300)
+      throw std::runtime_error(&quot;possible segfault???&quot;);
+    s=replace(s,&quot;/&quot;,&quot;\\&quot;);
+    s=replace(s,&quot;\\\\&quot;,&quot;\\&quot;); // prevent windows from searching on network
 #endif
-  return s;
-}
+    return s;
+  }
 
 std::string directLoad(const std::string &amp;pName)
-{
-  std::string fn=checkFileName(pName);
-  if(!fileExists(fn))
-	return &quot;&quot;;
-  
-  FILE *f=fopen(fn.c_str(),&quot;rb&quot;);
-  if(!f)
-    return &quot;&quot;;
-  fseek(f,0,SEEK_END);
-  long len=ftell(f);
-  fseek(f,0,SEEK_SET);
-  char *buffer=new char[len+2];
-  fread(buffer,1,len,f);
+  {
+    std::string fn=checkFileName(pName);
+    if(!fileExists(fn))
+      return &quot;&quot;;
 
-  fclose(f);
+    FILE *f=fopen(fn.c_str(),&quot;rb&quot;);
+    if(!f)
+      return &quot;&quot;;
+    fseek(f,0,SEEK_END);
+    long len=ftell(f);
+    fseek(f,0,SEEK_SET);
+    char *buffer=new char[len+2];
+    fread(buffer,1,len,f);
 
-  std::string r(buffer,len);
-  delete [] buffer;
-  return r;
-}
+    fclose(f);
 
+    std::string r(buffer,len);
+    delete [] buffer;
+    return r;
+  }
+
 AGFilename findFile(const AGFilename &amp;pName)
-{
-  if(fileExists(pName))
-    return pName;
-  for(std::list&lt;AGFilename&gt;::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
-    {
-      std::string n=*i+&quot;/&quot;+pName;
-      n=checkFileName(n);
-      if(fileExists(n))
-	return n;
-    }
+  {
+    if(fileExists(pName))
+      return pName;
+    for(std::list&lt;AGFilename&gt;::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
+      {
+        std::string n=*i+&quot;/&quot;+pName;
+        n=checkFileName(n);
+        if(fileExists(n))
+          return n;
+      }
 
 
-  if(pName.length()&gt;5)
-    {
-      if(pName.substr(pName.length()-4,3)==&quot;png&quot;)
-	return findFile(pName.substr(0,pName.length()-3)+&quot;jpg&quot;);
-    }
+    if(pName.length()&gt;5)
+      {
+        if(pName.substr(pName.length()-4,3)==&quot;png&quot;)
+          return findFile(pName.substr(0,pName.length()-3)+&quot;jpg&quot;);
+      }
 
-  //  throw std::runtime_error(&quot;File not found!&quot;);
-  return &quot;&quot;;
-}
+    //  throw std::runtime_error(&quot;File not found!&quot;);
+    return &quot;&quot;;
+  }
 
 std::string loadFromPath(const std::string &amp;pName)
-{
-  std::string r;
-  r=directLoad(pName);
-  if(r.length())
-    return r;
+  {
+    std::string r;
+    r=directLoad(pName);
+    if(r.length())
+      return r;
 
-  for(std::list&lt;AGFilename&gt;::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
-    {
-      r=directLoad(*i+&quot;/&quot;+pName);
-      if(r.length())
-	return r;
-    }
+    for(std::list&lt;AGFilename&gt;::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
+      {
+        r=directLoad(*i+&quot;/&quot;+pName);
+        if(r.length())
+          return r;
+      }
 
-  //  if(mFsPaths.size()==0)
-  //    throw std::runtime_error(&quot;Not yet inited fs-paths!&quot;);
+    //  if(mFsPaths.size()==0)
+    //    throw std::runtime_error(&quot;Not yet inited fs-paths!&quot;);
 
-  for(std::list&lt;AGFilename&gt;::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
-    dbout(0,&quot;path:&quot;&lt;&lt;*i);
+    for(std::list&lt;AGFilename&gt;::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
+      dbout(0,&quot;path:&quot;&lt;&lt;*i);
 
-  dbout(0,&quot;LOAD FAILED:&quot;&lt;&lt;pName);
+    dbout(0,&quot;LOAD FAILED:&quot;&lt;&lt;pName);
 
-  return r;
-}
+    return r;
+  }
 
 AGData loadFile(const AGFilename &amp;pName)
-{
-  return loadFromPath(checkFileName(pName));
+  {
+    return loadFromPath(checkFileName(pName));
 #ifdef USE_PHYSFS
-  TRACE;
-  assert(FSinited);
+    TRACE;
+    assert(FSinited);
 
-  std::string r=directLoad(pName);
-  if(r.length()!=0)
-	return r;
-
-  if(!fileExists(pName))
-    {
-      std::string r=directLoad(pName);
-      if(r.length()==0)
-	    std::cerr&lt;&lt;&quot;File '&quot;&lt;&lt;pName&lt;&lt;&quot;' does not exist!&quot;&lt;&lt;std::endl;
+    std::string r=directLoad(pName);
+    if(r.length()!=0)
       return r;
-    }
 
-  std::cerr&lt;&lt;&quot;File probably doesn't exist:&quot;&lt;&lt;pName&lt;&lt;std::endl;
-  PHYSFS_file *f=PHYSFS_openRead(pName.c_str());
-  std::string o;
+    if(!fileExists(pName))
+      {
+        std::string r=directLoad(pName);
+        if(r.length()==0)
+          std::cerr&lt;&lt;&quot;File '&quot;&lt;&lt;pName&lt;&lt;&quot;' does not exist!&quot;&lt;&lt;std::endl;
+        return r;
+      }
 
-  char buf[1001];
-  PHYSFS_uint32 c=0;
+    std::cerr&lt;&lt;&quot;File probably doesn't exist:&quot;&lt;&lt;pName&lt;&lt;std::endl;
+    PHYSFS_file *f=PHYSFS_openRead(pName.c_str());
+    std::string o;
 
-  do
-    {
-      c=PHYSFS_read(f,buf,1,1000);
-      o+=std::string(buf,c);
-    }
-  while(c);
+    char buf[1001];
+    PHYSFS_uint32 c=0;
 
-  PHYSFS_close(f);
-  return o;
+    do
+      {
+        c=PHYSFS_read(f,buf,1,1000);
+        o+=std::string(buf,c);
+      }
+    while(c);
+
+    PHYSFS_close(f);
+    return o;
 #endif
-}
+  }
 
 #ifdef WIN32
 /* GetUserProfileDirectory() is only available on &gt;= NT4 (no 9x/ME systems!) */
 typedef BOOL (STDMETHODCALLTYPE FAR * LPFNGETUSERPROFILEDIR) (
-      HANDLE hToken,
-      LPTSTR lpProfileDir,
-      LPDWORD lpcchSize);
+    HANDLE hToken,
+    LPTSTR lpProfileDir,
+    LPDWORD lpcchSize);
 #endif
 
 
 std::string gUserDir;
 std::string getUserDir()
-{
-  if(gUserDir==&quot;&quot;)
-    {
+  {
+    if(gUserDir==&quot;&quot;)
+      {
 #ifdef WIN32
-      char *userDir=0;
+        char *userDir=0;
 
-      DWORD psize = 0;
-      char dummy[1];
-      BOOL rc = 0;
-      HANDLE processHandle;            /* Current process handle */
-      HANDLE accessToken = NULL;       /* Security handle to process */
-      LPFNGETUSERPROFILEDIR GetUserProfileDirectory;
-      HMODULE lib;
-      
-      assert(userDir == 0);
-      
-      /*
-       * GetUserProfileDirectory() is only available on NT 4.0 and later.
-       *  This means Win95/98/ME (and CE?) users have to do without, so for
-       *  them, we'll default to the base directory when we can't get the
-       *  function pointer.
-       */
-      
-      lib = LoadLibrary(&quot;userenv.dll&quot;);
-      if (lib)
-	{
-	  /* !!! FIXME: Handle Unicode? */
-	  GetUserProfileDirectory = (LPFNGETUSERPROFILEDIR)
-	    GetProcAddress(lib, &quot;GetUserProfileDirectoryA&quot;);
-	  if (GetUserProfileDirectory)
-	    {
-	      processHandle = GetCurrentProcess();
-	      if (OpenProcessToken(processHandle, TOKEN_QUERY, &amp;accessToken))
-		{
-		  /*
-		   * Should fail. Will write the size of the profile path in
-		   *  psize. Also note that the second parameter can't be
-		   *  NULL or the function fails.
-		   */
-		  rc = GetUserProfileDirectory(accessToken, dummy, &amp;psize);
-		  assert(!rc);  /* success?! */
-		  
-		  /* Allocate memory for the profile directory */
-		  userDir = new char[psize+1];
-		  if (userDir != NULL)
-		    {
-		      if (!GetUserProfileDirectory(accessToken, userDir, &amp;psize))
-			{
-			  delete [] userDir;
-			  userDir = NULL;
-			} /* if */
-		    } /* else */
-		} /* if */
-	      
-	      CloseHandle(accessToken);
-	    } /* if */
-	  
-	  FreeLibrary(lib);
-	} /* if */
-      
-      if (userDir == NULL)  /* couldn't get profile for some reason. */
-	{
-	  /* Might just be a non-NT system; resort to the basedir. */
-	  userDir = &quot;.&quot;;
-	  std::cerr&lt;&lt;&quot;sorry, this game doesn't run correctly on non-nt systems (win98/me)&quot;&lt;&lt;std::endl;
-	} /* if */
-      gUserDir=userDir;
-      
+        DWORD psize = 0;
+        char dummy[1];
+        BOOL rc = 0;
+        HANDLE processHandle;            /* Current process handle */
+        HANDLE accessToken = NULL;       /* Security handle to process */
+        LPFNGETUSERPROFILEDIR GetUserProfileDirectory;
+        HMODULE lib;
+
+        assert(userDir == 0);
+
+        /*
+         * GetUserProfileDirectory() is only available on NT 4.0 and later.
+         *  This means Win95/98/ME (and CE?) users have to do without, so for
+         *  them, we'll default to the base directory when we can't get the
+         *  function pointer.
+         */
+
+        lib = LoadLibrary(&quot;userenv.dll&quot;);
+        if (lib)
+          {
+            /* !!! FIXME: Handle Unicode? */
+            GetUserProfileDirectory = (LPFNGETUSERPROFILEDIR)
+            GetProcAddress(lib, &quot;GetUserProfileDirectoryA&quot;);
+            if (GetUserProfileDirectory)
+              {
+                processHandle = GetCurrentProcess();
+                if (OpenProcessToken(processHandle, TOKEN_QUERY, &amp;accessToken))
+                  {
+                    /*
+                     * Should fail. Will write the size of the profile path in
+                     *  psize. Also note that the second parameter can't be
+                     *  NULL or the function fails.
+                     */
+                    rc = GetUserProfileDirectory(accessToken, dummy, &amp;psize);
+                    assert(!rc);  /* success?! */
+
+                    /* Allocate memory for the profile directory */
+                    userDir = new char[psize+1];
+                    if (userDir != NULL)
+                      {
+                        if (!GetUserProfileDirectory(accessToken, userDir, &amp;psize))
+                          {
+                            delete [] userDir;
+                            userDir = NULL;
+                          } /* if */
+                      } /* else */
+                  } /* if */
+
+                CloseHandle(accessToken);
+              } /* if */
+
+            FreeLibrary(lib);
+          } /* if */
+
+        if (userDir == NULL)  /* couldn't get profile for some reason. */
+          {
+            /* Might just be a non-NT system; resort to the basedir. */
+            userDir = &quot;.&quot;;
+            std::cerr&lt;&lt;&quot;sorry, this game doesn't run correctly on non-nt systems (win98/me)&quot;&lt;&lt;std::endl;
+          } /* if */
+        gUserDir=userDir;
+
 #else
-      gUserDir=getenv(&quot;HOME&quot;);
+        gUserDir=getenv(&quot;HOME&quot;);
 #endif
-    }
-  return gUserDir;
-}
+      }
+    return gUserDir;
+  }
 
 
 #ifdef WIN32
@@ -391,216 +394,215 @@
 #define SHGFP_TYPE_CURRENT 0
 
 AGFilename getDocumentsDir()
-{
-  CHAR wszPath[MAX_PATH];
-  
-  HWND hWnd=0;
+  {
+    CHAR wszPath[MAX_PATH];
 
-  SHGetFolderPath( hWnd, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, wszPath );
+    HWND hWnd=0;
 
-  AGFilename s(wszPath);
+    SHGetFolderPath( hWnd, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, wszPath );
 
-  return s;
+    AGFilename s(wszPath);
 
-}
+    return s;
 
+  }
+
 #else
 
 AGFilename getDocumentsDir()
-{
-  return getUserDir()+&quot;/Desktop&quot;;
-}
+  {
+    return getUserDir()+&quot;/Desktop&quot;;
+  }
 
 
 #endif
 
 
 AGFilename getWriteDir()
-{
-  return getUserDir()+&quot;/.&quot;+getAppName();
-}
+  {
+    return getUserDir()+&quot;/.&quot;+getAppName();
+  }
 
 bool saveFile(const AGFilename &amp;pName,const AGData &amp;pContent)
-{
+  {
 #ifdef USE_PHYSFS
-  TRACE;
-  assert(FSinited);
+    TRACE;
+    assert(FSinited);
 
-  PHYSFS_file *f=PHYSFS_openWrite(pName.c_str());
+    PHYSFS_file *f=PHYSFS_openWrite(pName.c_str());
 
-  if(!f)
-    {
-      dbout(0,&quot;Error saving file:&quot;&lt;&lt;pName);
-    }
-  assert(f);
+    if(!f)
+      {
+        dbout(0,&quot;Error saving file:&quot;&lt;&lt;pName);
+      }
+    assert(f);
 
-  PHYSFS_write(f,pContent.c_str(),1,pContent.length());
+    PHYSFS_write(f,pContent.c_str(),1,pContent.length());
 
-  PHYSFS_close(f);
+    PHYSFS_close(f);
 #else
-  std::string n=checkFileName(getWriteDir()+&quot;/&quot;+pName);
+    std::string n=checkFileName(getWriteDir()+&quot;/&quot;+pName);
 
-  checkParentDirs(n);
+    checkParentDirs(n);
 
 
-  FILE *f=fopen(n.c_str(),&quot;wb&quot;);
-  if(!f)
-    return false;
-  fwrite(pContent.c_str(),pContent.length(),1,f);
-  fclose(f);
+    FILE *f=fopen(n.c_str(),&quot;wb&quot;);
+    if(!f)
+      return false;
+    fwrite(pContent.c_str(),pContent.length(),1,f);
+    fclose(f);
 
 #endif
-  return true;
-}
+    return true;
+  }
 
 bool fileExists(const AGFilename &amp;pName)
-{
+  {
 #ifdef WIN32
-  if(GetFileAttributes(pName.c_str()) == INVALID_FILE_ATTRIBUTES)
-    return false;
-  return true;
+    if(GetFileAttributes(pName.c_str()) == INVALID_FILE_ATTRIBUTES)
+      return false;
+    return true;
 #endif
 
-  FILE *f=fopen(pName.c_str(),&quot;r&quot;);
-  bool found=false;
-	
-  if(f)
-    {
-			found=true;
-      fclose(f);
-    }
-  //	cdebug(&quot;file exists:&quot;&lt;&lt;pName&lt;&lt;&quot;:&quot;&lt;&lt;found);
+    FILE *f=fopen(pName.c_str(),&quot;r&quot;);
+    bool found=false;
 
-  return found;
+    if(f)
+      {
+        found=true;
+        fclose(f);
+      }
+
+    return found;
 #ifdef USE_PHYSFS
-  TRACE;
-  return PHYSFS_exists(pName.c_str());
+    TRACE;
+    return PHYSFS_exists(pName.c_str());
 #endif
-}
+  }
 
 std::vector&lt;AGFilename&gt; getDirectoryInternal(const AGFilename &amp;pDir)
-{
+  {
 #ifdef USE_PHYSFS
-  TRACE;
-  char **files= PHYSFS_enumerateFiles(pDir.c_str());
-  std::vector&lt;std::string&gt; v;
+    TRACE;
+    char **files= PHYSFS_enumerateFiles(pDir.c_str());
+    std::vector&lt;std::string&gt; v;
 
-  char **p=files;
+    char **p=files;
 
-  while(*p)
-    {
-      v.push_back(*p);
-      p++;
-    }
+    while(*p)
+      {
+        v.push_back(*p);
+        p++;
+      }
 
-  PHYSFS_freeList(files);
-  return v;
+    PHYSFS_freeList(files);
+    return v;
 #else
 
-  std::vector&lt;AGFilename&gt; v;
+    std::vector&lt;AGFilename&gt; v;
 
 #ifdef WIN32
-  WIN32_FIND_DATA ent;
+    WIN32_FIND_DATA ent;
 
-  std::string dir=pDir+&quot;\\*&quot;;
+    std::string dir=pDir+&quot;\\*&quot;;
 
-  dir=replace(dir,&quot;\\\\&quot;,&quot;\\&quot;); // remove doubles
+    dir=replace(dir,&quot;\\\\&quot;,&quot;\\&quot;); // remove doubles
 
-  char path[dir.length()+20];
-  strcpy(path,dir.c_str());
+    char path[dir.length()+20];
+    strcpy(path,dir.c_str());
 
-  HANDLE d=FindFirstFile(path,&amp;ent);
+    HANDLE d=FindFirstFile(path,&amp;ent);
 
-  if(d)
-    {
-      do
-	{
-	  v.push_back(ent.cFileName);
-	}
-      while(FindNextFile(d,&amp;ent)!=0);
-      
-      FindClose(d);
-    }
+    if(d)
+      {
+        do
+          {
+            v.push_back(ent.cFileName);
+          }
+        while(FindNextFile(d,&amp;ent)!=0);
 
+        FindClose(d);
+      }
+
 #else
-  struct dirent *ent;
-  DIR *dir;
-  std::string dirname=pDir;//+&quot;/*&quot;;
-  dbout(0,&quot;DIR:&quot;&lt;&lt;dirname);
-  dir=opendir(dirname.c_str());
-  if(dir)
-    {
-      while((ent=readdir(dir)))
-	{
-	  dbout(0,&quot;found:&quot;&lt;&lt;ent-&gt;d_name);
-	  v.push_back(ent-&gt;d_name);
-	}
-    }
+    struct dirent *ent;
+    DIR *dir;
+    std::string dirname=pDir;//+&quot;/*&quot;;
+    dbout(0,&quot;DIR:&quot;&lt;&lt;dirname);
+    dir=opendir(dirname.c_str());
+    if(dir)
+      {
+        while((ent=readdir(dir)))
+          {
+            dbout(0,&quot;found:&quot;&lt;&lt;ent-&gt;d_name);
+            v.push_back(ent-&gt;d_name);
+          }
+      }
 
 
 #endif
 
-  return v;
+    return v;
 #endif
-}
+  }
 
 std::vector&lt;AGFilename&gt; getDirectory(const AGFilename &amp;pDir)
-{
-  std::vector&lt;AGFilename&gt; v;
-  std::list&lt;AGFilename&gt; ps=mFsPaths;
-  ps.push_front(&quot;&quot;); // add current dir
-  ps.push_front(&quot;.&quot;); // add current dir
+  {
+    std::vector&lt;AGFilename&gt; v;
+    std::list&lt;AGFilename&gt; ps=mFsPaths;
+    ps.push_front(&quot;&quot;); // add current dir
+    ps.push_front(&quot;.&quot;); // add current dir
 
 
-  for(std::list&lt;AGFilename&gt;::iterator i=ps.begin();i!=ps.end();i++)
-    {
-      
-      std::vector&lt;AGFilename&gt; a=getDirectoryInternal(*i+&quot;/&quot;+pDir);
-      std::copy(a.begin(),a.end(),std::back_inserter(v));
-    }
-      
-  return v;
-}
+    for(std::list&lt;AGFilename&gt;::iterator i=ps.begin();i!=ps.end();i++)
+      {
 
+        std::vector&lt;AGFilename&gt; a=getDirectoryInternal(*i+&quot;/&quot;+pDir);
+        std::copy(a.begin(),a.end(),std::back_inserter(v));
+      }
 
+    return v;
+  }
 
 
+
+
 AGData compress(const AGData &amp;pString)
-{
-  BinaryStringOut o;
-  o&lt;&lt;(Uint32)pString.length();
+  {
+    BinaryStringOut o;
+    o&lt;&lt;(Uint32)pString.length();
 
-  uLongf destlen=pString.length()+1000;
-  char *buf=new char[destlen];
+    uLongf destlen=pString.length()+1000;
+    char *buf=new char[destlen];
 
-  compress((Bytef*)buf,&amp;destlen,(Bytef*)pString.c_str(),pString.length());
+    compress((Bytef*)buf,&amp;destlen,(Bytef*)pString.c_str(),pString.length());
 
-  std::string r=o.getString()+std::string(buf,destlen);
-  delete [] buf;
-  return r;
-}
+    std::string r=o.getString()+std::string(buf,destlen);
+    delete [] buf;
+    return r;
+  }
 AGData uncompress(const AGData &amp;pString)
-{
-  BinaryStringIn i(pString);
-  uLongf orig;
-  Uint32 o;
-  i&gt;&gt;o;
-  orig=o;
+  {
+    BinaryStringIn i(pString);
+    uLongf orig;
+    Uint32 o;
+    i&gt;&gt;o;
+    orig=o;
 
 
-  char *buf=new char[orig+10];
-  uncompress((Bytef*)buf,&amp;orig,(Bytef*)pString.c_str()+4,pString.length()-4);
-  std::string r(buf,orig);
-  delete [] buf;
+    char *buf=new char[orig+10];
+    uncompress((Bytef*)buf,&amp;orig,(Bytef*)pString.c_str()+4,pString.length()-4);
+    std::string r(buf,orig);
+    delete [] buf;
 
-  return r;
-}
+    return r;
+  }
 
 AGFilename getDirSep()
-{
+  {
 #ifdef WIN32
-  return &quot;\\&quot;;
+    return &quot;\\&quot;;
 #else
-  return &quot;/&quot;;
+    return &quot;/&quot;;
 #endif
-}
+  }

Modified: antargis/trunk/ext/basic/ag_geometry.cc
===================================================================
--- antargis/trunk/ext/basic/ag_geometry.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_geometry.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -38,17 +38,17 @@
 AGVector2 invalidVec2;
 
 bool collide1d(float a1,float a2,float b1,float b2, bool normal=true)
-{
-  float amin=std::min(a1,a2);
-  float amax=std::max(a1,a2);
-  float bmin=std::min(b1,b2);
-  float bmax=std::max(b1,b2);
+  {
+    float amin=std::min(a1,a2);
+    float amax=std::max(a1,a2);
+    float bmin=std::min(b1,b2);
+    float bmax=std::max(b1,b2);
 
-  if(normal &amp;&amp; (amax==bmin || bmax==amin))
-    return false;
+    if(normal &amp;&amp; (amax==bmin || bmax==amin))
+      return false;
 
-  return (amin&gt;=bmin &amp;&amp; amin&lt;=bmax) || (amax&gt;=bmin &amp;&amp; amax&lt;=bmax) || (bmin&gt;=amin &amp;&amp; bmin&lt;=amax) || (bmax&gt;=amin &amp;&amp; bmax&lt;=amin);
-}
+    return (amin&gt;=bmin &amp;&amp; amin&lt;=bmax) || (amax&gt;=bmin &amp;&amp; amax&lt;=bmax) || (bmin&gt;=amin &amp;&amp; bmin&lt;=amax) || (bmax&gt;=amin &amp;&amp; bmax&lt;=amin);
+  }
 
 struct AGSweepResult
 {
@@ -58,37 +58,37 @@
   float t1;
 
   AGSweepResult()
-  {
-    state=COL_ALWAYS;
-  }
+    {
+      state=COL_ALWAYS;
+    }
 
   void combine(const AGSweepResult &amp;r)
-  {
-    if(state==COL_AT)
-      {
-	if(r.state==COL_NEVER)
-	  state=COL_NEVER;
-	else if(r.state!=COL_ALWAYS) // ALWAYS has no effect
-	  {
-	    t0=std::max(t0,r.t0);
-	    t1=std::min(t1,r.t1);
-	  }
-      }
-    else if(state==COL_ALWAYS)
-      {
-	if(r.state==COL_NEVER)
-	  state=COL_NEVER;
-	else if(r.state!=COL_ALWAYS) // ALWAYS has no effect
-	  {
-	    state=COL_AT;
-	    t0=r.t0;
-	    t1=r.t1;
-	  }
-	
-      }
-    // COL_NEVER cannot be changed
-  }
+    {
+      if(state==COL_AT)
+        {
+          if(r.state==COL_NEVER)
+            state=COL_NEVER;
+          else if(r.state!=COL_ALWAYS) // ALWAYS has no effect
+            {
+              t0=std::max(t0,r.t0);
+              t1=std::min(t1,r.t1);
+            }
+        }
+      else if(state==COL_ALWAYS)
+        {
+          if(r.state==COL_NEVER)
+            state=COL_NEVER;
+          else if(r.state!=COL_ALWAYS) // ALWAYS has no effect
+            {
+              state=COL_AT;
+              t0=r.t0;
+              t1=r.t1;
+            }
 
+        }
+      // COL_NEVER cannot be changed
+    }
+
   bool collision(float delta) const
   {
     return state==COL_ALWAYS || (state==COL_AT &amp;&amp; t1&gt;0 &amp;&amp; t0&lt;delta);
@@ -112,38 +112,38 @@
 };
 
 AGSweepResult collide1d(float pa1,float pa2,float pb1,float pb2,float v)
-{
-  float a1=std::min(pa1,pa2);
-  float a2=std::max(pa1,pa2);
-  float b1=std::min(pb1,pb2);
-  float b2=std::max(pb1,pb2);
-  AGSweepResult r;
+  {
+    float a1=std::min(pa1,pa2);
+    float a2=std::max(pa1,pa2);
+    float b1=std::min(pb1,pb2);
+    float b2=std::max(pb1,pb2);
+    AGSweepResult r;
 
-  if(v&gt;0)
-    {
-      r.t0=(b1-a2)/v;
-      r.t1=(b2-a1)/v;
-      r.state = AGSweepResult::COL_AT;
+    if(v&gt;0)
+      {
+        r.t0=(b1-a2)/v;
+        r.t1=(b2-a1)/v;
+        r.state = AGSweepResult::COL_AT;
 
-      assert(r.t0 &lt;= r.t1);
-    }
-  else if(v&lt;0)
-    {
-      r.t0=(b2-a1)/v;
-      r.t1=(b1-a2)/v;
-      r.state = AGSweepResult::COL_AT;
+        assert(r.t0 &lt;= r.t1);
+      }
+    else if(v&lt;0)
+      {
+        r.t0=(b2-a1)/v;
+        r.t1=(b1-a2)/v;
+        r.state = AGSweepResult::COL_AT;
 
-      assert(r.t0 &lt;= r.t1);
-    }
-  else
-    {
-      if (a2 &lt; b1 || a1 &gt; b2)
-        r.state = AGSweepResult::COL_NEVER;
-      else
-        r.state = AGSweepResult::COL_ALWAYS;
-    }
-  return r;
-}
+        assert(r.t0 &lt;= r.t1);
+      }
+    else
+      {
+        if (a2 &lt; b1 || a1 &gt; b2)
+          r.state = AGSweepResult::COL_NEVER;
+        else
+          r.state = AGSweepResult::COL_ALWAYS;
+      }
+    return r;
+  }
 
 /////////////////////////////////////////////////////////////////////////////
 // AGAngle
@@ -158,38 +158,38 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGVector2::AGVector2(const AGString &amp;s)
-{
-  assert(s.length()&gt;=5);
-  assert(s[0]=='(');
-  assert(s[s.length()-1]==')');
-  AGString p=s.substr(1,s.length()-2);
-  size_t i=p.find(&quot;,&quot;);
-  assert(i!=p.npos);
-  v[0]=p.substr(0,i).toFloat();
-  v[1]=p.substr(i+1,p.length()-i-1).toFloat();
-}
+  {
+    assert(s.length()&gt;=5);
+    assert(s[0]=='(');
+    assert(s[s.length()-1]==')');
+    AGString p=s.substr(1,s.length()-2);
+    size_t i=p.find(&quot;,&quot;);
+    assert(i!=p.npos);
+    v[0]=p.substr(0,i).toFloat();
+    v[1]=p.substr(i+1,p.length()-i-1).toFloat();
+  }
 
 
 AGVector2::AGVector2(float pX,float pY)
-{
-  v[0]=pX;
-  v[1]=pY;
-}
+  {
+    v[0]=pX;
+    v[1]=pY;
+  }
 AGVector2::AGVector2(const AGVector2 &amp;a)
-{
-  v[0]=a.v[0];
-  v[1]=a.v[1];
-}
+  {
+    v[0]=a.v[0];
+    v[1]=a.v[1];
+  }
 AGVector2::AGVector2(const AGAngle &amp;a)
-{
-  v[0]=sin(a.angle);
-  v[1]=-cos(a.angle);
-}
+  {
+    v[0]=sin(a.angle);
+    v[1]=-cos(a.angle);
+  }
 
 AGVector2::AGVector2()
-{
-  v[0]=v[1]=0;
-}
+  {
+    v[0]=v[1]=0;
+  }
 
 void AGVector2::saveXML(Node &amp;node) const
 {
@@ -197,10 +197,10 @@
   node.set(&quot;y&quot;,AGString(v[1]));
 }
 void AGVector2::loadXML(const Node &amp;node)
-{
-  v[0]=node.get(&quot;x&quot;).toFloat();
-  v[1]=node.get(&quot;y&quot;).toFloat();
-}
+  {
+    v[0]=node.get(&quot;x&quot;).toFloat();
+    v[1]=node.get(&quot;y&quot;).toFloat();
+  }
 
 bool AGVector2::operator&lt;(const AGVector2 &amp;p) const
 {
@@ -215,24 +215,24 @@
 
 
 float getArcInternal(float x,float y)
-{
-  if(y==0.0)
-    {
-      if(x&lt;0.0)
-	return -M_PI/2.0;
-      else
-	return M_PI/2.0;
-    }
-  else if(y&lt;0.0)
-    {
-      float a=M_PI+atan(x/y);
-      if(a&gt;M_PI)
-	a-=M_PI*2.0;
-      return a;
-    }
-  else
-    return atan(x/y);
-}
+  {
+    if(y==0.0)
+      {
+        if(x&lt;0.0)
+          return -M_PI/2.0;
+        else
+          return M_PI/2.0;
+      }
+    else if(y&lt;0.0)
+      {
+        float a=M_PI+atan(x/y);
+        if(a&gt;M_PI)
+          a-=M_PI*2.0;
+        return a;
+      }
+    else
+      return atan(x/y);
+  }
 
 
 AGAngle AGVector2::getAngle() const
@@ -279,13 +279,13 @@
 }
 
 void AGVector2::setX(float pX)
-{
-  v[0]=pX;
-}
+  {
+    v[0]=pX;
+  }
 void AGVector2::setY(float pY)
-{
-  v[1]=pY;
-}
+  {
+    v[1]=pY;
+  }
 
 float AGVector2::getX() const
 {
@@ -365,10 +365,10 @@
     return *this;
 }
 void AGVector2::normalize()
-{
-  if(length2()!=0.0f)
-    operator/=(length());
-}
+  {
+    if(length2()!=0.0f)
+      operator/=(length());
+  }
 
 float AGVector2::operator[](int index) const
 {
@@ -387,36 +387,36 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGVector3::AGVector3(const AGVector2 &amp;p,float h)
-{
-  v[0]=p[0];
-  v[1]=p[1];
-  v[2]=h;
-}
+  {
+    v[0]=p[0];
+    v[1]=p[1];
+    v[2]=h;
+  }
 
 AGVector3::AGVector3(float pX,float pY,float pZ)
-{
-  v[0]=pX;
-  v[1]=pY;
-  v[2]=pZ;
-}
+  {
+    v[0]=pX;
+    v[1]=pY;
+    v[2]=pZ;
+  }
 AGVector3::AGVector3(const AGVector3 &amp;a)
-{
-  v[0]=a.v[0];
-  v[1]=a.v[1];
-  v[2]=a.v[2];
-}
+  {
+    v[0]=a.v[0];
+    v[1]=a.v[1];
+    v[2]=a.v[2];
+  }
 AGVector3::AGVector3(const AGAngle &amp;a)
-{
-  v[0]=sin(a.angle);
-  v[1]=-cos(a.angle);
-  v[2]=0.0f;
-}
+  {
+    v[0]=sin(a.angle);
+    v[1]=-cos(a.angle);
+    v[2]=0.0f;
+  }
 
 AGVector3::AGVector3()
-{
-  v[0]=v[1]=0;
-  v[2]=0.0f;
-}
+  {
+    v[0]=v[1]=0;
+    v[2]=0.0f;
+  }
 
 AGVector2 AGVector3::dim2() const
 {
@@ -437,11 +437,11 @@
   node.set(&quot;z&quot;,AGString(v[2]));
 }
 void AGVector3::loadXML(const Node &amp;node)
-{
-  v[0]=node.get(&quot;x&quot;).toFloat();
-  v[1]=node.get(&quot;y&quot;).toFloat();
-  v[2]=node.get(&quot;z&quot;).toFloat();
-}
+  {
+    v[0]=node.get(&quot;x&quot;).toFloat();
+    v[1]=node.get(&quot;y&quot;).toFloat();
+    v[2]=node.get(&quot;z&quot;).toFloat();
+  }
 
 
 
@@ -452,21 +452,21 @@
   if(y==0.0)
     {
       if(x&lt;0.0)
-	return -M_PI/2.0;
+        return -M_PI/2.0;
       else
-	return M_PI/2.0;
+        return M_PI/2.0;
     }
   else if(y&lt;0.0)
     {
       float a=M_PI+atan(x/y);
       if(a&gt;M_PI)
-	a-=M_PI*2.0;
+        a-=M_PI*2.0;
       return a;
     }
   else
     return atan(x/y);
 }
-*/
+ */
 
 AGAngle AGVector3::getAngle() const
 {
@@ -477,7 +477,7 @@
 bool AGVector3::operator==(const AGVector3 &amp;a) const
 {
   float m=std::max(v[0],std::max(v[1],v[2]));
-  
+
   m*=0.0001;
   return fabs(v[0]-a.v[0])&lt;m &amp;&amp; fabs(v[1]-a.v[1])&lt;m &amp;&amp; fabs(v[2]-a.v[2])&lt;m;
 }
@@ -510,17 +510,17 @@
 }
 
 void AGVector3::setX(float pX)
-{
-  v[0]=pX;
-}
+  {
+    v[0]=pX;
+  }
 void AGVector3::setY(float pY)
-{
-  v[1]=pY;
-}
+  {
+    v[1]=pY;
+  }
 void AGVector3::setZ(float pZ)
-{
-  v[2]=pZ;
-}
+  {
+    v[2]=pZ;
+  }
 
 float AGVector3::getX() const
 {
@@ -543,8 +543,8 @@
 AGVector3 AGVector3::operator%(const AGVector3 &amp;a) const
 {
   return AGVector3(v[1] * a.v[2] - v[2] * a.v[1],
-		   v[2] * a.v[0] - v[0] * a.v[2],
-		   v[0] * a.v[1] - v[1] * a.v[0]);
+      v[2] * a.v[0] - v[0] * a.v[2],
+      v[0] * a.v[1] - v[1] * a.v[0]);
 }
 
 
@@ -608,10 +608,10 @@
     return *this;
 }
 void AGVector3::normalize()
-{
-  if(length2()!=0.0f)
-    operator/=(length());
-}
+  {
+    if(length2()!=0.0f)
+      operator/=(length());
+  }
 
 float AGVector3::operator[](int index) const
 {
@@ -630,47 +630,47 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGMatrix3::AGMatrix3()
-{
-  a[0][1]=a[0][2]=
-    a[1][0]=a[1][2]=
-    a[2][0]=a[2][1]=0.0f;
+  {
+    a[0][1]=a[0][2]=
+      a[1][0]=a[1][2]=
+        a[2][0]=a[2][1]=0.0f;
 
-  a[0][0]=a[1][1]=a[2][2]=1.0f;
-}
+    a[0][0]=a[1][1]=a[2][2]=1.0f;
+  }
 
 AGMatrix3::AGMatrix3(const AGAngle &amp;n)
-{
-  a[0][0]=cos(n.angle);
-  a[1][0]=sin(n.angle);
-  a[0][1]=-sin(n.angle);
-  a[1][1]=cos(n.angle);
-  a[2][0]=a[2][1]=a[0][2]=a[1][2]=0.0f;
-  a[2][2]=1.0f;
-}
+  {
+    a[0][0]=cos(n.angle);
+    a[1][0]=sin(n.angle);
+    a[0][1]=-sin(n.angle);
+    a[1][1]=cos(n.angle);
+    a[2][0]=a[2][1]=a[0][2]=a[1][2]=0.0f;
+    a[2][2]=1.0f;
+  }
 
 AGMatrix3::AGMatrix3(const AGVector3 &amp;n)
-{
-  a[0][0]=a[1][1]=a[2][2]=1.0f;
-  a[0][1]=a[0][2]=
-    a[1][0]=a[1][2]=
-    a[2][0]=a[2][1]=0.0f;
-  a[2][0]=n[0];
-  a[2][1]=n[1];
-}
+  {
+    a[0][0]=a[1][1]=a[2][2]=1.0f;
+    a[0][1]=a[0][2]=
+      a[1][0]=a[1][2]=
+        a[2][0]=a[2][1]=0.0f;
+    a[2][0]=n[0];
+    a[2][1]=n[1];
+  }
 
 AGMatrix3::AGMatrix3(float x,float y)
-{
-  a[0][0]=x;
-  a[1][1]=y;
-  a[2][2]=1.0f;
-  a[0][1]=a[0][2]=
-    a[1][0]=a[1][2]=
-    a[2][0]=a[2][1]=0.0f;
-  a[2][0]=0.0f;
-  a[2][1]=0.0f;
-  
-}
+  {
+    a[0][0]=x;
+    a[1][1]=y;
+    a[2][2]=1.0f;
+    a[0][1]=a[0][2]=
+      a[1][0]=a[1][2]=
+        a[2][0]=a[2][1]=0.0f;
+    a[2][0]=0.0f;
+    a[2][1]=0.0f;
 
+  }
+
 AGMatrix3 AGMatrix3::transposed() const
 {
   AGMatrix3 a;
@@ -692,40 +692,40 @@
 }
 
 void AGMatrix3::swapRows(size_t a,size_t b)
-{
-  if(a==b)
-    return;
-  assert(a&lt;3);
-  assert(b&lt;3);
-  for(size_t x=0;x&lt;3;x++)
-    {
-      float t=get(x,a);
-      set(x,a,get(x,b));
-      set(x,b,t);
-    }
-}
+  {
+    if(a==b)
+      return;
+    assert(a&lt;3);
+    assert(b&lt;3);
+    for(size_t x=0;x&lt;3;x++)
+      {
+        float t=get(x,a);
+        set(x,a,get(x,b));
+        set(x,b,t);
+      }
+  }
 
 void AGMatrix3::swapCols(size_t a,size_t b)
-{
-  if(a==b)
-    return;
-  assert(a&lt;3);
-  assert(b&lt;3);
-  for(size_t y=0;y&lt;3;y++)
-    {
-      float t=get(a,y);
-      set(a,y,get(b,y));
-      set(b,y,t);
-    }
-}
+  {
+    if(a==b)
+      return;
+    assert(a&lt;3);
+    assert(b&lt;3);
+    for(size_t y=0;y&lt;3;y++)
+      {
+        float t=get(a,y);
+        set(a,y,get(b,y));
+        set(b,y,t);
+      }
+  }
 
 
 void AGMatrix3::set(size_t x,size_t y,float f)
-{
-  assert(x&gt;=0 &amp;&amp; x&lt;3);
-  assert(y&gt;=0 &amp;&amp; y&lt;3);
-  a[x][y]=f;
-}
+  {
+    assert(x&gt;=0 &amp;&amp; x&lt;3);
+    assert(y&gt;=0 &amp;&amp; y&lt;3);
+    a[x][y]=f;
+  }
 float AGMatrix3::get(size_t x,size_t y) const
 {
   assert(x&gt;=0 &amp;&amp; x&lt;3);
@@ -734,11 +734,11 @@
 }
 
 float &amp;AGMatrix3::get(size_t x,size_t y)
-{
-  assert(x&gt;=0 &amp;&amp; x&lt;3);
-  assert(y&gt;=0 &amp;&amp; y&lt;3);
-  return a[x][y];
-}
+  {
+    assert(x&gt;=0 &amp;&amp; x&lt;3);
+    assert(y&gt;=0 &amp;&amp; y&lt;3);
+    return a[x][y];
+  }
 
 AGMatrix3::Row AGMatrix3::operator[](size_t y)
 {
@@ -773,8 +773,8 @@
   for(x=0;x&lt;3;x++)
     for(y=0;y&lt;3;y++)
       n.a[x][y]=a[0][y]*m.a[x][0]+
-	a[1][y]*m.a[x][1]+
-	a[2][y]*m.a[x][2];
+      a[1][y]*m.a[x][1]+
+      a[2][y]*m.a[x][2];
   return n;
 }
 AGMatrix3 &amp;AGMatrix3::operator*=(const AGMatrix3 &amp;m)
@@ -786,8 +786,8 @@
 AGVector3 AGMatrix3::operator*(const AGVector3 &amp;v) const
 {
   return AGVector3(a[0][0]*v[0]+a[1][0]*v[1]+a[2][0]*v[2],
-		   a[0][1]*v[0]+a[1][1]*v[1]+a[2][1]*v[2],
-		   a[0][2]*v[0]+a[1][2]*v[1]+a[2][2]*v[2]);
+      a[0][1]*v[0]+a[1][1]*v[1]+a[2][1]*v[2],
+      a[0][2]*v[0]+a[1][2]*v[1]+a[2][2]*v[2]);
 }
 
 AGString AGMatrix3::toString() const
@@ -804,11 +804,11 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGTriangle2::AGTriangle2(const AGVector2 &amp;v0,const AGVector2 &amp;v1,const AGVector2 &amp;v2)
-{
-  p[0]=v0;
-  p[1]=v1;
-  p[2]=v2;
-}
+  {
+    p[0]=v0;
+    p[1]=v1;
+    p[2]=v2;
+  }
 
 AGRect2 AGTriangle2::getBBox() const
 {
@@ -822,11 +822,11 @@
 
 
 void AGTriangle2::apply(const AGMatrix3 &amp;m)
-{
-  p[0]=(m*AGVector3(p[0],1)).dim2();
-  p[1]=(m*AGVector3(p[1],1)).dim2();
-  p[2]=(m*AGVector3(p[2],1)).dim2();
-}
+  {
+    p[0]=(m*AGVector3(p[0],1)).dim2();
+    p[1]=(m*AGVector3(p[1],1)).dim2();
+    p[2]=(m*AGVector3(p[2],1)).dim2();
+  }
 
 /* FIXME: this will be some sweep-base collision detection,
    HOWEVER there's the angular-velocity still missing :-(
@@ -847,27 +847,27 @@
       float min1,min2,max1,max2;
       size_t j;
       for(j=0;j&lt;3;j++)
-	{
-	  if(j==0)
-	    {
-	      min1=max1=(*i)*p[j];
-	      min2=max2=(*i)*t.p[j];
-	    }
-	  else
-	    {
-	      float v0=(*i)*p[j];
-	      float v1=(*i)*t.p[j];
-	      min1=std::min(min1,v0);
-	      max1=std::max(max1,v0);
-	      min2=std::min(min2,v1);
-	      max2=std::max(max2,v1);
-	    }
-	}
+      {
+        if(j==0)
+          {
+            min1=max1=(*i)*p[j];
+            min2=max2=(*i)*t.p[j];
+          }
+        else
+          {
+            float v0=(*i)*p[j];
+            float v1=(*i)*t.p[j];
+            min1=std::min(min1,v0);
+            max1=std::max(max1,v0);
+            min2=std::min(min2,v1);
+            max2=std::max(max2,v1);
+          }
+      }
       
       float a1=
     }
 }
-*/
+ */
 
 std::vector&lt;AGVector2&gt; AGTriangle2::collisionPoints(const AGLine2 &amp;l) const
 {
@@ -880,7 +880,7 @@
     {
       p=i-&gt;collisionPoint(l);
       if(p!=invalidVec2)
-	ps.push_back(p);
+        ps.push_back(p);
     }
   return ps;
 }
@@ -888,8 +888,8 @@
 AGTriangle2 AGTriangle2::applied(const AGMatrix3 &amp;m) const
 {
   return AGTriangle2((m*AGVector3(p[0],1)).dim2(),
-		     (m*AGVector3(p[1],1)).dim2(),
-		     (m*AGVector3(p[2],1)).dim2());
+      (m*AGVector3(p[1],1)).dim2(),
+      (m*AGVector3(p[2],1)).dim2());
 }
 
 AGString AGTriangle2::toString() const
@@ -921,24 +921,24 @@
       float min1,min2,max1,max2;
       size_t j;
       for(j=0;j&lt;3;j++)
-	{
-	  if(j==0)
-	    {
-	      min1=max1=(*i)*p[j];
-	      min2=max2=(*i)*t.p[j];
-	    }
-	  else
-	    {
-	      float v0=(*i)*p[j];
-	      float v1=(*i)*t.p[j];
-	      min1=std::min(min1,v0);
-	      max1=std::max(max1,v0);
-	      min2=std::min(min2,v1);
-	      max2=std::max(max2,v1);
-	    }
-	}
+        {
+          if(j==0)
+            {
+              min1=max1=(*i)*p[j];
+              min2=max2=(*i)*t.p[j];
+            }
+          else
+            {
+              float v0=(*i)*p[j];
+              float v1=(*i)*t.p[j];
+              min1=std::min(min1,v0);
+              max1=std::max(max1,v0);
+              min2=std::min(min2,v1);
+              max2=std::max(max2,v1);
+            }
+        }
       if(!collide1d(min1,max1,min2,max2))
-	return false;
+        return false;
     }
   return true;
 }
@@ -968,7 +968,7 @@
   if(AGsign((pp-p[0])*l[0])==AGsign((p[2]-p[0])*l[0]))
     if(AGsign((pp-p[1])*l[1])==AGsign((p[0]-p[1])*l[1]))
       if(AGsign((pp-p[2])*l[2])==AGsign((p[1]-p[2])*l[2]))
-	return true;
+        return true;
   return false;
 }
 
@@ -980,9 +980,9 @@
   for(i=0;i&lt;3;i++)
     {
       if(contains(t[i]))
-	return t[i];
+        return t[i];
       else if(t.contains((*this)[i]))
-	return (*this)[i];
+        return (*this)[i];
     }
   return invalidVec2;
 }
@@ -1002,34 +1002,34 @@
   for(i=l0.begin();i!=l0.end();i++)
     for(j=l1.begin();j!=l1.end();j++)
       {
-	if(i-&gt;collide(*j))
-	  {
-	    sum[&amp;(*i)]++;
-	    sum[&amp;(*j)]++;
-	  }
+        if(i-&gt;collide(*j))
+          {
+            sum[&amp;(*i)]++;
+            sum[&amp;(*j)]++;
+          }
       }
   std::map&lt;AGLine2*,int&gt;::iterator k=sum.begin();
   for(;k!=sum.end();k++)
     {
       if(k-&gt;second==2)
-	return k-&gt;first-&gt;normal();
+        return k-&gt;first-&gt;normal();
     }
 
   // FIXME: not found - find other approximation
 
   //#else
-  {
-  size_t i;
-  for(i=0;i&lt;3;i++)
     {
-      if(contains(t[i]))
-	return nearestLine(t[i]).normal();
-      else if(t.contains((*this)[i]))
-	return t.nearestLine((*this)[i]).normal();
+      size_t i;
+      for(i=0;i&lt;3;i++)
+        {
+          if(contains(t[i]))
+            return nearestLine(t[i]).normal();
+          else if(t.contains((*this)[i]))
+            return t.nearestLine((*this)[i]).normal();
+        }
+      return invalidVec2;
     }
-  return invalidVec2;
-  }
-  //#endif
+    //#endif
 }
 
 AGLine2 AGTriangle2::nearestLine(const AGVector2 &amp;v) const
@@ -1113,11 +1113,11 @@
 // AGTriangle3
 /////////////////////////////////////////////////////////////////////////////
 AGTriangle3::AGTriangle3(const AGVector3 &amp;v0,const AGVector3 &amp;v1,const AGVector3 &amp;v2)
-{
-  p[0]=v0;
-  p[1]=v1;
-  p[2]=v2;
-}
+  {
+    p[0]=v0;
+    p[1]=v1;
+    p[2]=v2;
+  }
 
 AGVector4 AGTriangle3::collide(const AGLine3 &amp;pLine) const
 {
@@ -1188,52 +1188,52 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGRect2::AGRect2(const SDL_Rect &amp;r)
-{
-  v0=AGVector2(r.x,r.y);
-  v1=AGVector2(r.x+r.w,r.y+r.h);
-}
+  {
+    v0=AGVector2(r.x,r.y);
+    v1=AGVector2(r.x+r.w,r.y+r.h);
+  }
 
 
 AGRect2::AGRect2(const AGString &amp;ps)
-{
-  std::istringstream is;
-  char c;
-  float x,y,w,h;
-  is.str(ps);
-  is&gt;&gt;c;
-  is&gt;&gt;x;
-  is&gt;&gt;c;
-  is&gt;&gt;y;
-  is&gt;&gt;c;
-  is&gt;&gt;w;
-  is&gt;&gt;c;
-  is&gt;&gt;h;
-  is&gt;&gt;c;
-  v0=AGVector2(x,y);
-  v1=AGVector2(x+w,y+h);
-}
+  {
+    std::istringstream is;
+    char c;
+    float x,y,w,h;
+    is.str(ps);
+    is&gt;&gt;c;
+    is&gt;&gt;x;
+    is&gt;&gt;c;
+    is&gt;&gt;y;
+    is&gt;&gt;c;
+    is&gt;&gt;w;
+    is&gt;&gt;c;
+    is&gt;&gt;h;
+    is&gt;&gt;c;
+    v0=AGVector2(x,y);
+    v1=AGVector2(x+w,y+h);
+  }
 
 
 AGRect2::AGRect2()
-{
-}
+  {
+  }
 
 AGRect2::AGRect2(const AGVector2 &amp;pv0,const AGVector2 &amp;pv1):
   v0(pv0),v1(pv1)
-{
-}
+  {
+  }
 
 AGRect2::AGRect2(float x,float y,float w,float h):
   v0(x,y),v1(x+w,y+h)
-{
-}
+  {
+  }
 
 AGRect2 AGRect2::alignGrid() const
 {
   return AGRect2((int)x(),
-		 (int)y(),
-		 (int)w(),
-		 (int)h());
+      (int)y(),
+      (int)w(),
+      (int)h());
 }
 
 
@@ -1281,7 +1281,7 @@
     my0=my1;
 
   return AGRect2(AGVector2(mx0,my0),
-		 AGVector2(mx1,my1));
+      AGVector2(mx1,my1));
 }
 
 std::vector&lt;AGRect2&gt; AGRect2::difference(const AGRect2 &amp;r) const
@@ -1290,46 +1290,46 @@
   for(int i=0;i&lt;3;i++)
     for(int j=0;j&lt;3;j++)
       {
-	
-	float nx,ny,nw,nh;
-	
-	switch(i)
-	  {
-	  case 0:
-	    nx=x0();
-	    nw=r.x0()-x0();
-	    break;
-	  case 1:
-	    nx=r.x0();
-	    nw=r.x1()-r.x0();
-	    break;
-	  case 2:
-	    nx=r.x1();
-	    nw=x1()-r.x1();
-	    break;
-	  };
-	switch(j)
-	  {
-	  case 0:
-	    ny=y0();
-	    nh=r.y0()-y0();
-	    break;
-	  case 1:
-	    ny=r.y0();
-	    nh=r.y1()-r.y0();
-	    break;
-	  case 2:
-	    ny=r.y1();
-	    nh=y1()-r.y1();
-	    break;
-	  };
-	if(nw&gt;0 &amp;&amp; nh&gt;0)
-	  {
-	    AGRect2 n=intersect(AGRect2(nx,ny,nw,nh));
-	    if(n.w()&gt;0 &amp;&amp; n.h()&gt;0)
-	      if(!r.contains(n))
-		l.push_back(n);
-	  }
+
+        float nx,ny,nw,nh;
+
+        switch(i)
+        {
+        case 0:
+          nx=x0();
+          nw=r.x0()-x0();
+          break;
+        case 1:
+          nx=r.x0();
+          nw=r.x1()-r.x0();
+          break;
+        case 2:
+          nx=r.x1();
+          nw=x1()-r.x1();
+          break;
+        };
+        switch(j)
+        {
+        case 0:
+          ny=y0();
+          nh=r.y0()-y0();
+          break;
+        case 1:
+          ny=r.y0();
+          nh=r.y1()-r.y0();
+          break;
+        case 2:
+          ny=r.y1();
+          nh=y1()-r.y1();
+          break;
+        };
+        if(nw&gt;0 &amp;&amp; nh&gt;0)
+          {
+            AGRect2 n=intersect(AGRect2(nx,ny,nw,nh));
+            if(n.w()&gt;0 &amp;&amp; n.h()&gt;0)
+              if(!r.contains(n))
+                l.push_back(n);
+          }
       }
   return l;
 }
@@ -1339,27 +1339,27 @@
 AGVector2 AGRect2::operator[](size_t i) const
 {
   switch(i)
-    {
-    case 0:
-      return v0;
-    case 1:
-      return v1;
-    default:
-      throw AGString(&quot;invalid index in AGRect2::operator[]&quot;);
-    }
+  {
+  case 0:
+    return v0;
+  case 1:
+    return v1;
+  default:
+    throw AGString(&quot;invalid index in AGRect2::operator[]&quot;);
+  }
   return v0;
 }
 AGVector2 &amp;AGRect2::operator[](size_t i)
 {
   switch(i)
-    {
-    case 0:
-      return v0;
-    case 1:
-      return v1;
-    default:
-      throw AGString(&quot;invalid index in AGRect2::operator[]&quot;);
-    }
+  {
+  case 0:
+    return v0;
+  case 1:
+    return v1;
+  default:
+    throw AGString(&quot;invalid index in AGRect2::operator[]&quot;);
+  }
   return v0;
 }
 
@@ -1399,15 +1399,15 @@
 }
 
 float AGRect2::setWidth(float w)
-{
-  v1[0]=v0[0]+w;
-  return w;
-}
+  {
+    v1[0]=v0[0]+w;
+    return w;
+  }
 float AGRect2::setHeight(float h)
-{
-  v1[1]=v0[1]+h;
-  return h;
-}
+  {
+    v1[1]=v0[1]+h;
+    return h;
+  }
 
 float AGRect2::x0() const
 {
@@ -1438,12 +1438,12 @@
 
 
 void AGRect2::include(const AGVector2 &amp;v)
-{
-  v0[0]=std::min(v0[0],v[0]);
-  v0[1]=std::min(v0[1],v[1]);
-  v1[0]=std::max(v1[0],v[0]);
-  v1[1]=std::max(v1[1],v[1]);
-}
+  {
+    v0[0]=std::min(v0[0],v[0]);
+    v0[1]=std::min(v0[1],v[1]);
+    v1[0]=std::max(v1[0],v[0]);
+    v1[1]=std::max(v1[1],v[1]);
+  }
 
 
 std::list&lt;AGRect2&gt; AGRect2::split() const
@@ -1494,39 +1494,39 @@
 
 
 void AGRect2::setX(float p)
-{
-  float mw=w();
-  v0.setX(p);
-  v1.setX(p+mw);
-}
+  {
+    float mw=w();
+    v0.setX(p);
+    v1.setX(p+mw);
+  }
 void AGRect2::setY(float p)
-{
-  float mh=h();
-  v0.setY(p);
-  v1.setY(p+mh);
-}
+  {
+    float mh=h();
+    v0.setY(p);
+    v1.setY(p+mh);
+  }
 
 void AGRect2::setLeft(float p)
-{
-  float mw=w();
-  v0.setX(p);
-  v1.setX(p+mw);
-}
+  {
+    float mw=w();
+    v0.setX(p);
+    v1.setX(p+mw);
+  }
 void AGRect2::setTop(float p)
-{
-  float mh=h();
-  v0.setY(p);
-  v1.setY(p+mh);
-}
+  {
+    float mh=h();
+    v0.setY(p);
+    v1.setY(p+mh);
+  }
 
 void AGRect2::setRight(float p)
-{
-  v1.setX(p);
-}
+  {
+    v1.setX(p);
+  }
 void AGRect2::setBottom(float p)
-{
-  v1.setY(p);
-}
+  {
+    v1.setY(p);
+  }
 
 
 
@@ -1585,42 +1585,42 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGLine2::AGLine2()
-{
-}
+  {
+  }
 
 AGLine2::AGLine2(const AGVector2 &amp;pv0,const AGVector2 &amp;pv1):
   v0(pv0),v1(pv1)
-{
-}
+  {
+  }
 
 AGVector2 &amp;AGLine2::operator[](size_t i)
 {
   switch(i)
-    {
-    case 0:
-      return v0;
-    case 1:
-      return v1;
-    default:
-      throw AGString(&quot;wrong index in AGLine::op[]&quot;);
-    }
+  {
+  case 0:
+    return v0;
+  case 1:
+    return v1;
+  default:
+    throw AGString(&quot;wrong index in AGLine::op[]&quot;);
+  }
   return v0;
 }
 AGVector2 AGLine2::operator[](size_t i) const
 {
   switch(i)
-    {
-    case 0:
-      return v0;
-    case 1:
-      return v1;
-    default:
-      throw AGString(&quot;wrong index in AGLine::op[]&quot;);
-    }
+  {
+  case 0:
+    return v0;
+  case 1:
+    return v1;
+  default:
+    throw AGString(&quot;wrong index in AGLine::op[]&quot;);
+  }
   return v0;
 }
 
-  
+
 AGVector2 AGLine2::getV0() const
 {
   return v0;
@@ -1645,19 +1645,19 @@
   ldy = l.v1.getY() - l.v0.getY();
 
   AGVector2 p;
-  
+
   if(dx==0.0f)
     {
       if(ldx==0.0f)
-	return invalidVec2; // invalid
-      
+        return invalidVec2; // invalid
+
       // ldy!=0 !!
       float lm = ldy/ldx;
       float lb = l.v0.getY() - lm * l.v0.getX();
 
       //      cdebug(lm);
       //      cdebug(lb);
-      
+
       assert(lm!=0.0f);
       p=AGVector2(v0.getX(),lm*v0.getX()+lb);
     }
@@ -1674,7 +1674,7 @@
       float lb=l.v0.getY() - lm * l.v0.getX();
 
       if(m == lm)
-	return AGVector2(0,0); // parallel
+        return AGVector2(0,0); // parallel
       float x=(lb-b)/(m-lm); 
       p=AGVector2(x,m*x+b);
     }
@@ -1688,10 +1688,10 @@
   // check for inclusion
   if(includes(p) &amp;&amp; l.includes(p))
     {
-    assert(distance(p)&lt;0.01);
-    assert(l.distance(p)&lt;0.01);
-    return p;
-  }
+      assert(distance(p)&lt;0.01);
+      assert(l.distance(p)&lt;0.01);
+      return p;
+    }
   else
     return invalidVec2;
 }
@@ -1700,12 +1700,12 @@
 {
   float f=(v-v0)*((v1-v0).normalized());
   if(f&gt;=0 &amp;&amp; f&lt;(v1-v0).length())
-  {
-    /*    cdebug(v0.toString()&lt;&lt;&quot;  &quot;&lt;&lt;v1.toString()&lt;&lt;&quot;  &quot;&lt;&lt;v.toString());
+    {
+      /*    cdebug(v0.toString()&lt;&lt;&quot;  &quot;&lt;&lt;v1.toString()&lt;&lt;&quot;  &quot;&lt;&lt;v.toString());
     cdebug((v-v0).toString()&lt;&lt;&quot;   &quot;&lt;&lt;(v1-v0).toString()&lt;&lt;&quot;   &quot;&lt;&lt;(v1-v0).normalized().toString()&lt;&lt;&quot;   &quot;&lt;&lt;(v1-v0).length());
     cdebug(f);*/
-    return true;
-  }
+      return true;
+    }
   return false;
 }
 
@@ -1723,7 +1723,7 @@
   d1=l.direction();
   n0=normal();
   n1=l.normal();
-  
+
   bool t0=collide1d(v0*d0,v1*d0,l.v0*d0,l.v1*d0,false);
   bool t1=collide1d(v0*d1,v1*d1,l.v0*d1,l.v1*d1,false);
 
@@ -1763,13 +1763,13 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGLine3::AGLine3()
-{
-}
+  {
+  }
 
 AGLine3::AGLine3(const AGVector3 &amp;pv0,const AGVector3 &amp;pv1):
   v0(pv0),v1(pv1)
-{
-}
+  {
+  }
 
 float AGLine3::distance(const AGVector3 &amp;p) const
 {
@@ -1781,7 +1781,7 @@
   return fabs(diff*plane_normal);
 }
 
-  
+
 AGVector3 AGLine3::getV0() const
 {
   return v0;
@@ -1822,26 +1822,26 @@
 
 
 AGVector4::AGVector4(float pX,float pY,float pZ,float pW)
-{
-  v[0]=pX;
-  v[1]=pY;
-  v[2]=pZ;
-  v[3]=pW;
-}
+  {
+    v[0]=pX;
+    v[1]=pY;
+    v[2]=pZ;
+    v[3]=pW;
+  }
 AGVector4::AGVector4(const AGVector4 &amp;a)
-{
-  v[0]=a.v[0];
-  v[1]=a.v[1];
-  v[2]=a.v[2];
-  v[3]=a.v[3];
-}
+  {
+    v[0]=a.v[0];
+    v[1]=a.v[1];
+    v[2]=a.v[2];
+    v[3]=a.v[3];
+  }
 AGVector4::AGVector4(const AGVector3 &amp;a,float h)
-{
-  v[0]=a.v[0];
-  v[1]=a.v[1];
-  v[2]=a.v[2];
-  v[3]=h;
-}
+  {
+    v[0]=a.v[0];
+    v[1]=a.v[1];
+    v[2]=a.v[2];
+    v[3]=h;
+  }
 
 AGVector3 AGVector4::dim3() const
 {
@@ -1854,10 +1854,10 @@
 
 
 AGVector4::AGVector4()
-{
-  v[0]=v[1]=v[2]=0.0f;
-  v[3]=1.0f;
-}
+  {
+    v[0]=v[1]=v[2]=0.0f;
+    v[3]=1.0f;
+  }
 
 AGVector4 AGVector4::operator-() const
 {
@@ -1866,21 +1866,21 @@
 
 
 void AGVector4::setX(float pX)
-{
-  v[0]=pX;
-}
+  {
+    v[0]=pX;
+  }
 void AGVector4::setY(float pY)
-{
-  v[1]=pY;
-}
+  {
+    v[1]=pY;
+  }
 void AGVector4::setZ(float pZ)
-{
-  v[2]=pZ;
-}
+  {
+    v[2]=pZ;
+  }
 void AGVector4::setW(float pW)
-{
-  v[3]=pW;
-}
+  {
+    v[3]=pW;
+  }
 
 float AGVector4::getX() const
 {
@@ -1902,16 +1902,16 @@
 AGVector4 AGVector4::operator-(const AGVector4 &amp;p) const
 {
   return AGVector4(v[0]-p.v[0],
-		   v[1]-p.v[1],
-		   v[2]-p.v[2],
-		   v[3]-p.v[3]);
+      v[1]-p.v[1],
+      v[2]-p.v[2],
+      v[3]-p.v[3]);
 }
 AGVector4 AGVector4::operator+(const AGVector4 &amp;p) const
 {
   return AGVector4(v[0]+p.v[0],
-		   v[1]+p.v[1],
-		   v[2]+p.v[2],
-		   v[3]+p.v[3]);
+      v[1]+p.v[1],
+      v[2]+p.v[2],
+      v[3]+p.v[3]);
 }
 AGVector4 &amp;AGVector4::operator+=(const AGVector4 &amp;p)
 {
@@ -1933,9 +1933,9 @@
 float AGVector4::operator*(const AGVector4 &amp;p) const
 {
   return v[0]*p.v[0]+
-    v[1]*p.v[1]+
-    v[2]*p.v[2]+
-    v[3]*p.v[3];
+  v[1]*p.v[1]+
+  v[2]*p.v[2]+
+  v[3]*p.v[3];
 }
 AGVector4 &amp;AGVector4::operator*=(float f)
 {
@@ -1965,9 +1965,9 @@
 bool AGVector4::operator==(const AGVector4 &amp;a) const
 {
   return v[0]==a.v[0] &amp;&amp;
-    v[1]==a.v[1] &amp;&amp;
-    v[2]==a.v[2] &amp;&amp;
-    v[3]==a.v[3];
+  v[1]==a.v[1] &amp;&amp;
+  v[2]==a.v[2] &amp;&amp;
+  v[3]==a.v[3];
 }
 bool AGVector4::operator!=(const AGVector4 &amp;a) const
 {
@@ -1981,9 +1981,9 @@
 float AGVector4::length2() const
 {
   return v[0]*v[0]+
-    v[1]*v[1]+
-    v[2]*v[2]+
-    v[3]*v[3];
+  v[1]*v[1]+
+  v[2]*v[2]+
+  v[3]*v[3];
 }
 
 float AGVector4::length3() const
@@ -1996,18 +1996,18 @@
   return *this*(1.0f/length());
 }
 void AGVector4::normalize()
-{
-  operator*=(1.0f/length());
-}
+  {
+    operator*=(1.0f/length());
+  }
 
 AGVector4 AGVector4::normalized3() const
 {
   return *this*(1.0f/length3());
 }
 void AGVector4::normalize3()
-{
-  operator*=(1.0f/length3());
-}
+  {
+    operator*=(1.0f/length3());
+  }
 
 float &amp;AGVector4::operator[](int index)
 {
@@ -2024,9 +2024,9 @@
 bool AGVector4::nonZero() const
 {
   return v[0]!=0 ||
-    v[1]!=0 ||
-    v[2]!=0 ||
-    v[3]!=0;
+  v[1]!=0 ||
+  v[2]!=0 ||
+  v[3]!=0;
 }
 
 AGString AGVector4::toString() const
@@ -2049,8 +2049,8 @@
 AGVector4 AGVector4::operator%(const AGVector4 &amp;a) const
 {
   return AGVector4(v[1] * a.v[2] - v[2] * a.v[1],
-		   v[2] * a.v[0] - v[0] * a.v[2],
-		   v[0] * a.v[1] - v[1] * a.v[0]);
+      v[2] * a.v[0] - v[0] * a.v[2],
+      v[0] * a.v[1] - v[1] * a.v[0]);
 }
 
 ///////////////////////////////////////////////////////////////
@@ -2058,15 +2058,15 @@
 ///////////////////////////////////////////////////////////////
 
 AGMatrix4::AGMatrix4(float v[16])
-{
-  for(size_t i=0;i&lt;16;i++)
-    a[i]=v[i];
-}
+  {
+    for(size_t i=0;i&lt;16;i++)
+      a[i]=v[i];
+  }
 AGMatrix4::AGMatrix4(float angle,const AGVector3&amp;d)
-{
-  float co=cos(angle);
-  float si=sin(angle);
-  /*
+  {
+    float co=cos(angle);
+    float si=sin(angle);
+    /*
   set(0,0,co + d[0]*d[0]*(1-co));
   set(0,1,d[0]*d[1]*(1-co)-d[2]*si);
   set(0,2,d[0]*d[2]*(1-co)+d[1]*si);
@@ -2078,40 +2078,40 @@
   set(2,0,d[2]*d[0]*(1-co)-d[1]*si);
   set(2,1,d[2]*d[1]*(1-co)+d[0]*si);
   set(2,2,co + d[2]*d[2]*(1-co));
-  */
+     */
     set(0,0,co + d[0]*d[0]*(1-co));
-  set(1,0,d[0]*d[1]*(1-co)-d[2]*si);
-  set(2,0,d[0]*d[2]*(1-co)+d[1]*si);
+    set(1,0,d[0]*d[1]*(1-co)-d[2]*si);
+    set(2,0,d[0]*d[2]*(1-co)+d[1]*si);
 
-  set(0,1,d[1]*d[0]*(1-co)+d[2]*si);
-  set(1,1,co+d[1]*d[1]*(1-co));
-  set(2,1,d[1]*d[2]*(1-co)-d[0]*si);
+    set(0,1,d[1]*d[0]*(1-co)+d[2]*si);
+    set(1,1,co+d[1]*d[1]*(1-co));
+    set(2,1,d[1]*d[2]*(1-co)-d[0]*si);
 
-  set(0,2,d[2]*d[0]*(1-co)-d[1]*si);
-  set(1,2,d[2]*d[1]*(1-co)+d[0]*si);
-  set(2,2,co + d[2]*d[2]*(1-co));
-  
-  set(3,0,0);
-  set(3,1,0);
-  set(3,2,0);
+    set(0,2,d[2]*d[0]*(1-co)-d[1]*si);
+    set(1,2,d[2]*d[1]*(1-co)+d[0]*si);
+    set(2,2,co + d[2]*d[2]*(1-co));
 
-  set(0,3,0);
-  set(1,3,0);
-  set(2,3,0);
+    set(3,0,0);
+    set(3,1,0);
+    set(3,2,0);
 
-  set(3,3,1);
-}
+    set(0,3,0);
+    set(1,3,0);
+    set(2,3,0);
 
+    set(3,3,1);
+  }
 
+
 AGMatrix4::AGMatrix4()
-{
-  get(0,1)=get(0,2)=get(0,3)=
-    get(1,0)=get(1,2)=get(1,3)=
-    get(2,0)=get(2,1)=get(2,3)=
-    get(3,0)=get(3,1)=get(3,2)=0.0f;
+  {
+    get(0,1)=get(0,2)=get(0,3)=
+      get(1,0)=get(1,2)=get(1,3)=
+        get(2,0)=get(2,1)=get(2,3)=
+          get(3,0)=get(3,1)=get(3,2)=0.0f;
 
-  get(0,0)=get(1,1)=get(2,2)=get(3,3)=1.0f;
-}
+    get(0,0)=get(1,1)=get(2,2)=get(3,3)=1.0f;
+  }
 
 /*AGMatrix3::AGMatrix4(const AGAngle &amp;n)
 {
@@ -2124,15 +2124,15 @@
   }*/
 
 AGMatrix4::AGMatrix4(const AGVector4 &amp;n)
-{
-  get(0,0)=get(1,1)=get(2,2)=get(3,3)=1.0f;
-  get(0,1)=get(0,2)=get(0,3)=
-    get(1,0)=get(1,2)=get(1,3)=
-    get(2,0)=get(2,1)=get(2,3)=0.0f;
-  get(3,0)=n[0];
-  get(3,1)=n[1];
-  get(3,2)=n[2];
-}
+  {
+    get(0,0)=get(1,1)=get(2,2)=get(3,3)=1.0f;
+    get(0,1)=get(0,2)=get(0,3)=
+      get(1,0)=get(1,2)=get(1,3)=
+        get(2,0)=get(2,1)=get(2,3)=0.0f;
+    get(3,0)=n[0];
+    get(3,1)=n[1];
+    get(3,2)=n[2];
+  }
 
 AGMatrix4 &amp;AGMatrix4::operator+=(const AGMatrix4 &amp;m)
 {
@@ -2164,32 +2164,32 @@
 }
 
 void AGMatrix4::swapRows(size_t a,size_t b)
-{
-  if(a==b)
-    return;
-  assert(a&lt;4);
-  assert(b&lt;4);
-  for(size_t x=0;x&lt;4;x++)
-    {
-      float t=get(x,a);
-      set(x,a,get(x,b));
-      set(x,b,t);
-    }
-}
+  {
+    if(a==b)
+      return;
+    assert(a&lt;4);
+    assert(b&lt;4);
+    for(size_t x=0;x&lt;4;x++)
+      {
+        float t=get(x,a);
+        set(x,a,get(x,b));
+        set(x,b,t);
+      }
+  }
 
 void AGMatrix4::swapCols(size_t a,size_t b)
-{
-  if(a==b)
-    return;
-  assert(a&lt;4);
-  assert(b&lt;4);
-  for(size_t y=0;y&lt;4;y++)
-    {
-      float t=get(a,y);
-      set(a,y,get(b,y));
-      set(b,y,t);
-    }
-}
+  {
+    if(a==b)
+      return;
+    assert(a&lt;4);
+    assert(b&lt;4);
+    for(size_t y=0;y&lt;4;y++)
+      {
+        float t=get(a,y);
+        set(a,y,get(b,y));
+        set(b,y,t);
+      }
+  }
 
 
 AGMatrix3 AGMatrix4::get3x3(size_t x,size_t y) const
@@ -2205,11 +2205,11 @@
 
 
 void AGMatrix4::set(size_t x,size_t y,float f)
-{
-  assert(x&gt;=0 &amp;&amp; x&lt;4);
-  assert(y&gt;=0 &amp;&amp; y&lt;4);
-  a[x*4+y]=f;
-}
+  {
+    assert(x&gt;=0 &amp;&amp; x&lt;4);
+    assert(y&gt;=0 &amp;&amp; y&lt;4);
+    a[x*4+y]=f;
+  }
 float AGMatrix4::get(size_t x,size_t y) const
 {
   assert(x&gt;=0 &amp;&amp; x&lt;4);
@@ -2218,11 +2218,11 @@
 }
 
 float &amp;AGMatrix4::get(size_t x,size_t y)
-{
-  assert(x&gt;=0 &amp;&amp; x&lt;4);
-  assert(y&gt;=0 &amp;&amp; y&lt;4);
-  return a[4*x+y];
-}
+  {
+    assert(x&gt;=0 &amp;&amp; x&lt;4);
+    assert(y&gt;=0 &amp;&amp; y&lt;4);
+    return a[4*x+y];
+  }
 
 AGMatrix4 AGMatrix4::operator*(const AGMatrix4 &amp;m) const
 {
@@ -2231,9 +2231,9 @@
   for(x=0;x&lt;4;x++)
     for(y=0;y&lt;4;y++)
       n(x,y)=get(0,y)*m(x,0)+
-	get(1,y)*m(x,1)+
-	get(2,y)*m(x,2)+
-	get(3,y)*m(x,3);
+      get(1,y)*m(x,1)+
+      get(2,y)*m(x,2)+
+      get(3,y)*m(x,3);
   return n;
 }
 AGMatrix4 &amp;AGMatrix4::operator*=(const AGMatrix4 &amp;m)
@@ -2245,9 +2245,9 @@
 AGVector4 AGMatrix4::operator*(const AGVector4 &amp;v) const
 {
   return AGVector4(get(0,0)*v[0]+get(1,0)*v[1]+get(2,0)*v[2]+get(3,0)*v[3],
-		   get(0,1)*v[0]+get(1,1)*v[1]+get(2,1)*v[2]+get(3,1)*v[3],
-		   get(0,2)*v[0]+get(1,2)*v[1]+get(2,2)*v[2]+get(3,2)*v[3],
-		   get(0,3)*v[0]+get(1,3)*v[1]+get(2,3)*v[2]+get(3,3)*v[3]);
+      get(0,1)*v[0]+get(1,1)*v[1]+get(2,1)*v[2]+get(3,1)*v[3],
+      get(0,2)*v[0]+get(1,2)*v[1]+get(2,2)*v[2]+get(3,2)*v[3],
+      get(0,3)*v[0]+get(1,3)*v[1]+get(2,3)*v[2]+get(3,3)*v[3]);
 }
 
 AGString AGMatrix4::toString() const
@@ -2318,16 +2318,16 @@
 
 AGBox3::AGBox3(const AGVector3 &amp;pBase,const AGVector3 &amp;pDir):
   base(pBase),dir(pDir)
-{
-  // assert that pDir[i]&gt;0
-  for(size_t i=0;i&lt;3;i++)
-    if(dir[i]&lt;0)
-      {
-	base[i]+=dir[i];
-	dir[i]=-dir[i];
-      }
-  mValid=true;
-}
+  {
+    // assert that pDir[i]&gt;0
+    for(size_t i=0;i&lt;3;i++)
+      if(dir[i]&lt;0)
+        {
+          base[i]+=dir[i];
+          dir[i]=-dir[i];
+        }
+    mValid=true;
+  }
 
 
 
@@ -2356,9 +2356,9 @@
       AGVector4 p(frustum*AGVector4(*i,1));
       p/=p[3];
       if(p[0]&gt;=-1 &amp;&amp; p[0]&lt;=1 &amp;&amp;
-	 p[1]&gt;=-1 &amp;&amp; p[1]&lt;=1 &amp;&amp;
-	 p[2]&gt;=-1 &amp;&amp; p[2]&lt;=1)
-	return true;
+          p[1]&gt;=-1 &amp;&amp; p[1]&lt;=1 &amp;&amp;
+          p[2]&gt;=-1 &amp;&amp; p[2]&lt;=1)
+        return true;
 
       minx=std::min(minx,p[0]);
       miny=std::min(miny,p[1]);
@@ -2367,7 +2367,7 @@
       maxx=std::max(maxx,p[0]);
       maxy=std::max(maxy,p[1]);
       maxz=std::max(maxz,p[2]);
-	
+
     }
 
   return AGBox3(AGVector3(-1,-1,-1),AGVector3(2,2,2)).collides(AGBox3(AGVector3(minx,miny,minz),AGVector3(maxx-minx,maxy-miny,maxz-minz)));
@@ -2384,11 +2384,11 @@
   cdebug(collide1d(base[0],a[0],box.base[0],b[0]));
   cdebug(collide1d(base[1],a[1],box.base[1],b[1]));
   cdebug(collide1d(base[2],a[2],box.base[2],b[2]));
-  */
+   */
 
   return collide1d(base[0],a[0],box.base[0],b[0]) &amp;&amp;
-    collide1d(base[1],a[1],box.base[1],b[1]) &amp;&amp;
-    collide1d(base[2],a[2],box.base[2],b[2]);
+  collide1d(base[1],a[1],box.base[1],b[1]) &amp;&amp;
+  collide1d(base[2],a[2],box.base[2],b[2]);
 }
 
 
@@ -2426,32 +2426,32 @@
 
 
 void AGBox3::include(const AGVector3&amp;p)
-{
-  if(!mValid)
-    {
-      base=p;
-      dir=AGVector3(0,0,0);
-      mValid=true;
-      return;
-    }
-  AGVector3 b=base,b2=base+dir;
+  {
+    if(!mValid)
+      {
+        base=p;
+        dir=AGVector3(0,0,0);
+        mValid=true;
+        return;
+      }
+    AGVector3 b=base,b2=base+dir;
 
-  base[0]=std::min(b[0],p[0]);
-  base[1]=std::min(b[1],p[1]);
-  base[2]=std::min(b[2],p[2]);
-  AGVector3 n;
-  n[0]=std::max(b2[0],p[0]);
-  n[1]=std::max(b2[1],p[1]);
-  n[2]=std::max(b2[2],p[2]);
-  dir[0]=n[0]-base[0];
-  dir[1]=n[1]-base[1];
-  dir[2]=n[2]-base[2];
-}
+    base[0]=std::min(b[0],p[0]);
+    base[1]=std::min(b[1],p[1]);
+    base[2]=std::min(b[2],p[2]);
+    AGVector3 n;
+    n[0]=std::max(b2[0],p[0]);
+    n[1]=std::max(b2[1],p[1]);
+    n[2]=std::max(b2[2],p[2]);
+    dir[0]=n[0]-base[0];
+    dir[1]=n[1]-base[1];
+    dir[2]=n[2]-base[2];
+  }
 
 bool AGBox3::collides(const AGVector3&amp;p) const
 {
   return p[0]&gt;=base[0] &amp;&amp; p[1]&gt;=base[1] &amp;&amp; p[2]&gt;=base[2] &amp;&amp;
-    p[0]&lt;base[0]+dir[0] &amp;&amp; p[1]&lt;base[1]+dir[1] &amp;&amp; p[2]&lt;base[2]+dir[2];
+  p[0]&lt;base[0]+dir[0] &amp;&amp; p[1]&lt;base[1]+dir[1] &amp;&amp; p[2]&lt;base[2]+dir[2];
 }
 bool AGBox3::collides(const AGLine3&amp;p) const
 {
@@ -2461,7 +2461,7 @@
   for(std::vector&lt;AGRect3&gt;::iterator i=sides.begin();i!=sides.end();++i)
     {
       if((*i).collides(p))
-	return true;
+        return true;
     }
   return false;
 }
@@ -2489,12 +2489,12 @@
 }
 
 bool AGBox3::includes(const AGBox3 &amp;b)
-{
-  AGVector3 u0=base+dir;
-  AGVector3 u1=b.base+b.dir;
-  return (b.base[0]&gt;=base[0] &amp;&amp; b.base[1]&gt;=base[1] &amp;&amp; b.base[2]&gt;=base[2] &amp;&amp;
-	  u1[0]&lt;=u0[0] &amp;&amp; u1[1]&lt;=u0[1] &amp;&amp; u1[2]&lt;=u0[2]);
-}
+  {
+    AGVector3 u0=base+dir;
+    AGVector3 u1=b.base+b.dir;
+    return (b.base[0]&gt;=base[0] &amp;&amp; b.base[1]&gt;=base[1] &amp;&amp; b.base[2]&gt;=base[2] &amp;&amp;
+        u1[0]&lt;=u0[0] &amp;&amp; u1[1]&lt;=u0[1] &amp;&amp; u1[2]&lt;=u0[2]);
+  }
 
 AGString AGBox3::toString() const
 {
@@ -2527,15 +2527,15 @@
 
 AGRect3::AGRect3(const AGVector3 &amp;pBase,const AGVector3 &amp;pDir):
   base(pBase),dir(pDir)
-{
-  // assert that dir[i]&gt;=0
-  for(size_t i=0;i&lt;3;i++)
-    if(dir[i]&lt;0)
-      {
-	base[i]+=dir[i];
-	dir[i]=-dir[i];
-      }
-}
+  {
+    // assert that dir[i]&gt;=0
+    for(size_t i=0;i&lt;3;i++)
+      if(dir[i]&lt;0)
+        {
+          base[i]+=dir[i];
+          dir[i]=-dir[i];
+        }
+  }
 
 bool AGRect3::collides(const AGLine3&amp;pLine) const
 {
@@ -2569,16 +2569,15 @@
 
   //  cdebug(&quot;ip:&quot;&lt;&lt;ip.toString());
   //  cdebug(&quot;dist:&quot;&lt;&lt;(ip-base)*normal);
-  
+
   for(size_t i=0;i&lt;3;i++)
     {
       if(fabs(dir[i])&lt;0.0001)
-	continue;
+        continue;
       if(ip[i]&lt;base[i] || ip[i]&gt;base[i]+dir[i])
-	{
-	  //	  cdebug(&quot;fail:&quot;&lt;&lt;i);
-	  return false;
-	}
+        {
+          return false;
+        }
     }
   return true;
 }
@@ -2594,31 +2593,31 @@
 
 
 std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGVector2&amp;v)
-{
-  o&lt;&lt;v.toString();
-  return o;
-}
+  {
+    o&lt;&lt;v.toString();
+    return o;
+  }
 
 std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGVector3&amp;v)
-{
-  o&lt;&lt;v.toString();
-  return o;
-}
+  {
+    o&lt;&lt;v.toString();
+    return o;
+  }
 
 std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGVector4&amp;v)
-{
-  o&lt;&lt;v.toString();
-  return o;
-}
+  {
+    o&lt;&lt;v.toString();
+    return o;
+  }
 
 std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGRect2&amp;v)
-{
-  o&lt;&lt;v.toString();
-  return o;
-}
+  {
+    o&lt;&lt;v.toString();
+    return o;
+  }
 
 std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGBox3&amp;v)
-{
-  o&lt;&lt;&quot;(&quot;&lt;&lt;v.base&lt;&lt;&quot; &quot;&lt;&lt;v.dir&lt;&lt;&quot;/&quot;&lt;&lt;v.valid()&lt;&lt;&quot;)&quot;;
-  return o;
-}
+  {
+    o&lt;&lt;&quot;(&quot;&lt;&lt;v.base&lt;&lt;&quot; &quot;&lt;&lt;v.dir&lt;&lt;&quot;/&quot;&lt;&lt;v.valid()&lt;&lt;&quot;)&quot;;
+    return o;
+  }

Modified: antargis/trunk/ext/basic/ag_geometry.h
===================================================================
--- antargis/trunk/ext/basic/ag_geometry.h	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_geometry.h	2008-02-24 19:05:29 UTC (rev 1230)
@@ -697,11 +697,13 @@
   bool mValid;
 };
 
+#ifndef SWIG
 AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGVector2&amp;v);
 AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGVector3&amp;v);
 AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGVector4&amp;v);
 AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGRect2&amp;v);
 AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGBox3&amp;v);
+#endif
 
 #include &quot;ag_geometry_inline.cc&quot;
 

Modified: antargis/trunk/ext/basic/ag_kill.cc
===================================================================
--- antargis/trunk/ext/basic/ag_kill.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_kill.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -18,6 +18,9 @@
  * License along with this program.
  */
 
+
+// TODO: Is this still used ? 
+
 #include &quot;ag_kill.h&quot;
 #include &quot;ag_debug.h&quot;
 
@@ -25,42 +28,42 @@
 bool mIndirectInstance=false;
 
 void newInstanceKiller()
-{
-  assert(mInstanceKiller==0 || mIndirectInstance);
-  mInstanceKiller=new AGInstanceKiller;
-}
+  {
+    assert(mInstanceKiller==0 || mIndirectInstance);
+    mInstanceKiller=new AGInstanceKiller;
+  }
 void deleteInstanceKiller()
-{
-  assert(mInstanceKiller);
-  delete mInstanceKiller;
-}
+  {
+    assert(mInstanceKiller);
+    delete mInstanceKiller;
+  }
 
 AGInstanceKiller *getInstanceKiller()
-{
-  if(!mInstanceKiller)
-    {
-      mIndirectInstance=true;
-      newInstanceKiller();
-    }
-  assert(mInstanceKiller);
-  return mInstanceKiller;
-}
+  {
+    if(!mInstanceKiller)
+      {
+        mIndirectInstance=true;
+        newInstanceKiller();
+      }
+    assert(mInstanceKiller);
+    return mInstanceKiller;
+  }
 
 
 AGInstanceKiller::AGInstanceKiller()
-    {
-    }
+  {
+  }
 AGInstanceKiller::~AGInstanceKiller()
-    {
-      CTRACE;
-      std::set&lt;AGInstanceBase*&gt;::iterator i=bs.begin();
-      for(;i!=bs.end();i++)
-	{
-	  (*i)-&gt;kill();
-	  delete *i;
-	}
-      
-    }
+  {
+    CTRACE;
+    std::set&lt;AGInstanceBase*&gt;::iterator i=bs.begin();
+    for(;i!=bs.end();i++)
+      {
+        (*i)-&gt;kill();
+        delete *i;
+      }
+
+  }
 void AGInstanceKiller::reg(AGInstanceBase *b)
   {
     bs.insert(b);

Added: antargis/trunk/ext/basic/ag_message.h
===================================================================
--- antargis/trunk/ext/basic/ag_message.h	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_message.h	2008-02-24 19:05:29 UTC (rev 1230)
@@ -0,0 +1,46 @@
+#ifndef AG_MESSAGE_H_
+#define AG_MESSAGE_H_
+
+#include &lt;ag_string.h&gt;
+#include &lt;map&gt;
+
+class AGMessageSender
+{
+  
+};
+
+class AGMessageReceiver
+{
+  
+};
+
+class AGMessageTransceiver
+{
+  
+};
+
+class AGMessageSource
+{
+  AGMessageSender *mSender;
+  AGString mName;
+public:
+};
+
+class AGMessage
+{
+  AGMessageSource *mSource;
+public:
+  AGMessage(const AGMessageSource *pSource);
+};
+
+class AGMessageQueue
+{
+  std::map&lt;AGMessageSource,std::list&lt;AGMessageReceiver*&gt; &gt; connects;
+public:
+  void connect(const AGMessageSource &amp;pSource,const AGMessageReceiver *pReceiver);
+  void distconnect(const AGMessageSource &amp;pSource,const AGMessageReceiver *pReceiver);
+  
+  void send(const AGMessage &amp;pMessage);
+};
+
+#endif /*AG_MESSAGE_H_*/

Modified: antargis/trunk/ext/basic/ag_rubyobj.cc
===================================================================
--- antargis/trunk/ext/basic/ag_rubyobj.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_rubyobj.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -16,103 +16,116 @@
 
 std::set&lt;AGRubyObject*&gt; gExistingRubies;
 
+AGEXPORT void *getAddressOfRubyObject(AGRubyObject *o)
+  {
+    return o;
+  }
+
+AGEXPORT bool rubyObjectExists(void *po)
+  {
+    AGRubyObject *o=reinterpret_cast&lt;AGRubyObject*&gt;(po);
+    return gExistingRubies.find(o)!=gExistingRubies.end();
+  }
+
 AGRubyObject::AGRubyObject()
-{
-  mRubyObject=false;
-  mDeleted=false;
-  gExistingRubies.insert(this);
-  mRUBY=0;
+  {
+    mRubyObject=false;
+    mDeleted=false;
+    gExistingRubies.insert(this);
+    mRUBY=0;
 #ifdef GCDEBUG
-  printf(&quot;NEW ME:%lx\n&quot;,this);
+    printf(&quot;NEW ME:%lx\n&quot;,this);
 #endif
-  //  cdebug(&quot;existing rubies:&quot;&lt;&lt;gExistingRubies.size());
-  
-}
+    //  cdebug(&quot;existing rubies:&quot;&lt;&lt;gExistingRubies.size());
+
+  }
 AGRubyObject::~AGRubyObject()
-{
-  for(std::set&lt;AGBaseObject*&gt;::iterator i=mReferences.begin();i!=mReferences.end();i++)
-    (*i)-&gt;baseClear();
+  {
+    for(std::set&lt;AGBaseObject*&gt;::iterator i=mReferences.begin();i!=mReferences.end();i++)
+      (*i)-&gt;baseClear();
 
 
-  //  cdebug(&quot;DEL:&quot;&lt;&lt;mRUBY);
+    //  cdebug(&quot;DEL:&quot;&lt;&lt;mRUBY);
 #ifdef GCDEBUG
-  printf(&quot;DEL:%lx  %s (me:%lx)\n&quot;,mRUBY,mObjName.c_str(),this);
+    printf(&quot;DEL:%lx  %s (me:%lx)\n&quot;,mRUBY,mObjName.c_str(),this);
 #endif
-  mDeleted=true;
-  gExistingRubies.erase(this);
-  //  cdebug(&quot;existing rubies:&quot;&lt;&lt;gExistingRubies.size());
-  //  cdebug(&quot;DEL:&quot;&lt;&lt;mRUBY);
-}
+    mDeleted=true;
+    gExistingRubies.erase(this);
+    //  cdebug(&quot;existing rubies:&quot;&lt;&lt;gExistingRubies.size());
+    //  cdebug(&quot;DEL:&quot;&lt;&lt;mRUBY);
+  }
 
 
 /// override this function to mark your children
 void AGRubyObject::mark()
-{
-}
+  {
+  }
 
 // call this function with any object you want to mark.
 void AGRubyObject::markObject(AGRubyObject *o, bool recursive)
-{
-  assert(o);
+  {
+ //   CTRACE;
+    assert(o);
+//    cdebug(&quot;o:&quot;&lt;&lt;o);
 
 #ifdef GCDEBUG
-	printf(&quot;marking : %lx\n&quot;,o);
-  assert(gExistingRubies.find(o)!=gExistingRubies.end());
+    printf(&quot;marking : %lx\n&quot;,o);
+    assert(gExistingRubies.find(o)!=gExistingRubies.end());
 #endif
 
-  if(o-&gt;mRubyObject)
-    {
+    if(o-&gt;mRubyObject)
+      {
 #ifdef GCDEBUG
-			printf(&quot;marking ruby : %lx\n&quot;,o-&gt;mRUBY);
+        printf(&quot;marking ruby : %lx\n&quot;,o-&gt;mRUBY);
 #endif
-      rb_gc_mark(o-&gt;mRUBY);
-    }
-  if(recursive)
-    o-&gt;mark(); // call this directly
+        rb_gc_mark(o-&gt;mRUBY);
+      }
+    if(recursive)
+      o-&gt;mark(); // call this directly
 #ifdef GCDEBUG
-	printf(&quot;endmarking : %lx\n&quot;,o);
+    printf(&quot;endmarking : %lx\n&quot;,o);
 #endif
-}
+  }
 
 void AGRubyObject::clear()
-{
-  CTRACE;
-}
+  {
+    CTRACE;
+  }
 
 void AGRubyObject::addRef(AGBaseObject *o)
-{
-  mReferences.insert(o);
-}
+  {
+    mReferences.insert(o);
+  }
 
 void AGRubyObject::deleteRef(AGBaseObject *o)
-{
-  mReferences.erase(o);
-}
+  {
+    mReferences.erase(o);
+  }
 
 
 
 /// this is the marking function, that gets called by ruby
 /// it handles all the AGRubyObjects
 void general_markfunc(void *ptr)
-{
-  STACKTRACE;
-  //  TRACE;
-  if(!ptr)
-    {
-      cdebug(&quot;WARNING: a ptr==0 was given in general_markfunc!&quot;);
-      //      throw std::runtime_error(&quot;WARNING: a ptr==0 was given in general_markfunc!&quot;);
-      return; // ignore
-    }
-  assert(ptr);
-  AGRubyObject *o=static_cast&lt;AGRubyObject*&gt;(ptr);
+  {
+    STACKTRACE;
+    //  TRACE;
+    if(!ptr)
+      {
+        cdebug(&quot;WARNING: a ptr==0 was given in general_markfunc!&quot;);
+        //      throw std::runtime_error(&quot;WARNING: a ptr==0 was given in general_markfunc!&quot;);
+        return; // ignore
+      }
+    assert(ptr);
+    AGRubyObject *o=static_cast&lt;AGRubyObject*&gt;(ptr);
 
 #ifdef GCDEBUG
-  printf(&quot;mark: 0x%lx\n&quot;,o-&gt;mRUBY);
+    printf(&quot;mark: 0x%lx\n&quot;,o-&gt;mRUBY);
 #endif
 
-  assert(o);
-  o-&gt;mark();
-}
+    assert(o);
+    o-&gt;mark();
+  }
 
 
 /**
@@ -124,29 +137,29 @@
    1) put all deleted objects in a set
    2) check set before clearing/deleting
    3) clear this set when marking
-*/
+ */
 bool saveDelete(AGRubyObject *o)
-{
-  if(hasQuit())
-    return false; // we are quitting - so memory is discarded anyway - hopefully ;-)
-  
-  assert(o);
-  if(gExistingRubies.find(o)==gExistingRubies.end())
-    {
+  {
+    if(hasQuit())
+      return false; // we are quitting - so memory is discarded anyway - hopefully ;-)
+
+    assert(o);
+    if(gExistingRubies.find(o)==gExistingRubies.end())
+      {
 #ifdef GCDEBUG
-      cdebug(&quot;already deleted!&quot;);
+        cdebug(&quot;already deleted!&quot;);
 #endif
-      return false; // already deleted
-    }
-  assert(!o-&gt;mDeleted);
-  o-&gt;clear();
-  if(!o-&gt;mRubyObject)
-    {
-      delete o;
-      return true;
-    }
-  return false;
-}
+        return false; // already deleted
+      }
+    assert(!o-&gt;mDeleted);
+    o-&gt;clear();
+    if(!o-&gt;mRubyObject)
+      {
+        delete o;
+        return true;
+      }
+    return false;
+  }
 
 
 
@@ -156,19 +169,19 @@
 
 
 AGBaseObject::AGBaseObject(AGRubyObject *p)
-  :mp(p)
+:mp(p)
 {
   if(p)
     p-&gt;addRef(this);
 }
 
 AGBaseObject::~AGBaseObject()
-{
-  if(mp)
-    mp-&gt;deleteRef(this);
-}
+  {
+    if(mp)
+      mp-&gt;deleteRef(this);
+  }
 
 void AGBaseObject::baseClear()
-{
-  mp=0;
-}
+  {
+    mp=0;
+  }

Modified: antargis/trunk/ext/basic/ag_rubyobj.h
===================================================================
--- antargis/trunk/ext/basic/ag_rubyobj.h	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_rubyobj.h	2008-02-24 19:05:29 UTC (rev 1230)
@@ -120,4 +120,7 @@
 AGEXPORT void general_markfunc(void *ptr);
 AGEXPORT bool saveDelete(AGRubyObject *o);
 
+AGEXPORT void *getAddressOfRubyObject(AGRubyObject *object);
+AGEXPORT bool rubyObjectExists(void *o);
+
 #endif

Modified: antargis/trunk/ext/basic/ag_string_utf8.h
===================================================================
--- antargis/trunk/ext/basic/ag_string_utf8.h	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_string_utf8.h	2008-02-24 19:05:29 UTC (rev 1230)
@@ -50,7 +50,10 @@
 class AGEXPORT AGStringUtf8
 {
  public:
-  static const size_t npos = static_cast&lt;size_t&gt;(-1);
+#ifdef SWIG
+   %rename(Npos) npos;
+#endif
+   static const size_t npos = static_cast&lt;size_t&gt;(-1);
 
   AGStringUtf8();
 #ifndef SWIG

Modified: antargis/trunk/ext/game/map.cc
===================================================================
--- antargis/trunk/ext/game/map.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/game/map.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -40,26 +40,26 @@
 
 AntMap *myAntargisMap=0;
 AntMap *getMap()
-{
-  assert(myAntargisMap);
-  return myAntargisMap;
-}
+  {
+    assert(myAntargisMap);
+    return myAntargisMap;
+  }
 
 AntMap::AntMap(SceneBase *pScene,int w,int h):
   HeightMap(pScene,w,h),
   mEntQuad(new QuadTree&lt;AntEntity&gt;(AGRect2(0,0,w,h))),
   mHeuristicFunction(0)
-{
-  myAntargisMap=this;
-  maxID=0;
-}
+  {
+    myAntargisMap=this;
+    maxID=0;
+  }
 AntMap::~AntMap()
-{
-  CTRACE;
-  printf(&quot;%lX\n&quot;,mRUBY);
-  if(myAntargisMap==this)
-    myAntargisMap=0;
-}
+  {
+    CTRACE;
+    printf(&quot;%lX\n&quot;,mRUBY);
+    if(myAntargisMap==this)
+      myAntargisMap=0;
+  }
 
 AGVector3 AntMap::getPos(const AGVector2 &amp;pPos) const
 {
@@ -78,14 +78,14 @@
 
 // FIXME: exchange this function somehow!!
 int AntMap::getNewID()
-{
-  return maxID++;
-}
+  {
+    return maxID++;
+  }
 
 void AntMap::useID(int id)
-{
-  maxID=std::max(maxID,id+1);
-}
+  {
+    maxID=std::max(maxID,id+1);
+  }
 
 
 void AntMap::saveXML(Node &amp;node) const
@@ -97,118 +97,118 @@
   for(;i!=mEntities.end();i++)
     {
       cdebug(&quot;try saving child1 &quot;&lt;&lt;*i);
-			AGString s=(*i)-&gt;xmlName();
-			cdebug(&quot;xmlName:&quot;&lt;&lt;s);
+      AGString s=(*i)-&gt;xmlName();
+      cdebug(&quot;xmlName:&quot;&lt;&lt;s);
       Node &amp;child=node.addChild(s);
       cdebug(&quot;try saving child2 &quot;&lt;&lt;*i);
       (*i)-&gt;saveXML(child);
       cdebug(&quot;try saving child3 &quot;&lt;&lt;*i);
     }
-  
+
 }
 
 
 void AntMap::loadXML(const Node &amp;node)
-{
-  HeightMap::loadXML(node);
+  {
+    HeightMap::loadXML(node);
 
-  Node::const_iterator i=node.begin();
-  for(;i!=node.end();i++)
-    {
-      //      AntEntity *e=0;
-      Node *n=*i;
-      processXMLNode(*n);
-      /*        {
+    Node::const_iterator i=node.begin();
+    for(;i!=node.end();i++)
+      {
+        //      AntEntity *e=0;
+        Node *n=*i;
+        processXMLNode(*n);
+        /*        {
 	  e-&gt;loadXML(*n);
 	  insertEntity(e);
 	  }*/
-    }
-  // tell entities, that map has changed
-  std::list&lt;AntEntity*&gt;::iterator k=mEntities.begin();
-  for(;k!=mEntities.end();k++)
-    (*k)-&gt;eventMapChanged();
-}
+      }
+    // tell entities, that map has changed
+    std::list&lt;AntEntity*&gt;::iterator k=mEntities.begin();
+    for(;k!=mEntities.end();k++)
+      (*k)-&gt;eventMapChanged();
+  }
 
 void AntMap::insertEntity(AntEntity *e)
-{
-  //  cdebug(&quot;INSERTING:&quot;&lt;&lt;e);
-  mEntities.push_back(e);
-  //  mEntList.push_back(e);
-  mEntityMap[e-&gt;getID()]=e;
-  mEntQuad-&gt;insert(e);
-  //  entsChanged();
-  //  mByType[e-&gt;getType()].insert(e);
-}
+  {
+    //  cdebug(&quot;INSERTING:&quot;&lt;&lt;e);
+    mEntities.push_back(e);
+    //  mEntList.push_back(e);
+    mEntityMap[e-&gt;getID()]=e;
+    mEntQuad-&gt;insert(e);
+    //  entsChanged();
+    //  mByType[e-&gt;getType()].insert(e);
+  }
 
 void AntMap::removeEntity(AntEntity *p)
-{
   {
-    EntityList::iterator i=std::find(mToDel.begin(),mToDel.end(),p);
-    if(i!=mToDel.end())
       {
-	cdebug(&quot;Entity already deleted:&quot;&lt;&lt;p);
-	return;
+        EntityList::iterator i=std::find(mToDel.begin(),mToDel.end(),p);
+        if(i!=mToDel.end())
+          {
+            cdebug(&quot;Entity already deleted:&quot;&lt;&lt;p);
+            return;
+          }
       }
-  }
 
 
-  EntityList::iterator i=std::find(mEntities.begin(),mEntities.end(),p);
-  if(i!=mEntities.end())
-    mToDel.push_back(p);
-  else
-    {
-      cdebug(&quot;ERROR: Entity not found while removing:&quot;&lt;&lt;p);
-      //      throw std::runtime_error(&quot;ERROR: Entity not found while removing&quot;);
-    }
-}
+      EntityList::iterator i=std::find(mEntities.begin(),mEntities.end(),p);
+      if(i!=mEntities.end())
+        mToDel.push_back(p);
+      else
+        {
+          cdebug(&quot;ERROR: Entity not found while removing:&quot;&lt;&lt;p);
+          //      throw std::runtime_error(&quot;ERROR: Entity not found while removing&quot;);
+        }
+  }
 
 
 void AntMap::move(float pTime)
-{
-  STACKTRACE; 
-  //return;
-  // first remove entities, which shall be deleted
-  std::list&lt;AntEntity*&gt;::iterator d=mToDel.begin();
-  for(;d!=mToDel.end();d++)
-    {
-      EntityList::iterator i=std::find(mEntities.begin(),mEntities.end(),*d);
-      if(i!=mEntities.end())
-	mEntities.erase(i);
-      else
-	cdebug(&quot;ERROR: Entity not found while deleting:&quot;&lt;&lt;*d);
-      mEntityMap.erase((*d)-&gt;getID());
-      mEntQuad-&gt;remove(*i);
-      //      mByType[(*d)-&gt;getType()].erase(*d);
+  {
+    STACKTRACE; 
+    //return;
+    // first remove entities, which shall be deleted
+    std::list&lt;AntEntity*&gt;::iterator d=mToDel.begin();
+    for(;d!=mToDel.end();d++)
+      {
+        EntityList::iterator i=std::find(mEntities.begin(),mEntities.end(),*d);
+        if(i!=mEntities.end())
+          mEntities.erase(i);
+        else
+          cdebug(&quot;ERROR: Entity not found while deleting:&quot;&lt;&lt;*d);
+        mEntityMap.erase((*d)-&gt;getID());
+        mEntQuad-&gt;remove(*i);
+        //      mByType[(*d)-&gt;getType()].erase(*d);
 
-      saveDelete(*d);
-    }
-  mToDel.clear();
+        saveDelete(*d);
+      }
+    mToDel.clear();
 
-  // now move all entities
+    // now move all entities
 
-  EntityList::iterator i=mEntities.begin();
+    EntityList::iterator i=mEntities.begin();
 
-  for(;i!=mEntities.end();i++)
-    {
-      (*i)-&gt;move(pTime);
-    }
-}
+    for(;i!=mEntities.end();i++)
+      {
+        (*i)-&gt;move(pTime);
+      }
+  }
 
 
 void AntMap::processXMLNode(const Node &amp;node)
-{
-  //  AntEntity *e=0;
-  cdebug(&quot;type unknown:&quot;&lt;&lt;node.getName());
-  //  return e;
-}
+  {
+    //  AntEntity *e=0;
+    cdebug(&quot;type unknown:&quot;&lt;&lt;node.getName());
+    //  return e;
+  }
 AntMap::EntityList AntMap::getEntities(const AGRect2&amp;r)
-{
-  return mEntQuad-&gt;get(r);
-}
+  {
+    return mEntQuad-&gt;get(r);
+  }
 AntMap::EntityList AntMap::getAllEntities()
-{
-  return mEntities;
-}
+  {
+    return mEntities;
+  }
 /*
 std::vector&lt;AntEntityPtr&gt; AntMap::getAllEntitiesV()
 {
@@ -216,232 +216,235 @@
   std::copy(mEntities.begin(),mEntities.end(),std::back_inserter(v));
   return v;
 }
-*/
+ */
 
 std::vector&lt;AntEntity*&gt; AntMap::getEntities(const AGString &amp;pName)
-{
-  std::vector&lt;AntEntity*&gt; v;
-  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
-    if((*i)-&gt;provides(pName))
-      v.push_back(*i);
-  return v;
-}
+  {
+    std::vector&lt;AntEntity*&gt; v;
+    for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+      if((*i)-&gt;provides(pName))
+        v.push_back(*i);
+    return v;
+  }
 
 std::vector&lt;AntEntity*&gt; AntMap::getNextList(AntEntity *me,const AGString &amp;pType,size_t atLeast)
-{
-  //  assert(mHeuristicFunction);
+  {
+    //  assert(mHeuristicFunction);
 
-  // FIXME: optimize this - use quadtree
+    // FIXME: optimize this - use quadtree
 
-  std::multimap&lt;float,AntEntity*&gt; ents;
+    std::multimap&lt;float,AntEntity*&gt; ents;
 
 
-  EntityList::iterator i=mEntities.begin();
-  AGVector2 p=me-&gt;getPos2D(); // FIXME: check for reachability, too ??
+    EntityList::iterator i=mEntities.begin();
+    AGVector2 p=me-&gt;getPos2D(); // FIXME: check for reachability, too ??
 
-  for(;i!=mEntities.end();i++)
-    {
-      if(me!=*i)
-        {
-          if((*i)-&gt;provides(pType) &amp;&amp; (*i)-&gt;resource.get(pType)&gt;=atLeast)
-            {
-	      /*
+    for(;i!=mEntities.end();i++)
+      {
+        if(me!=*i)
+          {
+            if((*i)-&gt;provides(pType) &amp;&amp; (*i)-&gt;resource.get(pType)&gt;=atLeast)
+              {
+                /*
               AGVector2 p2=(*i)-&gt;getPos2D()-p;
               float norm=p2.length2();*/
-	      float norm;
-	      if(mHeuristicFunction)
-		norm=(*mHeuristicFunction)(std::make_pair((*i)-&gt;getPos2D(),p));
-	      else
-		norm=((*i)-&gt;getPos2D()-p).length2();
-              ents.insert(std::make_pair(norm,*i));
-            }
-        }
-    }
+                float norm;
+                if(mHeuristicFunction)
+                  norm=(*mHeuristicFunction)(std::make_pair((*i)-&gt;getPos2D(),p));
+                else
+                  norm=((*i)-&gt;getPos2D()-p).length2();
+                ents.insert(std::make_pair(norm,*i));
+              }
+          }
+      }
 
-  std::vector&lt;AntEntity*&gt; vec;
+    std::vector&lt;AntEntity*&gt; vec;
 
-  // take one of the nearest, but no farer away than 30% of nearest
-  //  AntEntity *e=0;
-  if(ents.size())
-    {
-      std::multimap&lt;float,AntEntity*&gt;::iterator j=ents.begin();
-      float nearest=j-&gt;first;
-      for(;j!=ents.end();j++)
-	{
-	  if(j-&gt;first&lt;=nearest*1.3)
-	    vec.push_back(j-&gt;second);
-	}
-    }
+    // take one of the nearest, but no farer away than 30% of nearest
+    //  AntEntity *e=0;
+    if(ents.size())
+      {
+        std::multimap&lt;float,AntEntity*&gt;::iterator j=ents.begin();
+        float nearest=j-&gt;first;
+        for(;j!=ents.end();j++)
+          {
+            if(j-&gt;first&lt;=nearest*1.3)
+              vec.push_back(j-&gt;second);
+          }
+      }
 
-  return vec;
-}
+    return vec;
+  }
 
 
 AntEntity *AntMap::getNext(AntEntity *me,const AGString &amp;pType,size_t atLeast)
-{
-  //  assert(mHeuristicFunction);
-  // FIXME: optimize this - use quadtree
+  {
+    //  assert(mHeuristicFunction);
+    // FIXME: optimize this - use quadtree
 
-  assert(me);
+    assert(me);
 
-  std::multimap&lt;float,AntEntity*&gt; ents;
+    std::multimap&lt;float,AntEntity*&gt; ents;
 
 
-  EntityList::iterator i=mEntities.begin();
-  AGVector2 p=me-&gt;getPos2D(); // FIXME: check for reachability, too ??
-  //  float dist=0;
+    EntityList::iterator i=mEntities.begin();
+    AGVector2 p=me-&gt;getPos2D(); // FIXME: check for reachability, too ??
+    //  float dist=0;
 
-  for(;i!=mEntities.end();i++)
-    {
-      if(me!=*i)
-        {
-          if((*i)-&gt;provides(pType) &amp;&amp; (*i)-&gt;resource.get(pType)&gt;=atLeast)
-            {
-	      //              AGVector2 p2=(*i)-&gt;getPos2D()-p;
-	      float norm;
+    for(;i!=mEntities.end();i++)
+      {
+        if(me!=*i)
+          {
+            if((*i)-&gt;provides(pType) &amp;&amp; (*i)-&gt;resource.get(pType)&gt;=atLeast)
+              {
+                //              AGVector2 p2=(*i)-&gt;getPos2D()-p;
+                float norm;
 
-	      if(mHeuristicFunction)
-	        norm=(*mHeuristicFunction)(std::make_pair((*i)-&gt;getPos2D(),p));
-	      else
-		norm=((*i)-&gt;getPos2D()-p).length2();
-//	      cdebug(&quot;norm:&quot;&lt;&lt;norm&lt;&lt;&quot; i:&quot;&lt;&lt;*i&lt;&lt;&quot; name:&quot;&lt;&lt;(*i)-&gt;getName());
-	      //              float norm=p2.length2();
-              ents.insert(std::make_pair(norm,*i));
-            }
-        }
-    }
+                if(mHeuristicFunction)
+                  norm=(*mHeuristicFunction)(std::make_pair((*i)-&gt;getPos2D(),p));
+                else
+                  norm=((*i)-&gt;getPos2D()-p).length2();
+                //	      cdebug(&quot;norm:&quot;&lt;&lt;norm&lt;&lt;&quot; i:&quot;&lt;&lt;*i&lt;&lt;&quot; name:&quot;&lt;&lt;(*i)-&gt;getName());
+                //              float norm=p2.length2();
+                ents.insert(std::make_pair(norm,*i));
+              }
+          }
+      }
 
 
-  // take one of the nearest, but no farer away than 30% of nearest
-  AntEntity *e=0;
-  if(ents.size())
-    {
-      std::multimap&lt;float,AntEntity*&gt;::iterator j=ents.begin();
-      float nearest=j-&gt;first;
-      int r=agRand(std::min((int)ents.size(),5));
-      while(r&gt;0 &amp;&amp; (j-&gt;first&lt;=nearest*1.3 || j-&gt;first&lt;2000*2000))
-        {
-          j++;
-          r--;
-        }
-      if(r&gt;0)
-        j--;
-      assert((j!=ents.end()));
-      e=j-&gt;second;
-      //      cdebug(&quot;DIST:&quot;&lt;&lt;j-&gt;first);
-    }
+    // take one of the nearest, but no farer away than 30% of nearest
+    AntEntity *e=0;
+    if(ents.size())
+      {
+        std::multimap&lt;float,AntEntity*&gt;::iterator j=ents.begin();
+        float nearest=j-&gt;first;
+        int r=agRand(std::min((int)ents.size(),5));
+        while(r&gt;0 &amp;&amp; (j-&gt;first&lt;=nearest*1.3 || j-&gt;first&lt;2000*2000))
+          {
+            j++;
+            r--;
+          }
+        if(r&gt;0)
+          j--;
+        assert((j!=ents.end()));
+        e=j-&gt;second;
+        //      cdebug(&quot;DIST:&quot;&lt;&lt;j-&gt;first);
+      }
 
-  return e;
-}
+    return e;
+  }
 
 void AntMap::setHeuristic(HeuristicFunction *pFunction)
-{
-  mHeuristicFunction=pFunction;
-}
+  {
+    mHeuristicFunction=pFunction;
+  }
 
 
 AntEntity *AntMap::getByName(const AGString &amp;pName)
-{
-  EntityList::iterator i=mEntities.begin();
+  {
+    EntityList::iterator i=mEntities.begin();
 
-  for(;i!=mEntities.end();i++)
-    {
-      if((*i)-&gt;getName()==pName)
-        return *i;
-    }
-  return 0;
-}
+    for(;i!=mEntities.end();i++)
+      {
+        if((*i)-&gt;getName()==pName)
+          return *i;
+      }
+    return 0;
+  }
 
 void AntMap::loadMapFromMemory(const AGData &amp;pMem)
-{
-  if(pMem.length())
-    {
-      Document d;
-      d.parseMemory(pMem);
-      loadXML(d.root());
-    }
-}
+  {
+    if(pMem.length())
+      {
+        Document d;
+        d.parseMemory(pMem);
+        loadXML(d.root());
+      }
+  }
 
 void AntMap::loadMap(const AGFilename &amp;pFilename)
-{
-  
-  loadMapFromMemory(loadFile(pFilename));
-}
+  {
+
+    loadMapFromMemory(loadFile(pFilename));
+  }
+
+/**
+ * save the current map into an xml-file named pFilename
+ */
 void AntMap::saveMap(const AGFilename &amp;pFilename)
-{
-	CTRACE;
-  mName=AGString(pFilename);
-  Document d;
-  Node &amp;root=d.root();
-  root.setName(&quot;antargisLevel&quot;);
-  cdebug(&quot;root:&quot;&lt;&lt;&amp;root);
-  saveXML(root);
+  {
+    CTRACE;
+    mName=AGString(pFilename);
+    Document d;
+    Node &amp;root=d.root();
+    root.setName(&quot;antargisLevel&quot;);
+    cdebug(&quot;root:&quot;&lt;&lt;&amp;root);
+    saveXML(root);
 
-  AGData c=d.toString();
-  cdebug(c);
-  saveFile(pFilename,c);
-}
+    AGData c=d.toString();
+    saveFile(pFilename,c);
+  }
 
 void AntMap::clear()
-{
-  //  getScene()-&gt;clear();
-  CTRACE;
-  //  mPlayers.clear();
+  {
+    //  getScene()-&gt;clear();
+    CTRACE;
+    //  mPlayers.clear();
 
-  mEntQuad-&gt;clear();
-  mEntityMap.clear();
+    mEntQuad-&gt;clear();
+    mEntityMap.clear();
 
-  // save delete entities
-  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
-    saveDelete(*i);
-  
+    // save delete entities
+    for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+      saveDelete(*i);
 
-  mEntities.clear();
 
-}
+    mEntities.clear();
 
+  }
+
 void AntMap::mapChanged()
-{
-  HeightMap::mapChanged();
-  // send info to entitites
-  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
-    (*i)-&gt;setPos((*i)-&gt;getPos2D());
-}
+  {
+    HeightMap::mapChanged();
+    // send info to entitites
+    for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+      (*i)-&gt;setPos((*i)-&gt;getPos2D());
+  }
 
 AntEntity *AntMap::getEntity(const Mesh &amp;pMesh)
-{
-  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
-    {
-      AntEntity::Meshes meshes=(*i)-&gt;getMesh();
-      if(std::find(meshes.begin(),meshes.end(),&amp;pMesh)!=meshes.end())
-	//      if((*i)-&gt;getMesh()==&amp;pMesh)
-	return *i;
-    }
-  return 0;
-}
+  {
+    for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+      {
+        AntEntity::Meshes meshes=(*i)-&gt;getMesh();
+        if(std::find(meshes.begin(),meshes.end(),&amp;pMesh)!=meshes.end())
+          //      if((*i)-&gt;getMesh()==&amp;pMesh)
+          return *i;
+      }
+    return 0;
+  }
 
 AntEntity *AntMap::getEntity(const AnimMesh &amp;pMesh)
-{
-  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
-    {
-      AntEntity::Meshes meshes=(*i)-&gt;getMesh();
-      if(std::find(meshes.begin(),meshes.end(),&amp;pMesh)!=meshes.end())
-	return *i;
-    }
-  return 0;
-}
+  {
+    for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+      {
+        AntEntity::Meshes meshes=(*i)-&gt;getMesh();
+        if(std::find(meshes.begin(),meshes.end(),&amp;pMesh)!=meshes.end())
+          return *i;
+      }
+    return 0;
+  }
 
 AntEntity *AntMap::getEntity(const Mesh2D &amp;pMesh)
-{
-  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
-    {
-      AntEntity::Meshes meshes=(*i)-&gt;getMesh();
-      if(std::find(meshes.begin(),meshes.end(),&amp;pMesh)!=meshes.end())
-	//      if((*i)-&gt;getMesh()==&amp;pMesh)
-	return *i;
-    }
-  return 0;
-}
+  {
+    for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+      {
+        AntEntity::Meshes meshes=(*i)-&gt;getMesh();
+        if(std::find(meshes.begin(),meshes.end(),&amp;pMesh)!=meshes.end())
+          //      if((*i)-&gt;getMesh()==&amp;pMesh)
+          return *i;
+      }
+    return 0;
+  }
 
 
 
@@ -451,23 +454,23 @@
 //bool markingFinished=true;
 
 void AntMap::mark()
-{
-  //  cout&lt;&lt;&quot;AntMap::mark()&quot;&lt;&lt;std::endl;
-  CTRACE;
-  HeightMap::mark();
-  AntMap::EntityList::iterator i=mEntities.begin();
+  {
+    //  cout&lt;&lt;&quot;AntMap::mark()&quot;&lt;&lt;std::endl;
+    CTRACE;
+    HeightMap::mark();
+    AntMap::EntityList::iterator i=mEntities.begin();
 
-  for(;i!=mEntities.end();i++)
-    markObject(*i);
+    for(;i!=mEntities.end();i++)
+      markObject(*i);
 
-  // mark to del, too, otherwise it crashes when tidying before move() is called
-  for(i=mToDel.begin();i!=mToDel.end();i++)
-    markObject(*i);
-}
+    // mark to del, too, otherwise it crashes when tidying before move() is called
+    for(i=mToDel.begin();i!=mToDel.end();i++)
+      markObject(*i);
+  }
 
 
 void AntMap::newMap(int w,int h)
-{
-  clear();
-  HeightMap::newMap(w,h);
-}
+  {
+    clear();
+    HeightMap::newMap(w,h);
+  }

Modified: antargis/trunk/ext/gui/ag_application.cc
===================================================================
--- antargis/trunk/ext/gui/ag_application.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/gui/ag_application.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -34,18 +34,18 @@
 #include &lt;ruby.h&gt;
 
 void disableKeyrepeat()
-{
-  SDL_EnableKeyRepeat(0,0);
-}
+  {
+    SDL_EnableKeyRepeat(0,0);
+  }
 
 AGApplication *gApplication=0;
 
 AGVector2 gAppCursorPos;
 
 AGApplication *getApplication()
-{
-  return gApplication;
-}
+  {
+    return gApplication;
+  }
 
 
 AGApplication::AGApplication():mRunning(true),mIdleCalls(true),mainWidget(0),mTooltip(0),mOverlay(0)
@@ -61,32 +61,32 @@
 }
 
 AGApplication::~AGApplication()
-{
-  CTRACE;
-  delete mCursor;
-}
+  {
+    CTRACE;
+    delete mCursor;
+  }
 
 void AGApplication::setKeyRepeat(bool enable)
-{
-  if(enable)
-    SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY,SDL_DEFAULT_REPEAT_INTERVAL);
-  else
-    SDL_EnableKeyRepeat(0,0);
-}
+  {
+    if(enable)
+      SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY,SDL_DEFAULT_REPEAT_INTERVAL);
+    else
+      SDL_EnableKeyRepeat(0,0);
+  }
 
 
 void AGApplication::setMainWidget(AGWidget *w)
-{
-  mainWidget=w;
-  setOverlay(0);
-  if(w)
-    w-&gt;redraw();
-}
+  {
+    mainWidget=w;
+    setOverlay(0);
+    if(w)
+      w-&gt;redraw();
+  }
 
 AGWidget *AGApplication::getMainWidget()
-{
-  return mainWidget;
-}
+  {
+    return mainWidget;
+  }
 
 /**
  * \brief the main-loop of each application
@@ -96,59 +96,59 @@
  */
 
 bool AGApplication::run() 
-{
-  STACKTRACE; 
-  Uint32 last,now;
-  SDL_Event event;
-  float t;
-  mRunning=true;
+  {
+    STACKTRACE; 
+    Uint32 last,now;
+    SDL_Event event;
+    float t;
+    mRunning=true;
 
-  gApplication=this;
-  
-  flushEventQueue();
-  last=now=SDL_GetTicks();
+    gApplication=this;
 
-  size_t loopCount=0;
-  
-  while(mRunning)
-    {
-      STACKTRACE; 
-      
-      gApplication=this;
+    flushEventQueue();
+    last=now=SDL_GetTicks();
 
+    size_t loopCount=0;
+
+    while(mRunning)
       {
-	// event handling
-	STACKTRACE;
-	// check for finished music
-	getMain()-&gt;repeatedCalls();
-	//	getSoundManager()-&gt;checkFinished();
-	
-	now=SDL_GetTicks();
-	/*
+        STACKTRACE; 
+
+        gApplication=this;
+
+          {
+            // event handling
+            STACKTRACE;
+            // check for finished music
+            getMain()-&gt;repeatedCalls();
+            //	getSoundManager()-&gt;checkFinished();
+
+            now=SDL_GetTicks();
+            /*
 	// pull motion events (may flood the eventqueue)
 		while(SDL_PeepEvents(&amp;event, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) &gt; 0)
 	  ;
-	*/
-	clearOldMousePosition();
-	//	dbout(2,&quot;loop pre-event:&quot;&lt;&lt;loopCount);
-	event=getNewEvent();
-	if(eventOk(event))
-	  {
-	    do
-	      {
-		//		dbout(2,&quot;eventok  &quot;&lt;&lt;toString(&amp;event));
-		doEvent(event);
-		if(mIdleCalls)
-		  {
-		    //		    dbout(2,&quot;getNewEvent...  (idlecalls:&quot;&lt;&lt;mIdleCalls&lt;&lt;&quot;)&quot;);
-		    event=getNewEvent();
-		  }
-		else
-		  resetEvent(event);
-	      }while(eventOk(event));
-	  } 
-	//	dbout(2,&quot;loop post-event:&quot;&lt;&lt;loopCount);
-	/*
+             */
+            clearOldMousePosition();
+            //	dbout(2,&quot;loop pre-event:&quot;&lt;&lt;loopCount);
+            event=getNewEvent();
+            if(eventOk(event))
+              {
+                do
+                  {
+                    //		dbout(2,&quot;eventok  &quot;&lt;&lt;toString(&amp;event));
+                    doEvent(event);
+                    if(mIdleCalls)
+                      {
+                        //		    dbout(2,&quot;getNewEvent...  (idlecalls:&quot;&lt;&lt;mIdleCalls&lt;&lt;&quot;)&quot;);
+                        event=getNewEvent();
+                      }
+                    else
+                      resetEvent(event);
+                  }while(eventOk(event));
+              } 
+            //	dbout(2,&quot;loop post-event:&quot;&lt;&lt;loopCount);
+            /*
 	if(mIdleCalls) 
 	  {
 	    if (SDL_PollEvent(&amp;event) == 0) 
@@ -160,7 +160,7 @@
 		    doEvent(&amp;event);
 		  }while(SDL_PollEvent(&amp;event)!=0);
 	      }
-	    
+
 	  } 
 	else 
 	  {
@@ -168,135 +168,135 @@
 	    doEvent(&amp;event);
 	    }*/
 
-	if(mDemoTime&gt;=0)
-	  {
-	    t=mDemoTime;
-	    mDemoTime=-1;
-	    dbout(2,&quot;demo time:&quot;&lt;&lt;t);
-	  }
-	else
-	  {
-	    t=(now-last)/1000.0;
-	  }
-	if(mainWidget)
-	  mainWidget-&gt;sigTick(t);
-	
-	dbout(2,&quot;frame events:&quot;&lt;&lt;t);
-	eventPrepareFrame(t);
+            if(mDemoTime&gt;=0)
+              {
+                t=mDemoTime;
+                mDemoTime=-1;
+                dbout(2,&quot;demo time:&quot;&lt;&lt;t);
+              }
+            else
+              {
+                t=(now-last)/1000.0;
+              }
+            if(mainWidget)
+              mainWidget-&gt;sigTick(t);
 
-	eventFrame(t);
+            dbout(2,&quot;frame events:&quot;&lt;&lt;t);
+            eventPrepareFrame(t);
+
+            eventFrame(t);
+          }
+            {
+              // drawing
+              STACKTRACE;
+                {
+                  STACKTRACE;
+                  prepareDraw();
+                }
+                  {
+                    STACKTRACE;
+                    draw();
+                  }
+            }
+
+            eventFrameEnd(t);
+            last=now;
+
+            loopCount++;
+            //      dbout(2,&quot;Running:&quot;&lt;&lt;mRunning);
       }
-      {
-	// drawing
-	STACKTRACE;
-	{
-	  STACKTRACE;
-	  prepareDraw();
-	}
-	{
-	  STACKTRACE;
-	  draw();
-	}
-      }
-      
-      eventFrameEnd(t);
-      last=now;
+    gApplication=0;
 
-      loopCount++;
-      //      dbout(2,&quot;Running:&quot;&lt;&lt;mRunning);
-    }
-  gApplication=0;
+    return true;
+  }
 
-  return true;
-}
-
 void AGApplication::setDemoTime(float t)
-{
-  dbout(2,&quot;demoTime:&quot;&lt;&lt;t);
-  mDemoTime=t;
-}
+  {
+    dbout(2,&quot;demoTime:&quot;&lt;&lt;t);
+    mDemoTime=t;
+  }
 
 
 SDL_Event AGApplication::getNewEvent()
-{
-  SDL_Event mEvent;
-  resetEvent(mEvent);
-  // pull motion events (may flood the eventqueue)
-  while(SDL_PeepEvents(&amp;mEvent, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) &gt; 0)
-    ;
-  
-  if(mIdleCalls) 
-    {
-      if (SDL_PollEvent(&amp;mEvent) == 0) 
-	{
-	  resetEvent(mEvent);
-	  return mEvent;
-	}
-    } 
-  else 
-    SDL_WaitEvent(&amp;mEvent);
-  return mEvent;
-}
+  {
+    SDL_Event mEvent;
+    resetEvent(mEvent);
+    // pull motion events (may flood the eventqueue)
+    while(SDL_PeepEvents(&amp;mEvent, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) &gt; 0)
+      ;
 
+    if(mIdleCalls) 
+      {
+        if (SDL_PollEvent(&amp;mEvent) == 0) 
+          {
+            resetEvent(mEvent);
+            return mEvent;
+          }
+      } 
+    else 
+      SDL_WaitEvent(&amp;mEvent);
+    return mEvent;
+  }
 
 
+
 bool AGApplication::doEvent(const SDL_Event &amp;event) 
-{
-  STACKTRACE;
-  SDL_Event e;
-  
-  // eat up old mouse motion events
-  while(SDL_PeepEvents(&amp;e, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) &gt; 0);
-  
-  AGEvent *message=newEvent(this,&quot;&quot;,event);
-  bool processed=false;
-  if(mOverlay)
-    processed=mOverlay-&gt;processEvent(message);
+  {
+    STACKTRACE;
+    SDL_Event e;
 
-  if(!processed)
-    {
-      if(!processed &amp;&amp; mainWidget)
-	processed=mainWidget-&gt;processEvent(message);
+    // eat up old mouse motion events
+    while(SDL_PeepEvents(&amp;e, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) &gt; 0);
 
-      if(!processed)
-	processed=processEvent(message);
-    }
-  
-  delete message;
-  return processed;
-}
+    AGEvent *message=newEvent(this,&quot;&quot;,event);
+    bool processed=false;
+    if(mOverlay)
+      processed=mOverlay-&gt;processEvent(message);
 
+    if(!processed)
+      {
+        if(!processed &amp;&amp; mainWidget)
+          processed=mainWidget-&gt;processEvent(message);
+
+        if(!processed)
+          processed=processEvent(message);
+      }
+
+    delete message;
+    return processed;
+  }
+
 void AGApplication::clearOldMousePosition()
-{
-}
+  {
+  }
 void AGApplication::drawCursor()
-{
-  if(!videoInited())
-    return;
-  AGPainter p;
-  if(mCursor)
-    {
-      mCursorOld=AGRect2(gAppCursorPos[0],gAppCursorPos[1],mCursor-&gt;width(),mCursor-&gt;height());
-      p.blit(*mCursor,mCursorOld);
-    }
+  {
+    if(!videoInited())
+      return;
+    AGPainter p;
+    if(mCursor)
+      {
+        mCursorOld=AGRect2(gAppCursorPos[0],gAppCursorPos[1],mCursor-&gt;width(),mCursor-&gt;height());
+        p.blit(*mCursor,mCursorOld);
+      }
 
-}
+  }
 
 void AGApplication::flushEventQueue()
-{
-}
- 
+  {
+  }
+
 bool AGApplication::eventQuit(AGEvent *m)
-{
-  CTRACE;
-  mRunning=false;
-  return false;
-}
+  {
+    CTRACE;
+    mRunning=false;
+    return false;
+  }
 
 bool AGApplication::eventIdle()
-{
-  return false;
-}
+  {
+    return false;
+  }
 
 
 /**
@@ -305,19 +305,19 @@
    prepareDraw runs prepareDraw for the main-widget, which itself runs
    prepareDraw recursively. This functions are meant to prepare possible
    texture contents and other things, that might be updated in each frame.
-*/
+ */
 void AGApplication::prepareDraw()
-{
-  STACKTRACE; 
+  {
+    STACKTRACE; 
 
-  if(mainWidget)
-    {
-      mainWidget-&gt;prepareDrawAll();
-      mainWidget-&gt;useTexturesRecursive();
-    }
-  if(mOverlay)
-    mOverlay-&gt;prepareDrawAll();
-}  
+    if(mainWidget)
+      {
+        mainWidget-&gt;prepareDrawAll();
+        mainWidget-&gt;useTexturesRecursive();
+      }
+    if(mOverlay)
+      mOverlay-&gt;prepareDrawAll();
+  }  
 
 
 AGWidget *pLastDrawn=0;
@@ -330,12 +330,12 @@
  */
 
 void AGApplication::redraw()
-{
-  pLastDrawn=0;
+  {
+    pLastDrawn=0;
 
-  if(mainWidget)
-    mainWidget-&gt;redraw();
-}
+    if(mainWidget)
+      mainWidget-&gt;redraw();
+  }
 
 /**
  * \brief calls the draw-function of the main-widget
@@ -346,103 +346,103 @@
  */
 
 void AGApplication::draw()
-{
-  CTRACE;
-  if(delCue.size()&gt;0)
-    {
-      for(std::list&lt;AGWidget*&gt;::iterator i=delCue.begin();i!=delCue.end();i++)
-	if(*i)
-	  saveDelete(*i);
-      delCue.clear();
-    }
+  {
+    CTRACE;
+    if(delCue.size()&gt;0)
+      {
+        for(std::list&lt;AGWidget*&gt;::iterator i=delCue.begin();i!=delCue.end();i++)
+          if(*i)
+            saveDelete(*i);
+        delCue.clear();
+      }
 
-  if(!videoInited())
-    return;
+    if(!videoInited())
+      return;
 
-  bool oldClippingTechnique=false;
-  AGClipping clip;
+    bool oldClippingTechnique=false;
+    AGClipping clip;
 
-  STACKTRACE;
-  beginRender();
+    STACKTRACE;
+    beginRender();
 
-//  cdebug(&quot;mainWidget:&quot;&lt;&lt;mainWidget);
-  if(mainWidget)
-    {
-      getScreen().begin();
-      
-      AGPainter *p;
-      AGClipPaintTarget paintTarget(&amp;getScreen());
+    //  cdebug(&quot;mainWidget:&quot;&lt;&lt;mainWidget);
+    if(mainWidget)
+      {
+        getScreen().begin();
 
-      if(opengl())
-	p=new AGPainter(getScreen());
-      else
-	p=new AGPainter(paintTarget);
+        AGPainter *p;
+        AGClipPaintTarget paintTarget(&amp;getScreen());
 
-      clip.exclude(mainWidget-&gt;getScreenRect());
-      if(pLastDrawn==mainWidget &amp;&amp; !opengl())
-	{
-	  if(oldClippingTechnique)
-	    {
-	      AGRect2 r=mainWidget-&gt;getChangeRect();
-	      if(mCursor)
-		r+=mCursorOld;
-	      
-	      p-&gt;clip(r);
-	    }
-	  else
-	    {
-	      // FIXME: do some advanced clipping
-	      mainWidget-&gt;acquireClipping(clip);
-	    }
-	}
-      else
-	{
-	  clip.include(mainWidget-&gt;getScreenRect());
-	}
+        if(opengl())
+          p=new AGPainter(getScreen());
+        else
+          p=new AGPainter(paintTarget);
 
-  //    cdebug(&quot;CLIP:&quot;&lt;&lt;clip.toString());
-      paintTarget.clip(clip);
-      mainWidget-&gt;drawAll(*p);
+        clip.exclude(mainWidget-&gt;getScreenRect());
+        if(pLastDrawn==mainWidget &amp;&amp; !opengl())
+          {
+            if(oldClippingTechnique)
+              {
+                AGRect2 r=mainWidget-&gt;getChangeRect();
+                if(mCursor)
+                  r+=mCursorOld;
 
-      if(mTooltip)
-	{
-	  AGPainter p;
-	  mTooltip-&gt;drawAll(p);
-	}
-      if(mOverlay)
-	{
-	  AGPainter p;
-	  mOverlay-&gt;drawAll(p);
-	}
+                p-&gt;clip(r);
+              }
+            else
+              {
+                // FIXME: do some advanced clipping
+                mainWidget-&gt;acquireClipping(clip);
+              }
+          }
+        else
+          {
+            clip.include(mainWidget-&gt;getScreenRect());
+          }
 
-      pLastDrawn=mainWidget;
+        //    cdebug(&quot;CLIP:&quot;&lt;&lt;clip.toString());
+        paintTarget.clip(clip);
+        mainWidget-&gt;drawAll(*p);
 
-      delete p;
-    }
-  else
-    cdebug(&quot;no mainwidget&quot;);
-  drawCursor();
+        if(mTooltip)
+          {
+            AGPainter p;
+            mTooltip-&gt;drawAll(p);
+          }
+        if(mOverlay)
+          {
+            AGPainter p;
+            mOverlay-&gt;drawAll(p);
+          }
 
-  std::list&lt;AGRect2&gt; changeList;
-  if(mainWidget)
-    {
-      changeList=mainWidget-&gt;aquireChanges();
-      mainWidget-&gt;clearChangeRects();
-    }
-  if(opengl())// || true)
-    getScreen().flip();
-  else
-    {
-      std::vector&lt;AGRect2&gt; changeV=clip.clip(mainWidget-&gt;getScreenRect());
-      changeList.clear();
-      std::copy(changeV.begin(),changeV.end(),std::back_inserter(changeList));
-      getScreen().update(changeList);
-    }
+        pLastDrawn=mainWidget;
 
-  endRender();
-//  cdebug(&quot;end render&quot;);
-}
+        delete p;
+      }
+    else
+      cdebug(&quot;no mainwidget&quot;);
+    drawCursor();
 
+    std::list&lt;AGRect2&gt; changeList;
+    if(mainWidget)
+      {
+        changeList=mainWidget-&gt;aquireChanges();
+        mainWidget-&gt;clearChangeRects();
+      }
+    if(opengl())// || true)
+      getScreen().flip();
+    else
+      {
+        std::vector&lt;AGRect2&gt; changeV=clip.clip(mainWidget-&gt;getScreenRect());
+        changeList.clear();
+        std::copy(changeV.begin(),changeV.end(),std::back_inserter(changeList));
+        getScreen().update(changeList);
+      }
+
+    endRender();
+    //  cdebug(&quot;end render&quot;);
+  }
+
 /**
  * \brief quit the application
  *
@@ -452,48 +452,48 @@
  */
 
 void AGApplication::tryQuit()
-{
-  CTRACE;
-  mRunning=false;
-}
+  {
+    CTRACE;
+    mRunning=false;
+  }
 
 bool AGApplication::eventKeyDown(AGEvent *m)
-{
-  if(m-&gt;isSDLEvent())
-    {
-      SDLKey k=m-&gt;getKey();
-      SDLMod mod=m-&gt;getMod();
+  {
+    if(m-&gt;isSDLEvent())
+      {
+        SDLKey k=m-&gt;getKey();
+        SDLMod mod=m-&gt;getMod();
 
-      if(k==SDLK_RETURN &amp;&amp; ((mod&amp;KMOD_LALT)||(mod&amp;KMOD_RALT)))
-	{
-	  getVideo()-&gt;toggleFull();
-	  eventChangedRes();
-	  redraw();
-	}
-      else if(k==SDLK_F10)
-	tryQuit();
-    }
-  return false;
-}
+        if(k==SDLK_RETURN &amp;&amp; ((mod&amp;KMOD_LALT)||(mod&amp;KMOD_RALT)))
+          {
+            getVideo()-&gt;toggleFull();
+            eventChangedRes();
+            redraw();
+          }
+        else if(k==SDLK_F10)
+          tryQuit();
+      }
+    return false;
+  }
 
 void AGApplication::eventChangedRes()
-{
-}
+  {
+  }
 
 bool AGApplication::eventPrepareFrame(float pTime)
-{
-  return false;
-}
+  {
+    return false;
+  }
 
 
 bool AGApplication::eventFrame(float pTime)
-{
-  return false;
-}
+  {
+    return false;
+  }
 bool AGApplication::eventFrameEnd(float pTime)
-{
-  return false;
-}
+  {
+    return false;
+  }
 
 long AGApplication::getTicks() const
 {
@@ -502,76 +502,76 @@
 
 /// delays execution for ms milliseconds. This can be used to decrease framerate and cpu-load.
 void AGApplication::delay(int ms)
-{
-  dbout(2,&quot;delay:&quot;&lt;&lt;ms);
-  SDL_Delay(ms);
-}
+  {
+    dbout(2,&quot;delay:&quot;&lt;&lt;ms);
+    SDL_Delay(ms);
+  }
 
 
 /// mark my mainWidget and my tooltip, as they can be ruby-objects
 void AGApplication::mark()
-{
-  //  CTRACE;
-  if(mainWidget)
-    markObject(mainWidget);
-  if(mTooltip)
-    markObject(mTooltip);
-}
+  {
+    CTRACE;
+    if(mainWidget)
+      markObject(mainWidget);
+    if(mTooltip)
+      markObject(mTooltip);
+  }
 
 /// this function sets the current tooltip, which is display above all widgets
 void AGApplication::setTooltip(AGTooltip *pTooltip)
-{
-  delete mTooltip;
-  mTooltip=pTooltip;
-    
-}
+  {
+    delete mTooltip;
+    mTooltip=pTooltip;
 
+  }
+
 /// this functions resets the tooltip pTooltip.
 /// @param pTooltip a tooltip of a widget
 void AGApplication::resetTooltip(AGTooltip *pTooltip)
-{
-  if(pTooltip==mTooltip)
-    {
-      delete mTooltip;
-      mTooltip=0;
-    }
-}
+  {
+    if(pTooltip==mTooltip)
+      {
+        delete mTooltip;
+        mTooltip=0;
+      }
+  }
 
 AGWidget *AGApplication::getOverlay()
-{
-  return mOverlay;
-}
+  {
+    return mOverlay;
+  }
 
 
 void AGApplication::setOverlay(AGWidget *pOverlay)
-{
-  CTRACE;
-  if(mOverlay)
-    delCue.push_back(mOverlay);
-  mOverlay=pOverlay;
-}
+  {
+    CTRACE;
+    if(mOverlay)
+      delCue.push_back(mOverlay);
+    mOverlay=pOverlay;
+  }
 
 
 bool AGApplication::eventMouseMotion(AGEvent *m)
-{
-  gAppCursorPos=m-&gt;getMousePosition();
-  return AGMessageObject::eventMouseMotion(m);
-}
+  {
+    gAppCursorPos=m-&gt;getMousePosition();
+    return AGMessageObject::eventMouseMotion(m);
+  }
 
 /// this function disables hardware cursor and shows software-cursor instead
 void AGApplication::setCursor(const AGTexture &amp;pTexture)
-{
-  mCursor=new AGTexture(pTexture);
-  SDL_ShowCursor(0);
-}
+  {
+    mCursor=new AGTexture(pTexture);
+    SDL_ShowCursor(0);
+  }
 
 /// this function enables hardware-cursor
 void AGApplication::setNormalCursor()
-{
-  SDL_ShowCursor(1);
-  delete mCursor;
-  mCursor=0;
-}
+  {
+    SDL_ShowCursor(1);
+    delete mCursor;
+    mCursor=0;
+  }
 
 bool AGApplication::hardwareCursor() const
 {

Modified: antargis/trunk/ext/gui/ag_button.cc
===================================================================
--- antargis/trunk/ext/gui/ag_button.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/gui/ag_button.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -222,7 +222,6 @@
 void AGButton::setWidth(float w)
 {
   assert(w&gt;=0);
-  ccdebug(w);
   AGWidget::setWidth(w);
   std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();
   for(;i!=mChildren.end();i++)

Modified: antargis/trunk/main/Rakefile
===================================================================
--- antargis/trunk/main/Rakefile	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/main/Rakefile	2008-02-24 19:05:29 UTC (rev 1230)
@@ -6,7 +6,9 @@
 
 task './starter'=&gt;File.join(&quot;main&quot;,&quot;starter.cc&quot;) do
 	require 'antconfig.rb'
-	cmd=&quot;g++ -o starter main/starter.cc &quot;+$CONFIG[&quot;CFLAGS&quot;]+&quot; &quot;+$CONFIG[&quot;INCLUDEPATH&quot;]+&quot; &quot;+`sdl-config --libs`.chomp+&quot; -l&quot;+CONFIG[&quot;RUBY_SO_NAME&quot;]
+	#debug=&quot;antargis.bundle -g&quot;
+	debug=&quot;&quot;
+	cmd=&quot;g++ -o starter main/starter.cc #{debug} &quot;+$CONFIG[&quot;CFLAGS&quot;]+&quot; &quot;+$CONFIG[&quot;INCLUDEPATH&quot;]+&quot; &quot;+`#{$CONFIG[&quot;SDL_CONFIG&quot;]} --libs`.chomp+&quot; -l&quot;+CONFIG[&quot;RUBY_SO_NAME&quot;]
 	cmd.gsub!(&quot;-arch ppc&quot;,&quot;&quot;)
 	sh cmd
 end

Modified: antargis/trunk/ruby/ant_messagebox.rb
===================================================================
--- antargis/trunk/ruby/ant_messagebox.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/ant_messagebox.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -29,8 +29,8 @@
 MB_YES=4
 MB_NO=8
 
-def messageBox(title,text,flags,&amp;block)
-	mw=getApplication.getMainWidget
+def messageBox(app,title,text,flags,&amp;block)
+	mw=app.getMainWidget
 	w=MessageBox.new(mw,&quot;data/gui/layout/messagebox.xml&quot;)
 	w.block=block
 	w.getChild(&quot;title&quot;).setText(title)

Modified: antargis/trunk/ruby/ant_mock.rb
===================================================================
--- antargis/trunk/ruby/ant_mock.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/ant_mock.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,4 +1,6 @@
+# TODO: remove me
+
+raise &quot;do not call this ???&quot;
+
 class Mesh
-	def initialize
-	end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_hero.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_hero.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/entities/ant_hero.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -163,6 +163,15 @@
 	end
 	def newHLBuildJob(pos,type)
 		@job.stopJob if @job
+    
+    if pos.is_a?(AGVector2) or pos.is_a?(AGVector3) 
+	    if getMap.getHeight(pos[0],pos[1])&lt;=0
+	      # TODO: should view an error message
+	      messageBox(getMap.getApp,_(&quot;Warning&quot;),_(&quot;You can't build on water.&quot;),MB_OK)
+	      return
+	    end
+    end
+    
 		puts &quot;POSHL:#{pos} #{pos.class}&quot;
 		if pos.is_a?(AGVector2) or pos.is_a?(AGVector3)
 			assert{pos.is_a?(AGVector2) or pos.is_a?(AGVector3)}

Modified: antargis/trunk/ruby/entities/ant_sack.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_sack.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/entities/ant_sack.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,5 +1,11 @@
 require 'ant_models.rb'
 
+#
+# AntSack is derived from AntAnimal, so that the KillANimal-job
+# can be used to catch the contents. eventDie is used to remove the sack
+# when the job is finished. So the behaviour is just like a dead animal
+# TODO: Find a better name for AntAnimal
+#
 class AntSack&lt;AntAnimal
 	def initialize(map)
 		super
@@ -7,9 +13,12 @@
 		@enabled=true
 		@storeGood=[&quot;food&quot;,&quot;tool&quot;,&quot;corn&quot;,&quot;stone&quot;,&quot;wood&quot;]
 	end
+	# is called by a finished KillAnimal-hl-job
 	def eventDie
 		getMap.removeEntity(self)
 	end
+	
+	# TODO: move this function to a module, which is included by AntHouse,AntTree and such, too.
 	def resourceChanged
 		@storeGood.each{|r|
 			setProvide(r,resource.get(r)&gt;0)

Modified: antargis/trunk/ruby/jobs/ant_hljob_states.rb
===================================================================
--- antargis/trunk/ruby/jobs/ant_hljob_states.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/jobs/ant_hljob_states.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -772,9 +772,12 @@
 #
 class HLJob_Recruit&lt;HLJob_BaseState
 	MAX_DIST=0.01
+  
+  attr_reader :countRecruited
+  
 	def enter
 		@countTargetMen=target.getMen.length
-		@countRecruiting=0
+		#@countRecruiting=0
 		@countRecruited=0
 		@myPos=hero.getPos2D
 		hero.formation=AntFormationRest.new(hero)
@@ -783,10 +786,11 @@
 
 	def ready
 		#return false
-		recruitedEnough=((@countRecruited&gt;=howManyToRecruit) or nonToRecruitLeft)
+	  recruitedEnough=(((@countRecruited+countRecruiting)&gt;=howManyToRecruit) or nonToRecruitLeft)
 		everyoneIsAtHisPlace=(hero.getMen).map{|man|(man.getPos2D-hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">man, at myPos</A>)).length}.max&lt;MAX_DIST
 		heroIsAtHisPlace=(hero.getPos2D-hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">hero, at myPos</A>)).length&lt;MAX_DIST
-		return (recruitedEnough and everyoneIsAtHisPlace)
+    allReady=(countRecruiting==0)
+		return (recruitedEnough and everyoneIsAtHisPlace and allReady)
 	end
 
 	def assign(man)
@@ -850,10 +854,14 @@
 			puts &quot;walkTo #{pos} #{man}&quot;
 		end
 	end
+  
+  def assignedTargets
+    hero.getMen.map{|man|man.hlJobMode[:recruitTarget]}
+  end
 
 	def getAssignableTargets
 		# all target's men without already assigned and target(hero) itself
-		target.getMen-hero.getMen.map{|man|man.getTarget}-[target]
+	  target.getMen-hero.getMen.map{|man|man.getTarget}-[target]-assignedTargets
 	end
 
 	def nonToRecruitLeft
@@ -865,11 +873,13 @@
 	end
 
 	def letRecruit(man)
+	  return false if countRecruited+countRecruiting&gt;howManyToRecruit
 		target=getNext(man,getAssignableTargets)
 		if target
+      assert{countRecruited+countRecruiting&lt;=howManyToRecruit}
 			man.hlJobMode[:recruitTarget]=target
 			man.newMoveJob(0,target,1)
-			@countRecruiting=@countRecruiting+1
+			#@countRecruiting=@countRecruiting+1
 			return true
 		end
 		false
@@ -882,9 +892,13 @@
 		menList=menList-[hero] if hasAtLeastOneFollower
 		menList.reverse.each{|man|
 			letRecruit(man)
-			break if @countRecruiting&gt;=howManyToRecruit
+			break if countRecruiting+countRecruited&gt;=howManyToRecruit
 		}
 	end
+  
+  def countRecruiting
+    hero.getMen.select{|man|man.hlJobMode[:recruitTarget]}.length
+  end
 end
 
 begin

Modified: antargis/trunk/ruby/jobs/ant_new_hljobs.rb
===================================================================
--- antargis/trunk/ruby/jobs/ant_new_hljobs.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/jobs/ant_new_hljobs.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -334,8 +334,8 @@
 	attr_accessor :targetPos
 	attr_accessor :formatDir
 	attr_accessor :target
-    attr_accessor :near
-	
+  attr_accessor :near
+
 	def initialize(hero,target)
 		@targetPos=target.getPos2D
 		@target=target

Modified: antargis/trunk/ruby/map.rb
===================================================================
--- antargis/trunk/ruby/map.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/map.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -64,13 +64,16 @@
 		assert{w.is_a?(Numeric)}
 		assert{h.is_a?(Numeric)}
 
-		if pScene.nil?
-			require 'ant_mock.rb'
-		end
+    # TODO: remove that ???
+		#if pScene.nil?
+		#	require 'ant_mock.rb'
+		#end
 
 		super(pScene,w,h)
 		@pause=false # is game paused
 		@app=app
+    
+    @classMapCache=nil
 
 		@@systemTime=0.0  # systemTime is needed for the playing of sounds - so they won't be played too often
 		@curTime=0.0      # curTime holds the current &quot;date&quot; of the world; the age of entities is measures by this
@@ -445,6 +448,10 @@
 			e.is_a?(type)
 		}
 	end
+  
+  def getApp
+    @app
+  end
 
 private	
 	def checkTriggers

Modified: antargis/trunk/ruby/meshes/grass.rb
===================================================================
--- antargis/trunk/ruby/meshes/grass.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/meshes/grass.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,10 +1,8 @@
 def getGrassMeshData(size,many=4,texture=nil,bush=false)
 	size=(size*10).to_i/10.0
 
-	if not $grassdata
-		$grassdata={}
-	end
-	if $grassdata[size]
+	$grassdata||={}
+ 	if $grassdata[size]
 		return $grassdata[size]
 	end
 	

Deleted: antargis/trunk/ruby/spec/geometry.rb
===================================================================
--- antargis/trunk/ruby/spec/geometry.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/geometry.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,27 +0,0 @@
-require 'ruby/antargislib.rb'
-require 'pp'
-
-describe AGCircle2,&quot;a radius 2 circle around (10,10)&quot; do
-	before(:each) do
-		@circleMiddle=AGVector2.new(10,10)
-		@radius=2
-		@circle=AGCircle2.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">circleMiddle, at radius</A>)
-	end
-
-	it &quot;should hit an intersection line (9,0)-(9,20)&quot; do
-		line=AGLine2.new(AGVector2.new(9,0),AGVector2.new(9,20))
-		list=@circle.collide(line)
-		list.length.should == 2
-		list.each{|p|(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p- at circleMiddle</A>).length.should == @radius}
-
-		# should lie on line
-		list.each{|p|p.x.should ==9}
-
-	end
-	it &quot;should not hit an line at (9,0)-(119,0)&quot; do
-		l2=AGLine2.new(AGVector2.new(9,0),AGVector2.new(119,0))
-		list=@circle.collide(l2)
-		list.length.should ==0
-
-	end
-end
\ No newline at end of file

Modified: antargis/trunk/ruby/spec/level_testing.rb
===================================================================
--- antargis/trunk/ruby/spec/level_testing.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/level_testing.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -46,26 +46,25 @@
 		end
 	end
 	
-    def clickAwayStory
-        telltaleWidget=widget(&quot;TellTale&quot;)
+  def clickAwayStory
+	  telltaleWidget=widget(&quot;TellTale&quot;)
 		raise if telltaleWidget.nil?
-        return if telltaleWidget.nil?
+    return if telltaleWidget.nil?
+	
+    telltaleWidget.should_not be_nil
+    telltaleWidget.should be_visible
+    okButton=telltaleWidget.child(&quot;ok&quot;)
+    okButton.should_not be_nil
+    okButton.click
+    trials=0
 
-        telltaleWidget.should_not be_nil
-        telltaleWidget.should be_visible
-        okButton=telltaleWidget.child(&quot;ok&quot;)
-        okButton.should_not be_nil
-        okButton.click
-        trials=0
-		
-        while telltaleWidget.visible?
-            okButton.click
-            @app.step
-            trials+=1
-            trials.should &lt;10
-        end
-
+    while telltaleWidget.visible?
+      okButton.click
+      @app.step
+      trials+=1
+      trials.should &lt;10
     end
+  end
 	
 	
 	def advance(time=nil)
@@ -78,12 +77,12 @@
 		end while time&gt;step
 	end	
 
-    def hero(name)
-    	h=map.getByName(name)
+  def hero(name)
+  	h=map.getByName(name)
 		h.should_not be_nil
 		h.should be_a_kind_of(AntHero)
 		h
-    end
+  end
 	def building(name)
 		b=map.getByName(name)
 		b.should_not be_nil
@@ -99,8 +98,11 @@
 	end
 	
 	def waitForStory
-		while not (widget(&quot;TellTale&quot;).valid and widget(&quot;TellTale&quot;).visible?)
+	  while not storyIsDisplayed
 			advance
 		 end
-	end		
+	end
+  def storyIsDisplayed
+    widget(&quot;TellTale&quot;).valid and widget(&quot;TellTale&quot;).visible?
+  end  
 end
\ No newline at end of file

Deleted: antargis/trunk/ruby/spec/map.rb
===================================================================
--- antargis/trunk/ruby/spec/map.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/map.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,32 +0,0 @@
-require 'ruby/antargislib.rb'
-require 'map.rb'
-
-module TestingMap
-	@@testing=false
-	def Testing.initTesting
-		return if @@testing
-		@@testing=true
-
-		@@app=AGApplication.new
-		@@scene=Scene.new(800,600)
-	end
-
-	def Testing.getTestMapFor(test)
-		initTesting
-		case test
-			when :recruit
-				map=AntRubyMap.new(@@app,@@scene,800,600)
-				map.loadMap(&quot;data/levels/tutorial/tutorial0.antlvl&quot;)
-				map
-		end
-	end
-end
-
-describe AntRubyMap,&quot;A BoA-Ruby-map&quot; do
-	it &quot;should run without UI at all&quot; do
-		map=AntRubyMap.new(nil,nil,64,64)
-		map.move(1)
-	end
-
-	it &quot;should be possible to create two maps concurrently (low prio)&quot;
-end
\ No newline at end of file

Added: antargis/trunk/ruby/spec/spec_coding_style.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_coding_style.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_coding_style.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -0,0 +1,30 @@
+describe &quot;Coding style C/++&quot; do
+  it &quot;shouldn't include any TABs anymore&quot; do
+    (Dir[&quot;**/*.cc&quot;]+Dir[&quot;**/*.h&quot;]).each {|filename|
+      file=File.open(filename)
+      c=file.read
+      file.close
+      okfilename=&quot;#{filename} contains no tabs&quot;
+      result=okfilename
+      result=&quot;#{filename} contains tabs&quot; if c =~/\t/
+      
+      linenr=0
+      numbers=c.split(&quot;\n&quot;).map{|line|[line=~/\t/,linenr+=1]}.select{|l|l[0]}.map{|l|l[1]}
+      puts &quot;failed line-numbers (#{filename}): #{numbers.join(&quot;,&quot;)}&quot;
+      
+      result.should == okfilename
+    }
+  end
+  it &quot;should not have senseless comments (outcommenting)&quot;
+  it &quot;should include decent documentation&quot;
+  it &quot;should include author/modification date&quot;
+  it &quot;should include GPL in all files&quot;
+  it &quot;should not have any TODOs left&quot;
+end
+
+describe &quot;Coding style Ruby&quot; do
+  it &quot;shouldn't include any TABs anymore&quot;
+  it &quot;should include decent documentation&quot;
+  it &quot;should include author/modification date&quot;
+  it &quot;should include GPL in all files&quot;
+end
\ No newline at end of file

Added: antargis/trunk/ruby/spec/spec_entity.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_entity.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_entity.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -0,0 +1,3 @@
+describe &quot;Tree&quot; do
+  it &quot;should not change mesh from now to then (=prevent tree dancing around)&quot;
+end
\ No newline at end of file

Modified: antargis/trunk/ruby/spec/spec_game_gui.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_game_gui.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_game_gui.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,3 +1,5 @@
+#if false
+
 require 'ruby/spec/level_testing.rb'
 
 describe &quot;Aggression buttons&quot; do
@@ -69,3 +71,23 @@
 	it &quot;should switch text color when enemy is pwned&quot;
 end
 
+describe AntInfoBox do
+    include LevelTesting
+    before(:all) do
+      getTestApp(:tutorial0)
+      waitForStory
+      clickAwayStory
+    end
+
+	it &quot;should be displayed when hero is badly hurt&quot; do
+	   widget(&quot;InfoBox&quot;).should be_nil#
+	   hero(&quot;Rowen&quot;).decEnergy(0.9)
+	   advance
+       widget(&quot;InfoBox&quot;).should_not be_nil
+       widget(&quot;InfoBox&quot;).should be_visible
+	end
+end
+
+
+
+#end
\ No newline at end of file

Added: antargis/trunk/ruby/spec/spec_gc.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_gc.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_gc.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -0,0 +1,35 @@
+# DOES NOT WORK !!!!
+
+if false
+  require 'ruby/antargislib.rb'
+
+
+
+def doapp
+	address=nil
+	Module.new.module_eval{
+		app=AGApplication.new #AGMessageObject.new #(nil,AGRect2.new(0,0,100,100)) #AGApplication.new
+		address=getAddressOfRubyObject(app)
+		app=nil
+	}
+    address
+	#nil
+end
+
+describe &quot;Garbage Collection&quot; do
+	it &quot;should handle AGApplication (alone) correctly&quot; do
+		#setDebugLevel(0)
+		address=0
+		begin
+			address=doapp
+		end
+		GC.enable
+	    # allocate much mem (200 MB)
+		text=&quot;a&quot;*1000*1000*300
+		GC.start
+		rubyObjectExists(address).should be_false
+		rubyObjectExists(getAddressOfRubyObject(getMain)).should be_true
+	end
+end
+
+end
\ No newline at end of file

Copied: antargis/trunk/ruby/spec/spec_geometry.rb (from rev 1229, antargis/trunk/ruby/spec/geometry.rb)

Modified: antargis/trunk/ruby/spec/spec_hljobs.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_hljobs.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_hljobs.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,3 +1,4 @@
+
 require 'ruby/spec/level_testing.rb'
 
 
@@ -83,8 +84,9 @@
 
 
 describe &quot;Recruit job - aggression&quot; do
+  include LevelTesting
 	it &quot;men should fetch a few men if aggression is low&quot;
-    it &quot;men should fetch all men if aggression if high&quot;
+  it &quot;men should fetch all men if aggression if high&quot;
 end
 
 
@@ -117,11 +119,22 @@
 		rowen=hero(&quot;Rowen&quot;)
 		waitForStory
 		clickAwayStory
+    widget(&quot;MessageBox&quot;).should be_nil
 		rowen.newHLBuildJob(rowen.getPos2D+AGVector2.new(-5,-10),AntTower)
+    widget(&quot;MessageBox&quot;).should_not be_nil
+    widget(&quot;MessageBox&quot;).should be_visible
+    widget(&quot;MessageBox&quot;).child(&quot;text&quot;).getText.should ==_(&quot;You can't build on water.&quot;)
 		rowen.getJob.should_not be_a_kind_of(AntHeroBuildJob)
 	end
+  it &quot;should use meshes correctly (in correct order)&quot;
+  it &quot;should find resources correctly&quot;
+  
 	describe &quot;Continue a build job&quot; do
 		it &quot;should work correctly&quot;
 	end
-	
+  
+  it &quot;should let people rest enough when aggression is low&quot;
+	it &quot;should let people rest at the correct position&quot;
 end
+
+

Added: antargis/trunk/ruby/spec/spec_map.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_map.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_map.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -0,0 +1,11 @@
+require &quot;ruby/spec/level_testing.rb&quot;
+
+describe AntRubyMap,&quot;A BoA-Ruby-map&quot; do
+	it &quot;should run without UI at all&quot; do
+		map=AntRubyMap.new(nil,nil,64,64)
+		map.move(1)
+	end
+  it &quot;should not include ant_mock.rb when calling without GUI&quot;
+
+	it &quot;should be possible to create two maps concurrently (low prio)&quot;
+end

Modified: antargis/trunk/ruby/spec/spec_menu.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_menu.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_menu.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,3 +1,5 @@
+#if false
+
 Dir.chdir(File.split(__FILE__)[0])
 
 require '../spec_helper.rb'
@@ -67,3 +69,4 @@
 	end
 end
 
+#end
\ No newline at end of file

Modified: antargis/trunk/ruby/spec/spec_run_tutorial.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_run_tutorial.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_run_tutorial.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,55 +1,103 @@
 #Dir.chdir(File.split(__FILE__)[0])
 
 require 'ruby/spec_helper.rb'
-require 'ruby/gui/testing.rb'
+require 'ruby/spec/level_testing.rb'
 require 'ruby/ant_application.rb'
 
+# TODO: redesign spec for different runs
+
 describe 'Tutorial campaign' do
 	describe '- First level' do
-		include GuiTest
-		before(:all) do
-			# FIXME
-			file=&quot;data/levels/tutorial/tutorial0.antlvl&quot;
-			clientConnection=nil
-			@app=makeTestAppClass(AntGameApp).new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
+	  include LevelTesting
+    describe &quot;- disjoint tests&quot; do
+			before do
+				@app=getTestApp(:tutorial0)
 		    @app.step
-			
-		end
-		it &quot;should start off with a story telling dialog&quot; do
-			telltaleWidget=widget(&quot;TellTale&quot;)
-			telltaleWidget.should_not be_nil
-			telltaleWidget.should be_visible
-			textWidget=telltaleWidget.child(&quot;text&quot;)
-			textWidget.should_not be_nil
-			text=textWidget.getText.to_s
-			okButton=telltaleWidget.child(&quot;ok&quot;)
-			okButton.should_not be_nil
-			okButton.click
-			text.should_not ==(textWidget.getText.to_s)
-			@app.step
-			clickAwayStory
-			
-		end
+				
+			end
+			it &quot;should start off with a story telling dialog&quot; do
+				telltaleWidget=widget(&quot;TellTale&quot;)
+				telltaleWidget.should_not be_nil
+				telltaleWidget.should be_visible
+				textWidget=telltaleWidget.child(&quot;text&quot;)
+				textWidget.should_not be_nil
+				text=textWidget.getText.to_s
+				okButton=telltaleWidget.child(&quot;ok&quot;)
+				okButton.should_not be_nil
+				okButton.click
+				text.should_not ==(textWidget.getText.to_s)
+				@app.step
+				clickAwayStory
+				
+			end
+
+      it &quot;should be no problem to recruit only a few men at the beginning when aggression is low&quot; do
+        storyIsDisplayed.should be_true
+        clickAwayStory
+        rowen=hero(&quot;Rowen&quot;)
+        keep=building(&quot;Keep&quot;)
+        rowen.getMen.length.should == 1
+        menCount=(rowen.getMen+keep.getMen).length
+        rowen.getAggression.should == 1
+        rowen.newHLRecruitJob(keep)
+        while rowen.hasHLJob
+          advance
+        end
+        rowen.getAggression.should == 1
+        rowen.hasHLJob.should be_false
+        rowen.getMen.length.should &lt; menCount
+        keep.getMen.length.should &gt; 0
+      end      
+      	    
+	    it &quot;should be no problem to set aggression to maximum at the beginning&quot; do
+	      storyIsDisplayed.should be_true
+	      clickAwayStory
+	      rowen=hero(&quot;Rowen&quot;)
+	      keep=building(&quot;Keep&quot;)
+	      rowen.getMen.length.should == 1
+	      menCount=(rowen.getMen+keep.getMen).length
+	      rowen.getAggression.should == 1
+	      rowen.setAggression(3.0)
+	      rowen.newHLRecruitJob(keep)
+	      while rowen.hasHLJob
+	        advance
+	      end
+	      rowen.getAggression.should == 3
+	      rowen.hasHLJob.should be_false
+	      rowen.getMen.length.should == menCount
+	      keep.getMen.length.should == 0
+	    end
+    end    
+    
 		describe '- State at the beginning' do
-		  before(:each) do
+		  before(:all) do
+	      @app=getTestApp(:tutorial0)
 			  @map=@app.getMap
 			  @map.should be_a_kind_of(AntRubyMap)
-			  clickAwayStory
+			  #clickAwayStory
 			  @enemy=nil
 			  @hero=nil
+        advance
 		  end
-          it &quot;should display no story-telling anymore at this time&quot; do
-          	widget(&quot;TellTale&quot;).should be_nil
-          end
+      it &quot;should display a story-telling&quot; do
+        storyIsDisplayed.should be_true
+        clickAwayStory
+      end
+      it &quot;should display no story-telling anymore at this time&quot; do
+        storyIsDisplayed.should be_false
+      end
+      it &quot;- hero should have low aggression at the beginning&quot; do
+        hero(&quot;Rowen&quot;).getAggression.should == 1
+      end
 
 			            	
 		  it &quot;should include Rowen and an enemy&quot; do
 		    heroes=@map.getOwnHeroes
-			enemies=@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">map.getHeroes- at map.getOwnHeroes</A>
-			heroes.length.should == 1
-			enemies.length.should == 1
-			@hero=heroes[0]
-			@enemy=enemies[0]
+				enemies=@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">map.getHeroes- at map.getOwnHeroes</A>
+				heroes.length.should == 1
+				enemies.length.should == 1
+				@hero=heroes[0]
+				@enemy=enemies[0]
 		  end
 		  it &quot;should have a single enemy with a few troopers&quot; do
 		  	getEnemy.getMen.length.should &gt;2
@@ -61,66 +109,96 @@
 
 		  it &quot;should have a tower with a few men&quot; do
 		  	towers=@map.getBuildings
-			towers.length.should == 1
-			@tower=towers[0]
-			@tower.should be_a_kind_of(AntTower)
-			@tower.getMen.length&gt;2
+				towers.length.should == 1
+				@tower=towers[0]
+				@tower.should be_a_kind_of(AntTower)
+				@tower.getMen.length&gt;2
 		  end
 		  it &quot;should include more men in tower than enemy has&quot; do
 		  	tower=@map.getBuildings[0]
-			tower.getMen.length.should &gt; getEnemy.getMen.length
+				tower.getMen.length.should &gt; getEnemy.getMen.length
 		  end
 		  
 		end
-		it &quot;should be possible to recruit some men&quot; do
-			# do a recruit job
-			@map=@app.getMap
-			hero=getHero
-			building=getBuilding
-			hero.newHLRecruitJob(building)
-			while hero.hasHLJob
+    
+    describe &quot;- normal run&quot; do
+      before(:all) do
+        # nothing
+        @app=getTestApp(:tutorial0)
+        advance
+        clickAwayStory
+      end
+    
+			it &quot;should be possible to recruit some men (not all)&quot; do
+				# do a recruit job
+				@map=@app.getMap
+				hero=getHero
+	      hero.getAggression.should == 1
+				building=getBuilding
+				hero.newHLRecruitJob(building)
+				while hero.hasHLJob
+					advance
+				end
+				hero.getJob.should_not be_a_kind_of(AntHeroRecruitJob)
+				widget(&quot;TellTale&quot;).should be_visible
+				building.getMen.length.should &gt; 0
+				hero.getMen.length.should &gt;= 2
+			end
+	    it &quot;should display a story part&quot; do
+	      storyIsDisplayed.should be_true
+	      clickAwayStory
+	    end
+	
+	    it &quot;should be possible to recruit the remaining men&quot; do
+	      rowen=hero(&quot;Rowen&quot;)
+	      keep=building(&quot;Keep&quot;)
+	      rowen.setAggression(3)
+	      rowen.newHLRecruitJob(keep)
+	      menCount=rowen.getMen.length+keep.getMen.length
+	      while rowen.hasHLJob ; advance; end
+	      rowen.getMen.length.should == menCount
+	      keep.getMen.length.should == 0
+	      rowen.getMen.length.should &gt; getEnemy.getMen.length
+	    end
+	    
+			it &quot;should be possible to defeat enemy with low aggression&quot; do
+			  
+				hero=getHero
+				enemy=getEnemy
+	      hero.setAggression(1)
+				hero.newHLFightJob(enemy)
+				hero.getJob.should be_a_kind_of(AntHeroFightJob)
+				enemy.hasHLJob.should be_false
+	      trials=300
+				while hero.hasHLJob
+					puts hero.getJob
+					advance
+	        break if storyIsDisplayed
+	        trials.should &gt; 0
+	        trials-=1
+				end
+	      storyIsDisplayed.should be_true
+				clickAwayStory
 				advance
+		    @app.result.won.should == &quot;won&quot;
+	      map.getOwnHeroes.length.should == 2
 			end
-			hero.getJob.should_not be_a_kind_of(AntHeroRecruitJob)
-			widget(&quot;TellTale&quot;).should be_visible
-			building.getMen.length.should == 0
-			hero.getMen.length.should &gt; 2
-			hero.getMen.length.should &gt; getEnemy.getMen.length
 			
-
-		end
-		it &quot;should be possible to defeat enemy&quot; do
-	       clickAwayStory
-			hero=getHero
-			enemy=getEnemy
-			hero.newHLFightJob(enemy)
-			hero.getJob.should be_a_kind_of(AntHeroFightJob)
-			enemy.hasHLJob.should be_false
-			while hero.hasHLJob
-				puts hero.getJob
-				advance
+			
+			it &quot;should be possible to dismiss some people&quot; do
+				hero=getHero
+				hero.setAggression(1)
+				oldMenCount=hero.getMen.length
+				oldMenCount.should &gt; 1
+				hero.newHLDismissJob
+				while hero.hasHLJob
+					advance
+				end
+				menCount=hero.getMen.length
+				menCount.should &lt; oldMenCount
 			end
-			clickAwayStory
-			advance
-		    @app.result.won.should == &quot;won&quot;
-            map.getOwnHeroes.length.should == 2
-		end
+    end			
 		
-		
-		it &quot;should be possible to dismiss some people&quot; do
-			hero=getHero
-			hero.setAggression(1)
-			oldMenCount=hero.getMen.length
-			oldMenCount.should &gt; 1
-			hero.newHLDismissJob
-			while hero.hasHLJob
-				advance
-			end
-			menCount=hero.getMen.length
-			menCount.should &lt; oldMenCount
-		end
-		
-		
 	
 		def getEnemies
 			enemies=map.getHeroes-map.getOwnHeroes
@@ -135,31 +213,5 @@
 		def getBuilding
 			@app.getMap.getBuildings[0]
 		end
-	    def advance
-	    	@app.getMap.move(0.3)
-			@app.step
-	    end
-		def map
-		  @app.getMap
-		end
 	end
-	
-	def clickAwayStory
-		telltaleWidget=widget(&quot;TellTale&quot;)
-		return if telltaleWidget.nil?
-
-		telltaleWidget.should_not be_nil
-		telltaleWidget.should be_visible
-		okButton=telltaleWidget.child(&quot;ok&quot;)
-		okButton.should_not be_nil
-		okButton.click
-		trials=0
-		while telltaleWidget.visible?
-			okButton.click
-			@app.step
-			trials+=1
-			trials.should &lt;10
-		end
-
-	end
 end
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000186.html">[Antargis-svn] r1229 - in antargis/trunk: . ext ext/3dengine	ext/game ext/video main ruby ruby/entities ruby/gui ruby/jobs	ruby/spec ruby/widgets
</A></li>
	<LI>Next message: <A HREF="000188.html">[Antargis-svn] r1231 - antargis/trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#187">[ date ]</a>
              <a href="thread.html#187">[ thread ]</a>
              <a href="subject.html#187">[ subject ]</a>
              <a href="author.html#187">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/antargis-svn">More information about the Antargis-svn
mailing list</a><br>
</body></html>
