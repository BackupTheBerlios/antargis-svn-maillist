<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Antargis-svn] r1227 - in antargis/trunk: . ext/video ruby
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/antargis-svn/2008-February/index.html" >
   <LINK REL="made" HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1227%20-%20in%20antargis/trunk%3A%20.%20ext/video%20ruby&In-Reply-To=%3C200802052013.m15KDEUi031895%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000183.html">
   <LINK REL="Next"  HREF="000185.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Antargis-svn] r1227 - in antargis/trunk: . ext/video ruby</H1>
    <B>davidkamphausen at BerliOS</B> 
    <A HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1227%20-%20in%20antargis/trunk%3A%20.%20ext/video%20ruby&In-Reply-To=%3C200802052013.m15KDEUi031895%40sheep.berlios.de%3E"
       TITLE="[Antargis-svn] r1227 - in antargis/trunk: . ext/video ruby">davidkamphausen at mail.berlios.de
       </A><BR>
    <I>Tue Feb  5 21:13:14 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000183.html">[Antargis-svn] r1226 - in antargis/trunk/ext: 3dengine video
</A></li>
        <LI>Next message: <A HREF="000185.html">[Antargis-svn] r1228 - in antargis/trunk: ext/3dengine ext/basic	ext/game ext/gui ext/math ext/sound ext/test ext/video ruby	ruby/entities ruby/gui ruby/spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#184">[ date ]</a>
              <a href="thread.html#184">[ thread ]</a>
              <a href="subject.html#184">[ subject ]</a>
              <a href="author.html#184">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: davidkamphausen
Date: 2008-02-05 21:13:13 +0100 (Tue, 05 Feb 2008)
New Revision: 1227

Added:
   antargis/trunk/ruby/ant_application.rb
Removed:
   antargis/trunk/ruby/run_game.rb
Modified:
   antargis/trunk/TODO
   antargis/trunk/antargis
   antargis/trunk/ext/video/ag_gltexture.cc
   antargis/trunk/ruby/intro.rb
   antargis/trunk/ruby/mainmenu.rb
Log:
* more specs on tutorial

Modified: antargis/trunk/TODO
===================================================================
--- antargis/trunk/TODO	2008-02-02 16:51:48 UTC (rev 1226)
+++ antargis/trunk/TODO	2008-02-05 20:13:13 UTC (rev 1227)
@@ -1,26 +1,19 @@
-* checkin editor !
+* bug-report at apple site on glTexSubImage issue 
+* fix shadows on mac (on shadow-extension ?)
+* check mingw on macosx
 
-* check for ccache in configure and only use it if available!
-
-
 * fix saving - problem occurs only if game is loaded ? (in editor, too)
+** hljobs can't be saved right now
+
 * move build/*.rb files to build/unused_tools/* if they're not used
 * google for &quot;/tmp/cciSLVG5.s:932678: Warning: .stabs: description field '1c216' too big, try a different debug format&quot;
 
-
 * check how many times AG_NewPointer is called !!!! - not so often - could be replaced by traceobjects from swig
 ** check if it's any good to switch over to standard-swig ??? seems so.
 
 !!! AGTexture - not wrapped correctly in bliTri etc ???
 
 
-* check swig-wrapping of: 
-	AGCollector *getCollector (basic/ag_collector.h)
-	AGEXPORT AGConfig *getConfig();
- std::Vector&lt;SceneNode*&gt;
- std::vector&lt;AntEntity*&gt; (game)
-path.h - don't export path-internals to ruby
-
 * moveto doesn't really work with &quot;near&quot; (hljob)
 * heroes don't die in reasonable fashion - starving men too
 * add seasons
@@ -31,10 +24,9 @@
 * why is the story-telling dialog eating up clicks ?
 * improve settings-dialog!
 * check level-editor
+** make wish-list
 
-* saving - hljobs !!
 * check dep-handling with swig
-* implement last hl-jobs 
 * move single entities with path-finder, too?
 
 * docs
@@ -45,8 +37,6 @@
  * antargis.iss
 
 
-
-
 * check if reachable before fetching !!! (in house) - or even better use heuristic for estimating distance in getNear(...)
 * fix jobs some more
 * what's wrong with pathfinding-test ???

Modified: antargis/trunk/antargis
===================================================================
--- antargis/trunk/antargis	2008-02-02 16:51:48 UTC (rev 1226)
+++ antargis/trunk/antargis	2008-02-05 20:13:13 UTC (rev 1227)
@@ -8,11 +8,36 @@
 require 'ruby/mainmenu.rb'
 
 
+
+# code for starting a level directly from command-line like this:
+# ./ruby/run_game.rb levels/birth1
+# or
+# ./ruby/run_game.rb savegames/savegame0
+$useMenu||=false
+if true
+  savegame=&quot;&quot;
+  ARGV.each{|arg|
+    if arg=~/levels.*/ or arg=~/savegames.*/
+      savegame=arg+&quot;.antlvl&quot;
+    end
+  }
+  if savegame!=&quot;&quot;
+    startGame(savegame) 
+    exit
+  end
+end
+
 if getConfig.get(&quot;intro&quot;)!=&quot;false&quot;
-	app=IntroApp.new
-	app.run
+  app=IntroApp.new
+  app.run
 end
 
+
+
+getConfig.set(&quot;ok&quot;,&quot;ok&quot;)
+
+
+
 # run menu
 app=AntMenuApp.new
 app.run

Modified: antargis/trunk/ext/video/ag_gltexture.cc
===================================================================
--- antargis/trunk/ext/video/ag_gltexture.cc	2008-02-02 16:51:48 UTC (rev 1226)
+++ antargis/trunk/ext/video/ag_gltexture.cc	2008-02-05 20:13:13 UTC (rev 1227)
@@ -116,24 +116,27 @@
 	c.begin();
 	assertGL;
 
-	
-  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
-  assertGL;
-  glPixelStorei(GL_UNPACK_ROW_LENGTH,
-                surface-&gt;pitch / surface-&gt;format-&gt;BytesPerPixel);
-	 
 
+	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
 	assertGL;
+	glPixelStorei(GL_UNPACK_ROW_LENGTH,
+			surface-&gt;pitch / surface-&gt;format-&gt;BytesPerPixel);
+
+
+	assertGL;
 	if(m3d)
 	{
 		assert(glIsEnabled(GL_TEXTURE_3D));
 		int mw=std::min(surface-&gt;w,surface-&gt;h);
 		int mh=std::max(surface-&gt;w,surface-&gt;h)/mw;
 
-	//	glTexImage3D(GL_TEXTURE_3D, 0, format, w, h, d, 0, GL_RGBA,
-	//			GL_UNSIGNED_BYTE, surface-&gt;pixels);
-	    glTexSubImage3D(GL_TEXTURE_3D,0,int(offset[0]),int(offset[1]),0,
-				      mw,mw,mh,format,GL_UNSIGNED_BYTE,surface-&gt;pixels);
+		// FIXME: use glTexImage instead of glTexSubImage, because it makes problems
+		// on MacOSX 10.5.1 (at least on my macbook pro - godrin)
+
+		glTexImage3D(GL_TEXTURE_3D, 0, format, w, h, d, 0, GL_RGBA,
+				GL_UNSIGNED_BYTE, surface-&gt;pixels);
+		glTexSubImage3D(GL_TEXTURE_3D,0,int(offset[0]),int(offset[1]),0,
+				mw,mw,mh,format,GL_UNSIGNED_BYTE,surface-&gt;pixels);
 	}
 	else
 	{

Copied: antargis/trunk/ruby/ant_application.rb (from rev 1225, antargis/trunk/ruby/run_game.rb)
===================================================================
--- antargis/trunk/ruby/run_game.rb	2008-01-31 20:08:48 UTC (rev 1225)
+++ antargis/trunk/ruby/ant_application.rb	2008-02-05 20:13:13 UTC (rev 1227)
@@ -0,0 +1,663 @@
+#!/usr/bin/env ruby
+#--
+# Copyright (c) 2005 by David Kamphausen. All rights reserved.
+#
+# game.rb
+# by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+#
+# The &quot;Antargis&quot; project, including all files needed to compile it,
+# is free software; you can redistribute it and/or use it and/or modify it
+# under the terms of the GNU General Public License as published
+# by the Free Software Foundation; either version 2 of the License,
+# or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+#
+# You should have received a copy of the GNU General Public
+# License along with this program.
+#++
+#
+# antargis.rb is the central file in antargis-level-playing.
+# it contains the main-application class AntGameApp for in-game looping, etc.
+# most of the GUI-events are processed here.
+#
+
+
+# add programdir to path
+$programDir=File.split(__FILE__)[0]
+$:.push($programDir)
+$:.push(File.join($programDir,&quot;entities&quot;))
+$:.push(File.join($programDir,&quot;widgets&quot;))
+
+require 'antargislib.rb'
+require 'dialogs.rb'
+require 'entities.rb'
+require 'map.rb'
+require 'view.rb'
+require 'game_result.rb'
+require 'storyflow.rb'
+require 'mpmap.rb'
+
+require 'pp'
+
+# get save path where savegames are stored
+# NOTE: this is combined with getWriteDir from ag_fs.h !
+def getSavePath
+	&quot;savegames&quot;
+end
+
+#
+# AntGameApp is the central application-class in game. It controls:
+# * event handling of all the user interaction
+# * holds all the game-objects
+# * calls the advance-function in each frame
+# * it's derived from AntRubyView, which implements/manages the (3d-)displaying in-game
+#
+class AntGameApp &lt;AntRubyView
+	attr_accessor :result
+	attr_reader :hero
+
+	include AGHandler
+
+	# creating an AntGameApp-object needs the following parameters:
+	# * *savegameText* - this is the actual level serialized in a string (the xml-text you see when you open an .antlvl-file)
+	#   it contains the height- and terrain-map, too. This has the advantage, that everything about a level is stored in one
+	#   text and can thus be transfered easily over internet 
+	# * *w* and *h* are the width and height of the screen, which is currently needed to init the underlying GLApp-class from C++
+	#   *FIXME:* this could be replaced by a call to getMain.getVideo.getWidth and such
+	# * *loadscreen* is a LoadApp-object (or nil); if it's set that indicates that a loadscreen (a progress bar) is displayed
+	# * *connection* is a network-connection to a BoA multiplayer-server for future networking-support. link:files/ruby/multiplayer/README.html
+	#
+	# this function does all the initializing of a level:
+	# * from the super-classes: create a scene (for more go to the parent-class)
+	# * display a load-screen (and set the progress)
+	# * create a AntMpMap object
+	# * create a displaying layout from data/gui/layout/ant_layout.xml
+	# * initializes some event-handlers (glue code between level-displaying and the game-world object of type AntMpMap
+	# * load the map fom *savegameText*
+	# * setup of the hero-display-list at the top of the screen
+	def initialize(savegameText,w,h,loadscreen=nil,connection=nil)
+		super(w,h)
+
+		@speed=1
+
+		# the result of the level - won or lost or canceled
+		@result=GameResult.new
+		$app=self
+		AntSound.setApplication(self)
+	
+		# display loading screen
+		if loadscreen
+			loadscreen.setValue(0.1)
+			loadscreen.tick
+		end
+
+		playerName=nil
+
+		# init network mode
+		@connection=connection
+		if connection
+			# FIXME: check, if this is a server - then don't assign playerName
+			playerName=connection.getName
+		end
+
+		# init game-engine's map
+		@map=AntMpMap.new(connection,self,getScene,32,32,playerName) # some small dummy size - gets overriden by loadMap anyway
+		if loadscreen
+			loadscreen.setValue(0.4)
+			loadscreen.tick
+		end
+
+		# load GUI layout
+		@layout=AGLayout.new(nil)
+		@layout.setApp(self)
+		assert{@layout.getApp}
+		@layout.loadXML(loadFile(&quot;data/gui/layout/ant_layout.xml&quot;))
+	
+
+		# init pointers to different displays
+		# statusBar (FPS display)
+		@statusBar=@layout.getChild(&quot;statusBar&quot;)
+		@inventory=@layout.getChild(&quot;inventory&quot;)
+		@buttonpanel=@layout.getChild(&quot;antButtonPanel&quot;)
+
+		@miniMap=@layout.getChild(&quot;miniMap&quot;)
+		@fps=0
+
+		setMainWidget(@layout)
+		addHandler(@layout.getChild(&quot;quit&quot;),:sigClick,:eventQuit)
+		addHandler(@layout.getChild(&quot;pause&quot;),:sigClick,:eventPause)
+		addHandler(@layout.getChild(&quot;options&quot;),:sigClick,:eventOptions)
+
+		if loadscreen
+			loadscreen.setValue(0.5)
+			loadscreen.tick
+		end
+	
+		if @miniMap
+			# connect MiniMap with Map for displaying terrain and entities
+			@miniMap.setMap(@map)
+			# connect MiniMap with Scene for displaying frustrum
+			@miniMap.setScene(getScene)
+		end
+
+		if loadscreen
+			loadscreen.setValue(0.8)
+			loadscreen.tick()
+		end
+		
+		if savegameText &amp;&amp; savegameText.length&gt;0
+			# load a level
+			@map.loadMapFromMemory(savegameText)
+		end	
+
+		if loadscreen
+			loadscreen.setValue(0.95)
+			loadscreen.tick
+		end
+
+		# inventory and buttonpanel signals
+		addHandler(@inventory,:sigJobChanged,:eventInventoryJob)
+		addHandler(@buttonpanel,:sigJobChanged,:eventHeroJob)
+
+		setupHeroDisplay(true)
+
+		# infobox is used for display a text &quot;Your hero 'xy' suffers&quot;
+		@infobox=nil
+
+		# frame counting
+		@frameCount=0
+		@elapsTime=0
+
+		#setCursor(getTextureCache.get(&quot;blue_cursor.png&quot;))
+	end
+
+	####################################
+	# EVENT HANDLERS
+	####################################
+
+	include AntMyEventHandler
+
+
+	# this handler is for the buttonpanel on the top
+	# the actions are direct ones, like rest,dimiss and so, which don't need an object to use (like fighting,taking,...)
+	def eventHeroJob(e)
+		case @buttonpanel.job
+			when &quot;doDismiss&quot;
+				# opens a query dialog &quot;do really want to do this?&quot;, that is given a block, that's executed on confirmation
+				@layout.addChild(AntQueryDialog.new(@layout,nil) {@hero.newHLDismissJob})
+			when &quot;doRest&quot;
+				if @hero
+					@hero.newHLRestJob(10)
+				end
+			when &quot;doBuild&quot;
+				@job=&quot;doBuild&quot;
+		end
+		return true
+	end
+
+	# react to inventory-based jobs - like taking, recruiting
+
+	def eventInventoryJob(e)
+		if @target.nil? #some more overview as
+			log &quot;NO TARGET SELECTED&quot;
+		else
+			case @inventory.job
+				when &quot;doRecruit&quot;
+					@hero.newHLRecruitJob(@target)
+				when &quot;doTakeFood&quot;
+					@hero.newHLTakeFoodJob(@target)
+				when &quot;doTakeWeapons&quot;
+					@hero.newHLTakeWeaponJob(@target)
+				when &quot;doConstruct&quot;
+					@hero.newHLConstructJob(@target)
+				when &quot;doUpgrade&quot;
+					@hero.upgradeMan(@target)
+				when &quot;doContinue&quot;
+					@hero.newHLBuildJob(@target,nil)
+				when &quot;doSupport&quot;
+					targetsTarget=nil
+					if @target.getJob.is_a?(AntHeroFightJob)
+						targetsTarget=@target.getJob.target
+					end
+					if targetsTarget
+						@hero.newHLFightJob(targetsTarget)
+					end
+			end
+		end
+		return true
+	end
+
+	def eventKeyDown(e)
+
+		# hero-selection by pressing F1 to F7
+		hero={	SDLK_F1=&gt;0,
+			SDLK_F2=&gt;1,
+			SDLK_F3=&gt;2,
+			SDLK_F4=&gt;3,
+			SDLK_F5=&gt;4,
+			SDLK_F6=&gt;5,
+			SDLK_F7=&gt;6}[e.getKey]
+		if hero
+			h=getHeroByNum(hero) 
+			if h
+				if @hero==h
+					focusHero(h)
+				end
+				selectHero(h)
+				return super(e)
+			end
+		end
+
+		
+		case e.getKey
+			when SDLK_F9 # F9 toggles panel on the right
+				if not panelVisible
+					showPanel
+				else
+					hidePanel
+				end
+			when SDLK_F8
+				@sceneEnabled=(not @sceneEnabled)
+				getScene.setEnabled(@sceneEnabled)
+			when SDLK_F1
+				hero=1
+			when SDLK_ESCAPE
+				if @hero
+					@hero.newHLRestJob(10)
+				end
+			when SDLK_PLUS
+				@speed=[@speed+1,10].min
+			when SDLK_MINUS
+				@speed=[@speed-1,0.2].max
+			
+			when SDLK_p
+				eventPause(nil)
+		end
+		return super(e)
+	end
+	
+	def eventStoryTalkFinished
+		showPanel
+		getMap.trigger(nil,Trigger.new(&quot;storyFinished&quot;))
+	end
+
+	def moveMap(time)
+		granularity=0.2
+		while time&gt;granularity
+			getMap().move(granularity)
+			time-=granularity
+		end
+		getMap().move(time)
+	end
+
+	def eventFrame(time)
+		super(time)
+
+		# FPS display
+		if @frameCount&gt;14 then
+			@fps=@frameCount / @elapsTime
+			fps=&quot;&quot;
+			if @fps&lt;10
+				fps=sprintf(&quot;%3.2f&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at fps</A>)
+			else
+				fps=sprintf(&quot;%3.0f&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at fps</A>)
+			end
+			@statusBar.setText(_(&quot;FPS:{1}&quot;,fps.to_s))
+			@frameCount=0
+			@elapsTime=0
+			startGC
+		end
+		@frameCount+=1
+		@elapsTime+=time
+
+
+# 		# move entities in game-engine
+		#getMap().move(time*@speed)
+		moveMap(time*@speed)
+
+		# advance animations
+		getScene.advance(time)
+		checkHeroEnergy
+
+		processMessages
+
+		# save some CPU-power, if available
+		if @connection
+			delay(20)
+		end
+
+		if @fps&gt;25
+			delay(5)
+		end
+		return true
+	end
+	
+	def eventQuit(e)
+		@layout.addChild(AntQuitDialog.new(@layout))
+		return true
+	end
+	def eventPause(e)
+		if not getMap().pause then
+			@layout.addChild(AntPauseDialog.new(@layout))
+		else
+			getMap.pause=false
+		end
+		return true
+	end
+	def eventOptions(e)
+		@layout.addChild(AntOptionsDialog.new(@layout))
+		return true
+	end
+	def eventHeroButton(e)
+		c=e.getCaller.getName
+		num=c[4..4]
+		name=@layout.getChild(&quot;HeroName#{num}&quot;).getText.to_s
+		ent=getMap.getByName(name)
+		selectHero(ent)
+		if ent==@inspect
+			focusHero(ent)
+		end
+		inspectEntity(ent)
+		return true
+
+	end
+
+	def eventAggressionChanged(e)
+		h=getSelectedHero
+		if h
+			h.setAggression(@buttonpanel.getAggression)
+		end
+		return true
+	end
+
+	def eventEntitiesClicked(list,button)
+		resetJob
+		# find first entity that's nearest to the camera
+		ent=nil
+		list.each{|node|
+			mesh=node.node
+			if [Mesh,AnimMesh,Mesh2D].member?(mesh.class)
+				ent=getMap.getEntity(mesh)
+				break if ent
+			end
+		}
+
+		# if an entity was found - set new target
+		if ent
+			if ent.class==AntHero and ent.getPlayer==getMap.getPlayer
+				#@hero=ent
+				@target=ent
+				inspectEntity(ent)
+			else
+				@target=ent
+				inspectEntity(ent)
+			end
+		end
+
+		if button==1
+			# left button == select
+		elsif button==3
+			# right button == fight or goto
+			if ent==@target
+				if @target.is_a?(AntBoss)
+					if @target.getPlayer!=@hero.getPlayer
+						@hero.newHLFightJob(@target)
+						return
+					end
+				elsif @target.is_a?(AntAnimal)
+					@hero.newHLFightAnimalJob(@target)
+					return
+				end
+				# move near target
+				@hero.newHLMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,2)
+			end
+		end
+	end
+
+	def eventMapClicked(pos,button)
+		if @job and button==1 then
+			case @job
+				when &quot;doBuild&quot;
+					buildHouse(pos.dim2)
+					@job=nil
+			end
+			resetJob
+			return
+		end
+		if @hero and button==3 then
+			# assign hero a move job
+			@hero.newHLMoveJob(0,pos,0)
+		end
+	end
+
+
+	###############################
+	# simple functions
+	###############################
+
+	def getMap
+		@map
+	end
+
+	def processMessages
+		if @connection
+			while message=@connection.getMessage
+				@map.processMessage(message)
+			end
+		end
+	end
+
+	def buildHouse(pos)
+		@layout.addChild(AntBuildDialog.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">layout,pos, at hero</A>))
+	end
+	
+	def save
+		if $campaign
+			@layout.addChild(AntSaveCampaignDialog.new(@layout))
+		else
+			@layout.addChild(AntSaveDialog.new(@layout))
+		end
+	end
+	def load
+		@layout.addChild(AntLoadDialog.new(@layout))
+	end
+	def videoOptions
+		@layout.addChild(AntVideoOptionsDialog.new(@layout))
+	end
+	def audioOptions
+		@layout.addChild(AntAudioOptionsDialog.new(@layout))
+	end
+
+	###############################################################
+	# Setting up of Hero displays (images, texts and eventHandlers
+	###############################################################
+
+	def setHeroImage(image,num)
+		@layout.getChild(&quot;HeroImage#{num}&quot;).setTexture(image)
+	end
+	def setHeroName(name,num)
+		@layout.getChild(&quot;HeroName#{num}&quot;).setText(_(name))
+		c=@layout.getChild(&quot;HeroBar#{num}&quot;)
+		raise 1 if c.nil?
+		c.setVisible((name!=&quot;&quot;))
+	end
+	def setHeroEnergy(hero,num)
+		@layout.getChild(&quot;HeroBar#{num}&quot;).setHero(hero)
+	end
+	def setHero(flag,num)
+		name=&quot;hero#{num}&quot;
+		c=@layout.getChild(name)
+		c.setEnabled(flag)
+		c.setVisible(flag)
+	end
+	def setupHeroDisplay(first=false)
+		#super
+		# setup Hero buttons
+		hs=getMap.getPlayer.getHeroes
+		for i in 0..5
+			if hs.length&gt;i
+				setHero(true,i)
+				setHeroName(hs[i].getName,i)
+				setHeroImage(hs[i].getImage,i)
+				setHeroEnergy(hs[i],i)
+			else
+				setHero(false,i)
+				setHeroImage(getTextureCache.get(&quot;data/gui/portraits/none.png&quot;),i)
+				setHeroName(&quot;&quot;,i)
+			end
+		end
+		# init Handlers of Buttons
+		if first
+			addHandler(@layout.getChild(&quot;antButtonPanel&quot;),:sigAggressionChanged,:eventAggressionChanged)
+			for i in 0..2
+				addHandler(@layout.getChild(&quot;hero#{i}&quot;),:sigClick,:eventHeroButton)
+			end
+			setupNames
+			
+			# center hero and select
+	 		if hs.length&gt;0
+	 			h=hs[0]
+	 			selectHero(h)
+ 				focusHero(h)
+				@layout.getChild(&quot;hero0&quot;).setChecked(true)
+ 			end
+			
+		end
+		checkHeroEnergy
+	end
+
+	# updates the energy displays of the heroes (if needed)
+	def checkHeroEnergy
+		name=nil
+		# FIXME: support more than 1 hero !
+		getMap.getPlayer.getHeroes.each{|h|
+			if h.getEnergy&lt;0.3
+				name=h.getName
+			end
+		}
+		if @infobox.nil? and name
+			@layout.addChild(@infobox=AntInfoBox.new(@layout,_(&quot;Your hero {1} suffers.&quot;,name)))
+		elsif @infobox and name.nil?
+			@infobox.close
+			@infobox=nil
+		end
+	end
+
+	# sets a new result
+	def setResult(r)
+		@result=r
+	end
+	
+	# returns boolean about the visibility of the panel
+	def panelVisible
+		@layout.getChild(&quot;SideBar&quot;).visible
+	end
+
+	def showPanel
+		sideBar=@layout.getChild(&quot;SideBar&quot;)
+		sideBarRight=@layout.getChild(&quot;SideBarRight&quot;)
+		sideBar.show
+		@controls=true
+		# reset Scene's width
+		getScene.getCameraObject.setWidth((getScreen.getWidth-sideBarRight.width).to_i)
+	end
+	def hidePanel
+		@layout.getChild(&quot;SideBar&quot;).hide
+		@controls=false
+		# reset Scene's width
+		getScene.getCameraObject.setWidth(getScreen.getWidth)
+	end
+
+
+	def tellStory(flow)
+		getMap.pause=true
+		hidePanel
+		if @story.nil?
+			@story=AntStoryTalk.new(@layout)
+		end
+		@layout.addChild(@story)
+		assert{@story.getApp}
+		@story.show
+		@story.setFlow(flow)
+		addHandler(@story,:sigStoryFinished,:eventStoryTalkFinished)
+	end
+
+	def inspectEntity(e)
+		if @inspect
+			#if @inspect.is_a?(AntBoss)
+				@inspect.selected=false
+			#end
+		end
+		@inspect=e
+		if @inspect
+			#if @inspect.is_a?(AntBoss)
+				@inspect.selected=true
+			#end
+		end
+		AntInventory.inspectEntity(e)
+	end
+
+	def resetJob
+		#@job=nil
+		@layout.getChild(&quot;doBuild&quot;).setChecked(false)
+	end
+
+	def getSelectedHero
+		@hero
+	end
+
+	def selectHero(h)
+		@hero=h
+		inspectEntity(h)
+		@buttonpanel.setHero(h)
+
+		for i in 0..2
+			if @layout.getChild(&quot;HeroName#{i}&quot;).getText.to_s==h.getName
+				@layout.getChild(&quot;hero#{i}&quot;).setChecked(true)
+			end
+		end
+
+		# set hero's aggression
+		@buttonpanel.setAggression(@hero.getAggression)
+	end
+
+	def getHeroByNum(n)
+		getMap.getOwnHeroes[n]
+	end
+
+	# views an information window about the entity ent
+	def viewInformation(ent)
+		win=AntInspectWindow.new(@layout,ent)
+		@layout.addChild(win)
+	end
+
+end
+
+
+# this function is only for starting a level directly (single map from the mainmenu or from cli)
+# you can start BoA from the cli by giving a level-name directly
+# For more information on that topic please refer to link:files/ruby/debugging/README.html
+def startGame(file=&quot;savegames/savegame0.antlvl&quot;,clientConnection=nil)
+	app=nil
+	if clientConnection
+		app=AntGameApp.new(file,getVideo.width,getVideo.height,nil,clientConnection)
+	else
+		app=AntGameApp.new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
+	end
+	#app.disableGC
+	app.run
+	result=app.result
+	# result all globals
+	app=nil
+	$map=nil
+	$app=nil
+	$screen=nil
+	# run garbage collector
+	startGC
+	return result
+end
+
+

Modified: antargis/trunk/ruby/intro.rb
===================================================================
--- antargis/trunk/ruby/intro.rb	2008-02-02 16:51:48 UTC (rev 1226)
+++ antargis/trunk/ruby/intro.rb	2008-02-05 20:13:13 UTC (rev 1227)
@@ -155,11 +155,3 @@
 	end
 	
 end
-# 
-# app=IntroApp.new
-# 
-# 
-# if getConfig.get(&quot;intro&quot;)!=&quot;false&quot;
-#   app.run
-# end
-# require 'ruby/mainmenu.rb'

Modified: antargis/trunk/ruby/mainmenu.rb
===================================================================
--- antargis/trunk/ruby/mainmenu.rb	2008-02-02 16:51:48 UTC (rev 1226)
+++ antargis/trunk/ruby/mainmenu.rb	2008-02-05 20:13:13 UTC (rev 1227)
@@ -21,7 +21,7 @@
 require 'ruby/antargislib.rb'
 $useMenu=true
 
-require &quot;run_game.rb&quot;
+require &quot;ant_application.rb&quot;
 require 'campaign.rb'
 require 'credits.rb'
 

Deleted: antargis/trunk/ruby/run_game.rb
===================================================================
--- antargis/trunk/ruby/run_game.rb	2008-02-02 16:51:48 UTC (rev 1226)
+++ antargis/trunk/ruby/run_game.rb	2008-02-05 20:13:13 UTC (rev 1227)
@@ -1,681 +0,0 @@
-#!/usr/bin/env ruby
-#--
-# Copyright (c) 2005 by David Kamphausen. All rights reserved.
-#
-# game.rb
-# by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
-#
-# The &quot;Antargis&quot; project, including all files needed to compile it,
-# is free software; you can redistribute it and/or use it and/or modify it
-# under the terms of the GNU General Public License as published
-# by the Free Software Foundation; either version 2 of the License,
-# or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-#
-# You should have received a copy of the GNU General Public
-# License along with this program.
-#++
-#
-# antargis.rb is the central file in antargis-level-playing.
-# it contains the main-application class AntGameApp for in-game looping, etc.
-# most of the GUI-events are processed here.
-#
-
-
-# add programdir to path
-$programDir=File.split(__FILE__)[0]
-$:.push($programDir)
-$:.push(File.join($programDir,&quot;entities&quot;))
-$:.push(File.join($programDir,&quot;widgets&quot;))
-
-require 'antargislib.rb'
-require 'dialogs.rb'
-require 'entities.rb'
-require 'map.rb'
-require 'view.rb'
-require 'game_result.rb'
-require 'storyflow.rb'
-require 'mpmap.rb'
-
-require 'pp'
-
-# get save path where savegames are stored
-# NOTE: this is combined with getWriteDir from ag_fs.h !
-def getSavePath
-	&quot;savegames&quot;
-end
-
-#
-# AntGameApp is the central application-class in game. It controls:
-# * event handling of all the user interaction
-# * holds all the game-objects
-# * calls the advance-function in each frame
-# * it's derived from AntRubyView, which implements/manages the (3d-)displaying in-game
-#
-class AntGameApp &lt;AntRubyView
-	attr_accessor :result
-	attr_reader :hero
-
-	include AGHandler
-
-	# creating an AntGameApp-object needs the following parameters:
-	# * *savegameText* - this is the actual level serialized in a string (the xml-text you see when you open an .antlvl-file)
-	#   it contains the height- and terrain-map, too. This has the advantage, that everything about a level is stored in one
-	#   text and can thus be transfered easily over internet 
-	# * *w* and *h* are the width and height of the screen, which is currently needed to init the underlying GLApp-class from C++
-	#   *FIXME:* this could be replaced by a call to getMain.getVideo.getWidth and such
-	# * *loadscreen* is a LoadApp-object (or nil); if it's set that indicates that a loadscreen (a progress bar) is displayed
-	# * *connection* is a network-connection to a BoA multiplayer-server for future networking-support. link:files/ruby/multiplayer/README.html
-	#
-	# this function does all the initializing of a level:
-	# * from the super-classes: create a scene (for more go to the parent-class)
-	# * display a load-screen (and set the progress)
-	# * create a AntMpMap object
-	# * create a displaying layout from data/gui/layout/ant_layout.xml
-	# * initializes some event-handlers (glue code between level-displaying and the game-world object of type AntMpMap
-	# * load the map fom *savegameText*
-	# * setup of the hero-display-list at the top of the screen
-	def initialize(savegameText,w,h,loadscreen=nil,connection=nil)
-		super(w,h)
-
-		@speed=1
-
-		# the result of the level - won or lost or canceled
-		@result=GameResult.new
-		$app=self
-		AntSound.setApplication(self)
-	
-		# display loading screen
-		if loadscreen
-			loadscreen.setValue(0.1)
-			loadscreen.tick
-		end
-
-		playerName=nil
-
-		# init network mode
-		@connection=connection
-		if connection
-			# FIXME: check, if this is a server - then don't assign playerName
-			playerName=connection.getName
-		end
-
-		# init game-engine's map
-		@map=AntMpMap.new(connection,self,getScene,32,32,playerName) # some small dummy size - gets overriden by loadMap anyway
-		if loadscreen
-			loadscreen.setValue(0.4)
-			loadscreen.tick
-		end
-
-		# load GUI layout
-		@layout=AGLayout.new(nil)
-		@layout.setApp(self)
-		assert{@layout.getApp}
-		@layout.loadXML(loadFile(&quot;data/gui/layout/ant_layout.xml&quot;))
-	
-
-		# init pointers to different displays
-		# statusBar (FPS display)
-		@statusBar=@layout.getChild(&quot;statusBar&quot;)
-		@inventory=@layout.getChild(&quot;inventory&quot;)
-		@buttonpanel=@layout.getChild(&quot;antButtonPanel&quot;)
-
-		@miniMap=@layout.getChild(&quot;miniMap&quot;)
-		@fps=0
-
-		setMainWidget(@layout)
-		addHandler(@layout.getChild(&quot;quit&quot;),:sigClick,:eventQuit)
-		addHandler(@layout.getChild(&quot;pause&quot;),:sigClick,:eventPause)
-		addHandler(@layout.getChild(&quot;options&quot;),:sigClick,:eventOptions)
-
-		if loadscreen
-			loadscreen.setValue(0.5)
-			loadscreen.tick
-		end
-	
-		if @miniMap
-			# connect MiniMap with Map for displaying terrain and entities
-			@miniMap.setMap(@map)
-			# connect MiniMap with Scene for displaying frustrum
-			@miniMap.setScene(getScene)
-		end
-
-		if loadscreen
-			loadscreen.setValue(0.8)
-			loadscreen.tick()
-		end
-		
-		if savegameText &amp;&amp; savegameText.length&gt;0
-			# load a level
-			@map.loadMapFromMemory(savegameText)
-		end	
-
-		if loadscreen
-			loadscreen.setValue(0.95)
-			loadscreen.tick
-		end
-
-		# inventory and buttonpanel signals
-		addHandler(@inventory,:sigJobChanged,:eventInventoryJob)
-		addHandler(@buttonpanel,:sigJobChanged,:eventHeroJob)
-
-		setupHeroDisplay(true)
-
-		# infobox is used for display a text &quot;Your hero 'xy' suffers&quot;
-		@infobox=nil
-
-		# frame counting
-		@frameCount=0
-		@elapsTime=0
-
-		#setCursor(getTextureCache.get(&quot;blue_cursor.png&quot;))
-	end
-
-	####################################
-	# EVENT HANDLERS
-	####################################
-
-	include AntMyEventHandler
-
-
-	# this handler is for the buttonpanel on the top
-	# the actions are direct ones, like rest,dimiss and so, which don't need an object to use (like fighting,taking,...)
-	def eventHeroJob(e)
-		case @buttonpanel.job
-			when &quot;doDismiss&quot;
-				# opens a query dialog &quot;do really want to do this?&quot;, that is given a block, that's executed on confirmation
-				@layout.addChild(AntQueryDialog.new(@layout,nil) {@hero.newHLDismissJob})
-			when &quot;doRest&quot;
-				if @hero
-					@hero.newHLRestJob(10)
-				end
-			when &quot;doBuild&quot;
-				@job=&quot;doBuild&quot;
-		end
-		return true
-	end
-
-	# react to inventory-based jobs - like taking, recruiting
-
-	def eventInventoryJob(e)
-		if @target.nil? #some more overview as
-			log &quot;NO TARGET SELECTED&quot;
-		else
-			case @inventory.job
-				when &quot;doRecruit&quot;
-					@hero.newHLRecruitJob(@target)
-				when &quot;doTakeFood&quot;
-					@hero.newHLTakeFoodJob(@target)
-				when &quot;doTakeWeapons&quot;
-					@hero.newHLTakeWeaponJob(@target)
-				when &quot;doConstruct&quot;
-					@hero.newHLConstructJob(@target)
-				when &quot;doUpgrade&quot;
-					@hero.upgradeMan(@target)
-				when &quot;doContinue&quot;
-					@hero.newHLBuildJob(@target,nil)
-				when &quot;doSupport&quot;
-					targetsTarget=nil
-					if @target.getJob.is_a?(AntHeroFightJob)
-						targetsTarget=@target.getJob.target
-					end
-					if targetsTarget
-						@hero.newHLFightJob(targetsTarget)
-					end
-			end
-		end
-		return true
-	end
-
-	def eventKeyDown(e)
-
-		# hero-selection by pressing F1 to F7
-		hero={	SDLK_F1=&gt;0,
-			SDLK_F2=&gt;1,
-			SDLK_F3=&gt;2,
-			SDLK_F4=&gt;3,
-			SDLK_F5=&gt;4,
-			SDLK_F6=&gt;5,
-			SDLK_F7=&gt;6}[e.getKey]
-		if hero
-			h=getHeroByNum(hero) 
-			if h
-				if @hero==h
-					focusHero(h)
-				end
-				selectHero(h)
-				return super(e)
-			end
-		end
-
-		
-		case e.getKey
-			when SDLK_F9 # F9 toggles panel on the right
-				if not panelVisible
-					showPanel
-				else
-					hidePanel
-				end
-			when SDLK_F8
-				@sceneEnabled=(not @sceneEnabled)
-				getScene.setEnabled(@sceneEnabled)
-			when SDLK_F1
-				hero=1
-			when SDLK_ESCAPE
-				if @hero
-					@hero.newHLRestJob(10)
-				end
-			when SDLK_PLUS
-				@speed=[@speed+1,10].min
-			when SDLK_MINUS
-				@speed=[@speed-1,0.2].max
-			
-			when SDLK_p
-				eventPause(nil)
-		end
-		return super(e)
-	end
-	
-	def eventStoryTalkFinished
-		showPanel
-		getMap.trigger(nil,Trigger.new(&quot;storyFinished&quot;))
-	end
-
-	def moveMap(time)
-		granularity=0.2
-		while time&gt;granularity
-			getMap().move(granularity)
-			time-=granularity
-		end
-		getMap().move(time)
-	end
-
-	def eventFrame(time)
-		super(time)
-
-		# FPS display
-		if @frameCount&gt;14 then
-			@fps=@frameCount / @elapsTime
-			fps=&quot;&quot;
-			if @fps&lt;10
-				fps=sprintf(&quot;%3.2f&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at fps</A>)
-			else
-				fps=sprintf(&quot;%3.0f&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at fps</A>)
-			end
-			@statusBar.setText(_(&quot;FPS:{1}&quot;,fps.to_s))
-			@frameCount=0
-			@elapsTime=0
-			startGC
-		end
-		@frameCount+=1
-		@elapsTime+=time
-
-
-# 		# move entities in game-engine
-		#getMap().move(time*@speed)
-		moveMap(time*@speed)
-
-		# advance animations
-		getScene.advance(time)
-		checkHeroEnergy
-
-		processMessages
-
-		# save some CPU-power, if available
-		if @connection
-			delay(20)
-		end
-
-		if @fps&gt;25
-			delay(5)
-		end
-		return true
-	end
-	
-	def eventQuit(e)
-		@layout.addChild(AntQuitDialog.new(@layout))
-		return true
-	end
-	def eventPause(e)
-		if not getMap().pause then
-			@layout.addChild(AntPauseDialog.new(@layout))
-		else
-			getMap.pause=false
-		end
-		return true
-	end
-	def eventOptions(e)
-		@layout.addChild(AntOptionsDialog.new(@layout))
-		return true
-	end
-	def eventHeroButton(e)
-		c=e.getCaller.getName
-		num=c[4..4]
-		name=@layout.getChild(&quot;HeroName#{num}&quot;).getText.to_s
-		ent=getMap.getByName(name)
-		selectHero(ent)
-		if ent==@inspect
-			focusHero(ent)
-		end
-		inspectEntity(ent)
-		return true
-
-	end
-
-	def eventAggressionChanged(e)
-		h=getSelectedHero
-		if h
-			h.setAggression(@buttonpanel.getAggression)
-		end
-		return true
-	end
-
-	def eventEntitiesClicked(list,button)
-		resetJob
-		# find first entity that's nearest to the camera
-		ent=nil
-		list.each{|node|
-			mesh=node.node
-			if [Mesh,AnimMesh,Mesh2D].member?(mesh.class)
-				ent=getMap.getEntity(mesh)
-				break if ent
-			end
-		}
-
-		# if an entity was found - set new target
-		if ent
-			if ent.class==AntHero and ent.getPlayer==getMap.getPlayer
-				#@hero=ent
-				@target=ent
-				inspectEntity(ent)
-			else
-				@target=ent
-				inspectEntity(ent)
-			end
-		end
-
-		if button==1
-			# left button == select
-		elsif button==3
-			# right button == fight or goto
-			if ent==@target
-				if @target.is_a?(AntBoss)
-					if @target.getPlayer!=@hero.getPlayer
-						@hero.newHLFightJob(@target)
-						return
-					end
-				elsif @target.is_a?(AntAnimal)
-					@hero.newHLFightAnimalJob(@target)
-					return
-				end
-				# move near target
-				@hero.newHLMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at target.getPos2D</A>,2)
-			end
-		end
-	end
-
-	def eventMapClicked(pos,button)
-		if @job and button==1 then
-			case @job
-				when &quot;doBuild&quot;
-					buildHouse(pos.dim2)
-					@job=nil
-			end
-			resetJob
-			return
-		end
-		if @hero and button==3 then
-			# assign hero a move job
-			@hero.newHLMoveJob(0,pos,0)
-		end
-	end
-
-
-	###############################
-	# simple functions
-	###############################
-
-	def getMap
-		@map
-	end
-
-	def processMessages
-		if @connection
-			while message=@connection.getMessage
-				@map.processMessage(message)
-			end
-		end
-	end
-
-	def buildHouse(pos)
-		@layout.addChild(AntBuildDialog.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">layout,pos, at hero</A>))
-	end
-	
-	def save
-		if $campaign
-			@layout.addChild(AntSaveCampaignDialog.new(@layout))
-		else
-			@layout.addChild(AntSaveDialog.new(@layout))
-		end
-	end
-	def load
-		@layout.addChild(AntLoadDialog.new(@layout))
-	end
-	def videoOptions
-		@layout.addChild(AntVideoOptionsDialog.new(@layout))
-	end
-	def audioOptions
-		@layout.addChild(AntAudioOptionsDialog.new(@layout))
-	end
-
-	###############################################################
-	# Setting up of Hero displays (images, texts and eventHandlers
-	###############################################################
-
-	def setHeroImage(image,num)
-		@layout.getChild(&quot;HeroImage#{num}&quot;).setTexture(image)
-	end
-	def setHeroName(name,num)
-		@layout.getChild(&quot;HeroName#{num}&quot;).setText(_(name))
-		c=@layout.getChild(&quot;HeroBar#{num}&quot;)
-		raise 1 if c.nil?
-		c.setVisible((name!=&quot;&quot;))
-	end
-	def setHeroEnergy(hero,num)
-		@layout.getChild(&quot;HeroBar#{num}&quot;).setHero(hero)
-	end
-	def setHero(flag,num)
-		name=&quot;hero#{num}&quot;
-		c=@layout.getChild(name)
-		c.setEnabled(flag)
-		c.setVisible(flag)
-	end
-	def setupHeroDisplay(first=false)
-		#super
-		# setup Hero buttons
-		hs=getMap.getPlayer.getHeroes
-		for i in 0..5
-			if hs.length&gt;i
-				setHero(true,i)
-				setHeroName(hs[i].getName,i)
-				setHeroImage(hs[i].getImage,i)
-				setHeroEnergy(hs[i],i)
-			else
-				setHero(false,i)
-				setHeroImage(getTextureCache.get(&quot;data/gui/portraits/none.png&quot;),i)
-				setHeroName(&quot;&quot;,i)
-			end
-		end
-		# init Handlers of Buttons
-		if first
-			addHandler(@layout.getChild(&quot;antButtonPanel&quot;),:sigAggressionChanged,:eventAggressionChanged)
-			for i in 0..2
-				addHandler(@layout.getChild(&quot;hero#{i}&quot;),:sigClick,:eventHeroButton)
-			end
-			setupNames
-			
-			# center hero and select
-	 		if hs.length&gt;0
-	 			h=hs[0]
-	 			selectHero(h)
- 				focusHero(h)
-				@layout.getChild(&quot;hero0&quot;).setChecked(true)
- 			end
-			
-		end
-		checkHeroEnergy
-	end
-
-	# updates the energy displays of the heroes (if needed)
-	def checkHeroEnergy
-		name=nil
-		# FIXME: support more than 1 hero !
-		getMap.getPlayer.getHeroes.each{|h|
-			if h.getEnergy&lt;0.3
-				name=h.getName
-			end
-		}
-		if @infobox.nil? and name
-			@layout.addChild(@infobox=AntInfoBox.new(@layout,_(&quot;Your hero {1} suffers.&quot;,name)))
-		elsif @infobox and name.nil?
-			@infobox.close
-			@infobox=nil
-		end
-	end
-
-	# sets a new result
-	def setResult(r)
-		@result=r
-	end
-	
-	# returns boolean about the visibility of the panel
-	def panelVisible
-		@layout.getChild(&quot;SideBar&quot;).visible
-	end
-
-	def showPanel
-		sideBar=@layout.getChild(&quot;SideBar&quot;)
-		sideBarRight=@layout.getChild(&quot;SideBarRight&quot;)
-		sideBar.show
-		@controls=true
-		# reset Scene's width
-		getScene.getCameraObject.setWidth((getScreen.getWidth-sideBarRight.width).to_i)
-	end
-	def hidePanel
-		@layout.getChild(&quot;SideBar&quot;).hide
-		@controls=false
-		# reset Scene's width
-		getScene.getCameraObject.setWidth(getScreen.getWidth)
-	end
-
-
-	def tellStory(flow)
-		getMap.pause=true
-		hidePanel
-		if @story.nil?
-			@story=AntStoryTalk.new(@layout)
-		end
-		@layout.addChild(@story)
-		assert{@story.getApp}
-		@story.show
-		@story.setFlow(flow)
-		addHandler(@story,:sigStoryFinished,:eventStoryTalkFinished)
-	end
-
-	def inspectEntity(e)
-		if @inspect
-			#if @inspect.is_a?(AntBoss)
-				@inspect.selected=false
-			#end
-		end
-		@inspect=e
-		if @inspect
-			#if @inspect.is_a?(AntBoss)
-				@inspect.selected=true
-			#end
-		end
-		AntInventory.inspectEntity(e)
-	end
-
-	def resetJob
-		#@job=nil
-		@layout.getChild(&quot;doBuild&quot;).setChecked(false)
-	end
-
-	def getSelectedHero
-		@hero
-	end
-
-	def selectHero(h)
-		@hero=h
-		inspectEntity(h)
-		@buttonpanel.setHero(h)
-
-		for i in 0..2
-			if @layout.getChild(&quot;HeroName#{i}&quot;).getText.to_s==h.getName
-				@layout.getChild(&quot;hero#{i}&quot;).setChecked(true)
-			end
-		end
-
-		# set hero's aggression
-		@buttonpanel.setAggression(@hero.getAggression)
-	end
-
-	def getHeroByNum(n)
-		getMap.getOwnHeroes[n]
-	end
-
-	# views an information window about the entity ent
-	def viewInformation(ent)
-		win=AntInspectWindow.new(@layout,ent)
-		@layout.addChild(win)
-	end
-
-end
-
-
-# this function is only for starting a level directly (single map from the mainmenu or from cli)
-# you can start BoA from the cli by giving a level-name directly
-# For more information on that topic please refer to link:files/ruby/debugging/README.html
-def startGame(file=&quot;savegames/savegame0.antlvl&quot;,clientConnection=nil)
-	app=nil
-	if clientConnection
-		app=AntGameApp.new(file,getVideo.width,getVideo.height,nil,clientConnection)
-	else
-		app=AntGameApp.new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
-	end
-	#app.disableGC
-	app.run
-	result=app.result
-	# result all globals
-	app=nil
-	$map=nil
-	$app=nil
-	$screen=nil
-	# run garbage collector
-	startGC
-	return result
-end
-
-
-# code for starting a level directly from command-line like this:
-# ./ruby/run_game.rb levels/birth1
-# or
-# ./ruby/run_game.rb savegames/savegame0
-$useMenu||=false
-if true
-	savegame=&quot;&quot;
-	ARGV.each{|arg|
-		if arg=~/levels.*/ or arg=~/savegames.*/
-			savegame=arg+&quot;.antlvl&quot;
-		end
-	}
-	if savegame!=&quot;&quot;
-		startGame(savegame)	
-	end
-end
-
-getConfig.set(&quot;ok&quot;,&quot;ok&quot;)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000183.html">[Antargis-svn] r1226 - in antargis/trunk/ext: 3dengine video
</A></li>
	<LI>Next message: <A HREF="000185.html">[Antargis-svn] r1228 - in antargis/trunk: ext/3dengine ext/basic	ext/game ext/gui ext/math ext/sound ext/test ext/video ruby	ruby/entities ruby/gui ruby/spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#184">[ date ]</a>
              <a href="thread.html#184">[ thread ]</a>
              <a href="subject.html#184">[ subject ]</a>
              <a href="author.html#184">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/antargis-svn">More information about the Antargis-svn
mailing list</a><br>
</body></html>
