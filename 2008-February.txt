From davidkamphausen at mail.berlios.de  Sat Feb  2 17:51:48 2008
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 2 Feb 2008 17:51:48 +0100
Subject: [Antargis-svn] r1226 - in antargis/trunk/ext: 3dengine video
Message-ID: <200802021651.m12Gpm7Y017393@sheep.berlios.de>

Author: davidkamphausen
Date: 2008-02-02 17:51:48 +0100 (Sat, 02 Feb 2008)
New Revision: 1226

Modified:
   antargis/trunk/ext/3dengine/ant_renderer.cc
   antargis/trunk/ext/video/ag_gltexture.cc
Log:
* workaroung for macos/x

Modified: antargis/trunk/ext/3dengine/ant_renderer.cc
===================================================================
--- antargis/trunk/ext/3dengine/ant_renderer.cc	2008-01-31 20:08:48 UTC (rev 1225)
+++ antargis/trunk/ext/3dengine/ant_renderer.cc	2008-02-02 16:51:48 UTC (rev 1226)
@@ -43,7 +43,7 @@
   shadowInited=false;
 
   if(!GLEE_EXT_texture3D)
-    std::cerr<<"Sorry, Battles of Antargis won't work without GL_EXT_texture3D extension!"<<std::endl;
+    std::cerr<<"Sorry, Battles of Antargis won't work properly without GL_EXT_texture3D extension!"<<std::endl;
 }
 
 Renderer::~Renderer()

Modified: antargis/trunk/ext/video/ag_gltexture.cc
===================================================================
--- antargis/trunk/ext/video/ag_gltexture.cc	2008-01-31 20:08:48 UTC (rev 1225)
+++ antargis/trunk/ext/video/ag_gltexture.cc	2008-02-02 16:51:48 UTC (rev 1226)
@@ -32,137 +32,140 @@
 
 AGGLTexture::AGGLTexture(size_t W,size_t H,GLint format):w(W),h(H),d(1),m3d(false)
 {
-  assertGL;
-  getSurfaceManager()->registerMe(this);
-  assertGL;
-  glGenTextures( 1, &mID);
-  assertGL;
-  glBindTexture( GL_TEXTURE_2D,mID);
-  assertGL;
+	assertGL;
+	getSurfaceManager()->registerMe(this);
+	assertGL;
+	glGenTextures( 1, &mID);
+	assertGL;
+	glBindTexture( GL_TEXTURE_2D,mID);
+	assertGL;
 
-  glTexImage2D(GL_TEXTURE_2D, 0, format, w, h, 0, GL_RGBA,
-               GL_UNSIGNED_BYTE, 0);
+	glTexImage2D(GL_TEXTURE_2D, 0, format, w, h, 0, GL_RGBA,
+			GL_UNSIGNED_BYTE, 0);
 
-  assertGL;
-  gUsedTexMemory+=w*h*4;
+	assertGL;
+	gUsedTexMemory+=w*h*4;
 
-  dbout(4,"used memory:"<<gUsedTexMemory);
+	dbout(4,"used memory:"<<gUsedTexMemory);
 
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-  assertGL;
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-  assertGL;
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+	assertGL;
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	assertGL;
 }
 AGGLTexture::AGGLTexture(size_t W,size_t H,size_t D,GLint format):w(W),h(H),d(D),m3d(true)
 {
-  assertGL;
-  getSurfaceManager()->registerMe(this);
-  assertGL;
+	assertGL;
+	getSurfaceManager()->registerMe(this);
+	assertGL;
 
-  glGenTextures( 1, &mID);
-  assertGL;
-  glBindTexture( GL_TEXTURE_3D,mID);
-  assertGL;
+	glGenTextures( 1, &mID);
+	assertGL;
+	glBindTexture( GL_TEXTURE_3D,mID);
+	assertGL;
 
-  glTexImage3D(GL_TEXTURE_3D, 0, format, w, h, d, 0, GL_RGBA,
-               GL_UNSIGNED_BYTE, 0);
-  assertGL;
+	//w=h=128;
+	//d=2;
 
-  gUsedTexMemory+=w*h*d*4;
-  dbout(4,"used memory:"<<gUsedTexMemory);
+	glTexImage3D(GL_TEXTURE_3D, 0, format, w, h, d, 0, GL_RGBA,
+			GL_UNSIGNED_BYTE, 0);
+	assertGL;
 
-  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-  assertGL;
-  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-  assertGL;
+	gUsedTexMemory+=w*h*d*4;
+	dbout(4,"used memory:"<<gUsedTexMemory);
+
+	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+	assertGL;
+	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	assertGL;
 }
 
 AGGLTexture::~AGGLTexture()
 {
-  assertGL;
-  glDeleteTextures(1,&mID);
+	assertGL;
+	glDeleteTextures(1,&mID);
 
-  if(m3d)
-    gUsedTexMemory-=w*h*d*4;
-  else
-    gUsedTexMemory-=w*h*4;
+	if(m3d)
+		gUsedTexMemory-=w*h*d*4;
+	else
+		gUsedTexMemory-=w*h*4;
 
-  assertGL;
-  getSurfaceManager()->deregisterMe(this);
+	assertGL;
+	getSurfaceManager()->deregisterMe(this);
 }
 
 void AGGLTexture::setSurface(AGInternalSurface *pSurface,const AGVector2 &offset)
 {
-  assertGL;
-  GLint format;
+	assertGL;
+	GLint format;
 
-  SDL_Surface *surface=pSurface->surface;
+	SDL_Surface *surface=pSurface->surface;
 
-  switch(surface->format->BytesPerPixel)
-    {
-    case 3:
-      format = GL_RGB;break;
-    case 4:
-      format = GL_RGBA;break;
-    default:
-      throw std::runtime_error("Surface-format not supported for texturing!");
-    }
+	switch(surface->format->BytesPerPixel)
+	{
+	case 3:
+		format = GL_RGB;break;
+	case 4:
+		format = GL_RGBA;break;
+	default:
+		throw std::runtime_error("Surface-format not supported for texturing!");
+	}
 
-  AGRenderContext c;
-  c.setTexture(this);
-  c.begin();
-  assertGL;
-  
-  /*
+	AGRenderContext c;
+	c.setTexture(this);
+	c.begin();
+	assertGL;
+
+	
   glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
   assertGL;
   glPixelStorei(GL_UNPACK_ROW_LENGTH,
                 surface->pitch / surface->format->BytesPerPixel);
-  */
+	 
 
-  if(m3d)
-    {
-      int mw=std::min(surface->w,surface->h);
-      int mh=std::max(surface->w,surface->h)/mw;
-SDL_SaveBMP(surface,"terrain.bmp");
-	cdebug("OFFSET:"<<offset);
-	cdebug("size:"<<mw<<","<<mw<<";"<<mh<<(int)(format==GL_RGBA));
-    glTexSubImage3D(GL_TEXTURE_3D,0,int(offset[0]),int(offset[1]),0,
-		      mw,mw,mh,format,GL_UNSIGNED_BYTE,surface->pixels);
-    std::cout<<("PIXELFORMAT:")<<surface->format<<std::endl;
-//    glTexSubImage3D(GL_TEXTURE_3D,0,int(offset[0]),int(offset[1]),0,
-//		      mw,mw,mh,format,GL_UNSIGNED_BYTE,surface->pixels);
-    }
-  else
-    {
-      assertGL;
-      
-      glTexSubImage2D(GL_TEXTURE_2D, 0, int(offset[0]), int(offset[1]),
-		      surface->w, surface->h, format, GL_UNSIGNED_BYTE,
-		      surface->pixels);
-    }
-  assertGL;
+	assertGL;
+	if(m3d)
+	{
+		assert(glIsEnabled(GL_TEXTURE_3D));
+		int mw=std::min(surface->w,surface->h);
+		int mh=std::max(surface->w,surface->h)/mw;
+
+	//	glTexImage3D(GL_TEXTURE_3D, 0, format, w, h, d, 0, GL_RGBA,
+	//			GL_UNSIGNED_BYTE, surface->pixels);
+	    glTexSubImage3D(GL_TEXTURE_3D,0,int(offset[0]),int(offset[1]),0,
+				      mw,mw,mh,format,GL_UNSIGNED_BYTE,surface->pixels);
+	}
+	else
+	{
+		assertGL;
+
+		glTexSubImage2D(GL_TEXTURE_2D, 0, int(offset[0]), int(offset[1]),
+				surface->w, surface->h, format, GL_UNSIGNED_BYTE,
+				surface->pixels);
+	}
+	assertGL;
+	AGRenderContext().begin();
 }
 
 GLuint AGGLTexture::id()
 {
 
-  return mID;
+	return mID;
 }
 bool AGGLTexture::is3d() const
 {
-  return m3d;
+	return m3d;
 }
 
 size_t AGGLTexture::width() const
 {
-  return w;
+	return w;
 }
 size_t AGGLTexture::height() const
 {
-  return h;
+	return h;
 }
 size_t AGGLTexture::depth() const
 {
-  return d;
+	return d;
 }



From davidkamphausen at mail.berlios.de  Tue Feb  5 21:13:14 2008
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Tue, 5 Feb 2008 21:13:14 +0100
Subject: [Antargis-svn] r1227 - in antargis/trunk: . ext/video ruby
Message-ID: <200802052013.m15KDEUi031895@sheep.berlios.de>

Author: davidkamphausen
Date: 2008-02-05 21:13:13 +0100 (Tue, 05 Feb 2008)
New Revision: 1227

Added:
   antargis/trunk/ruby/ant_application.rb
Removed:
   antargis/trunk/ruby/run_game.rb
Modified:
   antargis/trunk/TODO
   antargis/trunk/antargis
   antargis/trunk/ext/video/ag_gltexture.cc
   antargis/trunk/ruby/intro.rb
   antargis/trunk/ruby/mainmenu.rb
Log:
* more specs on tutorial

Modified: antargis/trunk/TODO
===================================================================
--- antargis/trunk/TODO	2008-02-02 16:51:48 UTC (rev 1226)
+++ antargis/trunk/TODO	2008-02-05 20:13:13 UTC (rev 1227)
@@ -1,26 +1,19 @@
-* checkin editor !
+* bug-report at apple site on glTexSubImage issue 
+* fix shadows on mac (on shadow-extension ?)
+* check mingw on macosx
 
-* check for ccache in configure and only use it if available!
-
-
 * fix saving - problem occurs only if game is loaded ? (in editor, too)
+** hljobs can't be saved right now
+
 * move build/*.rb files to build/unused_tools/* if they're not used
 * google for "/tmp/cciSLVG5.s:932678: Warning: .stabs: description field '1c216' too big, try a different debug format"
 
-
 * check how many times AG_NewPointer is called !!!! - not so often - could be replaced by traceobjects from swig
 ** check if it's any good to switch over to standard-swig ??? seems so.
 
 !!! AGTexture - not wrapped correctly in bliTri etc ???
 
 
-* check swig-wrapping of: 
-	AGCollector *getCollector (basic/ag_collector.h)
-	AGEXPORT AGConfig *getConfig();
- std::Vector<SceneNode*>
- std::vector<AntEntity*> (game)
-path.h - don't export path-internals to ruby
-
 * moveto doesn't really work with "near" (hljob)
 * heroes don't die in reasonable fashion - starving men too
 * add seasons
@@ -31,10 +24,9 @@
 * why is the story-telling dialog eating up clicks ?
 * improve settings-dialog!
 * check level-editor
+** make wish-list
 
-* saving - hljobs !!
 * check dep-handling with swig
-* implement last hl-jobs 
 * move single entities with path-finder, too?
 
 * docs
@@ -45,8 +37,6 @@
  * antargis.iss
 
 
-
-
 * check if reachable before fetching !!! (in house) - or even better use heuristic for estimating distance in getNear(...)
 * fix jobs some more
 * what's wrong with pathfinding-test ???

Modified: antargis/trunk/antargis
===================================================================
--- antargis/trunk/antargis	2008-02-02 16:51:48 UTC (rev 1226)
+++ antargis/trunk/antargis	2008-02-05 20:13:13 UTC (rev 1227)
@@ -8,11 +8,36 @@
 require 'ruby/mainmenu.rb'
 
 
+
+# code for starting a level directly from command-line like this:
+# ./ruby/run_game.rb levels/birth1
+# or
+# ./ruby/run_game.rb savegames/savegame0
+$useMenu||=false
+if true
+  savegame=""
+  ARGV.each{|arg|
+    if arg=~/levels.*/ or arg=~/savegames.*/
+      savegame=arg+".antlvl"
+    end
+  }
+  if savegame!=""
+    startGame(savegame) 
+    exit
+  end
+end
+
 if getConfig.get("intro")!="false"
-	app=IntroApp.new
-	app.run
+  app=IntroApp.new
+  app.run
 end
 
+
+
+getConfig.set("ok","ok")
+
+
+
 # run menu
 app=AntMenuApp.new
 app.run

Modified: antargis/trunk/ext/video/ag_gltexture.cc
===================================================================
--- antargis/trunk/ext/video/ag_gltexture.cc	2008-02-02 16:51:48 UTC (rev 1226)
+++ antargis/trunk/ext/video/ag_gltexture.cc	2008-02-05 20:13:13 UTC (rev 1227)
@@ -116,24 +116,27 @@
 	c.begin();
 	assertGL;
 
-	
-  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
-  assertGL;
-  glPixelStorei(GL_UNPACK_ROW_LENGTH,
-                surface->pitch / surface->format->BytesPerPixel);
-	 
 
+	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
 	assertGL;
+	glPixelStorei(GL_UNPACK_ROW_LENGTH,
+			surface->pitch / surface->format->BytesPerPixel);
+
+
+	assertGL;
 	if(m3d)
 	{
 		assert(glIsEnabled(GL_TEXTURE_3D));
 		int mw=std::min(surface->w,surface->h);
 		int mh=std::max(surface->w,surface->h)/mw;
 
-	//	glTexImage3D(GL_TEXTURE_3D, 0, format, w, h, d, 0, GL_RGBA,
-	//			GL_UNSIGNED_BYTE, surface->pixels);
-	    glTexSubImage3D(GL_TEXTURE_3D,0,int(offset[0]),int(offset[1]),0,
-				      mw,mw,mh,format,GL_UNSIGNED_BYTE,surface->pixels);
+		// FIXME: use glTexImage instead of glTexSubImage, because it makes problems
+		// on MacOSX 10.5.1 (at least on my macbook pro - godrin)
+
+		glTexImage3D(GL_TEXTURE_3D, 0, format, w, h, d, 0, GL_RGBA,
+				GL_UNSIGNED_BYTE, surface->pixels);
+		glTexSubImage3D(GL_TEXTURE_3D,0,int(offset[0]),int(offset[1]),0,
+				mw,mw,mh,format,GL_UNSIGNED_BYTE,surface->pixels);
 	}
 	else
 	{

Copied: antargis/trunk/ruby/ant_application.rb (from rev 1225, antargis/trunk/ruby/run_game.rb)
===================================================================
--- antargis/trunk/ruby/run_game.rb	2008-01-31 20:08:48 UTC (rev 1225)
+++ antargis/trunk/ruby/ant_application.rb	2008-02-05 20:13:13 UTC (rev 1227)
@@ -0,0 +1,663 @@
+#!/usr/bin/env ruby
+#--
+# Copyright (c) 2005 by David Kamphausen. All rights reserved.
+#
+# game.rb
+# by David Kamphausen (david.kamphausen at web.de)
+#
+# The "Antargis" project, including all files needed to compile it,
+# is free software; you can redistribute it and/or use it and/or modify it
+# under the terms of the GNU General Public License as published
+# by the Free Software Foundation; either version 2 of the License,
+# or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+#
+# You should have received a copy of the GNU General Public
+# License along with this program.
+#++
+#
+# antargis.rb is the central file in antargis-level-playing.
+# it contains the main-application class AntGameApp for in-game looping, etc.
+# most of the GUI-events are processed here.
+#
+
+
+# add programdir to path
+$programDir=File.split(__FILE__)[0]
+$:.push($programDir)
+$:.push(File.join($programDir,"entities"))
+$:.push(File.join($programDir,"widgets"))
+
+require 'antargislib.rb'
+require 'dialogs.rb'
+require 'entities.rb'
+require 'map.rb'
+require 'view.rb'
+require 'game_result.rb'
+require 'storyflow.rb'
+require 'mpmap.rb'
+
+require 'pp'
+
+# get save path where savegames are stored
+# NOTE: this is combined with getWriteDir from ag_fs.h !
+def getSavePath
+	"savegames"
+end
+
+#
+# AntGameApp is the central application-class in game. It controls:
+# * event handling of all the user interaction
+# * holds all the game-objects
+# * calls the advance-function in each frame
+# * it's derived from AntRubyView, which implements/manages the (3d-)displaying in-game
+#
+class AntGameApp <AntRubyView
+	attr_accessor :result
+	attr_reader :hero
+
+	include AGHandler
+
+	# creating an AntGameApp-object needs the following parameters:
+	# * *savegameText* - this is the actual level serialized in a string (the xml-text you see when you open an .antlvl-file)
+	#   it contains the height- and terrain-map, too. This has the advantage, that everything about a level is stored in one
+	#   text and can thus be transfered easily over internet 
+	# * *w* and *h* are the width and height of the screen, which is currently needed to init the underlying GLApp-class from C++
+	#   *FIXME:* this could be replaced by a call to getMain.getVideo.getWidth and such
+	# * *loadscreen* is a LoadApp-object (or nil); if it's set that indicates that a loadscreen (a progress bar) is displayed
+	# * *connection* is a network-connection to a BoA multiplayer-server for future networking-support. link:files/ruby/multiplayer/README.html
+	#
+	# this function does all the initializing of a level:
+	# * from the super-classes: create a scene (for more go to the parent-class)
+	# * display a load-screen (and set the progress)
+	# * create a AntMpMap object
+	# * create a displaying layout from data/gui/layout/ant_layout.xml
+	# * initializes some event-handlers (glue code between level-displaying and the game-world object of type AntMpMap
+	# * load the map fom *savegameText*
+	# * setup of the hero-display-list at the top of the screen
+	def initialize(savegameText,w,h,loadscreen=nil,connection=nil)
+		super(w,h)
+
+		@speed=1
+
+		# the result of the level - won or lost or canceled
+		@result=GameResult.new
+		$app=self
+		AntSound.setApplication(self)
+	
+		# display loading screen
+		if loadscreen
+			loadscreen.setValue(0.1)
+			loadscreen.tick
+		end
+
+		playerName=nil
+
+		# init network mode
+		@connection=connection
+		if connection
+			# FIXME: check, if this is a server - then don't assign playerName
+			playerName=connection.getName
+		end
+
+		# init game-engine's map
+		@map=AntMpMap.new(connection,self,getScene,32,32,playerName) # some small dummy size - gets overriden by loadMap anyway
+		if loadscreen
+			loadscreen.setValue(0.4)
+			loadscreen.tick
+		end
+
+		# load GUI layout
+		@layout=AGLayout.new(nil)
+		@layout.setApp(self)
+		assert{@layout.getApp}
+		@layout.loadXML(loadFile("data/gui/layout/ant_layout.xml"))
+	
+
+		# init pointers to different displays
+		# statusBar (FPS display)
+		@statusBar=@layout.getChild("statusBar")
+		@inventory=@layout.getChild("inventory")
+		@buttonpanel=@layout.getChild("antButtonPanel")
+
+		@miniMap=@layout.getChild("miniMap")
+		@fps=0
+
+		setMainWidget(@layout)
+		addHandler(@layout.getChild("quit"),:sigClick,:eventQuit)
+		addHandler(@layout.getChild("pause"),:sigClick,:eventPause)
+		addHandler(@layout.getChild("options"),:sigClick,:eventOptions)
+
+		if loadscreen
+			loadscreen.setValue(0.5)
+			loadscreen.tick
+		end
+	
+		if @miniMap
+			# connect MiniMap with Map for displaying terrain and entities
+			@miniMap.setMap(@map)
+			# connect MiniMap with Scene for displaying frustrum
+			@miniMap.setScene(getScene)
+		end
+
+		if loadscreen
+			loadscreen.setValue(0.8)
+			loadscreen.tick()
+		end
+		
+		if savegameText && savegameText.length>0
+			# load a level
+			@map.loadMapFromMemory(savegameText)
+		end	
+
+		if loadscreen
+			loadscreen.setValue(0.95)
+			loadscreen.tick
+		end
+
+		# inventory and buttonpanel signals
+		addHandler(@inventory,:sigJobChanged,:eventInventoryJob)
+		addHandler(@buttonpanel,:sigJobChanged,:eventHeroJob)
+
+		setupHeroDisplay(true)
+
+		# infobox is used for display a text "Your hero 'xy' suffers"
+		@infobox=nil
+
+		# frame counting
+		@frameCount=0
+		@elapsTime=0
+
+		#setCursor(getTextureCache.get("blue_cursor.png"))
+	end
+
+	####################################
+	# EVENT HANDLERS
+	####################################
+
+	include AntMyEventHandler
+
+
+	# this handler is for the buttonpanel on the top
+	# the actions are direct ones, like rest,dimiss and so, which don't need an object to use (like fighting,taking,...)
+	def eventHeroJob(e)
+		case @buttonpanel.job
+			when "doDismiss"
+				# opens a query dialog "do really want to do this?", that is given a block, that's executed on confirmation
+				@layout.addChild(AntQueryDialog.new(@layout,nil) {@hero.newHLDismissJob})
+			when "doRest"
+				if @hero
+					@hero.newHLRestJob(10)
+				end
+			when "doBuild"
+				@job="doBuild"
+		end
+		return true
+	end
+
+	# react to inventory-based jobs - like taking, recruiting
+
+	def eventInventoryJob(e)
+		if @target.nil? #some more overview as
+			log "NO TARGET SELECTED"
+		else
+			case @inventory.job
+				when "doRecruit"
+					@hero.newHLRecruitJob(@target)
+				when "doTakeFood"
+					@hero.newHLTakeFoodJob(@target)
+				when "doTakeWeapons"
+					@hero.newHLTakeWeaponJob(@target)
+				when "doConstruct"
+					@hero.newHLConstructJob(@target)
+				when "doUpgrade"
+					@hero.upgradeMan(@target)
+				when "doContinue"
+					@hero.newHLBuildJob(@target,nil)
+				when "doSupport"
+					targetsTarget=nil
+					if @target.getJob.is_a?(AntHeroFightJob)
+						targetsTarget=@target.getJob.target
+					end
+					if targetsTarget
+						@hero.newHLFightJob(targetsTarget)
+					end
+			end
+		end
+		return true
+	end
+
+	def eventKeyDown(e)
+
+		# hero-selection by pressing F1 to F7
+		hero={	SDLK_F1=>0,
+			SDLK_F2=>1,
+			SDLK_F3=>2,
+			SDLK_F4=>3,
+			SDLK_F5=>4,
+			SDLK_F6=>5,
+			SDLK_F7=>6}[e.getKey]
+		if hero
+			h=getHeroByNum(hero) 
+			if h
+				if @hero==h
+					focusHero(h)
+				end
+				selectHero(h)
+				return super(e)
+			end
+		end
+
+		
+		case e.getKey
+			when SDLK_F9 # F9 toggles panel on the right
+				if not panelVisible
+					showPanel
+				else
+					hidePanel
+				end
+			when SDLK_F8
+				@sceneEnabled=(not @sceneEnabled)
+				getScene.setEnabled(@sceneEnabled)
+			when SDLK_F1
+				hero=1
+			when SDLK_ESCAPE
+				if @hero
+					@hero.newHLRestJob(10)
+				end
+			when SDLK_PLUS
+				@speed=[@speed+1,10].min
+			when SDLK_MINUS
+				@speed=[@speed-1,0.2].max
+			
+			when SDLK_p
+				eventPause(nil)
+		end
+		return super(e)
+	end
+	
+	def eventStoryTalkFinished
+		showPanel
+		getMap.trigger(nil,Trigger.new("storyFinished"))
+	end
+
+	def moveMap(time)
+		granularity=0.2
+		while time>granularity
+			getMap().move(granularity)
+			time-=granularity
+		end
+		getMap().move(time)
+	end
+
+	def eventFrame(time)
+		super(time)
+
+		# FPS display
+		if @frameCount>14 then
+			@fps=@frameCount / @elapsTime
+			fps=""
+			if @fps<10
+				fps=sprintf("%3.2f", at fps)
+			else
+				fps=sprintf("%3.0f", at fps)
+			end
+			@statusBar.setText(_("FPS:{1}",fps.to_s))
+			@frameCount=0
+			@elapsTime=0
+			startGC
+		end
+		@frameCount+=1
+		@elapsTime+=time
+
+
+# 		# move entities in game-engine
+		#getMap().move(time*@speed)
+		moveMap(time*@speed)
+
+		# advance animations
+		getScene.advance(time)
+		checkHeroEnergy
+
+		processMessages
+
+		# save some CPU-power, if available
+		if @connection
+			delay(20)
+		end
+
+		if @fps>25
+			delay(5)
+		end
+		return true
+	end
+	
+	def eventQuit(e)
+		@layout.addChild(AntQuitDialog.new(@layout))
+		return true
+	end
+	def eventPause(e)
+		if not getMap().pause then
+			@layout.addChild(AntPauseDialog.new(@layout))
+		else
+			getMap.pause=false
+		end
+		return true
+	end
+	def eventOptions(e)
+		@layout.addChild(AntOptionsDialog.new(@layout))
+		return true
+	end
+	def eventHeroButton(e)
+		c=e.getCaller.getName
+		num=c[4..4]
+		name=@layout.getChild("HeroName#{num}").getText.to_s
+		ent=getMap.getByName(name)
+		selectHero(ent)
+		if ent==@inspect
+			focusHero(ent)
+		end
+		inspectEntity(ent)
+		return true
+
+	end
+
+	def eventAggressionChanged(e)
+		h=getSelectedHero
+		if h
+			h.setAggression(@buttonpanel.getAggression)
+		end
+		return true
+	end
+
+	def eventEntitiesClicked(list,button)
+		resetJob
+		# find first entity that's nearest to the camera
+		ent=nil
+		list.each{|node|
+			mesh=node.node
+			if [Mesh,AnimMesh,Mesh2D].member?(mesh.class)
+				ent=getMap.getEntity(mesh)
+				break if ent
+			end
+		}
+
+		# if an entity was found - set new target
+		if ent
+			if ent.class==AntHero and ent.getPlayer==getMap.getPlayer
+				#@hero=ent
+				@target=ent
+				inspectEntity(ent)
+			else
+				@target=ent
+				inspectEntity(ent)
+			end
+		end
+
+		if button==1
+			# left button == select
+		elsif button==3
+			# right button == fight or goto
+			if ent==@target
+				if @target.is_a?(AntBoss)
+					if @target.getPlayer!=@hero.getPlayer
+						@hero.newHLFightJob(@target)
+						return
+					end
+				elsif @target.is_a?(AntAnimal)
+					@hero.newHLFightAnimalJob(@target)
+					return
+				end
+				# move near target
+				@hero.newHLMoveJob(0, at target.getPos2D,2)
+			end
+		end
+	end
+
+	def eventMapClicked(pos,button)
+		if @job and button==1 then
+			case @job
+				when "doBuild"
+					buildHouse(pos.dim2)
+					@job=nil
+			end
+			resetJob
+			return
+		end
+		if @hero and button==3 then
+			# assign hero a move job
+			@hero.newHLMoveJob(0,pos,0)
+		end
+	end
+
+
+	###############################
+	# simple functions
+	###############################
+
+	def getMap
+		@map
+	end
+
+	def processMessages
+		if @connection
+			while message=@connection.getMessage
+				@map.processMessage(message)
+			end
+		end
+	end
+
+	def buildHouse(pos)
+		@layout.addChild(AntBuildDialog.new(@layout,pos, at hero))
+	end
+	
+	def save
+		if $campaign
+			@layout.addChild(AntSaveCampaignDialog.new(@layout))
+		else
+			@layout.addChild(AntSaveDialog.new(@layout))
+		end
+	end
+	def load
+		@layout.addChild(AntLoadDialog.new(@layout))
+	end
+	def videoOptions
+		@layout.addChild(AntVideoOptionsDialog.new(@layout))
+	end
+	def audioOptions
+		@layout.addChild(AntAudioOptionsDialog.new(@layout))
+	end
+
+	###############################################################
+	# Setting up of Hero displays (images, texts and eventHandlers
+	###############################################################
+
+	def setHeroImage(image,num)
+		@layout.getChild("HeroImage#{num}").setTexture(image)
+	end
+	def setHeroName(name,num)
+		@layout.getChild("HeroName#{num}").setText(_(name))
+		c=@layout.getChild("HeroBar#{num}")
+		raise 1 if c.nil?
+		c.setVisible((name!=""))
+	end
+	def setHeroEnergy(hero,num)
+		@layout.getChild("HeroBar#{num}").setHero(hero)
+	end
+	def setHero(flag,num)
+		name="hero#{num}"
+		c=@layout.getChild(name)
+		c.setEnabled(flag)
+		c.setVisible(flag)
+	end
+	def setupHeroDisplay(first=false)
+		#super
+		# setup Hero buttons
+		hs=getMap.getPlayer.getHeroes
+		for i in 0..5
+			if hs.length>i
+				setHero(true,i)
+				setHeroName(hs[i].getName,i)
+				setHeroImage(hs[i].getImage,i)
+				setHeroEnergy(hs[i],i)
+			else
+				setHero(false,i)
+				setHeroImage(getTextureCache.get("data/gui/portraits/none.png"),i)
+				setHeroName("",i)
+			end
+		end
+		# init Handlers of Buttons
+		if first
+			addHandler(@layout.getChild("antButtonPanel"),:sigAggressionChanged,:eventAggressionChanged)
+			for i in 0..2
+				addHandler(@layout.getChild("hero#{i}"),:sigClick,:eventHeroButton)
+			end
+			setupNames
+			
+			# center hero and select
+	 		if hs.length>0
+	 			h=hs[0]
+	 			selectHero(h)
+ 				focusHero(h)
+				@layout.getChild("hero0").setChecked(true)
+ 			end
+			
+		end
+		checkHeroEnergy
+	end
+
+	# updates the energy displays of the heroes (if needed)
+	def checkHeroEnergy
+		name=nil
+		# FIXME: support more than 1 hero !
+		getMap.getPlayer.getHeroes.each{|h|
+			if h.getEnergy<0.3
+				name=h.getName
+			end
+		}
+		if @infobox.nil? and name
+			@layout.addChild(@infobox=AntInfoBox.new(@layout,_("Your hero {1} suffers.",name)))
+		elsif @infobox and name.nil?
+			@infobox.close
+			@infobox=nil
+		end
+	end
+
+	# sets a new result
+	def setResult(r)
+		@result=r
+	end
+	
+	# returns boolean about the visibility of the panel
+	def panelVisible
+		@layout.getChild("SideBar").visible
+	end
+
+	def showPanel
+		sideBar=@layout.getChild("SideBar")
+		sideBarRight=@layout.getChild("SideBarRight")
+		sideBar.show
+		@controls=true
+		# reset Scene's width
+		getScene.getCameraObject.setWidth((getScreen.getWidth-sideBarRight.width).to_i)
+	end
+	def hidePanel
+		@layout.getChild("SideBar").hide
+		@controls=false
+		# reset Scene's width
+		getScene.getCameraObject.setWidth(getScreen.getWidth)
+	end
+
+
+	def tellStory(flow)
+		getMap.pause=true
+		hidePanel
+		if @story.nil?
+			@story=AntStoryTalk.new(@layout)
+		end
+		@layout.addChild(@story)
+		assert{@story.getApp}
+		@story.show
+		@story.setFlow(flow)
+		addHandler(@story,:sigStoryFinished,:eventStoryTalkFinished)
+	end
+
+	def inspectEntity(e)
+		if @inspect
+			#if @inspect.is_a?(AntBoss)
+				@inspect.selected=false
+			#end
+		end
+		@inspect=e
+		if @inspect
+			#if @inspect.is_a?(AntBoss)
+				@inspect.selected=true
+			#end
+		end
+		AntInventory.inspectEntity(e)
+	end
+
+	def resetJob
+		#@job=nil
+		@layout.getChild("doBuild").setChecked(false)
+	end
+
+	def getSelectedHero
+		@hero
+	end
+
+	def selectHero(h)
+		@hero=h
+		inspectEntity(h)
+		@buttonpanel.setHero(h)
+
+		for i in 0..2
+			if @layout.getChild("HeroName#{i}").getText.to_s==h.getName
+				@layout.getChild("hero#{i}").setChecked(true)
+			end
+		end
+
+		# set hero's aggression
+		@buttonpanel.setAggression(@hero.getAggression)
+	end
+
+	def getHeroByNum(n)
+		getMap.getOwnHeroes[n]
+	end
+
+	# views an information window about the entity ent
+	def viewInformation(ent)
+		win=AntInspectWindow.new(@layout,ent)
+		@layout.addChild(win)
+	end
+
+end
+
+
+# this function is only for starting a level directly (single map from the mainmenu or from cli)
+# you can start BoA from the cli by giving a level-name directly
+# For more information on that topic please refer to link:files/ruby/debugging/README.html
+def startGame(file="savegames/savegame0.antlvl",clientConnection=nil)
+	app=nil
+	if clientConnection
+		app=AntGameApp.new(file,getVideo.width,getVideo.height,nil,clientConnection)
+	else
+		app=AntGameApp.new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
+	end
+	#app.disableGC
+	app.run
+	result=app.result
+	# result all globals
+	app=nil
+	$map=nil
+	$app=nil
+	$screen=nil
+	# run garbage collector
+	startGC
+	return result
+end
+
+

Modified: antargis/trunk/ruby/intro.rb
===================================================================
--- antargis/trunk/ruby/intro.rb	2008-02-02 16:51:48 UTC (rev 1226)
+++ antargis/trunk/ruby/intro.rb	2008-02-05 20:13:13 UTC (rev 1227)
@@ -155,11 +155,3 @@
 	end
 	
 end
-# 
-# app=IntroApp.new
-# 
-# 
-# if getConfig.get("intro")!="false"
-#   app.run
-# end
-# require 'ruby/mainmenu.rb'

Modified: antargis/trunk/ruby/mainmenu.rb
===================================================================
--- antargis/trunk/ruby/mainmenu.rb	2008-02-02 16:51:48 UTC (rev 1226)
+++ antargis/trunk/ruby/mainmenu.rb	2008-02-05 20:13:13 UTC (rev 1227)
@@ -21,7 +21,7 @@
 require 'ruby/antargislib.rb'
 $useMenu=true
 
-require "run_game.rb"
+require "ant_application.rb"
 require 'campaign.rb'
 require 'credits.rb'
 

Deleted: antargis/trunk/ruby/run_game.rb
===================================================================
--- antargis/trunk/ruby/run_game.rb	2008-02-02 16:51:48 UTC (rev 1226)
+++ antargis/trunk/ruby/run_game.rb	2008-02-05 20:13:13 UTC (rev 1227)
@@ -1,681 +0,0 @@
-#!/usr/bin/env ruby
-#--
-# Copyright (c) 2005 by David Kamphausen. All rights reserved.
-#
-# game.rb
-# by David Kamphausen (david.kamphausen at web.de)
-#
-# The "Antargis" project, including all files needed to compile it,
-# is free software; you can redistribute it and/or use it and/or modify it
-# under the terms of the GNU General Public License as published
-# by the Free Software Foundation; either version 2 of the License,
-# or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-#
-# You should have received a copy of the GNU General Public
-# License along with this program.
-#++
-#
-# antargis.rb is the central file in antargis-level-playing.
-# it contains the main-application class AntGameApp for in-game looping, etc.
-# most of the GUI-events are processed here.
-#
-
-
-# add programdir to path
-$programDir=File.split(__FILE__)[0]
-$:.push($programDir)
-$:.push(File.join($programDir,"entities"))
-$:.push(File.join($programDir,"widgets"))
-
-require 'antargislib.rb'
-require 'dialogs.rb'
-require 'entities.rb'
-require 'map.rb'
-require 'view.rb'
-require 'game_result.rb'
-require 'storyflow.rb'
-require 'mpmap.rb'
-
-require 'pp'
-
-# get save path where savegames are stored
-# NOTE: this is combined with getWriteDir from ag_fs.h !
-def getSavePath
-	"savegames"
-end
-
-#
-# AntGameApp is the central application-class in game. It controls:
-# * event handling of all the user interaction
-# * holds all the game-objects
-# * calls the advance-function in each frame
-# * it's derived from AntRubyView, which implements/manages the (3d-)displaying in-game
-#
-class AntGameApp <AntRubyView
-	attr_accessor :result
-	attr_reader :hero
-
-	include AGHandler
-
-	# creating an AntGameApp-object needs the following parameters:
-	# * *savegameText* - this is the actual level serialized in a string (the xml-text you see when you open an .antlvl-file)
-	#   it contains the height- and terrain-map, too. This has the advantage, that everything about a level is stored in one
-	#   text and can thus be transfered easily over internet 
-	# * *w* and *h* are the width and height of the screen, which is currently needed to init the underlying GLApp-class from C++
-	#   *FIXME:* this could be replaced by a call to getMain.getVideo.getWidth and such
-	# * *loadscreen* is a LoadApp-object (or nil); if it's set that indicates that a loadscreen (a progress bar) is displayed
-	# * *connection* is a network-connection to a BoA multiplayer-server for future networking-support. link:files/ruby/multiplayer/README.html
-	#
-	# this function does all the initializing of a level:
-	# * from the super-classes: create a scene (for more go to the parent-class)
-	# * display a load-screen (and set the progress)
-	# * create a AntMpMap object
-	# * create a displaying layout from data/gui/layout/ant_layout.xml
-	# * initializes some event-handlers (glue code between level-displaying and the game-world object of type AntMpMap
-	# * load the map fom *savegameText*
-	# * setup of the hero-display-list at the top of the screen
-	def initialize(savegameText,w,h,loadscreen=nil,connection=nil)
-		super(w,h)
-
-		@speed=1
-
-		# the result of the level - won or lost or canceled
-		@result=GameResult.new
-		$app=self
-		AntSound.setApplication(self)
-	
-		# display loading screen
-		if loadscreen
-			loadscreen.setValue(0.1)
-			loadscreen.tick
-		end
-
-		playerName=nil
-
-		# init network mode
-		@connection=connection
-		if connection
-			# FIXME: check, if this is a server - then don't assign playerName
-			playerName=connection.getName
-		end
-
-		# init game-engine's map
-		@map=AntMpMap.new(connection,self,getScene,32,32,playerName) # some small dummy size - gets overriden by loadMap anyway
-		if loadscreen
-			loadscreen.setValue(0.4)
-			loadscreen.tick
-		end
-
-		# load GUI layout
-		@layout=AGLayout.new(nil)
-		@layout.setApp(self)
-		assert{@layout.getApp}
-		@layout.loadXML(loadFile("data/gui/layout/ant_layout.xml"))
-	
-
-		# init pointers to different displays
-		# statusBar (FPS display)
-		@statusBar=@layout.getChild("statusBar")
-		@inventory=@layout.getChild("inventory")
-		@buttonpanel=@layout.getChild("antButtonPanel")
-
-		@miniMap=@layout.getChild("miniMap")
-		@fps=0
-
-		setMainWidget(@layout)
-		addHandler(@layout.getChild("quit"),:sigClick,:eventQuit)
-		addHandler(@layout.getChild("pause"),:sigClick,:eventPause)
-		addHandler(@layout.getChild("options"),:sigClick,:eventOptions)
-
-		if loadscreen
-			loadscreen.setValue(0.5)
-			loadscreen.tick
-		end
-	
-		if @miniMap
-			# connect MiniMap with Map for displaying terrain and entities
-			@miniMap.setMap(@map)
-			# connect MiniMap with Scene for displaying frustrum
-			@miniMap.setScene(getScene)
-		end
-
-		if loadscreen
-			loadscreen.setValue(0.8)
-			loadscreen.tick()
-		end
-		
-		if savegameText && savegameText.length>0
-			# load a level
-			@map.loadMapFromMemory(savegameText)
-		end	
-
-		if loadscreen
-			loadscreen.setValue(0.95)
-			loadscreen.tick
-		end
-
-		# inventory and buttonpanel signals
-		addHandler(@inventory,:sigJobChanged,:eventInventoryJob)
-		addHandler(@buttonpanel,:sigJobChanged,:eventHeroJob)
-
-		setupHeroDisplay(true)
-
-		# infobox is used for display a text "Your hero 'xy' suffers"
-		@infobox=nil
-
-		# frame counting
-		@frameCount=0
-		@elapsTime=0
-
-		#setCursor(getTextureCache.get("blue_cursor.png"))
-	end
-
-	####################################
-	# EVENT HANDLERS
-	####################################
-
-	include AntMyEventHandler
-
-
-	# this handler is for the buttonpanel on the top
-	# the actions are direct ones, like rest,dimiss and so, which don't need an object to use (like fighting,taking,...)
-	def eventHeroJob(e)
-		case @buttonpanel.job
-			when "doDismiss"
-				# opens a query dialog "do really want to do this?", that is given a block, that's executed on confirmation
-				@layout.addChild(AntQueryDialog.new(@layout,nil) {@hero.newHLDismissJob})
-			when "doRest"
-				if @hero
-					@hero.newHLRestJob(10)
-				end
-			when "doBuild"
-				@job="doBuild"
-		end
-		return true
-	end
-
-	# react to inventory-based jobs - like taking, recruiting
-
-	def eventInventoryJob(e)
-		if @target.nil? #some more overview as
-			log "NO TARGET SELECTED"
-		else
-			case @inventory.job
-				when "doRecruit"
-					@hero.newHLRecruitJob(@target)
-				when "doTakeFood"
-					@hero.newHLTakeFoodJob(@target)
-				when "doTakeWeapons"
-					@hero.newHLTakeWeaponJob(@target)
-				when "doConstruct"
-					@hero.newHLConstructJob(@target)
-				when "doUpgrade"
-					@hero.upgradeMan(@target)
-				when "doContinue"
-					@hero.newHLBuildJob(@target,nil)
-				when "doSupport"
-					targetsTarget=nil
-					if @target.getJob.is_a?(AntHeroFightJob)
-						targetsTarget=@target.getJob.target
-					end
-					if targetsTarget
-						@hero.newHLFightJob(targetsTarget)
-					end
-			end
-		end
-		return true
-	end
-
-	def eventKeyDown(e)
-
-		# hero-selection by pressing F1 to F7
-		hero={	SDLK_F1=>0,
-			SDLK_F2=>1,
-			SDLK_F3=>2,
-			SDLK_F4=>3,
-			SDLK_F5=>4,
-			SDLK_F6=>5,
-			SDLK_F7=>6}[e.getKey]
-		if hero
-			h=getHeroByNum(hero) 
-			if h
-				if @hero==h
-					focusHero(h)
-				end
-				selectHero(h)
-				return super(e)
-			end
-		end
-
-		
-		case e.getKey
-			when SDLK_F9 # F9 toggles panel on the right
-				if not panelVisible
-					showPanel
-				else
-					hidePanel
-				end
-			when SDLK_F8
-				@sceneEnabled=(not @sceneEnabled)
-				getScene.setEnabled(@sceneEnabled)
-			when SDLK_F1
-				hero=1
-			when SDLK_ESCAPE
-				if @hero
-					@hero.newHLRestJob(10)
-				end
-			when SDLK_PLUS
-				@speed=[@speed+1,10].min
-			when SDLK_MINUS
-				@speed=[@speed-1,0.2].max
-			
-			when SDLK_p
-				eventPause(nil)
-		end
-		return super(e)
-	end
-	
-	def eventStoryTalkFinished
-		showPanel
-		getMap.trigger(nil,Trigger.new("storyFinished"))
-	end
-
-	def moveMap(time)
-		granularity=0.2
-		while time>granularity
-			getMap().move(granularity)
-			time-=granularity
-		end
-		getMap().move(time)
-	end
-
-	def eventFrame(time)
-		super(time)
-
-		# FPS display
-		if @frameCount>14 then
-			@fps=@frameCount / @elapsTime
-			fps=""
-			if @fps<10
-				fps=sprintf("%3.2f", at fps)
-			else
-				fps=sprintf("%3.0f", at fps)
-			end
-			@statusBar.setText(_("FPS:{1}",fps.to_s))
-			@frameCount=0
-			@elapsTime=0
-			startGC
-		end
-		@frameCount+=1
-		@elapsTime+=time
-
-
-# 		# move entities in game-engine
-		#getMap().move(time*@speed)
-		moveMap(time*@speed)
-
-		# advance animations
-		getScene.advance(time)
-		checkHeroEnergy
-
-		processMessages
-
-		# save some CPU-power, if available
-		if @connection
-			delay(20)
-		end
-
-		if @fps>25
-			delay(5)
-		end
-		return true
-	end
-	
-	def eventQuit(e)
-		@layout.addChild(AntQuitDialog.new(@layout))
-		return true
-	end
-	def eventPause(e)
-		if not getMap().pause then
-			@layout.addChild(AntPauseDialog.new(@layout))
-		else
-			getMap.pause=false
-		end
-		return true
-	end
-	def eventOptions(e)
-		@layout.addChild(AntOptionsDialog.new(@layout))
-		return true
-	end
-	def eventHeroButton(e)
-		c=e.getCaller.getName
-		num=c[4..4]
-		name=@layout.getChild("HeroName#{num}").getText.to_s
-		ent=getMap.getByName(name)
-		selectHero(ent)
-		if ent==@inspect
-			focusHero(ent)
-		end
-		inspectEntity(ent)
-		return true
-
-	end
-
-	def eventAggressionChanged(e)
-		h=getSelectedHero
-		if h
-			h.setAggression(@buttonpanel.getAggression)
-		end
-		return true
-	end
-
-	def eventEntitiesClicked(list,button)
-		resetJob
-		# find first entity that's nearest to the camera
-		ent=nil
-		list.each{|node|
-			mesh=node.node
-			if [Mesh,AnimMesh,Mesh2D].member?(mesh.class)
-				ent=getMap.getEntity(mesh)
-				break if ent
-			end
-		}
-
-		# if an entity was found - set new target
-		if ent
-			if ent.class==AntHero and ent.getPlayer==getMap.getPlayer
-				#@hero=ent
-				@target=ent
-				inspectEntity(ent)
-			else
-				@target=ent
-				inspectEntity(ent)
-			end
-		end
-
-		if button==1
-			# left button == select
-		elsif button==3
-			# right button == fight or goto
-			if ent==@target
-				if @target.is_a?(AntBoss)
-					if @target.getPlayer!=@hero.getPlayer
-						@hero.newHLFightJob(@target)
-						return
-					end
-				elsif @target.is_a?(AntAnimal)
-					@hero.newHLFightAnimalJob(@target)
-					return
-				end
-				# move near target
-				@hero.newHLMoveJob(0, at target.getPos2D,2)
-			end
-		end
-	end
-
-	def eventMapClicked(pos,button)
-		if @job and button==1 then
-			case @job
-				when "doBuild"
-					buildHouse(pos.dim2)
-					@job=nil
-			end
-			resetJob
-			return
-		end
-		if @hero and button==3 then
-			# assign hero a move job
-			@hero.newHLMoveJob(0,pos,0)
-		end
-	end
-
-
-	###############################
-	# simple functions
-	###############################
-
-	def getMap
-		@map
-	end
-
-	def processMessages
-		if @connection
-			while message=@connection.getMessage
-				@map.processMessage(message)
-			end
-		end
-	end
-
-	def buildHouse(pos)
-		@layout.addChild(AntBuildDialog.new(@layout,pos, at hero))
-	end
-	
-	def save
-		if $campaign
-			@layout.addChild(AntSaveCampaignDialog.new(@layout))
-		else
-			@layout.addChild(AntSaveDialog.new(@layout))
-		end
-	end
-	def load
-		@layout.addChild(AntLoadDialog.new(@layout))
-	end
-	def videoOptions
-		@layout.addChild(AntVideoOptionsDialog.new(@layout))
-	end
-	def audioOptions
-		@layout.addChild(AntAudioOptionsDialog.new(@layout))
-	end
-
-	###############################################################
-	# Setting up of Hero displays (images, texts and eventHandlers
-	###############################################################
-
-	def setHeroImage(image,num)
-		@layout.getChild("HeroImage#{num}").setTexture(image)
-	end
-	def setHeroName(name,num)
-		@layout.getChild("HeroName#{num}").setText(_(name))
-		c=@layout.getChild("HeroBar#{num}")
-		raise 1 if c.nil?
-		c.setVisible((name!=""))
-	end
-	def setHeroEnergy(hero,num)
-		@layout.getChild("HeroBar#{num}").setHero(hero)
-	end
-	def setHero(flag,num)
-		name="hero#{num}"
-		c=@layout.getChild(name)
-		c.setEnabled(flag)
-		c.setVisible(flag)
-	end
-	def setupHeroDisplay(first=false)
-		#super
-		# setup Hero buttons
-		hs=getMap.getPlayer.getHeroes
-		for i in 0..5
-			if hs.length>i
-				setHero(true,i)
-				setHeroName(hs[i].getName,i)
-				setHeroImage(hs[i].getImage,i)
-				setHeroEnergy(hs[i],i)
-			else
-				setHero(false,i)
-				setHeroImage(getTextureCache.get("data/gui/portraits/none.png"),i)
-				setHeroName("",i)
-			end
-		end
-		# init Handlers of Buttons
-		if first
-			addHandler(@layout.getChild("antButtonPanel"),:sigAggressionChanged,:eventAggressionChanged)
-			for i in 0..2
-				addHandler(@layout.getChild("hero#{i}"),:sigClick,:eventHeroButton)
-			end
-			setupNames
-			
-			# center hero and select
-	 		if hs.length>0
-	 			h=hs[0]
-	 			selectHero(h)
- 				focusHero(h)
-				@layout.getChild("hero0").setChecked(true)
- 			end
-			
-		end
-		checkHeroEnergy
-	end
-
-	# updates the energy displays of the heroes (if needed)
-	def checkHeroEnergy
-		name=nil
-		# FIXME: support more than 1 hero !
-		getMap.getPlayer.getHeroes.each{|h|
-			if h.getEnergy<0.3
-				name=h.getName
-			end
-		}
-		if @infobox.nil? and name
-			@layout.addChild(@infobox=AntInfoBox.new(@layout,_("Your hero {1} suffers.",name)))
-		elsif @infobox and name.nil?
-			@infobox.close
-			@infobox=nil
-		end
-	end
-
-	# sets a new result
-	def setResult(r)
-		@result=r
-	end
-	
-	# returns boolean about the visibility of the panel
-	def panelVisible
-		@layout.getChild("SideBar").visible
-	end
-
-	def showPanel
-		sideBar=@layout.getChild("SideBar")
-		sideBarRight=@layout.getChild("SideBarRight")
-		sideBar.show
-		@controls=true
-		# reset Scene's width
-		getScene.getCameraObject.setWidth((getScreen.getWidth-sideBarRight.width).to_i)
-	end
-	def hidePanel
-		@layout.getChild("SideBar").hide
-		@controls=false
-		# reset Scene's width
-		getScene.getCameraObject.setWidth(getScreen.getWidth)
-	end
-
-
-	def tellStory(flow)
-		getMap.pause=true
-		hidePanel
-		if @story.nil?
-			@story=AntStoryTalk.new(@layout)
-		end
-		@layout.addChild(@story)
-		assert{@story.getApp}
-		@story.show
-		@story.setFlow(flow)
-		addHandler(@story,:sigStoryFinished,:eventStoryTalkFinished)
-	end
-
-	def inspectEntity(e)
-		if @inspect
-			#if @inspect.is_a?(AntBoss)
-				@inspect.selected=false
-			#end
-		end
-		@inspect=e
-		if @inspect
-			#if @inspect.is_a?(AntBoss)
-				@inspect.selected=true
-			#end
-		end
-		AntInventory.inspectEntity(e)
-	end
-
-	def resetJob
-		#@job=nil
-		@layout.getChild("doBuild").setChecked(false)
-	end
-
-	def getSelectedHero
-		@hero
-	end
-
-	def selectHero(h)
-		@hero=h
-		inspectEntity(h)
-		@buttonpanel.setHero(h)
-
-		for i in 0..2
-			if @layout.getChild("HeroName#{i}").getText.to_s==h.getName
-				@layout.getChild("hero#{i}").setChecked(true)
-			end
-		end
-
-		# set hero's aggression
-		@buttonpanel.setAggression(@hero.getAggression)
-	end
-
-	def getHeroByNum(n)
-		getMap.getOwnHeroes[n]
-	end
-
-	# views an information window about the entity ent
-	def viewInformation(ent)
-		win=AntInspectWindow.new(@layout,ent)
-		@layout.addChild(win)
-	end
-
-end
-
-
-# this function is only for starting a level directly (single map from the mainmenu or from cli)
-# you can start BoA from the cli by giving a level-name directly
-# For more information on that topic please refer to link:files/ruby/debugging/README.html
-def startGame(file="savegames/savegame0.antlvl",clientConnection=nil)
-	app=nil
-	if clientConnection
-		app=AntGameApp.new(file,getVideo.width,getVideo.height,nil,clientConnection)
-	else
-		app=AntGameApp.new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
-	end
-	#app.disableGC
-	app.run
-	result=app.result
-	# result all globals
-	app=nil
-	$map=nil
-	$app=nil
-	$screen=nil
-	# run garbage collector
-	startGC
-	return result
-end
-
-
-# code for starting a level directly from command-line like this:
-# ./ruby/run_game.rb levels/birth1
-# or
-# ./ruby/run_game.rb savegames/savegame0
-$useMenu||=false
-if true
-	savegame=""
-	ARGV.each{|arg|
-		if arg=~/levels.*/ or arg=~/savegames.*/
-			savegame=arg+".antlvl"
-		end
-	}
-	if savegame!=""
-		startGame(savegame)	
-	end
-end
-
-getConfig.set("ok","ok")



From davidkamphausen at mail.berlios.de  Wed Feb  6 21:02:45 2008
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Wed, 6 Feb 2008 21:02:45 +0100
Subject: [Antargis-svn] r1228 - in antargis/trunk: ext/3dengine ext/basic
	ext/game ext/gui ext/math ext/sound ext/test ext/video ruby
	ruby/entities ruby/gui ruby/spec
Message-ID: <200802062002.m16K2j9k022477@sheep.berlios.de>

Author: davidkamphausen
Date: 2008-02-06 21:02:44 +0100 (Wed, 06 Feb 2008)
New Revision: 1228

Added:
   antargis/trunk/ext/test/Rakefile
   antargis/trunk/ext/test/gl_text_3d.cc
   antargis/trunk/ruby/spec/spec_run_tutorial.rb
Modified:
   antargis/trunk/ext/3dengine/headers.hh
   antargis/trunk/ext/basic/headers.hh
   antargis/trunk/ext/game/headers.hh
   antargis/trunk/ext/gui/ag_widget.cc
   antargis/trunk/ext/gui/headers.hh
   antargis/trunk/ext/math/headers.hh
   antargis/trunk/ext/sound/headers.hh
   antargis/trunk/ext/test/
   antargis/trunk/ext/video/headers.hh
   antargis/trunk/ruby/ant_application.rb
   antargis/trunk/ruby/entities/ant_boss.rb
   antargis/trunk/ruby/gui/testing.rb
Log:
* some new tests

Modified: antargis/trunk/ext/3dengine/headers.hh
===================================================================
--- antargis/trunk/ext/3dengine/headers.hh	2008-02-05 20:13:13 UTC (rev 1227)
+++ antargis/trunk/ext/3dengine/headers.hh	2008-02-06 20:02:44 UTC (rev 1228)
@@ -1,62 +1,62 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_geometry.h"
 #include "ext/basic/ag_main.h"
-#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_config.h"
 #include "ext/basic/ag_string_utf8.h"
-#include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_geometry.h"
+#include "ext/basic/ag_utf8.h"
 #include "ext/basic/ag_video_base.h"
 #include "ext/basic/ag_xml.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_rubyobj.h"
 #include "ext/sound/ag_mixer.h"
+#include "ext/math/ag_algebra.h"
 #include "ext/math/ag_rand.h"
-#include "ext/math/ag_algebra.h"
 #include "ext/math/ant_frustum.h"
-#include "ext/video/ag_rendercontext.h"
-#include "ext/video/ag_texturecache.h"
 #include "ext/video/ag_clip.h"
+#include "ext/video/ag_color.h"
+#include "ext/video/ag_font.h"
 #include "ext/video/ag_fontengine.h"
-#include "ext/video/ag_font.h"
-#include "ext/video/ag_video.h"
-#include "ext/video/ag_color.h"
+#include "ext/video/ag_painter.h"
+#include "ext/video/ag_painttarget.h"
+#include "ext/video/ag_rendercontext.h"
 #include "ext/video/ag_screen.h"
-#include "ext/video/ag_painttarget.h"
 #include "ext/video/ag_surface.h"
 #include "ext/video/ag_texture.h"
-#include "ext/video/ag_painter.h"
+#include "ext/video/ag_texturecache.h"
+#include "ext/video/ag_video.h"
+#include "ext/gui/ag_application.h"
+#include "ext/gui/ag_background.h"
+#include "ext/gui/ag_border.h"
+#include "ext/gui/ag_button.h"
+#include "ext/gui/ag_caption.h"
+#include "ext/gui/ag_checkbox.h"
+#include "ext/gui/ag_colorbutton.h"
+#include "ext/gui/ag_combo.h"
+#include "ext/gui/ag_edit.h"
+#include "ext/gui/ag_frame.h"
 #include "ext/gui/ag_image.h"
+#include "ext/gui/ag_layout.h"
+#include "ext/gui/ag_layoutfactory.h"
 #include "ext/gui/ag_listbox.h"
-#include "ext/gui/ag_edit.h"
-#include "ext/gui/ag_scroller.h"
 #include "ext/gui/ag_local.h"
-#include "ext/gui/ag_tooltip.h"
+#include "ext/gui/ag_menu.h"
+#include "ext/gui/ag_menuitem.h"
 #include "ext/gui/ag_radio.h"
-#include "ext/gui/ag_application.h"
-#include "ext/gui/ag_colorbutton.h"
-#include "ext/gui/ag_button.h"
 #include "ext/gui/ag_radiogroup.h"
-#include "ext/gui/ag_background.h"
-#include "ext/gui/ag_menuitem.h"
 #include "ext/gui/ag_screenwidget.h"
-#include "ext/gui/ag_widget.h"
+#include "ext/gui/ag_scroller.h"
+#include "ext/gui/ag_table.h"
 #include "ext/gui/ag_text.h"
-#include "ext/gui/ag_checkbox.h"
-#include "ext/gui/ag_table.h"
-#include "ext/gui/ag_frame.h"
-#include "ext/gui/ag_caption.h"
-#include "ext/gui/ag_combo.h"
 #include "ext/gui/ag_theme.h"
-#include "ext/gui/ag_menu.h"
-#include "ext/gui/ag_layoutfactory.h"
+#include "ext/gui/ag_tooltip.h"
+#include "ext/gui/ag_widget.h"
 #include "ext/gui/ag_window.h"
-#include "ext/gui/ag_layout.h"
-#include "ext/gui/ag_border.h"
 #include "ext/3dengine/mesh_data.h"
 #include "ext/3dengine/scene_base.h"
 #include "ext/3dengine/scenenode.h"

Modified: antargis/trunk/ext/basic/headers.hh
===================================================================
--- antargis/trunk/ext/basic/headers.hh	2008-02-05 20:13:13 UTC (rev 1227)
+++ antargis/trunk/ext/basic/headers.hh	2008-02-06 20:02:44 UTC (rev 1228)
@@ -13,8 +13,8 @@
 #include "ext/basic/ag_xml.h"
 #include "ext/basic/ag_string_utf8.h"
 #include "ext/basic/ag_stringstream.h"
+#include "ext/basic/ag_fs.h"
 #include "ext/basic/ag_utf8.h"
-#include "ext/basic/ag_fs.h"
 #ifdef SWIG
 %include "ext/basic/ag_rubyobj.h"
 %include "ext/basic/ag_messageobject.h"
@@ -28,7 +28,7 @@
 %include "ext/basic/ag_xml.h"
 %include "ext/basic/ag_string_utf8.h"
 %include "ext/basic/ag_stringstream.h"
+%include "ext/basic/ag_fs.h"
 %include "ext/basic/ag_utf8.h"
-%include "ext/basic/ag_fs.h"
 #endif
 #endif

Modified: antargis/trunk/ext/game/headers.hh
===================================================================
--- antargis/trunk/ext/game/headers.hh	2008-02-05 20:13:13 UTC (rev 1227)
+++ antargis/trunk/ext/game/headers.hh	2008-02-06 20:02:44 UTC (rev 1228)
@@ -1,78 +1,78 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_geometry.h"
 #include "ext/basic/ag_main.h"
-#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_config.h"
 #include "ext/basic/ag_string_utf8.h"
-#include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_geometry.h"
+#include "ext/basic/ag_utf8.h"
 #include "ext/basic/ag_video_base.h"
 #include "ext/basic/ag_xml.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_rubyobj.h"
 #include "ext/sound/ag_mixer.h"
+#include "ext/math/ag_algebra.h"
 #include "ext/math/ag_rand.h"
-#include "ext/math/ag_algebra.h"
 #include "ext/math/ant_frustum.h"
-#include "ext/video/ag_rendercontext.h"
-#include "ext/video/ag_texturecache.h"
 #include "ext/video/ag_clip.h"
+#include "ext/video/ag_color.h"
+#include "ext/video/ag_font.h"
 #include "ext/video/ag_fontengine.h"
-#include "ext/video/ag_font.h"
-#include "ext/video/ag_video.h"
-#include "ext/video/ag_color.h"
+#include "ext/video/ag_painter.h"
+#include "ext/video/ag_painttarget.h"
+#include "ext/video/ag_rendercontext.h"
 #include "ext/video/ag_screen.h"
-#include "ext/video/ag_painttarget.h"
 #include "ext/video/ag_surface.h"
 #include "ext/video/ag_texture.h"
-#include "ext/video/ag_painter.h"
+#include "ext/video/ag_texturecache.h"
+#include "ext/video/ag_video.h"
+#include "ext/gui/ag_application.h"
+#include "ext/gui/ag_background.h"
+#include "ext/gui/ag_border.h"
+#include "ext/gui/ag_button.h"
+#include "ext/gui/ag_caption.h"
+#include "ext/gui/ag_checkbox.h"
+#include "ext/gui/ag_colorbutton.h"
+#include "ext/gui/ag_combo.h"
+#include "ext/gui/ag_edit.h"
+#include "ext/gui/ag_frame.h"
 #include "ext/gui/ag_image.h"
+#include "ext/gui/ag_layout.h"
+#include "ext/gui/ag_layoutfactory.h"
 #include "ext/gui/ag_listbox.h"
-#include "ext/gui/ag_edit.h"
-#include "ext/gui/ag_scroller.h"
 #include "ext/gui/ag_local.h"
-#include "ext/gui/ag_tooltip.h"
+#include "ext/gui/ag_menu.h"
+#include "ext/gui/ag_menuitem.h"
 #include "ext/gui/ag_radio.h"
-#include "ext/gui/ag_application.h"
-#include "ext/gui/ag_colorbutton.h"
-#include "ext/gui/ag_button.h"
 #include "ext/gui/ag_radiogroup.h"
-#include "ext/gui/ag_background.h"
-#include "ext/gui/ag_menuitem.h"
 #include "ext/gui/ag_screenwidget.h"
-#include "ext/gui/ag_widget.h"
+#include "ext/gui/ag_scroller.h"
+#include "ext/gui/ag_table.h"
 #include "ext/gui/ag_text.h"
-#include "ext/gui/ag_checkbox.h"
-#include "ext/gui/ag_table.h"
-#include "ext/gui/ag_frame.h"
-#include "ext/gui/ag_caption.h"
-#include "ext/gui/ag_combo.h"
 #include "ext/gui/ag_theme.h"
-#include "ext/gui/ag_menu.h"
-#include "ext/gui/ag_layoutfactory.h"
+#include "ext/gui/ag_tooltip.h"
+#include "ext/gui/ag_widget.h"
 #include "ext/gui/ag_window.h"
-#include "ext/gui/ag_layout.h"
-#include "ext/gui/ag_border.h"
+#include "ext/3dengine/ag_glwidget.h"
+#include "ext/3dengine/anim_mesh.h"
 #include "ext/3dengine/anim_mesh_data.h"
 #include "ext/3dengine/ant_camera.h"
+#include "ext/3dengine/ant_particle.h"
+#include "ext/3dengine/ant_projection.h"
+#include "ext/3dengine/boa_3d_wireframe.h"
 #include "ext/3dengine/mesh.h"
-#include "ext/3dengine/scene.h"
-#include "ext/3dengine/mesh_optimizer.h"
-#include "ext/3dengine/ant_particle.h"
+#include "ext/3dengine/mesh_2d.h"
 #include "ext/3dengine/mesh_2d_data.h"
-#include "ext/3dengine/ag_glwidget.h"
-#include "ext/3dengine/mesh_2d.h"
+#include "ext/3dengine/mesh_base.h"
 #include "ext/3dengine/mesh_data.h"
+#include "ext/3dengine/mesh_optimizer.h"
+#include "ext/3dengine/scene.h"
 #include "ext/3dengine/scene_base.h"
-#include "ext/3dengine/boa_3d_wireframe.h"
-#include "ext/3dengine/anim_mesh.h"
 #include "ext/3dengine/scenenode.h"
-#include "ext/3dengine/ant_projection.h"
-#include "ext/3dengine/mesh_base.h"
 #include "ext/game/path.h"
 #include "ext/game/terrain.h"
 #include "ext/game/entity.h"

Modified: antargis/trunk/ext/gui/ag_widget.cc
===================================================================
--- antargis/trunk/ext/gui/ag_widget.cc	2008-02-05 20:13:13 UTC (rev 1227)
+++ antargis/trunk/ext/gui/ag_widget.cc	2008-02-06 20:02:44 UTC (rev 1228)
@@ -925,7 +925,7 @@
 	  if(mParent)
 	    {
 	      //CTRACE;
-	      cdebug("parent->queryRedraw::"<<typeid(*this).name()<<":"<<getName());
+	      // cdebug("parent->queryRedraw::"<<typeid(*this).name()<<":"<<getName());
 	      mParent->queryRedraw();
 	    }
 

Modified: antargis/trunk/ext/gui/headers.hh
===================================================================
--- antargis/trunk/ext/gui/headers.hh	2008-02-05 20:13:13 UTC (rev 1227)
+++ antargis/trunk/ext/gui/headers.hh	2008-02-06 20:02:44 UTC (rev 1228)
@@ -1,35 +1,35 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_geometry.h"
 #include "ext/basic/ag_main.h"
-#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_config.h"
 #include "ext/basic/ag_string_utf8.h"
-#include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_geometry.h"
+#include "ext/basic/ag_utf8.h"
 #include "ext/basic/ag_video_base.h"
 #include "ext/basic/ag_xml.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_rubyobj.h"
 #include "ext/sound/ag_mixer.h"
+#include "ext/math/ag_algebra.h"
 #include "ext/math/ag_rand.h"
-#include "ext/math/ag_algebra.h"
 #include "ext/math/ant_frustum.h"
-#include "ext/video/ag_rendercontext.h"
-#include "ext/video/ag_texturecache.h"
 #include "ext/video/ag_clip.h"
+#include "ext/video/ag_color.h"
+#include "ext/video/ag_font.h"
 #include "ext/video/ag_fontengine.h"
-#include "ext/video/ag_font.h"
-#include "ext/video/ag_video.h"
-#include "ext/video/ag_color.h"
+#include "ext/video/ag_painter.h"
+#include "ext/video/ag_painttarget.h"
+#include "ext/video/ag_rendercontext.h"
 #include "ext/video/ag_screen.h"
-#include "ext/video/ag_painttarget.h"
 #include "ext/video/ag_surface.h"
 #include "ext/video/ag_texture.h"
-#include "ext/video/ag_painter.h"
+#include "ext/video/ag_texturecache.h"
+#include "ext/video/ag_video.h"
 #include "ext/gui/ag_layoutfactory.h"
 #include "ext/gui/ag_widget.h"
 #include "ext/gui/ag_application.h"

Modified: antargis/trunk/ext/math/headers.hh
===================================================================
--- antargis/trunk/ext/math/headers.hh	2008-02-05 20:13:13 UTC (rev 1227)
+++ antargis/trunk/ext/math/headers.hh	2008-02-06 20:02:44 UTC (rev 1228)
@@ -1,19 +1,19 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_geometry.h"
 #include "ext/basic/ag_main.h"
-#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_config.h"
 #include "ext/basic/ag_string_utf8.h"
-#include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_geometry.h"
+#include "ext/basic/ag_utf8.h"
 #include "ext/basic/ag_video_base.h"
 #include "ext/basic/ag_xml.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_rubyobj.h"
 #include "ext/sound/ag_mixer.h"
 #include "ext/math/ag_rand.h"
 #include "ext/math/ant_frustum.h"

Modified: antargis/trunk/ext/sound/headers.hh
===================================================================
--- antargis/trunk/ext/sound/headers.hh	2008-02-05 20:13:13 UTC (rev 1227)
+++ antargis/trunk/ext/sound/headers.hh	2008-02-06 20:02:44 UTC (rev 1228)
@@ -1,19 +1,19 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_geometry.h"
 #include "ext/basic/ag_main.h"
-#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_config.h"
 #include "ext/basic/ag_string_utf8.h"
-#include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_geometry.h"
+#include "ext/basic/ag_utf8.h"
 #include "ext/basic/ag_video_base.h"
 #include "ext/basic/ag_xml.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_rubyobj.h"
 #include "ext/sound/ag_mixer.h"
 #ifdef SWIG
 %include "ext/sound/ag_mixer.h"


Property changes on: antargis/trunk/ext/test
___________________________________________________________________
Name: svn:ignore
   + gl_text_3d.oo
gl_text_3d


Added: antargis/trunk/ext/test/Rakefile
===================================================================
--- antargis/trunk/ext/test/Rakefile	2008-02-05 20:13:13 UTC (rev 1227)
+++ antargis/trunk/ext/test/Rakefile	2008-02-06 20:02:44 UTC (rev 1228)
@@ -0,0 +1,11 @@
+#!/usr/bin/env ruby
+
+task 'gl_text_3d' => 'gl_text_3d.cc' do
+  cflags=`sdl-config --cflags`.chomp
+  ldflags=`sdl-config --libs`.chomp
+  cmd="g++ -o gl_text_3d gl_text_3d.cc -framework OpenGL "+cflags+" "+ldflags+" -lSDL_image"
+  sh cmd 
+end
+
+
+task :default=>["gl_text_3d"]
\ No newline at end of file

Added: antargis/trunk/ext/test/gl_text_3d.cc
===================================================================
--- antargis/trunk/ext/test/gl_text_3d.cc	2008-02-05 20:13:13 UTC (rev 1227)
+++ antargis/trunk/ext/test/gl_text_3d.cc	2008-02-06 20:02:44 UTC (rev 1228)
@@ -0,0 +1,131 @@
+#include <SDL.h>
+#include <SDL_opengl.h>
+#include <stdexcept>
+#include <iostream>
+#include <sstream> 
+
+
+void assertGL(std::string s)
+{
+	{
+		GLenum error = glGetError();
+		if(error != GL_NO_ERROR) {
+			std::ostringstream msg;
+			msg <<s<< ": OpenGLError "
+			<< gluErrorString(error);
+
+			std::cerr<<msg.str()<<std::endl;
+			throw std::runtime_error(msg.str());
+		}
+	}
+}
+
+int main(int argc,char *argv[])
+{
+	SDL_Init(SDL_INIT_VIDEO);
+
+	int w=1024;
+	int h=768;
+
+	SDL_SetVideoMode(w,h,32,SDL_OPENGL);
+
+	// load file
+	//SDL_Surface *surface=IMG_Load(IMAGE_FILE);
+
+	GLuint tex;
+	// generate texture
+	glGenTextures(1,&tex);
+	glBindTexture(GL_TEXTURE_3D,tex);
+	glEnable(GL_TEXTURE_3D);
+
+	size_t redSize=128*128*4096*4;
+	char *red=new char[redSize];
+	for(size_t i=0;i<redSize;i++)
+		red[i]=(((i%4)==0 || (i%4)==3)?255:0);
+	char *blue=new char[redSize];
+	for(size_t i=0;i<redSize;i++)
+		blue[i]=(((i%4)==2 || (i%4)==3)?255:0);
+
+
+	glTexImage3D(GL_TEXTURE_3D, 0, GL_RGBA, 128, 128, 4096/128, 0, GL_RGBA,
+			GL_UNSIGNED_BYTE,red);
+
+	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+
+	  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+	  assertGL("");
+	  glPixelStorei(GL_UNPACK_ROW_LENGTH,
+	                128); //blue->pitch / blue->format->BytesPerPixel);
+		 
+	
+	glTexSubImage3D(GL_TEXTURE_3D,0,0,0,0,
+			128,128,32,GL_RGBA,GL_UNSIGNED_BYTE,blue);
+
+
+	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+	glBindTexture(GL_TEXTURE_3D,tex);
+	glEnable(GL_TEXTURE_3D);
+
+	glDisable(GL_TEXTURE_2D);
+
+	glViewport( 0, 0, w, h );
+	glMatrixMode( GL_PROJECTION );
+	glLoadIdentity( );
+
+	GLfloat ratio;
+
+	ratio = ( float )w / ( float )h;
+
+	gluOrtho2D(0,w,0,h);
+	glMatrixMode(GL_MODELVIEW);
+	glLoadIdentity();
+
+	glColor4f(1,1,1,1);
+	glBegin(GL_QUADS);
+
+	for(int i=0;i<32;i++)
+	{
+		float x=int(i%6);
+		float y=int(i/6);
+
+		float d=float(i)/32.0;
+
+		x*=110;
+		y*=110;
+
+		float w=100;
+		float x2=x+w;
+		float y2=y+w;
+
+
+
+		glTexCoord3f(0,0,d);
+		glVertex2f(x,y);
+
+		glTexCoord3f(1,0,d);
+		glVertex2f(x2,y);
+
+		glTexCoord3f(1,1,d);
+		glVertex2f(x2,y2);
+
+		glTexCoord3f(0,1,d);
+		glVertex2f(x,y2);
+
+	}
+
+	glEnd();
+
+	SDL_GL_SwapBuffers();
+
+
+
+
+	assertGL("");
+
+	SDL_Delay(10000);
+
+	return 0;
+}

Modified: antargis/trunk/ext/video/headers.hh
===================================================================
--- antargis/trunk/ext/video/headers.hh	2008-02-05 20:13:13 UTC (rev 1227)
+++ antargis/trunk/ext/video/headers.hh	2008-02-06 20:02:44 UTC (rev 1228)
@@ -1,22 +1,22 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_geometry.h"
 #include "ext/basic/ag_main.h"
-#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_singleton.h"
-#include "ext/basic/ag_config.h"
 #include "ext/basic/ag_string_utf8.h"
-#include "ext/basic/ag_rand_base.h"
-#include "ext/basic/ag_serial.h"
 #include "ext/basic/ag_stringstream.h"
-#include "ext/basic/ag_geometry.h"
+#include "ext/basic/ag_utf8.h"
 #include "ext/basic/ag_video_base.h"
 #include "ext/basic/ag_xml.h"
-#include "ext/basic/ag_fs.h"
-#include "ext/basic/ag_messageobject.h"
-#include "ext/basic/ag_rubyobj.h"
 #include "ext/sound/ag_mixer.h"
+#include "ext/math/ag_algebra.h"
 #include "ext/math/ag_rand.h"
-#include "ext/math/ag_algebra.h"
 #include "ext/math/ant_frustum.h"
 #include "ext/video/ag_painttarget.h"
 #include "ext/video/ag_surface.h"

Modified: antargis/trunk/ruby/ant_application.rb
===================================================================
--- antargis/trunk/ruby/ant_application.rb	2008-02-05 20:13:13 UTC (rev 1227)
+++ antargis/trunk/ruby/ant_application.rb	2008-02-06 20:02:44 UTC (rev 1228)
@@ -329,7 +329,7 @@
 			delay(20)
 		end
 
-		if @fps>25
+		if @fps>25 and isRunning
 			delay(5)
 		end
 		return true

Modified: antargis/trunk/ruby/entities/ant_boss.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_boss.rb	2008-02-05 20:13:13 UTC (rev 1227)
+++ antargis/trunk/ruby/entities/ant_boss.rb	2008-02-06 20:02:44 UTC (rev 1228)
@@ -86,6 +86,10 @@
 		@job
 	end
 	
+	def hasHLJob
+		@job and (not @job.is_a?(AntHeroRestJob))
+	end
+	
 	def menCount
 		@men=@men.uniq
 		return @men.length

Modified: antargis/trunk/ruby/gui/testing.rb
===================================================================
--- antargis/trunk/ruby/gui/testing.rb	2008-02-05 20:13:13 UTC (rev 1227)
+++ antargis/trunk/ruby/gui/testing.rb	2008-02-06 20:02:44 UTC (rev 1228)
@@ -4,7 +4,6 @@
 		run
 	end
 	def eventFrame(t)
-		puts "FRAME"
 		super
 		tryQuit
 		true

Added: antargis/trunk/ruby/spec/spec_run_tutorial.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_run_tutorial.rb	2008-02-05 20:13:13 UTC (rev 1227)
+++ antargis/trunk/ruby/spec/spec_run_tutorial.rb	2008-02-06 20:02:44 UTC (rev 1228)
@@ -0,0 +1,148 @@
+#Dir.chdir(File.split(__FILE__)[0])
+
+require 'ruby/spec_helper.rb'
+require 'ruby/gui/testing.rb'
+require 'ruby/ant_application.rb'
+
+describe 'Tutorial campaign' do
+	describe '- First level' do
+		include GuiTest
+		before(:all) do
+			# FIXME
+			file="data/levels/tutorial/tutorial0.antlvl"
+			clientConnection=nil
+			@app=makeTestAppClass(AntGameApp).new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
+		    @app.step
+			
+		end
+		it "should start off with a story telling dialog" do
+			telltaleWidget=widget("TellTale")
+			telltaleWidget.should_not be_nil
+			telltaleWidget.should be_visible
+			textWidget=telltaleWidget.child("text")
+			textWidget.should_not be_nil
+			text=textWidget.getText.to_s
+			okButton=telltaleWidget.child("ok")
+			okButton.should_not be_nil
+			okButton.click
+			text.should_not ==(textWidget.getText.to_s)
+			@app.step
+			clickAwayStory
+			
+		end
+		describe '- State at the beginning' do
+		  before(:each) do
+			  @map=@app.getMap
+			  @map.should be_a_kind_of(AntRubyMap)
+			  clickAwayStory
+			  @enemy=nil
+			  @hero=nil
+		  end
+          it "should display no story-telling anymore at this time" do
+          	widget("TellTale").should be_nil
+          end
+
+			            	
+		  it "should include Rowen and an enemy" do
+		    heroes=@map.getOwnHeroes
+			enemies=@map.getHeroes- at map.getOwnHeroes
+			heroes.length.should == 1
+			enemies.length.should == 1
+			@hero=heroes[0]
+			@enemy=enemies[0]
+		  end
+		  it "should have a single enemy with a few troopers" do
+		  	getEnemy.getMen.length.should >2
+		  end
+
+		  it "should have Rowen with no followers yet" do
+		  	getHero.getMen.length ==1
+		  end
+
+		  it "should have a tower with a few men" do
+		  	towers=@map.getBuildings
+			towers.length.should == 1
+			@tower=towers[0]
+			@tower.should be_a_kind_of(AntTower)
+			@tower.getMen.length>2
+		  end
+		  it "should include more men in tower than enemy has" do
+		  	tower=@map.getBuildings[0]
+			tower.getMen.length.should > getEnemy.getMen.length
+		  end
+		  
+		end
+		it "should be possible to recruit some men" do
+			# do a recruit job
+			@map=@app.getMap
+			hero=getHero
+			building=getBuilding
+			hero.newHLRecruitJob(building)
+			while hero.hasHLJob
+				advance
+			end
+			hero.getJob.should_not be_a_kind_of(AntHeroRecruitJob)
+			widget("TellTale").should be_visible
+			building.getMen.length.should == 0
+			hero.getMen.length.should > 2
+			hero.getMen.length.should > getEnemy.getMen.length
+			
+
+		end
+		it "should be possible to defeat enemy" do
+	       clickAwayStory
+					hero=getHero
+			enemy=getEnemy
+			hero.newHLFightJob(enemy)
+			hero.getJob.should be_a_kind_of(AntHeroFightJob)
+			enemy.hasHLJob.should be_false
+			while hero.hasHLJob
+				puts hero.getJob
+					advance
+			end
+			clickAwayStory
+		    @app.result.won.should == "won"
+            map.getOwnHeroes.length.should == 2
+		end
+	
+		def getEnemies
+			enemies=map.getHeroes-map.getOwnHeroes
+			enemies
+		end
+		def getEnemy
+		  getEnemies[0]
+		end
+		def getHero
+		  @app.getMap.getOwnHeroes[0]
+		end
+		def getBuilding
+			@app.getMap.getBuildings[0]
+		end
+	    def advance
+	    	@app.getMap.move(0.3)
+			@app.step
+	    end
+		def map
+		  @app.getMap
+		end
+	end
+	
+	def clickAwayStory
+		telltaleWidget=widget("TellTale")
+		return if telltaleWidget.nil?
+
+		telltaleWidget.should_not be_nil
+		telltaleWidget.should be_visible
+		okButton=telltaleWidget.child("ok")
+		okButton.should_not be_nil
+		okButton.click
+		trials=0
+		while telltaleWidget.visible?
+			okButton.click
+			@app.step
+			trials+=1
+			trials.should <10
+		end
+
+	end
+end
\ No newline at end of file



From davidkamphausen at mail.berlios.de  Fri Feb 15 21:44:20 2008
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Fri, 15 Feb 2008 21:44:20 +0100
Subject: [Antargis-svn] r1229 - in antargis/trunk: . ext ext/3dengine
	ext/game ext/video main ruby ruby/entities ruby/gui ruby/jobs
	ruby/spec ruby/widgets
Message-ID: <200802152044.m1FKiKAK000857@sheep.berlios.de>

Author: davidkamphausen
Date: 2008-02-15 21:44:14 +0100 (Fri, 15 Feb 2008)
New Revision: 1229

Added:
   antargis/trunk/ruby/spec/level_testing.rb
   antargis/trunk/ruby/spec/spec_formation.rb
   antargis/trunk/ruby/spec/spec_game_gui.rb
   antargis/trunk/ruby/spec/spec_hljobs.rb
   antargis/trunk/ruby/spec/story_test.rb
Modified:
   antargis/trunk/Rakefile
   antargis/trunk/TODO
   antargis/trunk/ext/
   antargis/trunk/ext/3dengine/ag_glsl.cc
   antargis/trunk/ext/3dengine/glsl.cc
   antargis/trunk/ext/3dengine/vertex_array.cc
   antargis/trunk/ext/3dengine/vertex_array.h
   antargis/trunk/ext/game/entity.cc
   antargis/trunk/ext/game/entity.h
   antargis/trunk/ext/game/jobs.cc
   antargis/trunk/ext/game/jobs.h
   antargis/trunk/ext/video/ag_glscreen.cc
   antargis/trunk/main/Rakefile
   antargis/trunk/ruby/ant_application.rb
   antargis/trunk/ruby/ant_formations.rb
   antargis/trunk/ruby/entities/ant_hero.rb
   antargis/trunk/ruby/entities/ant_manbase.rb
   antargis/trunk/ruby/entities/entity.rb
   antargis/trunk/ruby/gui/ag_tools.rb
   antargis/trunk/ruby/gui/testing.rb
   antargis/trunk/ruby/jobs/ant_hljob_states.rb
   antargis/trunk/ruby/jobs/ant_new_hljobs.rb
   antargis/trunk/ruby/jobs/ant_state_machine.rb
   antargis/trunk/ruby/spec/spec_run_tutorial.rb
   antargis/trunk/ruby/spec_helper.rb
   antargis/trunk/ruby/widgets/ant_name_display.rb
Log:
* many specs and bugfixes - esp. for macosx

Modified: antargis/trunk/Rakefile
===================================================================
--- antargis/trunk/Rakefile	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/Rakefile	2008-02-15 20:44:14 UTC (rev 1229)
@@ -54,7 +54,7 @@
 		s.platform = Gem::Platform::WIN32
 		s.name = 'antargis-win32'
 	else
-		s.platform = Gem::Platform::LINUX_586
+		s.platform = Gem::Platform::CURRENT
 		s.name = 'antargis-linux'
 	end
 	s.summary = "A real-time strategy game."
@@ -130,5 +130,5 @@
 
 
 desc "Build all"
-task :default=>[:starter,:library] do
+task :default=>[:starterPrg,:library] do
 end

Modified: antargis/trunk/TODO
===================================================================
--- antargis/trunk/TODO	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/TODO	2008-02-15 20:44:14 UTC (rev 1229)
@@ -1,12 +1,14 @@
 * bug-report at apple site on glTexSubImage issue 
 * fix shadows on mac (on shadow-extension ?)
 * check mingw on macosx
+* toggling fullscreen destroys animated meshes (and textures partly)
 
 * fix saving - problem occurs only if game is loaded ? (in editor, too)
 ** hljobs can't be saved right now
 
 * move build/*.rb files to build/unused_tools/* if they're not used
-* google for "/tmp/cciSLVG5.s:932678: Warning: .stabs: description field '1c216' too big, try a different debug format"
+* issue with mingw: 
+** google for "/tmp/cciSLVG5.s:932678: Warning: .stabs: description field '1c216' too big, try a different debug format"
 
 * check how many times AG_NewPointer is called !!!! - not so often - could be replaced by traceobjects from swig
 ** check if it's any good to switch over to standard-swig ??? seems so.


Property changes on: antargis/trunk/ext
___________________________________________________________________
Name: svn:ignore
   - *.so
*.a

   + *.so
*.a
swig.*
interface.i


Modified: antargis/trunk/ext/3dengine/ag_glsl.cc
===================================================================
--- antargis/trunk/ext/3dengine/ag_glsl.cc	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ext/3dengine/ag_glsl.cc	2008-02-15 20:44:14 UTC (rev 1229)
@@ -7,123 +7,123 @@
 std::map<std::string,AGFragProgram*> mFragPrograms;
 
 AGVertexProgram *getVertexProgram(const std::string &pFile)
-{
-  std::map<std::string,AGVertexProgram*>::iterator i=mVertexPrograms.find(pFile);
+  {
+    std::map<std::string,AGVertexProgram*>::iterator i=mVertexPrograms.find(pFile);
 
-  if(i==mVertexPrograms.end())
-    {
-      AGVertexProgram *p=new AGVertexProgram(pFile);
-      mVertexPrograms[pFile]=p;
-      return p;
-    }
-  return i->second;
-}
+    if(i==mVertexPrograms.end())
+      {
+        AGVertexProgram *p=new AGVertexProgram(pFile);
+        mVertexPrograms[pFile]=p;
+        return p;
+      }
+    return i->second;
+  }
 
 AGFragProgram *getFragProgram(const std::string &pFile)
-{
-  std::map<std::string,AGFragProgram*>::iterator i=mFragPrograms.find(pFile);
+  {
+    std::map<std::string,AGFragProgram*>::iterator i=mFragPrograms.find(pFile);
 
-  if(i==mFragPrograms.end())
-    {
-      AGFragProgram *p=new AGFragProgram(pFile);
-      mFragPrograms[pFile]=p;
-      return p;
-    }
-  return i->second;
-}
+    if(i==mFragPrograms.end())
+      {
+        AGFragProgram *p=new AGFragProgram(pFile);
+        mFragPrograms[pFile]=p;
+        return p;
+      }
+    return i->second;
+  }
 
 int GLSL_ok=-1;
 bool glslOk()
-{
-//  return false;
-  // do not check in each call, because this is slow!!!
-  if(GLSL_ok<0)
-    {
-      GLeeInit();
-      GLSL_ok=(GLEE_ARB_vertex_shader && GLEE_ARB_fragment_shader && GLEE_ARB_shading_language_100);
-    }
-  
-  return GLSL_ok;
-}
+  {
+    //  return false;
+    // do not check in each call, because this is slow!!!
+    if(GLSL_ok<0)
+      {
+        GLeeInit();
+        GLSL_ok=(GLEE_ARB_vertex_shader && GLEE_ARB_fragment_shader && GLEE_ARB_shading_language_100);
+      }
 
+    return GLSL_ok;
+  }
+
 void printInfoLog(GLhandleARB obj)
-{
+  {
     int infologLength = 0;
     int charsWritten  = 0;
     char *infoLog;
 
-        glGetObjectParameterivARB(obj, GL_OBJECT_INFO_LOG_LENGTH_ARB,
-                                         &infologLength);
+    glGetObjectParameterivARB(obj, GL_OBJECT_INFO_LOG_LENGTH_ARB,
+        &infologLength);
 
     if (infologLength > 0)
-    {
-      cdebug("GLSL ERROR:");
-      infoLog = (char *)malloc(infologLength);
-      glGetInfoLogARB(obj, infologLength, &charsWritten, infoLog);
-      if(infoLog)
-	cdebug(infoLog);
-      free(infoLog);
-    }
-}
+      {
+        cdebug("GLSL ERROR:");
+        infoLog = (char *)malloc(infologLength);
+        glGetInfoLogARB(obj, infologLength, &charsWritten, infoLog);
+        if(infoLog)
+          cdebug(infoLog);
+        free(infoLog);
+      }
+  }
 
 
 AGVertexProgram::AGVertexProgram(const std::string &pFile)
-{
-  //  CTRACE;
-  if(glslOk())
-    {
-      vertexShader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
-      std::string s=loadFile(pFile);
-      
-      const char*a=s.c_str();
-      const GLcharARB**x=&a;
-      glShaderSourceARB(vertexShader, 1, x,NULL);
-      glCompileShaderARB(vertexShader);
-      printInfoLog(vertexShader);
-      assertGL;
-    }
-}
+  {
+    //  CTRACE;
+    if(glslOk())
+      {
+        vertexShader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
+        std::string s=loadFile(pFile);
 
+        const char*a=s.c_str();
+        const GLcharARB**x=&a;
+        glShaderSourceARB(vertexShader, 1, x,NULL);
+        glCompileShaderARB(vertexShader);
+        printInfoLog(vertexShader);
+        assertGL;
+      }
+  }
+
 AGVertexProgram::~AGVertexProgram()
-{
-  CTRACE;
-  if(glslOk() && !hasQuit())
-    glDeleteObjectARB(vertexShader);
-  assertGL;
-}
+  {
+    CTRACE;
+    if(glslOk() && !hasQuit())
+      glDeleteObjectARB(vertexShader);
+    assertGL;
+  }
 
 AGFragProgram::AGFragProgram(const std::string &pFile)
-{
-  mValid=false;
-  //  CTRACE;
-  if(glslOk() && pFile.length()>0)
-    {
-      fragShader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
-      std::string s=loadFile(pFile);
-      const char*a=s.c_str();
-      const GLcharARB**x=&a;
-      glShaderSourceARB(fragShader, 1, x,NULL);
-      glCompileShaderARB(fragShader);
-      printInfoLog(fragShader);
-      mValid=true;
-      assertGL;
-	
-    }
-}
+  {
+    mValid=false;
+    //  CTRACE;
+    if(glslOk() && pFile.length()>0)
+      {
+        fragShader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
+        std::string s=loadFile(pFile);
+        const char*a=s.c_str();
+        const GLcharARB**x=&a;
+        glShaderSourceARB(fragShader, 1, x,NULL);
+        glCompileShaderARB(fragShader);
+        printInfoLog(fragShader);
+        mValid=true;
+        assertGL;
 
+      }
+  }
+
 AGFragProgram::AGFragProgram()
-{
-  mValid=false;
-}
+  {
+    mValid=false;
+  }
 
 AGFragProgram::~AGFragProgram()
-{
-  CTRACE;
-  if(glslOk() && !hasQuit())
-    glDeleteObjectARB(fragShader);
-  assertGL;
+  {
+    CTRACE;
+    if(glslOk() && !hasQuit())
+      glDeleteObjectARB(fragShader);
+    assertGL;
 
-}
+  }
 
 
 bool AGFragProgram::valid() const
@@ -135,165 +135,165 @@
 AGShaderProgram::AGShaderProgram(const std::string &pVertexFile,const std::string &pFragFile):
   //  vertex(getVertexProgram(pVertexFile)),frag(getFragProgram(pFragFile))
   vertex(pVertexFile),frag(pFragFile)
-{
-  //  CTRACE;
-  if(glslOk())
-    {
-      p = glCreateProgramObjectARB();
-      glAttachObjectARB(p,vertex.vertexShader);
-      if(frag.valid())
-	glAttachObjectARB(p,frag.fragShader);
-      
-      glLinkProgramARB(p);
-      printInfoLog(p);
+  {
+    //  CTRACE;
+    if(glslOk())
+      {
+        p = glCreateProgramObjectARB();
+        glAttachObjectARB(p,vertex.vertexShader);
+        if(frag.valid())
+          glAttachObjectARB(p,frag.fragShader);
 
-      assert(p);
-    }
-  on=false;
-  matrixBuf=new float[16*100];
-  name=pVertexFile+":"+pFragFile;
-  assertGL;
+        glLinkProgramARB(p);
+        printInfoLog(p);
 
-}
+        assert(p);
+      }
+    on=false;
+    matrixBuf=new float[16*100];
+    name=pVertexFile+":"+pFragFile;
+    assertGL;
 
+  }
+
 AGShaderProgram::~AGShaderProgram()
-{
-  disable();
-  CTRACE;
-  cdebug("name:"<<name);
-  if(glslOk() && !hasQuit())
-    glDeleteObjectARB(p);
-  cdebug("name:"<<name);
-  delete [] matrixBuf;
-  cdebug("name:"<<name);
-  assertGL;
+  {
+    disable();
+    CTRACE;
+    cdebug("name:"<<name);
+    if(glslOk() && !hasQuit())
+      glDeleteObjectARB(p);
+    cdebug("name:"<<name);
+    delete [] matrixBuf;
+    cdebug("name:"<<name);
+    assertGL;
 
-}
+  }
 
 
 void AGShaderProgram::enable()
-{
-  if(glslOk())
-    {
-      glUseProgramObjectARB(p);
-      on=true;
-      assertGL;
+  {
+    if(glslOk())
+      {
+        glUseProgramObjectARB(p);
+        on=true;
+        assertGL;
 
-    }
-}
+      }
+  }
 void AGShaderProgram::disable()
-{
-  if(glslOk())
-    {
-      glUseProgramObjectARB(0);
-      on=false;
-      assertGL;
-    }
-}
+  {
+    if(glslOk())
+      {
+        glUseProgramObjectARB(0);
+        on=false;
+        assertGL;
+      }
+  }
 
 void AGShaderProgram::update(float time)
-{
-  if(glslOk())
-    {
-      enable();
-      doUpdate(time);
-      disable();
-      assertGL;
-    }
-}
+  {
+    if(glslOk())
+      {
+        enable();
+        doUpdate(time);
+        disable();
+        assertGL;
+      }
+  }
 
 void AGShaderProgram::doUpdate(float time)
-{
-}
+  {
+  }
 
 void AGShaderProgram::sendUniform(const std::string &pName,int i)
-{
-  glUniform1iARB(getLoc(pName),i);
-  assertGL;
-}
+  {
+    glUniform1iARB(getLoc(pName),i);
+    assertGL;
+  }
 void AGShaderProgram::sendUniform(const std::string &pName,float f)
-{
-  glUniform1fARB(getLoc(pName),f);
-  assertGL;
-}
+  {
+    glUniform1fARB(getLoc(pName),f);
+    assertGL;
+  }
 void AGShaderProgram::sendUniform(const std::string &pName,const AGVector3 &m)
-{
-  glUniform3fARB(getLoc(pName),m[0],m[1],m[2]);
-  assertGL;
-}
+  {
+    glUniform3fARB(getLoc(pName),m[0],m[1],m[2]);
+    assertGL;
+  }
 void AGShaderProgram::sendUniform(const std::string &pName,const AGVector4 &m)
-{
-  glUniform4fARB(getLoc(pName),m[0],m[1],m[2],m[3]);
-  assertGL;
-}
+  {
+    glUniform4fARB(getLoc(pName),m[0],m[1],m[2],m[3]);
+    assertGL;
+  }
 void AGShaderProgram::sendUniform(const std::string &pName,const AGMatrix4 &m)
-{
-  glUniformMatrix4fvARB(getLoc(pName),1,false,m);
-  assertGL;
-}
+  {
+    glUniformMatrix4fvARB(getLoc(pName),1,false,m);
+    assertGL;
+  }
 void AGShaderProgram::sendUniform(const std::string &pName,const std::vector<AGMatrix4> &m)
-{
-  assert(m.size()<100);
-  float *p=matrixBuf;
+  {
+    assert(m.size()<100);
+    float *p=matrixBuf;
 
-  for(size_t i=0;i<m.size();i++)
-    {
-      const float *s=m[i];
-      for(size_t j=0;j<16;j++)
-	*(p++)=*(s++);
-    }
-  assertGL;
-  glUniformMatrix4fvARB(getLoc(pName),m.size(),false,matrixBuf);
-  assertGL;
-}
+    for(size_t i=0;i<m.size();i++)
+      {
+        const float *s=m[i];
+        for(size_t j=0;j<16;j++)
+          *(p++)=*(s++);
+      }
+    assertGL;
+    glUniformMatrix4fvARB(getLoc(pName),m.size(),false,matrixBuf);
+    assertGL;
+  }
 
 GLint AGShaderProgram::getLoc(const std::string &pName)
-{
-  // register only once !
-  
-  std::map<std::string,GLint>::iterator i=locations.find(pName);
-  if(i!=locations.end())
-    return i->second;
-  
-  GLint k=glGetUniformLocationARB(p,pName.c_str());
-  locations.insert(std::make_pair(pName,k));
-  assertGL;
-  return k;
-}
+  {
+    // register only once !
 
+    std::map<std::string,GLint>::iterator i=locations.find(pName);
+    if(i!=locations.end())
+      return i->second;
+
+    GLint k=glGetUniformLocationARB(p,pName.c_str());
+    locations.insert(std::make_pair(pName,k));
+    assertGL;
+    return k;
+  }
+
 GLint AGShaderProgram::getAttr(const std::string &pName)
-{
-  //  TRACE;
-  // register only once !
-  assert(on);
-  std::map<std::string,GLint>::iterator i=attrs.find(pName);
-  if(i!=attrs.end())
-    return i->second;
-  
-  assertGL;
-  GLint k=glGetAttribLocationARB(p,pName.c_str());
-  //  cdebug("k:"<<k);
-  if(k<0)
-    {
-      cdebug("ERROR:attribute could be get! Maybe it was not defined in the vertex-shader? :"<<pName);
-    }
-  assertGL;
-  attrs.insert(std::make_pair(pName,k));
-  assertGL;
-  return k;
-}
+  {
+    //  TRACE;
+    // register only once !
+    assert(on);
+    std::map<std::string,GLint>::iterator i=attrs.find(pName);
+    if(i!=attrs.end())
+      return i->second;
 
+    assertGL;
+    GLint k=glGetAttribLocationARB(p,pName.c_str());
+    //  cdebug("k:"<<k);
+    if(k<0)
+      {
+        cdebug("ERROR:attribute could be get! Maybe it was not defined in the vertex-shader? :"<<pName);
+      }
+    assertGL;
+    attrs.insert(std::make_pair(pName,k));
+    assertGL;
+    return k;
+  }
+
 void AGShaderProgram::sendAttribute(const std::string &pName,const std::vector<float> &vf)
-{
-  assertGL;
-  GLint loc=getAttr(pName);
-  assertGL;
-  glEnableClientState(GL_VERTEX_ARRAY);
-  assertGL;
-  glEnableVertexAttribArrayARB(loc); // add array
-  assertGL;
+  {
+    assertGL;
+    GLint loc=getAttr(pName);
+    assertGL;
+    glEnableClientState(GL_VERTEX_ARRAY);
+    assertGL;
+    glEnableVertexAttribArrayARB(loc); // add array
+    assertGL;
 
-  glVertexAttribPointerARB(loc,1,GL_FLOAT,0,0,&vf[0]); // set attributes (for each vertex an attribute)
-  assertGL;
-}
+    glVertexAttribPointerARB(loc,1,GL_FLOAT,0,0,&vf[0]); // set attributes (for each vertex an attribute)
+    assertGL;
+  }
 

Modified: antargis/trunk/ext/3dengine/glsl.cc
===================================================================
--- antargis/trunk/ext/3dengine/glsl.cc	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ext/3dengine/glsl.cc	2008-02-15 20:44:14 UTC (rev 1229)
@@ -136,6 +136,8 @@
 {
  if(glslOk())
     {
+	  locations.clear();
+	  attrs.clear();
       vertex=new AntVertexProgram(mVertexFile);
       frag=new AntFragProgram(mFragFile);
 
@@ -161,6 +163,7 @@
   //  cdebug("name:"<<name);
   delete vertex;
   delete frag;
+  locations.clear();
 }
 
 

Modified: antargis/trunk/ext/3dengine/vertex_array.cc
===================================================================
--- antargis/trunk/ext/3dengine/vertex_array.cc	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ext/3dengine/vertex_array.cc	2008-02-15 20:44:14 UTC (rev 1229)
@@ -7,28 +7,28 @@
 #include <ag_main.h>
 
 static bool useVBO()
-{
-  AGString s=getConfig()->get("useVBO");
-  //cdebug("useVBO:"<<s);
-  if(s!="true" && s!="false")
-    {
-      cdebug("useVBO:"<<s);
-      s="true";
-      getConfig()->set("useVBO",s);
-    }
-  return s=="true";
-}
+  {
+    AGString s=getConfig()->get("useVBO");
+    //cdebug("useVBO:"<<s);
+    if(s!="true" && s!="false")
+      {
+        cdebug("useVBO:"<<s);
+        s="true";
+        getConfig()->set("useVBO",s);
+      }
+    return s=="true";
+  }
 
 static bool useVertexArrays()
-{
-  AGString s=getConfig()->get("useVertexArrays");
-  if(s!="true" && s!="false")
-    {
-      s="true";
-      getConfig()->set("useVertexArrays",s);
-    }
-  return s=="true";
-}
+  {
+    AGString s=getConfig()->get("useVertexArrays");
+    if(s!="true" && s!="false")
+      {
+        s="true";
+        getConfig()->set("useVertexArrays",s);
+      }
+    return s=="true";
+  }
 
 
 VertexArray::VertexArray(bool pDynamic):mDynamic(pDynamic),bbox(AGVector3(),AGVector3())
@@ -53,373 +53,373 @@
 }
 
 VertexArray::~VertexArray()
-{
-  //  CTRACE;
-  if(mBuffers && mVertexBuffer!=0) //mChanged==false)
-    {
-      glDeleteBuffersARB( 1, &mVertexBuffer );
-      glDeleteBuffersARB( 1, &mColorBuffer );
-      glDeleteBuffersARB( 1, &mNormalBuffer );
-      glDeleteBuffersARB( 1, &mTexBuffer );
-      if(!mDynamic)
-	glDeleteBuffersARB( 1, &mIndexBuffer );
-    }
-}
+  {
+    //  CTRACE;
+    if(mBuffers && mVertexBuffer!=0) //mChanged==false)
+      {
+        glDeleteBuffersARB( 1, &mVertexBuffer );
+        glDeleteBuffersARB( 1, &mColorBuffer );
+        glDeleteBuffersARB( 1, &mNormalBuffer );
+        glDeleteBuffersARB( 1, &mTexBuffer );
+        if(!mDynamic)
+          glDeleteBuffersARB( 1, &mIndexBuffer );
+      }
+  }
 
 
 void VertexArray::addVertex(AGVector4 pVertex, AGVector4 pColor, AGVector3 pNormal, AGVector2 pTex)
-{
-  mVertices.push_back(pVertex);
-  mColors.push_back(pColor);
-  mNormals.push_back(pNormal);
-  mTexCoords.push_back(pTex);
-  mChanged=true;
-  if(mVertices.size()==1)
-    bbox=AGBox3(pVertex.dim3(),AGVector3(0,0,0));
-  else
-    bbox.include(pVertex.dim3());
-}
+  {
+    mVertices.push_back(pVertex);
+    mColors.push_back(pColor);
+    mNormals.push_back(pNormal);
+    mTexCoords.push_back(pTex);
+    mChanged=true;
+    if(mVertices.size()==1)
+      bbox=AGBox3(pVertex.dim3(),AGVector3(0,0,0));
+    else
+      bbox.include(pVertex.dim3());
+  }
 
 void VertexArray::addVertex(AGVector4 pVertex, AGVector4 pColor, AGVector3 pNormal, AGVector3 pTex)
-{
-  assert(mTextures3D || mVertices.size()==0);
-  mTextures3D=true;
-  mVertices.push_back(pVertex);
-  mColors.push_back(pColor);
-  mNormals.push_back(pNormal);
-  mTexCoords3D.push_back(pTex);
-  mChanged=true;
-  if(mVertices.size()==1)
-    bbox=AGBox3(pVertex.dim3(),AGVector3(0,0,0));
-  else
-    bbox.include(pVertex.dim3());
-}
+  {
+    assert(mTextures3D || mVertices.size()==0);
+    mTextures3D=true;
+    mVertices.push_back(pVertex);
+    mColors.push_back(pColor);
+    mNormals.push_back(pNormal);
+    mTexCoords3D.push_back(pTex);
+    mChanged=true;
+    if(mVertices.size()==1)
+      bbox=AGBox3(pVertex.dim3(),AGVector3(0,0,0));
+    else
+      bbox.include(pVertex.dim3());
+  }
 
 void VertexArray::addTriangle(size_t p0,size_t p1,size_t p2)
-{
-  assert(p0<mVertices.size());
-  assert(p1<mVertices.size());
-  assert(p2<mVertices.size());
-  mIndices.push_back(p0);
-  mIndices.push_back(p1);
-  mIndices.push_back(p2);
-  mChanged=true;
-}
+  {
+    assert(p0<mVertices.size());
+    assert(p1<mVertices.size());
+    assert(p2<mVertices.size());
+    mIndices.push_back(p0);
+    mIndices.push_back(p1);
+    mIndices.push_back(p2);
+    mChanged=true;
+  }
 
 void VertexArray::init()
-{
-  if(mBuffers)
-    {
-      STACKTRACE;
-      glGenBuffersARB( 1, &mVertexBuffer );
-      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer );
-      glBufferDataARB( GL_ARRAY_BUFFER_ARB, mVertices.size()*sizeof(AGVector4), &(mVertices[0]), GL_STATIC_DRAW_ARB );
-      
-      glGenBuffersARB( 1, &mColorBuffer );
-      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mColorBuffer );
-      glBufferDataARB( GL_ARRAY_BUFFER_ARB, mColors.size()*sizeof(AGVector4), &(mColors[0]), GL_STATIC_DRAW_ARB );
-      
-      glGenBuffersARB( 1, &mNormalBuffer );
-      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mNormalBuffer );
-      glBufferDataARB( GL_ARRAY_BUFFER_ARB, mNormals.size()*sizeof(AGVector3), &(mNormals[0]), GL_STATIC_DRAW_ARB );
-      
-      glGenBuffersARB( 1, &mTexBuffer );
-      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer );
-      if(mTextures3D)
-	glBufferDataARB( GL_ARRAY_BUFFER_ARB, mTexCoords3D.size()*sizeof(AGVector3), &(mTexCoords3D[0]), GL_STATIC_DRAW_ARB );
-      else
-	glBufferDataARB( GL_ARRAY_BUFFER_ARB, mTexCoords.size()*sizeof(AGVector2), &(mTexCoords[0]), GL_STATIC_DRAW_ARB );
+  {
+    if(mBuffers)
+      {
+        STACKTRACE;
+        glGenBuffersARB( 1, &mVertexBuffer );
+        glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer );
+        glBufferDataARB( GL_ARRAY_BUFFER_ARB, mVertices.size()*sizeof(AGVector4), &(mVertices[0]), GL_STATIC_DRAW_ARB );
 
-      if(!mDynamic)
-	{
-	  glGenBuffersARB( 1, &mIndexBuffer );
-	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer );
-	  glBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndices.size()*sizeof(Uint16), &(mIndices[0]), GL_STATIC_DRAW_ARB );
-	}
+        glGenBuffersARB( 1, &mColorBuffer );
+        glBindBufferARB( GL_ARRAY_BUFFER_ARB, mColorBuffer );
+        glBufferDataARB( GL_ARRAY_BUFFER_ARB, mColors.size()*sizeof(AGVector4), &(mColors[0]), GL_STATIC_DRAW_ARB );
 
-      glBindBufferARB( GL_ARRAY_BUFFER_ARB, 0);
-      glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
+        glGenBuffersARB( 1, &mNormalBuffer );
+        glBindBufferARB( GL_ARRAY_BUFFER_ARB, mNormalBuffer );
+        glBufferDataARB( GL_ARRAY_BUFFER_ARB, mNormals.size()*sizeof(AGVector3), &(mNormals[0]), GL_STATIC_DRAW_ARB );
 
+        glGenBuffersARB( 1, &mTexBuffer );
+        glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer );
+        if(mTextures3D)
+          glBufferDataARB( GL_ARRAY_BUFFER_ARB, mTexCoords3D.size()*sizeof(AGVector3), &(mTexCoords3D[0]), GL_STATIC_DRAW_ARB );
+        else
+          glBufferDataARB( GL_ARRAY_BUFFER_ARB, mTexCoords.size()*sizeof(AGVector2), &(mTexCoords[0]), GL_STATIC_DRAW_ARB );
 
-    }
-  mChanged=false;
-}
+        if(!mDynamic)
+          {
+            glGenBuffersARB( 1, &mIndexBuffer );
+            glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer );
+            glBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndices.size()*sizeof(Uint16), &(mIndices[0]), GL_STATIC_DRAW_ARB );
+          }
 
+        glBindBufferARB( GL_ARRAY_BUFFER_ARB, 0);
+        glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
+
+
+      }
+    mChanged=false;
+  }
+
 void VertexArray::setColors(bool color)
-{
-  bColor=color;
-}
+  {
+    bColor=color;
+  }
 
 void VertexArray::draw()
-{
-  assertGL;
-  if(mChanged)
-    init();
+  {
+    assertGL;
+    if(mChanged)
+      init();
 
-  assertGL;
+    assertGL;
 
-  if(mBuffers||mArrays)
-    {
-      glEnableClientState(GL_VERTEX_ARRAY);
-      glEnableClientState(GL_NORMAL_ARRAY);
-      if(bColor)
-	glEnableClientState(GL_COLOR_ARRAY);
-      else
-	glDisableClientState(GL_COLOR_ARRAY);
-      glEnableClientState(GL_TEXTURE_COORD_ARRAY);
-    }
+    if(mBuffers||mArrays)
+      {
+        glEnableClientState(GL_VERTEX_ARRAY);
+        glEnableClientState(GL_NORMAL_ARRAY);
+        if(bColor)
+          glEnableClientState(GL_COLOR_ARRAY);
+        else
+          glDisableClientState(GL_COLOR_ARRAY);
+        glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+      }
 
-  if(mBuffers)
-    {
-      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mNormalBuffer );
-      glNormalPointer(GL_FLOAT, 0, 0);
+    if(mBuffers)
+      {
+        glBindBufferARB( GL_ARRAY_BUFFER_ARB, mNormalBuffer );
+        glNormalPointer(GL_FLOAT, 0, 0);
 
-      /*
+        /*
       glClientActiveTexture(GL_TEXTURE1);
       glEnableClientState(GL_TEXTURE_COORD_ARRAY);
       glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer);
       glTexCoordPointer(2, GL_FLOAT, 0, 0);
-      */
-      glClientActiveTexture(GL_TEXTURE0);
+         */
+        glClientActiveTexture(GL_TEXTURE0);
 
-      glEnableClientState(GL_TEXTURE_COORD_ARRAY);
-      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer);
-      if(mTextures3D)
-	glTexCoordPointer(3, GL_FLOAT, 0, 0);
-      else
-	glTexCoordPointer(2, GL_FLOAT, 0, 0);
+        glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+        glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer);
+        if(mTextures3D)
+          glTexCoordPointer(3, GL_FLOAT, 0, 0);
+        else
+          glTexCoordPointer(2, GL_FLOAT, 0, 0);
 
-      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer);
-      glVertexPointer(4, GL_FLOAT, 0, 0);
-      if(bColor)
-	{
-	  glBindBufferARB( GL_ARRAY_BUFFER_ARB, mColorBuffer);
-	  glColorPointer(4, GL_FLOAT, 0, 0);
-	}
+        glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer);
+        glVertexPointer(4, GL_FLOAT, 0, 0);
+        if(bColor)
+          {
+            glBindBufferARB( GL_ARRAY_BUFFER_ARB, mColorBuffer);
+            glColorPointer(4, GL_FLOAT, 0, 0);
+          }
 
-      if(mDynamic)
-	{
-	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
-			 &(mIndices[0]));
-	}
-      else
-	{
-	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer);
-	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,0);
-	}
-    }
-  else if(mArrays)
-    {
-      //      cdebug("too much work");
-      glNormalPointer(GL_FLOAT, 0, &(mNormals[0]));
-      glClientActiveTexture(GL_TEXTURE0);
-      if(mTextures3D)
-	glTexCoordPointer(3, GL_FLOAT, 0, &(mTexCoords3D[0]));
-      else
-	glTexCoordPointer(2, GL_FLOAT, 0, &(mTexCoords[0]));
-      glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
-      if(bColor)
-	glColorPointer(4, GL_FLOAT, 0, &(mColors[0]));
-      glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
-		     &(mIndices[0]));
-  }
-  else
-    {
-      glClientActiveTexture(GL_TEXTURE0);
-      glBegin(GL_TRIANGLES);
-      for(std::vector<Uint16>::iterator i=mIndices.begin();i!=mIndices.end();i++)
-	{
-	  glNormal3fv(mNormals[*i]);
-	  if(mTextures3D)
-	    glTexCoord3fv(mTexCoords3D[*i]);
-	  else
-	    glTexCoord2fv(mTexCoords[*i]);
-	  if(bColor)
-	    glColor4fv(mColors[*i]);
-	  glVertex4fv(mVertices[*i]);
-	}
-      glEnd();
-      
-    }
+        if(mDynamic)
+          {
+            glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+                &(mIndices[0]));
+          }
+        else
+          {
+            glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer);
+            glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,0);
+          }
+      }
+    else if(mArrays)
+      {
+        //      cdebug("too much work");
+        glNormalPointer(GL_FLOAT, 0, &(mNormals[0]));
+        glClientActiveTexture(GL_TEXTURE0);
+        if(mTextures3D)
+          glTexCoordPointer(3, GL_FLOAT, 0, &(mTexCoords3D[0]));
+        else
+          glTexCoordPointer(2, GL_FLOAT, 0, &(mTexCoords[0]));
+        glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
+        if(bColor)
+          glColorPointer(4, GL_FLOAT, 0, &(mColors[0]));
+        glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+            &(mIndices[0]));
+      }
+    else
+      {
+        glClientActiveTexture(GL_TEXTURE0);
+        glBegin(GL_TRIANGLES);
+        for(std::vector<Uint16>::iterator i=mIndices.begin();i!=mIndices.end();i++)
+          {
+            glNormal3fv(mNormals[*i]);
+            if(mTextures3D)
+              glTexCoord3fv(mTexCoords3D[*i]);
+            else
+              glTexCoord2fv(mTexCoords[*i]);
+            if(bColor)
+              glColor4fv(mColors[*i]);
+            glVertex4fv(mVertices[*i]);
+          }
+        glEnd();
 
-  if(mBuffers||mArrays)
-    {
-      glDisableClientState(GL_VERTEX_ARRAY);
-      glDisableClientState(GL_NORMAL_ARRAY);
-      glDisableClientState(GL_COLOR_ARRAY);
-      glDisableClientState(GL_TEXTURE_COORD_ARRAY);
-    }
-  assertGL;
+      }
 
-}
+    if(mBuffers||mArrays)
+      {
+        glDisableClientState(GL_VERTEX_ARRAY);
+        glDisableClientState(GL_NORMAL_ARRAY);
+        glDisableClientState(GL_COLOR_ARRAY);
+        glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+      }
+    assertGL;
 
+  }
+
 void VertexArray::drawPick()
-{
-  STACKTRACE;
-  if(false)
-    {
-      // use vertex arrays
-      glEnableClientState(GL_VERTEX_ARRAY);
+  {
+    STACKTRACE;
+    if(false)
+      {
+        // use vertex arrays
+        glEnableClientState(GL_VERTEX_ARRAY);
 
-      glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
-      glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
-		     &(mIndices[0]));
-      
-      glDisableClientState(GL_VERTEX_ARRAY);
+        glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
+        glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+            &(mIndices[0]));
 
-    }
+        glDisableClientState(GL_VERTEX_ARRAY);
 
-  else if(true)
-    {
-      if(displayListInited)
-	{
-	  STACKTRACE;
-	  
-	  glCallList(displayList);
-	}
-      else
-	{
-	  displayList=glGenLists(1);
-	  glNewList(displayList,GL_COMPILE);
-	  {
-	    // paint in software - because this is faster for picking
-	    glBegin(GL_TRIANGLES);
-	    for(std::vector<Uint16>::iterator i=mIndices.begin();i!=mIndices.end();i++)
-	      glVertex4fv(mVertices[*i]);
-	    glEnd();
-	  }
-	  glEndList();
-	  glCallList(displayList);
+      }
 
-	  displayListInited=true;
-	}
-    }
-  else
-    {
-      // FIXME: some this doesn't - what the heck!
-      if(mChanged)
-	init();
-      
-      
-      glEnableClientState(GL_VERTEX_ARRAY);
-      
-      
-      // disable textures
-      glClientActiveTexture(GL_TEXTURE1);
-      glDisableClientState(GL_TEXTURE_COORD_ARRAY);
-      glClientActiveTexture(GL_TEXTURE0);
-      
-      glDisableClientState(GL_TEXTURE_COORD_ARRAY);
-      
+    else if(true)
       {
-	cdebug(mVertices.size());
-	cdebug(mIndices.size());
-	glBindBufferARB( GL_ARRAY_BUFFER_ARB,0);
-	glNormalPointer(GL_FLOAT,0,0);
-	glBindBufferARB( GL_ARRAY_BUFFER_ARB,0);
-	glTexCoordPointer(2,GL_FLOAT,0,0);
-	glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
-	glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
-		       &(mIndices[0]));
+        if(displayListInited)
+          {
+            STACKTRACE;
+
+            glCallList(displayList);
+          }
+        else
+          {
+            displayList=glGenLists(1);
+            glNewList(displayList,GL_COMPILE);
+              {
+                // paint in software - because this is faster for picking
+                glBegin(GL_TRIANGLES);
+                for(std::vector<Uint16>::iterator i=mIndices.begin();i!=mIndices.end();i++)
+                  glVertex4fv(mVertices[*i]);
+                glEnd();
+              }
+              glEndList();
+              glCallList(displayList);
+
+              displayListInited=true;
+          }
       }
-      
-      glDisableClientState(GL_VERTEX_ARRAY);
-    }
-}
+    else
+      {
+        // FIXME: some this doesn't - what the heck!
+        if(mChanged)
+          init();
 
 
+        glEnableClientState(GL_VERTEX_ARRAY);
 
+
+        // disable textures
+        glClientActiveTexture(GL_TEXTURE1);
+        glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+        glClientActiveTexture(GL_TEXTURE0);
+
+        glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+
+          {
+            cdebug(mVertices.size());
+            cdebug(mIndices.size());
+            glBindBufferARB( GL_ARRAY_BUFFER_ARB,0);
+            glNormalPointer(GL_FLOAT,0,0);
+            glBindBufferARB( GL_ARRAY_BUFFER_ARB,0);
+            glTexCoordPointer(2,GL_FLOAT,0,0);
+            glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
+            glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+                &(mIndices[0]));
+          }
+
+          glDisableClientState(GL_VERTEX_ARRAY);
+      }
+  }
+
+
+
 void VertexArray::drawDepth()
-{
+  {
 #ifdef OLD
-  if(mChanged)
-    init();
+    if(mChanged)
+      init();
 
-  glEnableClientState(GL_VERTEX_ARRAY);
+    glEnableClientState(GL_VERTEX_ARRAY);
 
 
-  //  glDisable(GL_TEXTURE_2D);
+    //  glDisable(GL_TEXTURE_2D);
 
-  if(mBuffers)
-    {
-      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer);
-      glVertexPointer(4, GL_FLOAT, 0, 0);
+    if(mBuffers)
+      {
+        glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer);
+        glVertexPointer(4, GL_FLOAT, 0, 0);
 
-      if(mDynamic)
-	{
-	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
-			 &(mIndices[0]));
-	}
-      else
-	{
-	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer);
-	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,0);
-	}
+        if(mDynamic)
+          {
+            glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+                &(mIndices[0]));
+          }
+        else
+          {
+            glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer);
+            glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,0);
+          }
 
-    }
-  else
-    {
-      //      cdebug("too much work");
-      glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
+      }
+    else
+      {
+        //      cdebug("too much work");
+        glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
 
-      glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
-		     &(mIndices[0]));
-  }
+        glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+            &(mIndices[0]));
+      }
 
-  //  glEnable(GL_TEXTURE_2D);
+    //  glEnable(GL_TEXTURE_2D);
 
-  glDisableClientState(GL_VERTEX_ARRAY);
+    glDisableClientState(GL_VERTEX_ARRAY);
 #else
-  if(mChanged)
-    init();
+    if(mChanged)
+      init();
 
-  glEnableClientState(GL_VERTEX_ARRAY);
+    glEnableClientState(GL_VERTEX_ARRAY);
 
-  glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+    glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 
 
-  if(mBuffers)
-    {
-      glClientActiveTexture(GL_TEXTURE0);
+    if(mBuffers)
+      {
+        glClientActiveTexture(GL_TEXTURE0);
 
-      glEnableClientState(GL_TEXTURE_COORD_ARRAY);
-      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer);
-      if(mTextures3D)
-	glTexCoordPointer(3, GL_FLOAT, 0, 0);
-      else
-	glTexCoordPointer(2, GL_FLOAT, 0, 0);
+        glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+        glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer);
+        if(mTextures3D)
+          glTexCoordPointer(3, GL_FLOAT, 0, 0);
+        else
+          glTexCoordPointer(2, GL_FLOAT, 0, 0);
 
-      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer);
-      glVertexPointer(4, GL_FLOAT, 0, 0);
+        glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer);
+        glVertexPointer(4, GL_FLOAT, 0, 0);
 
-      if(mDynamic)
-	{
-	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
-			 &(mIndices[0]));
-	}
-      else
-	{
-	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer);
-	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,0);
-	}
+        if(mDynamic)
+          {
+            glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+                &(mIndices[0]));
+          }
+        else
+          {
+            glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer);
+            glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,0);
+          }
 
-    }
-  else
-    {
-      if(mTextures3D)
-	glTexCoordPointer(3, GL_FLOAT, 0, &(mTexCoords3D[0]));
-      else
-	glTexCoordPointer(2, GL_FLOAT, 0, &(mTexCoords[0]));
-      glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
+      }
+    else
+      {
+        if(mTextures3D)
+          glTexCoordPointer(3, GL_FLOAT, 0, &(mTexCoords3D[0]));
+        else
+          glTexCoordPointer(2, GL_FLOAT, 0, &(mTexCoords[0]));
+        glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
 
-      glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
-		     &(mIndices[0]));
-  }
+        glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+            &(mIndices[0]));
+      }
 
-  glDisableClientState(GL_VERTEX_ARRAY);
-  glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+    glDisableClientState(GL_VERTEX_ARRAY);
+    glDisableClientState(GL_TEXTURE_COORD_ARRAY);
 #endif
-}
+  }
 
 
 
@@ -440,77 +440,69 @@
       AGVector4 r;
       r=t.collide(pLine);
       if(r[3]==1)
-	{
-	  return r;
-	}
+        {
+          return r;
+        }
     }
   return mfalse;
 }
 
 void VertexArray::update()
-{
-  if(mBuffers && mVertexBuffer!=0) //mChanged==false)
-    {
-      glDeleteBuffersARB( 1, &mVertexBuffer );
-      glDeleteBuffersARB( 1, &mColorBuffer );
-      glDeleteBuffersARB( 1, &mNormalBuffer );
-      glDeleteBuffersARB( 1, &mTexBuffer );
-      glDeleteBuffersARB( 1, &mIndexBuffer );
-      mVertexBuffer=0;
-    }
-  mChanged=true;
-}
+  {
+    if(mBuffers && mVertexBuffer!=0) //mChanged==false)
+      {
+        glDeleteBuffersARB( 1, &mVertexBuffer );
+        glDeleteBuffersARB( 1, &mColorBuffer );
+        glDeleteBuffersARB( 1, &mNormalBuffer );
+        glDeleteBuffersARB( 1, &mTexBuffer );
+        glDeleteBuffersARB( 1, &mIndexBuffer );
+        mVertexBuffer=0;
+      }
+    mChanged=true;
+  }
 void VertexArray::clear()
-{
-  /*  if(mBuffers && mVertexBuffer!=0) //mChanged==false)
-    {
-      glDeleteBuffersARB( 1, &mVertexBuffer );
-      glDeleteBuffersARB( 1, &mColorBuffer );
-      glDeleteBuffersARB( 1, &mNormalBuffer );
-      glDeleteBuffersARB( 1, &mTexBuffer );
-      glDeleteBuffersARB( 1, &mIndexBuffer );
-      }*/
-  mVertices.clear();
-  mColors.clear();
-  mNormals.clear();
-  mTexCoords.clear();
-  mTexCoords3D.clear();
-  mIndices.clear();
-  update();
-}
+  {
+    mVertices.clear();
+    mColors.clear();
+    mNormals.clear();
+    mTexCoords.clear();
+    mTexCoords3D.clear();
+    mIndices.clear();
+    update();
+  }
 
 void VertexArray::setBuffers(bool pBuffers)
-{
-  mBuffers=false;
-}
+  {
+    mBuffers=false;
+  }
 
 
 size_t VertexArray::getIndex(size_t i)
-{
-  return mIndices[i];
-}
+  {
+    return mIndices[i];
+  }
 AGVector4 VertexArray::getVertex(size_t i)
-{
-  return mVertices[i];
-}
+  {
+    return mVertices[i];
+  }
 AGVector4 VertexArray::getColor(size_t i)
-{
-  return mColors[i];
-}
+  {
+    return mColors[i];
+  }
 AGVector3 VertexArray::getNormal(size_t i)
-{
-  return mNormals[i];
-}
-  AGVector2 VertexArray::getTexCoord(size_t i)
-{
-  return mTexCoords[i];
-}
+  {
+    return mNormals[i];
+  }
+AGVector2 VertexArray::getTexCoord(size_t i)
+  {
+    return mTexCoords[i];
+  }
 
 void VertexArray::setTexCoord(size_t i,const AGVector2 &t)
-{
-  mTexCoords[i]=t;
-  update();
-}
+  {
+    mTexCoords[i]=t;
+    update();
+  }
 
 bool VertexArray::useVertexArrays() const
 {
@@ -519,23 +511,23 @@
 
 
 void VertexArray::onScreenUp()
-{
+  {
     init();
-}
+  }
 
 void VertexArray::onScreenDown()
-{
-  if(mBuffers && mVertexBuffer!=0) //mChanged==false)
-    {
-      glDeleteBuffersARB( 1, &mVertexBuffer );
-      glDeleteBuffersARB( 1, &mColorBuffer );
-      glDeleteBuffersARB( 1, &mNormalBuffer );
-      glDeleteBuffersARB( 1, &mTexBuffer );
-      if(!mDynamic)
-	glDeleteBuffersARB( 1, &mIndexBuffer );
-    }
-  mVertexBuffer=mColorBuffer=mNormalBuffer=mTexBuffer=mIndexBuffer=0;
-}
+  {
+    if(mBuffers && mVertexBuffer!=0) //mChanged==false)
+      {
+        glDeleteBuffersARB( 1, &mVertexBuffer );
+        glDeleteBuffersARB( 1, &mColorBuffer );
+        glDeleteBuffersARB( 1, &mNormalBuffer );
+        glDeleteBuffersARB( 1, &mTexBuffer );
+        if(!mDynamic)
+          glDeleteBuffersARB( 1, &mIndexBuffer );
+      }
+    mVertexBuffer=mColorBuffer=mNormalBuffer=mTexBuffer=mIndexBuffer=0;
+  }
 
 
 
@@ -551,155 +543,170 @@
   aInited=false;
 }
 VertexArrayShader::~VertexArrayShader()
-{
-  for(std::map<std::string,std::vector<float>*>::iterator i=as.begin();i!=as.end();++i)
-    {
-      if(i->second)
-	delete i->second;
-    }
+  {
+    for(std::map<std::string,std::vector<float>*>::iterator i=as.begin();i!=as.end();++i)
+      {
+        if(i->second)
+          delete i->second;
+      }
 
-  for(std::map<std::string,std::vector<Uint16>*>::iterator i=elementAs.begin();i!=elementAs.end();++i)
-    {
-      if(i->second)
-	delete i->second;
-    }
+    for(std::map<std::string,std::vector<Uint16>*>::iterator i=elementAs.begin();i!=elementAs.end();++i)
+      {
+        if(i->second)
+          delete i->second;
+      }
 
-}
+  }
 
 void VertexArrayShader::addAttribute(const std::string &pName,const std::vector<float> &a)
-{
-  as[pName]=new std::vector<float>(a);
-  aInited=false;
-}
+  {
+    as[pName]=new std::vector<float>(a);
+    aInited=false;
+  }
 
 void VertexArrayShader::addAttribute(const std::string &pName,const std::vector<Uint16> &a)
-{
-  elementAs[pName]=new std::vector<Uint16>(a);
-  aInited=false;
-}
+  {
+    elementAs[pName]=new std::vector<Uint16>(a);
+    aInited=false;
+  }
 
 
+void VertexArrayShader::onScreenUp()
+  {
+    CTRACE;
+    VertexArray::onScreenUp();
+    
+  }
+void VertexArrayShader::onScreenDown()
+  {
+    CTRACE;
+    VertexArray::onScreenDown();
+    aInited=false;
+    // FIXME: cleanup gl-objects
+  }
+
+
 void VertexArrayShader::draw()
-{
-  assertGL;
-  p->enable();
-  assertGL;
-  if(!aInited)
-    aInit();
-  assertGL;
-  attach();
-  assertGL;
-  VertexArray::draw();
-  p->disable();
-}
+  {
+    assertGL;
+    p->enable();
+    assertGL;
+    if(!aInited)
+      aInit();
+    assertGL;
+    attach();
+    assertGL;
+    VertexArray::draw();
+    p->disable();
+  }
 
 void VertexArrayShader::attach()
-{
-  //  if(useVertexArrays())
-    {
-      for(std::map<std::string,unsigned int>::iterator i=aids.begin();i!=aids.end();i++)
-	{
-	  GLint loc=p->getAttr(i->first);
-	  glEnableClientState(GL_VERTEX_ARRAY);
-	  glEnableVertexAttribArrayARB(loc); // add array
-	  glBindBufferARB( GL_ARRAY_BUFFER_ARB, i->second);
-	  glVertexAttribPointerARB(loc,1,GL_FLOAT,0,0,0);
-	  //      glTexCoordPointer(2, GL_FLOAT, 0, 0);
-	}
+  {
+    //  if(useVertexArrays())
+      {
+        for(std::map<std::string,unsigned int>::iterator i=aids.begin();i!=aids.end();i++)
+          {
+            GLint loc=p->getAttr(i->first);
+            glEnableClientState(GL_VERTEX_ARRAY);
+            glEnableVertexAttribArrayARB(loc); // add array
+            glBindBufferARB( GL_ARRAY_BUFFER_ARB, i->second);
+            glVertexAttribPointerARB(loc,1,GL_FLOAT,0,0,0);
+            //      glTexCoordPointer(2, GL_FLOAT, 0, 0);
+          }
 
-      for(std::map<std::string,unsigned int>::iterator i=elementIds.begin();i!=elementIds.end();i++)
-	{
-  assertGL;
-	  GLint loc=p->getAttr(i->first);
-  assertGL;
-	  glEnableClientState(GL_VERTEX_ARRAY);
-  assertGL;
-	  glEnableVertexAttribArrayARB(loc); // add array
-  assertGL;
-	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, i->second);
-  assertGL;
-	  glVertexAttribPointerARB(loc,1,GL_UNSIGNED_SHORT,0,0,0);
-  assertGL;
-	  //      glTexCoordPointer(2, GL_FLOAT, 0, 0);
-	}
+        for(std::map<std::string,unsigned int>::iterator i=elementIds.begin();i!=elementIds.end();i++)
+          {
+            assertGL;
+            GLint loc=p->getAttr(i->first);
+            assertGL;
+            glEnableClientState(GL_VERTEX_ARRAY);
+            assertGL;
+            glEnableVertexAttribArrayARB(loc); // add array
+            assertGL;
+            glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, i->second);
+            assertGL;
+            glVertexAttribPointerARB(loc,1,GL_UNSIGNED_SHORT,0,0,0);
+            assertGL;
+            //      glTexCoordPointer(2, GL_FLOAT, 0, 0);
+          }
 
-    }
-}
+      }
+  }
 
 void VertexArrayShader::aInit()
-{
-  for(std::map<std::string,std::vector<float>*>::iterator i=as.begin();i!=as.end();i++)
-    {
-      unsigned int id;
+  {
+    for(std::map<std::string,std::vector<float>*>::iterator i=as.begin();i!=as.end();i++)
+      {
+        unsigned int id;
 
-      glGenBuffersARB( 1, &id);
-      glBindBufferARB( GL_ARRAY_BUFFER_ARB, id);
-      glBufferDataARB( GL_ARRAY_BUFFER_ARB, i->second->size()*sizeof(float), &((*i->second)[0]), GL_STATIC_DRAW_ARB );
+        glGenBuffersARB( 1, &id);
+        glBindBufferARB( GL_ARRAY_BUFFER_ARB, id);
+        glBufferDataARB( GL_ARRAY_BUFFER_ARB, i->second->size()*sizeof(float), &((*i->second)[0]), GL_STATIC_DRAW_ARB );
 
-      aids[i->first]=id;
-    }
+        aids[i->first]=id;
+      }
 
-  for(std::map<std::string,std::vector<Uint16>*>::iterator i=elementAs.begin();i!=elementAs.end();i++)
-    {
-      unsigned int id;
+    for(std::map<std::string,std::vector<Uint16>*>::iterator i=elementAs.begin();i!=elementAs.end();i++)
+      {
+        unsigned int id;
 
-      glGenBuffersARB( 1, &id);
-      glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, id);
-      glBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, i->second->size()*sizeof(Uint16), &((*i->second)[0]), GL_STATIC_DRAW_ARB );
+        glGenBuffersARB( 1, &id);
+        glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, id);
+        glBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, i->second->size()*sizeof(Uint16), &((*i->second)[0]), GL_STATIC_DRAW_ARB );
 
-      elementIds[i->first]=id;
-    }
+        elementIds[i->first]=id;
+      }
 
 
-  aInited=true;
-}
+    aInited=true;
+  }
 
 
 VertexArray *makeInstances(const VertexArray &va,const std::vector<AGMatrix4> &ts)
-{
-  VertexArray *na=new VertexArray;
-  size_t start=0;
-  size_t ci;
+  {
+    VertexArray *na=new VertexArray;
+    size_t start=0;
+    size_t ci;
 
-  for(std::vector<AGMatrix4>::const_iterator i=ts.begin();i!=ts.end();i++)
-    {
-      assert(va.mVertices.size()==va.mNormals.size());
-      // transform normals and vertices
-      for(size_t j=0;j<va.mVertices.size();j++)
-	{
-	  AGVector4 v=va.mVertices[j];
-	  AGVector3 n=va.mNormals[j];
+    for(std::vector<AGMatrix4>::const_iterator i=ts.begin();i!=ts.end();i++)
+      {
+        assert(va.mVertices.size()==va.mNormals.size());
+        // transform normals and vertices
+        for(size_t j=0;j<va.mVertices.size();j++)
+          {
+            AGVector4 v=va.mVertices[j];
+            AGVector3 n=va.mNormals[j];
 
-	  v=*i*v;
-	  n=(*i*AGVector4(n,0)).dim3();
-	  
-	  na->mVertices.push_back(v);
-	  na->mNormals.push_back(n);
-	}
+            v=*i*v;
+            n=(*i*AGVector4(n,0)).dim3();
 
-      std::copy(va.mColors.begin(),va.mColors.end(),std::back_inserter(na->mColors));
-      std::copy(va.mTexCoords.begin(),va.mTexCoords.end(),std::back_inserter(na->mTexCoords));
-      std::copy(va.mTexCoords3D.begin(),va.mTexCoords3D.end(),std::back_inserter(na->mTexCoords3D));
-      for(std::vector<Uint16>::const_iterator j=va.mIndices.begin();j!=va.mIndices.end();j++)
-	{
-	  ci=*j+start;
-	  assert(ci>=start);
-	  assert(ci<na->mVertices.size());
-	  assert(ci<na->mColors.size());
-	  assert(ci<na->mNormals.size());
-	    
-	  na->mIndices.push_back(*j+start);
-	}
-      start+=va.mVertices.size();
-    }
+            na->mVertices.push_back(v);
+            na->mNormals.push_back(n);
+          }
 
-  na->bColor=va.bColor;
-  na->mChanged=true;
+        std::copy(va.mColors.begin(),va.mColors.end(),std::back_inserter(na->mColors));
+        std::copy(va.mTexCoords.begin(),va.mTexCoords.end(),std::back_inserter(na->mTexCoords));
+        std::copy(va.mTexCoords3D.begin(),va.mTexCoords3D.end(),std::back_inserter(na->mTexCoords3D));
+        for(std::vector<Uint16>::const_iterator j=va.mIndices.begin();j!=va.mIndices.end();j++)
+          {
+            ci=*j+start;
+            assert(ci>=start);
+            assert(ci<na->mVertices.size());
+            assert(ci<na->mColors.size());
+            assert(ci<na->mNormals.size());
 
-  // calc bbox
-  na->bbox=AGBox3(AGVector3(),AGVector3());
+            na->mIndices.push_back(*j+start);
+          }
+        start+=va.mVertices.size();
+      }
 
-  
+    na->bColor=va.bColor;
+    na->mChanged=true;
 
-  return na;
-}
+    // calc bbox
+    na->bbox=AGBox3(AGVector3(),AGVector3());
+
+
+
+    return na;
+  }

Modified: antargis/trunk/ext/3dengine/vertex_array.h
===================================================================
--- antargis/trunk/ext/3dengine/vertex_array.h	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ext/3dengine/vertex_array.h	2008-02-15 20:44:14 UTC (rev 1229)
@@ -83,8 +83,8 @@
   bool useVertexArrays() const;
   friend VertexArray *makeInstances(const VertexArray &va,const std::vector<AGMatrix4> &ts);
 
-  void onScreenUp();
-  void onScreenDown();
+  virtual void onScreenUp();
+  virtual void onScreenDown();
 
 };
 
@@ -118,6 +118,9 @@
 
   virtual void draw();
 
+  virtual void onScreenUp();
+  virtual void onScreenDown();
+
  private:
   void aInit();
   void attach();

Modified: antargis/trunk/ext/game/entity.cc
===================================================================
--- antargis/trunk/ext/game/entity.cc	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ext/game/entity.cc	2008-02-15 20:44:14 UTC (rev 1229)
@@ -870,6 +870,17 @@
   return dynamic_cast<MoveJob*>(mJob);
 }
 
+AGVector2 AntEntity::getTargetPos2D()
+{
+	if(mJob) {
+		MoveJob *m=dynamic_cast<MoveJob*>(mJob);
+		if(m)
+			return m->getTargetPos2D();
+	}
+	return getPos2D();
+}
+
+
 AntEntity *AntEntity::getTarget()
 {
   if(mJob)

Modified: antargis/trunk/ext/game/entity.h
===================================================================
--- antargis/trunk/ext/game/entity.h	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ext/game/entity.h	2008-02-15 20:44:14 UTC (rev 1229)
@@ -276,6 +276,7 @@
     AntMap *getMap();
 
     AntEntity *getTarget();
+    AGVector2 getTargetPos2D();
 
   private:
     void init();

Modified: antargis/trunk/ext/game/jobs.cc
===================================================================
--- antargis/trunk/ext/game/jobs.cc	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ext/game/jobs.cc	2008-02-15 20:44:14 UTC (rev 1229)
@@ -145,6 +145,12 @@
   
 }
 
+AGVector2 MoveJob::getTargetPos2D() const
+{
+	return mTarget;
+}
+
+
 AGVector2 MoveJob::getDirection(const AntEntity *e) const
 {
   return (mTarget-e->getPos2D()).normalized();

Modified: antargis/trunk/ext/game/jobs.h
===================================================================
--- antargis/trunk/ext/game/jobs.h	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ext/game/jobs.h	2008-02-15 20:44:14 UTC (rev 1229)
@@ -96,6 +96,7 @@
     {
       return mTargetEntity;
     }
+  AGVector2 getTargetPos2D() const;
   
  private:
   void moveBy(AntEntity *e,float ptime,float aspeed);

Modified: antargis/trunk/ext/video/ag_glscreen.cc
===================================================================
--- antargis/trunk/ext/video/ag_glscreen.cc	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ext/video/ag_glscreen.cc	2008-02-15 20:44:14 UTC (rev 1229)
@@ -55,37 +55,37 @@
 
 void initDraw()
 {
-  glEnable( GL_BLEND );
-  glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
+	glEnable( GL_BLEND );
+	glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
 
-  glDisable(GL_DEPTH_TEST); // enable depth test
-  glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT); // clear screen and depth buffer
-  glLoadIdentity();
-  glDepthMask(false);
-  //  glTranslatef(0.375, 0.375, 0.0);
-  glEnable(GL_CULL_FACE);
-  glCullFace(GL_BACK);
+	glDisable(GL_DEPTH_TEST); // enable depth test
+	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT); // clear screen and depth buffer
+	glLoadIdentity();
+	glDepthMask(false);
+	//  glTranslatef(0.375, 0.375, 0.0);
+	glEnable(GL_CULL_FACE);
+	glCullFace(GL_BACK);
 }
 
 void initGUIView(int w,int h)
 {
-  glMatrixMode( GL_PROJECTION );
-  glLoadIdentity( );
+	glMatrixMode( GL_PROJECTION );
+	glLoadIdentity( );
 
-  GLfloat ratio;
+	GLfloat ratio;
 
-  ratio = ( float )w / ( float )h;
+	ratio = ( float )w / ( float )h;
 
-  gluOrtho2D(0,w,0,h);
+	gluOrtho2D(0,w,0,h);
 
-  glMatrixMode( GL_MODELVIEW );
-  glLoadIdentity( );
+	glMatrixMode( GL_MODELVIEW );
+	glLoadIdentity( );
 
 }
 
 void myFlip()
 {
-  SDL_GL_SwapBuffers();
+	SDL_GL_SwapBuffers();
 }
 
 ////////////////////////////////////////////////////////////////////////
@@ -95,12 +95,12 @@
 
 AGGLObject::AGGLObject()
 {
-  AGGLScreen::addGLObject(this);
+	AGGLScreen::addGLObject(this);
 }
 
 AGGLObject::~AGGLObject()
 {
-  AGGLScreen::removeGLObject(this);
+	AGGLScreen::removeGLObject(this);
 }
 
 void AGGLObject::onScreenDown()
@@ -118,43 +118,43 @@
 
 
 AGGLScreen::AGGLScreen(int W,int H,int VW,int VH):
-  w(VW),h(VH),
-  rw(W),rh(H)
-{
-  if(w<rw)
-    w=rw;
-  if(h<rh)
-    h=rh;
+	w(VW),h(VH),
+	rw(W),rh(H)
+	{
+	if(w<rw)
+		w=rw;
+	if(h<rh)
+		h=rh;
 
-  mLineWidth=2;
+	mLineWidth=2;
 
-  cdebug("w:"<<w<<" h:"<<h);
+	cdebug("w:"<<w<<" h:"<<h);
 
-  // init GL
-  glEnable(GL_TEXTURE_2D);
-  glShadeModel(GL_SMOOTH);
-  glClearColor(0.0f,0.0f,0.0f,0.0f); // clear bgcolor
-  glClearDepth(1.0f);      // clear depth buffer
-  glEnable(GL_DEPTH_TEST); // enable depth test
-  glDepthFunc(GL_LEQUAL); // set type depth test
-  glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // GL_NICEST // best perspective correction
-  glEnable(GL_BLEND);
+	// init GL
+	glEnable(GL_TEXTURE_2D);
+	glShadeModel(GL_SMOOTH);
+	glClearColor(0.0f,0.0f,0.0f,0.0f); // clear bgcolor
+	glClearDepth(1.0f);      // clear depth buffer
+	glEnable(GL_DEPTH_TEST); // enable depth test
+	glDepthFunc(GL_LEQUAL); // set type depth test
+	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // GL_NICEST // best perspective correction
+	glEnable(GL_BLEND);
 
-  glViewport( 0, 0, rw, rh );
-  glMatrixMode( GL_PROJECTION );
-  glLoadIdentity( );
+	glViewport( 0, 0, rw, rh );
+	glMatrixMode( GL_PROJECTION );
+	glLoadIdentity( );
 
-  GLfloat ratio;
+	GLfloat ratio;
 
-  ratio = ( float )w / ( float )h;
+	ratio = ( float )w / ( float )h;
 
-  //  gluPerspective( 45.0f, ratio, 1.0f, 100.0f );
+	//  gluPerspective( 45.0f, ratio, 1.0f, 100.0f );
 
-  gluOrtho2D(0,w,0,h);
+	gluOrtho2D(0,w,0,h);
 
-  glMatrixMode( GL_MODELVIEW );
-  glLoadIdentity( );
-}
+	glMatrixMode( GL_MODELVIEW );
+	glLoadIdentity( );
+	}
 
 
 
@@ -165,276 +165,277 @@
 
 AGSurface AGGLScreen::screenshot(bool frontBuffer)
 {
-  AGSurface s(getWidth(),getHeight());
+	AGSurface s(getWidth(),getHeight());
 
-  //  SDL_Surface *surface=s.surface()->surface;
+	//  SDL_Surface *surface=s.surface()->surface;
 
-  unsigned char *buffer=new unsigned char[getWidth()*getHeight()*4];
+	unsigned char *buffer=new unsigned char[getWidth()*getHeight()*4];
 
-  if(frontBuffer)
-    glReadBuffer(GL_FRONT);
-  else
-    glReadBuffer(GL_BACK);
+	if(frontBuffer)
+		glReadBuffer(GL_FRONT);
+	else
+		glReadBuffer(GL_BACK);
 
-  cdebug(s.surface());
-  cdebug(s.surface()->surface);
+	cdebug(s.surface());
+	cdebug(s.surface()->surface);
 
-  glPixelStorei(GL_PACK_ALIGNMENT, 2);
-  assertGL;
-  glPixelStorei(GL_PACK_ROW_LENGTH, getWidth());
-  //                surface->pitch / surface->format->BytesPerPixel);
-  assertGL;
+	glPixelStorei(GL_PACK_ALIGNMENT, 2);
+	assertGL;
+	glPixelStorei(GL_PACK_ROW_LENGTH, getWidth());
+	//                surface->pitch / surface->format->BytesPerPixel);
+	assertGL;
 
 
-  {
-    TRACE;
-    glReadPixels(0,0,getWidth(),getHeight(),GL_RGBA,GL_UNSIGNED_BYTE,buffer);//s.surface()->surface);
-    glReadBuffer(GL_BACK);
-  }
+	{
+		TRACE;
+		glReadPixels(0,0,getWidth(),getHeight(),GL_RGBA,GL_UNSIGNED_BYTE,buffer);//s.surface()->surface);
+		glReadBuffer(GL_BACK);
+	}
 
-  {
-    // copy
-    TRACE;
-    int h=getHeight()-1;
-    for(int x=0;x<(int)getWidth();x++)
-      for(int y=0;y<(int)getHeight();y++)
 	{
-	  unsigned char*p=buffer+((x+(h-y)*getWidth())*4);
-	  AGColor c(p[0],p[1],p[2],p[3]);
-	  s.putPixel(x,y,c);
+		// copy
+		TRACE;
+		int h=getHeight()-1;
+		for(int x=0;x<(int)getWidth();x++)
+			for(int y=0;y<(int)getHeight();y++)
+			{
+				unsigned char*p=buffer+((x+(h-y)*getWidth())*4);
+				AGColor c(p[0],p[1],p[2],p[3]);
+				s.putPixel(x,y,c);
+			}
 	}
-  }
-  
 
-  delete [] buffer;
-  return s;
+
+	delete [] buffer;
+	return s;
 }
 
 
 void AGGLScreen::begin()
 {
-  glViewport( 0, 0, rw, rh );
-  glDisable(GL_LIGHTING);
-  glEnable(GL_TEXTURE_2D);
-  glShadeModel(GL_SMOOTH);
+	glViewport( 0, 0, rw, rh );
+	glDisable(GL_LIGHTING);
+	glEnable(GL_TEXTURE_2D);
+	glShadeModel(GL_SMOOTH);
 
-  glEnable(GL_DEPTH_TEST); // enable depth test
-  glDepthFunc(GL_LEQUAL); // set type depth test
-  glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // GL_NICEST // best perspective correction
-  glEnable(GL_BLEND);
+	glEnable(GL_DEPTH_TEST); // enable depth test
+	glDepthFunc(GL_LEQUAL); // set type depth test
+	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // GL_NICEST // best perspective correction
+	glEnable(GL_BLEND);
 
-  glViewport( 0, 0, rw, rh );
-  glMatrixMode( GL_PROJECTION );
-  glLoadIdentity( );
+	glViewport( 0, 0, rw, rh );
+	glMatrixMode( GL_PROJECTION );
+	glLoadIdentity( );
 
-  GLfloat ratio;
+	GLfloat ratio;
 
-  ratio = ( float )w / ( float )h;
+	ratio = ( float )w / ( float )h;
 
-  gluOrtho2D(0,w,0,h);
+	gluOrtho2D(0,w,0,h);
 
-  glMatrixMode( GL_MODELVIEW );
-  glLoadIdentity( );
+	glMatrixMode( GL_MODELVIEW );
+	glLoadIdentity( );
 
-  glEnable( GL_BLEND );
-  glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
+	glEnable( GL_BLEND );
+	glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
 
-  glDisable(GL_DEPTH_TEST); // enable depth test
+	glDisable(GL_DEPTH_TEST); // enable depth test
 
-  glDepthMask(false);
+	glDepthMask(false);
 }
 
 void AGGLScreen::flip()
 {
-  myFlip();
-  getSurfaceManager()->cleanup(); // FIXME: maybe delete it - or do cleanup in 2 stages
-  initDraw();
+	myFlip();
+	getSurfaceManager()->cleanup(); // FIXME: maybe delete it - or do cleanup in 2 stages
+	initDraw();
 
-  initGUIView(w,h);
+	initGUIView(w,h);
 }
 void AGGLScreen::update(const std::list<AGRect2> &rs)
 {
-  flip();
+	flip();
 }
 
 
 size_t next2pow(size_t i)
 {
-  size_t j=1;
-  while(j<i)
-    j<<=1;
+	size_t j=1;
+	while(j<i)
+		j<<=1;
 
-  return j;
+	return j;
 }
 
 
 bool AGGLScreen::inScreen(const AGRect2 &r) const
 {
-  return AGRect2(0,0,w,h).contains(r);
+	return AGRect2(0,0,w,h).contains(r);
 }
 
 void AGGLScreen::blit(const AGTexture &pSource,const AGRect2 &pRect,const AGRect2 &pSrc)
 {
-  blit(pSource,pRect,pSrc,AGColor(0xFF,0xFF,0xFF,0xFF));
+	blit(pSource,pRect,pSrc,AGColor(0xFF,0xFF,0xFF,0xFF));
 }
 
 void AGGLScreen::blit(const AGTexture &pSource,const AGRect2 &pRect,const AGRect2 &pSrc,const AGColor &pColor)
 {
-  AGGLPainter::blit(pSource,pRect,pSrc,pColor);
+	AGGLPainter::blit(pSource,pRect,pSrc,pColor);
 }
 
 
 void AGGLScreen::blit(const AGTexture &pSource,const std::vector<std::pair<AGRect2,AGRect2> > &pSrcDestRects,const AGColor &pColor)
 {
-  AGGLPainter::blit(pSource,pSrcDestRects,pColor);
+	AGGLPainter::blit(pSource,pSrcDestRects,pColor);
 }
 
 
 void AGGLScreen::tile(const AGTexture &pSource,const AGRect2 &pTarget,const AGColor &pColor)
 {
-  AGGLPainter::tile(pSource,pTarget,pColor);
+	AGGLPainter::tile(pSource,pTarget,pColor);
 }
 
 
 void AGGLScreen::fillRect(const AGRect2 &pRect,const AGColor &c)
 {
-  AGGLPainter::fillRect(pRect,c);
+	AGGLPainter::fillRect(pRect,c);
 }
 
 void AGGLScreen::fillRects(const std::vector<std::pair<AGRect2,AGVector4> > &pRects)
 {
-  AGGLPainter::fillRects(pRects);
+	AGGLPainter::fillRects(pRects);
 }
 
 
 AGRect2 AGGLScreen::getRect() const
 {
-  return AGRect2(0,0,w,h);
+	return AGRect2(0,0,w,h);
 }
 
 void glColor(const AGColor &c)
 {
-  glColor4f(c.r/255.0,c.g/255.0,c.b/255.0,c.a/255.0);
+	glColor4f(c.r/255.0,c.g/255.0,c.b/255.0,c.a/255.0);
 }
 
 void AGGLScreen::drawGradientAlpha(const AGRect2& pRect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr)
 {
-  AGGLPainter::drawGradientAlpha(pRect,ul,ur,dl,dr);
+	AGGLPainter::drawGradientAlpha(pRect,ul,ur,dl,dr);
 }
 
 void AGGLScreen::drawBorder(const AGRect2& rect,int W, const AGColor& c1, const AGColor& c2)
 {
-  AGGLPainter::drawBorder(rect,W,c1,c2);
+	AGGLPainter::drawBorder(rect,W,c1,c2);
 }
 
 void AGGLScreen::putPixel(int x,int y,const AGColor &pc)
 {
-  AGGLPainter::putPixel(x,y,pc);
+	AGGLPainter::putPixel(x,y,pc);
 }
 
 void AGGLScreen::drawGradient(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr)
 {
-  drawGradientAlpha(rect,ul,ur,dl,dr);
+	drawGradientAlpha(rect,ul,ur,dl,dr);
 }
 
 void AGGLScreen::drawLine(const AGVector2 &p0,const AGVector2 &p1,const AGColor &c)
 {
-  AGGLPainter::drawLine(p0,p1,c,mLineWidth);
+	AGGLPainter::drawLine(p0,p1,c,mLineWidth);
 }
 
 void AGGLScreen::blitTri(const AGTexture &pSource,const AGTriangle2 &pSrc,const AGTriangle2 &pDest)
 {
-  AGGLPainter::blitTri(pSource,pSrc,pDest);
+	AGGLPainter::blitTri(pSource,pSrc,pDest);
 }
 
 size_t AGGLScreen::getWidth() const
 {
-  return w;
+	return w;
 }
 size_t AGGLScreen::getHeight() const
 {
-  return h;
+	return h;
 }
 void AGGLScreen::clip(const AGRect2 &r)
 {
-  //return;
+	//return;
 #warning "insert clipping facility for opengl"
 
-  AGRect2 x=AGRect2(0,0,w,h);
-  AGRect2 m=x.intersect(r);
+	AGRect2 x=AGRect2(0,0,w,h);
+	AGRect2 m=x.intersect(r);
 
-  GLint x0,y0,cw,ch;
+	GLint x0,y0,cw,ch;
 
-  x0=(GLint)m.x0();
-  y0=(GLint)(h-m.y1()); // -1
-  cw=(GLint)m.width();
-  ch=(GLint)m.height(); // +2
+	x0=(GLint)m.x0();
+	y0=(GLint)(h-m.y1()); // -1
+	cw=(GLint)m.width();
+	ch=(GLint)m.height(); // +2
 
-  //  cdebug(x0<<";"<<y0<<";"<<cw<<";"<<ch);
+	//  cdebug(x0<<";"<<y0<<";"<<cw<<";"<<ch);
 
-  glScissor(x0,y0,cw,ch);
-  /*
+	glScissor(x0,y0,cw,ch);
+	/*
 
   glScissor((GLint)(m.x0()),
 	    (GLint)(h-1-m.y1()),
 	    (GLint)(m.width()),
 	    (GLint)(m.height()));
-  */
-  assertGL;
-  glEnable(GL_SCISSOR_TEST);
-  assertGL;
+	 */
+	assertGL;
+	glEnable(GL_SCISSOR_TEST);
+	assertGL;
 }
 void AGGLScreen::unclip()
 {
-  glDisable(GL_SCISSOR_TEST);
-  assertGL;
+	glDisable(GL_SCISSOR_TEST);
+	assertGL;
 }
 
 
 void AGGLScreen::beginPaint()
 {
-  //  CTRACE;
-  glMatrixMode(GL_MODELVIEW);
-  glLoadIdentity();
-  glTranslatef(0,getHeight(),0);
-  glScalef(1,-1,1);
+	//  CTRACE;
+	glMatrixMode(GL_MODELVIEW);
+	glLoadIdentity();
+	glTranslatef(0,getHeight(),0);
+	glScalef(1,-1,1);
 }
 
 void AGGLScreen::endPaint()
 {
-  glMatrixMode(GL_MODELVIEW);
-  glLoadIdentity();
+	glMatrixMode(GL_MODELVIEW);
+	glLoadIdentity();
 }
 
 void AGGLScreen::setLineWidth(float w)
 {
-  mLineWidth=w;
+	mLineWidth=w;
 }
 
 void AGGLScreen::addGLObject(AGGLObject *pObject)
 {
-  msObjects.insert(pObject);
+	msObjects.insert(pObject);
 }
 
 void AGGLScreen::removeGLObject(AGGLObject *pObject)
 {
-  msObjects.erase(pObject);
+	msObjects.erase(pObject);
 }
 
 void AGGLScreen::screenDown()
 {
-  for(std::set<AGGLObject*>::iterator i=msObjects.begin();i!=msObjects.end();i++)
-    (*i)->onScreenDown();
+	CTRACE;
+	for(std::set<AGGLObject*>::iterator i=msObjects.begin();i!=msObjects.end();i++)
+		(*i)->onScreenDown();
 
 }
 void AGGLScreen::screenUp()
 {
-  for(std::set<AGGLObject*>::iterator i=msObjects.begin();i!=msObjects.end();i++)
-    (*i)->onScreenUp();
+	for(std::set<AGGLObject*>::iterator i=msObjects.begin();i!=msObjects.end();i++)
+		(*i)->onScreenUp();
 }
 
 
 bool opengl()
 {
-  return dynamic_cast<AGGLScreen*>(&getScreen());
+	return dynamic_cast<AGGLScreen*>(&getScreen());
 }

Modified: antargis/trunk/main/Rakefile
===================================================================
--- antargis/trunk/main/Rakefile	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/main/Rakefile	2008-02-15 20:44:14 UTC (rev 1229)
@@ -4,13 +4,13 @@
 Dir.chdir(File.split(File.split(__FILE__)[0])[0])
 
 
-task 'starter'=>"main/starter.cc" do
+task './starter'=>File.join("main","starter.cc") do
 	require 'antconfig.rb'
 	cmd="g++ -o starter main/starter.cc "+$CONFIG["CFLAGS"]+" "+$CONFIG["INCLUDEPATH"]+" "+`sdl-config --libs`.chomp+" -l"+CONFIG["RUBY_SO_NAME"]
 	cmd.gsub!("-arch ppc","")
 	sh cmd
 end
 
-#task :starter=>'starter'
+task :starterPrg=>'./starter'
 
 CLEAN << Dir["starter"]
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_application.rb
===================================================================
--- antargis/trunk/ruby/ant_application.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/ant_application.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -314,8 +314,7 @@
 		@elapsTime+=time
 
 
-# 		# move entities in game-engine
-		#getMap().move(time*@speed)
+ 		# move entities in game-engine
 		moveMap(time*@speed)
 
 		# advance animations

Modified: antargis/trunk/ruby/ant_formations.rb
===================================================================
--- antargis/trunk/ruby/ant_formations.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/ant_formations.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -28,10 +28,16 @@
 	end
 	def calcFormation
 	end
+	
+	
 	def getPosition(man,pos)
 		if pos.nil?
 			raise "pos nil"
 		end
+		# clear cache if men have changed
+		if changedMen
+		  @cache={}
+	    end
 		if @cache.member?(man)
 			return @cache[man]+pos
 		end
@@ -50,7 +56,9 @@
 			end
 		end
 		@cache[man]=r
-		return r+pos
+		ret= r+pos
+		puts "RET:#{ret}=#{r}+#{pos}"
+		ret
 	end
 	def getSortedMen
 		if @sorted.nil?
@@ -61,8 +69,16 @@
 	def sort(men)
 		raise "not implemented"
 	end
+	
+
+    def changedMen
+        nmen=sort(@boss.getMen-[@boss])
+        @men!=nmen
+    end	
 end
 
+#
+# *a* has better weaponry than *b*
 def betterWeapons(a,b)
 	weapons=["bow","sword"]
 	weapons.each{|w|
@@ -72,15 +88,18 @@
 		end
 	}
 	return 0
+
 end
 
 
 class AntFormationRest<AntFormation
 	def initialize(boss)
 		super(boss)
+		puts "new formation"
 	end
 
 	def calcFormation
+		puts "calcFormation"
 		@rpos={} # real positions as map from man to AGVector2
 		vpos={}  # virtual positions as map from man to pair of [row,line (circle)]
 
@@ -105,6 +124,7 @@
 			row,line=vpos[m]
 			radius=line*1.2
 			angle=row.to_f/linesizes[line]*Math::PI*2
+			puts "#{m} #{row} #{line} #{angle} #{radius} #{linesizes[line]}"
 			@rpos[m]=AGVector2.new(Math::cos(angle)*radius,Math::sin(angle)*radius)
 			#puts "SET:#{m}"
 		}
@@ -112,14 +132,22 @@
 		if @men.length>0
 			@inited=true
 		end
+		
+		@rpos.keys.each{|key|
+			puts "FORMAT #{key} : #{@rpos[key]}"
+		}
+		
 	end
 	def getPositionReal(man)
-		if (not @inited)
+		if (not @inited) or changedMen
 			calcFormation
 		end
 		return @rpos[man]
 	end
+		
 	private
+	
+
 	def getRowsOfLine(line)
 		{1=>10,2=>14,3=>20,4=>40}[line]
 	end

Modified: antargis/trunk/ruby/entities/ant_hero.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_hero.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/entities/ant_hero.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -163,14 +163,17 @@
 	end
 	def newHLBuildJob(pos,type)
 		@job.stopJob if @job
-		if true
+		puts "POSHL:#{pos} #{pos.class}"
+		if pos.is_a?(AGVector2) or pos.is_a?(AGVector3)
+			assert{pos.is_a?(AGVector2) or pos.is_a?(AGVector3)}
 			target=AntBuildingSite.new(getMap)
 			target.setPos(pos)
 			target.building=type
 			getMap.insertEntity(target)
 			@job=AntHeroBuildJob.new(self,target) #pos,type)
 		else
-			@job=AntHeroBuildJob.new(self,pos,type)
+			assert{pos.is_a?(AntBuildingSite)}
+			@job=AntHeroBuildJob.new(self,pos)
 		end
 		assignJob2All
 	end

Modified: antargis/trunk/ruby/entities/ant_manbase.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_manbase.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/entities/ant_manbase.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -76,7 +76,7 @@
 	end
 
 	def standStillShort
-		newRestJob(0.2)
+		newRestJob(0.1)
 		setMeshState("stand")
 	end
 

Modified: antargis/trunk/ruby/entities/entity.rb
===================================================================
--- antargis/trunk/ruby/entities/entity.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/entities/entity.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -8,7 +8,7 @@
 # This should be used for all the entity-types.
 class AntRubyEntity<AntEntity
 	attr_accessor :birthday
-	attr_reader :uid
+	attr_reader :uid, :selected
 
 	# get the 3d-scene-object out of the Map-object
 	def getScene

Modified: antargis/trunk/ruby/gui/ag_tools.rb
===================================================================
--- antargis/trunk/ruby/gui/ag_tools.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/gui/ag_tools.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -57,10 +57,8 @@
 	end
 	# event dispatcher
 	def signal(e)
-		pp e
 		@handlers||={}
 		mcaller=e.getCaller
-		pp mcaller
 		evName=makeHandlerName(mcaller,e.getName)
 		#callerName=e.getCaller.getName
 		#evName=callerName+":"+e.getName

Modified: antargis/trunk/ruby/gui/testing.rb
===================================================================
--- antargis/trunk/ruby/gui/testing.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/gui/testing.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -2,9 +2,11 @@
 	attr_reader :quitCounter
 	def step
 		run
+		puts "step end"
 	end
 	def eventFrame(t)
 		super
+		puts "FRAME - try Quit..."
 		tryQuit
 		true
 	end

Modified: antargis/trunk/ruby/jobs/ant_hljob_states.rb
===================================================================
--- antargis/trunk/ruby/jobs/ant_hljob_states.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/jobs/ant_hljob_states.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -782,6 +782,7 @@
 	end
 
 	def ready
+		#return false
 		recruitedEnough=((@countRecruited>=howManyToRecruit) or nonToRecruitLeft)
 		everyoneIsAtHisPlace=(hero.getMen).map{|man|(man.getPos2D-hero.getFormation(man, at myPos)).length}.max<MAX_DIST
 		heroIsAtHisPlace=(hero.getPos2D-hero.getFormation(hero, at myPos)).length<MAX_DIST
@@ -837,10 +838,13 @@
 
 	def returnToStart(man)
 		pos=hero.getFormation(man, at myPos)
+		puts "RETURN to start: mypos:#{@myPos} diffHero:#{@myPos-hero.getPos2D} manpos:#{man.getPos2D} tposman:#{pos} diff:#{pos-man.getPos2D}"
+		
+		
 		if (man.getPos2D-pos).length<MAX_DIST
 			man.lookTo(@myPos)
 			man.standStillShort # FIXME: really short ?
-			puts "standStill #{man}"
+			puts "standStill #{man} #{pos}==#{man.getPos2D}  ---#{@myPos} "
 		else
 			man.walkTo(pos)
 			puts "walkTo #{pos} #{man}"

Modified: antargis/trunk/ruby/jobs/ant_new_hljobs.rb
===================================================================
--- antargis/trunk/ruby/jobs/ant_new_hljobs.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/jobs/ant_new_hljobs.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -334,12 +334,13 @@
 	attr_accessor :targetPos
 	attr_accessor :formatDir
 	attr_accessor :target
-
+    attr_accessor :near
+	
 	def initialize(hero,target)
 		@targetPos=target.getPos2D
 		@target=target
+        @near=4
 		super(hero)
-		@states[:moveComplete].near=4
 		
 		if (hero.getPos2D-target.getPos2D).length<4
 			state.moveDirectly			

Modified: antargis/trunk/ruby/jobs/ant_state_machine.rb
===================================================================
--- antargis/trunk/ruby/jobs/ant_state_machine.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/jobs/ant_state_machine.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -78,6 +78,10 @@
 		end
 		raise "no state defined!"
 	end
+	
+	def stateName
+		@state
+	end
 
 	def stateCall(*s)
 		if @state

Added: antargis/trunk/ruby/spec/level_testing.rb
===================================================================
--- antargis/trunk/ruby/spec/level_testing.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/spec/level_testing.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -0,0 +1,106 @@
+require 'ruby/spec_helper.rb'
+require 'ruby/gui/testing.rb'
+require 'ruby/ant_application.rb'
+
+module LevelTesting
+	class TestEntity
+		class ClickNode
+			attr_accessor :node
+		end
+
+		def initialize(entity,app)
+			@entity=entity
+			@app=app
+		end
+		def click(button=1)
+			n=ClickNode.new
+			n.node=@entity.getMesh[0]
+			@app.eventEntitiesClicked([n],button)
+		end
+		def method_missing(*s)
+			@entity.send(*s)
+		end
+	end
+	
+	def entities(type)
+		map.getByType(type).collect{|e|TestEntity.new(e, at app)}
+	end
+	
+	include GuiTest
+	def getTestApp(testLevelName)
+		case testLevelName
+			when :tutorial0
+				file="data/levels/tutorial/tutorial0.antlvl"
+			when :tutorial3
+				file="data/levels/tutorial/tutorial3.antlvl"
+	    end
+	    clientConnection=nil
+	    @app=makeTestAppClass(AntGameApp).new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
+	end
+	
+	def runUntilLowLevelJobToFinish(entity)
+		observe(entity,:eventJobFinished) do |observer|
+			while observer.isNotCalled
+				advance
+			end
+		end
+	end
+	
+    def clickAwayStory
+        telltaleWidget=widget("TellTale")
+		raise if telltaleWidget.nil?
+        return if telltaleWidget.nil?
+
+        telltaleWidget.should_not be_nil
+        telltaleWidget.should be_visible
+        okButton=telltaleWidget.child("ok")
+        okButton.should_not be_nil
+        okButton.click
+        trials=0
+		
+        while telltaleWidget.visible?
+            okButton.click
+            @app.step
+            trials+=1
+            trials.should <10
+        end
+
+    end
+	
+	
+	def advance(time=nil)
+		step=0.3
+		time||=0
+		begin
+			@app.getMap.move(step)
+			@app.step
+			time-=step
+		end while time>step
+	end	
+
+    def hero(name)
+    	h=map.getByName(name)
+		h.should_not be_nil
+		h.should be_a_kind_of(AntHero)
+		h
+    end
+	def building(name)
+		b=map.getByName(name)
+		b.should_not be_nil
+		b.should be_a_kind_of(AntHouse)
+		b
+	end
+	def map
+		@app.getMap
+	end
+	
+	def clickMap(pos2d,button=1)
+		@app.eventMapClicked(pos2d,button)
+	end
+	
+	def waitForStory
+		while not (widget("TellTale").valid and widget("TellTale").visible?)
+			advance
+		 end
+	end		
+end
\ No newline at end of file

Added: antargis/trunk/ruby/spec/spec_formation.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_formation.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/spec/spec_formation.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -0,0 +1,68 @@
+require 'ruby/spec/level_testing.rb'
+
+class MockResource
+	def get(*s)
+		0
+	end
+end
+
+class MockMan
+    def initialize(pos)
+        @pos=pos
+    end
+	def getPos2D
+		@pos
+	end
+	def resource
+		MockResource.new
+	end
+end
+
+class MockHero<MockMan
+	def initialize(pos)
+		super
+		@men=[]
+	end
+	def add(man)
+		@men << man
+	end
+	def getMen
+		@men+[self]
+	end
+end
+
+
+describe 'SitFormation' do
+	it "should center on heroes position with hero only" do
+		hero=MockHero.new(AGVector2.new(0,0))
+		AntFormationRest.new(hero).getPosition(hero,hero.getPos2D).should == hero.getPos2D
+	end
+	
+	(2..25).step(3){|count|
+		it "should center on heroes with #{count} men in range of 1" do
+			middle=AGVector2.new(0,0)
+			some=AGVector2.new(100,100)
+			hero=MockHero.new(middle)
+			null=AGVector2.new(0,0)
+			(1...count).each{|i|
+				hero.add(MockMan.new(some))
+			}
+			formation=AntFormationRest.new(hero)
+			poss=hero.getMen.collect{|man|
+				pos=formation.getPosition(man,hero.getPos2D)
+				puts pos
+				pos
+			}
+			sum=poss.inject(null){|a,b|a+b}
+			(sum/poss.length-middle).length.should < 1
+		end
+	}
+end
+
+describe 'WalkFormation' do
+	it "should work correctly with only the hero"
+	it "should work correctly with a single trooper"
+	it "should work correctly with 5 troopers"
+    it "should work correctly with 15 troopers"
+    it "should work correctly with 35 troopers"
+end
\ No newline at end of file

Added: antargis/trunk/ruby/spec/spec_game_gui.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_game_gui.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/spec/spec_game_gui.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -0,0 +1,71 @@
+require 'ruby/spec/level_testing.rb'
+
+describe "Aggression buttons" do
+	include LevelTesting
+	before(:all) do
+	  getTestApp(:tutorial0)
+	end
+	it "should not call pp" do
+		lambda {widget("doAgg0").click}.should_not cross(:pp)
+	end
+end
+
+describe "Gui-Selecting" do
+    include LevelTesting
+    before(:all) do
+      getTestApp(:tutorial0)
+      waitForStory
+      clickAwayStory
+    end
+	
+	it "should be possible to select tower" do
+		tower=entities(AntTower)[0]
+		lambda{tower.click}.should change(tower,:selected)
+	end
+	
+end
+
+describe "Building with gui interaction" do
+    include LevelTesting
+    before(:all) do
+      getTestApp(:tutorial3)
+	  waitForStory
+	  clickAwayStory
+    end
+	it "should start at all" do
+		widget("doBuild").click
+		advance
+		clickMap(hero("Rowen").getPos2D+AGVector2.new(-5,10))
+        widget("AntTower").should be_a_kind_of(AGButton)
+        widget("AntTower").click
+		hero("Rowen").getJob.should be_a_kind_of(AntHeroBuildJob)
+		advance(15)
+		map.getByType(AntBuildingSite).should have(1).item
+	end
+	it "should be possible to stop and rest" do
+		widget("doRest").click
+        hero("Rowen").getJob.should_not be_a_kind_of(AntHeroBuildJob)
+        hero("Rowen").getJob.should be_a_kind_of(AntHeroRestJob)
+	end
+	it "should be possible to continue building a tower" do
+		site=entities(AntBuildingSite)[0]
+		lambda{site.click}.should change(site,:selected)
+		widget("doContinue").click
+		hero("Rowen").getJob.should be_a_kind_of(AntHeroBuildJob)
+		advance(100)
+        hero("Rowen").getJob.should be_a_kind_of(AntHeroRestJob)
+		entities(AntBuildingSite).should have(0).items
+		entities(AntTower).should have(1).item
+		entities(AntTower)[0].getPlayer.should == hero("Rowen").getPlayer
+
+	end
+	
+	it "toggling fullscreen should'nt destroy anim-meshes"
+end
+
+describe AntNameDisplay do
+	it "should display a red text for enemies"
+	it "should display a yellow text for friends"
+	it "should switch text color when enemy is pwned"
+end
+

Added: antargis/trunk/ruby/spec/spec_hljobs.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_hljobs.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/spec/spec_hljobs.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -0,0 +1,127 @@
+require 'ruby/spec/level_testing.rb'
+
+
+class Store
+	def initialize
+		@store={}
+	end
+	def [](name)
+		@store[name]
+	end
+	def []=(name,value)
+		@store[name]=value
+	end
+end
+
+describe "HL-MoveJob" do
+	it "should format correctly"
+	it "should use only limited count of ll-jobs"
+end
+
+describe "Recruit job - run through" do
+  include LevelTesting
+  before(:all) do
+    getTestApp(:tutorial0)
+	@store=Store.new
+  end
+  it "should start off with hero with no men" do
+  	advance
+  	clickAwayStory
+  	hero("Rowen").getMen.length.should == 1
+  end
+  it "starting recruit-job should work" do
+  	rowen=hero("Rowen")
+	rowen.newHLRecruitJob(building("Keep"))
+	rowen.getJob.should be_a_kind_of(AntHeroRecruitJob)
+  end
+
+  it "should then send hero to tower (at most 10 low-level move-jobs for format and move)" do
+    rowen=hero("Rowen")
+  keep=building("Keep")
+
+  	# format
+    while rowen.getJob.stateName==:moveComplete
+	  advance
+    end
+	
+	rowen.getJobName.should =="moveJob"
+	rowen.getTarget.should be_a_kind_of(AntMan)
+	@store[:oldPos]=rowen.getPos2D
+  end
+  it "hero should only go fetch one man;go back and then stay at his position" do
+  	rowen=hero("Rowen")
+	man=rowen.getTarget
+  	runUntilLowLevelJobToFinish(rowen)
+	rowen.getJobName.should == "moveJob"
+	rowen.getTarget.should be_nil
+	trials=0
+	while rowen.getJobName=="moveJob"
+        runUntilLowLevelJobToFinish(rowen)
+		trials+=1
+		raise "too many trials" if trials>10
+	end
+	(rowen.getPos2D- at store[:oldPos]).length.should < 0.1
+  end
+  it "all men should stand at the sitting-position when job is finished" do
+  	while rowen.getJob.stateName == :recruit
+  		advance
+	end
+ 
+	
+	clickAwayStory
+	rowen.getJob.should_not be_a_kind_of(AntHeroRecruitJob)
+	rowen.formation.should be_a_kind_of(AntFormationRest)
+	rowen.getMen.each{|man|
+		(man.getPos2D-rowen.getFormation(man,rowen.getPos2D)).length.should < 0.1
+	}
+  end
+  
+  def rowen
+  	hero("Rowen")
+  end
+end
+
+
+describe "Recruit job - aggression" do
+	it "men should fetch a few men if aggression is low"
+    it "men should fetch all men if aggression if high"
+end
+
+
+describe "Build job" do
+	include LevelTesting
+	before(:all) do
+	  getTestApp(:tutorial3)
+	  @store=Store.new
+	end
+    it "should run at all" do
+    	waitForStory
+		clickAwayStory
+    	rowen=hero("Rowen")
+		dist=AGVector2.new(-5,8)
+		rowen.newHLBuildJob(rowen.getPos2D+dist,AntTower)
+		map.getBuildings.length.should ==0
+		steps=0
+		while rowen.getJob and rowen.getJob.is_a?(AntHeroBuildJob)
+			advance
+			steps.should < 100
+		end
+		map.getBuildings.length.should == 1
+		map.getBuildings[0].should be_a_kind_of(AntTower)
+    end
+	it "- the tower should be of Rowen" do
+		hero("Rowen").getPlayer.should equal(map.getBuildings[0].getPlayer)
+	end
+	it "should not work on water" do
+		getTestApp(:tutorial3)
+		rowen=hero("Rowen")
+		waitForStory
+		clickAwayStory
+		rowen.newHLBuildJob(rowen.getPos2D+AGVector2.new(-5,-10),AntTower)
+		rowen.getJob.should_not be_a_kind_of(AntHeroBuildJob)
+	end
+	describe "Continue a build job" do
+		it "should work correctly"
+	end
+	
+end

Modified: antargis/trunk/ruby/spec/spec_run_tutorial.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_run_tutorial.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/spec/spec_run_tutorial.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -91,19 +91,36 @@
 		end
 		it "should be possible to defeat enemy" do
 	       clickAwayStory
-					hero=getHero
+			hero=getHero
 			enemy=getEnemy
 			hero.newHLFightJob(enemy)
 			hero.getJob.should be_a_kind_of(AntHeroFightJob)
 			enemy.hasHLJob.should be_false
 			while hero.hasHLJob
 				puts hero.getJob
-					advance
+				advance
 			end
 			clickAwayStory
+			advance
 		    @app.result.won.should == "won"
             map.getOwnHeroes.length.should == 2
 		end
+		
+		
+		it "should be possible to dismiss some people" do
+			hero=getHero
+			hero.setAggression(1)
+			oldMenCount=hero.getMen.length
+			oldMenCount.should > 1
+			hero.newHLDismissJob
+			while hero.hasHLJob
+				advance
+			end
+			menCount=hero.getMen.length
+			menCount.should < oldMenCount
+		end
+		
+		
 	
 		def getEnemies
 			enemies=map.getHeroes-map.getOwnHeroes

Added: antargis/trunk/ruby/spec/story_test.rb
===================================================================
--- antargis/trunk/ruby/spec/story_test.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/spec/story_test.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -0,0 +1,11 @@
+require 'rubygems'
+require 'spec/story/runner/plain_text_story_runner.rb'
+
+include Spec::Story::Runner
+
+PlainTextStoryRunner.new('path/to/file')
+
+ # PlainTextStoryRunner.new do |runner|
+ #   runner.load 'path/to/file'
+ # end
+  
\ No newline at end of file

Modified: antargis/trunk/ruby/spec_helper.rb
===================================================================
--- antargis/trunk/ruby/spec_helper.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/spec_helper.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -25,6 +25,7 @@
 	end
 	class Cross
 		@@called={}
+		@@backtrace={}
 		def initialize(target,function)
 			@target=target
 			@function=function
@@ -50,6 +51,7 @@
 				return @@called[callName]>0
 	
 			end
+			@callName=callName
 			mclass=@target
 			mclass=@target.class unless @target.is_a?(Class)
 	
@@ -65,10 +67,13 @@
 			"expected #{@proc.inspect} to call #{@expected}"
 		end
 		def negative_failure_message
-			"expected #{@proc.inspect} not to call #{@expected}"
+			bt=""
+			bt=@@backtrace[@callName].join("\n") if @@backtrace[@callName] 
+			"expected #{@proc.inspect} not to call #{@expected} BT:#{bt}"
 		end
 		def Cross.symCall(name)
 			@@called[name]+=1
+			@@backtrace[name]=caller
 			nil
 		end
 	end
@@ -82,3 +87,43 @@
 		Cross.new(target,function)
 	end
 #end
+	
+	
+class Observer
+	attr_accessor :ok
+	def initialize(object,methodName)
+		@methodName=methodName
+		@object=object
+		@ok=false
+	end
+	def run
+		method=@object.method(@methodName)
+		this=self
+		@object.class.send(:define_method, at methodName) {|*s|this.ok=true;puts "MUH";method.call(*s)} 
+		yield
+		@object.class.send(:define_method, at methodName,method)
+		@ok
+	end
+	def isNotCalled
+	   @ok==false
+	end
+	def isCalled
+	   @ok
+	end
+end	
+
+def observe(object,method,&block)
+	observer=Observer.new(object,method)
+	
+	observer.run {block.call(observer)}
+end
+
+#class A
+#	def b
+#		puts "B"
+#	end
+#end
+#
+#a=A.new
+#call=CalledIn.new(a,:b)
+#call.run {}

Modified: antargis/trunk/ruby/widgets/ant_name_display.rb
===================================================================
--- antargis/trunk/ruby/widgets/ant_name_display.rb	2008-02-06 20:02:44 UTC (rev 1228)
+++ antargis/trunk/ruby/widgets/ant_name_display.rb	2008-02-15 20:44:14 UTC (rev 1229)
@@ -1,6 +1,16 @@
+
+# the AntNameDisplay shows the name of a hero some place above the actual hero
+# mesh. It consists of a button with a custom text-display. 
+# It checks if the hero's player' changed in each frame. TODO: here's some possiblity for optimization.
+# Enemy heroes' names are displayed in red - your own heroes are display in yellow.
+# the position on the screen must be given from outside (from the application e.g.)
 class AntNameDisplay<AGWidget
 	@@fontChangeCount=0
 
+	# p - the parent widget
+	# r - the surrounding rectangle
+	# hero - the inspected hero
+	# map - the containing map-object
 	def initialize(p,r,hero,map)
 		super(p,r)
 		@map=map
@@ -10,15 +20,19 @@
 		@name=@hero.getName
 		addChild(@mb=AGButton.new(self,AGRect.new(0,0,width,height),_("")))
 		
+		# disable button - so it can't be clicked anymore (no hovering either)
 		@mb.setEnabled(false)
 		addChild(@textWidget=AGText.new(self,AGRect.new(0,0,width,height),AGStringUtf8.new(@hero.getName), at font))
 		
+		# assign font-types
 		@fonts={true=>getTheme.getFont("heroName.font"),false=>getTheme.getFont("enemyHero.font")}
-		@oldPlayer=nil
+		
+		# enable caching of widget texture - this improves drawing performance (slightly)
 		setCaching(true)
 	end
 
 	# enforce integer position	
+	# 
 	def setRect(r)
 		super(AGRect.new(r.x.to_i,r.y.to_i,r.w.to_i,r.h.to_i))
 	end
@@ -28,23 +42,15 @@
 	end
 
 	def prepareDraw
+		# check if @hero's player changed
 		@font=@fonts[@hero.getPlayer==@map.getPlayer]
 		if @font!=@oldfont
-			puts "#{@hero.getPlayer} #{@map.getPlayer} #{@oldPlayer}"
-			puts "#{@font} #{@oldfont}"
-			@oldPlayer=@hero.getPlayer
-			puts "font changed"
-			@@fontChangeCount||=0
-			@@fontChangeCount+=1
-			if @@fontChangeCount>20
-				raise 1
-			end
+			# this is the case - so assign new font to textWidget
 			@oldfont=@font
 			@textWidget.setFont(@font)
+			# query redraw of (possibly) cached widget texture
 			queryRedraw
 		end
 		super
 	end
-
-	private
 end



From davidkamphausen at mail.berlios.de  Sun Feb 24 20:05:35 2008
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 24 Feb 2008 20:05:35 +0100
Subject: [Antargis-svn] r1230 - in antargis/trunk: . build/swig/tests
	data/levels/tutorial ext/3dengine ext/basic ext/game ext/gui
	main ruby ruby/entities ruby/jobs ruby/meshes ruby/spec
Message-ID: <200802241905.m1OJ5Z0r002003@sheep.berlios.de>

Author: davidkamphausen
Date: 2008-02-24 20:05:29 +0100 (Sun, 24 Feb 2008)
New Revision: 1230

Added:
   antargis/trunk/.project
   antargis/trunk/ext/basic/ag_message.h
   antargis/trunk/ruby/garbage/
   antargis/trunk/ruby/spec/spec_coding_style.rb
   antargis/trunk/ruby/spec/spec_entity.rb
   antargis/trunk/ruby/spec/spec_gc.rb
   antargis/trunk/ruby/spec/spec_geometry.rb
   antargis/trunk/ruby/spec/spec_map.rb
Removed:
   antargis/trunk/Rantfile
   antargis/trunk/ruby/spec/geometry.rb
   antargis/trunk/ruby/spec/map.rb
Modified:
   antargis/trunk/Rakefile
   antargis/trunk/build/swig/tests/test.cc
   antargis/trunk/data/levels/tutorial/tutorial0.antlvl
   antargis/trunk/ext/3dengine/anim_mesh.cc
   antargis/trunk/ext/3dengine/anim_mesh_data.cc
   antargis/trunk/ext/3dengine/ant_camera.cc
   antargis/trunk/ext/3dengine/ant_particle.cc
   antargis/trunk/ext/3dengine/ant_renderer.cc
   antargis/trunk/ext/3dengine/glsl.cc
   antargis/trunk/ext/3dengine/mesh.cc
   antargis/trunk/ext/3dengine/mesh_data.cc
   antargis/trunk/ext/3dengine/mesh_optimizer.cc
   antargis/trunk/ext/3dengine/scene.cc
   antargis/trunk/ext/3dengine/scene_2d.cc
   antargis/trunk/ext/3dengine/scene_base.cc
   antargis/trunk/ext/basic/ag_config.cc
   antargis/trunk/ext/basic/ag_fs.cc
   antargis/trunk/ext/basic/ag_geometry.cc
   antargis/trunk/ext/basic/ag_geometry.h
   antargis/trunk/ext/basic/ag_kill.cc
   antargis/trunk/ext/basic/ag_rubyobj.cc
   antargis/trunk/ext/basic/ag_rubyobj.h
   antargis/trunk/ext/basic/ag_string_utf8.h
   antargis/trunk/ext/game/map.cc
   antargis/trunk/ext/gui/ag_application.cc
   antargis/trunk/ext/gui/ag_button.cc
   antargis/trunk/main/Rakefile
   antargis/trunk/ruby/ant_messagebox.rb
   antargis/trunk/ruby/ant_mock.rb
   antargis/trunk/ruby/entities/ant_hero.rb
   antargis/trunk/ruby/entities/ant_sack.rb
   antargis/trunk/ruby/jobs/ant_hljob_states.rb
   antargis/trunk/ruby/jobs/ant_new_hljobs.rb
   antargis/trunk/ruby/map.rb
   antargis/trunk/ruby/meshes/grass.rb
   antargis/trunk/ruby/spec/level_testing.rb
   antargis/trunk/ruby/spec/spec_game_gui.rb
   antargis/trunk/ruby/spec/spec_hljobs.rb
   antargis/trunk/ruby/spec/spec_menu.rb
   antargis/trunk/ruby/spec/spec_run_tutorial.rb
Log:
* many new specs
* several bugfixes

Added: antargis/trunk/.project
===================================================================
--- antargis/trunk/.project	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/.project	2008-02-24 19:05:29 UTC (rev 1230)
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>antargis</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.fullBuildTarget</key>
+					<value>all</value>
+				</dictionary>
+				<dictionary>
+					<key>?name?</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
+					<value>false</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildLocation</key>
+					<value>${workspace_loc:/antargis/Debug}</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
+					<value>clean</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.contents</key>
+					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<value>false</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildArguments</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildCommand</key>
+					<value>rake</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.autoBuildTarget</key>
+					<value>all</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.stopOnError</key>
+					<value>true</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+	</natures>
+</projectDescription>

Modified: antargis/trunk/Rakefile
===================================================================
--- antargis/trunk/Rakefile	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/Rakefile	2008-02-24 19:05:29 UTC (rev 1230)
@@ -132,3 +132,6 @@
 desc "Build all"
 task :default=>[:starterPrg,:library] do
 end
+
+task :all=>:default do
+end
\ No newline at end of file

Deleted: antargis/trunk/Rantfile
===================================================================
--- antargis/trunk/Rantfile	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/Rantfile	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,400 +0,0 @@
-import "md5"                         # md5 is needed for automatic checksum-check for changes in files
-import "autoclean"                    # autoclean includes the a simple facility for a clean-make-target
-import "package/tgz"                  # support for packaging (tar.gz, zip)
-import "package/zip"                  # support for packaging (tar.gz, zip)
-import "rubydoc"
-import "c/dependencies"
-require 'pp'
-
-puts "ERROR: Please run ./configure before building!" unless File.exists?("config.rb")
-
-begin
-system 'echo "doing this for you now...";ruby configure' unless File.exists?("config.rb")
-rescue;end
-
-require 'config.rb'                   # include build-options
-require 'build/base_tools.rb'
-
-
-
-# get library-dependencies for libSDL
-sdlLibs=$config['LIBS'].split(" ")
-
-allSDLlibs=sdlLibs+["-lSDL_image","-lSDL_ttf","-lpng"]
-glLibs=$config["LIBGL"].split(" ")
-
-# configure source-directories.
-# DLLs will be build for each directory and in the given order.
-# on the left the directory containing the sources is given
-# on the right the dependencies, which can be one of the following:
-# - an external library, which then marked by "-l" in front, like "-lz" for the z-library
-# - an internal dependency on a directory
-# NOTE: dependencies are not automatically inherited, you have to include them yourself!
-
-rubyLib=[$config['RUBYLIB']]
-
-sourceDeps=[
-	["ext/external",["-lz"]+sdlLibs],
-	["ext/basic",["ext/external","-lz"]+sdlLibs+rubyLib],
-	["ext/math",["ext/external","ext/basic"]],
-	["ext/video",["ext/external","ext/basic","ext/math"]+glLibs+allSDLlibs],
-	["ext/gui",["ext/basic","ext/math","ext/video"]+allSDLlibs],
-	["ext/sound",["ext/basic","-lSDL_mixer"]+sdlLibs],
-	["ext/3dengine",["ext/external","ext/basic","ext/math","ext/video","ext/gui"]+glLibs+sdlLibs],
-	["ext/game",["ext/basic","ext/math","ext/video","ext/gui","ext/3dengine"]+glLibs+sdlLibs],
-]
-
-$sourceDeps=sourceDeps
-
-sourceDirs=sourceDeps.collect{|a|a[0]}    # collect dirs containing source (in the correct order !)
-
-externalIncludes=$config['CFLAGS']
-#externalIncludes+=`sdl-config --cflags`.gsub("\n","")
-
-# sitearchdir - include in usr/local
-rubyIncDir=getConfig("archdir")
-    
-# gather include-directories (separately from other cflags, so they can be used for swig later on
-var :INCLUDES => sourceDirs+[rubyIncDir,"."]
-
-var :INCLUDESTR => var[:INCLUDES].collect{|d|"-I#{d}"}.join(" ")+" "+externalIncludes    # build include-string (-I...)
-
-
-# configure cflags out of config.rb
-cflags=""
-cflags+=" -DGCDEBUG" if $config["gcdebug"]   # enable debuggin of garbage-collection
-cflags+=" -g -O0"    if $config["debug"]     # disable optimizations for better debugging
-cflags+=" -DNDEBUG -DMNDEBUG"  if not $config["debug"] # disable debug-output
-cflags+=" -O0 -g"       unless $config["debug"] # enable optimizations
-#cflags+=" -O2"       unless $config["debug"] # enable optimizations
-cflags+=" -DMPROFILE" if $config["profile"]  # enable profiling
-
-
-# FIXME: discard this before submiting to SVN
-cflags+=" -g -O0"
-	
-
-var :CFLAGS => var[:INCLUDESTR]+cflags          # store cflags in "var" for later read-out while compiling
-
-var.env %w(CC CFLAGS)                           # get cflags from environment
-
-###########################################
-# all-target
-buildLibs=sourceDirs.collect{|d|"ext/"+"lib"+makeLibName(d)+".so"}
-interfaceLibs=sourceDirs[1..-1].collect{|d|"ext/"+makeLibName(d)+".so"} # exclude "ext/external"
-allTargets = buildLibs + interfaceLibs
-task :all => allTargets
-#
-###########################################
-
-
-
-   
-
-###########################################
-# build libraries (without swig)
-#
-sourceDeps.each{|pair|
-	dir,dep=pair                                                               # get directory and dependencies
-	target="ext/"+"lib"+makeLibName(dir)+".so"                    # make library name like "ext/libantargisgui.so"
-	tsources=Dir[dir+"/*.cc"].select{|f|not f=~/swig/}            # get all *.cc files (without the swig-generated file)
-	tsources.collect!{|f|f.sub_ext("oo")}                                      # translate the .cc files to .oo
-	tsources+=Dir[dir+"/*.c"].collect!{|f|f.sub_ext("o")}         # add *.c files if there are any
-	extlibs=[]
-    
-    #puts "TARGET:",target
-    #puts "TSOURCES:",tsources
-    
-	dep.each{|d|
-		if d[0..0]=="-"
-			extlibs << d                                                           # gather external libraries (-lz)
-		else
-			extlibs+=["ext/lib"+makeLibName(d)+".so"]             # gather internal deps like (ext/libantargisbasic.so)
-		end
-	}
-	task target => tsources do |t|
-		# build command
-		sources=t.prerequisites
-        
-		if ENV['WINDIR']
-                extlibs=extlibs.collect{|s|s.gsub(/.*lib(.*)\.so/,'-l\1')}
-                
-                
-				#puts "SOURCES #{sources}"
-				#puts "EXTLIBS #{extlibs}"
-				sources=sources.select{|f|not f=~/\.so/}
-		end
-		cmd=makeCommand("LINK_SHARED",sys.expand_path(U2W(t.name)), (sources.collect{|f|sys.expand_path(f)}+extlibs).join(" "))
-        #puts "------",cmd,"--------------!"
-		sys cmd
-		puts
-		if isWindows
-				sys "copy #{sys.expand_path(t.name).gsub("/",Dir.separator)}.a #{sys.expand_path(t.name).sub(/\.so/,".dll").gsub("/",Dir.separator)}.a"
-				puts
-		end
-	end
-}
-#
-###########################################
-
-
-###########################################
-# build extension libraries
-#
-sourceDeps.each{|pair|
-	dir,dep=pair
-	libname=makeLibName(dir)
-	target="ext/"+makeLibName(dir)+".so"
-
-	# FIXME:re-include this
-	tsources=[]
-	tsources+=[dir+"/"+libname+"swig.cc"]
-	tsources.collect!{|f|f.sub_ext("oo")}
-	#tsources+=["ext/lib"+makeLibName(dir)+".so"]
-	extlibs=[] #["-l"+makeLibName(dir)]
-    
-    if isWindows
-	    extlibs+=["-l"+makeLibName(dir)]
-    end
-    
-	dep.each{|d|
-		if d[0..0]!="-" and d!="ext/external"
-			if isWindows
-				extlibs+=["-l"+makeLibName(d)]
-			else
-				# take some direct path instead ???
-				#tsources+=["ext/lib"+makeLibName(dir)+".so"]
-				extlibs+=["ext/lib"+makeLibName(dir)+".so"]
-			end
-		end
-	}
-    
-    puts "EXTLIBS:#{extlibs}"
-    #tsources+=rubyLib
-    
-    #puts "TARGET:",target
-    #puts "SOURES:",tsources
-    #puts "---"
-	task target => tsources do |t|
-		cmd=makeCommand("LINK_SHARED",sys.expand_path(t.name), (t.prerequisites.collect{|f|sys.expand_path(f)}+extlibs+rubyLib).join(" "))
-        #puts "------",cmd,"--------------!"
-		sys cmd
-		puts
-	end
-}
-###########################################
-
-
-depC=lambda{|target|
-	source=target.gsub(/\.o$/,".c").gsub(/\.oo$/,".cc")
-	target=sys.expand_path(target)
-	deps=getDependencies(target)
-	#puts "MUH:"+([source]+deps).join(":::")
-	[source]+deps
-}    
-
-###########################################
-# build c
-#
-gen Rule, '.o' => depC do |t|
-	cmd=makeCommand("CC_CALL",sys.expand_path(t.name),"#{var :CFLAGS} #{(t.source)}")
-	sys cmd
-	puts
-end
-###########################################
-
-###########################################
-# build c++
-#
-gen Rule, '.oo' => depC do |t|
-	cmd=makeCommand("CXX_CALL",sys.expand_path(t.name),"#{var :CFLAGS} #{sys.expand_path(t.source)}")
-	sys cmd
-	puts
-end
-#
-###########################################
-
-
-###########################################
-# swig - interfacing for ruby
-#
-swigSrc = lambda { |target| 
-	dir=getDirUnix(target)
-    #puts "TARGET:#{target} DIR:#{dir}"
-	name=makeLibName(dir)
-	a=[target.sub(/#{name}swig.*/,"interface.i")]+sys["build/*.i"]+importsForInterface(target).split(":") 
-    puts "A: #{a}"
-    puts "name: #{name}"
-    puts "dir: #{dir}"
-    puts "target: #{target}"
-    a
-}
-
-gen Rule, /^.*swig.(cc|h)$/ => swigSrc do |t|
-
-	puts "SOURCE #{t.source} #{t.name}"
-
-	#tsource=sys.expand_path(t.source)
-	tsource=t.source
-
-	#tname=sys.expand_path(t.name.gsub(/\.h$/,".cc"))
-	tname=t.name.gsub(/\.h$/,".cc")
-
-	cmd=makeCommand("SWIG_CALL",tname,"-DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR} #{tsource}".gsub("/",Dir.separator))
-	sys cmd
-	puts
-
-	incs="-DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR}"
-	out=".deps"+Dir.separator+sys.expand_path(t.name).gsub("/","_")
-	cmd=makeCommand("SWIGDEPS",out,incs+" "+t.name.gsub(/[0-9_a-z]*\.(h|cc)$/,"interface.i"))
-	sys cmd
-	puts
-
-end
-#
-###########################################
-
-
-
-###########################################
-# interface-files for swig
-#
-
-def importsForInterface(name)
-#puts "?=="
-	#puts "importsForInterface:#{name}"
-	$sourceDeps.each{|t|
-		if name=~/#{t[0]}/
-			return t[1].select{|f|not f=~/-.*/}.select{|f|not f=~/external/}.collect{|f|f+"/interface.i"}.join(":")
-		end
-	}
-	return ""
-end
-
-interfaceSrc = lambda { |target| 
-	list=Dir[getDirUnix(target)+"/"+"*.h"].select{|f|not f=~/swig.h/}+Dir["build/*.rb"] # FIXME:replace
-	list+=importsForInterface(target).split(":")
-	list
-}
-
-gen Rule, /^.*interface.i$/ => interfaceSrc do |t|
-	# FIXME: remove expand_ath ???
-    cmd=makeCommand("CREATEINTERFACE",getDirUnix(sys.expand_path(t.name)),importsForInterface(t.name))
-	sys cmd
-end
-#
-###########################################
-
-###########################################
-# make swig-sources
-#
-task :swigSources =>sourceDirs.select{|d|not d=~/external/}.collect{|d|d+"/"+makeLibName(d)+"swig.cc"} do
-end
-#
-###########################################
-
-###########################################
-# make rant-stand-alone
-#
-task :rantStandAlone =>[] do |t|
-	cmd="rant-import --force --auto build.rb"
-    sys cmd
-end
-#
-###########################################
-
-###########################################
-# build extensions
-#
-task :extensions=>allTargets do |t|
-end
-#
-###########################################
-
-
-###########################################
-# build source-distribution
-#
-files=(sys["build/**/*"]+sys["ext/**/*"]+sys["ruby/**/*.rb"]+sys["data/**/*"]+sys["*"]).select{|f|not (f=~/~/ or f=~/.xcf/ or f=~/swig/ or f=~/packages/ or f=~/\.o/ or f=~/\.so/)}
-#puts files
-#exit
-
-if isWindows
-    sourcePkg=gen Package::Zip, "packages","antargis-source-"+extendCommand($config,"version"), :files => files
-else
-    sourcePkg=gen Package::Tgz, "packages","antargis-source-"+extendCommand($config,"version"), :extension => ".tar.gz", :files => files
-end
-
-task :dist=>[:swigSources,:rantStandAlone,sourcePkg.path] do |t|
-end
-#
-###########################################
-
-###########################################
-# build source-distribution
-#
-if isWindows
-    binpkg=gen Package::Zip, "packages","antargis-"+extendCommand($config,"system")+"-"+extendCommand($config,"version"), :files => (sys["ext/*.so"]+sys["ruby/**/*.rb"]+sys["data/**/*"]+sys["*"]).select{|f|not (f=~/~/ or f=~/.xcf/)}
-else
-    binpkg=gen Package::Tgz, "packages","antargis-"+extendCommand($config,"system")+"-"+extendCommand($config,"version"), :extension => ".tar.gz", :files => (sys["ext/*.so"]+sys["ruby/**/*.rb"]+sys["data/**/*"]+sys["*"]).select{|f|not (f=~/~/ or f=~/.xcf/)}
-end
-
-task :bindist=>[:extensions,binpkg.path] do |t| #"packages/antargis-"+extendCommand($config,"version")+".tar.gz"] do |t|
-end
-#
-###########################################
-
-# # build documentation
-# task :doc do
-# 	puts "running doxygen"
-# 	`doxygen Doxyfile`
-# 	rubies=`find -name "*.rb"`.split("\n").select{|f|not (f=~/(contrib|skat|test)/)}.join(" ")
-# 	readmes=`find -name "README"`.split("\n").select{|f|not (f=~/(contrib|skat|test)/)}.join(" ")
-# 	headers=`find -name "*.h"`.split("\n").select{|f|not (f=~/(contrib|skat|test)/)}.join(" ")
-# 	`rdoc -m README --op docs/ruby #{rubies} #{readmes}` # --exclude "(\\.cc|\\.c|skat|test\/|contrib)"`
-# end
-
-desc "Generate html documentation for c++-sources"
-task :doxygen=>[] do |t|
-			# run doxygen in here
- 			`doxygen build/Doxyfile`
- end
-desc "Generate html documentation."
-	gen RubyDoc do |t|
-			a=sys["**/README"]+sys["ruby/**/*.rb"]+sys["INSTALL"]+sys["build/*.rb"]+sys["configure"]+sys["Rantfile"]
-			a=a.select{|f|not f=~/_test/}
-			t.opts = %w(--title Battles\ of\ Antargis --main README --diagram)+a
-			t.dir = "docs/ruby"
-	end
-
-###########################################
-# configure - clean-task
-gen AutoClean, :clean
-var[:clean].include "**/marker.i"   # not needed any more - managed by Rule
-var[:clean].include "ext/*.so"
-var[:clean].include ".deps"
-###########################################
-
-task :check_c_prgs do
-	require 'build/testing.rb'
-	
-	Cmd.setQuiet(true)
-	
-	testFiles=Dir[File.join("ext/**/tests/*.cc")]
-	
-	testFiles.each{|file|
-		Testing.runCTest(file)
-	}
-	puts Testing.getStats
-
-end
-
-task :check=> [:check_c_prgs] do
-end
-
-
-task :spec do
- 	cmd="find ruby -name \"*.rb\"|grep spec|xargs spec -f h>test.html"
-	`#{cmd}`
-end
-

Modified: antargis/trunk/build/swig/tests/test.cc
===================================================================
--- antargis/trunk/build/swig/tests/test.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/build/swig/tests/test.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -3,53 +3,53 @@
 
 A::A(const AGString &a):m(a)
 {
-	std::cout<<"A::A:"<<a<<std::endl;
+  std::cout<<"A::A:"<<a<<std::endl;
 }
 void A::callTest(const AGString &a)
-{
-	std::cout<<"A::callTest:"<<a<<std::endl;
-}
+  {
+    std::cout<<"A::callTest:"<<a<<std::endl;
+  }
 
 AGString A::returnTest() const
 {
-	return "returnTest";
+  return "returnTest";
 }
 
 AGString A::virtReturnTest()
-{
-	return "virtReturnTest";
-}
+  {
+    return "virtReturnTest";
+  }
 
 const AGString &A::virtReturnTest2() const
 {
-	return m;
+  return m;
 }
 
 void A::callVirt()
-{
-	std::cout<<virtReturnTest()<<std::endl;
-}
+  {
+    std::cout<<virtReturnTest()<<std::endl;
+  }
 
 void A::callTest2(AGString &a)
-{
-	a="ksjklkjdslkj";
-}
+  {
+    a="ksjklkjdslkj";
+  }
 
 void A::ptrTest(A *a)
-{
-	std::cout<<a->m<<std::endl;
-}
+  {
+    std::cout<<a->m<<std::endl;
+  }
 
 
 
 C::C(const AGString &a):A(a)
 {
-	std::cout<<"C::C:"<<a<<std::endl;
+  std::cout<<"C::C:"<<a<<std::endl;
 }
 
 
 
 AGString C::virtReturnTest()
-{
-	return "virtReturnTest2";
-}
+  {
+    return "virtReturnTest2";
+  }

Modified: antargis/trunk/data/levels/tutorial/tutorial0.antlvl
===================================================================
--- antargis/trunk/data/levels/tutorial/tutorial0.antlvl	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/data/levels/tutorial/tutorial0.antlvl	2008-02-24 19:05:29 UTC (rev 1230)
@@ -3,7 +3,7 @@
     <position x="56.642" y="51.0992" z="1.78436"/>
 		<resource food="30" stone="50"/>
   </antTower>
-  <antHero aggression="3" appearance="hero" energy="1" healSpeed="0.1" morale="1" name="" onGround="true" name="Rowen" primary="true">
+  <antHero aggression="1" appearance="hero" energy="1" healSpeed="0.1" morale="1" name="" onGround="true" name="Rowen" primary="true">
     <position x="64.4641" y="51.154" z="2.22674"/>
 		<resource food="10"/>
   </antHero>

Modified: antargis/trunk/ext/3dengine/anim_mesh.cc
===================================================================
--- antargis/trunk/ext/3dengine/anim_mesh.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/anim_mesh.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -16,54 +16,54 @@
 
 
 void setRotation(AGMatrix4 &m,const AGVector3 &angles)
-{
-  double cr = cos( angles[0] );
-  double sr = sin( angles[0] );
-  double cp = cos( angles[1] );
-  double sp = sin( angles[1] );
-  double cy = cos( angles[2] );
-  double sy = sin( angles[2] );
-  // FIXME: maybe the coord must be switched
+  {
+    double cr = cos( angles[0] );
+    double sr = sin( angles[0] );
+    double cp = cos( angles[1] );
+    double sp = sin( angles[1] );
+    double cy = cos( angles[2] );
+    double sy = sin( angles[2] );
+    // FIXME: maybe the coord must be switched
 
-  m.set(0,0,( float )( cp*cy ));
-  m.set(0,1,( float )( cp*sy ));
-  m.set(0,2,( float )( -sp ));
+    m.set(0,0,( float )( cp*cy ));
+    m.set(0,1,( float )( cp*sy ));
+    m.set(0,2,( float )( -sp ));
     double srsp = sr*sp;
-  double crsp = cr*sp;
+    double crsp = cr*sp;
 
-  m.set(1,0,( float )( srsp*cy-cr*sy ));
-  m.set(1,1,( float )( srsp*sy+cr*cy ));
-  m.set(1,2,( float )( sr*cp ));
-  
-  m.set(2,0,( float )( crsp*cy+sr*sy ));
-  m.set(2,1,( float )( crsp*sy-sr*cy ));
-  m.set(2,2,( float )( cr*cp ));
+    m.set(1,0,( float )( srsp*cy-cr*sy ));
+    m.set(1,1,( float )( srsp*sy+cr*cy ));
+    m.set(1,2,( float )( sr*cp ));
 
-}
+    m.set(2,0,( float )( crsp*cy+sr*sy ));
+    m.set(2,1,( float )( crsp*sy-sr*cy ));
+    m.set(2,2,( float )( cr*cp ));
 
+  }
+
 void setTranslation(AGMatrix4 &m,const AGVector3 &t)
-{
-  m.set(3,0,t[0]);
-  m.set(3,1,t[1]);
-  m.set(3,2,t[2]);
-}
+  {
+    m.set(3,0,t[0]);
+    m.set(3,1,t[1]);
+    m.set(3,2,t[2]);
+  }
 
 
 void inverseRotate(AGVector3 &v, const AGMatrix4 &m )
-{
-  AGVector3 n;
-  n[0]=v[0]*m.get(0,0) + v[1]*m.get(0,1) + v[2]*m.get(0,2);
-  n[1]=v[0]*m.get(1,0) + v[1]*m.get(1,1) + v[2]*m.get(1,2);
-  n[2]=v[0]*m.get(2,0) + v[1]*m.get(2,1) + v[2]*m.get(2,2);
-  v=n;
-}
+  {
+    AGVector3 n;
+    n[0]=v[0]*m.get(0,0) + v[1]*m.get(0,1) + v[2]*m.get(0,2);
+    n[1]=v[0]*m.get(1,0) + v[1]*m.get(1,1) + v[2]*m.get(1,2);
+    n[2]=v[0]*m.get(2,0) + v[1]*m.get(2,1) + v[2]*m.get(2,2);
+    v=n;
+  }
 
 void inverseTranslate(AGVector3 &v, const AGMatrix4 &m )
-{
-  v[0]-=m.get(3,0);
-  v[1]-=m.get(3,1);
-  v[2]-=m.get(3,2);
-}
+  {
+    v[0]-=m.get(3,0);
+    v[1]-=m.get(3,1);
+    v[2]-=m.get(3,2);
+  }
 
 
 
@@ -75,292 +75,292 @@
 AnimMesh::AnimMesh(Scene *pScene,AnimMeshData *data):
   MeshBase(pScene,AGVector4(),data->bbox()),
   mData(data),mMatrices(data->bones.size()+1),mShaderMatrices(20)
-{
-  curKey=0;
-  mTime=0;
-  
-  assert(mData->mAnimations.size()>0);
-  mAnimName=mData->mAnimations.begin()->first;
-  mAnimation=&mData->mAnimations.begin()->second;
+  {
+    curKey=0;
+    mTime=0;
 
-  mEntity=0;
-  setOrder(MESH_Z);
+    assert(mData->mAnimations.size()>0);
+    mAnimName=mData->mAnimations.begin()->first;
+    mAnimation=&mData->mAnimations.begin()->second;
 
-}
+    mEntity=0;
+    setOrder(MESH_Z);
 
+  }
+
 AnimMesh::~AnimMesh()
-{
-  //  CTRACE;
-}
+  {
+    //  CTRACE;
+  }
 
 void AnimMesh::setEntity(AntEntity *e)
-{
-  mEntity=e;
-}
+  {
+    mEntity=e;
+  }
 
 
 void AnimMesh::drawDepth()
-{
-  STACKTRACE;
-  drawPrivate(false,false);
-}
+  {
+    STACKTRACE;
+    drawPrivate(false,false);
+  }
 
 void AnimMesh::draw()
-{
-  STACKTRACE;
-  //return;
-  drawPrivate(true,false);
-}
+  {
+    STACKTRACE;
+    //return;
+    drawPrivate(true,false);
+  }
 void AnimMesh::drawPick()
-{
-  STACKTRACE;
-  drawPrivate(false,true);
-}
+  {
+    STACKTRACE;
+    drawPrivate(false,true);
+  }
 
 
 void AnimMesh::drawPrivate(bool textured, bool mem)
-{
-  assertGL;
-  AGRenderContext c;
-  if(textured)
-    {
-      c.setTexture(mData->mTexture.glTexture());
-      
-      c.setLighting(true);
-    }
-  c.begin();
-  glPushMatrix();
+  {
+    assertGL;
+    AGRenderContext c;
+    if(textured)
+      {
+        c.setTexture(mData->mTexture.glTexture());
 
-  AGVector4 p=getPos();
-  glTranslatef(p[0],p[1],p[2]);
-  glRotatef(mRot[3],mRot[0],mRot[1],mRot[2]);
+        c.setLighting(true);
+      }
+    c.begin();
+    glPushMatrix();
 
-  bool pick=mem&&(!textured);
+    AGVector4 p=getPos();
+    glTranslatef(p[0],p[1],p[2]);
+    glRotatef(mRot[3],mRot[0],mRot[1],mRot[2]);
 
+    bool pick=mem&&(!textured);
 
-  if(useShaderAnimation() && !pick)
-    {
-      glMultMatrixf(mData->getTransform());
-      if(textured)
-	{
-	  mData->animShader.enable();
 
-	  mData->animShader.sendUniform("matrices",mShaderMatrices);
-	  
-	  //	  mData->mArrayDepth.setColors(false);
-	  mData->mArray.draw();
+    if(useShaderAnimation() && !pick)
+      {
+        glMultMatrixf(mData->getTransform());
+        if(textured)
+          {
+            mData->animShader.enable();
 
-	  mData->animShader.disable();
+            mData->animShader.sendUniform("matrices",mShaderMatrices);
 
-	}
-      else if(mem)
-	{
-	  mData->mArray.drawPick();
-	}
-      else
-	{
-	  mData->animShaderDepth.enable();
+            //mData->mArrayDepth.setColors(false);
+            mData->mArray.draw();
 
-	  mData->animShaderDepth.sendUniform("matrices",mShaderMatrices);
+            mData->animShader.disable();
 
-	  mData->mArrayDepth.setColors(false);
+          }
+        else if(mem)
+          {
+            mData->mArray.drawPick();
+          }
+        else
+          {
+            mData->animShaderDepth.enable();
 
-	  mData->mArrayDepth.draw(); // FIXME: drawDepth makes some problems here
+            mData->animShaderDepth.sendUniform("matrices",mShaderMatrices);
 
-	  mData->animShaderDepth.disable();
-	}
-    }
+            mData->mArrayDepth.setColors(false);
 
-  else if(!mData->animate)
-    {
-      glBegin(GL_TRIANGLES);
-      
-      // for a start do a simple drawing 
-      for(std::vector<size_t>::iterator i=mData->indices.begin();i!=mData->indices.end();i++)
-	{
-	  AGMatrix4 m(mData->getTransform());
-	  AGVector3 p((m*AGVector4(mData->pos[*i],1)).dim3());
-	  if(textured)
-	    {
-	      AGVector3 n((m*AGVector4(mData->normal[*i],0)).dim3());
-	      
-	      glNormal3fv(n);
-	      glTexCoord2fv(mData->uv[*i]);
-	    }
-	  glVertex3fv(p);
-	  
-	}
-      
-      glEnd();
-    }
-  else
-    {
+            mData->mArrayDepth.draw(); // FIXME: drawDepth makes some problems here
 
-      // paint with transform
+            mData->animShaderDepth.disable();
+          }
+      }
 
-      glMultMatrixf(mData->getTransform());
+    else if(!mData->animate)
+      {
+        glBegin(GL_TRIANGLES);
 
-      glBegin(GL_TRIANGLES);
-      
-      // for a start do a simple drawing 
-      for(std::vector<size_t>::iterator i=mData->indices.begin();i!=mData->indices.end();i++)
-	{
-	  int b=mData->bone[*i];
-	  AGMatrix4 m;
-	  if(b>=0)
-	    {
-	      m=mMatrices[b];
-	    }
-	  AGVector3 p((m*AGVector4(mData->pos[*i],1)).dim3());
-	  if(textured)
-	    {
-	      AGVector3 n((m*AGVector4(mData->normal[*i],0)).dim3());
-	      
-	      glNormal3fv(n);
-	      glTexCoord2fv(mData->uv[*i]);
-	    }
-	  glVertex3fv(p);
-	}
-      
-      glEnd();
+        // for a start do a simple drawing 
+        for(std::vector<size_t>::iterator i=mData->indices.begin();i!=mData->indices.end();i++)
+          {
+            AGMatrix4 m(mData->getTransform());
+            AGVector3 p((m*AGVector4(mData->pos[*i],1)).dim3());
+            if(textured)
+              {
+                AGVector3 n((m*AGVector4(mData->normal[*i],0)).dim3());
 
+                glNormal3fv(n);
+                glTexCoord2fv(mData->uv[*i]);
+              }
+            glVertex3fv(p);
 
-    }
-  
-  glPopMatrix();
-  assertGL;
-}
+          }
 
+        glEnd();
+      }
+    else
+      {
+
+        // paint with transform
+
+        glMultMatrixf(mData->getTransform());
+
+        glBegin(GL_TRIANGLES);
+
+        // for a start do a simple drawing 
+        for(std::vector<size_t>::iterator i=mData->indices.begin();i!=mData->indices.end();i++)
+          {
+            int b=mData->bone[*i];
+            AGMatrix4 m;
+            if(b>=0)
+              {
+                m=mMatrices[b];
+              }
+            AGVector3 p((m*AGVector4(mData->pos[*i],1)).dim3());
+            if(textured)
+              {
+                AGVector3 n((m*AGVector4(mData->normal[*i],0)).dim3());
+
+                glNormal3fv(n);
+                glTexCoord2fv(mData->uv[*i]);
+              }
+            glVertex3fv(p);
+          }
+
+        glEnd();
+
+
+      }
+
+    glPopMatrix();
+    assertGL;
+  }
+
 void AnimMesh::advance(float time)
-{
-  if(!mData->animate)
-    return;
-  float oldTime=mTime;
+  {
+    if(!mData->animate)
+      return;
+    float oldTime=mTime;
 
-  mTime+=mAnimation->fps*time;
+    mTime+=mAnimation->fps*time;
 
-  if(mAnimation->len>0)
-    {
-      if(mAnimation->loop)
-	while(mTime>mAnimation->end)
-	  mTime-=mAnimation->len;
-      else
-	mTime=std::min(mTime,mAnimation->end);
-    }
-  else
-    mTime=mAnimation->begin;
+    if(mAnimation->len>0)
+      {
+        if(mAnimation->loop)
+          while(mTime>mAnimation->end)
+            mTime-=mAnimation->len;
+        else
+          mTime=std::min(mTime,mAnimation->end);
+      }
+    else
+      mTime=mAnimation->begin;
 
-  mTime=std::max(mTime,mAnimation->begin);
+    mTime=std::max(mTime,mAnimation->begin);
 
-  //  cdebug(mAnimName<<"  "<<mTime<<"  "<<mAnimation->len<<" "<<mAnimation->begin<<" "<<mAnimation->end);
+    //  cdebug(mAnimName<<"  "<<mTime<<"  "<<mAnimation->len<<" "<<mAnimation->begin<<" "<<mAnimation->end);
 
 
-  // check events
-  if(mEntity && mData->frameEvents.size())
-    {
-      if(oldTime>mTime)
-	{
-	  for(std::map<int,AGString>::iterator i=mData->frameEvents.begin();i!=mData->frameEvents.end();i++)
-	    if(i->first>=oldTime || i->first<mTime)
-	      mEntity->animationEvent(i->second);
-	}
-      else
-	{
-	  for(std::map<int,AGString>::iterator i=mData->frameEvents.begin();i!=mData->frameEvents.end();i++)
-	    {
-	      if(i->first>=oldTime && i->first<mTime)
-		mEntity->animationEvent(i->second);
-	    }
-	}
+    // check events
+    if(mEntity && mData->frameEvents.size())
+      {
+        if(oldTime>mTime)
+          {
+            for(std::map<int,AGString>::iterator i=mData->frameEvents.begin();i!=mData->frameEvents.end();i++)
+              if(i->first>=oldTime || i->first<mTime)
+                mEntity->animationEvent(i->second);
+          }
+        else
+          {
+            for(std::map<int,AGString>::iterator i=mData->frameEvents.begin();i!=mData->frameEvents.end();i++)
+              {
+                if(i->first>=oldTime && i->first<mTime)
+                  mEntity->animationEvent(i->second);
+              }
+          }
 
-    }
+      }
 
 
-  update();
-}
+    update();
+  }
 
 void AnimMesh::update()
-{
-  // this doesn't take much of rendering-time
-  // calculate 
-  
-  while(mTime>mData->animTime)
-    mTime-=mData->animTime;
-  
-  for(size_t k=0;k<mData->bones.size();k++)
-    {
-      Bone *bone=mData->bones[k];
-      AGMatrix4 final(bone->mRelative);
-      AGMatrix4 trans;
-      AGVector3 rot,pos;
+  {
+    // this doesn't take much of rendering-time
+    // calculate 
 
-      // first get surrounding keyframes (rot & trans) for this bone 
-      // and calculate ri0,ri1 and ti0,ti1 (1-ti0 == ti1)
+    while(mTime>mData->animTime)
+      mTime-=mData->animTime;
 
-      rot=bone->interpolateRot(mTime);
-      pos=bone->interpolateTrans(mTime);
+    for(size_t k=0;k<mData->bones.size();k++)
+      {
+        Bone *bone=mData->bones[k];
+        AGMatrix4 final(bone->mRelative);
+        AGMatrix4 trans;
+        AGVector3 rot,pos;
 
-      ::setRotation(trans,rot);
-      setTranslation(trans,pos);
-      
-      
-      final=final*trans;
-      
-      if(mData->bones[k]->parent)
-	final=mMatrices[mData->bones[k]->parent->id]*final;
-      
-      mMatrices[k]=final;
-    }
-  mMatrices[mData->bones.size()]=AGMatrix4();
+        // first get surrounding keyframes (rot & trans) for this bone 
+        // and calculate ri0,ri1 and ti0,ti1 (1-ti0 == ti1)
 
-  for(size_t k=0;k<mData->bones.size();k++)
-    mShaderMatrices[k]=mData->getTransform()*mMatrices[k];
-  mShaderMatrices[mData->bones.size()]=mData->getTransform()*mMatrices[mData->bones.size()];
+        rot=bone->interpolateRot(mTime);
+        pos=bone->interpolateTrans(mTime);
 
+        ::setRotation(trans,rot);
+        setTranslation(trans,pos);
 
-  for(size_t k=0;k<mData->bones.size();k++)
-    mShaderMatrices[k]=mMatrices[k];
 
-  mShaderMatrices[mData->bones.size()]=mMatrices[mData->bones.size()];
-}
+        final=final*trans;
 
+        if(mData->bones[k]->parent)
+          final=mMatrices[mData->bones[k]->parent->id]*final;
 
+        mMatrices[k]=final;
+      }
+    mMatrices[mData->bones.size()]=AGMatrix4();
+
+    for(size_t k=0;k<mData->bones.size();k++)
+      mShaderMatrices[k]=mData->getTransform()*mMatrices[k];
+    mShaderMatrices[mData->bones.size()]=mData->getTransform()*mMatrices[mData->bones.size()];
+
+
+    for(size_t k=0;k<mData->bones.size();k++)
+      mShaderMatrices[k]=mMatrices[k];
+
+    mShaderMatrices[mData->bones.size()]=mMatrices[mData->bones.size()];
+  }
+
+
 AnimMeshData *AnimMesh::getData()
-{
-  return mData;
-}
+  {
+    return mData;
+  }
 
 
 void AnimMesh::setTransform(const AGMatrix4 &m)
-{
-  mTransform=m;
-  assert(mData);
-  mComplete=mData->getTransform()*mTransform;
-}
+  {
+    mTransform=m;
+    assert(mData);
+    mComplete=mData->getTransform()*mTransform;
+  }
 
 void AnimMesh::setPos(const AGVector3 &p)
-{
-  SceneNode::setPos(p);
+  {
+    SceneNode::setPos(p);
 
-  mTransform=AGMatrix4(mRot[3],mRot.dim3())*AGMatrix4(getPos());//p);//mPos);
+    mTransform=AGMatrix4(mRot[3],mRot.dim3())*AGMatrix4(getPos());//p);//mPos);
 
-  assert(mData);
-  mComplete=mData->getTransform()*mTransform;
-}
+    assert(mData);
+    mComplete=mData->getTransform()*mTransform;
+  }
 void AnimMesh::setRotation(const AGVector3 &r,float a)
-{
-  mRot=AGVector4(r,a);
+  {
+    mRot=AGVector4(r,a);
 
-  mTransform=AGMatrix4(a,r)*AGMatrix4(getPos());
+    mTransform=AGMatrix4(a,r)*AGMatrix4(getPos());
 
-  assert(mData);
-  mComplete=mData->getTransform()*mTransform;
-}
+    assert(mData);
+    mComplete=mData->getTransform()*mTransform;
+  }
 
 void AnimMesh::setRotation(float r)
-{
-  setRotation(AGVector3(0,0,1),r+180);
-}
+  {
+    setRotation(AGVector3(0,0,1),r+180);
+  }
 
 AGString AnimMesh::getAnimation() const
 {
@@ -368,25 +368,25 @@
 }
 
 bool AnimMesh::setAnimation(const AGString &pName)
-{
-  if(mAnimName==pName)
+  {
+    if(mAnimName==pName)
+      return true;
+    if(mData->mAnimations.find(pName)==mData->mAnimations.end())
+      {
+        cdebug(AGString("Animation ")+pName+" is known here!");
+        return false;
+      }
+
+    mAnimation=&(mData->mAnimations[pName]);
+    mAnimName=pName;
+    mTime=mAnimation->begin;
     return true;
-  if(mData->mAnimations.find(pName)==mData->mAnimations.end())
-    {
-      cdebug(AGString("Animation ")+pName+" is known here!");
-      return false;
-    }
+  }
 
-  mAnimation=&(mData->mAnimations[pName]);
-  mAnimName=pName;
-  mTime=mAnimation->begin;
-  return true;
-}
-
 void AnimMesh::mark()
-{
-  markObject(mData);
-}
+  {
+    markObject(mData);
+  }
 
 size_t AnimMesh::getTriangles() const
 {

Modified: antargis/trunk/ext/3dengine/anim_mesh_data.cc
===================================================================
--- antargis/trunk/ext/3dengine/anim_mesh_data.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/anim_mesh_data.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -12,50 +12,50 @@
 
 
 bool useAnimation()
-{
-  bool anim=getConfig()->get("animationType")!="false";
-  getConfig()->set("animationType",anim?"true":"false");
-  return anim;
-}
+  {
+    bool anim=getConfig()->get("animationType")!="false";
+    getConfig()->set("animationType",anim?"true":"false");
+    return anim;
+  }
 
 bool useShaderAnimation()
-{
-  return glslOk() && GLEE_ARB_vertex_buffer_object; // doesn't work with vbos
-}
+  {
+    return glslOk() && GLEE_ARB_vertex_buffer_object; // doesn't work with vbos
+  }
 
 AGVector3 Bone::interpolate(const std::vector<KeyFrame> &frames,float t)
-{
-  size_t i;
-  for(i=0;i<frames.size();i++)
-    {
-      if(frames.size()>i+1)
-	{
-	  if(frames[i+1].time>t)
-	    break;
-	}
-      else
-	break;
-    }
-  size_t j=i+1;
-  if(j>=frames.size())
-    return frames[i].v;
-  
-  float t0=frames[i].time;
-  float t1=frames[j].time;
+  {
+    size_t i;
+    for(i=0;i<frames.size();i++)
+      {
+        if(frames.size()>i+1)
+          {
+            if(frames[i+1].time>t)
+              break;
+          }
+        else
+          break;
+      }
+    size_t j=i+1;
+    if(j>=frames.size())
+      return frames[i].v;
 
-  float i0=(t-t0)/(t1-t0);
-  float i1=1-i0;
+    float t0=frames[i].time;
+    float t1=frames[j].time;
 
-  return frames[i].v*i1 + frames[j].v*i0;
-}
+    float i0=(t-t0)/(t1-t0);
+    float i1=1-i0;
+
+    return frames[i].v*i1 + frames[j].v*i0;
+  }
 AGVector3 Bone::interpolateRot(float t)
-{
-  return interpolate(rFrames,t);
-}
+  {
+    return interpolate(rFrames,t);
+  }
 AGVector3 Bone::interpolateTrans(float t)
-{
-  return interpolate(tFrames,t);
-}
+  {
+    return interpolate(tFrames,t);
+  }
 
 
 
@@ -65,70 +65,70 @@
   animShaderDepth("data/shaders/anim_depth.vert","data/shaders/anim_depth.frag"),
   mArray(&animShader),
   mArrayDepth(&animShaderDepth)
-{
-  Document doc(xmlfile);
+  {
+    Document doc(xmlfile);
 
-  Node &root=doc.root();
+    Node &root=doc.root();
 
-  events=false;
+    events=false;
 
-  animate=true;
-  if(root.get("debug")=="true")
-    animate=false;
-  if(!useAnimation())
-    animate=false;
+    animate=true;
+    if(root.get("debug")=="true")
+      animate=false;
+    if(!useAnimation())
+      animate=false;
 
-  cdebug("loading from:"<<root.get("model"));
+    cdebug("loading from:"<<root.get("model"));
 
-  loadAnt3(loadFile(root.get("model")),root.get("scale").toFloat(),root.get("texture"));
-  
-  // load animations
-  
-  cdebug("animTime:"<<animTime);
+    loadAnt3(loadFile(root.get("model")),root.get("scale").toFloat(),root.get("texture"));
 
-  Node::NodeVector anims=root.getChildren("animation");
-  for(Node::NodeVector::iterator i=anims.begin();i!=anims.end();i++)
-    {
-      float begin=(*i)->get("begin").toFloat()-1;
-      float end=(*i)->get("end").toFloat()-1;
-      float fps=(*i)->get("fps").toFloat();
-      assert(fps>0);
-      assert(begin>=0);
-      assert(begin<animTime);
-      assert(begin<=end);
-      assert(end<animTime);
-      mAnimations[(*i)->get("name")]=Animation(begin,end,fps);
+    // load animations
 
-      mAnimations[(*i)->get("name")].loop=((*i)->get("loop")!="false");
+    cdebug("animTime:"<<animTime);
 
-      // parse events
-      Node::NodeVector enodes=(*i)->getChildren("event");
-      for(Node::NodeVector::iterator j=enodes.begin();j!=enodes.end();j++)
-	{
-	  frameEvents.insert(std::make_pair((*j)->get("frame").toInt(),(*j)->get("name")));
-	}
-      
-    }
+    Node::NodeVector anims=root.getChildren("animation");
+    for(Node::NodeVector::iterator i=anims.begin();i!=anims.end();i++)
+      {
+        float begin=(*i)->get("begin").toFloat()-1;
+        float end=(*i)->get("end").toFloat()-1;
+        float fps=(*i)->get("fps").toFloat();
+        assert(fps>0);
+        assert(begin>=0);
+        assert(begin<animTime);
+        assert(begin<=end);
+        assert(end<animTime);
+        mAnimations[(*i)->get("name")]=Animation(begin,end,fps);
 
-  if(anims.size()==0)
-    {
-      std::cerr<<"There are no animations in "<<xmlfile<<std::endl;
-      throw std::string("no animations found in xmlfile");
-    }
-  mName=AGString(xmlfile);
-}
+        mAnimations[(*i)->get("name")].loop=((*i)->get("loop")!="false");
 
+        // parse events
+        Node::NodeVector enodes=(*i)->getChildren("event");
+        for(Node::NodeVector::iterator j=enodes.begin();j!=enodes.end();j++)
+          {
+            frameEvents.insert(std::make_pair((*j)->get("frame").toInt(),(*j)->get("name")));
+          }
+
+      }
+
+    if(anims.size()==0)
+      {
+        std::cerr<<"There are no animations in "<<xmlfile<<std::endl;
+        throw std::string("no animations found in xmlfile");
+      }
+    mName=AGString(xmlfile);
+  }
+
 AnimMeshData::~AnimMeshData()
-{
-  CTRACE;
-  cdebug(mName);
+  {
+    CTRACE;
+    cdebug(mName);
 
-  // delete bones
-  for(std::vector<Bone*>::iterator i=bones.begin();i!=bones.end();++i)
-    delete *i;
+    // delete bones
+    for(std::vector<Bone*>::iterator i=bones.begin();i!=bones.end();++i)
+      delete *i;
 
 
-}
+  }
 
 AGBox3 AnimMeshData::bbox() const
 {
@@ -136,131 +136,131 @@
 }
 
 void AnimMeshData::setEvents(bool e)
-{
-  events=e;
-}
+  {
+    events=e;
+  }
 
 
 int getMeshDownScale()
-{
-  int s=1;
-  AGString n="meshDownScaleExp";
+  {
+    int s=1;
+    AGString n="meshDownScaleExp";
 
-  if(getConfig()->get(n)!="")
-    s=getConfig()->get(n).toInt();
-  
-  getConfig()->set(n,AGString(s));
+    if(getConfig()->get(n)!="")
+      s=getConfig()->get(n).toInt();
 
-  return s;
+    getConfig()->set(n,AGString(s));
 
-}
+    return s;
 
+  }
+
 void AnimMeshData::loadAnt3(const AGData &instr,float scale,const AGFilename &tex)
-{
-  mTexture=getTextureCache()->get(tex,getMeshDownScale());
-  BinaryStringIn l(instr);
+  {
+    mTexture=getTextureCache()->get(tex,getMeshDownScale());
+    BinaryStringIn l(instr);
 
-  Uint32 vs,ts;
+    Uint32 vs,ts;
 
-  l>>vs;
-  for(Uint32 i=0;i<vs;i++)
-    {
-      float x,y,z,tx,ty,nx,ny,nz;
-      Sint32 boneID;
-      l>>x>>y>>z>>tx>>ty>>boneID>>nx>>ny>>nz;
+    l>>vs;
+    for(Uint32 i=0;i<vs;i++)
+      {
+        float x,y,z,tx,ty,nx,ny,nz;
+        Sint32 boneID;
+        l>>x>>y>>z>>tx>>ty>>boneID>>nx>>ny>>nz;
 
-      AGVector3 v(x,y,z);
-      v*=scale;
-      mBBox.include(v);
-      pos.push_back(v);
-      uv.push_back(AGVector2(tx,1-ty));
-      normal.push_back(AGVector3(nx,ny,nz));
-      bone.push_back(boneID);
-    }
+        AGVector3 v(x,y,z);
+        v*=scale;
+        mBBox.include(v);
+        pos.push_back(v);
+        uv.push_back(AGVector2(tx,1-ty));
+        normal.push_back(AGVector3(nx,ny,nz));
+        bone.push_back(boneID);
+      }
 
-  l>>ts;
-  Uint32 index;
-  for(Uint32 i=0;i<ts*3;i++)
-    {
-      l>>index;
-      indices.push_back(index);
-    }
+    l>>ts;
+    Uint32 index;
+    for(Uint32 i=0;i<ts*3;i++)
+      {
+        l>>index;
+        indices.push_back(index);
+      }
 
-  Uint32 nbones,frames;
-  l>>frames>>nbones;
+    Uint32 nbones,frames;
+    l>>frames>>nbones;
 
-  for(size_t k=0;k<bone.size();k++)
-    {
-      if(bone[k]==-1)
-	{
-	  bonef.push_back(nbones);
-	  boneui.push_back(nbones);
-	}
-      else
-	{
-	  bonef.push_back(bone[k]);
-	  boneui.push_back(bone[k]);
-	}
-    }
+    for(size_t k=0;k<bone.size();k++)
+      {
+        if(bone[k]==-1)
+          {
+            bonef.push_back(nbones);
+            boneui.push_back(nbones);
+          }
+        else
+          {
+            bonef.push_back(bone[k]);
+            boneui.push_back(bone[k]);
+          }
+      }
 
 
-  animTime=frames;
+    animTime=frames;
 
-  for(Uint32 i=0;i<nbones;i++)
-    {
-      float x,y,z,rx,ry,rz;
-      Sint32 parent;
-      l>>x>>y>>z>>rx>>ry>>rz>>parent;
-      Bone *bone=new Bone;
-      bone->id=i;
-      bone->pos=AGVector3(x,y,z)*scale;
-      bone->rot=AGVector3(rx,ry,rz);
-      if(parent<0)
-	bone->parent=0;
-      else
-	{
-	  assert(parent<(int)i);
-	  bone->parent=bones[parent];
-	}
+    for(Uint32 i=0;i<nbones;i++)
+      {
+        float x,y,z,rx,ry,rz;
+        Sint32 parent;
+        l>>x>>y>>z>>rx>>ry>>rz>>parent;
+        Bone *bone=new Bone;
+        bone->id=i;
+        bone->pos=AGVector3(x,y,z)*scale;
+        bone->rot=AGVector3(rx,ry,rz);
+        if(parent<0)
+          bone->parent=0;
+        else
+          {
+            assert(parent<(int)i);
+            bone->parent=bones[parent];
+          }
 
-      // read rot-frames
-      Sint32 frames;
-      l>>frames;
-      KeyFrame frame;
-      for(Sint32 r=0;r<frames;r++)
-	{
-	  float x,y,z,t;
-	  l>>t>>x>>y>>z;
-	  frame.time=t;
-	  frame.v=AGVector3(x,y,z);
-	  bone->rFrames.push_back(frame);
-	}
+        // read rot-frames
+        Sint32 frames;
+        l>>frames;
+        KeyFrame frame;
+        for(Sint32 r=0;r<frames;r++)
+          {
+            float x,y,z,t;
+            l>>t>>x>>y>>z;
+            frame.time=t;
+            frame.v=AGVector3(x,y,z);
+            bone->rFrames.push_back(frame);
+          }
 
-      l>>frames;
-      for(Sint32 r=0;r<frames;r++)
-	{
-	  float x,y,z,t;
-	  l>>t>>x>>y>>z;
-	  frame.time=t;
-	  frame.v=AGVector3(x,y,z)*scale;
-	  bone->tFrames.push_back(frame);
-	}
+        l>>frames;
+        for(Sint32 r=0;r<frames;r++)
+          {
+            float x,y,z,t;
+            l>>t>>x>>y>>z;
+            frame.time=t;
+            frame.v=AGVector3(x,y,z)*scale;
+            bone->tFrames.push_back(frame);
+          }
 
 
 
-      bones.push_back(bone);
-    }
+        bones.push_back(bone);
+      }
 
-  if(animate)
-    setupJoints();
+    if(animate)
+      setupJoints();
 
-  setupArray();
-}
+    setupArray();
+  }
 
 void AnimMeshData::setTransform(const AGMatrix4 &m)
-{
-  mBase=m;
-}
+  {
+    mBase=m;
+  }
 
 const AGMatrix4 &AnimMeshData::getTransform() const
 {
@@ -269,62 +269,62 @@
 
 
 void AnimMeshData::setupJoints()
-{
-  for (std::vector<Bone*>::iterator i = bones.begin(); i!=bones.end(); i++ )
-    {
-      Bone& joint = **i;
+  {
+    for (std::vector<Bone*>::iterator i = bones.begin(); i!=bones.end(); i++ )
+      {
+        Bone& joint = **i;
 
-      setRotation(joint.mRelative, joint.rot);
-      setTranslation(joint.mRelative, joint.pos);
+        setRotation(joint.mRelative, joint.rot);
+        setTranslation(joint.mRelative, joint.pos);
 
-      if(joint.parent)
-	joint.mAbsolute=joint.parent->mAbsolute*joint.mRelative;
-      else
-	joint.mAbsolute=joint.mRelative;
+        if(joint.parent)
+          joint.mAbsolute=joint.parent->mAbsolute*joint.mRelative;
+        else
+          joint.mAbsolute=joint.mRelative;
 
-    }
+      }
 
-  for (size_t i=0;i<pos.size();i++)
-    {
-      if(bone[i]!=-1)
-	{
-	  AGMatrix4 m(bones[bone[i]]->mAbsolute);
-	  AGVector3 test=pos[i];
-	  inverseTranslate(pos[i],m);
-	  inverseRotate(pos[i],m);
+    for (size_t i=0;i<pos.size();i++)
+      {
+        if(bone[i]!=-1)
+          {
+            AGMatrix4 m(bones[bone[i]]->mAbsolute);
+            AGVector3 test=pos[i];
+            inverseTranslate(pos[i],m);
+            inverseRotate(pos[i],m);
 
-	  // normals
-	  inverseRotate(normal[i],m);
-	}
-    }
-}
+            // normals
+            inverseRotate(normal[i],m);
+          }
+      }
+  }
 
 
 void AnimMeshData::setupArray()
-{
-  for(size_t i=0;i<pos.size();i++)
-    mArray.addVertex(AGVector4(pos[i],1),AGVector4(1,1,1,1),normal[i],uv[i]);
-  for(size_t i=0;i<indices.size();i+=3)
-    mArray.addTriangle(indices[i],indices[i+1],indices[i+2]);
+  {
+    for(size_t i=0;i<pos.size();i++)
+      mArray.addVertex(AGVector4(pos[i],1),AGVector4(1,1,1,1),normal[i],uv[i]);
+    for(size_t i=0;i<indices.size();i+=3)
+      mArray.addTriangle(indices[i],indices[i+1],indices[i+2]);
 
-  // set boneIDs
-  mArray.addAttribute("bones",bonef);
-  //  mArray.addAttribute("ibones",boneui);
+    // set boneIDs
+    mArray.addAttribute("bones",bonef);
+    //  mArray.addAttribute("ibones",boneui);
 
 
 
 
-  for(size_t i=0;i<pos.size();i++)
-    mArrayDepth.addVertex(AGVector4(pos[i],1),AGVector4(1,1,1,1),normal[i],uv[i]);
-  for(size_t i=0;i<indices.size();i+=3)
-    mArrayDepth.addTriangle(indices[i],indices[i+1],indices[i+2]);
+    for(size_t i=0;i<pos.size();i++)
+      mArrayDepth.addVertex(AGVector4(pos[i],1),AGVector4(1,1,1,1),normal[i],uv[i]);
+    for(size_t i=0;i<indices.size();i+=3)
+      mArrayDepth.addTriangle(indices[i],indices[i+1],indices[i+2]);
 
-  // set boneIDs
-  mArrayDepth.addAttribute("bones",bonef);
-  //  mArrayDepth.addAttribute("ibones",boneui);
+    // set boneIDs
+    mArrayDepth.addAttribute("bones",bonef);
+    //  mArrayDepth.addAttribute("ibones",boneui);
 
 
-}
+  }
 
 std::vector<std::string> AnimMeshData::getAnimations() const
 {

Modified: antargis/trunk/ext/3dengine/ant_camera.cc
===================================================================
--- antargis/trunk/ext/3dengine/ant_camera.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/ant_camera.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -20,161 +20,160 @@
 
 #include "ant_camera.h"
 #include "ant_renderer.h"
-#include <GL/gl.h>
-#include <GL/glu.h>
+#include <SDL_opengl.h>
 #include <math.h>
 
 #include "ag_debug.h"
 
 AntCamera::AntCamera(int w,int h)
-{
-  mWidth=w;
-  mHeight=h;
+  {
+    mWidth=w;
+    mHeight=h;
 
-  cameraPosition=AGVector4(0,-20,20);
-  lightPosition=AGVector4( -25, -50, 60,1);
-  scenePosition=AGVector4(0,0,0,1);
+    cameraPosition=AGVector4(0,-20,20);
+    lightPosition=AGVector4( -25, -50, 60,1);
+    scenePosition=AGVector4(0,0,0,1);
 
-  cameraPosition=AGVector4(0,-15,15);
+    cameraPosition=AGVector4(0,-15,15);
 
-  mPSM=false;
-  updateMatrices();
-}
+    mPSM=false;
+    updateMatrices();
+  }
 
 void AntCamera::incCameraDistance()
-{
-  float d=cameraPosition[2]+0.3;
+  {
+    float d=cameraPosition[2]+0.3;
 
-  d=std::min(d,20.0f);
-  cameraPosition=AGVector4(0,-d,d);
-  updateMatrices();
-}
+    d=std::min(d,20.0f);
+    cameraPosition=AGVector4(0,-d,d);
+    updateMatrices();
+  }
 void AntCamera::decCameraDistance()
-{
-  float d=cameraPosition[2]-0.3;
+  {
+    float d=cameraPosition[2]-0.3;
 
-  d=std::max(d,12.0f);
-  cameraPosition=AGVector4(0,-d,d);
-  updateMatrices();
-}
+    d=std::max(d,12.0f);
+    cameraPosition=AGVector4(0,-d,d);
+    updateMatrices();
+  }
 
 
 void AntCamera::updateMatrices()
-{
+  {
 
-  // 1. init camera view matrix
-  glMatrixMode(GL_MODELVIEW);
-  glLoadIdentity();
-  gluLookAt(cameraPosition[0]+scenePosition[0],cameraPosition[1]+scenePosition[1],cameraPosition[2]+scenePosition[2],
-	    scenePosition[0],scenePosition[1],scenePosition[2],
-	    0,0,1);
-  glGetFloatv(GL_MODELVIEW_MATRIX, cameraView);
-  
-  // 2. init camera projection matrix
-  
-  glMatrixMode(GL_PROJECTION);
-  glLoadIdentity();
-  gluPerspective(45.0f, ((float)mWidth)/mHeight, 3.0f, 63.0f);
-  glGetFloatv(GL_PROJECTION_MATRIX, cameraProjection);
-  glMatrixMode(GL_MODELVIEW);
-  if(mPSM)
-    {
-      // PSM
-      // calculation of lightposition is somehow crappy
+    // 1. init camera view matrix
+    glMatrixMode(GL_MODELVIEW);
+    glLoadIdentity();
+    gluLookAt(cameraPosition[0]+scenePosition[0],cameraPosition[1]+scenePosition[1],cameraPosition[2]+scenePosition[2],
+        scenePosition[0],scenePosition[1],scenePosition[2],
+        0,0,1);
+    glGetFloatv(GL_MODELVIEW_MATRIX, cameraView);
 
+    // 2. init camera projection matrix
 
-      // PSMs
-      //  lightPosition=AGVector4( -2.0, -3, 5.1,1)*100;
-      
-      // light View Matrix
-      glLoadIdentity();
-      
-      AGVector4 lp=lightPosition;
-      //    lp[
-      lp[3]=1;
-      lp=cameraProjection*cameraView*lp;
-      
-      lp/=lp[3];
-      
-      // it is something like (12,-10,10)
-      
-      
-      
-      
-      lp=AGVector4(-0.5,1.5,-0.5,1); // should be something like this 
-      lp*=100;
-      
-      
-      //lp=AGVector4(-2,2,-2,1);
-      gluLookAt(lp[0], lp[1], lp[2],
-		0,0,0,
-		0.0f, 1.0f, 0.0f);
-      glGetFloatv(GL_MODELVIEW_MATRIX, lightView);
-      
-      lightView=lightView*cameraProjection*cameraView;
-      // light projection Matrix
-      glLoadIdentity();
-      //    glOrtho(-10,10,-15,20,10,1000);
-      cdebug(lp.toString());
-      float s2=sqrt(2.0f);
-      float ldist=lp.length3();
-      
-      glOrtho(-s2,s2,-s2,s2,ldist-2*s2,ldist+10);//1,10);//ldist-2*s2,ldist+10*s2);
-      
-      
-      //very old:glOrtho(-1,2,-1.5,3,700,750);
-      //      glOrtho(-1,2,-1,1,2,8);
-      
-      glGetFloatv(GL_MODELVIEW_MATRIX, lightProjection);
-    }
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    gluPerspective(45.0f, ((float)mWidth)/mHeight, 3.0f, 63.0f);
+    glGetFloatv(GL_PROJECTION_MATRIX, cameraProjection);
+    glMatrixMode(GL_MODELVIEW);
+    if(mPSM)
+      {
+        // PSM
+        // calculation of lightposition is somehow crappy
 
-    {
-      //  lightPosition=AGVector4( -1.0, -3, 5.1,1);
-      
-      // calc light view,too
-      // light View Matrix
-      glLoadIdentity();
-      gluLookAt(lightPosition[0]+scenePosition[0], lightPosition[1]+scenePosition[1], lightPosition[2]+scenePosition[2],
-		scenePosition[0],scenePosition[1],scenePosition[2],
-		0.0f, 0.0f, 1.0f);
-      glGetFloatv(GL_MODELVIEW_MATRIX, lightView);
-      
-      
-      // light projection Matrix
-      glLoadIdentity();
-      
-	{
+
+        // PSMs
+        //  lightPosition=AGVector4( -2.0, -3, 5.1,1)*100;
+
+        // light View Matrix
+        glLoadIdentity();
+
+        AGVector4 lp=lightPosition;
+        //    lp[
+        lp[3]=1;
+        lp=cameraProjection*cameraView*lp;
+
+        lp/=lp[3];
+
+        // it is something like (12,-10,10)
+
+
+
+
+        lp=AGVector4(-0.5,1.5,-0.5,1); // should be something like this 
+        lp*=100;
+
+
+        //lp=AGVector4(-2,2,-2,1);
+        gluLookAt(lp[0], lp[1], lp[2],
+            0,0,0,
+            0.0f, 1.0f, 0.0f);
+        glGetFloatv(GL_MODELVIEW_MATRIX, lightView);
+
+        lightView=lightView*cameraProjection*cameraView;
+        // light projection Matrix
+        glLoadIdentity();
+        //    glOrtho(-10,10,-15,20,10,1000);
+        cdebug(lp.toString());
+        float s2=sqrt(2.0f);
+        float ldist=lp.length3();
+
+        glOrtho(-s2,s2,-s2,s2,ldist-2*s2,ldist+10);//1,10);//ldist-2*s2,ldist+10*s2);
+
+
+        //very old:glOrtho(-1,2,-1.5,3,700,750);
+        //      glOrtho(-1,2,-1,1,2,8);
+
+        glGetFloatv(GL_MODELVIEW_MATRIX, lightProjection);
+      }
+
+      {
+        //  lightPosition=AGVector4( -1.0, -3, 5.1,1);
+
+        // calc light view,too
+        // light View Matrix
+        glLoadIdentity();
+        gluLookAt(lightPosition[0]+scenePosition[0], lightPosition[1]+scenePosition[1], lightPosition[2]+scenePosition[2],
+            scenePosition[0],scenePosition[1],scenePosition[2],
+            0.0f, 0.0f, 1.0f);
+        glGetFloatv(GL_MODELVIEW_MATRIX, lightView);
+
+
+        // light projection Matrix
+        glLoadIdentity();
+
+          {
 #warning "add some decent calculation here"
-	  // use getFrustum for estimating a good light-frustum
+            // use getFrustum for estimating a good light-frustum
 
-	  float near0=20,near1=60;
-	  float far0=20,far1=110;
+            float near0=20,near1=60;
+            float far0=20,far1=110;
 
-	  float mnear=sqrt(near0*near0+near1*near1);
-	  float mfar=sqrt(far0*far0+far1*far1);
-	  
-	  float left=-25;
-	  float right=14;
-	  float bottom=-15;
-	  float top=14;
+            float mnear=sqrt(near0*near0+near1*near1);
+            float mfar=sqrt(far0*far0+far1*far1);
 
-	  if(getRenderer()->badShadowMap())
-	    top=bottom+(top-bottom)*1024.0f/768.0f;
+            float left=-25;
+            float right=14;
+            float bottom=-15;
+            float top=14;
 
-	  glFrustum(left, right, bottom, top,
-		    mnear,mfar);
+            if(getRenderer()->badShadowMap())
+              top=bottom+(top-bottom)*1024.0f/768.0f;
 
-	}
-      
-      glGetFloatv(GL_MODELVIEW_MATRIX, lightProjection);
-    }
+            glFrustum(left, right, bottom, top,
+                mnear,mfar);
 
-    // viewport
-  glMatrixMode(GL_MODELVIEW);
-    
-}
+          }
 
+          glGetFloatv(GL_MODELVIEW_MATRIX, lightProjection);
+      }
 
+      // viewport
+      glMatrixMode(GL_MODELVIEW);
+
+  }
+
+
 Viewport AntCamera::getViewport() const
 {
   Viewport p;
@@ -194,10 +193,10 @@
 }
 
 void AntCamera::setPosition(const AGVector3 &p)
-{
-  scenePosition=AGVector4(p,1);
-  updateMatrices();
-}
+  {
+    scenePosition=AGVector4(p,1);
+    updateMatrices();
+  }
 
 AGVector4 AntCamera::getCameraPosition() const
 {
@@ -231,9 +230,9 @@
 AGMatrix4 AntCamera::getLightComplete() const
 {
   float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
-		0.0f, 0.5f, 0.0f, 0.0f,
-		0.0f, 0.0f, 0.5f, 0.0f,
-		0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
+      0.0f, 0.5f, 0.0f, 0.0f,
+      0.0f, 0.0f, 0.5f, 0.0f,
+      0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
   static AGMatrix4 biasMatrix(bias);
   return biasMatrix*lightProjection*lightView;
 }
@@ -257,12 +256,12 @@
 }
 
 void AntCamera::setWidth(int w)
-{
-  mWidth=w;
-  updateMatrices();
-}
+  {
+    mWidth=w;
+    updateMatrices();
+  }
 void AntCamera::setHeight(int h)
-{
-  mHeight=h;
-  updateMatrices();
-}
+  {
+    mHeight=h;
+    updateMatrices();
+  }

Modified: antargis/trunk/ext/3dengine/ant_particle.cc
===================================================================
--- antargis/trunk/ext/3dengine/ant_particle.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/ant_particle.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -13,190 +13,190 @@
 
 // small caching fct, so that lookup is not that long???
 bool particleEnabled()
-{
-  long ts=getMain()->getTicks();
-  if(getMain()->getTicks()-lastParticleTest>1000)
-    {
-      gParticle=getConfig()->get("particleEffects")!="false";
-      lastParticleTest=ts;
-      getConfig()->set("particleEffects",gParticle?"true":"false");
-    }
+  {
+    long ts=getMain()->getTicks();
+    if(getMain()->getTicks()-lastParticleTest>1000)
+      {
+        gParticle=getConfig()->get("particleEffects")!="false";
+        lastParticleTest=ts;
+        getConfig()->set("particleEffects",gParticle?"true":"false");
+      }
 
-  return gParticle;
-}
+    return gParticle;
+  }
 
 float randf()
-{
-  return (rand()%10000)/10000.0;
-}
+  {
+    return (rand()%10000)/10000.0;
+  }
 
 AntParticle::AntParticle(Scene *pScene,float f):
   SceneNode(pScene,AGVector4(),AGBox3(AGVector3(-0.5,-0.5,0),AGVector3(1,1,10)))
-{
-  maxtime=20;
+  {
+    maxtime=20;
 
-  mtime=0;
-  freq=f;
-  stime=1/freq;
-  if(videoInited())
-    mTexture=getTextureCache()->get("data/textures/point.png");
-  fire=false;
-  setOrder(PARTICLE_Z);
-  enabled=true;
-}
+    mtime=0;
+    freq=f;
+    stime=1/freq;
+    if(videoInited())
+      mTexture=getTextureCache()->get("data/textures/point.png");
+    fire=false;
+    setOrder(PARTICLE_Z);
+    enabled=true;
+  }
 
 AntParticle::~AntParticle()
-{
-  for(std::list<Piece*>::iterator i=mPieces.begin();i!=mPieces.end();i++)
-    delete *i;
-  mPieces.clear();
+  {
+    for(std::list<Piece*>::iterator i=mPieces.begin();i!=mPieces.end();i++)
+      delete *i;
+    mPieces.clear();
 
-}
+  }
 
 void AntParticle::setFire(bool f)
-{
-  fire=f;
-}
+  {
+    fire=f;
+  }
 
 void AntParticle::setMaxTime(float m)
-{
-  maxtime=m;
-}
+  {
+    maxtime=m;
+  }
 
 void AntParticle::advance(float time)
-{
-  STACKTRACE;
-  if(!particleEnabled())
-    return;
-  //  return;
-  // advance pieces
-  for(std::list<Piece*>::iterator i=mPieces.begin();i!=mPieces.end();i++)
-    {
-      (*i)->lived+=time;
-      // move
-      (*i)->pos+=(*i)->speed*time;
-    }
-  // delete old pieces
-  while(mPieces.size())
-    {
-      if(mPieces.back()->lived>maxtime)
-	{
-	  delete mPieces.back();
-	  mPieces.pop_back();
-	}
-      else
-	break;
-    }
+  {
+    STACKTRACE;
+    if(!particleEnabled())
+      return;
+    //  return;
+    // advance pieces
+    for(std::list<Piece*>::iterator i=mPieces.begin();i!=mPieces.end();i++)
+      {
+        (*i)->lived+=time;
+        // move
+        (*i)->pos+=(*i)->speed*time;
+      }
+    // delete old pieces
+    while(mPieces.size())
+      {
+        if(mPieces.back()->lived>maxtime)
+          {
+            delete mPieces.back();
+            mPieces.pop_back();
+          }
+        else
+          break;
+      }
 
-  if(!enabled)
-    return;
+    if(!enabled)
+      return;
 
-  // create new piece
-  mtime+=time;
+    // create new piece
+    mtime+=time;
 
-  float timevar=1;
+    float timevar=1;
 
-  if(mtime>stime)
-    {
-      Piece *ps=new Piece;
+    if(mtime>stime)
+      {
+        Piece *ps=new Piece;
 
-      if(fire)
-	{
-	  ps->pos=getPos().dim3();
-	  ps->lived=-timevar*randf();
-	  ps->light=randf()*0.8+0.2;//5+0.5;
-	  ps->size=randf()*0.05+0.1;
-	  ps->speed=AGVector3(randf()*0.4-0.2,0,1+randf()*0.5);
-	  ps->color=AGVector3(1,1,0);
-	}
-      else
-	{
-	  ps->pos=getPos().dim3();
-	  ps->lived=-timevar*randf();
-	  ps->light=randf()*0.2+0.2;//5+0.5;
-	  ps->size=randf()*0.1+0.2;
-	  ps->speed=AGVector3(randf()*0.01,0,0.2+randf()*0.1);
-	  ps->color=AGVector3(1,1,1);
-	}
-      mPieces.push_front(ps);
-      mtime-=stime;
-	  
-    }
-}
+        if(fire)
+          {
+            ps->pos=getPos().dim3();
+            ps->lived=-timevar*randf();
+            ps->light=randf()*0.8+0.2;//5+0.5;
+            ps->size=randf()*0.05+0.1;
+            ps->speed=AGVector3(randf()*0.4-0.2,0,1+randf()*0.5);
+            ps->color=AGVector3(1,1,0);
+          }
+        else
+          {
+            ps->pos=getPos().dim3();
+            ps->lived=-timevar*randf();
+            ps->light=randf()*0.2+0.2;//5+0.5;
+            ps->size=randf()*0.1+0.2;
+            ps->speed=AGVector3(randf()*0.01,0,0.2+randf()*0.1);
+            ps->color=AGVector3(1,1,1);
+          }
+        mPieces.push_front(ps);
+        mtime-=stime;
 
+      }
+  }
+
 void AntParticle::draw()
-{
-  STACKTRACE;
+  {
+    STACKTRACE;
 
-  if(!particleEnabled())
-    return;
+    if(!particleEnabled())
+      return;
 
-  AGVector3 dir=getRenderer()->getCurrentScene()->getCameraDirTo(getPos().dim3());
+    AGVector3 dir=getRenderer()->getCurrentScene()->getCameraDirTo(getPos().dim3());
 
-  AGVector3 pdown(0,0,-1);
-  AGVector3 side=dir%pdown;
-  AGVector3 up=side%dir;
+    AGVector3 pdown(0,0,-1);
+    AGVector3 side=dir%pdown;
+    AGVector3 up=side%dir;
 
-  side.normalize();
-  up.normalize();
+    side.normalize();
+    up.normalize();
 
-  AGRenderContext c;
-  c.setAlpha(0,GL_NONE);
-  c.setDepthWrite(false);
-  c.setTexture(mTexture.glTexture());
-  c.setColor(AGVector4(1,1,1,1));
-  c.begin();
+    AGRenderContext c;
+    c.setAlpha(0,GL_NONE);
+    c.setDepthWrite(false);
+    c.setTexture(mTexture.glTexture());
+    c.setColor(AGVector4(1,1,1,1));
+    c.begin();
 
-  glBegin(GL_QUADS);
+    glBegin(GL_QUADS);
 
-  float a,s,l;
-  AGVector4 color;
+    float a,s,l;
+    AGVector4 color;
 
-  for(std::list<Piece*>::iterator i=mPieces.begin();i!=mPieces.end();i++)
-    {
-      a=1;
-      if(!fire)
-	if((*i)->lived<1)
-	  a=(*i)->lived;
-      
-      a=std::min(maxtime-(*i)->lived,a);
+    for(std::list<Piece*>::iterator i=mPieces.begin();i!=mPieces.end();i++)
+      {
+        a=1;
+        if(!fire)
+          if((*i)->lived<1)
+            a=(*i)->lived;
 
-      l=(*i)->light;
-      s=(*i)->size;
-      color=AGVector4((*i)->color[0]*l,(*i)->color[1]*l,(*i)->color[2]*l,a);
-      if(fire)
-	{
-	  float x=maxtime/(*i)->lived;
-	  x=std::max(std::min(x,1.0f),0.0f);
-	  (*i)->color=AGVector3(1,0,0)*x+AGVector3(1,1,0)*(1-x);
-	}
-      else
-	{
-	  if((*i)->lived<3)
-	    s*=(*i)->lived/3;
-	}
-      glColor4fv(color);
-      glTexCoord2f(0,0);
-      glVertex3fv((*i)->pos+(AGVector3(0,0,0)-side+up)*s);
+        a=std::min(maxtime-(*i)->lived,a);
 
-      glColor4fv(color);
-      glTexCoord2f(1,0);
-      glVertex3fv((*i)->pos+(side+up)*s);
+        l=(*i)->light;
+        s=(*i)->size;
+        color=AGVector4((*i)->color[0]*l,(*i)->color[1]*l,(*i)->color[2]*l,a);
+        if(fire)
+          {
+            float x=maxtime/(*i)->lived;
+            x=std::max(std::min(x,1.0f),0.0f);
+            (*i)->color=AGVector3(1,0,0)*x+AGVector3(1,1,0)*(1-x);
+          }
+        else
+          {
+            if((*i)->lived<3)
+              s*=(*i)->lived/3;
+          }
+        glColor4fv(color);
+        glTexCoord2f(0,0);
+        glVertex3fv((*i)->pos+(AGVector3(0,0,0)-side+up)*s);
 
-      glColor4fv(color);
-      glTexCoord2f(1,1);
-      glVertex3fv((*i)->pos+(side-up)*s);
-      
-      glColor4fv(color);
-      glTexCoord2f(0,1);
-      glVertex3fv((*i)->pos+(AGVector3(0,0,0)-side-up)*s);
+        glColor4fv(color);
+        glTexCoord2f(1,0);
+        glVertex3fv((*i)->pos+(side+up)*s);
 
-    }
-  glEnd();
-  
-}
+        glColor4fv(color);
+        glTexCoord2f(1,1);
+        glVertex3fv((*i)->pos+(side-up)*s);
 
+        glColor4fv(color);
+        glTexCoord2f(0,1);
+        glVertex3fv((*i)->pos+(AGVector3(0,0,0)-side-up)*s);
+
+      }
+    glEnd();
+
+  }
+
 void AntParticle::setEnabled(bool f)
-{
-  enabled=f;
-}
+  {
+    enabled=f;
+  }

Modified: antargis/trunk/ext/3dengine/ant_renderer.cc
===================================================================
--- antargis/trunk/ext/3dengine/ant_renderer.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/ant_renderer.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -13,23 +13,23 @@
   mCanMultitexture(-1),
   mCanShadow(-1),
   mCanGLSL(-1)
-{
-  mFBO=0;
-  CTRACE;
-  GLeeInit(); // this call is essential for letting glee work
-  assert(gRenderer==0);
-  gRenderer=this;
-  mScene=0;
-  
-  AGString shadowType=getConfig()->get("shadowType");
-  if(shadowType=="big" || shadowType=="")
-    shadowMapSize=1024;
-  else if(shadowType=="small")
-    shadowMapSize=512;
-  else
-    shadowMapSize=0;
+  {
+    mFBO=0;
+    CTRACE;
+    GLeeInit(); // this call is essential for letting glee work
+    assert(gRenderer==0);
+    gRenderer=this;
+    mScene=0;
 
-  switch(shadowMapSize)
+    AGString shadowType=getConfig()->get("shadowType");
+    if(shadowType=="big" || shadowType=="")
+      shadowMapSize=1024;
+    else if(shadowType=="small")
+      shadowMapSize=512;
+    else
+      shadowMapSize=0;
+
+    switch(shadowMapSize)
     {
     case 0:
       getConfig()->set("shadowType","none");break;
@@ -38,332 +38,332 @@
     case 1024:
       getConfig()->set("shadowType","big");break;
     }
-  
 
-  shadowInited=false;
 
-  if(!GLEE_EXT_texture3D)
-    std::cerr<<"Sorry, Battles of Antargis won't work properly without GL_EXT_texture3D extension!"<<std::endl;
-}
+    shadowInited=false;
 
+    if(!GLEE_EXT_texture3D)
+      std::cerr<<"Sorry, Battles of Antargis won't work properly without GL_EXT_texture3D extension!"<<std::endl;
+  }
+
 Renderer::~Renderer()
-{
-  cdebug("gRenderer:"<<gRenderer);
-  assert(gRenderer==this);
-  gRenderer=0;
-  delete mFBO;
-}
+  {
+    cdebug("gRenderer:"<<gRenderer);
+    assert(gRenderer==this);
+    gRenderer=0;
+    delete mFBO;
+  }
 
 bool Renderer::canMultitexture()
-{
-  if(mCanMultitexture<0)
-    mCanMultitexture=GLEE_ARB_multitexture;
-  return mCanMultitexture;
-}
+  {
+    if(mCanMultitexture<0)
+      mCanMultitexture=GLEE_ARB_multitexture;
+    return mCanMultitexture;
+  }
 
 bool Renderer::canShadow()
-{
-  if(mCanShadow<0)
-    mCanShadow=(GLEE_ARB_shadow && GLEE_ARB_shadow_ambient);
-  return mCanShadow && shadowMapSize>0;
-}
+  {
+    if(mCanShadow<0)
+      mCanShadow=(GLEE_ARB_shadow && GLEE_ARB_shadow_ambient);
+    return mCanShadow && shadowMapSize>0;
+  }
 
 bool Renderer::canGLSL()
-{
-  if(mCanGLSL<0)
-    mCanGLSL=(GLEE_ARB_vertex_shader && GLEE_ARB_fragment_shader && GLEE_ARB_shading_language_100);
-  return mCanGLSL;
-}
+  {
+    if(mCanGLSL<0)
+      mCanGLSL=(GLEE_ARB_vertex_shader && GLEE_ARB_fragment_shader && GLEE_ARB_shading_language_100);
+    return mCanGLSL;
+  }
 
 void Renderer::setCurrentScene(Scene *scene)
-{
-  mScene=scene;
-}
+  {
+    mScene=scene;
+  }
 
 Scene *Renderer::getCurrentScene()
-{
-  assert(mScene);
-  return mScene;
-}
+  {
+    assert(mScene);
+    return mScene;
+  }
 
 GLint Renderer::getShadowUnit()
-{
-  assert(canMultitexture());
-  return 3;
-}
+  {
+    assert(canMultitexture());
+    return 3;
+  }
 GLint Renderer::getNormalUnit()
-{
-  if(canMultitexture())
-    return 0;
-  else
-    return 0;
-}
+  {
+    if(canMultitexture())
+      return 0;
+    else
+      return 0;
+  }
 
 void Renderer::initShadowTexture()
-{
-  if(!canShadow())
-    return;
+  {
+    if(!canShadow())
+      return;
 
-  if(shadowInited)
-    return;
+    if(shadowInited)
+      return;
 
-  CTRACE;
-  glGenTextures(1, &shadowMapTexture);
-  glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
-  //  glTexImage2D(   GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, shadowMapSize, shadowMapSize, 0,
-  //		  GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, NULL);
-  glTexImage2D(   GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT16, shadowMapSize, shadowMapSize, 0,
-		  GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, NULL);
-  assertGL;
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //NEAREST);
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); //NEAREST);
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-  
-  glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
+    CTRACE;
+    glGenTextures(1, &shadowMapTexture);
+    glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
+    //  glTexImage2D(   GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, shadowMapSize, shadowMapSize, 0,
+    //  GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, NULL);
+    glTexImage2D(   GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT16, shadowMapSize, shadowMapSize, 0,
+        GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, NULL);
+    assertGL;
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); //NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
 
-  shadowInited=true;
+    glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
 
-  if(canFBO())
-    {
-      mFBO=new AGFBO(shadowMapTexture,shadowMapSize,shadowMapSize);//,true);
-    }
+    shadowInited=true;
 
-}
+    if(canFBO())
+      {
+        mFBO=new AGFBO(shadowMapTexture,shadowMapSize,shadowMapSize);//,true);
+      }
 
+  }
+
 void Renderer::beginShadowComputation()
-{
-  if(!shadowInited)
-    initShadowTexture();
+  {
+    if(!shadowInited)
+      initShadowTexture();
 
-  if(mFBO)
-    {
-      mFBO->beginDraw();
-    }
+    if(mFBO)
+      {
+        mFBO->beginDraw();
+      }
 
-  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  assertGL;
-  
-  
-  glMatrixMode(GL_PROJECTION);
-  glLoadMatrixf(getCurrentScene()->getLightProj());
-  
-  glMatrixMode(GL_MODELVIEW);
-  glLoadMatrixf(getCurrentScene()->getLightView());
-  
-  //Use viewport the same size as the shadow map
-  glViewport(0, 0, shadowMapSize, shadowMapSize);
-  
-  //Draw back faces into the shadow map
-  glCullFace(GL_FRONT);
-  glEnable(GL_CULL_FACE);
-  
-  //Disable color writes, and use flat shading for speed
-  glShadeModel(GL_FLAT);
-  glColorMask(0, 0, 0, 0);
-  
-  //Draw the scene
-  // Offset the drawing a little back, so that slopy surfaces don't get shadowed
-  glEnable(GL_POLYGON_OFFSET_FILL);
-  glPolygonOffset(1,1); // was 1,1
+    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+    assertGL;
 
-  assertGL;
 
-}
+    glMatrixMode(GL_PROJECTION);
+    glLoadMatrixf(getCurrentScene()->getLightProj());
+
+    glMatrixMode(GL_MODELVIEW);
+    glLoadMatrixf(getCurrentScene()->getLightView());
+
+    //Use viewport the same size as the shadow map
+    glViewport(0, 0, shadowMapSize, shadowMapSize);
+
+    //Draw back faces into the shadow map
+    glCullFace(GL_FRONT);
+    glEnable(GL_CULL_FACE);
+
+    //Disable color writes, and use flat shading for speed
+    glShadeModel(GL_FLAT);
+    glColorMask(0, 0, 0, 0);
+
+    //Draw the scene
+    // Offset the drawing a little back, so that slopy surfaces don't get shadowed
+    glEnable(GL_POLYGON_OFFSET_FILL);
+    glPolygonOffset(1,1); // was 1,1
+
+    assertGL;
+
+  }
 void Renderer::endShadowComputation()
-{
-  glDisable(GL_POLYGON_OFFSET_FILL);
-  assertGL;
-  //Read the depth buffer into the shadow map texture
-  glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
-  assertGL;
+  {
+    glDisable(GL_POLYGON_OFFSET_FILL);
+    assertGL;
+    //Read the depth buffer into the shadow map texture
+    glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
+    assertGL;
 
-  /// @todo switch to FBOs - this should bring an improvement of 17 to 19 fps
+    /// @todo switch to FBOs - this should bring an improvement of 17 to 19 fps
 
     if(mFBO)
       {
-	mFBO->endDraw();
+        mFBO->endDraw();
       }
     else
       {
-	glReadBuffer(GL_BACK);
-	
-	glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, 0, 0, shadowMapSize, shadowMapSize,0);
-	
-	glReadBuffer(GL_FRONT);
+        glReadBuffer(GL_BACK);
+
+        glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, 0, 0, shadowMapSize, shadowMapSize,0);
+
+        glReadBuffer(GL_FRONT);
       }
 
-  assertGL;
+    assertGL;
 
 
-  //restore states
-  assertGL;
-  glCullFace(GL_BACK);
-  
-  glShadeModel(GL_SMOOTH);
-  glColorMask(1, 1, 1, 1);
-}
+    //restore states
+    assertGL;
+    glCullFace(GL_BACK);
 
+    glShadeModel(GL_SMOOTH);
+    glColorMask(1, 1, 1, 1);
+  }
 
+
 void Renderer::beginShadowDrawing()
-{
-  glActiveTexture(getShadowUnit());
+  {
+    glActiveTexture(getShadowUnit());
 
-  glMatrixMode(GL_MODELVIEW);
-  // draw a flat shadow over 
-  //  glDisable(GL_LIGHTING);
-  //  glEnable(GL_COLOR_MATERIAL);
-  assertGL;
-  
+    glMatrixMode(GL_MODELVIEW);
+    // draw a flat shadow over 
+    //  glDisable(GL_LIGHTING);
+    //  glEnable(GL_COLOR_MATERIAL);
+    assertGL;
 
-  if(usePlainGL)
-    {
-      //Calculate texture matrix for projection
-      //This matrix takes us from eye space to the light's clip space
-      //It is postmultiplied by the inverse of the current view matrix when specifying texgen
-      float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
-		    0.0f, 0.5f, 0.0f, 0.0f,
-		    0.0f, 0.0f, 0.5f, 0.0f,
-		    0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
-      static AGMatrix4 biasMatrix(bias);
-      AGMatrix4 textureMatrix=biasMatrix * getCurrentScene()->getLightProj() * getCurrentScene()->getLightView();
-      
-      //Set up texture coordinate generation.
-      glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
-      assertGL;
-      glTexGenfv(GL_S, GL_EYE_PLANE, textureMatrix.getRow(0));
-      assertGL;
-      glEnable(GL_TEXTURE_GEN_S);
-      assertGL;
-      
-      glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
-      assertGL;
-      glTexGenfv(GL_T, GL_EYE_PLANE, textureMatrix.getRow(1));
-      assertGL;
-      glEnable(GL_TEXTURE_GEN_T);
-      assertGL;
-      
-      glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
-      assertGL;
-      glTexGenfv(GL_R, GL_EYE_PLANE, textureMatrix.getRow(2));
-      assertGL;
-      glEnable(GL_TEXTURE_GEN_R);
-      
-      assertGL;
-      glTexGeni(GL_Q, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
-      assertGL;
-      glTexGenfv(GL_Q, GL_EYE_PLANE, textureMatrix.getRow(3));
-      assertGL;
-      glEnable(GL_TEXTURE_GEN_Q);
-      assertGL;
-    }
-  
-  //Bind & enable shadow map texture
-  glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
-  glEnable(GL_TEXTURE_2D);
-  
-  //Enable shadow comparison
-  assertGL;
 
-  if(usePlainGL)
-    {
-            
+    if(usePlainGL)
+      {
+        //Calculate texture matrix for projection
+        //This matrix takes us from eye space to the light's clip space
+        //It is postmultiplied by the inverse of the current view matrix when specifying texgen
+        float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
+            0.0f, 0.5f, 0.0f, 0.0f,
+            0.0f, 0.0f, 0.5f, 0.0f,
+            0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
+        static AGMatrix4 biasMatrix(bias);
+        AGMatrix4 textureMatrix=biasMatrix * getCurrentScene()->getLightProj() * getCurrentScene()->getLightView();
+
+        //Set up texture coordinate generation.
+        glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+        assertGL;
+        glTexGenfv(GL_S, GL_EYE_PLANE, textureMatrix.getRow(0));
+        assertGL;
+        glEnable(GL_TEXTURE_GEN_S);
+        assertGL;
+
+        glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+        assertGL;
+        glTexGenfv(GL_T, GL_EYE_PLANE, textureMatrix.getRow(1));
+        assertGL;
+        glEnable(GL_TEXTURE_GEN_T);
+        assertGL;
+
+        glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+        assertGL;
+        glTexGenfv(GL_R, GL_EYE_PLANE, textureMatrix.getRow(2));
+        assertGL;
+        glEnable(GL_TEXTURE_GEN_R);
+
+        assertGL;
+        glTexGeni(GL_Q, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+        assertGL;
+        glTexGenfv(GL_Q, GL_EYE_PLANE, textureMatrix.getRow(3));
+        assertGL;
+        glEnable(GL_TEXTURE_GEN_Q);
+        assertGL;
+      }
+
+    //Bind & enable shadow map texture
+    glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
+    glEnable(GL_TEXTURE_2D);
+
+    //Enable shadow comparison
+    assertGL;
+
+    if(usePlainGL)
+      {
+
 #ifndef OLD_SHADOW
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE);
-      assertGL;
-      //Shadow comparison should be true (ie not in shadow) if r<=texture
-      //        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL);
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL); // not needed ???
-      assertGL;
-      
-      //Shadow comparison should generate an INTENSITY result
-      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
-      assertGL;
-      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE);//INTENSITY);
-      assertGL;
-      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 1.0f-0.3f);//shadowAlpha);
-      assertGL;
-      //      glColor4f(0,0,0,0.3);
-      assertGL;
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE);
+        assertGL;
+        //Shadow comparison should be true (ie not in shadow) if r<=texture
+        //        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL); // not needed ???
+        assertGL;
 
-      //      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+        //Shadow comparison should generate an INTENSITY result
+        glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
+        assertGL;
+        glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE);//INTENSITY);
+        assertGL;
+        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 1.0f-0.3f);//shadowAlpha);
+        assertGL;
+        //      glColor4f(0,0,0,0.3);
+        assertGL;
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 
+        //      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+
 #else
-      glEnable(GL_TEXTURE_2D);
-      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE, GL_INTENSITY);  //set this to a "depth texture"
-      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 0.5f);      //set the compare fail value
+        glEnable(GL_TEXTURE_2D);
+        glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE, GL_INTENSITY);  //set this to a "depth texture"
+        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 0.5f);      //set the compare fail value
 
-      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-      
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE_ARB);
+        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
 
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE_ARB);
 
 
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL); // not needed ???
-      assertGL;
-      
-      //Shadow comparison should generate an INTENSITY result
-      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
-      assertGL;
-      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE);//INTENSITY);
 
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL); // not needed ???
+        assertGL;
 
+        //Shadow comparison should generate an INTENSITY result
+        glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
+        assertGL;
+        glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE);//INTENSITY);
 
+
+
         // Set up the eye plane for projecting the shadow map on the scene
 
 #endif
-      //Set alpha test to discard false comparisons
-      //  glAlphaFunc(GL_GREATER,0.99f);//LEQUAL, 0.999f);
-      //      glAlphaFunc(GL_GEQUAL, 0.99f);
-      //      glDisable(GL_ALPHA_TEST);
+        //Set alpha test to discard false comparisons
+        //  glAlphaFunc(GL_GREATER,0.99f);//LEQUAL, 0.999f);
+        //      glAlphaFunc(GL_GEQUAL, 0.99f);
+        //      glDisable(GL_ALPHA_TEST);
 
-      
-    }
 
-  glActiveTexture(getNormalUnit());
-  assertGL;
+      }
 
-}
+    glActiveTexture(getNormalUnit());
+    assertGL;
+
+  }
 void Renderer::endShadowDrawing()
-{
-  assertGL;
+  {
+    assertGL;
 
-  glDisable(GL_POLYGON_OFFSET_FILL);
+    glDisable(GL_POLYGON_OFFSET_FILL);
 
-  glActiveTexture(getShadowUnit());
-  glBindTexture(GL_TEXTURE_2D,0);
+    glActiveTexture(getShadowUnit());
+    glBindTexture(GL_TEXTURE_2D,0);
 
-  if(usePlainGL)
-    {
-      glDisable(GL_ALPHA_TEST);
-      glDisable(GL_TEXTURE_GEN_S);
-      glDisable(GL_TEXTURE_GEN_T);
-      glDisable(GL_TEXTURE_GEN_R);
-      glDisable(GL_TEXTURE_GEN_Q);
-    }
-  glActiveTexture(getNormalUnit());
-  assertGL;
+    if(usePlainGL)
+      {
+        glDisable(GL_ALPHA_TEST);
+        glDisable(GL_TEXTURE_GEN_S);
+        glDisable(GL_TEXTURE_GEN_T);
+        glDisable(GL_TEXTURE_GEN_R);
+        glDisable(GL_TEXTURE_GEN_Q);
+      }
+    glActiveTexture(getNormalUnit());
+    assertGL;
 
-}
+  }
 
 
 bool Renderer::badShadowMap()
-{
-  return shadowMapSize==1024;
-}
+  {
+    return shadowMapSize==1024;
+  }
 
 
 Renderer *getRenderer()
-{
-  if(!gRenderer)
-    {
-      gRenderer=new Renderer;
-      REGISTER_SINGLETON(gRenderer);
-    }
-  assert(gRenderer);
-  return gRenderer;
-}
+  {
+    if(!gRenderer)
+      {
+        gRenderer=new Renderer;
+        REGISTER_SINGLETON(gRenderer);
+      }
+    assert(gRenderer);
+    return gRenderer;
+  }

Modified: antargis/trunk/ext/3dengine/glsl.cc
===================================================================
--- antargis/trunk/ext/3dengine/glsl.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/glsl.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -31,7 +31,7 @@
     }
   return i->second;
 }
-*/
+ */
 
 bool glslOk();
 
@@ -40,58 +40,58 @@
 
 
 AntVertexProgram::AntVertexProgram(const std::string &pFile)
-{
-  //  CTRACE;
-  if(glslOk())
-    {
-      vertexShader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
-      std::string s=loadFile(pFile);
-      
-      const char*a=s.c_str();
-      const GLcharARB**x=&a;
-      glShaderSourceARB(vertexShader, 1, x,NULL);
-      glCompileShaderARB(vertexShader);
-      printInfoLog(vertexShader);
-      
-    }
-}
+  {
+    //  CTRACE;
+    if(glslOk())
+      {
+        vertexShader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
+        std::string s=loadFile(pFile);
 
+        const char*a=s.c_str();
+        const GLcharARB**x=&a;
+        glShaderSourceARB(vertexShader, 1, x,NULL);
+        glCompileShaderARB(vertexShader);
+        printInfoLog(vertexShader);
+
+      }
+  }
+
 AntVertexProgram::~AntVertexProgram()
-{
-  CTRACE;
-  if(glslOk() && !hasQuit())
-    glDeleteObjectARB(vertexShader);
-}
+  {
+    CTRACE;
+    if(glslOk() && !hasQuit())
+      glDeleteObjectARB(vertexShader);
+  }
 
 AntFragProgram::AntFragProgram(const std::string &pFile)
-{
-  mValid=false;
-  //  CTRACE;
-  if(glslOk() && pFile.length()>0)
-    {
-      fragShader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
-      std::string s=loadFile(pFile);
-      const char*a=s.c_str();
-      const GLcharARB**x=&a;
-      glShaderSourceARB(fragShader, 1, x,NULL);
-      glCompileShaderARB(fragShader);
-      printInfoLog(fragShader);
-      mValid=true;
-      
-    }
-}
+  {
+    mValid=false;
+    //  CTRACE;
+    if(glslOk() && pFile.length()>0)
+      {
+        fragShader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
+        std::string s=loadFile(pFile);
+        const char*a=s.c_str();
+        const GLcharARB**x=&a;
+        glShaderSourceARB(fragShader, 1, x,NULL);
+        glCompileShaderARB(fragShader);
+        printInfoLog(fragShader);
+        mValid=true;
 
+      }
+  }
+
 AntFragProgram::AntFragProgram()
-{
-  mValid=false;
-}
+  {
+    mValid=false;
+  }
 
 AntFragProgram::~AntFragProgram()
-{
-  CTRACE;
-  if(glslOk() && !hasQuit())
-    glDeleteObjectARB(fragShader);
-}
+  {
+    CTRACE;
+    if(glslOk() && !hasQuit())
+      glDeleteObjectARB(fragShader);
+  }
 
 
 bool AntFragProgram::valid() const
@@ -104,184 +104,184 @@
   //  vertex(getVertexProgram(pVertexFile)),frag(getFragProgram(pFragFile))
   mVertexFile(pVertexFile),mFragFile(pFragFile),
   vertex(0),frag(0)
-{
-  //  CTRACE;
-  on=false;
-  matrixBuf=new float[16*100];
-  name=pVertexFile+":"+pFragFile;
+  {
+    //  CTRACE;
+    on=false;
+    matrixBuf=new float[16*100];
+    name=pVertexFile+":"+pFragFile;
 
-  init();
-}
+    init();
+  }
 
 AntShaderProgram::~AntShaderProgram()
-{
-  takeDown();
+  {
+    takeDown();
 
-  delete [] matrixBuf;
-}
+    delete [] matrixBuf;
+  }
 
 void AntShaderProgram::onScreenUp()
-{
-  CTRACE;
-  init();
-}
+  {
+    CTRACE;
+    init();
+  }
 void AntShaderProgram::onScreenDown()
-{
-  CTRACE;
-  takeDown();
-}
+  {
+    CTRACE;
+    takeDown();
+  }
 
 
 void AntShaderProgram::init()
-{
- if(glslOk())
-    {
-	  locations.clear();
-	  attrs.clear();
-      vertex=new AntVertexProgram(mVertexFile);
-      frag=new AntFragProgram(mFragFile);
+  {
+    if(glslOk())
+      {
+        locations.clear();
+        attrs.clear();
+        vertex=new AntVertexProgram(mVertexFile);
+        frag=new AntFragProgram(mFragFile);
 
-      p = glCreateProgramObjectARB();
-      glAttachObjectARB(p,vertex->vertexShader);
-      if(frag->valid())
-	glAttachObjectARB(p,frag->fragShader);
-      
-      glLinkProgramARB(p);
-      printInfoLog(p);
+        p = glCreateProgramObjectARB();
+        glAttachObjectARB(p,vertex->vertexShader);
+        if(frag->valid())
+          glAttachObjectARB(p,frag->fragShader);
 
-      assert(p);
-    }
-}
+        glLinkProgramARB(p);
+        printInfoLog(p);
 
+        assert(p);
+      }
+  }
+
 void AntShaderProgram::takeDown()
-{
-  disable();
-  CTRACE;
-  //  cdebug("name:"<<name);
-  if(glslOk() && !hasQuit())
-    glDeleteObjectARB(p);
-  //  cdebug("name:"<<name);
-  delete vertex;
-  delete frag;
-  locations.clear();
-}
+  {
+    disable();
+    CTRACE;
+    //  cdebug("name:"<<name);
+    if(glslOk() && !hasQuit())
+      glDeleteObjectARB(p);
+    //  cdebug("name:"<<name);
+    delete vertex;
+    delete frag;
+    locations.clear();
+  }
 
 
 
 void AntShaderProgram::enable()
-{
-  if(glslOk())
-    {
-      glUseProgramObjectARB(p);
-      on=true;
-    }
-}
+  {
+    if(glslOk())
+      {
+        glUseProgramObjectARB(p);
+        on=true;
+      }
+  }
 void AntShaderProgram::disable()
-{
-  if(glslOk())
-    {
-      glUseProgramObjectARB(0);
-      on=false;
-    }
-}
+  {
+    if(glslOk())
+      {
+        glUseProgramObjectARB(0);
+        on=false;
+      }
+  }
 
 void AntShaderProgram::update(float time)
-{
-  if(glslOk())
-    {
-      enable();
-      doUpdate(time);
-      disable();
-    }
-}
+  {
+    if(glslOk())
+      {
+        enable();
+        doUpdate(time);
+        disable();
+      }
+  }
 
 void AntShaderProgram::doUpdate(float time)
-{
-}
+  {
+  }
 
 void AntShaderProgram::sendUniform(const std::string &pName,int i)
-{
-  glUniform1iARB(getLoc(pName),i);
-}
+  {
+    glUniform1iARB(getLoc(pName),i);
+  }
 void AntShaderProgram::sendUniform(const std::string &pName,float f)
-{
-  glUniform1fARB(getLoc(pName),f);
-}
+  {
+    glUniform1fARB(getLoc(pName),f);
+  }
 void AntShaderProgram::sendUniform(const std::string &pName,const AGVector3 &m)
-{
-  glUniform3fARB(getLoc(pName),m[0],m[1],m[2]);
-}
+  {
+    glUniform3fARB(getLoc(pName),m[0],m[1],m[2]);
+  }
 void AntShaderProgram::sendUniform(const std::string &pName,const AGVector4 &m)
-{
-  glUniform4fARB(getLoc(pName),m[0],m[1],m[2],m[3]);
-}
+  {
+    glUniform4fARB(getLoc(pName),m[0],m[1],m[2],m[3]);
+  }
 void AntShaderProgram::sendUniform(const std::string &pName,const AGMatrix4 &m)
-{
-  glUniformMatrix4fvARB(getLoc(pName),1,false,m);
-}
+  {
+    glUniformMatrix4fvARB(getLoc(pName),1,false,m);
+  }
 void AntShaderProgram::sendUniform(const std::string &pName,const std::vector<AGMatrix4> &m)
-{
-  assert(m.size()<100);
-  float *p=matrixBuf;
+  {
+    assert(m.size()<100);
+    float *p=matrixBuf;
 
-  for(size_t i=0;i<m.size();i++)
-    {
-      const float *s=m[i];
-      for(size_t j=0;j<16;j++)
-	*(p++)=*(s++);
-    }
-  assertGL;
-  glUniformMatrix4fvARB(getLoc(pName),m.size(),false,matrixBuf);
-  assertGL;
-}
+    for(size_t i=0;i<m.size();i++)
+      {
+        const float *s=m[i];
+        for(size_t j=0;j<16;j++)
+          *(p++)=*(s++);
+      }
+    assertGL;
+    glUniformMatrix4fvARB(getLoc(pName),m.size(),false,matrixBuf);
+    assertGL;
+  }
 
 GLint AntShaderProgram::getLoc(const std::string &pName)
-{
-  // register only once !
-  
-  std::map<std::string,GLint>::iterator i=locations.find(pName);
-  if(i!=locations.end())
-    return i->second;
-  
-  GLint k=glGetUniformLocationARB(p,pName.c_str());
-  locations.insert(std::make_pair(pName,k));
-  return k;
-}
+  {
+    // register only once !
 
+    std::map<std::string,GLint>::iterator i=locations.find(pName);
+    if(i!=locations.end())
+      return i->second;
+
+    GLint k=glGetUniformLocationARB(p,pName.c_str());
+    locations.insert(std::make_pair(pName,k));
+    return k;
+  }
+
 GLint AntShaderProgram::getAttr(const std::string &pName)
-{
-  //  TRACE;
-  // register only once !
-  assert(on);
-  std::map<std::string,GLint>::iterator i=attrs.find(pName);
-  if(i!=attrs.end())
-    return i->second;
-  
-  assertGL;
-  GLint k=glGetAttribLocationARB(p,pName.c_str());
-  //  cdebug("k:"<<k);
-  if(k<0)
-    {
-      cdebug("ERROR:attribute could be get! Maybe it was not defined in the vertex-shader? :"<<pName);
-    }
-  assertGL;
-  attrs.insert(std::make_pair(pName,k));
-  return k;
-}
+  {
+    //  TRACE;
+    // register only once !
+    assert(on);
+    std::map<std::string,GLint>::iterator i=attrs.find(pName);
+    if(i!=attrs.end())
+      return i->second;
 
+    assertGL;
+    GLint k=glGetAttribLocationARB(p,pName.c_str());
+    //  cdebug("k:"<<k);
+    if(k<0)
+      {
+        cdebug("ERROR:attribute could be get! Maybe it was not defined in the vertex-shader? :"<<pName);
+      }
+    assertGL;
+    attrs.insert(std::make_pair(pName,k));
+    return k;
+  }
+
 void AntShaderProgram::sendAttribute(const std::string &pName,const std::vector<float> &vf)
-{
-  assertGL;
-  GLint loc=getAttr(pName);
-  assertGL;
-  glEnableClientState(GL_VERTEX_ARRAY);
-  assertGL;
-  glEnableVertexAttribArrayARB(loc); // add array
-  assertGL;
+  {
+    assertGL;
+    GLint loc=getAttr(pName);
+    assertGL;
+    glEnableClientState(GL_VERTEX_ARRAY);
+    assertGL;
+    glEnableVertexAttribArrayARB(loc); // add array
+    assertGL;
 
-  glVertexAttribPointerARB(loc,1,GL_FLOAT,0,0,&vf[0]); // set attributes (for each vertex an attribute)
-  assertGL;
-}
+    glVertexAttribPointerARB(loc,1,GL_FLOAT,0,0,&vf[0]); // set attributes (for each vertex an attribute)
+    assertGL;
+  }
 
 
 
@@ -290,61 +290,61 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 AntShadowShader::AntShadowShader(const std::string &pVertexFile,const std::string &pFragFile):
-	AntShaderProgram(pVertexFile,pFragFile)
-{
-}
+  AntShaderProgram(pVertexFile,pFragFile)
+  {
+  }
 
 void AntShadowShader::doUpdate(float time)
-{
-  if(glslOk())
-    {
-      Renderer *r=getRenderer();
-      sendUniform("shadowTex",r->getShadowUnit());
-      sendUniform("normalTex",r->getNormalUnit());
-      sendUniform("lightComplete",r->getCurrentScene()->getLightComplete());
-    }
-}
+  {
+    if(glslOk())
+      {
+        Renderer *r=getRenderer();
+        sendUniform("shadowTex",r->getShadowUnit());
+        sendUniform("normalTex",r->getNormalUnit());
+        sendUniform("lightComplete",r->getCurrentScene()->getLightComplete());
+      }
+  }
 
 
 void AntShadowShader::enable()
-{
-  AntShaderProgram::enable();
-  if(glslOk())
-    {
-      Scene *scene=getRenderer()->getCurrentScene();
+  {
+    AntShaderProgram::enable();
+    if(glslOk())
+      {
+        Scene *scene=getRenderer()->getCurrentScene();
 
-      glActiveTexture(getRenderer()->getShadowUnit()); // shadow unit
+        glActiveTexture(getRenderer()->getShadowUnit()); // shadow unit
 
-      glMatrixMode(GL_TEXTURE);
-      glPushMatrix();
+        glMatrixMode(GL_TEXTURE);
+        glPushMatrix();
 
-      // FIXME: move bias to frag-shader, as this shall reduce z-fighting
-      float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
-		0.0f, 0.5f, 0.0f, 0.0f,
-		0.0f, 0.0f, 0.5f, 0.0f,
-		0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
-      glLoadMatrixf(bias);
+        // FIXME: move bias to frag-shader, as this shall reduce z-fighting
+        float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
+            0.0f, 0.5f, 0.0f, 0.0f,
+            0.0f, 0.0f, 0.5f, 0.0f,
+            0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
+        glLoadMatrixf(bias);
 
-      glMultMatrixf(scene->getLightProj());
-      glMultMatrixf(scene->getLightView());
+        glMultMatrixf(scene->getLightProj());
+        glMultMatrixf(scene->getLightView());
 
-      glActiveTexture(getRenderer()->getNormalUnit()); // tex unit
+        glActiveTexture(getRenderer()->getNormalUnit()); // tex unit
 
-      glMatrixMode(GL_MODELVIEW);
-    }
-}
+        glMatrixMode(GL_MODELVIEW);
+      }
+  }
 void AntShadowShader::disable()
-{
-  AntShaderProgram::disable();
-  if(glslOk())
-    {
-      glActiveTexture(getRenderer()->getShadowUnit()); // shadow unit
-      glMatrixMode(GL_TEXTURE);
-      glPopMatrix();
-      glMatrixMode(GL_MODELVIEW);
-      glActiveTexture(getRenderer()->getNormalUnit()); // tex unit
-    }
-}
+  {
+    AntShaderProgram::disable();
+    if(glslOk())
+      {
+        glActiveTexture(getRenderer()->getShadowUnit()); // shadow unit
+        glMatrixMode(GL_TEXTURE);
+        glPopMatrix();
+        glMatrixMode(GL_MODELVIEW);
+        glActiveTexture(getRenderer()->getNormalUnit()); // tex unit
+      }
+  }
 
 
 ///////////////////////////////////////////////////////////////////////////
@@ -355,18 +355,18 @@
 
 AntWaterShader::AntWaterShader():
   AntShaderProgram("data/shaders/simplewater.vert","data/shaders/simplewater.frag")
-{
-}
+  {
+  }
 void AntWaterShader::doUpdate(float time)
-{
-  if(glslOk())
-    {
-      AntShaderProgram::doUpdate(time);
-      
-      t+=time;
-      sendUniform("time", t);
-    }
-}
+  {
+    if(glslOk())
+      {
+        AntShaderProgram::doUpdate(time);
 
+        t+=time;
+        sendUniform("time", t);
+      }
+  }
 
 
+

Modified: antargis/trunk/ext/3dengine/mesh.cc
===================================================================
--- antargis/trunk/ext/3dengine/mesh.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/mesh.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -16,61 +16,61 @@
 
 Mesh::Mesh(Scene *pScene):
   MeshBase(pScene,AGVector4(),AGBox3())
-{
-  mData=0;
-  mRotation=0;
-  setOrder(MESH_Z);
-  mColor=AGVector4(1,1,1,1);
-  mVisible=true;
-}
+  {
+    mData=0;
+    mRotation=0;
+    setOrder(MESH_Z);
+    mColor=AGVector4(1,1,1,1);
+    mVisible=true;
+  }
 
 Mesh::Mesh(Scene *pScene,MeshData &data,const AGVector4 &pPos,float pRot):
   MeshBase(pScene,pPos,data.bbox())
-{
-  mData=&data;
-  mRotation=pRot;
-  setOrder(MESH_Z);
-  mColor=AGVector4(1,1,1,1);
-  mVisible=true;
-}
+  {
+    mData=&data;
+    mRotation=pRot;
+    setOrder(MESH_Z);
+    mColor=AGVector4(1,1,1,1);
+    mVisible=true;
+  }
 
 Mesh::~Mesh()
-{
-}
+  {
+  }
 
 void Mesh::draw()
-{
-  STACKTRACE;
-  if(!mVisible)
-    return;
+  {
+    STACKTRACE;
+    if(!mVisible)
+      return;
 
-  begin();
-  if(mData)
-    {
-      mData->draw(mColor);
-    }
-  end();
-}
+    begin();
+    if(mData)
+      {
+        mData->draw(mColor);
+      }
+    end();
+  }
 void Mesh::drawDepth()
-{
-  STACKTRACE;
-  if(!mVisible)
-    return;
-  begin();
-  if(mData)
-    mData->drawDepth();
-  end();
-}
+  {
+    STACKTRACE;
+    if(!mVisible)
+      return;
+    begin();
+    if(mData)
+      mData->drawDepth();
+    end();
+  }
 void Mesh::drawShadow()
-{
-  STACKTRACE;
-  if(!mVisible)
-    return;
-  begin();
-  if(mData)
-    mData->drawShadow();
-  end();
-}
+  {
+    STACKTRACE;
+    if(!mVisible)
+      return;
+    begin();
+    if(mData)
+      mData->drawShadow();
+    end();
+  }
 
 size_t Mesh::getTriangles() const
 {
@@ -80,18 +80,18 @@
 }
 
 void Mesh::begin()
-{
-  assertGL;
+  {
+    assertGL;
 
-  glPushMatrix();
-  AGVector4 p=getPos();
-  glTranslatef(p[0],p[1],p[2]);
-  glRotatef(mRotation,0.0,0.0,1.0);
-}
+    glPushMatrix();
+    AGVector4 p=getPos();
+    glTranslatef(p[0],p[1],p[2]);
+    glRotatef(mRotation,0.0,0.0,1.0);
+  }
 void Mesh::end()
-{
-  glPopMatrix();
-}
+  {
+    glPopMatrix();
+  }
 
 
 AGVector4 Mesh::lineHit(const AGLine3 &pLine) const
@@ -101,59 +101,59 @@
   AGMatrix4 rot(-mRotation*M_PI/180.0,AGVector3(0,0,1));
   AGMatrix4 tr(-getPos());
   AGMatrix4 complete=rot*tr;
-  
+
   AGVector4 p0(pLine.getV0(),1);
   AGVector4 p1(pLine.getV1(),1);
-  
+
   p0=complete*p0;
   p1=complete*p1;
   return mData->lineHit(AGLine3(AGVector3(p0[0],p0[1],p0[2]),
-				AGVector3(p1[0],p1[1],p1[2])))+AGVector4(getPos().dim3(),0);
+      AGVector3(p1[0],p1[1],p1[2])))+AGVector4(getPos().dim3(),0);
 }
 
 void Mesh::setRotation(float r)
-{
-  mRotation=r;
-}
+  {
+    mRotation=r;
+  }
 
 MeshData *Mesh::getData()
-{
-  return mData;
-}
+  {
+    return mData;
+  }
 
 void Mesh::drawPick()
-{
-  STACKTRACE;
+  {
+    STACKTRACE;
 
-  if(!mVisible)
-    return;
-  begin();
+    if(!mVisible)
+      return;
+    begin();
 
-  if(mData)
-    mData->drawPick();
-  end();
-}
+    if(mData)
+      mData->drawPick();
+    end();
+  }
 
 
 bool Mesh::transparent()
-{
-  assert(mData);
-  return mData->transparent();
-}
+  {
+    assert(mData);
+    return mData->transparent();
+  }
 
 
 void Mesh::mark()
-{
-  markObject(getData());
-}
+  {
+    markObject(getData());
+  }
 
 
 void Mesh::setColor(const AGVector4 &pColor)
-{
-  mColor=pColor;
-}
+  {
+    mColor=pColor;
+  }
 void Mesh::setVisible(bool v)
-{
-  mVisible=v;
-}
+  {
+    mVisible=v;
+  }
 

Modified: antargis/trunk/ext/3dengine/mesh_data.cc
===================================================================
--- antargis/trunk/ext/3dengine/mesh_data.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/mesh_data.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -53,78 +53,65 @@
       mTexture=getTextureCache()->get(pTexture,getMeshDownScale());
       mWithTexture=true;
     }
-  
+
   MeshVertex mVertices[4];
   MeshOptimizer opt;
   bool withTex=filename.find(".ant2")!=filename.npos;
 
   BinaryFileIn f(filename);
   /*
-  
+
   FILE *f=fopen(filename.c_str(),"rb");
   assert(f);
   fread(&meshes,sizeof(Uint16),1,f);*/
 
   f>>meshes;
-  
+
   for(;meshes>0;meshes--)
     {
       f>>faces;
       //      fread(&faces,sizeof(Uint16),1,f);
-      
+
       for(Uint16 i=0;i<faces;i++)
-	{
-	  //  fread(&vertices,sizeof(Uint16),1,f);
-	  f>>vertices;
-	  assert(vertices<=4);
-	  for(Uint16 j=0;j<vertices;j++)
-	    {
-	      AGVector3 v,n,c;
-	      f>>v;
-	      mVertices[j].v=AGVector4(v,1);
-	      f>>n;
-	      mVertices[j].n=n;
-	      f>>c; // load here first, as mVertices[.].c is a AGVector4
-	      mVertices[j].c=AGVector4(c,1);
-	      if(withTex)
-		f>>mVertices[j].t;
+        {
+          //  fread(&vertices,sizeof(Uint16),1,f);
+          f>>vertices;
+          assert(vertices<=4);
+          for(Uint16 j=0;j<vertices;j++)
+            {
+              AGVector3 v,n,c;
+              f>>v;
+              mVertices[j].v=AGVector4(v,1);
+              f>>n;
+              mVertices[j].n=n;
+              f>>c; // load here first, as mVertices[.].c is a AGVector4
+              mVertices[j].c=AGVector4(c,1);
+              if(withTex)
+                f>>mVertices[j].t;
 
-	      mVertices[j].t[1]=1-mVertices[j].t[1];
+              mVertices[j].t[1]=1-mVertices[j].t[1];
 
-	      mVertices[j].v*=zoom;
-	      mVertices[j].v[3]=1;
+              mVertices[j].v*=zoom;
+              mVertices[j].v[3]=1;
 
-	      mBBox.include(mVertices[j].v.dim3());
-	      /*
-	      fread(mVertices[j].v,sizeof(float),3,f);
-	      fread(mVertices[j].n,sizeof(float),3,f);
-	      fread(mVertices[j].c,sizeof(float),3,f);
-	      if(withTex)
-		fread(mVertices[j].t,sizeof(float),2,f);
-	      mVertices[j].t[1]=1-mVertices[j].t[1];
-
-	      mVertices[j].v*=zoom;
-	      mVertices[j].v[3]=1;
-
-	      mBBox.include(mVertices[j].v.dim3());
-	      */
-	    }
-	  if(vertices==3)
-	    {
-	      opt.add(mVertices[0]);
-	      opt.add(mVertices[1]);
-	      opt.add(mVertices[2]);
-	    }
-	  else
-	    {
-	      opt.add(mVertices[0]);
-	      opt.add(mVertices[1]);
-	      opt.add(mVertices[2]);
-	      opt.add(mVertices[0]);
-	      opt.add(mVertices[2]);
-	      opt.add(mVertices[3]);
-	    }
-	}
+              mBBox.include(mVertices[j].v.dim3());
+            }
+          if(vertices==3)
+            {
+              opt.add(mVertices[0]);
+              opt.add(mVertices[1]);
+              opt.add(mVertices[2]);
+            }
+          else
+            {
+              opt.add(mVertices[0]);
+              opt.add(mVertices[1]);
+              opt.add(mVertices[2]);
+              opt.add(mVertices[0]);
+              opt.add(mVertices[2]);
+              opt.add(mVertices[3]);
+            }
+        }
     }
   //  fclose(f);
   mShadow=pShadow;
@@ -138,24 +125,24 @@
 }
 
 MeshData::~MeshData()
-{
-  //  TRACE;
-}
+  {
+    //  TRACE;
+  }
 
 bool MeshData::transparent()
-{
-  return mTransparent;
-}
+  {
+    return mTransparent;
+  }
 
 void MeshData::setTransparent(bool p)
-{
-  mTransparent=p;
-}
+  {
+    mTransparent=p;
+  }
 
 void MeshData::setLighting(bool l)
-{
-  mLighting=l;
-}
+  {
+    mLighting=l;
+  }
 
 AGBox3 MeshData::bbox() const
 {
@@ -164,158 +151,158 @@
 
 
 void MeshData::save(const std::string &pFilename)
-{
-  FILE *f=fopen(pFilename.c_str(),"wb");
+  {
+    FILE *f=fopen(pFilename.c_str(),"wb");
 
-  size_t meshes=1;
-  size_t vertices=3;
-  size_t faces=mArray.getTriangles();
+    size_t meshes=1;
+    size_t vertices=3;
+    size_t faces=mArray.getTriangles();
 
-  // meshes
-  fwrite(&meshes,sizeof(Uint16),1,f);
+    // meshes
+    fwrite(&meshes,sizeof(Uint16),1,f);
 
-  // faces
-  fwrite(&faces,sizeof(Uint16),1,f);
-  for(size_t i=0;i<faces;i++)
-    {
-      fwrite(&vertices,sizeof(Uint16),1,f);
-      for(size_t k=0;k<vertices;k++)
-	{
-	  size_t j=mArray.getIndex(i*vertices+k);
-	  fwrite(mArray.getVertex(j),sizeof(float),3,f);
-	  fwrite(mArray.getNormal(j),sizeof(float),3,f);
-	  fwrite(mArray.getColor(j),sizeof(float),3,f);
-	  fwrite(mArray.getTexCoord(j),sizeof(float),2,f);
-	}
-    }
+    // faces
+    fwrite(&faces,sizeof(Uint16),1,f);
+    for(size_t i=0;i<faces;i++)
+      {
+        fwrite(&vertices,sizeof(Uint16),1,f);
+        for(size_t k=0;k<vertices;k++)
+          {
+            size_t j=mArray.getIndex(i*vertices+k);
+            fwrite(mArray.getVertex(j),sizeof(float),3,f);
+            fwrite(mArray.getNormal(j),sizeof(float),3,f);
+            fwrite(mArray.getColor(j),sizeof(float),3,f);
+            fwrite(mArray.getTexCoord(j),sizeof(float),2,f);
+          }
+      }
 
-  fclose(f);
-}
+    fclose(f);
+  }
 
 
 void MeshData::setOverdraw(bool o)
-{
-  overdraw=o;
-}
+  {
+    overdraw=o;
+  }
 
 void MeshData::drawPick()
-{
-  if(mPickable)
-    mArray.drawPick();
-}
+  {
+    if(mPickable)
+      mArray.drawPick();
+  }
 #ifdef OLD
 void MeshData::draw()
-{
-  if(!mShadow)
-    glDepthMask(false);
+  {
+    if(!mShadow)
+      glDepthMask(false);
 
-  if(mTransparent)
-    glDisable(GL_CULL_FACE);
+    if(mTransparent)
+      glDisable(GL_CULL_FACE);
 
-  glEnable(GL_ALPHA_TEST);
-  glAlphaFunc(GL_GREATER,0.9);
+    glEnable(GL_ALPHA_TEST);
+    glAlphaFunc(GL_GREATER,0.9);
 
 
-  if(mLighting)
-    glEnable(GL_LIGHTING);
-  else
-    glDisable(GL_LIGHTING);
+    if(mLighting)
+      glEnable(GL_LIGHTING);
+    else
+      glDisable(GL_LIGHTING);
 
-  glBindTexture(GL_TEXTURE_2D,0);
-  glEnable(GL_COLOR_MATERIAL);
-  glColorMaterial(GL_FRONT,GL_AMBIENT_AND_DIFFUSE);
-  
+    glBindTexture(GL_TEXTURE_2D,0);
+    glEnable(GL_COLOR_MATERIAL);
+    glColorMaterial(GL_FRONT,GL_AMBIENT_AND_DIFFUSE);
 
-  if(mWithTexture)
-    glBindTexture(GL_TEXTURE_2D,mTexture.getTextureID());
 
-  if(mTransparent)
-    {
-      glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);//_MIPMAP_LINEAR);//NEAREST);//GL_LINEAR);
+    if(mWithTexture)
+      glBindTexture(GL_TEXTURE_2D,mTexture.getTextureID());
 
-      //      glDisable(GL_LIGHTING);
-      glAlphaFunc(GL_GREATER,0.4f);
-      glEnable(GL_ALPHA_TEST);
-    }
-  if(overdraw)
-    {
-      glDisable(GL_ALPHA_TEST);
-      glDisable(GL_DEPTH_TEST);
-    }
-  mArray.setColors(drawColors);
-  mArray.draw();
-  if(overdraw)
-    {
-      glEnable(GL_DEPTH_TEST);
-      glEnable(GL_ALPHA_TEST);
-    }
-  if(mTransparent)
-    {
-      glAlphaFunc(GL_GREATER,0.9f);
-      glEnable(GL_LIGHTING);
-    }
-  //    glEnable(GL_ALPHA_TEST);
+    if(mTransparent)
+      {
+        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);//_MIPMAP_LINEAR);//NEAREST);//GL_LINEAR);
 
+        //      glDisable(GL_LIGHTING);
+        glAlphaFunc(GL_GREATER,0.4f);
+        glEnable(GL_ALPHA_TEST);
+      }
+    if(overdraw)
+      {
+        glDisable(GL_ALPHA_TEST);
+        glDisable(GL_DEPTH_TEST);
+      }
+    mArray.setColors(drawColors);
+    mArray.draw();
+    if(overdraw)
+      {
+        glEnable(GL_DEPTH_TEST);
+        glEnable(GL_ALPHA_TEST);
+      }
+    if(mTransparent)
+      {
+        glAlphaFunc(GL_GREATER,0.9f);
+        glEnable(GL_LIGHTING);
+      }
+    //    glEnable(GL_ALPHA_TEST);
 
-  glBindTexture(GL_TEXTURE_2D,0);
-  if(!mShadow)
-    glDepthMask(true);
 
-  glDisable(GL_ALPHA_TEST);
-  if(mTransparent)
-    glEnable(GL_CULL_FACE);
-}
+    glBindTexture(GL_TEXTURE_2D,0);
+    if(!mShadow)
+      glDepthMask(true);
+
+    glDisable(GL_ALPHA_TEST);
+    if(mTransparent)
+      glEnable(GL_CULL_FACE);
+  }
 #else
 
 void MeshData::setCulling(bool c)
-{
-  mCulling=c;
-}
+  {
+    mCulling=c;
+  }
 
 
 void MeshData::draw(const AGVector4 &pColor)
-{
-  AGRenderContext c;
-  
-  if(!mShadow)
-    c.setDepthWrite(false);
+  {
+    AGRenderContext c;
 
-  //  if(mTransparent)
-  c.setCulling(mCulling);
+    if(!mShadow)
+      c.setDepthWrite(false);
 
-  c.setAlpha(0.9,GL_GREATER);
+    //  if(mTransparent)
+    c.setCulling(mCulling);
 
-  c.setLighting(mLighting);
+    c.setAlpha(0.9,GL_GREATER);
 
-  if(pColor!=AGVector4(1,1,1,1))
-    c.setColor(pColor);
+    c.setLighting(mLighting);
 
-  if(mWithTexture)
-    c.setTexture(mTexture.glTexture());
+    if(pColor!=AGVector4(1,1,1,1))
+      c.setColor(pColor);
 
-  if(mTransparent)
-    {
-      mTexture.setFilter(GL_LINEAR,GL_LINEAR);
-      c.setAlpha(0.4f,GL_GREATER);
-    }
-  if(overdraw)
-    {
-      c.setDepthWrite(false);
-      c.setDepthTest(false);
-      c.setAlpha(0,GL_NONE);
-    }
-  c.begin();
-  mArray.setColors(drawColors);
-  mArray.draw();
-}
+    if(mWithTexture)
+      c.setTexture(mTexture.glTexture());
 
+    if(mTransparent)
+      {
+        mTexture.setFilter(GL_LINEAR,GL_LINEAR);
+        c.setAlpha(0.4f,GL_GREATER);
+      }
+    if(overdraw)
+      {
+        c.setDepthWrite(false);
+        c.setDepthTest(false);
+        c.setAlpha(0,GL_NONE);
+      }
+    c.begin();
+    mArray.setColors(drawColors);
+    mArray.draw();
+  }
+
 #endif
 
 
 void MeshData::setColors(bool c)
-{
-  drawColors=c;
-}
+  {
+    drawColors=c;
+  }
 
 size_t MeshData::getTriangles() const
 {
@@ -323,69 +310,69 @@
 }
 
 void MeshData::drawShadow()
-{
-  if(mTransparent)
-    glDisable(GL_CULL_FACE);
+  {
+    if(mTransparent)
+      glDisable(GL_CULL_FACE);
 
-  drawDepth();
+    drawDepth();
 
-  if(mTransparent)
-    glEnable(GL_CULL_FACE);
-}
+    if(mTransparent)
+      glEnable(GL_CULL_FACE);
+  }
 void MeshData::drawDepth()
-{
-  assertGL;
-  AGRenderContext c;
-  if(mTransparent)
-    {
-      c.setCulling(false);
-      c.setAlpha(0.9f,GL_GREATER);
-      c.setTexture(mTexture.glTexture());
-      /*
+  {
+    assertGL;
+    AGRenderContext c;
+    if(mTransparent)
+      {
+        c.setCulling(false);
+        c.setAlpha(0.9f,GL_GREATER);
+        c.setTexture(mTexture.glTexture());
+        /*
       glDisable(GL_CULL_FACE);
       //      throw int();
 
       glBindTexture(GL_TEXTURE_2D,mTexture.getTextureID());
       glEnable(GL_ALPHA_TEST);
       glAlphaFunc(GL_GREATER,0.9f);
-      */
-      //      cdebug("muh");
-    }
-  c.begin();
-  assertGL;
-  if(mShadow)
+         */
+        //      cdebug("muh");
+      }
+    c.begin();
+    assertGL;
+    if(mShadow)
+      {
+        mArray.setColors(false);
+        mArray.draw();
+        mArray.setColors(true);
+      }
+    /*  if(mTransparent)
     {
-      mArray.setColors(false);
-      mArray.draw();
-      mArray.setColors(true);
-    }
-  /*  if(mTransparent)
-    {
       glEnable(GL_CULL_FACE);
       glBindTexture(GL_TEXTURE_2D,0);
       }*/
-}
+  }
 
 void MeshData::texCoordFromPos(float scale)
-{
-  for(size_t i=0;i<mArray.getTriangles()*3;i++)
-    {
-      size_t j=mArray.getIndex(i);
+  {
+    for(size_t i=0;i<mArray.getTriangles()*3;i++)
+      {
+        size_t j=mArray.getIndex(i);
 
-      AGVector4 v=mArray.getVertex(j);
-      AGVector2 t(v[0]+v[1],v[2]);
-      mArray.setTexCoord(j,t*scale);
-    }
-}
+        AGVector4 v=mArray.getVertex(j);
+        AGVector2 t(v[0]+v[1],v[2]);
+        mArray.setTexCoord(j,t*scale);
+      }
+  }
 
 void MeshData::setPickable(bool p)
-{
-  mPickable=p;
-}
+  {
+    mPickable=p;
+  }
 
 void MeshData::makeInstances(const std::vector<AGMatrix4> &ts)
-{
-  VertexArray *va=::makeInstances(mArray,ts);
-  mArray=*va;
-  delete va;
-}
+  {
+    VertexArray *va=::makeInstances(mArray,ts);
+    mArray=*va;
+    delete va;
+  }

Modified: antargis/trunk/ext/3dengine/mesh_optimizer.cc
===================================================================
--- antargis/trunk/ext/3dengine/mesh_optimizer.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/mesh_optimizer.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -13,56 +13,56 @@
   for(i=0;i<3;i++)
     if(v[i]<p.v[i])
       return true;
-  
+
   for(i=0;i<4;i++)
     if(c[i]<p.c[i])
       return true;
-  
+
   for(i=0;i<3;i++) 
     if(n[i]<p.n[i]) 
       return true; 
-  
+
   for(i=0;i<2;i++)
     if(t[i]<p.t[i]) 
       return true;
-  
-    return false;
+
+  return false;
 }
 
 
 MeshOptimizer::MeshOptimizer()
-{
-  saved=0;
-}
+  {
+    saved=0;
+  }
 void MeshOptimizer::add(const MeshVertex &v)
-{
-  size_t index=mVertices.size();
-  std::map<MeshVertex,int>::iterator i=mMap.find(v);
-  if(i!=mMap.end())
-    {
-      saved++;
-      index=i->second;
-    }
-  else
-    {
-      mVertices.push_back(v);
-      mMap[v]=index;
-    }
-  assert(index<mVertices.size());
-  mIndices.push_back(index);
-  return;
-}
+  {
+    size_t index=mVertices.size();
+    std::map<MeshVertex,int>::iterator i=mMap.find(v);
+    if(i!=mMap.end())
+      {
+        saved++;
+        index=i->second;
+      }
+    else
+      {
+        mVertices.push_back(v);
+        mMap[v]=index;
+      }
+    assert(index<mVertices.size());
+    mIndices.push_back(index);
+    return;
+  }
 
 
 struct MeshTriangle
 {
   size_t i0,i1,i2;
   MeshTriangle(size_t p0,size_t p1,size_t p2)
-  {
-    i0=p0;
-    i1=p1;
-    i2=p2;
-  }
+    {
+      i0=p0;
+      i1=p1;
+      i2=p2;
+    }
 
   bool operator<(const MeshTriangle &t) const;
 };
@@ -86,90 +86,90 @@
 
 
 VertexArray MeshOptimizer::getArray()
-{
-  CTRACE;
-  VertexArray a;
-  for(size_t i=0;i<mVertices.size();i++)
-    {
-      MeshVertex v=mVertices[i];
-      a.addVertex(v.v,v.c,v.n,v.t);
-    }
+  {
+    CTRACE;
+    VertexArray a;
+    for(size_t i=0;i<mVertices.size();i++)
+      {
+        MeshVertex v=mVertices[i];
+        a.addVertex(v.v,v.c,v.n,v.t);
+      }
 
-  std::vector<MeshTriangle> tris;
-  for(size_t i=0;i<mIndices.size();i+=3)
-    {
-      tris.push_back(MeshTriangle(mIndices[i],mIndices[i+1],mIndices[i+2]));
-    }  
-  sort(tris.begin(),tris.end(),TriCompare(this,AGVector3(0,-10,10)));
+    std::vector<MeshTriangle> tris;
+    for(size_t i=0;i<mIndices.size();i+=3)
+      {
+        tris.push_back(MeshTriangle(mIndices[i],mIndices[i+1],mIndices[i+2]));
+      }  
+    sort(tris.begin(),tris.end(),TriCompare(this,AGVector3(0,-10,10)));
 
-  for(std::vector<MeshTriangle>::iterator i=tris.begin();i!=tris.end();i++)
-    a.addTriangle(i->i0,i->i1,i->i2);
+    for(std::vector<MeshTriangle>::iterator i=tris.begin();i!=tris.end();i++)
+      a.addTriangle(i->i0,i->i1,i->i2);
 
 
-  if(mIndices.size()==0)
-    cdebug("NO TRIANGLES FOUND!");
-  cdebug("SAVED:"<<1.0f-float(saved)/mIndices.size());
-  return a;
-}
+    if(mIndices.size()==0)
+      cdebug("NO TRIANGLES FOUND!");
+    cdebug("SAVED:"<<1.0f-float(saved)/mIndices.size());
+    return a;
+  }
 
 AGVector4 MeshOptimizer::getV(size_t i)
-{
-  return mVertices[i].v;
-}
+  {
+    return mVertices[i].v;
+  }
 
 
 MeshOptimizer loadFromText(const std::string &pText, bool withTex, float zoom)
-{
-  MeshOptimizer opt;
-  MeshVertex mVertices[4];
+  {
+    MeshOptimizer opt;
+    MeshVertex mVertices[4];
 
-  BinaryStringIn in(pText);
+    BinaryStringIn in(pText);
 
-  Uint16 meshes,faces,vertices;
-  AGVector3 v;
+    Uint16 meshes,faces,vertices;
+    AGVector3 v;
 
-  in>>meshes;
-  cdebug("meshes:"<<meshes);
-  for(;meshes>0;meshes--)
-    {
-      in>>faces;
-      cdebug("faces:"<<faces);
-      for(Uint16 i=0;i<faces;i++)
-	{
-	  in>>vertices;
-	  cdebug("vs:"<<vertices);
-	  assert(vertices<=4);
-	  for(Uint16 j=0;j<vertices;j++)
-	    {
-	      in>>v;
-	      mVertices[j].v=AGVector4(v,1);
-	      //	      cdebug("v:"<<mVertices[j].v.toString());
-	      in>>mVertices[j].n;
-	      in>>v;
-	      mVertices[j].c=AGVector4(v,1);
-	      if(withTex)
-		in>>mVertices[j].t;
-	      mVertices[j].v*=zoom;
-	      mVertices[j].v[3]=1;
-	    }
-	  if(vertices==3)
-	    {
-	      opt.add(mVertices[0]);
-	      opt.add(mVertices[1]);
-	      opt.add(mVertices[2]);
-	    }
-	  else
-	    {
-	      opt.add(mVertices[0]);
-	      opt.add(mVertices[1]);
-	      opt.add(mVertices[2]);
-	      opt.add(mVertices[0]);
-	      opt.add(mVertices[2]);
-	      opt.add(mVertices[3]);
-	    }
-	}
-    }
+    in>>meshes;
+    cdebug("meshes:"<<meshes);
+    for(;meshes>0;meshes--)
+      {
+        in>>faces;
+        cdebug("faces:"<<faces);
+        for(Uint16 i=0;i<faces;i++)
+          {
+            in>>vertices;
+            cdebug("vs:"<<vertices);
+            assert(vertices<=4);
+            for(Uint16 j=0;j<vertices;j++)
+              {
+                in>>v;
+                mVertices[j].v=AGVector4(v,1);
+                // cdebug("v:"<<mVertices[j].v.toString());
+                in>>mVertices[j].n;
+                in>>v;
+                mVertices[j].c=AGVector4(v,1);
+                if(withTex)
+                  in>>mVertices[j].t;
+                mVertices[j].v*=zoom;
+                mVertices[j].v[3]=1;
+              }
+            if(vertices==3)
+              {
+                opt.add(mVertices[0]);
+                opt.add(mVertices[1]);
+                opt.add(mVertices[2]);
+              }
+            else
+              {
+                opt.add(mVertices[0]);
+                opt.add(mVertices[1]);
+                opt.add(mVertices[2]);
+                opt.add(mVertices[0]);
+                opt.add(mVertices[2]);
+                opt.add(mVertices[3]);
+              }
+          }
+      }
 
 
-  return opt;
-}
+    return opt;
+  }

Modified: antargis/trunk/ext/3dengine/scene.cc
===================================================================
--- antargis/trunk/ext/3dengine/scene.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/scene.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,8 +1,9 @@
 #include "ant_renderer.h"
 #include "scene.h"
 
-#include <GL/gl.h>
-#include <GL/glu.h>
+#include <SDL_opengl.h>
+//#include <GL/gl.h>
+//#include <GL/glu.h>
 
 #include <ag_debug.h>
 #include <ag_vdebug.h>
@@ -26,29 +27,29 @@
 
 Scene::Scene(int w,int h):
   SceneBase(w,h)
-{
-  white=AGVector4(1,1,1,1);
-  black=AGVector4(0,0,0,1);
-  
-  GLeeInit();
+  {
+    white=AGVector4(1,1,1,1);
+    black=AGVector4(0,0,0,1);
 
-  cdebug("SHADOW:"<<(int)GLEE_ARB_shadow);
-  cdebug("SHADOW_AMB:"<<(int)GLEE_ARB_shadow_ambient);
-  
-  if(getRenderer()->canShadow())
-    mShadow=1;
-  else
-    mShadow=0;
-  
-  mRubyObject=false;
-  mEnabled=true;
+    GLeeInit();
 
-}
+    cdebug("SHADOW:"<<(int)GLEE_ARB_shadow);
+    cdebug("SHADOW_AMB:"<<(int)GLEE_ARB_shadow_ambient);
 
+    if(getRenderer()->canShadow())
+      mShadow=1;
+    else
+      mShadow=0;
 
+    mRubyObject=false;
+    mEnabled=true;
+
+  }
+
+
 Scene::~Scene()
-{
-}
+  {
+  }
 
 size_t Scene::getDrawnMeshes() const
 {
@@ -67,45 +68,45 @@
 
 
 void Scene::draw()
-{
-  if(!mEnabled)
-    return;
-  AGRenderContext c;
-  c.begin(); // reset gl-state
+  {
+    if(!mEnabled)
+      return;
+    AGRenderContext c;
+    c.begin(); // reset gl-state
 
-  getRenderer()->setCurrentScene(this);
-  assertGL;
+    getRenderer()->setCurrentScene(this);
+    assertGL;
 
-  mMeshes=0;
-  mTriangles=0;
-  mPickTriangles=0;
+    mMeshes=0;
+    mTriangles=0;
+    mPickTriangles=0;
 
-  for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
-    (*i)->sort(AGVector4(mCamera.getPosition(),1));
-  
-  if(mShadow)
-    {
-      calcShadowMap();
-      initScene();
-      drawShadow();
-    }
-  else
-    {
-      initScene();
-      drawScene();
-    }
+    for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
+      (*i)->sort(AGVector4(mCamera.getPosition(),1));
 
-  getRenderer()->setCurrentScene(0);
-}
+    if(mShadow)
+      {
+        calcShadowMap();
+        initScene();
+        drawShadow();
+      }
+    else
+      {
+        initScene();
+        drawScene();
+      }
 
+    getRenderer()->setCurrentScene(0);
+  }
+
 void Scene::setShadow(int v)
-{
-  if(getRenderer()->canShadow())
-    {
-      mShadow=v;
-      cdebug(mShadow);
-    }
-}
+  {
+    if(getRenderer()->canShadow())
+      {
+        mShadow=v;
+        cdebug(mShadow);
+      }
+  }
 int Scene::getShadow() const
 {
   return mShadow;
@@ -115,227 +116,227 @@
 
 
 SceneNodeList Scene::getCurrentNodes()
-{
-  STACKTRACE;
-  AGVector2 p=mCamera.getPosition().dim2();
-  SceneNodeList l=mTree->get(AGRect2(p+AGVector2(-30,-30),p+AGVector2(30,30)));
+  {
+    STACKTRACE;
+    AGVector2 p=mCamera.getPosition().dim2();
+    SceneNodeList l=mTree->get(AGRect2(p+AGVector2(-30,-30),p+AGVector2(30,30)));
 
-  for(SceneNodeList::iterator i=l.begin();i!=l.end();i++)
-    {
-      if(mNodeSet.find(*i)==mNodeSet.end())
-	cdebug("ERROR:"<<*i);
-      assert(mNodeSet.find(*i)!=mNodeSet.end());
-    }
-  return l;
-}
+    for(SceneNodeList::iterator i=l.begin();i!=l.end();i++)
+      {
+        if(mNodeSet.find(*i)==mNodeSet.end())
+          cdebug("ERROR:"<<*i);
+        assert(mNodeSet.find(*i)!=mNodeSet.end());
+      }
+    return l;
+  }
 
 
 void Scene::calcShadowMap()
-{
-  STACKTRACE;
-  assertGL;
-  //  AGMatrix4 frustum=getFrustum();
-  size_t shadowMeshes=0;
-
-  getRenderer()->beginShadowComputation();
-
   {
     STACKTRACE;
-    SceneNodeList l=getCurrentNodes();
-    Nodes sorted;
-    std::copy(l.rbegin(),l.rend(),std::back_inserter(sorted));
-    
+    assertGL;
+    //  AGMatrix4 frustum=getFrustum();
+    size_t shadowMeshes=0;
 
-    {
-      // apply frustrum culling
-      AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
-      for(Nodes::iterator i=sorted.begin();i!=sorted.end();)
-	{
-	  if(cFrustum.collides((*i)->bbox()))
-	    i++;
-	  else
-	    i=sorted.erase(i);
-	}
-    }
+    getRenderer()->beginShadowComputation();
 
-    sort(sorted.begin(),sorted.end(),SortOrder());
-      
-    for(Nodes::iterator i=sorted.begin();i!=sorted.end();i++)
       {
-	{
-	  if((*i)->visible())
-	    {
-	      (*i)->drawDepth();
-	      mTriangles+=(*i)->getTriangles();
-	      shadowMeshes++;
-	    }
-	}
-    }
+        STACKTRACE;
+        SceneNodeList l=getCurrentNodes();
+        Nodes sorted;
+        std::copy(l.rbegin(),l.rend(),std::back_inserter(sorted));
+
+
+          {
+            // apply frustrum culling
+            AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
+            for(Nodes::iterator i=sorted.begin();i!=sorted.end();)
+              {
+                if(cFrustum.collides((*i)->bbox()))
+                  i++;
+                else
+                  i=sorted.erase(i);
+              }
+          }
+
+          sort(sorted.begin(),sorted.end(),SortOrder());
+
+          for(Nodes::iterator i=sorted.begin();i!=sorted.end();i++)
+            {
+                {
+                  if((*i)->visible())
+                    {
+                      (*i)->drawDepth();
+                      mTriangles+=(*i)->getTriangles();
+                      shadowMeshes++;
+                    }
+                }
+            }
+      }
+      //  cdebug("shadowMeshes:"<<shadowMeshes);
+
+      getRenderer()->endShadowComputation();
+      assertGL;
   }
-  //  cdebug("shadowMeshes:"<<shadowMeshes);
 
-  getRenderer()->endShadowComputation();
-  assertGL;
-}
-
 /**
    setups up lighting and gl-matrices (projection and such)
-*/
+ */
 void Scene::initScene()
-{
-  glClear(GL_DEPTH_BUFFER_BIT);
-  
-  glMatrixMode(GL_PROJECTION);
-  glLoadMatrixf(mCamera.getProjection());
-  
-  glMatrixMode(GL_MODELVIEW);
-  glLoadIdentity();
+  {
+    glClear(GL_DEPTH_BUFFER_BIT);
 
-  float xfactor=float(getVideo()->realWidth())/getVideo()->width();
-  float yfactor=float(getVideo()->realHeight())/getVideo()->height();
-  
-  glViewport(0, 0,(GLint)(mCamera.getWidth()*xfactor), (GLint)(mCamera.getHeight()*yfactor));
-  
-  //Use dim light to represent shadowed areas
+    glMatrixMode(GL_PROJECTION);
+    glLoadMatrixf(mCamera.getProjection());
 
-  AGVector4 l=mCamera.getLightPosition();
-  l[3]=1;
+    glMatrixMode(GL_MODELVIEW);
+    glLoadIdentity();
 
-  glLightfv(GL_LIGHT1, GL_POSITION, l);
-  glLightfv(GL_LIGHT1, GL_AMBIENT, AGVector4(0.1,0.1,0.1,1));//white*0.05f);
-  glLightfv(GL_LIGHT1, GL_DIFFUSE, AGVector4(0.3,0.3,0.3,1));//white*0.3f);//*0.2f);
-  glLightfv(GL_LIGHT1, GL_SPECULAR, black);
-  glEnable(GL_LIGHT1);
+    float xfactor=float(getVideo()->realWidth())/getVideo()->width();
+    float yfactor=float(getVideo()->realHeight())/getVideo()->height();
 
-  AGVector4 lightPosition2=AGVector4( 0, 0, -50,1);
+    glViewport(0, 0,(GLint)(mCamera.getWidth()*xfactor), (GLint)(mCamera.getHeight()*yfactor));
 
-  //  glLightfv(GL_LIGHT2, GL_POSITION, lightPosition2+scenePosition);
-  glLightfv(GL_LIGHT2, GL_AMBIENT, black);
-  glLightfv(GL_LIGHT2, GL_DIFFUSE, AGVector4(0.7,0.7,0.7,1));//white*0.7f);//*0.2f);
-  glLightfv(GL_LIGHT2, GL_SPECULAR, white);
-  glLightfv(GL_LIGHT2, GL_SPOT_DIRECTION, AGVector4(0,0,-1,0));
-  glLightf(GL_LIGHT2,GL_LINEAR_ATTENUATION,0);
-  glLightf(GL_LIGHT2,GL_QUADRATIC_ATTENUATION,0);
-  glLightf(GL_LIGHT2,GL_CONSTANT_ATTENUATION,0);
-  glEnable(GL_LIGHT2);
+    //Use dim light to represent shadowed areas
 
+    AGVector4 l=mCamera.getLightPosition();
+    l[3]=1;
 
+    glLightfv(GL_LIGHT1, GL_POSITION, l);
+    glLightfv(GL_LIGHT1, GL_AMBIENT, AGVector4(0.1,0.1,0.1,1));//white*0.05f);
+    glLightfv(GL_LIGHT1, GL_DIFFUSE, AGVector4(0.3,0.3,0.3,1));//white*0.3f);//*0.2f);
+    glLightfv(GL_LIGHT1, GL_SPECULAR, black);
+    glEnable(GL_LIGHT1);
 
-  glEnable(GL_LIGHTING);
+    AGVector4 lightPosition2=AGVector4( 0, 0, -50,1);
 
-  glDisable(GL_LIGHT0);
-  glDisable(GL_LIGHT3);
-  glDisable(GL_LIGHT4);
-  glDisable(GL_LIGHT5);
+    //  glLightfv(GL_LIGHT2, GL_POSITION, lightPosition2+scenePosition);
+    glLightfv(GL_LIGHT2, GL_AMBIENT, black);
+    glLightfv(GL_LIGHT2, GL_DIFFUSE, AGVector4(0.7,0.7,0.7,1));//white*0.7f);//*0.2f);
+    glLightfv(GL_LIGHT2, GL_SPECULAR, white);
+    glLightfv(GL_LIGHT2, GL_SPOT_DIRECTION, AGVector4(0,0,-1,0));
+    glLightf(GL_LIGHT2,GL_LINEAR_ATTENUATION,0);
+    glLightf(GL_LIGHT2,GL_QUADRATIC_ATTENUATION,0);
+    glLightf(GL_LIGHT2,GL_CONSTANT_ATTENUATION,0);
+    glEnable(GL_LIGHT2);
 
-  //  glLoadMatrixf(cameraViewMatrix);
-  glLoadMatrixf(mCamera.getModelview());
-}
 
+
+    glEnable(GL_LIGHTING);
+
+    glDisable(GL_LIGHT0);
+    glDisable(GL_LIGHT3);
+    glDisable(GL_LIGHT4);
+    glDisable(GL_LIGHT5);
+
+    //  glLoadMatrixf(cameraViewMatrix);
+    glLoadMatrixf(mCamera.getModelview());
+  }
+
 #ifdef TEST_DL
 static GLuint displayList=0;
 static bool dlInited=false;
 #endif
 
 void Scene::drawScene()
-{
+  {
 #ifdef TEST_DL
-  // this was for testing only - to check if display-lists are any good.
-  // it seems they are comparable with VBOs - the problem is that they're inflexible
-  // please leave this code, so we have some example, if we happen to use this again at a later stage
+    // this was for testing only - to check if display-lists are any good.
+    // it seems they are comparable with VBOs - the problem is that they're inflexible
+    // please leave this code, so we have some example, if we happen to use this again at a later stage
 
-  if(dlInited)
-    {
-      glCallList(displayList);
-    }
-  else
-    {
-      dlInited=true;
-      displayList=glGenLists(1);
-      glNewList(displayList,GL_COMPILE);
+    if(dlInited)
+      {
+        glCallList(displayList);
+      }
+    else
+      {
+        dlInited=true;
+        displayList=glGenLists(1);
+        glNewList(displayList,GL_COMPILE);
 #endif
 
-  STACKTRACE; 
+        STACKTRACE; 
 
-  // this is used for frustum cullin
-  AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
-  
-  //2nd pass - Draw from camera's point of view
+        // this is used for frustum cullin
+        AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
 
-  // draw scene with texturing and so
+        //2nd pass - Draw from camera's point of view
 
-  int drawn=0;
+        // draw scene with texturing and so
 
-  SceneNodeList l=getCurrentNodes();
-  Nodes sorted;
-  std::copy(l.begin(),l.end(),std::back_inserter(sorted));
+        int drawn=0;
 
-  {
-    STACKTRACE;
-    for(Nodes::iterator i=sorted.begin();i!=sorted.end();)
-      {
-	if(cFrustum.collides((*i)->bbox()))
-	  i++;
-	else
-	  i=sorted.erase(i);
-      }
-  }
+        SceneNodeList l=getCurrentNodes();
+        Nodes sorted;
+        std::copy(l.begin(),l.end(),std::back_inserter(sorted));
 
-  sort(sorted.begin(),sorted.end(),SortOrder());
-  // draw opaque objects first, from front to back
-  for(Nodes::iterator i=sorted.begin();i!=sorted.end();i++)
-    {
-      if(!(*i)->transparent())
-	{
-	  if((*i)->visible())
-	    {
-	      (*i)->draw();
-	      mTriangles+=(*i)->getTriangles();
-	      drawn++;
-	      mMeshes++;
-	    }
-	}
-    }
-  sort(sorted.begin(),sorted.end(),SortDistance(mCamera.getCameraPosition().dim3()));
-  // draw transparent ones next from back to front
-  for(Nodes::reverse_iterator i=sorted.rbegin();i!=sorted.rend();i++)
-    {
-      if((*i)->transparent())
-	{
-	  if((*i)->visible())
-	    {
-	      (*i)->draw();
-	      mTriangles+=(*i)->getTriangles();
-	      drawn++;
-	      mMeshes++;
-	    }
-	}
-    }
+          {
+            STACKTRACE;
+            for(Nodes::iterator i=sorted.begin();i!=sorted.end();)
+              {
+                if(cFrustum.collides((*i)->bbox()))
+                  i++;
+                else
+                  i=sorted.erase(i);
+              }
+          }
 
+          sort(sorted.begin(),sorted.end(),SortOrder());
+          // draw opaque objects first, from front to back
+          for(Nodes::iterator i=sorted.begin();i!=sorted.end();i++)
+            {
+              if(!(*i)->transparent())
+                {
+                  if((*i)->visible())
+                    {
+                      (*i)->draw();
+                      mTriangles+=(*i)->getTriangles();
+                      drawn++;
+                      mMeshes++;
+                    }
+                }
+            }
+          sort(sorted.begin(),sorted.end(),SortDistance(mCamera.getCameraPosition().dim3()));
+          // draw transparent ones next from back to front
+          for(Nodes::reverse_iterator i=sorted.rbegin();i!=sorted.rend();i++)
+            {
+              if((*i)->transparent())
+                {
+                  if((*i)->visible())
+                    {
+                      (*i)->draw();
+                      mTriangles+=(*i)->getTriangles();
+                      drawn++;
+                      mMeshes++;
+                    }
+                }
+            }
+
 #ifdef TEST_DL
-  glEndList();
-  glCallList(displayList);
-    }
+          glEndList();
+          glCallList(displayList);
+      }
 #endif
 
-}
+  }
 
 
 /// deprecated function - this is done in one pass with "normal" drawing
 /// it was used to paint the shadow afterwards in a 3rd pass
 void Scene::drawShadow()
-{
-  assertGL;
+  {
+    assertGL;
 
-  getRenderer()->beginShadowDrawing();
-  
-  drawScene();
+    getRenderer()->beginShadowDrawing();
 
-  getRenderer()->endShadowDrawing();
+    drawScene();
 
-  assertGL;
-}
+    getRenderer()->endShadowDrawing();
 
+    assertGL;
+  }
+
 AGVector3 Scene::getCameraDirTo(const AGVector3 &p) const
 {
   return mCamera.getCameraPosition().dim3()-p;
@@ -344,144 +345,144 @@
 /** pickDraw is used for picking ;-)
     it draws all the objects with opengl
     and not using texturing, shaders and such - if I'm right here??
-*/
+ */
 void Scene::pickDraw()
-{
-  STACKTRACE;
-  GLuint name=1;
-  pickNames.clear();
+  {
+    STACKTRACE;
+    GLuint name=1;
+    pickNames.clear();
 
-  AGMatrix4 frustum=cameraPickMatrix*mCamera.getModelview();
+    AGMatrix4 frustum=cameraPickMatrix*mCamera.getModelview();
 
-  AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
-  
-  SceneNodeList l=getCurrentNodes();
+    AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
 
-  for(SceneNodeList::iterator i=l.begin();i!=l.end();i++)
-    {
-      STACKTRACE;
-      if((*i)->visible() && (*i)->bbox().collides(frustum))
-	if(cFrustum.collides((*i)->bbox()))
-	  {
-	    STACKTRACE;
-	    glPushName(name);
-	    (*i)->drawPick();
-	    glPopName();
-	    pickNames.insert(std::make_pair(name,*i));
-	    name++;
-	    mPickTriangles+=(*i)->getTriangles();
-	  }
-    }
+    SceneNodeList l=getCurrentNodes();
 
-  glEnable(GL_CULL_FACE);
-}
+    for(SceneNodeList::iterator i=l.begin();i!=l.end();i++)
+      {
+        STACKTRACE;
+        if((*i)->visible() && (*i)->bbox().collides(frustum))
+          if(cFrustum.collides((*i)->bbox()))
+            {
+              STACKTRACE;
+              glPushName(name);
+              (*i)->drawPick();
+              glPopName();
+              pickNames.insert(std::make_pair(name,*i));
+              name++;
+              mPickTriangles+=(*i)->getTriangles();
+            }
+      }
 
+    glEnable(GL_CULL_FACE);
+  }
+
 /// this a global function - use this for picking!
 /// x and y are in screen-coordinates in normal fashion
 /// so (0,0) is the top left corner and (1023,767) bottom right.
 /// the same for w and h
 PickResult Scene::pick(float x,float y,float w,float h)
-{
-  STACKTRACE;
-  size_t bufsize=4000;
-  GLuint buffer[bufsize+1];
-  
-  glSelectBuffer(bufsize,buffer);
-  glRenderMode(GL_SELECT);
-  
-  glMatrixMode(GL_PROJECTION);
-  glPushMatrix();
-  glLoadIdentity();
-  
-  assertGL;
-  gluPickMatrix(x,mCamera.getHeight()-y,h,w,getViewport());
+  {
+    STACKTRACE;
+    size_t bufsize=4000;
+    GLuint buffer[bufsize+1];
 
-  assertGL;
-  
-  glMultMatrixf(mCamera.getProjection());
-  glGetFloatv(GL_PROJECTION_MATRIX, cameraPickMatrix);
-  assertGL;
-  
-  glMatrixMode(GL_MODELVIEW);
-  glPushMatrix();
-  glLoadIdentity();
+    glSelectBuffer(bufsize,buffer);
+    glRenderMode(GL_SELECT);
 
-  glMultMatrixf(mCamera.getModelview());
-  glInitNames();
-  assertGL;
+    glMatrixMode(GL_PROJECTION);
+    glPushMatrix();
+    glLoadIdentity();
 
-  pickDraw();
-  assertGL;
-  
-  
-  // back to normality
-  glPopMatrix();
-  glMatrixMode(GL_PROJECTION);
-  glPopMatrix();
-  glMatrixMode(GL_MODELVIEW);
-  glFlush();
-  assertGL;
-  
-  int hits=glRenderMode(GL_RENDER);
-  assertGL;
-  PickResult r=processHits(hits,buffer,x+w/2,mCamera.getHeight()-(y+h/2));
-  std::sort(r.begin(),r.end());
-  return r;
-}
+    assertGL;
+    gluPickMatrix(x,mCamera.getHeight()-y,h,w,getViewport());
 
+    assertGL;
+
+    glMultMatrixf(mCamera.getProjection());
+    glGetFloatv(GL_PROJECTION_MATRIX, cameraPickMatrix);
+    assertGL;
+
+    glMatrixMode(GL_MODELVIEW);
+    glPushMatrix();
+    glLoadIdentity();
+
+    glMultMatrixf(mCamera.getModelview());
+    glInitNames();
+    assertGL;
+
+    pickDraw();
+    assertGL;
+
+
+    // back to normality
+    glPopMatrix();
+    glMatrixMode(GL_PROJECTION);
+    glPopMatrix();
+    glMatrixMode(GL_MODELVIEW);
+    glFlush();
+    assertGL;
+
+    int hits=glRenderMode(GL_RENDER);
+    assertGL;
+    PickResult r=processHits(hits,buffer,x+w/2,mCamera.getHeight()-(y+h/2));
+    std::sort(r.begin(),r.end());
+    return r;
+  }
+
 /// helper function for gettin PickResult from opengl's buffers
 PickResult Scene::processHits (int hits, GLuint *buffer,float px,float py)
-{
-  STACKTRACE;
-  PickResult result;
-  if(hits==0)
-    return result;
+  {
+    STACKTRACE;
+    PickResult result;
+    if(hits==0)
+      return result;
 
-   unsigned int i, j;
-   GLuint names, *ptr, minZ,*ptrNames, numberOfNames;
+    unsigned int i, j;
+    GLuint names, *ptr, minZ,*ptrNames, numberOfNames;
 
-   ptr = (GLuint *) buffer;
-   minZ = 0xffffffff;
-   for (i = 0; i < (unsigned int)hits; i++) { 
+    ptr = (GLuint *) buffer;
+    minZ = 0xffffffff;
+    for (i = 0; i < (unsigned int)hits; i++) { 
       names = *ptr;
       ptr++;
       if (*ptr < minZ) {
-	numberOfNames = names;
-	minZ = *ptr;
+        numberOfNames = names;
+        minZ = *ptr;
 
-	ptrNames = ptr+2;
+        ptrNames = ptr+2;
 
-	GLuint *mptr=ptrNames;
-	for(j=0;j<numberOfNames;j++,mptr++)
-	  {
-	    PickNode n;
-	    n.node=pickNames[*mptr];
-	    n.camDist=minZ/float(0xFFFFFFFF); // (0-1)
+        GLuint *mptr=ptrNames;
+        for(j=0;j<numberOfNames;j++,mptr++)
+          {
+            PickNode n;
+            n.node=pickNames[*mptr];
+            n.camDist=minZ/float(0xFFFFFFFF); // (0-1)
 
-	    // get world-position
-	    GLdouble x,y,z;
+            // get world-position
+            GLdouble x,y,z;
 
-	    GLdouble modelview[16],projection[16];
-	    for(size_t i=0;i<16;i++)
-	      {
-		modelview[i]=((float*)mCamera.getModelview())[i];
-		projection[i]=((float*)cameraPickMatrix)[i];
-	      }
+            GLdouble modelview[16],projection[16];
+            for(size_t i=0;i<16;i++)
+              {
+                modelview[i]=((float*)mCamera.getModelview())[i];
+                projection[i]=((float*)cameraPickMatrix)[i];
+              }
 
-	    gluUnProject(px,py,n.camDist,modelview,projection,getViewport(),&x,&y,&z);
-	    n.pos=AGVector4(x,y,z,1);
-	    n.camDist=(n.pos-mCamera.getCameraPosition()).length3();
+            gluUnProject(px,py,n.camDist,modelview,projection,getViewport(),&x,&y,&z);
+            n.pos=AGVector4(x,y,z,1);
+            n.camDist=(n.pos-mCamera.getCameraPosition()).length3();
 
-	    result.push_back(n);
-	  }
+            result.push_back(n);
+          }
 
       }
-      
+
       ptr += names+2;
-   }
+    }
 
-   return result;
-}
+    return result;
+  }
 
 
 Viewport Scene::getViewport() const
@@ -509,7 +510,7 @@
 AGVector2 Scene::getPosition(const AGVector4 &v) const
 {
   GLdouble x,y,z;
-  
+
   GLdouble modelview[16],projection[16];
   for(size_t i=0;i<16;i++)
     {
@@ -524,13 +525,13 @@
 
 
 void Scene::setEnabled(bool p)
-{
-  mEnabled=p;
-}
+  {
+    mEnabled=p;
+  }
 
 
 void Scene::advance(float time)
-{
-  if(mEnabled)
-    SceneBase::advance(time);
-}
+  {
+    if(mEnabled)
+      SceneBase::advance(time);
+  }

Modified: antargis/trunk/ext/3dengine/scene_2d.cc
===================================================================
--- antargis/trunk/ext/3dengine/scene_2d.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/scene_2d.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -7,61 +7,61 @@
 
 Scene2D::Scene2D(int w,int h):
   SceneBase(w,h),mPainter(0)
-{
-}
+  {
+  }
 
 Scene2D::~Scene2D()
-{
-}
+  {
+  }
 
 void Scene2D::draw()
-{
-  // FIXME
-  
-  SceneNodeList nodeList=getCurrentNodes();
-  Nodes ns;
-  std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
+  {
+    // FIXME
 
+    SceneNodeList nodeList=getCurrentNodes();
+    Nodes ns;
+    std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
 
-  sort(ns.begin(),ns.end(),SortYCoord());
 
-  //FIXME:sort!!
+    sort(ns.begin(),ns.end(),SortYCoord());
 
-  for(Nodes::iterator i=ns.begin();i!=ns.end();i++)
-    (*i)->draw();
-}
+    //FIXME:sort!!
 
+    for(Nodes::iterator i=ns.begin();i!=ns.end();i++)
+      (*i)->draw();
+  }
+
 PickResult Scene2D::pick(float x,float y,float w,float h)
-{
-  PickResult result;
-  SceneNodeList nodeList=getCurrentNodes();
+  {
+    PickResult result;
+    SceneNodeList nodeList=getCurrentNodes();
 
-  Nodes ns;
-  std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
-  sort(ns.begin(),ns.end(),SortOrder());
+    Nodes ns;
+    std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
+    sort(ns.begin(),ns.end(),SortOrder());
 
-  for(Nodes::reverse_iterator i=ns.rbegin();i!=ns.rend();i++)
-    {
-      Mesh2D*m=dynamic_cast<Mesh2D*>(*i);
-      if(m)
-	{
-	  if(m->hit(AGVector2(x,y)))
-	    {
-	      PickNode node;
-	      node.pos=m->getPos();
-	      node.node=m;
-	      node.camDist=0;
+    for(Nodes::reverse_iterator i=ns.rbegin();i!=ns.rend();i++)
+      {
+        Mesh2D*m=dynamic_cast<Mesh2D*>(*i);
+        if(m)
+          {
+            if(m->hit(AGVector2(x,y)))
+              {
+                PickNode node;
+                node.pos=m->getPos();
+                node.node=m;
+                node.camDist=0;
 
-	      cdebug("hit:"<<node.pos<<"   "<<node.node);
-	      result.push_back(node);
-	    }
-	}
-    }
-  
+                cdebug("hit:"<<node.pos<<"   "<<node.node);
+                result.push_back(node);
+              }
+          }
+      }
 
-  return result;
-}
 
+    return result;
+  }
+
 AGVector2 Scene2D::getPosition(const AGVector4 &v) const
 {
   // FIXME: include camera !!
@@ -86,37 +86,37 @@
 }
 
 SceneNodeList Scene2D::getCurrentNodes()
-{
-  //  cdebug("FIXME");
+  {
+    //  cdebug("FIXME");
 
-  SceneNodeList l;
-  std::copy(mNodes.begin(),mNodes.end(),std::back_inserter(l));
+    SceneNodeList l;
+    std::copy(mNodes.begin(),mNodes.end(),std::back_inserter(l));
 
-  //  throw std::runtime_error("FIXME");
-  return l;
-}
+    //  throw std::runtime_error("FIXME");
+    return l;
+  }
 
 //void setEnabled(bool p);
 
 void Scene2D::setPainter(AGPainter *p)
-{
-  CTRACE;
-  assert(mPainter==0);
-  mPainter=p;
-}
+  {
+    CTRACE;
+    assert(mPainter==0);
+    mPainter=p;
+  }
 void Scene2D::discardPainter()
-{
-  CTRACE;
-  assert(mPainter!=0);
-  mPainter=0;
-}
+  {
+    CTRACE;
+    assert(mPainter!=0);
+    mPainter=0;
+  }
 
 AGPainter *Scene2D::getPainter()
-{
-  CTRACE;
-  assert(mPainter);
-  return mPainter;
-}
+  {
+    CTRACE;
+    assert(mPainter);
+    return mPainter;
+  }
 
 
 #endif

Modified: antargis/trunk/ext/3dengine/scene_base.cc
===================================================================
--- antargis/trunk/ext/3dengine/scene_base.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/3dengine/scene_base.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -7,112 +7,110 @@
 SceneBase::SceneBase(int w,int h):
   mTree(new QuadTree<SceneNode>(AGRect2(AGVector2(),AGVector2(w,h)))),
   mCamera(w,h)
-{
-}
+  {
+  }
 
 
 SceneBase::~SceneBase()
-{
-  // tell nodes, that I'm no longer there :-)
-  for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
-    (*i)->resetScene(); 
+  {
+    // tell nodes, that I'm no longer there :-)
+    for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
+      (*i)->resetScene(); 
 
-  delete mTree;
-}
+    delete mTree;
+  }
 
 
 
 
 
 void SceneBase::addNode(SceneNode *node)
-{
-  //  std::cout<<"addNode:(this:"<<this<<") "<<node<<"  "<<typeid(*node).name()<<std::endl;
-  if(mNodeSet.find(node)==mNodeSet.end())
-    {
-      node->setScene(this);
+  {
+    //  std::cout<<"addNode:(this:"<<this<<") "<<node<<"  "<<typeid(*node).name()<<std::endl;
+    if(mNodeSet.find(node)==mNodeSet.end())
+      {
+        node->setScene(this);
 
-      mNodes.push_back(node);
-      mNodeSet.insert(node);
-      assert(node->getScene()==this);
-      mTree->insert(node);
-    }
-}
+        mNodes.push_back(node);
+        mNodeSet.insert(node);
+        assert(node->getScene()==this);
+        mTree->insert(node);
+      }
+  }
 
 
 
 void SceneBase::updatePos(SceneNode *node)
-{
-  if(mNodeSet.find(node)==mNodeSet.end())
-    throw std::string("Dont know about this!");
-  mTree->insert(node);
-}
+  {
+    if(mNodeSet.find(node)==mNodeSet.end())
+      throw std::string("Dont know about this!");
+    mTree->insert(node);
+  }
 
 void SceneBase::prepareUpdate(SceneNode *node)
-{
-  if(mNodeSet.find(node)==mNodeSet.end())
-    throw std::string("Dont know about this!");
-  mTree->remove(node);
-}
+  {
+    if(mNodeSet.find(node)==mNodeSet.end())
+      throw std::string("Dont know about this!");
+    mTree->remove(node);
+  }
 
 
 void SceneBase::removeNode(SceneNode *node)
-{
-  //  std::cout<<"remove node:"<<node<<std::endl;
-  if(mNodeSet.find(node)!=mNodeSet.end())
-    {
-      Nodes::iterator i=std::find(mNodes.begin(),mNodes.end(),node);
-      mNodes.erase(i);
-      mNodeSet.erase(node);
-      assert(node->getScene()==this);
-      node->resetScene();
-      bool ok=(mTree->remove(node));
-      assert(ok);
-    }
-  else
-    {
-      throw std::runtime_error("Trying to remove unknown node");
-    }
-}
+  {
+    //  std::cout<<"remove node:"<<node<<std::endl;
+    if(mNodeSet.find(node)!=mNodeSet.end())
+      {
+        Nodes::iterator i=std::find(mNodes.begin(),mNodes.end(),node);
+        mNodes.erase(i);
+        mNodeSet.erase(node);
+        assert(node->getScene()==this);
+        node->resetScene();
+        bool ok=(mTree->remove(node));
+        assert(ok);
+      }
+    else
+      {
+        throw std::runtime_error("Trying to remove unknown node");
+      }
+  }
 
 void SceneBase::clear()
-{
-  for(std::vector<SceneNode*>::iterator i=mNodes.begin();i!=mNodes.end();i++)
-    {
-      assert((*i)->getScene()==this);
-      (*i)->resetScene();
-    }
-  TRACE;
-  mNodes.clear();
-  mNodeSet.clear();
-  mTree->clear();
-}
+  {
+    for(std::vector<SceneNode*>::iterator i=mNodes.begin();i!=mNodes.end();i++)
+      {
+        assert((*i)->getScene()==this);
+        (*i)->resetScene();
+      }
+    TRACE;
+    mNodes.clear();
+    mNodeSet.clear();
+    mTree->clear();
+  }
 
-  // (mx,my,0)
+// (mx,my,0)
 void SceneBase::setCamera(AGVector4 v)
-{
-  mCamera.setPosition(v.dim3());
-}
+  {
+    mCamera.setPosition(v.dim3());
+  }
 
 void SceneBase::advance(float time)
-{
-  STACKTRACE; 
+  {
+    STACKTRACE; 
 
-  //  if(!mEnabled)
-  //    return;
-  // advance only in view
+    //  if(!mEnabled)
+    //    return;
+    // advance only in view
 
-  SceneNodeList l=getCurrentNodes();
+    SceneNodeList l=getCurrentNodes();
 
-  for(SceneNodeList::iterator i=l.begin();i!=l.end();i++)
-    {
-      if((*i)->visible())
-	{
-	  //	  std::cout<<(*i)<<std::endl;
-	  //	  std::cout<<(typeid(**i).name())<<std::endl;
-	  (*i)->advance(time);
-	}
-    }
-}
+    for(SceneNodeList::iterator i=l.begin();i!=l.end();i++)
+      {
+        if((*i)->visible())
+          {
+            (*i)->advance(time);
+          }
+      }
+  }
 
 float SceneBase::width() const
 {
@@ -124,16 +122,16 @@
 }
 
 void SceneBase::mark()
-{
-  //  std::cout<<"SceneBase::mark()"<<std::endl;
-  SceneBase::Nodes::iterator i=mNodes.begin();
+  {
+    //  std::cout<<"SceneBase::mark()"<<std::endl;
+    SceneBase::Nodes::iterator i=mNodes.begin();
 
-  for(;i!=mNodes.end();i++)
-    {
-      //  std::cout<<"scenebase-mark:"<< this<<"  "<<*i<<std::endl;
-      markObject(*i);
-    }
-}
+    for(;i!=mNodes.end();i++)
+      {
+        //  std::cout<<"scenebase-mark:"<< this<<"  "<<*i<<std::endl;
+        markObject(*i);
+      }
+  }
 
 AGVector4 SceneBase::getCamera() const
 {
@@ -141,12 +139,12 @@
 }
 
 AntCamera &SceneBase::getCameraObject()
-{
-  return mCamera;
-}
+  {
+    return mCamera;
+  }
 
 SceneNodeList SceneBase::getCurrentNodes()
-{
-  throw std::runtime_error("not implemented!");
-  return SceneNodeList();
-}
+  {
+    throw std::runtime_error("not implemented!");
+    return SceneNodeList();
+  }

Modified: antargis/trunk/ext/basic/ag_config.cc
===================================================================
--- antargis/trunk/ext/basic/ag_config.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_config.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,54 +1,46 @@
 #include "ag_config.h"
 #include "ag_xml.h"
 
+// TODO: AGConfig should switch to a ruby-based configuration (maybe YAML)
+// TODO: commenting should be possible !! (no overwriting)
+
 AGConfig::AGConfig()
-{
-  Document doc("config.xml");
+  {
+    Document doc("config.xml");
 
-  Node &root=doc.root();
-  AGString comment;
-  for(Node::iterator i=root.begin();i!=root.end();i++)
-    {
-      if((*i)->get("name")=="")
-	{
-	  AGString c=(*i)->getContent();
-	  if(c.substr(0,4)=="<!--")
-	    {
-	      comment=c;
-	      //	      cdebug("comment:"<<comment);
-	    }
-	  else
-	    {
-	      //	      cdebug("no comment."<<c);
-	    }
-	}
-      else
-	{
-	  singleValue[(*i)->get("name")]=(*i)->get("value");
-	  comments[(*i)->get("name")]=comment;
-	  //	  cdebug((*i)->get("name")<<":"<<(*i)->get("value")<<":"<<comment);
-	  comment="";
-	}
-    }
+    Node &root=doc.root();
+    AGString comment;
+    for(Node::iterator i=root.begin();i!=root.end();i++)
+      {
+        if((*i)->get("name")=="")
+          {
+            AGString c=(*i)->getContent();
+            if(c.substr(0,4)=="<!--")
+              {
+                comment=c;
+              }
+          }
+        else
+          {
+            singleValue[(*i)->get("name")]=(*i)->get("value");
+            comments[(*i)->get("name")]=comment;
+            comment="";
+          }
+      }
+    //  writeToDisc();
+  }
 
-  //  cdebug("singleValues:"<<singleValue.size());
-
-  //  std::cerr<<doc.toString()<<std::endl;
-
-  //  writeToDisc();
-}
-
 AGString AGConfig::get(const AGString &pValue,const AGString &pDefault,const AGString &pComment)
-{
-  AGString v=get(pValue);
-  if(v=="")
-    {
-      comments[pValue]=pComment;
-      set(pValue,pDefault);
-      v=pDefault;
-    }
-  return v;
-}
+  {
+    AGString v=get(pValue);
+    if(v=="")
+      {
+        comments[pValue]=pComment;
+        set(pValue,pDefault);
+        v=pDefault;
+      }
+    return v;
+  }
 
 
 
@@ -62,49 +54,49 @@
 }
 
 void AGConfig::set(const AGString &pName,const AGString &pValue)
-{
-	AGString old=singleValue[pName];
-	if(old!=pValue)
-	{
-		singleValue[pName]=pValue;
-		writeToDisc();
-	}
-}
+  {
+    AGString old=singleValue[pName];
+    if(old!=pValue)
+      {
+        singleValue[pName]=pValue;
+        writeToDisc();
+      }
+  }
 
 void AGConfig::writeToDisc()
-{
-  Document doc;
-  Node &root=doc.root();
-  root.setName("config");
-  for(std::map<AGString,AGString>::const_iterator i=singleValue.begin();i!=singleValue.end();i++)
-    {
-      if(comments[i->first]!="")
-	{
-	  Node &n=root.addChild("");
-	  n.setContent(AGString("\n")+comments[i->first]+"\n");
-	}
+  {
+    Document doc;
+    Node &root=doc.root();
+    root.setName("config");
+    for(std::map<AGString,AGString>::const_iterator i=singleValue.begin();i!=singleValue.end();i++)
+      {
+        if(comments[i->first]!="")
+          {
+            Node &n=root.addChild("");
+            n.setContent(AGString("\n")+comments[i->first]+"\n");
+          }
 
-      Node &n=root.addChild("option");
-      n.set("name",i->first);
-      n.set("value",i->second);
-    }
+        Node &n=root.addChild("option");
+        n.set("name",i->first);
+        n.set("value",i->second);
+      }
 
-  saveFile("config.xml",doc.toString(true));
-}
+    saveFile("config.xml",doc.toString(true));
+  }
 
 
 
 AGConfig *gConfig=0;
 AGConfig *getConfig()
-{
-  if(!gConfig)
-    gConfig=new AGConfig;
-  return gConfig;
-}
+  {
+    if(!gConfig)
+      gConfig=new AGConfig;
+    return gConfig;
+  }
 
 void updateConfig()
-{
-  delete gConfig;
-  gConfig=0;
-  //  getConfig();
-}
+  {
+    delete gConfig;
+    gConfig=0;
+    //  getConfig();
+  }

Modified: antargis/trunk/ext/basic/ag_fs.cc
===================================================================
--- antargis/trunk/ext/basic/ag_fs.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_fs.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -18,6 +18,9 @@
  * License along with this program.
  */
 
+
+// TODO: Code-review !!!
+
 #include <string>
 #include <list>
 #include <assert.h>
@@ -42,348 +45,348 @@
 static std::list<AGFilename> mFsPaths;
 
 void addPath(const AGFilename &pName)
-{
-  mFsPaths.push_back(pName);
+  {
+    mFsPaths.push_back(pName);
 #ifdef USE_PHYSFS
-  TRACE;
-  PHYSFS_addToSearchPath(pName.c_str(),1);
-  char **p=PHYSFS_getSearchPath();
-  for(;*p;p++)
-    {
-      dbout(0,*p);
+    TRACE;
+    PHYSFS_addToSearchPath(pName.c_str(),1);
+    char **p=PHYSFS_getSearchPath();
+    for(;*p;p++)
+      {
+        dbout(0,*p);
 
-    }
+      }
 #endif
-  updateConfig();
-}
+    updateConfig();
+  }
 
 void addPathFront(const AGFilename &pName)
-{
-  mFsPaths.push_front(pName);
+  {
+    mFsPaths.push_front(pName);
 #ifdef USE_PHYSFS
-  TRACE;
-  PHYSFS_addToSearchPath(pName.c_str(),1);
-  char **p=PHYSFS_getSearchPath();
-  for(;*p;p++)
-    {
-      dbout(0,*p);
+    TRACE;
+    PHYSFS_addToSearchPath(pName.c_str(),1);
+    char **p=PHYSFS_getSearchPath();
+    for(;*p;p++)
+      {
+        dbout(0,*p);
 
-    }
+      }
 #endif
-  updateConfig();
-}
+    updateConfig();
+  }
 
 
 void initFS(const char *argv0)
-{
+  {
 #ifdef USE_PHYSFS
-  TRACE;
-  PHYSFS_init(argv0);
-  PHYSFS_setSaneConfig("Antargis","Antargis","ZIP",false,false);
-  FSinited=true;
-  const char *wp=PHYSFS_getWriteDir();
-  dbout(0,"writedir:"<<wp);
+    TRACE;
+    PHYSFS_init(argv0);
+    PHYSFS_setSaneConfig("Antargis","Antargis","ZIP",false,false);
+    FSinited=true;
+    const char *wp=PHYSFS_getWriteDir();
+    dbout(0,"writedir:"<<wp);
 
-  dbout(0,"searchpath:");
+    dbout(0,"searchpath:");
 
-  PHYSFS_addToSearchPath("./data/",1);
-  PHYSFS_addToSearchPath("/usr/share/antargisgui/",1);
-  PHYSFS_addToSearchPath("/usr/share/antargisgui/pics",1);
-  PHYSFS_addToSearchPath("/usr/local/share/antargisgui/",1);
-  PHYSFS_addToSearchPath("/usr/local/share/antargisgui/pics",1);
-  PHYSFS_addToSearchPath("./",1);
-  PHYSFS_addToSearchPath("../",1);
+    PHYSFS_addToSearchPath("./data/",1);
+    PHYSFS_addToSearchPath("/usr/share/antargisgui/",1);
+    PHYSFS_addToSearchPath("/usr/share/antargisgui/pics",1);
+    PHYSFS_addToSearchPath("/usr/local/share/antargisgui/",1);
+    PHYSFS_addToSearchPath("/usr/local/share/antargisgui/pics",1);
+    PHYSFS_addToSearchPath("./",1);
+    PHYSFS_addToSearchPath("../",1);
 
-  char **p=PHYSFS_getSearchPath();
-  for(;*p;p++)
-    {
-      dbout(0,*p);
+    char **p=PHYSFS_getSearchPath();
+    for(;*p;p++)
+      {
+        dbout(0,*p);
 
-    }
+      }
 
-  dbout(0,"--");
+    dbout(0,"--");
 
 #endif
-  addPath("data");
-  addPath("data/fonts");
+    addPath("data");
+    addPath("data/fonts");
 #ifndef WIN32
-  addPath("/usr/local/share/antargisgui/pics");
-  addPath("/usr/local/share/antargisgui");
-  addPath("/usr/share/fonts/truetype/freefont/");
+    addPath("/usr/local/share/antargisgui/pics");
+    addPath("/usr/local/share/antargisgui");
+    addPath("/usr/share/fonts/truetype/freefont/");
 #endif
-  addPath(getWriteDir());
+    addPath(getWriteDir());
 #ifdef WIN32
-  addPath("c:/Windows/Fonts/");
+    addPath("c:/Windows/Fonts/");
 #endif
-}
+  }
 
 void checkDir(const std::string &s)
-{
+  {
 #ifdef WIN32
-  DWORD rc = CreateDirectory(s.c_str(), NULL);
-  DWORD le;
-  if(rc==0)
-    {
-	  le=GetLastError();
-	  if(le==ERROR_ALREADY_EXISTS)
-		{
-		   // dir exists -ok
-		}
-	  else
-	  {
-		  dbout(0,"could not create dir:"<<s);
-		  dbout(0,"rc:"<<rc);
-		  throw std::runtime_error("could not create dir");
-		}
-    }
+    DWORD rc = CreateDirectory(s.c_str(), NULL);
+    DWORD le;
+    if(rc==0)
+      {
+        le=GetLastError();
+        if(le==ERROR_ALREADY_EXISTS)
+          {
+            // dir exists -ok
+          }
+        else
+          {
+            dbout(0,"could not create dir:"<<s);
+            dbout(0,"rc:"<<rc);
+            throw std::runtime_error("could not create dir");
+          }
+      }
 #else
-  int rc;
-  errno = 0;
-  rc = mkdir(s.c_str(), S_IRWXU);
-  if(rc==-1)
-    {
-      switch(errno)
-	{
-	case EEXIST:
-	  return; // everything's fine - directory exists already;
-	case EACCES: 
-	  return; // probably exists - we don't have access
-	default:
-	  dbout(0,"could not create dir:"<<s);
-	  throw std::runtime_error("could not create dir");
-	}
-    }
+    int rc;
+    errno = 0;
+    rc = mkdir(s.c_str(), S_IRWXU);
+    if(rc==-1)
+      {
+        switch(errno)
+        {
+        case EEXIST:
+          return; // everything's fine - directory exists already;
+        case EACCES: 
+          return; // probably exists - we don't have access
+        default:
+          dbout(0,"could not create dir:"<<s);
+          throw std::runtime_error("could not create dir");
+        }
+      }
 #endif
-}
+  }
 
 void checkParentDirs(const std::string &s)
-{
+  {
 #ifdef WIN32
-  std::string sep="\\";
+    std::string sep="\\";
 #else
-  std::string sep="/";
+    std::string sep="/";
 #endif
-  std::vector<std::string> a=split(sep,s);
+    std::vector<std::string> a=split(sep,s);
 
-  a.pop_back();
+    a.pop_back();
 
-  std::ostringstream os;
-  for(std::vector<std::string>::iterator i=a.begin();i!=a.end();++i)
-    {
-      if(i->length()==0)
-		continue;
-      if(i!=a.begin())
-		os<<sep;
-      os<<*i;
-      if(os.str().find(sep)!=std::string::npos)
-		checkDir(os.str());
-    }
-}
+    std::ostringstream os;
+    for(std::vector<std::string>::iterator i=a.begin();i!=a.end();++i)
+      {
+        if(i->length()==0)
+          continue;
+        if(i!=a.begin())
+          os<<sep;
+        os<<*i;
+        if(os.str().find(sep)!=std::string::npos)
+          checkDir(os.str());
+      }
+  }
 
 AGFilename checkFileName(AGFilename s)
-{
+  {
 #ifdef WIN32
-  if(s.length()>300)
-	throw std::runtime_error("possible segfault???");
-  s=replace(s,"/","\\");
-  s=replace(s,"\\\\","\\"); // prevent windows from searching on network
+    if(s.length()>300)
+      throw std::runtime_error("possible segfault???");
+    s=replace(s,"/","\\");
+    s=replace(s,"\\\\","\\"); // prevent windows from searching on network
 #endif
-  return s;
-}
+    return s;
+  }
 
 std::string directLoad(const std::string &pName)
-{
-  std::string fn=checkFileName(pName);
-  if(!fileExists(fn))
-	return "";
-  
-  FILE *f=fopen(fn.c_str(),"rb");
-  if(!f)
-    return "";
-  fseek(f,0,SEEK_END);
-  long len=ftell(f);
-  fseek(f,0,SEEK_SET);
-  char *buffer=new char[len+2];
-  fread(buffer,1,len,f);
+  {
+    std::string fn=checkFileName(pName);
+    if(!fileExists(fn))
+      return "";
 
-  fclose(f);
+    FILE *f=fopen(fn.c_str(),"rb");
+    if(!f)
+      return "";
+    fseek(f,0,SEEK_END);
+    long len=ftell(f);
+    fseek(f,0,SEEK_SET);
+    char *buffer=new char[len+2];
+    fread(buffer,1,len,f);
 
-  std::string r(buffer,len);
-  delete [] buffer;
-  return r;
-}
+    fclose(f);
 
+    std::string r(buffer,len);
+    delete [] buffer;
+    return r;
+  }
+
 AGFilename findFile(const AGFilename &pName)
-{
-  if(fileExists(pName))
-    return pName;
-  for(std::list<AGFilename>::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
-    {
-      std::string n=*i+"/"+pName;
-      n=checkFileName(n);
-      if(fileExists(n))
-	return n;
-    }
+  {
+    if(fileExists(pName))
+      return pName;
+    for(std::list<AGFilename>::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
+      {
+        std::string n=*i+"/"+pName;
+        n=checkFileName(n);
+        if(fileExists(n))
+          return n;
+      }
 
 
-  if(pName.length()>5)
-    {
-      if(pName.substr(pName.length()-4,3)=="png")
-	return findFile(pName.substr(0,pName.length()-3)+"jpg");
-    }
+    if(pName.length()>5)
+      {
+        if(pName.substr(pName.length()-4,3)=="png")
+          return findFile(pName.substr(0,pName.length()-3)+"jpg");
+      }
 
-  //  throw std::runtime_error("File not found!");
-  return "";
-}
+    //  throw std::runtime_error("File not found!");
+    return "";
+  }
 
 std::string loadFromPath(const std::string &pName)
-{
-  std::string r;
-  r=directLoad(pName);
-  if(r.length())
-    return r;
+  {
+    std::string r;
+    r=directLoad(pName);
+    if(r.length())
+      return r;
 
-  for(std::list<AGFilename>::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
-    {
-      r=directLoad(*i+"/"+pName);
-      if(r.length())
-	return r;
-    }
+    for(std::list<AGFilename>::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
+      {
+        r=directLoad(*i+"/"+pName);
+        if(r.length())
+          return r;
+      }
 
-  //  if(mFsPaths.size()==0)
-  //    throw std::runtime_error("Not yet inited fs-paths!");
+    //  if(mFsPaths.size()==0)
+    //    throw std::runtime_error("Not yet inited fs-paths!");
 
-  for(std::list<AGFilename>::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
-    dbout(0,"path:"<<*i);
+    for(std::list<AGFilename>::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
+      dbout(0,"path:"<<*i);
 
-  dbout(0,"LOAD FAILED:"<<pName);
+    dbout(0,"LOAD FAILED:"<<pName);
 
-  return r;
-}
+    return r;
+  }
 
 AGData loadFile(const AGFilename &pName)
-{
-  return loadFromPath(checkFileName(pName));
+  {
+    return loadFromPath(checkFileName(pName));
 #ifdef USE_PHYSFS
-  TRACE;
-  assert(FSinited);
+    TRACE;
+    assert(FSinited);
 
-  std::string r=directLoad(pName);
-  if(r.length()!=0)
-	return r;
-
-  if(!fileExists(pName))
-    {
-      std::string r=directLoad(pName);
-      if(r.length()==0)
-	    std::cerr<<"File '"<<pName<<"' does not exist!"<<std::endl;
+    std::string r=directLoad(pName);
+    if(r.length()!=0)
       return r;
-    }
 
-  std::cerr<<"File probably doesn't exist:"<<pName<<std::endl;
-  PHYSFS_file *f=PHYSFS_openRead(pName.c_str());
-  std::string o;
+    if(!fileExists(pName))
+      {
+        std::string r=directLoad(pName);
+        if(r.length()==0)
+          std::cerr<<"File '"<<pName<<"' does not exist!"<<std::endl;
+        return r;
+      }
 
-  char buf[1001];
-  PHYSFS_uint32 c=0;
+    std::cerr<<"File probably doesn't exist:"<<pName<<std::endl;
+    PHYSFS_file *f=PHYSFS_openRead(pName.c_str());
+    std::string o;
 
-  do
-    {
-      c=PHYSFS_read(f,buf,1,1000);
-      o+=std::string(buf,c);
-    }
-  while(c);
+    char buf[1001];
+    PHYSFS_uint32 c=0;
 
-  PHYSFS_close(f);
-  return o;
+    do
+      {
+        c=PHYSFS_read(f,buf,1,1000);
+        o+=std::string(buf,c);
+      }
+    while(c);
+
+    PHYSFS_close(f);
+    return o;
 #endif
-}
+  }
 
 #ifdef WIN32
 /* GetUserProfileDirectory() is only available on >= NT4 (no 9x/ME systems!) */
 typedef BOOL (STDMETHODCALLTYPE FAR * LPFNGETUSERPROFILEDIR) (
-      HANDLE hToken,
-      LPTSTR lpProfileDir,
-      LPDWORD lpcchSize);
+    HANDLE hToken,
+    LPTSTR lpProfileDir,
+    LPDWORD lpcchSize);
 #endif
 
 
 std::string gUserDir;
 std::string getUserDir()
-{
-  if(gUserDir=="")
-    {
+  {
+    if(gUserDir=="")
+      {
 #ifdef WIN32
-      char *userDir=0;
+        char *userDir=0;
 
-      DWORD psize = 0;
-      char dummy[1];
-      BOOL rc = 0;
-      HANDLE processHandle;            /* Current process handle */
-      HANDLE accessToken = NULL;       /* Security handle to process */
-      LPFNGETUSERPROFILEDIR GetUserProfileDirectory;
-      HMODULE lib;
-      
-      assert(userDir == 0);
-      
-      /*
-       * GetUserProfileDirectory() is only available on NT 4.0 and later.
-       *  This means Win95/98/ME (and CE?) users have to do without, so for
-       *  them, we'll default to the base directory when we can't get the
-       *  function pointer.
-       */
-      
-      lib = LoadLibrary("userenv.dll");
-      if (lib)
-	{
-	  /* !!! FIXME: Handle Unicode? */
-	  GetUserProfileDirectory = (LPFNGETUSERPROFILEDIR)
-	    GetProcAddress(lib, "GetUserProfileDirectoryA");
-	  if (GetUserProfileDirectory)
-	    {
-	      processHandle = GetCurrentProcess();
-	      if (OpenProcessToken(processHandle, TOKEN_QUERY, &accessToken))
-		{
-		  /*
-		   * Should fail. Will write the size of the profile path in
-		   *  psize. Also note that the second parameter can't be
-		   *  NULL or the function fails.
-		   */
-		  rc = GetUserProfileDirectory(accessToken, dummy, &psize);
-		  assert(!rc);  /* success?! */
-		  
-		  /* Allocate memory for the profile directory */
-		  userDir = new char[psize+1];
-		  if (userDir != NULL)
-		    {
-		      if (!GetUserProfileDirectory(accessToken, userDir, &psize))
-			{
-			  delete [] userDir;
-			  userDir = NULL;
-			} /* if */
-		    } /* else */
-		} /* if */
-	      
-	      CloseHandle(accessToken);
-	    } /* if */
-	  
-	  FreeLibrary(lib);
-	} /* if */
-      
-      if (userDir == NULL)  /* couldn't get profile for some reason. */
-	{
-	  /* Might just be a non-NT system; resort to the basedir. */
-	  userDir = ".";
-	  std::cerr<<"sorry, this game doesn't run correctly on non-nt systems (win98/me)"<<std::endl;
-	} /* if */
-      gUserDir=userDir;
-      
+        DWORD psize = 0;
+        char dummy[1];
+        BOOL rc = 0;
+        HANDLE processHandle;            /* Current process handle */
+        HANDLE accessToken = NULL;       /* Security handle to process */
+        LPFNGETUSERPROFILEDIR GetUserProfileDirectory;
+        HMODULE lib;
+
+        assert(userDir == 0);
+
+        /*
+         * GetUserProfileDirectory() is only available on NT 4.0 and later.
+         *  This means Win95/98/ME (and CE?) users have to do without, so for
+         *  them, we'll default to the base directory when we can't get the
+         *  function pointer.
+         */
+
+        lib = LoadLibrary("userenv.dll");
+        if (lib)
+          {
+            /* !!! FIXME: Handle Unicode? */
+            GetUserProfileDirectory = (LPFNGETUSERPROFILEDIR)
+            GetProcAddress(lib, "GetUserProfileDirectoryA");
+            if (GetUserProfileDirectory)
+              {
+                processHandle = GetCurrentProcess();
+                if (OpenProcessToken(processHandle, TOKEN_QUERY, &accessToken))
+                  {
+                    /*
+                     * Should fail. Will write the size of the profile path in
+                     *  psize. Also note that the second parameter can't be
+                     *  NULL or the function fails.
+                     */
+                    rc = GetUserProfileDirectory(accessToken, dummy, &psize);
+                    assert(!rc);  /* success?! */
+
+                    /* Allocate memory for the profile directory */
+                    userDir = new char[psize+1];
+                    if (userDir != NULL)
+                      {
+                        if (!GetUserProfileDirectory(accessToken, userDir, &psize))
+                          {
+                            delete [] userDir;
+                            userDir = NULL;
+                          } /* if */
+                      } /* else */
+                  } /* if */
+
+                CloseHandle(accessToken);
+              } /* if */
+
+            FreeLibrary(lib);
+          } /* if */
+
+        if (userDir == NULL)  /* couldn't get profile for some reason. */
+          {
+            /* Might just be a non-NT system; resort to the basedir. */
+            userDir = ".";
+            std::cerr<<"sorry, this game doesn't run correctly on non-nt systems (win98/me)"<<std::endl;
+          } /* if */
+        gUserDir=userDir;
+
 #else
-      gUserDir=getenv("HOME");
+        gUserDir=getenv("HOME");
 #endif
-    }
-  return gUserDir;
-}
+      }
+    return gUserDir;
+  }
 
 
 #ifdef WIN32
@@ -391,216 +394,215 @@
 #define SHGFP_TYPE_CURRENT 0
 
 AGFilename getDocumentsDir()
-{
-  CHAR wszPath[MAX_PATH];
-  
-  HWND hWnd=0;
+  {
+    CHAR wszPath[MAX_PATH];
 
-  SHGetFolderPath( hWnd, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, wszPath );
+    HWND hWnd=0;
 
-  AGFilename s(wszPath);
+    SHGetFolderPath( hWnd, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, wszPath );
 
-  return s;
+    AGFilename s(wszPath);
 
-}
+    return s;
 
+  }
+
 #else
 
 AGFilename getDocumentsDir()
-{
-  return getUserDir()+"/Desktop";
-}
+  {
+    return getUserDir()+"/Desktop";
+  }
 
 
 #endif
 
 
 AGFilename getWriteDir()
-{
-  return getUserDir()+"/."+getAppName();
-}
+  {
+    return getUserDir()+"/."+getAppName();
+  }
 
 bool saveFile(const AGFilename &pName,const AGData &pContent)
-{
+  {
 #ifdef USE_PHYSFS
-  TRACE;
-  assert(FSinited);
+    TRACE;
+    assert(FSinited);
 
-  PHYSFS_file *f=PHYSFS_openWrite(pName.c_str());
+    PHYSFS_file *f=PHYSFS_openWrite(pName.c_str());
 
-  if(!f)
-    {
-      dbout(0,"Error saving file:"<<pName);
-    }
-  assert(f);
+    if(!f)
+      {
+        dbout(0,"Error saving file:"<<pName);
+      }
+    assert(f);
 
-  PHYSFS_write(f,pContent.c_str(),1,pContent.length());
+    PHYSFS_write(f,pContent.c_str(),1,pContent.length());
 
-  PHYSFS_close(f);
+    PHYSFS_close(f);
 #else
-  std::string n=checkFileName(getWriteDir()+"/"+pName);
+    std::string n=checkFileName(getWriteDir()+"/"+pName);
 
-  checkParentDirs(n);
+    checkParentDirs(n);
 
 
-  FILE *f=fopen(n.c_str(),"wb");
-  if(!f)
-    return false;
-  fwrite(pContent.c_str(),pContent.length(),1,f);
-  fclose(f);
+    FILE *f=fopen(n.c_str(),"wb");
+    if(!f)
+      return false;
+    fwrite(pContent.c_str(),pContent.length(),1,f);
+    fclose(f);
 
 #endif
-  return true;
-}
+    return true;
+  }
 
 bool fileExists(const AGFilename &pName)
-{
+  {
 #ifdef WIN32
-  if(GetFileAttributes(pName.c_str()) == INVALID_FILE_ATTRIBUTES)
-    return false;
-  return true;
+    if(GetFileAttributes(pName.c_str()) == INVALID_FILE_ATTRIBUTES)
+      return false;
+    return true;
 #endif
 
-  FILE *f=fopen(pName.c_str(),"r");
-  bool found=false;
-	
-  if(f)
-    {
-			found=true;
-      fclose(f);
-    }
-  //	cdebug("file exists:"<<pName<<":"<<found);
+    FILE *f=fopen(pName.c_str(),"r");
+    bool found=false;
 
-  return found;
+    if(f)
+      {
+        found=true;
+        fclose(f);
+      }
+
+    return found;
 #ifdef USE_PHYSFS
-  TRACE;
-  return PHYSFS_exists(pName.c_str());
+    TRACE;
+    return PHYSFS_exists(pName.c_str());
 #endif
-}
+  }
 
 std::vector<AGFilename> getDirectoryInternal(const AGFilename &pDir)
-{
+  {
 #ifdef USE_PHYSFS
-  TRACE;
-  char **files= PHYSFS_enumerateFiles(pDir.c_str());
-  std::vector<std::string> v;
+    TRACE;
+    char **files= PHYSFS_enumerateFiles(pDir.c_str());
+    std::vector<std::string> v;
 
-  char **p=files;
+    char **p=files;
 
-  while(*p)
-    {
-      v.push_back(*p);
-      p++;
-    }
+    while(*p)
+      {
+        v.push_back(*p);
+        p++;
+      }
 
-  PHYSFS_freeList(files);
-  return v;
+    PHYSFS_freeList(files);
+    return v;
 #else
 
-  std::vector<AGFilename> v;
+    std::vector<AGFilename> v;
 
 #ifdef WIN32
-  WIN32_FIND_DATA ent;
+    WIN32_FIND_DATA ent;
 
-  std::string dir=pDir+"\\*";
+    std::string dir=pDir+"\\*";
 
-  dir=replace(dir,"\\\\","\\"); // remove doubles
+    dir=replace(dir,"\\\\","\\"); // remove doubles
 
-  char path[dir.length()+20];
-  strcpy(path,dir.c_str());
+    char path[dir.length()+20];
+    strcpy(path,dir.c_str());
 
-  HANDLE d=FindFirstFile(path,&ent);
+    HANDLE d=FindFirstFile(path,&ent);
 
-  if(d)
-    {
-      do
-	{
-	  v.push_back(ent.cFileName);
-	}
-      while(FindNextFile(d,&ent)!=0);
-      
-      FindClose(d);
-    }
+    if(d)
+      {
+        do
+          {
+            v.push_back(ent.cFileName);
+          }
+        while(FindNextFile(d,&ent)!=0);
 
+        FindClose(d);
+      }
+
 #else
-  struct dirent *ent;
-  DIR *dir;
-  std::string dirname=pDir;//+"/*";
-  dbout(0,"DIR:"<<dirname);
-  dir=opendir(dirname.c_str());
-  if(dir)
-    {
-      while((ent=readdir(dir)))
-	{
-	  dbout(0,"found:"<<ent->d_name);
-	  v.push_back(ent->d_name);
-	}
-    }
+    struct dirent *ent;
+    DIR *dir;
+    std::string dirname=pDir;//+"/*";
+    dbout(0,"DIR:"<<dirname);
+    dir=opendir(dirname.c_str());
+    if(dir)
+      {
+        while((ent=readdir(dir)))
+          {
+            dbout(0,"found:"<<ent->d_name);
+            v.push_back(ent->d_name);
+          }
+      }
 
 
 #endif
 
-  return v;
+    return v;
 #endif
-}
+  }
 
 std::vector<AGFilename> getDirectory(const AGFilename &pDir)
-{
-  std::vector<AGFilename> v;
-  std::list<AGFilename> ps=mFsPaths;
-  ps.push_front(""); // add current dir
-  ps.push_front("."); // add current dir
+  {
+    std::vector<AGFilename> v;
+    std::list<AGFilename> ps=mFsPaths;
+    ps.push_front(""); // add current dir
+    ps.push_front("."); // add current dir
 
 
-  for(std::list<AGFilename>::iterator i=ps.begin();i!=ps.end();i++)
-    {
-      
-      std::vector<AGFilename> a=getDirectoryInternal(*i+"/"+pDir);
-      std::copy(a.begin(),a.end(),std::back_inserter(v));
-    }
-      
-  return v;
-}
+    for(std::list<AGFilename>::iterator i=ps.begin();i!=ps.end();i++)
+      {
 
+        std::vector<AGFilename> a=getDirectoryInternal(*i+"/"+pDir);
+        std::copy(a.begin(),a.end(),std::back_inserter(v));
+      }
 
+    return v;
+  }
 
 
+
+
 AGData compress(const AGData &pString)
-{
-  BinaryStringOut o;
-  o<<(Uint32)pString.length();
+  {
+    BinaryStringOut o;
+    o<<(Uint32)pString.length();
 
-  uLongf destlen=pString.length()+1000;
-  char *buf=new char[destlen];
+    uLongf destlen=pString.length()+1000;
+    char *buf=new char[destlen];
 
-  compress((Bytef*)buf,&destlen,(Bytef*)pString.c_str(),pString.length());
+    compress((Bytef*)buf,&destlen,(Bytef*)pString.c_str(),pString.length());
 
-  std::string r=o.getString()+std::string(buf,destlen);
-  delete [] buf;
-  return r;
-}
+    std::string r=o.getString()+std::string(buf,destlen);
+    delete [] buf;
+    return r;
+  }
 AGData uncompress(const AGData &pString)
-{
-  BinaryStringIn i(pString);
-  uLongf orig;
-  Uint32 o;
-  i>>o;
-  orig=o;
+  {
+    BinaryStringIn i(pString);
+    uLongf orig;
+    Uint32 o;
+    i>>o;
+    orig=o;
 
 
-  char *buf=new char[orig+10];
-  uncompress((Bytef*)buf,&orig,(Bytef*)pString.c_str()+4,pString.length()-4);
-  std::string r(buf,orig);
-  delete [] buf;
+    char *buf=new char[orig+10];
+    uncompress((Bytef*)buf,&orig,(Bytef*)pString.c_str()+4,pString.length()-4);
+    std::string r(buf,orig);
+    delete [] buf;
 
-  return r;
-}
+    return r;
+  }
 
 AGFilename getDirSep()
-{
+  {
 #ifdef WIN32
-  return "\\";
+    return "\\";
 #else
-  return "/";
+    return "/";
 #endif
-}
+  }

Modified: antargis/trunk/ext/basic/ag_geometry.cc
===================================================================
--- antargis/trunk/ext/basic/ag_geometry.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_geometry.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -38,17 +38,17 @@
 AGVector2 invalidVec2;
 
 bool collide1d(float a1,float a2,float b1,float b2, bool normal=true)
-{
-  float amin=std::min(a1,a2);
-  float amax=std::max(a1,a2);
-  float bmin=std::min(b1,b2);
-  float bmax=std::max(b1,b2);
+  {
+    float amin=std::min(a1,a2);
+    float amax=std::max(a1,a2);
+    float bmin=std::min(b1,b2);
+    float bmax=std::max(b1,b2);
 
-  if(normal && (amax==bmin || bmax==amin))
-    return false;
+    if(normal && (amax==bmin || bmax==amin))
+      return false;
 
-  return (amin>=bmin && amin<=bmax) || (amax>=bmin && amax<=bmax) || (bmin>=amin && bmin<=amax) || (bmax>=amin && bmax<=amin);
-}
+    return (amin>=bmin && amin<=bmax) || (amax>=bmin && amax<=bmax) || (bmin>=amin && bmin<=amax) || (bmax>=amin && bmax<=amin);
+  }
 
 struct AGSweepResult
 {
@@ -58,37 +58,37 @@
   float t1;
 
   AGSweepResult()
-  {
-    state=COL_ALWAYS;
-  }
+    {
+      state=COL_ALWAYS;
+    }
 
   void combine(const AGSweepResult &r)
-  {
-    if(state==COL_AT)
-      {
-	if(r.state==COL_NEVER)
-	  state=COL_NEVER;
-	else if(r.state!=COL_ALWAYS) // ALWAYS has no effect
-	  {
-	    t0=std::max(t0,r.t0);
-	    t1=std::min(t1,r.t1);
-	  }
-      }
-    else if(state==COL_ALWAYS)
-      {
-	if(r.state==COL_NEVER)
-	  state=COL_NEVER;
-	else if(r.state!=COL_ALWAYS) // ALWAYS has no effect
-	  {
-	    state=COL_AT;
-	    t0=r.t0;
-	    t1=r.t1;
-	  }
-	
-      }
-    // COL_NEVER cannot be changed
-  }
+    {
+      if(state==COL_AT)
+        {
+          if(r.state==COL_NEVER)
+            state=COL_NEVER;
+          else if(r.state!=COL_ALWAYS) // ALWAYS has no effect
+            {
+              t0=std::max(t0,r.t0);
+              t1=std::min(t1,r.t1);
+            }
+        }
+      else if(state==COL_ALWAYS)
+        {
+          if(r.state==COL_NEVER)
+            state=COL_NEVER;
+          else if(r.state!=COL_ALWAYS) // ALWAYS has no effect
+            {
+              state=COL_AT;
+              t0=r.t0;
+              t1=r.t1;
+            }
 
+        }
+      // COL_NEVER cannot be changed
+    }
+
   bool collision(float delta) const
   {
     return state==COL_ALWAYS || (state==COL_AT && t1>0 && t0<delta);
@@ -112,38 +112,38 @@
 };
 
 AGSweepResult collide1d(float pa1,float pa2,float pb1,float pb2,float v)
-{
-  float a1=std::min(pa1,pa2);
-  float a2=std::max(pa1,pa2);
-  float b1=std::min(pb1,pb2);
-  float b2=std::max(pb1,pb2);
-  AGSweepResult r;
+  {
+    float a1=std::min(pa1,pa2);
+    float a2=std::max(pa1,pa2);
+    float b1=std::min(pb1,pb2);
+    float b2=std::max(pb1,pb2);
+    AGSweepResult r;
 
-  if(v>0)
-    {
-      r.t0=(b1-a2)/v;
-      r.t1=(b2-a1)/v;
-      r.state = AGSweepResult::COL_AT;
+    if(v>0)
+      {
+        r.t0=(b1-a2)/v;
+        r.t1=(b2-a1)/v;
+        r.state = AGSweepResult::COL_AT;
 
-      assert(r.t0 <= r.t1);
-    }
-  else if(v<0)
-    {
-      r.t0=(b2-a1)/v;
-      r.t1=(b1-a2)/v;
-      r.state = AGSweepResult::COL_AT;
+        assert(r.t0 <= r.t1);
+      }
+    else if(v<0)
+      {
+        r.t0=(b2-a1)/v;
+        r.t1=(b1-a2)/v;
+        r.state = AGSweepResult::COL_AT;
 
-      assert(r.t0 <= r.t1);
-    }
-  else
-    {
-      if (a2 < b1 || a1 > b2)
-        r.state = AGSweepResult::COL_NEVER;
-      else
-        r.state = AGSweepResult::COL_ALWAYS;
-    }
-  return r;
-}
+        assert(r.t0 <= r.t1);
+      }
+    else
+      {
+        if (a2 < b1 || a1 > b2)
+          r.state = AGSweepResult::COL_NEVER;
+        else
+          r.state = AGSweepResult::COL_ALWAYS;
+      }
+    return r;
+  }
 
 /////////////////////////////////////////////////////////////////////////////
 // AGAngle
@@ -158,38 +158,38 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGVector2::AGVector2(const AGString &s)
-{
-  assert(s.length()>=5);
-  assert(s[0]=='(');
-  assert(s[s.length()-1]==')');
-  AGString p=s.substr(1,s.length()-2);
-  size_t i=p.find(",");
-  assert(i!=p.npos);
-  v[0]=p.substr(0,i).toFloat();
-  v[1]=p.substr(i+1,p.length()-i-1).toFloat();
-}
+  {
+    assert(s.length()>=5);
+    assert(s[0]=='(');
+    assert(s[s.length()-1]==')');
+    AGString p=s.substr(1,s.length()-2);
+    size_t i=p.find(",");
+    assert(i!=p.npos);
+    v[0]=p.substr(0,i).toFloat();
+    v[1]=p.substr(i+1,p.length()-i-1).toFloat();
+  }
 
 
 AGVector2::AGVector2(float pX,float pY)
-{
-  v[0]=pX;
-  v[1]=pY;
-}
+  {
+    v[0]=pX;
+    v[1]=pY;
+  }
 AGVector2::AGVector2(const AGVector2 &a)
-{
-  v[0]=a.v[0];
-  v[1]=a.v[1];
-}
+  {
+    v[0]=a.v[0];
+    v[1]=a.v[1];
+  }
 AGVector2::AGVector2(const AGAngle &a)
-{
-  v[0]=sin(a.angle);
-  v[1]=-cos(a.angle);
-}
+  {
+    v[0]=sin(a.angle);
+    v[1]=-cos(a.angle);
+  }
 
 AGVector2::AGVector2()
-{
-  v[0]=v[1]=0;
-}
+  {
+    v[0]=v[1]=0;
+  }
 
 void AGVector2::saveXML(Node &node) const
 {
@@ -197,10 +197,10 @@
   node.set("y",AGString(v[1]));
 }
 void AGVector2::loadXML(const Node &node)
-{
-  v[0]=node.get("x").toFloat();
-  v[1]=node.get("y").toFloat();
-}
+  {
+    v[0]=node.get("x").toFloat();
+    v[1]=node.get("y").toFloat();
+  }
 
 bool AGVector2::operator<(const AGVector2 &p) const
 {
@@ -215,24 +215,24 @@
 
 
 float getArcInternal(float x,float y)
-{
-  if(y==0.0)
-    {
-      if(x<0.0)
-	return -M_PI/2.0;
-      else
-	return M_PI/2.0;
-    }
-  else if(y<0.0)
-    {
-      float a=M_PI+atan(x/y);
-      if(a>M_PI)
-	a-=M_PI*2.0;
-      return a;
-    }
-  else
-    return atan(x/y);
-}
+  {
+    if(y==0.0)
+      {
+        if(x<0.0)
+          return -M_PI/2.0;
+        else
+          return M_PI/2.0;
+      }
+    else if(y<0.0)
+      {
+        float a=M_PI+atan(x/y);
+        if(a>M_PI)
+          a-=M_PI*2.0;
+        return a;
+      }
+    else
+      return atan(x/y);
+  }
 
 
 AGAngle AGVector2::getAngle() const
@@ -279,13 +279,13 @@
 }
 
 void AGVector2::setX(float pX)
-{
-  v[0]=pX;
-}
+  {
+    v[0]=pX;
+  }
 void AGVector2::setY(float pY)
-{
-  v[1]=pY;
-}
+  {
+    v[1]=pY;
+  }
 
 float AGVector2::getX() const
 {
@@ -365,10 +365,10 @@
     return *this;
 }
 void AGVector2::normalize()
-{
-  if(length2()!=0.0f)
-    operator/=(length());
-}
+  {
+    if(length2()!=0.0f)
+      operator/=(length());
+  }
 
 float AGVector2::operator[](int index) const
 {
@@ -387,36 +387,36 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGVector3::AGVector3(const AGVector2 &p,float h)
-{
-  v[0]=p[0];
-  v[1]=p[1];
-  v[2]=h;
-}
+  {
+    v[0]=p[0];
+    v[1]=p[1];
+    v[2]=h;
+  }
 
 AGVector3::AGVector3(float pX,float pY,float pZ)
-{
-  v[0]=pX;
-  v[1]=pY;
-  v[2]=pZ;
-}
+  {
+    v[0]=pX;
+    v[1]=pY;
+    v[2]=pZ;
+  }
 AGVector3::AGVector3(const AGVector3 &a)
-{
-  v[0]=a.v[0];
-  v[1]=a.v[1];
-  v[2]=a.v[2];
-}
+  {
+    v[0]=a.v[0];
+    v[1]=a.v[1];
+    v[2]=a.v[2];
+  }
 AGVector3::AGVector3(const AGAngle &a)
-{
-  v[0]=sin(a.angle);
-  v[1]=-cos(a.angle);
-  v[2]=0.0f;
-}
+  {
+    v[0]=sin(a.angle);
+    v[1]=-cos(a.angle);
+    v[2]=0.0f;
+  }
 
 AGVector3::AGVector3()
-{
-  v[0]=v[1]=0;
-  v[2]=0.0f;
-}
+  {
+    v[0]=v[1]=0;
+    v[2]=0.0f;
+  }
 
 AGVector2 AGVector3::dim2() const
 {
@@ -437,11 +437,11 @@
   node.set("z",AGString(v[2]));
 }
 void AGVector3::loadXML(const Node &node)
-{
-  v[0]=node.get("x").toFloat();
-  v[1]=node.get("y").toFloat();
-  v[2]=node.get("z").toFloat();
-}
+  {
+    v[0]=node.get("x").toFloat();
+    v[1]=node.get("y").toFloat();
+    v[2]=node.get("z").toFloat();
+  }
 
 
 
@@ -452,21 +452,21 @@
   if(y==0.0)
     {
       if(x<0.0)
-	return -M_PI/2.0;
+        return -M_PI/2.0;
       else
-	return M_PI/2.0;
+        return M_PI/2.0;
     }
   else if(y<0.0)
     {
       float a=M_PI+atan(x/y);
       if(a>M_PI)
-	a-=M_PI*2.0;
+        a-=M_PI*2.0;
       return a;
     }
   else
     return atan(x/y);
 }
-*/
+ */
 
 AGAngle AGVector3::getAngle() const
 {
@@ -477,7 +477,7 @@
 bool AGVector3::operator==(const AGVector3 &a) const
 {
   float m=std::max(v[0],std::max(v[1],v[2]));
-  
+
   m*=0.0001;
   return fabs(v[0]-a.v[0])<m && fabs(v[1]-a.v[1])<m && fabs(v[2]-a.v[2])<m;
 }
@@ -510,17 +510,17 @@
 }
 
 void AGVector3::setX(float pX)
-{
-  v[0]=pX;
-}
+  {
+    v[0]=pX;
+  }
 void AGVector3::setY(float pY)
-{
-  v[1]=pY;
-}
+  {
+    v[1]=pY;
+  }
 void AGVector3::setZ(float pZ)
-{
-  v[2]=pZ;
-}
+  {
+    v[2]=pZ;
+  }
 
 float AGVector3::getX() const
 {
@@ -543,8 +543,8 @@
 AGVector3 AGVector3::operator%(const AGVector3 &a) const
 {
   return AGVector3(v[1] * a.v[2] - v[2] * a.v[1],
-		   v[2] * a.v[0] - v[0] * a.v[2],
-		   v[0] * a.v[1] - v[1] * a.v[0]);
+      v[2] * a.v[0] - v[0] * a.v[2],
+      v[0] * a.v[1] - v[1] * a.v[0]);
 }
 
 
@@ -608,10 +608,10 @@
     return *this;
 }
 void AGVector3::normalize()
-{
-  if(length2()!=0.0f)
-    operator/=(length());
-}
+  {
+    if(length2()!=0.0f)
+      operator/=(length());
+  }
 
 float AGVector3::operator[](int index) const
 {
@@ -630,47 +630,47 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGMatrix3::AGMatrix3()
-{
-  a[0][1]=a[0][2]=
-    a[1][0]=a[1][2]=
-    a[2][0]=a[2][1]=0.0f;
+  {
+    a[0][1]=a[0][2]=
+      a[1][0]=a[1][2]=
+        a[2][0]=a[2][1]=0.0f;
 
-  a[0][0]=a[1][1]=a[2][2]=1.0f;
-}
+    a[0][0]=a[1][1]=a[2][2]=1.0f;
+  }
 
 AGMatrix3::AGMatrix3(const AGAngle &n)
-{
-  a[0][0]=cos(n.angle);
-  a[1][0]=sin(n.angle);
-  a[0][1]=-sin(n.angle);
-  a[1][1]=cos(n.angle);
-  a[2][0]=a[2][1]=a[0][2]=a[1][2]=0.0f;
-  a[2][2]=1.0f;
-}
+  {
+    a[0][0]=cos(n.angle);
+    a[1][0]=sin(n.angle);
+    a[0][1]=-sin(n.angle);
+    a[1][1]=cos(n.angle);
+    a[2][0]=a[2][1]=a[0][2]=a[1][2]=0.0f;
+    a[2][2]=1.0f;
+  }
 
 AGMatrix3::AGMatrix3(const AGVector3 &n)
-{
-  a[0][0]=a[1][1]=a[2][2]=1.0f;
-  a[0][1]=a[0][2]=
-    a[1][0]=a[1][2]=
-    a[2][0]=a[2][1]=0.0f;
-  a[2][0]=n[0];
-  a[2][1]=n[1];
-}
+  {
+    a[0][0]=a[1][1]=a[2][2]=1.0f;
+    a[0][1]=a[0][2]=
+      a[1][0]=a[1][2]=
+        a[2][0]=a[2][1]=0.0f;
+    a[2][0]=n[0];
+    a[2][1]=n[1];
+  }
 
 AGMatrix3::AGMatrix3(float x,float y)
-{
-  a[0][0]=x;
-  a[1][1]=y;
-  a[2][2]=1.0f;
-  a[0][1]=a[0][2]=
-    a[1][0]=a[1][2]=
-    a[2][0]=a[2][1]=0.0f;
-  a[2][0]=0.0f;
-  a[2][1]=0.0f;
-  
-}
+  {
+    a[0][0]=x;
+    a[1][1]=y;
+    a[2][2]=1.0f;
+    a[0][1]=a[0][2]=
+      a[1][0]=a[1][2]=
+        a[2][0]=a[2][1]=0.0f;
+    a[2][0]=0.0f;
+    a[2][1]=0.0f;
 
+  }
+
 AGMatrix3 AGMatrix3::transposed() const
 {
   AGMatrix3 a;
@@ -692,40 +692,40 @@
 }
 
 void AGMatrix3::swapRows(size_t a,size_t b)
-{
-  if(a==b)
-    return;
-  assert(a<3);
-  assert(b<3);
-  for(size_t x=0;x<3;x++)
-    {
-      float t=get(x,a);
-      set(x,a,get(x,b));
-      set(x,b,t);
-    }
-}
+  {
+    if(a==b)
+      return;
+    assert(a<3);
+    assert(b<3);
+    for(size_t x=0;x<3;x++)
+      {
+        float t=get(x,a);
+        set(x,a,get(x,b));
+        set(x,b,t);
+      }
+  }
 
 void AGMatrix3::swapCols(size_t a,size_t b)
-{
-  if(a==b)
-    return;
-  assert(a<3);
-  assert(b<3);
-  for(size_t y=0;y<3;y++)
-    {
-      float t=get(a,y);
-      set(a,y,get(b,y));
-      set(b,y,t);
-    }
-}
+  {
+    if(a==b)
+      return;
+    assert(a<3);
+    assert(b<3);
+    for(size_t y=0;y<3;y++)
+      {
+        float t=get(a,y);
+        set(a,y,get(b,y));
+        set(b,y,t);
+      }
+  }
 
 
 void AGMatrix3::set(size_t x,size_t y,float f)
-{
-  assert(x>=0 && x<3);
-  assert(y>=0 && y<3);
-  a[x][y]=f;
-}
+  {
+    assert(x>=0 && x<3);
+    assert(y>=0 && y<3);
+    a[x][y]=f;
+  }
 float AGMatrix3::get(size_t x,size_t y) const
 {
   assert(x>=0 && x<3);
@@ -734,11 +734,11 @@
 }
 
 float &AGMatrix3::get(size_t x,size_t y)
-{
-  assert(x>=0 && x<3);
-  assert(y>=0 && y<3);
-  return a[x][y];
-}
+  {
+    assert(x>=0 && x<3);
+    assert(y>=0 && y<3);
+    return a[x][y];
+  }
 
 AGMatrix3::Row AGMatrix3::operator[](size_t y)
 {
@@ -773,8 +773,8 @@
   for(x=0;x<3;x++)
     for(y=0;y<3;y++)
       n.a[x][y]=a[0][y]*m.a[x][0]+
-	a[1][y]*m.a[x][1]+
-	a[2][y]*m.a[x][2];
+      a[1][y]*m.a[x][1]+
+      a[2][y]*m.a[x][2];
   return n;
 }
 AGMatrix3 &AGMatrix3::operator*=(const AGMatrix3 &m)
@@ -786,8 +786,8 @@
 AGVector3 AGMatrix3::operator*(const AGVector3 &v) const
 {
   return AGVector3(a[0][0]*v[0]+a[1][0]*v[1]+a[2][0]*v[2],
-		   a[0][1]*v[0]+a[1][1]*v[1]+a[2][1]*v[2],
-		   a[0][2]*v[0]+a[1][2]*v[1]+a[2][2]*v[2]);
+      a[0][1]*v[0]+a[1][1]*v[1]+a[2][1]*v[2],
+      a[0][2]*v[0]+a[1][2]*v[1]+a[2][2]*v[2]);
 }
 
 AGString AGMatrix3::toString() const
@@ -804,11 +804,11 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGTriangle2::AGTriangle2(const AGVector2 &v0,const AGVector2 &v1,const AGVector2 &v2)
-{
-  p[0]=v0;
-  p[1]=v1;
-  p[2]=v2;
-}
+  {
+    p[0]=v0;
+    p[1]=v1;
+    p[2]=v2;
+  }
 
 AGRect2 AGTriangle2::getBBox() const
 {
@@ -822,11 +822,11 @@
 
 
 void AGTriangle2::apply(const AGMatrix3 &m)
-{
-  p[0]=(m*AGVector3(p[0],1)).dim2();
-  p[1]=(m*AGVector3(p[1],1)).dim2();
-  p[2]=(m*AGVector3(p[2],1)).dim2();
-}
+  {
+    p[0]=(m*AGVector3(p[0],1)).dim2();
+    p[1]=(m*AGVector3(p[1],1)).dim2();
+    p[2]=(m*AGVector3(p[2],1)).dim2();
+  }
 
 /* FIXME: this will be some sweep-base collision detection,
    HOWEVER there's the angular-velocity still missing :-(
@@ -847,27 +847,27 @@
       float min1,min2,max1,max2;
       size_t j;
       for(j=0;j<3;j++)
-	{
-	  if(j==0)
-	    {
-	      min1=max1=(*i)*p[j];
-	      min2=max2=(*i)*t.p[j];
-	    }
-	  else
-	    {
-	      float v0=(*i)*p[j];
-	      float v1=(*i)*t.p[j];
-	      min1=std::min(min1,v0);
-	      max1=std::max(max1,v0);
-	      min2=std::min(min2,v1);
-	      max2=std::max(max2,v1);
-	    }
-	}
+      {
+        if(j==0)
+          {
+            min1=max1=(*i)*p[j];
+            min2=max2=(*i)*t.p[j];
+          }
+        else
+          {
+            float v0=(*i)*p[j];
+            float v1=(*i)*t.p[j];
+            min1=std::min(min1,v0);
+            max1=std::max(max1,v0);
+            min2=std::min(min2,v1);
+            max2=std::max(max2,v1);
+          }
+      }
       
       float a1=
     }
 }
-*/
+ */
 
 std::vector<AGVector2> AGTriangle2::collisionPoints(const AGLine2 &l) const
 {
@@ -880,7 +880,7 @@
     {
       p=i->collisionPoint(l);
       if(p!=invalidVec2)
-	ps.push_back(p);
+        ps.push_back(p);
     }
   return ps;
 }
@@ -888,8 +888,8 @@
 AGTriangle2 AGTriangle2::applied(const AGMatrix3 &m) const
 {
   return AGTriangle2((m*AGVector3(p[0],1)).dim2(),
-		     (m*AGVector3(p[1],1)).dim2(),
-		     (m*AGVector3(p[2],1)).dim2());
+      (m*AGVector3(p[1],1)).dim2(),
+      (m*AGVector3(p[2],1)).dim2());
 }
 
 AGString AGTriangle2::toString() const
@@ -921,24 +921,24 @@
       float min1,min2,max1,max2;
       size_t j;
       for(j=0;j<3;j++)
-	{
-	  if(j==0)
-	    {
-	      min1=max1=(*i)*p[j];
-	      min2=max2=(*i)*t.p[j];
-	    }
-	  else
-	    {
-	      float v0=(*i)*p[j];
-	      float v1=(*i)*t.p[j];
-	      min1=std::min(min1,v0);
-	      max1=std::max(max1,v0);
-	      min2=std::min(min2,v1);
-	      max2=std::max(max2,v1);
-	    }
-	}
+        {
+          if(j==0)
+            {
+              min1=max1=(*i)*p[j];
+              min2=max2=(*i)*t.p[j];
+            }
+          else
+            {
+              float v0=(*i)*p[j];
+              float v1=(*i)*t.p[j];
+              min1=std::min(min1,v0);
+              max1=std::max(max1,v0);
+              min2=std::min(min2,v1);
+              max2=std::max(max2,v1);
+            }
+        }
       if(!collide1d(min1,max1,min2,max2))
-	return false;
+        return false;
     }
   return true;
 }
@@ -968,7 +968,7 @@
   if(AGsign((pp-p[0])*l[0])==AGsign((p[2]-p[0])*l[0]))
     if(AGsign((pp-p[1])*l[1])==AGsign((p[0]-p[1])*l[1]))
       if(AGsign((pp-p[2])*l[2])==AGsign((p[1]-p[2])*l[2]))
-	return true;
+        return true;
   return false;
 }
 
@@ -980,9 +980,9 @@
   for(i=0;i<3;i++)
     {
       if(contains(t[i]))
-	return t[i];
+        return t[i];
       else if(t.contains((*this)[i]))
-	return (*this)[i];
+        return (*this)[i];
     }
   return invalidVec2;
 }
@@ -1002,34 +1002,34 @@
   for(i=l0.begin();i!=l0.end();i++)
     for(j=l1.begin();j!=l1.end();j++)
       {
-	if(i->collide(*j))
-	  {
-	    sum[&(*i)]++;
-	    sum[&(*j)]++;
-	  }
+        if(i->collide(*j))
+          {
+            sum[&(*i)]++;
+            sum[&(*j)]++;
+          }
       }
   std::map<AGLine2*,int>::iterator k=sum.begin();
   for(;k!=sum.end();k++)
     {
       if(k->second==2)
-	return k->first->normal();
+        return k->first->normal();
     }
 
   // FIXME: not found - find other approximation
 
   //#else
-  {
-  size_t i;
-  for(i=0;i<3;i++)
     {
-      if(contains(t[i]))
-	return nearestLine(t[i]).normal();
-      else if(t.contains((*this)[i]))
-	return t.nearestLine((*this)[i]).normal();
+      size_t i;
+      for(i=0;i<3;i++)
+        {
+          if(contains(t[i]))
+            return nearestLine(t[i]).normal();
+          else if(t.contains((*this)[i]))
+            return t.nearestLine((*this)[i]).normal();
+        }
+      return invalidVec2;
     }
-  return invalidVec2;
-  }
-  //#endif
+    //#endif
 }
 
 AGLine2 AGTriangle2::nearestLine(const AGVector2 &v) const
@@ -1113,11 +1113,11 @@
 // AGTriangle3
 /////////////////////////////////////////////////////////////////////////////
 AGTriangle3::AGTriangle3(const AGVector3 &v0,const AGVector3 &v1,const AGVector3 &v2)
-{
-  p[0]=v0;
-  p[1]=v1;
-  p[2]=v2;
-}
+  {
+    p[0]=v0;
+    p[1]=v1;
+    p[2]=v2;
+  }
 
 AGVector4 AGTriangle3::collide(const AGLine3 &pLine) const
 {
@@ -1188,52 +1188,52 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGRect2::AGRect2(const SDL_Rect &r)
-{
-  v0=AGVector2(r.x,r.y);
-  v1=AGVector2(r.x+r.w,r.y+r.h);
-}
+  {
+    v0=AGVector2(r.x,r.y);
+    v1=AGVector2(r.x+r.w,r.y+r.h);
+  }
 
 
 AGRect2::AGRect2(const AGString &ps)
-{
-  std::istringstream is;
-  char c;
-  float x,y,w,h;
-  is.str(ps);
-  is>>c;
-  is>>x;
-  is>>c;
-  is>>y;
-  is>>c;
-  is>>w;
-  is>>c;
-  is>>h;
-  is>>c;
-  v0=AGVector2(x,y);
-  v1=AGVector2(x+w,y+h);
-}
+  {
+    std::istringstream is;
+    char c;
+    float x,y,w,h;
+    is.str(ps);
+    is>>c;
+    is>>x;
+    is>>c;
+    is>>y;
+    is>>c;
+    is>>w;
+    is>>c;
+    is>>h;
+    is>>c;
+    v0=AGVector2(x,y);
+    v1=AGVector2(x+w,y+h);
+  }
 
 
 AGRect2::AGRect2()
-{
-}
+  {
+  }
 
 AGRect2::AGRect2(const AGVector2 &pv0,const AGVector2 &pv1):
   v0(pv0),v1(pv1)
-{
-}
+  {
+  }
 
 AGRect2::AGRect2(float x,float y,float w,float h):
   v0(x,y),v1(x+w,y+h)
-{
-}
+  {
+  }
 
 AGRect2 AGRect2::alignGrid() const
 {
   return AGRect2((int)x(),
-		 (int)y(),
-		 (int)w(),
-		 (int)h());
+      (int)y(),
+      (int)w(),
+      (int)h());
 }
 
 
@@ -1281,7 +1281,7 @@
     my0=my1;
 
   return AGRect2(AGVector2(mx0,my0),
-		 AGVector2(mx1,my1));
+      AGVector2(mx1,my1));
 }
 
 std::vector<AGRect2> AGRect2::difference(const AGRect2 &r) const
@@ -1290,46 +1290,46 @@
   for(int i=0;i<3;i++)
     for(int j=0;j<3;j++)
       {
-	
-	float nx,ny,nw,nh;
-	
-	switch(i)
-	  {
-	  case 0:
-	    nx=x0();
-	    nw=r.x0()-x0();
-	    break;
-	  case 1:
-	    nx=r.x0();
-	    nw=r.x1()-r.x0();
-	    break;
-	  case 2:
-	    nx=r.x1();
-	    nw=x1()-r.x1();
-	    break;
-	  };
-	switch(j)
-	  {
-	  case 0:
-	    ny=y0();
-	    nh=r.y0()-y0();
-	    break;
-	  case 1:
-	    ny=r.y0();
-	    nh=r.y1()-r.y0();
-	    break;
-	  case 2:
-	    ny=r.y1();
-	    nh=y1()-r.y1();
-	    break;
-	  };
-	if(nw>0 && nh>0)
-	  {
-	    AGRect2 n=intersect(AGRect2(nx,ny,nw,nh));
-	    if(n.w()>0 && n.h()>0)
-	      if(!r.contains(n))
-		l.push_back(n);
-	  }
+
+        float nx,ny,nw,nh;
+
+        switch(i)
+        {
+        case 0:
+          nx=x0();
+          nw=r.x0()-x0();
+          break;
+        case 1:
+          nx=r.x0();
+          nw=r.x1()-r.x0();
+          break;
+        case 2:
+          nx=r.x1();
+          nw=x1()-r.x1();
+          break;
+        };
+        switch(j)
+        {
+        case 0:
+          ny=y0();
+          nh=r.y0()-y0();
+          break;
+        case 1:
+          ny=r.y0();
+          nh=r.y1()-r.y0();
+          break;
+        case 2:
+          ny=r.y1();
+          nh=y1()-r.y1();
+          break;
+        };
+        if(nw>0 && nh>0)
+          {
+            AGRect2 n=intersect(AGRect2(nx,ny,nw,nh));
+            if(n.w()>0 && n.h()>0)
+              if(!r.contains(n))
+                l.push_back(n);
+          }
       }
   return l;
 }
@@ -1339,27 +1339,27 @@
 AGVector2 AGRect2::operator[](size_t i) const
 {
   switch(i)
-    {
-    case 0:
-      return v0;
-    case 1:
-      return v1;
-    default:
-      throw AGString("invalid index in AGRect2::operator[]");
-    }
+  {
+  case 0:
+    return v0;
+  case 1:
+    return v1;
+  default:
+    throw AGString("invalid index in AGRect2::operator[]");
+  }
   return v0;
 }
 AGVector2 &AGRect2::operator[](size_t i)
 {
   switch(i)
-    {
-    case 0:
-      return v0;
-    case 1:
-      return v1;
-    default:
-      throw AGString("invalid index in AGRect2::operator[]");
-    }
+  {
+  case 0:
+    return v0;
+  case 1:
+    return v1;
+  default:
+    throw AGString("invalid index in AGRect2::operator[]");
+  }
   return v0;
 }
 
@@ -1399,15 +1399,15 @@
 }
 
 float AGRect2::setWidth(float w)
-{
-  v1[0]=v0[0]+w;
-  return w;
-}
+  {
+    v1[0]=v0[0]+w;
+    return w;
+  }
 float AGRect2::setHeight(float h)
-{
-  v1[1]=v0[1]+h;
-  return h;
-}
+  {
+    v1[1]=v0[1]+h;
+    return h;
+  }
 
 float AGRect2::x0() const
 {
@@ -1438,12 +1438,12 @@
 
 
 void AGRect2::include(const AGVector2 &v)
-{
-  v0[0]=std::min(v0[0],v[0]);
-  v0[1]=std::min(v0[1],v[1]);
-  v1[0]=std::max(v1[0],v[0]);
-  v1[1]=std::max(v1[1],v[1]);
-}
+  {
+    v0[0]=std::min(v0[0],v[0]);
+    v0[1]=std::min(v0[1],v[1]);
+    v1[0]=std::max(v1[0],v[0]);
+    v1[1]=std::max(v1[1],v[1]);
+  }
 
 
 std::list<AGRect2> AGRect2::split() const
@@ -1494,39 +1494,39 @@
 
 
 void AGRect2::setX(float p)
-{
-  float mw=w();
-  v0.setX(p);
-  v1.setX(p+mw);
-}
+  {
+    float mw=w();
+    v0.setX(p);
+    v1.setX(p+mw);
+  }
 void AGRect2::setY(float p)
-{
-  float mh=h();
-  v0.setY(p);
-  v1.setY(p+mh);
-}
+  {
+    float mh=h();
+    v0.setY(p);
+    v1.setY(p+mh);
+  }
 
 void AGRect2::setLeft(float p)
-{
-  float mw=w();
-  v0.setX(p);
-  v1.setX(p+mw);
-}
+  {
+    float mw=w();
+    v0.setX(p);
+    v1.setX(p+mw);
+  }
 void AGRect2::setTop(float p)
-{
-  float mh=h();
-  v0.setY(p);
-  v1.setY(p+mh);
-}
+  {
+    float mh=h();
+    v0.setY(p);
+    v1.setY(p+mh);
+  }
 
 void AGRect2::setRight(float p)
-{
-  v1.setX(p);
-}
+  {
+    v1.setX(p);
+  }
 void AGRect2::setBottom(float p)
-{
-  v1.setY(p);
-}
+  {
+    v1.setY(p);
+  }
 
 
 
@@ -1585,42 +1585,42 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGLine2::AGLine2()
-{
-}
+  {
+  }
 
 AGLine2::AGLine2(const AGVector2 &pv0,const AGVector2 &pv1):
   v0(pv0),v1(pv1)
-{
-}
+  {
+  }
 
 AGVector2 &AGLine2::operator[](size_t i)
 {
   switch(i)
-    {
-    case 0:
-      return v0;
-    case 1:
-      return v1;
-    default:
-      throw AGString("wrong index in AGLine::op[]");
-    }
+  {
+  case 0:
+    return v0;
+  case 1:
+    return v1;
+  default:
+    throw AGString("wrong index in AGLine::op[]");
+  }
   return v0;
 }
 AGVector2 AGLine2::operator[](size_t i) const
 {
   switch(i)
-    {
-    case 0:
-      return v0;
-    case 1:
-      return v1;
-    default:
-      throw AGString("wrong index in AGLine::op[]");
-    }
+  {
+  case 0:
+    return v0;
+  case 1:
+    return v1;
+  default:
+    throw AGString("wrong index in AGLine::op[]");
+  }
   return v0;
 }
 
-  
+
 AGVector2 AGLine2::getV0() const
 {
   return v0;
@@ -1645,19 +1645,19 @@
   ldy = l.v1.getY() - l.v0.getY();
 
   AGVector2 p;
-  
+
   if(dx==0.0f)
     {
       if(ldx==0.0f)
-	return invalidVec2; // invalid
-      
+        return invalidVec2; // invalid
+
       // ldy!=0 !!
       float lm = ldy/ldx;
       float lb = l.v0.getY() - lm * l.v0.getX();
 
       //      cdebug(lm);
       //      cdebug(lb);
-      
+
       assert(lm!=0.0f);
       p=AGVector2(v0.getX(),lm*v0.getX()+lb);
     }
@@ -1674,7 +1674,7 @@
       float lb=l.v0.getY() - lm * l.v0.getX();
 
       if(m == lm)
-	return AGVector2(0,0); // parallel
+        return AGVector2(0,0); // parallel
       float x=(lb-b)/(m-lm); 
       p=AGVector2(x,m*x+b);
     }
@@ -1688,10 +1688,10 @@
   // check for inclusion
   if(includes(p) && l.includes(p))
     {
-    assert(distance(p)<0.01);
-    assert(l.distance(p)<0.01);
-    return p;
-  }
+      assert(distance(p)<0.01);
+      assert(l.distance(p)<0.01);
+      return p;
+    }
   else
     return invalidVec2;
 }
@@ -1700,12 +1700,12 @@
 {
   float f=(v-v0)*((v1-v0).normalized());
   if(f>=0 && f<(v1-v0).length())
-  {
-    /*    cdebug(v0.toString()<<"  "<<v1.toString()<<"  "<<v.toString());
+    {
+      /*    cdebug(v0.toString()<<"  "<<v1.toString()<<"  "<<v.toString());
     cdebug((v-v0).toString()<<"   "<<(v1-v0).toString()<<"   "<<(v1-v0).normalized().toString()<<"   "<<(v1-v0).length());
     cdebug(f);*/
-    return true;
-  }
+      return true;
+    }
   return false;
 }
 
@@ -1723,7 +1723,7 @@
   d1=l.direction();
   n0=normal();
   n1=l.normal();
-  
+
   bool t0=collide1d(v0*d0,v1*d0,l.v0*d0,l.v1*d0,false);
   bool t1=collide1d(v0*d1,v1*d1,l.v0*d1,l.v1*d1,false);
 
@@ -1763,13 +1763,13 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGLine3::AGLine3()
-{
-}
+  {
+  }
 
 AGLine3::AGLine3(const AGVector3 &pv0,const AGVector3 &pv1):
   v0(pv0),v1(pv1)
-{
-}
+  {
+  }
 
 float AGLine3::distance(const AGVector3 &p) const
 {
@@ -1781,7 +1781,7 @@
   return fabs(diff*plane_normal);
 }
 
-  
+
 AGVector3 AGLine3::getV0() const
 {
   return v0;
@@ -1822,26 +1822,26 @@
 
 
 AGVector4::AGVector4(float pX,float pY,float pZ,float pW)
-{
-  v[0]=pX;
-  v[1]=pY;
-  v[2]=pZ;
-  v[3]=pW;
-}
+  {
+    v[0]=pX;
+    v[1]=pY;
+    v[2]=pZ;
+    v[3]=pW;
+  }
 AGVector4::AGVector4(const AGVector4 &a)
-{
-  v[0]=a.v[0];
-  v[1]=a.v[1];
-  v[2]=a.v[2];
-  v[3]=a.v[3];
-}
+  {
+    v[0]=a.v[0];
+    v[1]=a.v[1];
+    v[2]=a.v[2];
+    v[3]=a.v[3];
+  }
 AGVector4::AGVector4(const AGVector3 &a,float h)
-{
-  v[0]=a.v[0];
-  v[1]=a.v[1];
-  v[2]=a.v[2];
-  v[3]=h;
-}
+  {
+    v[0]=a.v[0];
+    v[1]=a.v[1];
+    v[2]=a.v[2];
+    v[3]=h;
+  }
 
 AGVector3 AGVector4::dim3() const
 {
@@ -1854,10 +1854,10 @@
 
 
 AGVector4::AGVector4()
-{
-  v[0]=v[1]=v[2]=0.0f;
-  v[3]=1.0f;
-}
+  {
+    v[0]=v[1]=v[2]=0.0f;
+    v[3]=1.0f;
+  }
 
 AGVector4 AGVector4::operator-() const
 {
@@ -1866,21 +1866,21 @@
 
 
 void AGVector4::setX(float pX)
-{
-  v[0]=pX;
-}
+  {
+    v[0]=pX;
+  }
 void AGVector4::setY(float pY)
-{
-  v[1]=pY;
-}
+  {
+    v[1]=pY;
+  }
 void AGVector4::setZ(float pZ)
-{
-  v[2]=pZ;
-}
+  {
+    v[2]=pZ;
+  }
 void AGVector4::setW(float pW)
-{
-  v[3]=pW;
-}
+  {
+    v[3]=pW;
+  }
 
 float AGVector4::getX() const
 {
@@ -1902,16 +1902,16 @@
 AGVector4 AGVector4::operator-(const AGVector4 &p) const
 {
   return AGVector4(v[0]-p.v[0],
-		   v[1]-p.v[1],
-		   v[2]-p.v[2],
-		   v[3]-p.v[3]);
+      v[1]-p.v[1],
+      v[2]-p.v[2],
+      v[3]-p.v[3]);
 }
 AGVector4 AGVector4::operator+(const AGVector4 &p) const
 {
   return AGVector4(v[0]+p.v[0],
-		   v[1]+p.v[1],
-		   v[2]+p.v[2],
-		   v[3]+p.v[3]);
+      v[1]+p.v[1],
+      v[2]+p.v[2],
+      v[3]+p.v[3]);
 }
 AGVector4 &AGVector4::operator+=(const AGVector4 &p)
 {
@@ -1933,9 +1933,9 @@
 float AGVector4::operator*(const AGVector4 &p) const
 {
   return v[0]*p.v[0]+
-    v[1]*p.v[1]+
-    v[2]*p.v[2]+
-    v[3]*p.v[3];
+  v[1]*p.v[1]+
+  v[2]*p.v[2]+
+  v[3]*p.v[3];
 }
 AGVector4 &AGVector4::operator*=(float f)
 {
@@ -1965,9 +1965,9 @@
 bool AGVector4::operator==(const AGVector4 &a) const
 {
   return v[0]==a.v[0] &&
-    v[1]==a.v[1] &&
-    v[2]==a.v[2] &&
-    v[3]==a.v[3];
+  v[1]==a.v[1] &&
+  v[2]==a.v[2] &&
+  v[3]==a.v[3];
 }
 bool AGVector4::operator!=(const AGVector4 &a) const
 {
@@ -1981,9 +1981,9 @@
 float AGVector4::length2() const
 {
   return v[0]*v[0]+
-    v[1]*v[1]+
-    v[2]*v[2]+
-    v[3]*v[3];
+  v[1]*v[1]+
+  v[2]*v[2]+
+  v[3]*v[3];
 }
 
 float AGVector4::length3() const
@@ -1996,18 +1996,18 @@
   return *this*(1.0f/length());
 }
 void AGVector4::normalize()
-{
-  operator*=(1.0f/length());
-}
+  {
+    operator*=(1.0f/length());
+  }
 
 AGVector4 AGVector4::normalized3() const
 {
   return *this*(1.0f/length3());
 }
 void AGVector4::normalize3()
-{
-  operator*=(1.0f/length3());
-}
+  {
+    operator*=(1.0f/length3());
+  }
 
 float &AGVector4::operator[](int index)
 {
@@ -2024,9 +2024,9 @@
 bool AGVector4::nonZero() const
 {
   return v[0]!=0 ||
-    v[1]!=0 ||
-    v[2]!=0 ||
-    v[3]!=0;
+  v[1]!=0 ||
+  v[2]!=0 ||
+  v[3]!=0;
 }
 
 AGString AGVector4::toString() const
@@ -2049,8 +2049,8 @@
 AGVector4 AGVector4::operator%(const AGVector4 &a) const
 {
   return AGVector4(v[1] * a.v[2] - v[2] * a.v[1],
-		   v[2] * a.v[0] - v[0] * a.v[2],
-		   v[0] * a.v[1] - v[1] * a.v[0]);
+      v[2] * a.v[0] - v[0] * a.v[2],
+      v[0] * a.v[1] - v[1] * a.v[0]);
 }
 
 ///////////////////////////////////////////////////////////////
@@ -2058,15 +2058,15 @@
 ///////////////////////////////////////////////////////////////
 
 AGMatrix4::AGMatrix4(float v[16])
-{
-  for(size_t i=0;i<16;i++)
-    a[i]=v[i];
-}
+  {
+    for(size_t i=0;i<16;i++)
+      a[i]=v[i];
+  }
 AGMatrix4::AGMatrix4(float angle,const AGVector3&d)
-{
-  float co=cos(angle);
-  float si=sin(angle);
-  /*
+  {
+    float co=cos(angle);
+    float si=sin(angle);
+    /*
   set(0,0,co + d[0]*d[0]*(1-co));
   set(0,1,d[0]*d[1]*(1-co)-d[2]*si);
   set(0,2,d[0]*d[2]*(1-co)+d[1]*si);
@@ -2078,40 +2078,40 @@
   set(2,0,d[2]*d[0]*(1-co)-d[1]*si);
   set(2,1,d[2]*d[1]*(1-co)+d[0]*si);
   set(2,2,co + d[2]*d[2]*(1-co));
-  */
+     */
     set(0,0,co + d[0]*d[0]*(1-co));
-  set(1,0,d[0]*d[1]*(1-co)-d[2]*si);
-  set(2,0,d[0]*d[2]*(1-co)+d[1]*si);
+    set(1,0,d[0]*d[1]*(1-co)-d[2]*si);
+    set(2,0,d[0]*d[2]*(1-co)+d[1]*si);
 
-  set(0,1,d[1]*d[0]*(1-co)+d[2]*si);
-  set(1,1,co+d[1]*d[1]*(1-co));
-  set(2,1,d[1]*d[2]*(1-co)-d[0]*si);
+    set(0,1,d[1]*d[0]*(1-co)+d[2]*si);
+    set(1,1,co+d[1]*d[1]*(1-co));
+    set(2,1,d[1]*d[2]*(1-co)-d[0]*si);
 
-  set(0,2,d[2]*d[0]*(1-co)-d[1]*si);
-  set(1,2,d[2]*d[1]*(1-co)+d[0]*si);
-  set(2,2,co + d[2]*d[2]*(1-co));
-  
-  set(3,0,0);
-  set(3,1,0);
-  set(3,2,0);
+    set(0,2,d[2]*d[0]*(1-co)-d[1]*si);
+    set(1,2,d[2]*d[1]*(1-co)+d[0]*si);
+    set(2,2,co + d[2]*d[2]*(1-co));
 
-  set(0,3,0);
-  set(1,3,0);
-  set(2,3,0);
+    set(3,0,0);
+    set(3,1,0);
+    set(3,2,0);
 
-  set(3,3,1);
-}
+    set(0,3,0);
+    set(1,3,0);
+    set(2,3,0);
 
+    set(3,3,1);
+  }
 
+
 AGMatrix4::AGMatrix4()
-{
-  get(0,1)=get(0,2)=get(0,3)=
-    get(1,0)=get(1,2)=get(1,3)=
-    get(2,0)=get(2,1)=get(2,3)=
-    get(3,0)=get(3,1)=get(3,2)=0.0f;
+  {
+    get(0,1)=get(0,2)=get(0,3)=
+      get(1,0)=get(1,2)=get(1,3)=
+        get(2,0)=get(2,1)=get(2,3)=
+          get(3,0)=get(3,1)=get(3,2)=0.0f;
 
-  get(0,0)=get(1,1)=get(2,2)=get(3,3)=1.0f;
-}
+    get(0,0)=get(1,1)=get(2,2)=get(3,3)=1.0f;
+  }
 
 /*AGMatrix3::AGMatrix4(const AGAngle &n)
 {
@@ -2124,15 +2124,15 @@
   }*/
 
 AGMatrix4::AGMatrix4(const AGVector4 &n)
-{
-  get(0,0)=get(1,1)=get(2,2)=get(3,3)=1.0f;
-  get(0,1)=get(0,2)=get(0,3)=
-    get(1,0)=get(1,2)=get(1,3)=
-    get(2,0)=get(2,1)=get(2,3)=0.0f;
-  get(3,0)=n[0];
-  get(3,1)=n[1];
-  get(3,2)=n[2];
-}
+  {
+    get(0,0)=get(1,1)=get(2,2)=get(3,3)=1.0f;
+    get(0,1)=get(0,2)=get(0,3)=
+      get(1,0)=get(1,2)=get(1,3)=
+        get(2,0)=get(2,1)=get(2,3)=0.0f;
+    get(3,0)=n[0];
+    get(3,1)=n[1];
+    get(3,2)=n[2];
+  }
 
 AGMatrix4 &AGMatrix4::operator+=(const AGMatrix4 &m)
 {
@@ -2164,32 +2164,32 @@
 }
 
 void AGMatrix4::swapRows(size_t a,size_t b)
-{
-  if(a==b)
-    return;
-  assert(a<4);
-  assert(b<4);
-  for(size_t x=0;x<4;x++)
-    {
-      float t=get(x,a);
-      set(x,a,get(x,b));
-      set(x,b,t);
-    }
-}
+  {
+    if(a==b)
+      return;
+    assert(a<4);
+    assert(b<4);
+    for(size_t x=0;x<4;x++)
+      {
+        float t=get(x,a);
+        set(x,a,get(x,b));
+        set(x,b,t);
+      }
+  }
 
 void AGMatrix4::swapCols(size_t a,size_t b)
-{
-  if(a==b)
-    return;
-  assert(a<4);
-  assert(b<4);
-  for(size_t y=0;y<4;y++)
-    {
-      float t=get(a,y);
-      set(a,y,get(b,y));
-      set(b,y,t);
-    }
-}
+  {
+    if(a==b)
+      return;
+    assert(a<4);
+    assert(b<4);
+    for(size_t y=0;y<4;y++)
+      {
+        float t=get(a,y);
+        set(a,y,get(b,y));
+        set(b,y,t);
+      }
+  }
 
 
 AGMatrix3 AGMatrix4::get3x3(size_t x,size_t y) const
@@ -2205,11 +2205,11 @@
 
 
 void AGMatrix4::set(size_t x,size_t y,float f)
-{
-  assert(x>=0 && x<4);
-  assert(y>=0 && y<4);
-  a[x*4+y]=f;
-}
+  {
+    assert(x>=0 && x<4);
+    assert(y>=0 && y<4);
+    a[x*4+y]=f;
+  }
 float AGMatrix4::get(size_t x,size_t y) const
 {
   assert(x>=0 && x<4);
@@ -2218,11 +2218,11 @@
 }
 
 float &AGMatrix4::get(size_t x,size_t y)
-{
-  assert(x>=0 && x<4);
-  assert(y>=0 && y<4);
-  return a[4*x+y];
-}
+  {
+    assert(x>=0 && x<4);
+    assert(y>=0 && y<4);
+    return a[4*x+y];
+  }
 
 AGMatrix4 AGMatrix4::operator*(const AGMatrix4 &m) const
 {
@@ -2231,9 +2231,9 @@
   for(x=0;x<4;x++)
     for(y=0;y<4;y++)
       n(x,y)=get(0,y)*m(x,0)+
-	get(1,y)*m(x,1)+
-	get(2,y)*m(x,2)+
-	get(3,y)*m(x,3);
+      get(1,y)*m(x,1)+
+      get(2,y)*m(x,2)+
+      get(3,y)*m(x,3);
   return n;
 }
 AGMatrix4 &AGMatrix4::operator*=(const AGMatrix4 &m)
@@ -2245,9 +2245,9 @@
 AGVector4 AGMatrix4::operator*(const AGVector4 &v) const
 {
   return AGVector4(get(0,0)*v[0]+get(1,0)*v[1]+get(2,0)*v[2]+get(3,0)*v[3],
-		   get(0,1)*v[0]+get(1,1)*v[1]+get(2,1)*v[2]+get(3,1)*v[3],
-		   get(0,2)*v[0]+get(1,2)*v[1]+get(2,2)*v[2]+get(3,2)*v[3],
-		   get(0,3)*v[0]+get(1,3)*v[1]+get(2,3)*v[2]+get(3,3)*v[3]);
+      get(0,1)*v[0]+get(1,1)*v[1]+get(2,1)*v[2]+get(3,1)*v[3],
+      get(0,2)*v[0]+get(1,2)*v[1]+get(2,2)*v[2]+get(3,2)*v[3],
+      get(0,3)*v[0]+get(1,3)*v[1]+get(2,3)*v[2]+get(3,3)*v[3]);
 }
 
 AGString AGMatrix4::toString() const
@@ -2318,16 +2318,16 @@
 
 AGBox3::AGBox3(const AGVector3 &pBase,const AGVector3 &pDir):
   base(pBase),dir(pDir)
-{
-  // assert that pDir[i]>0
-  for(size_t i=0;i<3;i++)
-    if(dir[i]<0)
-      {
-	base[i]+=dir[i];
-	dir[i]=-dir[i];
-      }
-  mValid=true;
-}
+  {
+    // assert that pDir[i]>0
+    for(size_t i=0;i<3;i++)
+      if(dir[i]<0)
+        {
+          base[i]+=dir[i];
+          dir[i]=-dir[i];
+        }
+    mValid=true;
+  }
 
 
 
@@ -2356,9 +2356,9 @@
       AGVector4 p(frustum*AGVector4(*i,1));
       p/=p[3];
       if(p[0]>=-1 && p[0]<=1 &&
-	 p[1]>=-1 && p[1]<=1 &&
-	 p[2]>=-1 && p[2]<=1)
-	return true;
+          p[1]>=-1 && p[1]<=1 &&
+          p[2]>=-1 && p[2]<=1)
+        return true;
 
       minx=std::min(minx,p[0]);
       miny=std::min(miny,p[1]);
@@ -2367,7 +2367,7 @@
       maxx=std::max(maxx,p[0]);
       maxy=std::max(maxy,p[1]);
       maxz=std::max(maxz,p[2]);
-	
+
     }
 
   return AGBox3(AGVector3(-1,-1,-1),AGVector3(2,2,2)).collides(AGBox3(AGVector3(minx,miny,minz),AGVector3(maxx-minx,maxy-miny,maxz-minz)));
@@ -2384,11 +2384,11 @@
   cdebug(collide1d(base[0],a[0],box.base[0],b[0]));
   cdebug(collide1d(base[1],a[1],box.base[1],b[1]));
   cdebug(collide1d(base[2],a[2],box.base[2],b[2]));
-  */
+   */
 
   return collide1d(base[0],a[0],box.base[0],b[0]) &&
-    collide1d(base[1],a[1],box.base[1],b[1]) &&
-    collide1d(base[2],a[2],box.base[2],b[2]);
+  collide1d(base[1],a[1],box.base[1],b[1]) &&
+  collide1d(base[2],a[2],box.base[2],b[2]);
 }
 
 
@@ -2426,32 +2426,32 @@
 
 
 void AGBox3::include(const AGVector3&p)
-{
-  if(!mValid)
-    {
-      base=p;
-      dir=AGVector3(0,0,0);
-      mValid=true;
-      return;
-    }
-  AGVector3 b=base,b2=base+dir;
+  {
+    if(!mValid)
+      {
+        base=p;
+        dir=AGVector3(0,0,0);
+        mValid=true;
+        return;
+      }
+    AGVector3 b=base,b2=base+dir;
 
-  base[0]=std::min(b[0],p[0]);
-  base[1]=std::min(b[1],p[1]);
-  base[2]=std::min(b[2],p[2]);
-  AGVector3 n;
-  n[0]=std::max(b2[0],p[0]);
-  n[1]=std::max(b2[1],p[1]);
-  n[2]=std::max(b2[2],p[2]);
-  dir[0]=n[0]-base[0];
-  dir[1]=n[1]-base[1];
-  dir[2]=n[2]-base[2];
-}
+    base[0]=std::min(b[0],p[0]);
+    base[1]=std::min(b[1],p[1]);
+    base[2]=std::min(b[2],p[2]);
+    AGVector3 n;
+    n[0]=std::max(b2[0],p[0]);
+    n[1]=std::max(b2[1],p[1]);
+    n[2]=std::max(b2[2],p[2]);
+    dir[0]=n[0]-base[0];
+    dir[1]=n[1]-base[1];
+    dir[2]=n[2]-base[2];
+  }
 
 bool AGBox3::collides(const AGVector3&p) const
 {
   return p[0]>=base[0] && p[1]>=base[1] && p[2]>=base[2] &&
-    p[0]<base[0]+dir[0] && p[1]<base[1]+dir[1] && p[2]<base[2]+dir[2];
+  p[0]<base[0]+dir[0] && p[1]<base[1]+dir[1] && p[2]<base[2]+dir[2];
 }
 bool AGBox3::collides(const AGLine3&p) const
 {
@@ -2461,7 +2461,7 @@
   for(std::vector<AGRect3>::iterator i=sides.begin();i!=sides.end();++i)
     {
       if((*i).collides(p))
-	return true;
+        return true;
     }
   return false;
 }
@@ -2489,12 +2489,12 @@
 }
 
 bool AGBox3::includes(const AGBox3 &b)
-{
-  AGVector3 u0=base+dir;
-  AGVector3 u1=b.base+b.dir;
-  return (b.base[0]>=base[0] && b.base[1]>=base[1] && b.base[2]>=base[2] &&
-	  u1[0]<=u0[0] && u1[1]<=u0[1] && u1[2]<=u0[2]);
-}
+  {
+    AGVector3 u0=base+dir;
+    AGVector3 u1=b.base+b.dir;
+    return (b.base[0]>=base[0] && b.base[1]>=base[1] && b.base[2]>=base[2] &&
+        u1[0]<=u0[0] && u1[1]<=u0[1] && u1[2]<=u0[2]);
+  }
 
 AGString AGBox3::toString() const
 {
@@ -2527,15 +2527,15 @@
 
 AGRect3::AGRect3(const AGVector3 &pBase,const AGVector3 &pDir):
   base(pBase),dir(pDir)
-{
-  // assert that dir[i]>=0
-  for(size_t i=0;i<3;i++)
-    if(dir[i]<0)
-      {
-	base[i]+=dir[i];
-	dir[i]=-dir[i];
-      }
-}
+  {
+    // assert that dir[i]>=0
+    for(size_t i=0;i<3;i++)
+      if(dir[i]<0)
+        {
+          base[i]+=dir[i];
+          dir[i]=-dir[i];
+        }
+  }
 
 bool AGRect3::collides(const AGLine3&pLine) const
 {
@@ -2569,16 +2569,15 @@
 
   //  cdebug("ip:"<<ip.toString());
   //  cdebug("dist:"<<(ip-base)*normal);
-  
+
   for(size_t i=0;i<3;i++)
     {
       if(fabs(dir[i])<0.0001)
-	continue;
+        continue;
       if(ip[i]<base[i] || ip[i]>base[i]+dir[i])
-	{
-	  //	  cdebug("fail:"<<i);
-	  return false;
-	}
+        {
+          return false;
+        }
     }
   return true;
 }
@@ -2594,31 +2593,31 @@
 
 
 std::ostream &operator<<(std::ostream &o,const AGVector2&v)
-{
-  o<<v.toString();
-  return o;
-}
+  {
+    o<<v.toString();
+    return o;
+  }
 
 std::ostream &operator<<(std::ostream &o,const AGVector3&v)
-{
-  o<<v.toString();
-  return o;
-}
+  {
+    o<<v.toString();
+    return o;
+  }
 
 std::ostream &operator<<(std::ostream &o,const AGVector4&v)
-{
-  o<<v.toString();
-  return o;
-}
+  {
+    o<<v.toString();
+    return o;
+  }
 
 std::ostream &operator<<(std::ostream &o,const AGRect2&v)
-{
-  o<<v.toString();
-  return o;
-}
+  {
+    o<<v.toString();
+    return o;
+  }
 
 std::ostream &operator<<(std::ostream &o,const AGBox3&v)
-{
-  o<<"("<<v.base<<" "<<v.dir<<"/"<<v.valid()<<")";
-  return o;
-}
+  {
+    o<<"("<<v.base<<" "<<v.dir<<"/"<<v.valid()<<")";
+    return o;
+  }

Modified: antargis/trunk/ext/basic/ag_geometry.h
===================================================================
--- antargis/trunk/ext/basic/ag_geometry.h	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_geometry.h	2008-02-24 19:05:29 UTC (rev 1230)
@@ -697,11 +697,13 @@
   bool mValid;
 };
 
+#ifndef SWIG
 AGEXPORT std::ostream &operator<<(std::ostream &o,const AGVector2&v);
 AGEXPORT std::ostream &operator<<(std::ostream &o,const AGVector3&v);
 AGEXPORT std::ostream &operator<<(std::ostream &o,const AGVector4&v);
 AGEXPORT std::ostream &operator<<(std::ostream &o,const AGRect2&v);
 AGEXPORT std::ostream &operator<<(std::ostream &o,const AGBox3&v);
+#endif
 
 #include "ag_geometry_inline.cc"
 

Modified: antargis/trunk/ext/basic/ag_kill.cc
===================================================================
--- antargis/trunk/ext/basic/ag_kill.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_kill.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -18,6 +18,9 @@
  * License along with this program.
  */
 
+
+// TODO: Is this still used ? 
+
 #include "ag_kill.h"
 #include "ag_debug.h"
 
@@ -25,42 +28,42 @@
 bool mIndirectInstance=false;
 
 void newInstanceKiller()
-{
-  assert(mInstanceKiller==0 || mIndirectInstance);
-  mInstanceKiller=new AGInstanceKiller;
-}
+  {
+    assert(mInstanceKiller==0 || mIndirectInstance);
+    mInstanceKiller=new AGInstanceKiller;
+  }
 void deleteInstanceKiller()
-{
-  assert(mInstanceKiller);
-  delete mInstanceKiller;
-}
+  {
+    assert(mInstanceKiller);
+    delete mInstanceKiller;
+  }
 
 AGInstanceKiller *getInstanceKiller()
-{
-  if(!mInstanceKiller)
-    {
-      mIndirectInstance=true;
-      newInstanceKiller();
-    }
-  assert(mInstanceKiller);
-  return mInstanceKiller;
-}
+  {
+    if(!mInstanceKiller)
+      {
+        mIndirectInstance=true;
+        newInstanceKiller();
+      }
+    assert(mInstanceKiller);
+    return mInstanceKiller;
+  }
 
 
 AGInstanceKiller::AGInstanceKiller()
-    {
-    }
+  {
+  }
 AGInstanceKiller::~AGInstanceKiller()
-    {
-      CTRACE;
-      std::set<AGInstanceBase*>::iterator i=bs.begin();
-      for(;i!=bs.end();i++)
-	{
-	  (*i)->kill();
-	  delete *i;
-	}
-      
-    }
+  {
+    CTRACE;
+    std::set<AGInstanceBase*>::iterator i=bs.begin();
+    for(;i!=bs.end();i++)
+      {
+        (*i)->kill();
+        delete *i;
+      }
+
+  }
 void AGInstanceKiller::reg(AGInstanceBase *b)
   {
     bs.insert(b);

Added: antargis/trunk/ext/basic/ag_message.h
===================================================================
--- antargis/trunk/ext/basic/ag_message.h	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_message.h	2008-02-24 19:05:29 UTC (rev 1230)
@@ -0,0 +1,46 @@
+#ifndef AG_MESSAGE_H_
+#define AG_MESSAGE_H_
+
+#include <ag_string.h>
+#include <map>
+
+class AGMessageSender
+{
+  
+};
+
+class AGMessageReceiver
+{
+  
+};
+
+class AGMessageTransceiver
+{
+  
+};
+
+class AGMessageSource
+{
+  AGMessageSender *mSender;
+  AGString mName;
+public:
+};
+
+class AGMessage
+{
+  AGMessageSource *mSource;
+public:
+  AGMessage(const AGMessageSource *pSource);
+};
+
+class AGMessageQueue
+{
+  std::map<AGMessageSource,std::list<AGMessageReceiver*> > connects;
+public:
+  void connect(const AGMessageSource &pSource,const AGMessageReceiver *pReceiver);
+  void distconnect(const AGMessageSource &pSource,const AGMessageReceiver *pReceiver);
+  
+  void send(const AGMessage &pMessage);
+};
+
+#endif /*AG_MESSAGE_H_*/

Modified: antargis/trunk/ext/basic/ag_rubyobj.cc
===================================================================
--- antargis/trunk/ext/basic/ag_rubyobj.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_rubyobj.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -16,103 +16,116 @@
 
 std::set<AGRubyObject*> gExistingRubies;
 
+AGEXPORT void *getAddressOfRubyObject(AGRubyObject *o)
+  {
+    return o;
+  }
+
+AGEXPORT bool rubyObjectExists(void *po)
+  {
+    AGRubyObject *o=reinterpret_cast<AGRubyObject*>(po);
+    return gExistingRubies.find(o)!=gExistingRubies.end();
+  }
+
 AGRubyObject::AGRubyObject()
-{
-  mRubyObject=false;
-  mDeleted=false;
-  gExistingRubies.insert(this);
-  mRUBY=0;
+  {
+    mRubyObject=false;
+    mDeleted=false;
+    gExistingRubies.insert(this);
+    mRUBY=0;
 #ifdef GCDEBUG
-  printf("NEW ME:%lx\n",this);
+    printf("NEW ME:%lx\n",this);
 #endif
-  //  cdebug("existing rubies:"<<gExistingRubies.size());
-  
-}
+    //  cdebug("existing rubies:"<<gExistingRubies.size());
+
+  }
 AGRubyObject::~AGRubyObject()
-{
-  for(std::set<AGBaseObject*>::iterator i=mReferences.begin();i!=mReferences.end();i++)
-    (*i)->baseClear();
+  {
+    for(std::set<AGBaseObject*>::iterator i=mReferences.begin();i!=mReferences.end();i++)
+      (*i)->baseClear();
 
 
-  //  cdebug("DEL:"<<mRUBY);
+    //  cdebug("DEL:"<<mRUBY);
 #ifdef GCDEBUG
-  printf("DEL:%lx  %s (me:%lx)\n",mRUBY,mObjName.c_str(),this);
+    printf("DEL:%lx  %s (me:%lx)\n",mRUBY,mObjName.c_str(),this);
 #endif
-  mDeleted=true;
-  gExistingRubies.erase(this);
-  //  cdebug("existing rubies:"<<gExistingRubies.size());
-  //  cdebug("DEL:"<<mRUBY);
-}
+    mDeleted=true;
+    gExistingRubies.erase(this);
+    //  cdebug("existing rubies:"<<gExistingRubies.size());
+    //  cdebug("DEL:"<<mRUBY);
+  }
 
 
 /// override this function to mark your children
 void AGRubyObject::mark()
-{
-}
+  {
+  }
 
 // call this function with any object you want to mark.
 void AGRubyObject::markObject(AGRubyObject *o, bool recursive)
-{
-  assert(o);
+  {
+ //   CTRACE;
+    assert(o);
+//    cdebug("o:"<<o);
 
 #ifdef GCDEBUG
-	printf("marking : %lx\n",o);
-  assert(gExistingRubies.find(o)!=gExistingRubies.end());
+    printf("marking : %lx\n",o);
+    assert(gExistingRubies.find(o)!=gExistingRubies.end());
 #endif
 
-  if(o->mRubyObject)
-    {
+    if(o->mRubyObject)
+      {
 #ifdef GCDEBUG
-			printf("marking ruby : %lx\n",o->mRUBY);
+        printf("marking ruby : %lx\n",o->mRUBY);
 #endif
-      rb_gc_mark(o->mRUBY);
-    }
-  if(recursive)
-    o->mark(); // call this directly
+        rb_gc_mark(o->mRUBY);
+      }
+    if(recursive)
+      o->mark(); // call this directly
 #ifdef GCDEBUG
-	printf("endmarking : %lx\n",o);
+    printf("endmarking : %lx\n",o);
 #endif
-}
+  }
 
 void AGRubyObject::clear()
-{
-  CTRACE;
-}
+  {
+    CTRACE;
+  }
 
 void AGRubyObject::addRef(AGBaseObject *o)
-{
-  mReferences.insert(o);
-}
+  {
+    mReferences.insert(o);
+  }
 
 void AGRubyObject::deleteRef(AGBaseObject *o)
-{
-  mReferences.erase(o);
-}
+  {
+    mReferences.erase(o);
+  }
 
 
 
 /// this is the marking function, that gets called by ruby
 /// it handles all the AGRubyObjects
 void general_markfunc(void *ptr)
-{
-  STACKTRACE;
-  //  TRACE;
-  if(!ptr)
-    {
-      cdebug("WARNING: a ptr==0 was given in general_markfunc!");
-      //      throw std::runtime_error("WARNING: a ptr==0 was given in general_markfunc!");
-      return; // ignore
-    }
-  assert(ptr);
-  AGRubyObject *o=static_cast<AGRubyObject*>(ptr);
+  {
+    STACKTRACE;
+    //  TRACE;
+    if(!ptr)
+      {
+        cdebug("WARNING: a ptr==0 was given in general_markfunc!");
+        //      throw std::runtime_error("WARNING: a ptr==0 was given in general_markfunc!");
+        return; // ignore
+      }
+    assert(ptr);
+    AGRubyObject *o=static_cast<AGRubyObject*>(ptr);
 
 #ifdef GCDEBUG
-  printf("mark: 0x%lx\n",o->mRUBY);
+    printf("mark: 0x%lx\n",o->mRUBY);
 #endif
 
-  assert(o);
-  o->mark();
-}
+    assert(o);
+    o->mark();
+  }
 
 
 /**
@@ -124,29 +137,29 @@
    1) put all deleted objects in a set
    2) check set before clearing/deleting
    3) clear this set when marking
-*/
+ */
 bool saveDelete(AGRubyObject *o)
-{
-  if(hasQuit())
-    return false; // we are quitting - so memory is discarded anyway - hopefully ;-)
-  
-  assert(o);
-  if(gExistingRubies.find(o)==gExistingRubies.end())
-    {
+  {
+    if(hasQuit())
+      return false; // we are quitting - so memory is discarded anyway - hopefully ;-)
+
+    assert(o);
+    if(gExistingRubies.find(o)==gExistingRubies.end())
+      {
 #ifdef GCDEBUG
-      cdebug("already deleted!");
+        cdebug("already deleted!");
 #endif
-      return false; // already deleted
-    }
-  assert(!o->mDeleted);
-  o->clear();
-  if(!o->mRubyObject)
-    {
-      delete o;
-      return true;
-    }
-  return false;
-}
+        return false; // already deleted
+      }
+    assert(!o->mDeleted);
+    o->clear();
+    if(!o->mRubyObject)
+      {
+        delete o;
+        return true;
+      }
+    return false;
+  }
 
 
 
@@ -156,19 +169,19 @@
 
 
 AGBaseObject::AGBaseObject(AGRubyObject *p)
-  :mp(p)
+:mp(p)
 {
   if(p)
     p->addRef(this);
 }
 
 AGBaseObject::~AGBaseObject()
-{
-  if(mp)
-    mp->deleteRef(this);
-}
+  {
+    if(mp)
+      mp->deleteRef(this);
+  }
 
 void AGBaseObject::baseClear()
-{
-  mp=0;
-}
+  {
+    mp=0;
+  }

Modified: antargis/trunk/ext/basic/ag_rubyobj.h
===================================================================
--- antargis/trunk/ext/basic/ag_rubyobj.h	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_rubyobj.h	2008-02-24 19:05:29 UTC (rev 1230)
@@ -120,4 +120,7 @@
 AGEXPORT void general_markfunc(void *ptr);
 AGEXPORT bool saveDelete(AGRubyObject *o);
 
+AGEXPORT void *getAddressOfRubyObject(AGRubyObject *object);
+AGEXPORT bool rubyObjectExists(void *o);
+
 #endif

Modified: antargis/trunk/ext/basic/ag_string_utf8.h
===================================================================
--- antargis/trunk/ext/basic/ag_string_utf8.h	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/basic/ag_string_utf8.h	2008-02-24 19:05:29 UTC (rev 1230)
@@ -50,7 +50,10 @@
 class AGEXPORT AGStringUtf8
 {
  public:
-  static const size_t npos = static_cast<size_t>(-1);
+#ifdef SWIG
+   %rename(Npos) npos;
+#endif
+   static const size_t npos = static_cast<size_t>(-1);
 
   AGStringUtf8();
 #ifndef SWIG

Modified: antargis/trunk/ext/game/map.cc
===================================================================
--- antargis/trunk/ext/game/map.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/game/map.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -40,26 +40,26 @@
 
 AntMap *myAntargisMap=0;
 AntMap *getMap()
-{
-  assert(myAntargisMap);
-  return myAntargisMap;
-}
+  {
+    assert(myAntargisMap);
+    return myAntargisMap;
+  }
 
 AntMap::AntMap(SceneBase *pScene,int w,int h):
   HeightMap(pScene,w,h),
   mEntQuad(new QuadTree<AntEntity>(AGRect2(0,0,w,h))),
   mHeuristicFunction(0)
-{
-  myAntargisMap=this;
-  maxID=0;
-}
+  {
+    myAntargisMap=this;
+    maxID=0;
+  }
 AntMap::~AntMap()
-{
-  CTRACE;
-  printf("%lX\n",mRUBY);
-  if(myAntargisMap==this)
-    myAntargisMap=0;
-}
+  {
+    CTRACE;
+    printf("%lX\n",mRUBY);
+    if(myAntargisMap==this)
+      myAntargisMap=0;
+  }
 
 AGVector3 AntMap::getPos(const AGVector2 &pPos) const
 {
@@ -78,14 +78,14 @@
 
 // FIXME: exchange this function somehow!!
 int AntMap::getNewID()
-{
-  return maxID++;
-}
+  {
+    return maxID++;
+  }
 
 void AntMap::useID(int id)
-{
-  maxID=std::max(maxID,id+1);
-}
+  {
+    maxID=std::max(maxID,id+1);
+  }
 
 
 void AntMap::saveXML(Node &node) const
@@ -97,118 +97,118 @@
   for(;i!=mEntities.end();i++)
     {
       cdebug("try saving child1 "<<*i);
-			AGString s=(*i)->xmlName();
-			cdebug("xmlName:"<<s);
+      AGString s=(*i)->xmlName();
+      cdebug("xmlName:"<<s);
       Node &child=node.addChild(s);
       cdebug("try saving child2 "<<*i);
       (*i)->saveXML(child);
       cdebug("try saving child3 "<<*i);
     }
-  
+
 }
 
 
 void AntMap::loadXML(const Node &node)
-{
-  HeightMap::loadXML(node);
+  {
+    HeightMap::loadXML(node);
 
-  Node::const_iterator i=node.begin();
-  for(;i!=node.end();i++)
-    {
-      //      AntEntity *e=0;
-      Node *n=*i;
-      processXMLNode(*n);
-      /*        {
+    Node::const_iterator i=node.begin();
+    for(;i!=node.end();i++)
+      {
+        //      AntEntity *e=0;
+        Node *n=*i;
+        processXMLNode(*n);
+        /*        {
 	  e->loadXML(*n);
 	  insertEntity(e);
 	  }*/
-    }
-  // tell entities, that map has changed
-  std::list<AntEntity*>::iterator k=mEntities.begin();
-  for(;k!=mEntities.end();k++)
-    (*k)->eventMapChanged();
-}
+      }
+    // tell entities, that map has changed
+    std::list<AntEntity*>::iterator k=mEntities.begin();
+    for(;k!=mEntities.end();k++)
+      (*k)->eventMapChanged();
+  }
 
 void AntMap::insertEntity(AntEntity *e)
-{
-  //  cdebug("INSERTING:"<<e);
-  mEntities.push_back(e);
-  //  mEntList.push_back(e);
-  mEntityMap[e->getID()]=e;
-  mEntQuad->insert(e);
-  //  entsChanged();
-  //  mByType[e->getType()].insert(e);
-}
+  {
+    //  cdebug("INSERTING:"<<e);
+    mEntities.push_back(e);
+    //  mEntList.push_back(e);
+    mEntityMap[e->getID()]=e;
+    mEntQuad->insert(e);
+    //  entsChanged();
+    //  mByType[e->getType()].insert(e);
+  }
 
 void AntMap::removeEntity(AntEntity *p)
-{
   {
-    EntityList::iterator i=std::find(mToDel.begin(),mToDel.end(),p);
-    if(i!=mToDel.end())
       {
-	cdebug("Entity already deleted:"<<p);
-	return;
+        EntityList::iterator i=std::find(mToDel.begin(),mToDel.end(),p);
+        if(i!=mToDel.end())
+          {
+            cdebug("Entity already deleted:"<<p);
+            return;
+          }
       }
-  }
 
 
-  EntityList::iterator i=std::find(mEntities.begin(),mEntities.end(),p);
-  if(i!=mEntities.end())
-    mToDel.push_back(p);
-  else
-    {
-      cdebug("ERROR: Entity not found while removing:"<<p);
-      //      throw std::runtime_error("ERROR: Entity not found while removing");
-    }
-}
+      EntityList::iterator i=std::find(mEntities.begin(),mEntities.end(),p);
+      if(i!=mEntities.end())
+        mToDel.push_back(p);
+      else
+        {
+          cdebug("ERROR: Entity not found while removing:"<<p);
+          //      throw std::runtime_error("ERROR: Entity not found while removing");
+        }
+  }
 
 
 void AntMap::move(float pTime)
-{
-  STACKTRACE; 
-  //return;
-  // first remove entities, which shall be deleted
-  std::list<AntEntity*>::iterator d=mToDel.begin();
-  for(;d!=mToDel.end();d++)
-    {
-      EntityList::iterator i=std::find(mEntities.begin(),mEntities.end(),*d);
-      if(i!=mEntities.end())
-	mEntities.erase(i);
-      else
-	cdebug("ERROR: Entity not found while deleting:"<<*d);
-      mEntityMap.erase((*d)->getID());
-      mEntQuad->remove(*i);
-      //      mByType[(*d)->getType()].erase(*d);
+  {
+    STACKTRACE; 
+    //return;
+    // first remove entities, which shall be deleted
+    std::list<AntEntity*>::iterator d=mToDel.begin();
+    for(;d!=mToDel.end();d++)
+      {
+        EntityList::iterator i=std::find(mEntities.begin(),mEntities.end(),*d);
+        if(i!=mEntities.end())
+          mEntities.erase(i);
+        else
+          cdebug("ERROR: Entity not found while deleting:"<<*d);
+        mEntityMap.erase((*d)->getID());
+        mEntQuad->remove(*i);
+        //      mByType[(*d)->getType()].erase(*d);
 
-      saveDelete(*d);
-    }
-  mToDel.clear();
+        saveDelete(*d);
+      }
+    mToDel.clear();
 
-  // now move all entities
+    // now move all entities
 
-  EntityList::iterator i=mEntities.begin();
+    EntityList::iterator i=mEntities.begin();
 
-  for(;i!=mEntities.end();i++)
-    {
-      (*i)->move(pTime);
-    }
-}
+    for(;i!=mEntities.end();i++)
+      {
+        (*i)->move(pTime);
+      }
+  }
 
 
 void AntMap::processXMLNode(const Node &node)
-{
-  //  AntEntity *e=0;
-  cdebug("type unknown:"<<node.getName());
-  //  return e;
-}
+  {
+    //  AntEntity *e=0;
+    cdebug("type unknown:"<<node.getName());
+    //  return e;
+  }
 AntMap::EntityList AntMap::getEntities(const AGRect2&r)
-{
-  return mEntQuad->get(r);
-}
+  {
+    return mEntQuad->get(r);
+  }
 AntMap::EntityList AntMap::getAllEntities()
-{
-  return mEntities;
-}
+  {
+    return mEntities;
+  }
 /*
 std::vector<AntEntityPtr> AntMap::getAllEntitiesV()
 {
@@ -216,232 +216,235 @@
   std::copy(mEntities.begin(),mEntities.end(),std::back_inserter(v));
   return v;
 }
-*/
+ */
 
 std::vector<AntEntity*> AntMap::getEntities(const AGString &pName)
-{
-  std::vector<AntEntity*> v;
-  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
-    if((*i)->provides(pName))
-      v.push_back(*i);
-  return v;
-}
+  {
+    std::vector<AntEntity*> v;
+    for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+      if((*i)->provides(pName))
+        v.push_back(*i);
+    return v;
+  }
 
 std::vector<AntEntity*> AntMap::getNextList(AntEntity *me,const AGString &pType,size_t atLeast)
-{
-  //  assert(mHeuristicFunction);
+  {
+    //  assert(mHeuristicFunction);
 
-  // FIXME: optimize this - use quadtree
+    // FIXME: optimize this - use quadtree
 
-  std::multimap<float,AntEntity*> ents;
+    std::multimap<float,AntEntity*> ents;
 
 
-  EntityList::iterator i=mEntities.begin();
-  AGVector2 p=me->getPos2D(); // FIXME: check for reachability, too ??
+    EntityList::iterator i=mEntities.begin();
+    AGVector2 p=me->getPos2D(); // FIXME: check for reachability, too ??
 
-  for(;i!=mEntities.end();i++)
-    {
-      if(me!=*i)
-        {
-          if((*i)->provides(pType) && (*i)->resource.get(pType)>=atLeast)
-            {
-	      /*
+    for(;i!=mEntities.end();i++)
+      {
+        if(me!=*i)
+          {
+            if((*i)->provides(pType) && (*i)->resource.get(pType)>=atLeast)
+              {
+                /*
               AGVector2 p2=(*i)->getPos2D()-p;
               float norm=p2.length2();*/
-	      float norm;
-	      if(mHeuristicFunction)
-		norm=(*mHeuristicFunction)(std::make_pair((*i)->getPos2D(),p));
-	      else
-		norm=((*i)->getPos2D()-p).length2();
-              ents.insert(std::make_pair(norm,*i));
-            }
-        }
-    }
+                float norm;
+                if(mHeuristicFunction)
+                  norm=(*mHeuristicFunction)(std::make_pair((*i)->getPos2D(),p));
+                else
+                  norm=((*i)->getPos2D()-p).length2();
+                ents.insert(std::make_pair(norm,*i));
+              }
+          }
+      }
 
-  std::vector<AntEntity*> vec;
+    std::vector<AntEntity*> vec;
 
-  // take one of the nearest, but no farer away than 30% of nearest
-  //  AntEntity *e=0;
-  if(ents.size())
-    {
-      std::multimap<float,AntEntity*>::iterator j=ents.begin();
-      float nearest=j->first;
-      for(;j!=ents.end();j++)
-	{
-	  if(j->first<=nearest*1.3)
-	    vec.push_back(j->second);
-	}
-    }
+    // take one of the nearest, but no farer away than 30% of nearest
+    //  AntEntity *e=0;
+    if(ents.size())
+      {
+        std::multimap<float,AntEntity*>::iterator j=ents.begin();
+        float nearest=j->first;
+        for(;j!=ents.end();j++)
+          {
+            if(j->first<=nearest*1.3)
+              vec.push_back(j->second);
+          }
+      }
 
-  return vec;
-}
+    return vec;
+  }
 
 
 AntEntity *AntMap::getNext(AntEntity *me,const AGString &pType,size_t atLeast)
-{
-  //  assert(mHeuristicFunction);
-  // FIXME: optimize this - use quadtree
+  {
+    //  assert(mHeuristicFunction);
+    // FIXME: optimize this - use quadtree
 
-  assert(me);
+    assert(me);
 
-  std::multimap<float,AntEntity*> ents;
+    std::multimap<float,AntEntity*> ents;
 
 
-  EntityList::iterator i=mEntities.begin();
-  AGVector2 p=me->getPos2D(); // FIXME: check for reachability, too ??
-  //  float dist=0;
+    EntityList::iterator i=mEntities.begin();
+    AGVector2 p=me->getPos2D(); // FIXME: check for reachability, too ??
+    //  float dist=0;
 
-  for(;i!=mEntities.end();i++)
-    {
-      if(me!=*i)
-        {
-          if((*i)->provides(pType) && (*i)->resource.get(pType)>=atLeast)
-            {
-	      //              AGVector2 p2=(*i)->getPos2D()-p;
-	      float norm;
+    for(;i!=mEntities.end();i++)
+      {
+        if(me!=*i)
+          {
+            if((*i)->provides(pType) && (*i)->resource.get(pType)>=atLeast)
+              {
+                //              AGVector2 p2=(*i)->getPos2D()-p;
+                float norm;
 
-	      if(mHeuristicFunction)
-	        norm=(*mHeuristicFunction)(std::make_pair((*i)->getPos2D(),p));
-	      else
-		norm=((*i)->getPos2D()-p).length2();
-//	      cdebug("norm:"<<norm<<" i:"<<*i<<" name:"<<(*i)->getName());
-	      //              float norm=p2.length2();
-              ents.insert(std::make_pair(norm,*i));
-            }
-        }
-    }
+                if(mHeuristicFunction)
+                  norm=(*mHeuristicFunction)(std::make_pair((*i)->getPos2D(),p));
+                else
+                  norm=((*i)->getPos2D()-p).length2();
+                //	      cdebug("norm:"<<norm<<" i:"<<*i<<" name:"<<(*i)->getName());
+                //              float norm=p2.length2();
+                ents.insert(std::make_pair(norm,*i));
+              }
+          }
+      }
 
 
-  // take one of the nearest, but no farer away than 30% of nearest
-  AntEntity *e=0;
-  if(ents.size())
-    {
-      std::multimap<float,AntEntity*>::iterator j=ents.begin();
-      float nearest=j->first;
-      int r=agRand(std::min((int)ents.size(),5));
-      while(r>0 && (j->first<=nearest*1.3 || j->first<2000*2000))
-        {
-          j++;
-          r--;
-        }
-      if(r>0)
-        j--;
-      assert((j!=ents.end()));
-      e=j->second;
-      //      cdebug("DIST:"<<j->first);
-    }
+    // take one of the nearest, but no farer away than 30% of nearest
+    AntEntity *e=0;
+    if(ents.size())
+      {
+        std::multimap<float,AntEntity*>::iterator j=ents.begin();
+        float nearest=j->first;
+        int r=agRand(std::min((int)ents.size(),5));
+        while(r>0 && (j->first<=nearest*1.3 || j->first<2000*2000))
+          {
+            j++;
+            r--;
+          }
+        if(r>0)
+          j--;
+        assert((j!=ents.end()));
+        e=j->second;
+        //      cdebug("DIST:"<<j->first);
+      }
 
-  return e;
-}
+    return e;
+  }
 
 void AntMap::setHeuristic(HeuristicFunction *pFunction)
-{
-  mHeuristicFunction=pFunction;
-}
+  {
+    mHeuristicFunction=pFunction;
+  }
 
 
 AntEntity *AntMap::getByName(const AGString &pName)
-{
-  EntityList::iterator i=mEntities.begin();
+  {
+    EntityList::iterator i=mEntities.begin();
 
-  for(;i!=mEntities.end();i++)
-    {
-      if((*i)->getName()==pName)
-        return *i;
-    }
-  return 0;
-}
+    for(;i!=mEntities.end();i++)
+      {
+        if((*i)->getName()==pName)
+          return *i;
+      }
+    return 0;
+  }
 
 void AntMap::loadMapFromMemory(const AGData &pMem)
-{
-  if(pMem.length())
-    {
-      Document d;
-      d.parseMemory(pMem);
-      loadXML(d.root());
-    }
-}
+  {
+    if(pMem.length())
+      {
+        Document d;
+        d.parseMemory(pMem);
+        loadXML(d.root());
+      }
+  }
 
 void AntMap::loadMap(const AGFilename &pFilename)
-{
-  
-  loadMapFromMemory(loadFile(pFilename));
-}
+  {
+
+    loadMapFromMemory(loadFile(pFilename));
+  }
+
+/**
+ * save the current map into an xml-file named pFilename
+ */
 void AntMap::saveMap(const AGFilename &pFilename)
-{
-	CTRACE;
-  mName=AGString(pFilename);
-  Document d;
-  Node &root=d.root();
-  root.setName("antargisLevel");
-  cdebug("root:"<<&root);
-  saveXML(root);
+  {
+    CTRACE;
+    mName=AGString(pFilename);
+    Document d;
+    Node &root=d.root();
+    root.setName("antargisLevel");
+    cdebug("root:"<<&root);
+    saveXML(root);
 
-  AGData c=d.toString();
-  cdebug(c);
-  saveFile(pFilename,c);
-}
+    AGData c=d.toString();
+    saveFile(pFilename,c);
+  }
 
 void AntMap::clear()
-{
-  //  getScene()->clear();
-  CTRACE;
-  //  mPlayers.clear();
+  {
+    //  getScene()->clear();
+    CTRACE;
+    //  mPlayers.clear();
 
-  mEntQuad->clear();
-  mEntityMap.clear();
+    mEntQuad->clear();
+    mEntityMap.clear();
 
-  // save delete entities
-  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
-    saveDelete(*i);
-  
+    // save delete entities
+    for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+      saveDelete(*i);
 
-  mEntities.clear();
 
-}
+    mEntities.clear();
 
+  }
+
 void AntMap::mapChanged()
-{
-  HeightMap::mapChanged();
-  // send info to entitites
-  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
-    (*i)->setPos((*i)->getPos2D());
-}
+  {
+    HeightMap::mapChanged();
+    // send info to entitites
+    for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+      (*i)->setPos((*i)->getPos2D());
+  }
 
 AntEntity *AntMap::getEntity(const Mesh &pMesh)
-{
-  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
-    {
-      AntEntity::Meshes meshes=(*i)->getMesh();
-      if(std::find(meshes.begin(),meshes.end(),&pMesh)!=meshes.end())
-	//      if((*i)->getMesh()==&pMesh)
-	return *i;
-    }
-  return 0;
-}
+  {
+    for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+      {
+        AntEntity::Meshes meshes=(*i)->getMesh();
+        if(std::find(meshes.begin(),meshes.end(),&pMesh)!=meshes.end())
+          //      if((*i)->getMesh()==&pMesh)
+          return *i;
+      }
+    return 0;
+  }
 
 AntEntity *AntMap::getEntity(const AnimMesh &pMesh)
-{
-  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
-    {
-      AntEntity::Meshes meshes=(*i)->getMesh();
-      if(std::find(meshes.begin(),meshes.end(),&pMesh)!=meshes.end())
-	return *i;
-    }
-  return 0;
-}
+  {
+    for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+      {
+        AntEntity::Meshes meshes=(*i)->getMesh();
+        if(std::find(meshes.begin(),meshes.end(),&pMesh)!=meshes.end())
+          return *i;
+      }
+    return 0;
+  }
 
 AntEntity *AntMap::getEntity(const Mesh2D &pMesh)
-{
-  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
-    {
-      AntEntity::Meshes meshes=(*i)->getMesh();
-      if(std::find(meshes.begin(),meshes.end(),&pMesh)!=meshes.end())
-	//      if((*i)->getMesh()==&pMesh)
-	return *i;
-    }
-  return 0;
-}
+  {
+    for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+      {
+        AntEntity::Meshes meshes=(*i)->getMesh();
+        if(std::find(meshes.begin(),meshes.end(),&pMesh)!=meshes.end())
+          //      if((*i)->getMesh()==&pMesh)
+          return *i;
+      }
+    return 0;
+  }
 
 
 
@@ -451,23 +454,23 @@
 //bool markingFinished=true;
 
 void AntMap::mark()
-{
-  //  cout<<"AntMap::mark()"<<std::endl;
-  CTRACE;
-  HeightMap::mark();
-  AntMap::EntityList::iterator i=mEntities.begin();
+  {
+    //  cout<<"AntMap::mark()"<<std::endl;
+    CTRACE;
+    HeightMap::mark();
+    AntMap::EntityList::iterator i=mEntities.begin();
 
-  for(;i!=mEntities.end();i++)
-    markObject(*i);
+    for(;i!=mEntities.end();i++)
+      markObject(*i);
 
-  // mark to del, too, otherwise it crashes when tidying before move() is called
-  for(i=mToDel.begin();i!=mToDel.end();i++)
-    markObject(*i);
-}
+    // mark to del, too, otherwise it crashes when tidying before move() is called
+    for(i=mToDel.begin();i!=mToDel.end();i++)
+      markObject(*i);
+  }
 
 
 void AntMap::newMap(int w,int h)
-{
-  clear();
-  HeightMap::newMap(w,h);
-}
+  {
+    clear();
+    HeightMap::newMap(w,h);
+  }

Modified: antargis/trunk/ext/gui/ag_application.cc
===================================================================
--- antargis/trunk/ext/gui/ag_application.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/gui/ag_application.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -34,18 +34,18 @@
 #include <ruby.h>
 
 void disableKeyrepeat()
-{
-  SDL_EnableKeyRepeat(0,0);
-}
+  {
+    SDL_EnableKeyRepeat(0,0);
+  }
 
 AGApplication *gApplication=0;
 
 AGVector2 gAppCursorPos;
 
 AGApplication *getApplication()
-{
-  return gApplication;
-}
+  {
+    return gApplication;
+  }
 
 
 AGApplication::AGApplication():mRunning(true),mIdleCalls(true),mainWidget(0),mTooltip(0),mOverlay(0)
@@ -61,32 +61,32 @@
 }
 
 AGApplication::~AGApplication()
-{
-  CTRACE;
-  delete mCursor;
-}
+  {
+    CTRACE;
+    delete mCursor;
+  }
 
 void AGApplication::setKeyRepeat(bool enable)
-{
-  if(enable)
-    SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY,SDL_DEFAULT_REPEAT_INTERVAL);
-  else
-    SDL_EnableKeyRepeat(0,0);
-}
+  {
+    if(enable)
+      SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY,SDL_DEFAULT_REPEAT_INTERVAL);
+    else
+      SDL_EnableKeyRepeat(0,0);
+  }
 
 
 void AGApplication::setMainWidget(AGWidget *w)
-{
-  mainWidget=w;
-  setOverlay(0);
-  if(w)
-    w->redraw();
-}
+  {
+    mainWidget=w;
+    setOverlay(0);
+    if(w)
+      w->redraw();
+  }
 
 AGWidget *AGApplication::getMainWidget()
-{
-  return mainWidget;
-}
+  {
+    return mainWidget;
+  }
 
 /**
  * \brief the main-loop of each application
@@ -96,59 +96,59 @@
  */
 
 bool AGApplication::run() 
-{
-  STACKTRACE; 
-  Uint32 last,now;
-  SDL_Event event;
-  float t;
-  mRunning=true;
+  {
+    STACKTRACE; 
+    Uint32 last,now;
+    SDL_Event event;
+    float t;
+    mRunning=true;
 
-  gApplication=this;
-  
-  flushEventQueue();
-  last=now=SDL_GetTicks();
+    gApplication=this;
 
-  size_t loopCount=0;
-  
-  while(mRunning)
-    {
-      STACKTRACE; 
-      
-      gApplication=this;
+    flushEventQueue();
+    last=now=SDL_GetTicks();
 
+    size_t loopCount=0;
+
+    while(mRunning)
       {
-	// event handling
-	STACKTRACE;
-	// check for finished music
-	getMain()->repeatedCalls();
-	//	getSoundManager()->checkFinished();
-	
-	now=SDL_GetTicks();
-	/*
+        STACKTRACE; 
+
+        gApplication=this;
+
+          {
+            // event handling
+            STACKTRACE;
+            // check for finished music
+            getMain()->repeatedCalls();
+            //	getSoundManager()->checkFinished();
+
+            now=SDL_GetTicks();
+            /*
 	// pull motion events (may flood the eventqueue)
 		while(SDL_PeepEvents(&event, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) > 0)
 	  ;
-	*/
-	clearOldMousePosition();
-	//	dbout(2,"loop pre-event:"<<loopCount);
-	event=getNewEvent();
-	if(eventOk(event))
-	  {
-	    do
-	      {
-		//		dbout(2,"eventok  "<<toString(&event));
-		doEvent(event);
-		if(mIdleCalls)
-		  {
-		    //		    dbout(2,"getNewEvent...  (idlecalls:"<<mIdleCalls<<")");
-		    event=getNewEvent();
-		  }
-		else
-		  resetEvent(event);
-	      }while(eventOk(event));
-	  } 
-	//	dbout(2,"loop post-event:"<<loopCount);
-	/*
+             */
+            clearOldMousePosition();
+            //	dbout(2,"loop pre-event:"<<loopCount);
+            event=getNewEvent();
+            if(eventOk(event))
+              {
+                do
+                  {
+                    //		dbout(2,"eventok  "<<toString(&event));
+                    doEvent(event);
+                    if(mIdleCalls)
+                      {
+                        //		    dbout(2,"getNewEvent...  (idlecalls:"<<mIdleCalls<<")");
+                        event=getNewEvent();
+                      }
+                    else
+                      resetEvent(event);
+                  }while(eventOk(event));
+              } 
+            //	dbout(2,"loop post-event:"<<loopCount);
+            /*
 	if(mIdleCalls) 
 	  {
 	    if (SDL_PollEvent(&event) == 0) 
@@ -160,7 +160,7 @@
 		    doEvent(&event);
 		  }while(SDL_PollEvent(&event)!=0);
 	      }
-	    
+
 	  } 
 	else 
 	  {
@@ -168,135 +168,135 @@
 	    doEvent(&event);
 	    }*/
 
-	if(mDemoTime>=0)
-	  {
-	    t=mDemoTime;
-	    mDemoTime=-1;
-	    dbout(2,"demo time:"<<t);
-	  }
-	else
-	  {
-	    t=(now-last)/1000.0;
-	  }
-	if(mainWidget)
-	  mainWidget->sigTick(t);
-	
-	dbout(2,"frame events:"<<t);
-	eventPrepareFrame(t);
+            if(mDemoTime>=0)
+              {
+                t=mDemoTime;
+                mDemoTime=-1;
+                dbout(2,"demo time:"<<t);
+              }
+            else
+              {
+                t=(now-last)/1000.0;
+              }
+            if(mainWidget)
+              mainWidget->sigTick(t);
 
-	eventFrame(t);
+            dbout(2,"frame events:"<<t);
+            eventPrepareFrame(t);
+
+            eventFrame(t);
+          }
+            {
+              // drawing
+              STACKTRACE;
+                {
+                  STACKTRACE;
+                  prepareDraw();
+                }
+                  {
+                    STACKTRACE;
+                    draw();
+                  }
+            }
+
+            eventFrameEnd(t);
+            last=now;
+
+            loopCount++;
+            //      dbout(2,"Running:"<<mRunning);
       }
-      {
-	// drawing
-	STACKTRACE;
-	{
-	  STACKTRACE;
-	  prepareDraw();
-	}
-	{
-	  STACKTRACE;
-	  draw();
-	}
-      }
-      
-      eventFrameEnd(t);
-      last=now;
+    gApplication=0;
 
-      loopCount++;
-      //      dbout(2,"Running:"<<mRunning);
-    }
-  gApplication=0;
+    return true;
+  }
 
-  return true;
-}
-
 void AGApplication::setDemoTime(float t)
-{
-  dbout(2,"demoTime:"<<t);
-  mDemoTime=t;
-}
+  {
+    dbout(2,"demoTime:"<<t);
+    mDemoTime=t;
+  }
 
 
 SDL_Event AGApplication::getNewEvent()
-{
-  SDL_Event mEvent;
-  resetEvent(mEvent);
-  // pull motion events (may flood the eventqueue)
-  while(SDL_PeepEvents(&mEvent, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) > 0)
-    ;
-  
-  if(mIdleCalls) 
-    {
-      if (SDL_PollEvent(&mEvent) == 0) 
-	{
-	  resetEvent(mEvent);
-	  return mEvent;
-	}
-    } 
-  else 
-    SDL_WaitEvent(&mEvent);
-  return mEvent;
-}
+  {
+    SDL_Event mEvent;
+    resetEvent(mEvent);
+    // pull motion events (may flood the eventqueue)
+    while(SDL_PeepEvents(&mEvent, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) > 0)
+      ;
 
+    if(mIdleCalls) 
+      {
+        if (SDL_PollEvent(&mEvent) == 0) 
+          {
+            resetEvent(mEvent);
+            return mEvent;
+          }
+      } 
+    else 
+      SDL_WaitEvent(&mEvent);
+    return mEvent;
+  }
 
 
+
 bool AGApplication::doEvent(const SDL_Event &event) 
-{
-  STACKTRACE;
-  SDL_Event e;
-  
-  // eat up old mouse motion events
-  while(SDL_PeepEvents(&e, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) > 0);
-  
-  AGEvent *message=newEvent(this,"",event);
-  bool processed=false;
-  if(mOverlay)
-    processed=mOverlay->processEvent(message);
+  {
+    STACKTRACE;
+    SDL_Event e;
 
-  if(!processed)
-    {
-      if(!processed && mainWidget)
-	processed=mainWidget->processEvent(message);
+    // eat up old mouse motion events
+    while(SDL_PeepEvents(&e, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) > 0);
 
-      if(!processed)
-	processed=processEvent(message);
-    }
-  
-  delete message;
-  return processed;
-}
+    AGEvent *message=newEvent(this,"",event);
+    bool processed=false;
+    if(mOverlay)
+      processed=mOverlay->processEvent(message);
 
+    if(!processed)
+      {
+        if(!processed && mainWidget)
+          processed=mainWidget->processEvent(message);
+
+        if(!processed)
+          processed=processEvent(message);
+      }
+
+    delete message;
+    return processed;
+  }
+
 void AGApplication::clearOldMousePosition()
-{
-}
+  {
+  }
 void AGApplication::drawCursor()
-{
-  if(!videoInited())
-    return;
-  AGPainter p;
-  if(mCursor)
-    {
-      mCursorOld=AGRect2(gAppCursorPos[0],gAppCursorPos[1],mCursor->width(),mCursor->height());
-      p.blit(*mCursor,mCursorOld);
-    }
+  {
+    if(!videoInited())
+      return;
+    AGPainter p;
+    if(mCursor)
+      {
+        mCursorOld=AGRect2(gAppCursorPos[0],gAppCursorPos[1],mCursor->width(),mCursor->height());
+        p.blit(*mCursor,mCursorOld);
+      }
 
-}
+  }
 
 void AGApplication::flushEventQueue()
-{
-}
- 
+  {
+  }
+
 bool AGApplication::eventQuit(AGEvent *m)
-{
-  CTRACE;
-  mRunning=false;
-  return false;
-}
+  {
+    CTRACE;
+    mRunning=false;
+    return false;
+  }
 
 bool AGApplication::eventIdle()
-{
-  return false;
-}
+  {
+    return false;
+  }
 
 
 /**
@@ -305,19 +305,19 @@
    prepareDraw runs prepareDraw for the main-widget, which itself runs
    prepareDraw recursively. This functions are meant to prepare possible
    texture contents and other things, that might be updated in each frame.
-*/
+ */
 void AGApplication::prepareDraw()
-{
-  STACKTRACE; 
+  {
+    STACKTRACE; 
 
-  if(mainWidget)
-    {
-      mainWidget->prepareDrawAll();
-      mainWidget->useTexturesRecursive();
-    }
-  if(mOverlay)
-    mOverlay->prepareDrawAll();
-}  
+    if(mainWidget)
+      {
+        mainWidget->prepareDrawAll();
+        mainWidget->useTexturesRecursive();
+      }
+    if(mOverlay)
+      mOverlay->prepareDrawAll();
+  }  
 
 
 AGWidget *pLastDrawn=0;
@@ -330,12 +330,12 @@
  */
 
 void AGApplication::redraw()
-{
-  pLastDrawn=0;
+  {
+    pLastDrawn=0;
 
-  if(mainWidget)
-    mainWidget->redraw();
-}
+    if(mainWidget)
+      mainWidget->redraw();
+  }
 
 /**
  * \brief calls the draw-function of the main-widget
@@ -346,103 +346,103 @@
  */
 
 void AGApplication::draw()
-{
-  CTRACE;
-  if(delCue.size()>0)
-    {
-      for(std::list<AGWidget*>::iterator i=delCue.begin();i!=delCue.end();i++)
-	if(*i)
-	  saveDelete(*i);
-      delCue.clear();
-    }
+  {
+    CTRACE;
+    if(delCue.size()>0)
+      {
+        for(std::list<AGWidget*>::iterator i=delCue.begin();i!=delCue.end();i++)
+          if(*i)
+            saveDelete(*i);
+        delCue.clear();
+      }
 
-  if(!videoInited())
-    return;
+    if(!videoInited())
+      return;
 
-  bool oldClippingTechnique=false;
-  AGClipping clip;
+    bool oldClippingTechnique=false;
+    AGClipping clip;
 
-  STACKTRACE;
-  beginRender();
+    STACKTRACE;
+    beginRender();
 
-//  cdebug("mainWidget:"<<mainWidget);
-  if(mainWidget)
-    {
-      getScreen().begin();
-      
-      AGPainter *p;
-      AGClipPaintTarget paintTarget(&getScreen());
+    //  cdebug("mainWidget:"<<mainWidget);
+    if(mainWidget)
+      {
+        getScreen().begin();
 
-      if(opengl())
-	p=new AGPainter(getScreen());
-      else
-	p=new AGPainter(paintTarget);
+        AGPainter *p;
+        AGClipPaintTarget paintTarget(&getScreen());
 
-      clip.exclude(mainWidget->getScreenRect());
-      if(pLastDrawn==mainWidget && !opengl())
-	{
-	  if(oldClippingTechnique)
-	    {
-	      AGRect2 r=mainWidget->getChangeRect();
-	      if(mCursor)
-		r+=mCursorOld;
-	      
-	      p->clip(r);
-	    }
-	  else
-	    {
-	      // FIXME: do some advanced clipping
-	      mainWidget->acquireClipping(clip);
-	    }
-	}
-      else
-	{
-	  clip.include(mainWidget->getScreenRect());
-	}
+        if(opengl())
+          p=new AGPainter(getScreen());
+        else
+          p=new AGPainter(paintTarget);
 
-  //    cdebug("CLIP:"<<clip.toString());
-      paintTarget.clip(clip);
-      mainWidget->drawAll(*p);
+        clip.exclude(mainWidget->getScreenRect());
+        if(pLastDrawn==mainWidget && !opengl())
+          {
+            if(oldClippingTechnique)
+              {
+                AGRect2 r=mainWidget->getChangeRect();
+                if(mCursor)
+                  r+=mCursorOld;
 
-      if(mTooltip)
-	{
-	  AGPainter p;
-	  mTooltip->drawAll(p);
-	}
-      if(mOverlay)
-	{
-	  AGPainter p;
-	  mOverlay->drawAll(p);
-	}
+                p->clip(r);
+              }
+            else
+              {
+                // FIXME: do some advanced clipping
+                mainWidget->acquireClipping(clip);
+              }
+          }
+        else
+          {
+            clip.include(mainWidget->getScreenRect());
+          }
 
-      pLastDrawn=mainWidget;
+        //    cdebug("CLIP:"<<clip.toString());
+        paintTarget.clip(clip);
+        mainWidget->drawAll(*p);
 
-      delete p;
-    }
-  else
-    cdebug("no mainwidget");
-  drawCursor();
+        if(mTooltip)
+          {
+            AGPainter p;
+            mTooltip->drawAll(p);
+          }
+        if(mOverlay)
+          {
+            AGPainter p;
+            mOverlay->drawAll(p);
+          }
 
-  std::list<AGRect2> changeList;
-  if(mainWidget)
-    {
-      changeList=mainWidget->aquireChanges();
-      mainWidget->clearChangeRects();
-    }
-  if(opengl())// || true)
-    getScreen().flip();
-  else
-    {
-      std::vector<AGRect2> changeV=clip.clip(mainWidget->getScreenRect());
-      changeList.clear();
-      std::copy(changeV.begin(),changeV.end(),std::back_inserter(changeList));
-      getScreen().update(changeList);
-    }
+        pLastDrawn=mainWidget;
 
-  endRender();
-//  cdebug("end render");
-}
+        delete p;
+      }
+    else
+      cdebug("no mainwidget");
+    drawCursor();
 
+    std::list<AGRect2> changeList;
+    if(mainWidget)
+      {
+        changeList=mainWidget->aquireChanges();
+        mainWidget->clearChangeRects();
+      }
+    if(opengl())// || true)
+      getScreen().flip();
+    else
+      {
+        std::vector<AGRect2> changeV=clip.clip(mainWidget->getScreenRect());
+        changeList.clear();
+        std::copy(changeV.begin(),changeV.end(),std::back_inserter(changeList));
+        getScreen().update(changeList);
+      }
+
+    endRender();
+    //  cdebug("end render");
+  }
+
 /**
  * \brief quit the application
  *
@@ -452,48 +452,48 @@
  */
 
 void AGApplication::tryQuit()
-{
-  CTRACE;
-  mRunning=false;
-}
+  {
+    CTRACE;
+    mRunning=false;
+  }
 
 bool AGApplication::eventKeyDown(AGEvent *m)
-{
-  if(m->isSDLEvent())
-    {
-      SDLKey k=m->getKey();
-      SDLMod mod=m->getMod();
+  {
+    if(m->isSDLEvent())
+      {
+        SDLKey k=m->getKey();
+        SDLMod mod=m->getMod();
 
-      if(k==SDLK_RETURN && ((mod&KMOD_LALT)||(mod&KMOD_RALT)))
-	{
-	  getVideo()->toggleFull();
-	  eventChangedRes();
-	  redraw();
-	}
-      else if(k==SDLK_F10)
-	tryQuit();
-    }
-  return false;
-}
+        if(k==SDLK_RETURN && ((mod&KMOD_LALT)||(mod&KMOD_RALT)))
+          {
+            getVideo()->toggleFull();
+            eventChangedRes();
+            redraw();
+          }
+        else if(k==SDLK_F10)
+          tryQuit();
+      }
+    return false;
+  }
 
 void AGApplication::eventChangedRes()
-{
-}
+  {
+  }
 
 bool AGApplication::eventPrepareFrame(float pTime)
-{
-  return false;
-}
+  {
+    return false;
+  }
 
 
 bool AGApplication::eventFrame(float pTime)
-{
-  return false;
-}
+  {
+    return false;
+  }
 bool AGApplication::eventFrameEnd(float pTime)
-{
-  return false;
-}
+  {
+    return false;
+  }
 
 long AGApplication::getTicks() const
 {
@@ -502,76 +502,76 @@
 
 /// delays execution for ms milliseconds. This can be used to decrease framerate and cpu-load.
 void AGApplication::delay(int ms)
-{
-  dbout(2,"delay:"<<ms);
-  SDL_Delay(ms);
-}
+  {
+    dbout(2,"delay:"<<ms);
+    SDL_Delay(ms);
+  }
 
 
 /// mark my mainWidget and my tooltip, as they can be ruby-objects
 void AGApplication::mark()
-{
-  //  CTRACE;
-  if(mainWidget)
-    markObject(mainWidget);
-  if(mTooltip)
-    markObject(mTooltip);
-}
+  {
+    CTRACE;
+    if(mainWidget)
+      markObject(mainWidget);
+    if(mTooltip)
+      markObject(mTooltip);
+  }
 
 /// this function sets the current tooltip, which is display above all widgets
 void AGApplication::setTooltip(AGTooltip *pTooltip)
-{
-  delete mTooltip;
-  mTooltip=pTooltip;
-    
-}
+  {
+    delete mTooltip;
+    mTooltip=pTooltip;
 
+  }
+
 /// this functions resets the tooltip pTooltip.
 /// @param pTooltip a tooltip of a widget
 void AGApplication::resetTooltip(AGTooltip *pTooltip)
-{
-  if(pTooltip==mTooltip)
-    {
-      delete mTooltip;
-      mTooltip=0;
-    }
-}
+  {
+    if(pTooltip==mTooltip)
+      {
+        delete mTooltip;
+        mTooltip=0;
+      }
+  }
 
 AGWidget *AGApplication::getOverlay()
-{
-  return mOverlay;
-}
+  {
+    return mOverlay;
+  }
 
 
 void AGApplication::setOverlay(AGWidget *pOverlay)
-{
-  CTRACE;
-  if(mOverlay)
-    delCue.push_back(mOverlay);
-  mOverlay=pOverlay;
-}
+  {
+    CTRACE;
+    if(mOverlay)
+      delCue.push_back(mOverlay);
+    mOverlay=pOverlay;
+  }
 
 
 bool AGApplication::eventMouseMotion(AGEvent *m)
-{
-  gAppCursorPos=m->getMousePosition();
-  return AGMessageObject::eventMouseMotion(m);
-}
+  {
+    gAppCursorPos=m->getMousePosition();
+    return AGMessageObject::eventMouseMotion(m);
+  }
 
 /// this function disables hardware cursor and shows software-cursor instead
 void AGApplication::setCursor(const AGTexture &pTexture)
-{
-  mCursor=new AGTexture(pTexture);
-  SDL_ShowCursor(0);
-}
+  {
+    mCursor=new AGTexture(pTexture);
+    SDL_ShowCursor(0);
+  }
 
 /// this function enables hardware-cursor
 void AGApplication::setNormalCursor()
-{
-  SDL_ShowCursor(1);
-  delete mCursor;
-  mCursor=0;
-}
+  {
+    SDL_ShowCursor(1);
+    delete mCursor;
+    mCursor=0;
+  }
 
 bool AGApplication::hardwareCursor() const
 {

Modified: antargis/trunk/ext/gui/ag_button.cc
===================================================================
--- antargis/trunk/ext/gui/ag_button.cc	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ext/gui/ag_button.cc	2008-02-24 19:05:29 UTC (rev 1230)
@@ -222,7 +222,6 @@
 void AGButton::setWidth(float w)
 {
   assert(w>=0);
-  ccdebug(w);
   AGWidget::setWidth(w);
   std::list<AGWidget*>::iterator i=mChildren.begin();
   for(;i!=mChildren.end();i++)

Modified: antargis/trunk/main/Rakefile
===================================================================
--- antargis/trunk/main/Rakefile	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/main/Rakefile	2008-02-24 19:05:29 UTC (rev 1230)
@@ -6,7 +6,9 @@
 
 task './starter'=>File.join("main","starter.cc") do
 	require 'antconfig.rb'
-	cmd="g++ -o starter main/starter.cc "+$CONFIG["CFLAGS"]+" "+$CONFIG["INCLUDEPATH"]+" "+`sdl-config --libs`.chomp+" -l"+CONFIG["RUBY_SO_NAME"]
+	#debug="antargis.bundle -g"
+	debug=""
+	cmd="g++ -o starter main/starter.cc #{debug} "+$CONFIG["CFLAGS"]+" "+$CONFIG["INCLUDEPATH"]+" "+`#{$CONFIG["SDL_CONFIG"]} --libs`.chomp+" -l"+CONFIG["RUBY_SO_NAME"]
 	cmd.gsub!("-arch ppc","")
 	sh cmd
 end

Modified: antargis/trunk/ruby/ant_messagebox.rb
===================================================================
--- antargis/trunk/ruby/ant_messagebox.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/ant_messagebox.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -29,8 +29,8 @@
 MB_YES=4
 MB_NO=8
 
-def messageBox(title,text,flags,&block)
-	mw=getApplication.getMainWidget
+def messageBox(app,title,text,flags,&block)
+	mw=app.getMainWidget
 	w=MessageBox.new(mw,"data/gui/layout/messagebox.xml")
 	w.block=block
 	w.getChild("title").setText(title)

Modified: antargis/trunk/ruby/ant_mock.rb
===================================================================
--- antargis/trunk/ruby/ant_mock.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/ant_mock.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,4 +1,6 @@
+# TODO: remove me
+
+raise "do not call this ???"
+
 class Mesh
-	def initialize
-	end
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/entities/ant_hero.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_hero.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/entities/ant_hero.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -163,6 +163,15 @@
 	end
 	def newHLBuildJob(pos,type)
 		@job.stopJob if @job
+    
+    if pos.is_a?(AGVector2) or pos.is_a?(AGVector3) 
+	    if getMap.getHeight(pos[0],pos[1])<=0
+	      # TODO: should view an error message
+	      messageBox(getMap.getApp,_("Warning"),_("You can't build on water."),MB_OK)
+	      return
+	    end
+    end
+    
 		puts "POSHL:#{pos} #{pos.class}"
 		if pos.is_a?(AGVector2) or pos.is_a?(AGVector3)
 			assert{pos.is_a?(AGVector2) or pos.is_a?(AGVector3)}

Modified: antargis/trunk/ruby/entities/ant_sack.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_sack.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/entities/ant_sack.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,5 +1,11 @@
 require 'ant_models.rb'
 
+#
+# AntSack is derived from AntAnimal, so that the KillANimal-job
+# can be used to catch the contents. eventDie is used to remove the sack
+# when the job is finished. So the behaviour is just like a dead animal
+# TODO: Find a better name for AntAnimal
+#
 class AntSack<AntAnimal
 	def initialize(map)
 		super
@@ -7,9 +13,12 @@
 		@enabled=true
 		@storeGood=["food","tool","corn","stone","wood"]
 	end
+	# is called by a finished KillAnimal-hl-job
 	def eventDie
 		getMap.removeEntity(self)
 	end
+	
+	# TODO: move this function to a module, which is included by AntHouse,AntTree and such, too.
 	def resourceChanged
 		@storeGood.each{|r|
 			setProvide(r,resource.get(r)>0)

Modified: antargis/trunk/ruby/jobs/ant_hljob_states.rb
===================================================================
--- antargis/trunk/ruby/jobs/ant_hljob_states.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/jobs/ant_hljob_states.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -772,9 +772,12 @@
 #
 class HLJob_Recruit<HLJob_BaseState
 	MAX_DIST=0.01
+  
+  attr_reader :countRecruited
+  
 	def enter
 		@countTargetMen=target.getMen.length
-		@countRecruiting=0
+		#@countRecruiting=0
 		@countRecruited=0
 		@myPos=hero.getPos2D
 		hero.formation=AntFormationRest.new(hero)
@@ -783,10 +786,11 @@
 
 	def ready
 		#return false
-		recruitedEnough=((@countRecruited>=howManyToRecruit) or nonToRecruitLeft)
+	  recruitedEnough=(((@countRecruited+countRecruiting)>=howManyToRecruit) or nonToRecruitLeft)
 		everyoneIsAtHisPlace=(hero.getMen).map{|man|(man.getPos2D-hero.getFormation(man, at myPos)).length}.max<MAX_DIST
 		heroIsAtHisPlace=(hero.getPos2D-hero.getFormation(hero, at myPos)).length<MAX_DIST
-		return (recruitedEnough and everyoneIsAtHisPlace)
+    allReady=(countRecruiting==0)
+		return (recruitedEnough and everyoneIsAtHisPlace and allReady)
 	end
 
 	def assign(man)
@@ -850,10 +854,14 @@
 			puts "walkTo #{pos} #{man}"
 		end
 	end
+  
+  def assignedTargets
+    hero.getMen.map{|man|man.hlJobMode[:recruitTarget]}
+  end
 
 	def getAssignableTargets
 		# all target's men without already assigned and target(hero) itself
-		target.getMen-hero.getMen.map{|man|man.getTarget}-[target]
+	  target.getMen-hero.getMen.map{|man|man.getTarget}-[target]-assignedTargets
 	end
 
 	def nonToRecruitLeft
@@ -865,11 +873,13 @@
 	end
 
 	def letRecruit(man)
+	  return false if countRecruited+countRecruiting>howManyToRecruit
 		target=getNext(man,getAssignableTargets)
 		if target
+      assert{countRecruited+countRecruiting<=howManyToRecruit}
 			man.hlJobMode[:recruitTarget]=target
 			man.newMoveJob(0,target,1)
-			@countRecruiting=@countRecruiting+1
+			#@countRecruiting=@countRecruiting+1
 			return true
 		end
 		false
@@ -882,9 +892,13 @@
 		menList=menList-[hero] if hasAtLeastOneFollower
 		menList.reverse.each{|man|
 			letRecruit(man)
-			break if @countRecruiting>=howManyToRecruit
+			break if countRecruiting+countRecruited>=howManyToRecruit
 		}
 	end
+  
+  def countRecruiting
+    hero.getMen.select{|man|man.hlJobMode[:recruitTarget]}.length
+  end
 end
 
 begin

Modified: antargis/trunk/ruby/jobs/ant_new_hljobs.rb
===================================================================
--- antargis/trunk/ruby/jobs/ant_new_hljobs.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/jobs/ant_new_hljobs.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -334,8 +334,8 @@
 	attr_accessor :targetPos
 	attr_accessor :formatDir
 	attr_accessor :target
-    attr_accessor :near
-	
+  attr_accessor :near
+
 	def initialize(hero,target)
 		@targetPos=target.getPos2D
 		@target=target

Modified: antargis/trunk/ruby/map.rb
===================================================================
--- antargis/trunk/ruby/map.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/map.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -64,13 +64,16 @@
 		assert{w.is_a?(Numeric)}
 		assert{h.is_a?(Numeric)}
 
-		if pScene.nil?
-			require 'ant_mock.rb'
-		end
+    # TODO: remove that ???
+		#if pScene.nil?
+		#	require 'ant_mock.rb'
+		#end
 
 		super(pScene,w,h)
 		@pause=false # is game paused
 		@app=app
+    
+    @classMapCache=nil
 
 		@@systemTime=0.0  # systemTime is needed for the playing of sounds - so they won't be played too often
 		@curTime=0.0      # curTime holds the current "date" of the world; the age of entities is measures by this
@@ -445,6 +448,10 @@
 			e.is_a?(type)
 		}
 	end
+  
+  def getApp
+    @app
+  end
 
 private	
 	def checkTriggers

Modified: antargis/trunk/ruby/meshes/grass.rb
===================================================================
--- antargis/trunk/ruby/meshes/grass.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/meshes/grass.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,10 +1,8 @@
 def getGrassMeshData(size,many=4,texture=nil,bush=false)
 	size=(size*10).to_i/10.0
 
-	if not $grassdata
-		$grassdata={}
-	end
-	if $grassdata[size]
+	$grassdata||={}
+ 	if $grassdata[size]
 		return $grassdata[size]
 	end
 	

Deleted: antargis/trunk/ruby/spec/geometry.rb
===================================================================
--- antargis/trunk/ruby/spec/geometry.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/geometry.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,27 +0,0 @@
-require 'ruby/antargislib.rb'
-require 'pp'
-
-describe AGCircle2,"a radius 2 circle around (10,10)" do
-	before(:each) do
-		@circleMiddle=AGVector2.new(10,10)
-		@radius=2
-		@circle=AGCircle2.new(@circleMiddle, at radius)
-	end
-
-	it "should hit an intersection line (9,0)-(9,20)" do
-		line=AGLine2.new(AGVector2.new(9,0),AGVector2.new(9,20))
-		list=@circle.collide(line)
-		list.length.should == 2
-		list.each{|p|(p- at circleMiddle).length.should == @radius}
-
-		# should lie on line
-		list.each{|p|p.x.should ==9}
-
-	end
-	it "should not hit an line at (9,0)-(119,0)" do
-		l2=AGLine2.new(AGVector2.new(9,0),AGVector2.new(119,0))
-		list=@circle.collide(l2)
-		list.length.should ==0
-
-	end
-end
\ No newline at end of file

Modified: antargis/trunk/ruby/spec/level_testing.rb
===================================================================
--- antargis/trunk/ruby/spec/level_testing.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/level_testing.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -46,26 +46,25 @@
 		end
 	end
 	
-    def clickAwayStory
-        telltaleWidget=widget("TellTale")
+  def clickAwayStory
+	  telltaleWidget=widget("TellTale")
 		raise if telltaleWidget.nil?
-        return if telltaleWidget.nil?
+    return if telltaleWidget.nil?
+	
+    telltaleWidget.should_not be_nil
+    telltaleWidget.should be_visible
+    okButton=telltaleWidget.child("ok")
+    okButton.should_not be_nil
+    okButton.click
+    trials=0
 
-        telltaleWidget.should_not be_nil
-        telltaleWidget.should be_visible
-        okButton=telltaleWidget.child("ok")
-        okButton.should_not be_nil
-        okButton.click
-        trials=0
-		
-        while telltaleWidget.visible?
-            okButton.click
-            @app.step
-            trials+=1
-            trials.should <10
-        end
-
+    while telltaleWidget.visible?
+      okButton.click
+      @app.step
+      trials+=1
+      trials.should <10
     end
+  end
 	
 	
 	def advance(time=nil)
@@ -78,12 +77,12 @@
 		end while time>step
 	end	
 
-    def hero(name)
-    	h=map.getByName(name)
+  def hero(name)
+  	h=map.getByName(name)
 		h.should_not be_nil
 		h.should be_a_kind_of(AntHero)
 		h
-    end
+  end
 	def building(name)
 		b=map.getByName(name)
 		b.should_not be_nil
@@ -99,8 +98,11 @@
 	end
 	
 	def waitForStory
-		while not (widget("TellTale").valid and widget("TellTale").visible?)
+	  while not storyIsDisplayed
 			advance
 		 end
-	end		
+	end
+  def storyIsDisplayed
+    widget("TellTale").valid and widget("TellTale").visible?
+  end  
 end
\ No newline at end of file

Deleted: antargis/trunk/ruby/spec/map.rb
===================================================================
--- antargis/trunk/ruby/spec/map.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/map.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,32 +0,0 @@
-require 'ruby/antargislib.rb'
-require 'map.rb'
-
-module TestingMap
-	@@testing=false
-	def Testing.initTesting
-		return if @@testing
-		@@testing=true
-
-		@@app=AGApplication.new
-		@@scene=Scene.new(800,600)
-	end
-
-	def Testing.getTestMapFor(test)
-		initTesting
-		case test
-			when :recruit
-				map=AntRubyMap.new(@@app,@@scene,800,600)
-				map.loadMap("data/levels/tutorial/tutorial0.antlvl")
-				map
-		end
-	end
-end
-
-describe AntRubyMap,"A BoA-Ruby-map" do
-	it "should run without UI at all" do
-		map=AntRubyMap.new(nil,nil,64,64)
-		map.move(1)
-	end
-
-	it "should be possible to create two maps concurrently (low prio)"
-end
\ No newline at end of file

Added: antargis/trunk/ruby/spec/spec_coding_style.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_coding_style.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_coding_style.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -0,0 +1,30 @@
+describe "Coding style C/++" do
+  it "shouldn't include any TABs anymore" do
+    (Dir["**/*.cc"]+Dir["**/*.h"]).each {|filename|
+      file=File.open(filename)
+      c=file.read
+      file.close
+      okfilename="#{filename} contains no tabs"
+      result=okfilename
+      result="#{filename} contains tabs" if c =~/\t/
+      
+      linenr=0
+      numbers=c.split("\n").map{|line|[line=~/\t/,linenr+=1]}.select{|l|l[0]}.map{|l|l[1]}
+      puts "failed line-numbers (#{filename}): #{numbers.join(",")}"
+      
+      result.should == okfilename
+    }
+  end
+  it "should not have senseless comments (outcommenting)"
+  it "should include decent documentation"
+  it "should include author/modification date"
+  it "should include GPL in all files"
+  it "should not have any TODOs left"
+end
+
+describe "Coding style Ruby" do
+  it "shouldn't include any TABs anymore"
+  it "should include decent documentation"
+  it "should include author/modification date"
+  it "should include GPL in all files"
+end
\ No newline at end of file

Added: antargis/trunk/ruby/spec/spec_entity.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_entity.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_entity.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -0,0 +1,3 @@
+describe "Tree" do
+  it "should not change mesh from now to then (=prevent tree dancing around)"
+end
\ No newline at end of file

Modified: antargis/trunk/ruby/spec/spec_game_gui.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_game_gui.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_game_gui.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,3 +1,5 @@
+#if false
+
 require 'ruby/spec/level_testing.rb'
 
 describe "Aggression buttons" do
@@ -69,3 +71,23 @@
 	it "should switch text color when enemy is pwned"
 end
 
+describe AntInfoBox do
+    include LevelTesting
+    before(:all) do
+      getTestApp(:tutorial0)
+      waitForStory
+      clickAwayStory
+    end
+
+	it "should be displayed when hero is badly hurt" do
+	   widget("InfoBox").should be_nil#
+	   hero("Rowen").decEnergy(0.9)
+	   advance
+       widget("InfoBox").should_not be_nil
+       widget("InfoBox").should be_visible
+	end
+end
+
+
+
+#end
\ No newline at end of file

Added: antargis/trunk/ruby/spec/spec_gc.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_gc.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_gc.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -0,0 +1,35 @@
+# DOES NOT WORK !!!!
+
+if false
+  require 'ruby/antargislib.rb'
+
+
+
+def doapp
+	address=nil
+	Module.new.module_eval{
+		app=AGApplication.new #AGMessageObject.new #(nil,AGRect2.new(0,0,100,100)) #AGApplication.new
+		address=getAddressOfRubyObject(app)
+		app=nil
+	}
+    address
+	#nil
+end
+
+describe "Garbage Collection" do
+	it "should handle AGApplication (alone) correctly" do
+		#setDebugLevel(0)
+		address=0
+		begin
+			address=doapp
+		end
+		GC.enable
+	    # allocate much mem (200 MB)
+		text="a"*1000*1000*300
+		GC.start
+		rubyObjectExists(address).should be_false
+		rubyObjectExists(getAddressOfRubyObject(getMain)).should be_true
+	end
+end
+
+end
\ No newline at end of file

Copied: antargis/trunk/ruby/spec/spec_geometry.rb (from rev 1229, antargis/trunk/ruby/spec/geometry.rb)

Modified: antargis/trunk/ruby/spec/spec_hljobs.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_hljobs.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_hljobs.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,3 +1,4 @@
+
 require 'ruby/spec/level_testing.rb'
 
 
@@ -83,8 +84,9 @@
 
 
 describe "Recruit job - aggression" do
+  include LevelTesting
 	it "men should fetch a few men if aggression is low"
-    it "men should fetch all men if aggression if high"
+  it "men should fetch all men if aggression if high"
 end
 
 
@@ -117,11 +119,22 @@
 		rowen=hero("Rowen")
 		waitForStory
 		clickAwayStory
+    widget("MessageBox").should be_nil
 		rowen.newHLBuildJob(rowen.getPos2D+AGVector2.new(-5,-10),AntTower)
+    widget("MessageBox").should_not be_nil
+    widget("MessageBox").should be_visible
+    widget("MessageBox").child("text").getText.should ==_("You can't build on water.")
 		rowen.getJob.should_not be_a_kind_of(AntHeroBuildJob)
 	end
+  it "should use meshes correctly (in correct order)"
+  it "should find resources correctly"
+  
 	describe "Continue a build job" do
 		it "should work correctly"
 	end
-	
+  
+  it "should let people rest enough when aggression is low"
+	it "should let people rest at the correct position"
 end
+
+

Added: antargis/trunk/ruby/spec/spec_map.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_map.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_map.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -0,0 +1,11 @@
+require "ruby/spec/level_testing.rb"
+
+describe AntRubyMap,"A BoA-Ruby-map" do
+	it "should run without UI at all" do
+		map=AntRubyMap.new(nil,nil,64,64)
+		map.move(1)
+	end
+  it "should not include ant_mock.rb when calling without GUI"
+
+	it "should be possible to create two maps concurrently (low prio)"
+end

Modified: antargis/trunk/ruby/spec/spec_menu.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_menu.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_menu.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,3 +1,5 @@
+#if false
+
 Dir.chdir(File.split(__FILE__)[0])
 
 require '../spec_helper.rb'
@@ -67,3 +69,4 @@
 	end
 end
 
+#end
\ No newline at end of file

Modified: antargis/trunk/ruby/spec/spec_run_tutorial.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_run_tutorial.rb	2008-02-15 20:44:14 UTC (rev 1229)
+++ antargis/trunk/ruby/spec/spec_run_tutorial.rb	2008-02-24 19:05:29 UTC (rev 1230)
@@ -1,55 +1,103 @@
 #Dir.chdir(File.split(__FILE__)[0])
 
 require 'ruby/spec_helper.rb'
-require 'ruby/gui/testing.rb'
+require 'ruby/spec/level_testing.rb'
 require 'ruby/ant_application.rb'
 
+# TODO: redesign spec for different runs
+
 describe 'Tutorial campaign' do
 	describe '- First level' do
-		include GuiTest
-		before(:all) do
-			# FIXME
-			file="data/levels/tutorial/tutorial0.antlvl"
-			clientConnection=nil
-			@app=makeTestAppClass(AntGameApp).new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
+	  include LevelTesting
+    describe "- disjoint tests" do
+			before do
+				@app=getTestApp(:tutorial0)
 		    @app.step
-			
-		end
-		it "should start off with a story telling dialog" do
-			telltaleWidget=widget("TellTale")
-			telltaleWidget.should_not be_nil
-			telltaleWidget.should be_visible
-			textWidget=telltaleWidget.child("text")
-			textWidget.should_not be_nil
-			text=textWidget.getText.to_s
-			okButton=telltaleWidget.child("ok")
-			okButton.should_not be_nil
-			okButton.click
-			text.should_not ==(textWidget.getText.to_s)
-			@app.step
-			clickAwayStory
-			
-		end
+				
+			end
+			it "should start off with a story telling dialog" do
+				telltaleWidget=widget("TellTale")
+				telltaleWidget.should_not be_nil
+				telltaleWidget.should be_visible
+				textWidget=telltaleWidget.child("text")
+				textWidget.should_not be_nil
+				text=textWidget.getText.to_s
+				okButton=telltaleWidget.child("ok")
+				okButton.should_not be_nil
+				okButton.click
+				text.should_not ==(textWidget.getText.to_s)
+				@app.step
+				clickAwayStory
+				
+			end
+
+      it "should be no problem to recruit only a few men at the beginning when aggression is low" do
+        storyIsDisplayed.should be_true
+        clickAwayStory
+        rowen=hero("Rowen")
+        keep=building("Keep")
+        rowen.getMen.length.should == 1
+        menCount=(rowen.getMen+keep.getMen).length
+        rowen.getAggression.should == 1
+        rowen.newHLRecruitJob(keep)
+        while rowen.hasHLJob
+          advance
+        end
+        rowen.getAggression.should == 1
+        rowen.hasHLJob.should be_false
+        rowen.getMen.length.should < menCount
+        keep.getMen.length.should > 0
+      end      
+      	    
+	    it "should be no problem to set aggression to maximum at the beginning" do
+	      storyIsDisplayed.should be_true
+	      clickAwayStory
+	      rowen=hero("Rowen")
+	      keep=building("Keep")
+	      rowen.getMen.length.should == 1
+	      menCount=(rowen.getMen+keep.getMen).length
+	      rowen.getAggression.should == 1
+	      rowen.setAggression(3.0)
+	      rowen.newHLRecruitJob(keep)
+	      while rowen.hasHLJob
+	        advance
+	      end
+	      rowen.getAggression.should == 3
+	      rowen.hasHLJob.should be_false
+	      rowen.getMen.length.should == menCount
+	      keep.getMen.length.should == 0
+	    end
+    end    
+    
 		describe '- State at the beginning' do
-		  before(:each) do
+		  before(:all) do
+	      @app=getTestApp(:tutorial0)
 			  @map=@app.getMap
 			  @map.should be_a_kind_of(AntRubyMap)
-			  clickAwayStory
+			  #clickAwayStory
 			  @enemy=nil
 			  @hero=nil
+        advance
 		  end
-          it "should display no story-telling anymore at this time" do
-          	widget("TellTale").should be_nil
-          end
+      it "should display a story-telling" do
+        storyIsDisplayed.should be_true
+        clickAwayStory
+      end
+      it "should display no story-telling anymore at this time" do
+        storyIsDisplayed.should be_false
+      end
+      it "- hero should have low aggression at the beginning" do
+        hero("Rowen").getAggression.should == 1
+      end
 
 			            	
 		  it "should include Rowen and an enemy" do
 		    heroes=@map.getOwnHeroes
-			enemies=@map.getHeroes- at map.getOwnHeroes
-			heroes.length.should == 1
-			enemies.length.should == 1
-			@hero=heroes[0]
-			@enemy=enemies[0]
+				enemies=@map.getHeroes- at map.getOwnHeroes
+				heroes.length.should == 1
+				enemies.length.should == 1
+				@hero=heroes[0]
+				@enemy=enemies[0]
 		  end
 		  it "should have a single enemy with a few troopers" do
 		  	getEnemy.getMen.length.should >2
@@ -61,66 +109,96 @@
 
 		  it "should have a tower with a few men" do
 		  	towers=@map.getBuildings
-			towers.length.should == 1
-			@tower=towers[0]
-			@tower.should be_a_kind_of(AntTower)
-			@tower.getMen.length>2
+				towers.length.should == 1
+				@tower=towers[0]
+				@tower.should be_a_kind_of(AntTower)
+				@tower.getMen.length>2
 		  end
 		  it "should include more men in tower than enemy has" do
 		  	tower=@map.getBuildings[0]
-			tower.getMen.length.should > getEnemy.getMen.length
+				tower.getMen.length.should > getEnemy.getMen.length
 		  end
 		  
 		end
-		it "should be possible to recruit some men" do
-			# do a recruit job
-			@map=@app.getMap
-			hero=getHero
-			building=getBuilding
-			hero.newHLRecruitJob(building)
-			while hero.hasHLJob
+    
+    describe "- normal run" do
+      before(:all) do
+        # nothing
+        @app=getTestApp(:tutorial0)
+        advance
+        clickAwayStory
+      end
+    
+			it "should be possible to recruit some men (not all)" do
+				# do a recruit job
+				@map=@app.getMap
+				hero=getHero
+	      hero.getAggression.should == 1
+				building=getBuilding
+				hero.newHLRecruitJob(building)
+				while hero.hasHLJob
+					advance
+				end
+				hero.getJob.should_not be_a_kind_of(AntHeroRecruitJob)
+				widget("TellTale").should be_visible
+				building.getMen.length.should > 0
+				hero.getMen.length.should >= 2
+			end
+	    it "should display a story part" do
+	      storyIsDisplayed.should be_true
+	      clickAwayStory
+	    end
+	
+	    it "should be possible to recruit the remaining men" do
+	      rowen=hero("Rowen")
+	      keep=building("Keep")
+	      rowen.setAggression(3)
+	      rowen.newHLRecruitJob(keep)
+	      menCount=rowen.getMen.length+keep.getMen.length
+	      while rowen.hasHLJob ; advance; end
+	      rowen.getMen.length.should == menCount
+	      keep.getMen.length.should == 0
+	      rowen.getMen.length.should > getEnemy.getMen.length
+	    end
+	    
+			it "should be possible to defeat enemy with low aggression" do
+			  
+				hero=getHero
+				enemy=getEnemy
+	      hero.setAggression(1)
+				hero.newHLFightJob(enemy)
+				hero.getJob.should be_a_kind_of(AntHeroFightJob)
+				enemy.hasHLJob.should be_false
+	      trials=300
+				while hero.hasHLJob
+					puts hero.getJob
+					advance
+	        break if storyIsDisplayed
+	        trials.should > 0
+	        trials-=1
+				end
+	      storyIsDisplayed.should be_true
+				clickAwayStory
 				advance
+		    @app.result.won.should == "won"
+	      map.getOwnHeroes.length.should == 2
 			end
-			hero.getJob.should_not be_a_kind_of(AntHeroRecruitJob)
-			widget("TellTale").should be_visible
-			building.getMen.length.should == 0
-			hero.getMen.length.should > 2
-			hero.getMen.length.should > getEnemy.getMen.length
 			
-
-		end
-		it "should be possible to defeat enemy" do
-	       clickAwayStory
-			hero=getHero
-			enemy=getEnemy
-			hero.newHLFightJob(enemy)
-			hero.getJob.should be_a_kind_of(AntHeroFightJob)
-			enemy.hasHLJob.should be_false
-			while hero.hasHLJob
-				puts hero.getJob
-				advance
+			
+			it "should be possible to dismiss some people" do
+				hero=getHero
+				hero.setAggression(1)
+				oldMenCount=hero.getMen.length
+				oldMenCount.should > 1
+				hero.newHLDismissJob
+				while hero.hasHLJob
+					advance
+				end
+				menCount=hero.getMen.length
+				menCount.should < oldMenCount
 			end
-			clickAwayStory
-			advance
-		    @app.result.won.should == "won"
-            map.getOwnHeroes.length.should == 2
-		end
+    end			
 		
-		
-		it "should be possible to dismiss some people" do
-			hero=getHero
-			hero.setAggression(1)
-			oldMenCount=hero.getMen.length
-			oldMenCount.should > 1
-			hero.newHLDismissJob
-			while hero.hasHLJob
-				advance
-			end
-			menCount=hero.getMen.length
-			menCount.should < oldMenCount
-		end
-		
-		
 	
 		def getEnemies
 			enemies=map.getHeroes-map.getOwnHeroes
@@ -135,31 +213,5 @@
 		def getBuilding
 			@app.getMap.getBuildings[0]
 		end
-	    def advance
-	    	@app.getMap.move(0.3)
-			@app.step
-	    end
-		def map
-		  @app.getMap
-		end
 	end
-	
-	def clickAwayStory
-		telltaleWidget=widget("TellTale")
-		return if telltaleWidget.nil?
-
-		telltaleWidget.should_not be_nil
-		telltaleWidget.should be_visible
-		okButton=telltaleWidget.child("ok")
-		okButton.should_not be_nil
-		okButton.click
-		trials=0
-		while telltaleWidget.visible?
-			okButton.click
-			@app.step
-			trials+=1
-			trials.should <10
-		end
-
-	end
 end
\ No newline at end of file



From davidkamphausen at mail.berlios.de  Sun Feb 24 20:08:13 2008
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 24 Feb 2008 20:08:13 +0100
Subject: [Antargis-svn] r1231 - antargis/trunk
Message-ID: <200802241908.m1OJ8Dwv002239@sheep.berlios.de>

Author: davidkamphausen
Date: 2008-02-24 20:08:12 +0100 (Sun, 24 Feb 2008)
New Revision: 1231

Modified:
   antargis/trunk/
Log:
* some additions to svn-ignore


Property changes on: antargis/trunk
___________________________________________________________________
Name: svn:ignore
   + coverage
*.bundle
starter.dSYM
spec_output.html
starter




From davidkamphausen at mail.berlios.de  Fri Feb 29 17:26:30 2008
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Fri, 29 Feb 2008 17:26:30 +0100
Subject: [Antargis-svn] r1233 - antargis/trunk
Message-ID: <200802291626.m1TGQUEI011680@sheep.berlios.de>

Author: davidkamphausen
Date: 2008-02-29 17:26:29 +0100 (Fri, 29 Feb 2008)
New Revision: 1233

Modified:
   antargis/trunk/
Log:
* some svn:ignores


Property changes on: antargis/trunk
___________________________________________________________________
Name: svn:ignore
   - coverage
*.bundle
starter.dSYM
spec_output.html
starter

   + coverage
*.bundle
starter.dSYM
spec_output.html
starter
.deps
.settings
antconfig.rb
events.txt
.cproject




