<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Antargis-svn] r1238 - in antargis/trunk: . build build/win32/libs	dev dev/3dengine_v2 ext/game ext/gui main rookey	rookey/configs rookey/cpp rookey/externals	rookey/externals/swig rookey/spec rookey/spec/cpp rookey/swig	ruby/entities ruby/jobs ruby/spec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/antargis-svn/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1238%20-%20in%20antargis/trunk%3A%20.%20build%20build/win32/libs%0A%09dev%20dev/3dengine_v2%20ext/game%20ext/gui%20main%20rookey%0A%09rookey/configs%20rookey/cpp%20rookey/externals%0A%09rookey/externals/swig%20rookey/spec%20rookey/spec/cpp%20rookey/swig%0A%09ruby/entities%20ruby/jobs%20ruby/spec&In-Reply-To=%3C200804081802.m38I27C8021259%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000195.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Antargis-svn] r1238 - in antargis/trunk: . build build/win32/libs	dev dev/3dengine_v2 ext/game ext/gui main rookey	rookey/configs rookey/cpp rookey/externals	rookey/externals/swig rookey/spec rookey/spec/cpp rookey/swig	ruby/entities ruby/jobs ruby/spec</H1>
    <B>davidkamphausen at BerliOS</B> 
    <A HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1238%20-%20in%20antargis/trunk%3A%20.%20build%20build/win32/libs%0A%09dev%20dev/3dengine_v2%20ext/game%20ext/gui%20main%20rookey%0A%09rookey/configs%20rookey/cpp%20rookey/externals%0A%09rookey/externals/swig%20rookey/spec%20rookey/spec/cpp%20rookey/swig%0A%09ruby/entities%20ruby/jobs%20ruby/spec&In-Reply-To=%3C200804081802.m38I27C8021259%40sheep.berlios.de%3E"
       TITLE="[Antargis-svn] r1238 - in antargis/trunk: . build build/win32/libs	dev dev/3dengine_v2 ext/game ext/gui main rookey	rookey/configs rookey/cpp rookey/externals	rookey/externals/swig rookey/spec rookey/spec/cpp rookey/swig	ruby/entities ruby/jobs ruby/spec">davidkamphausen at mail.berlios.de
       </A><BR>
    <I>Tue Apr  8 20:02:07 CEST 2008</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000195.html">[Antargis-svn] r1239 - in antargis/trunk: . data/gui/layout	data/gui/layout/editor data/gui/layout/editor/campaign dev	dev/3dengine_v2 ext/basic ext/gui ext/math ext/video rookey	rookey/configs rookey/cpp rookey/spec/.deps ruby/editor	ruby/editor/campaign
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#194">[ date ]</a>
              <a href="thread.html#194">[ thread ]</a>
              <a href="subject.html#194">[ subject ]</a>
              <a href="author.html#194">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: davidkamphausen
Date: 2008-04-08 20:02:03 +0200 (Tue, 08 Apr 2008)
New Revision: 1238

Added:
   antargis/trunk/.build_/
   antargis/trunk/build/antconfig.rb
   antargis/trunk/build/win32/libs/usr/
   antargis/trunk/configure
   antargis/trunk/configure.old
   antargis/trunk/dev/
   antargis/trunk/dev/3dengine_v2/
   antargis/trunk/dev/3dengine_v2/ant_camera.h
   antargis/trunk/dev/3dengine_v2/ant_camera_view.cc
   antargis/trunk/dev/3dengine_v2/ant_camera_view.h
   antargis/trunk/dev/3dengine_v2/ant_example_cube.h
   antargis/trunk/dev/3dengine_v2/ant_fbo.h
   antargis/trunk/dev/3dengine_v2/ant_gl.cc
   antargis/trunk/dev/3dengine_v2/ant_gl.h
   antargis/trunk/dev/3dengine_v2/ant_postprocessing.h
   antargis/trunk/dev/3dengine_v2/ant_render_mode.h
   antargis/trunk/dev/3dengine_v2/ant_render_pipelet.cc
   antargis/trunk/dev/3dengine_v2/ant_render_pipelet.h
   antargis/trunk/dev/3dengine_v2/ant_render_pipeline.cc
   antargis/trunk/dev/3dengine_v2/ant_render_pipeline.h
   antargis/trunk/dev/3dengine_v2/ant_render_scene_pipelet.cc
   antargis/trunk/dev/3dengine_v2/ant_render_scene_pipelet.h
   antargis/trunk/dev/3dengine_v2/ant_render_target.cc
   antargis/trunk/dev/3dengine_v2/ant_render_target.h
   antargis/trunk/dev/3dengine_v2/ant_renderable.h
   antargis/trunk/dev/3dengine_v2/ant_scene_graph.cc
   antargis/trunk/dev/3dengine_v2/ant_scene_graph.h
   antargis/trunk/dev/3dengine_v2/ant_scene_node.h
   antargis/trunk/dev/3dengine_v2/ant_screen_render_target.cc
   antargis/trunk/dev/3dengine_v2/ant_screen_render_target.h
   antargis/trunk/dev/3dengine_v2/ant_sdl.cc
   antargis/trunk/dev/3dengine_v2/ant_sdl.h
   antargis/trunk/dev/3dengine_v2/ant_simple_scene_graph.cc
   antargis/trunk/dev/3dengine_v2/ant_simple_scene_graph.h
   antargis/trunk/dev/3dengine_v2/ant_texture.h
   antargis/trunk/dev/3dengine_v2/ant_world.h
   antargis/trunk/dev/Rakefile
   antargis/trunk/dev/mytest.cc
   antargis/trunk/dev/rookey_configuration.rb
   antargis/trunk/dev/test
   antargis/trunk/dev/test.c
   antargis/trunk/less
   antargis/trunk/rookey/configs/png.rb
   antargis/trunk/rookey/externals/
   antargis/trunk/rookey/externals/built/
   antargis/trunk/rookey/externals/ext_config.rb
   antargis/trunk/rookey/externals/swig/
   antargis/trunk/rookey/externals/swig/build.rb
   antargis/trunk/rookey/rookey_config.rb
   antargis/trunk/rookey/spec/.deps/
   antargis/trunk/rookey/spec/d.h
   antargis/trunk/rookey/spec/file3_interface.i
   antargis/trunk/rookey/spec/file3_swig.cc
   antargis/trunk/rookey/spec/file3_swig.h
   antargis/trunk/rookey/spec/my_vector.i
   antargis/trunk/rookey/spec/rookey_configuration.rb
   antargis/trunk/rookey/swig/
   antargis/trunk/rookey/swig/swig_dyn_cast_containers.i
   antargis/trunk/ruby/spec/spec_local.rb
   antargis/trunk/ruby/spec/spec_swig.rb
Removed:
   antargis/trunk/configure
   antargis/trunk/rookey/antargis
   antargis/trunk/rookey/antargis.bundle
   antargis/trunk/rookey/spec/test
Modified:
   antargis/trunk/Rakefile
   antargis/trunk/ext/game/entity.cc
   antargis/trunk/ext/gui/ag_local.cc
   antargis/trunk/main/starter.cc
   antargis/trunk/rookey/compile.rb
   antargis/trunk/rookey/config_generator.rb
   antargis/trunk/rookey/configs/debug.rb
   antargis/trunk/rookey/configs/gl.rb
   antargis/trunk/rookey/configs/swig.rb
   antargis/trunk/rookey/cpp/ag_rubyobj.cc
   antargis/trunk/rookey/rookey.rb
   antargis/trunk/rookey/spec/a.h
   antargis/trunk/rookey/spec/b.h
   antargis/trunk/rookey/spec/cpp/ag_rubyobj.cc
   antargis/trunk/rookey/spec/spec_rookey.rb
   antargis/trunk/rookey/swig_interface_builder.rb
   antargis/trunk/rookey/tasks.rb
   antargis/trunk/ruby/entities/entity.rb
   antargis/trunk/ruby/jobs/ant_hljob_states.rb
   antargis/trunk/ruby/spec/spec_code_check.rb
   antargis/trunk/ruby/spec/spec_gui.rb
   antargis/trunk/ruby/spec/spec_hljobs.rb
Log:
* many additions/bugfixes

Modified: antargis/trunk/Rakefile
===================================================================
--- antargis/trunk/Rakefile	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/Rakefile	2008-04-08 18:02:03 UTC (rev 1238)
@@ -27,11 +27,21 @@
 end
 
 
+alias :oldSystem :system
+def system(cmd)
+  #puts Dir.pwd
+  if cmd=~/ruby .*/
+    cmd.gsub!(/^ruby/,&quot;./starter&quot;)
+  end
+  #puts cmd
+  oldSystem(cmd)
+end
 
+
 # rspec
 Spec::Rake::SpecTask.new(:spec=&gt;:default) do |t|
-        t.spec_files = FileList['**/spec_*.rb']
-        t.warning = true
-        t.rcov = true
-        t.spec_opts=[&quot;--format html:&quot;+File.expand_path(&quot;spec_output.html&quot;)]
+  t.spec_files = FileList['ruby/**/spec_*.rb'].map{|f|File.expand_path(f)}
+  t.warning = true
+  t.rcov = true
+  t.spec_opts=[&quot;--format html:&quot;+File.expand_path(&quot;spec_output.html&quot;)]
 end
\ No newline at end of file

Added: antargis/trunk/build/antconfig.rb
===================================================================

Deleted: antargis/trunk/configure
===================================================================
--- antargis/trunk/configure	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/configure	2008-04-08 18:02:03 UTC (rev 1238)
@@ -1,354 +0,0 @@
-#!/usr/bin/env ruby
-
-require 'optparse'
-require 'mkmf'
-require 'build/property.rb'
-require 'build/mkmf_support.rb'
-require 'pp'
-require 'logger'
-
-NEEDED_PROGRAMS={&quot;CC&quot;=&gt;&quot;gcc&quot;,&quot;CXX&quot;=&gt;&quot;g++&quot;,&quot;SWIG&quot;=&gt;&quot;swig&quot;,&quot;RUBY&quot;=&gt;&quot;ruby&quot;}
-POSSIBLE_PROGRAMS={&quot;CCACHE&quot;=&gt;&quot;ccache&quot;,&quot;SDL_CONFIG&quot;=&gt;&quot;sdl-config&quot;}
-
-NEEDED_LIBS=[
-	&quot;GL&quot;,&quot;GLU&quot;,&quot;png&quot;,&quot;SDL&quot;,&quot;SDL_image&quot;,&quot;SDL_ttf&quot;,&quot;SDL_mixer&quot;,&quot;stdc++&quot;,&quot;zs&quot;
-]
-FALLBACK_LIBS={&quot;GLU&quot;=&gt;&quot;glu32&quot;,&quot;GL&quot;=&gt;&quot;opengl32&quot;,&quot;ruby&quot;=&gt;&quot;msvcrt-ruby18&quot;,&quot;zs&quot;=&gt;&quot;z&quot;}
-
-def allPrograms
-	POSSIBLE_PROGRAMS.merge(NEEDED_PROGRAMS)
-end
-
-class ConfigureOptions
-	def self.parse(args)
-		options={}
-		options[:use_mkmf]=true
-		options[:use_env]=true
-		options[:use_sdlconfig]=true
-		options[:use_fallbacks]=true
-		options[:debug]=false
-		options[:gcdebug]=false
-		options[:profile]=false
-		options[:version]=&quot;0.2.1.5&quot;
-
-		options[:programs]={}
-		allPrograms.keys.each{|p|
-			options[:programs][p]=p
-		}
-	
-		opts=OptionParser.new do |opts|
-			opts.banner = &quot;Usage: configure [options]&quot;
-
-			opts.separator &quot;&quot;
-			opts.separator &quot;Specific options:&quot;
-
-			opts.on(&quot;-d&quot;, &quot;--enable-debug&quot;,
-							&quot;enable debugging&quot;) do 
-				options[:debug]=true
-			end
-
-			opts.on(&quot;-g&quot;,&quot;--enable-gc-debug&quot;,
-							&quot;enable debugging of garbage collector&quot;) do
-				options[:gcdebug]=true
-			end
-
-			opts.on(&quot;-p&quot;,&quot;--enable-profile&quot;,
-							&quot;enable c++ profiling&quot;) do 
-				options[:profile]=true
-			end
-
-			opts.on(&quot;--disable-sdlconfig&quot;,
-							&quot;do not use sdl-config for configuration&quot;) do 
-				options[:use_sdlconfig]=false
-			end
-			opts.on(&quot;--disable-fallbacks&quot;,
-							&quot;do not use fallback dirs for X11 and GL&quot;) do 
-				options[:use_fallbacks]=false
-			end
-
-			opts.on(&quot;--prefix PREFIXDIR&quot;,
-							&quot;set prefix directory PREFIXDIR&quot;) do |dir|
-				options[:prefix]=dir
-			end
-
-			opts.on(&quot;--drmuser DRMUSER&quot;,
-				&quot;set user for DRM&quot;) do |v|
-					options[:drmuser]=v
-			end
-			
-			opts.on(&quot;--drmpw DRMPASSWORD&quot;,
-				&quot;set password for DRM&quot;) do |v|
-					options[:drmpass]=v
-			end
-			
-			opts.on(&quot;-v&quot;,&quot;--version&quot;,
-				&quot;set release version of BoA&quot;) do |v|
-					options[:version]=v
-			end
-
-			opts.on(&quot;--ext-config CONFIG&quot;,
-				&quot;use user-defined config instead of ruby's mkmf&quot;,&quot;CONFIG maybe in mingw32 or unix&quot;) do |extconfig|
-					options[:extconfig]=extconfig
-					options[:use_mkmf]=false
-			end
-
-			allPrograms.keys.each{|program|
-				opts.on(&quot;--path-&quot;+program+&quot; PATH&quot;,
-					&quot;set path to program '#{program}'&quot;) do |d|
-					options[program]=d
-				end
-			}
-
-
-		end
-		opts.parse!(args)
-		options
-	end
-end
-
-######################
-# helpers
-######################
-
-def gatherENVConfig
-	config={}
-	[&quot;PATH&quot;,&quot;LDFLAGS&quot;,&quot;CFLAGS&quot;,&quot;CXX&quot;,&quot;CC&quot;,&quot;SWIG&quot;].each{|name|
-		if ENV[name]
-			config[name]=ENV[name]
-		end
-	}
-	# FIXME: add system-switch to cmd-line options
-	system=nil
-	unless config[&quot;PATH&quot;]=~/^[a-zA-Z]:\\/
-		config[&quot;PATH&quot;]=config[&quot;PATH&quot;].split(&quot;:&quot;) # Unix ?
-		system=:unix
-	else
-		config[&quot;PATH&quot;]=config[&quot;PATH&quot;].split(&quot;;&quot;) # Windows ?
-		system=:windows
-	end
-	config[&quot;PATH&quot;].each{|d|
-		puts &quot;\nWARNING: Something went wrong while checking PATH. Detected #{system} - was it wrong ? \n&quot; unless File.exists?(d)
-	}
-
-	config
-end
-
-def splitLDFLAGS(config)
-	ldflags=config[&quot;LDFLAGS&quot;].value.split(&quot; &quot;)
-	config.set!(&quot;LIBS&quot;,ldflags.select{|s|s=~/^-l/}.join(&quot; &quot;))
-	config.set!(&quot;LDFLAGS&quot;,ldflags.select{|s|not s=~/^-l/}.join(&quot; &quot;))
-	config
-end
-
-def splitCFLAGS(config)
-	cflags=config[&quot;CFLAGS&quot;].value.split(&quot; &quot;)
-	config[&quot;INCLUDEPATH&quot;]=cflags.select{|s|s=~/^-I/}.join(&quot; &quot;)
-	config[&quot;DEFINES&quot;]=cflags.select{|s|s=~/^-D/}.join(&quot; &quot;)
-	config
-end
-
-
-def gatherMkmfConfig
-	mkmfs={
-		&quot;CC&quot;=&gt;&quot;$(CC)&quot;,
-		&quot;LDSHARED&quot;=&gt;&quot;$(LDSHARED)&quot;,
-		&quot;RUBY&quot;=&gt;&quot;$(bindir)/$(ruby_install_name)&quot;,
-		&quot;LIBPATH&quot;=&gt;&quot;-L$(archdir) -L$(sitearchdir)&quot;,
-		&quot;CFLAGS&quot;=&gt;&quot;$(CFLAGS)&quot;,
-		&quot;LDFLAGS&quot;=&gt;&quot;$(LDFLAGS) $(LIBRUBYARG)&quot;,
-		&quot;INCLUDEPATH&quot;=&gt;&quot;-I$(includedir) -I$(archdir) -I$(sitearchdir)&quot;,
-		&quot;target_os&quot;=&gt;&quot;$(target_os)&quot;
-	}
-
-	config={}
-
-	mkmfs.each{|k,v|
-		value=checkMkmf(v,CONFIG)
-		config[k]=value if value
-	}
-
-	# post-process to get LIBS to separate variable
-	config
-end
-
-
-######################
-
-def getUserInput
-	options = ConfigureOptions.parse(ARGV)
-end
-
-def generateHardConfiguration(options)
-	config=Properties.new
-
-	allPrograms.each{|k,v|config[k]=v}
-
-	# FIXME: include default-dirs (/usr/include/GL, /usr/include/X11 /usr/X11/include and such - same for libs!!!
-
-	if options[:use_mkmf]
-		config.merge!(gatherMkmfConfig)
-	end
-	if options[:use_env]
-		config.merge!(gatherENVConfig)
-	end
-	config.merge!(Properties.new(options))
-
-	config
-end
-
-def testProgram(prg)
-	return false unless File.exist?(prg)
-	return true
-	#`#{prg} --help`
-	#$?==0
-end
-
-def searchPrograms(config)
-	allPrograms.each{|k,v|
-		ok=false
-		info=&quot;&quot;
-		if config[k].value!=v
-			# not default - check if ok
-			ok=testProgram(config[k].value)
-			info=&quot;(given by config)&quot;
-			unless ok
-				puts &quot;Given path #{config[k].value} for #{k} was not correct!&quot;
-			end
-		end
-		unless ok
-			pathes=config[&quot;PATH&quot;].value
-			pp pathes
-			
-			pathes.each{|path|
-				cpath=File.join(path,v)
-				pp cpath
-				
-				if testProgram(cpath)
-					config[k]=cpath
-					ok=true
-					break
-				end
-			}
-
-		end
-		if ok
-			puts &quot;#{k.ljust(10)} found at #{config[k].value.ljust(25)} #{info}&quot;
-		else
-			puts &quot;#{k.ljust(10)} not found!&quot;
-			config[k]=&quot;&quot;
-		end
-	}
-	config
-end
-
-def tryAddMissingLibs(config)
-	NEEDED_LIBS.each{|lib|
-		ok=have_library(lib)
-		unless ok
-			# check fallback
-
-			begin
-				have_library(FALLBACK_LIBS[lib])
-			rescue
-			end
-		end
-	}
-	if not $libs
-		puts &quot;ERROR: Not compatible with current mkmf!&quot;
-		exit
-	end
-	config[&quot;LDFLAGS&quot;]=$libs
-	config
-end
-
-def addSDLConfig(config,userInput)
-	if userInput[:use_sdlconfig]
-		sdlconf=config[&quot;SDL_CONFIG&quot;].value
-		pp sdlconf
-		return config if sdlconf==&quot;sdl-config&quot;
-		#pp sdlconf
-		cflags=`#{sdlconf} --cflags`.chomp
-		config[&quot;CFLAGS&quot;]=cflags if $?==0
-		puts &quot;#{sdlconf} --cflags exited with #{$?} and gave the output:\n#{cflags}&quot; if $?!=0
-		libs=`#{sdlconf} --libs`.chomp
-		config[&quot;LDFLAGS&quot;]=libs if $?==0
-		puts &quot;#{sdlconf} --libs exited with #{$?} and gave the output:\n#{libs}&quot; if $?!=0
-	end
-	config
-end
-
-def darwin?
-  CONFIG[&quot;host_os&quot;]=~/darwin/
-end
-
-def addStandardFallbacks(config,options)
-	if options[:use_fallbacks]
-		dirs=[&quot;/usr/include/GL&quot;]
-		dirs+=[&quot;/usr/include/X11&quot;,&quot;/usr/X11R6/include&quot;] #unless darwin?
-		config[&quot;INCLUDEPATH&quot;]=dirs.inject(&quot;&quot;){|str,d|str+&quot; -I&quot;+d}+&quot; -I.&quot;
-		config[&quot;CFLAGS&quot;]=&quot;-dH&quot;
-	
-		dirs=[&quot;/usr/lib/GL&quot;]
-		dirs+=[&quot;/usr/lib/X11&quot;,&quot;/usr/X11R6/lib&quot;] unless darwin?
-		config[&quot;LIBPATH&quot;]=dirs.inject(&quot;&quot;){|str,d|str+&quot; -L&quot;+d}
-	end	
-	config
-end
-
-def checkFlags(config,options)
-	if options[:debug]
-		options=config[&quot;CFLAGS&quot;].value.split(&quot; &quot;).select{|op|not op=~/^-O[0-5]$/}.join(&quot; &quot;)
-		config.set!(&quot;CFLAGS&quot;,options+&quot; -O0 -g&quot;)
-	end
-	if options[:profile]
-		config[&quot;CFLAGS&quot;]=&quot;-pg&quot; 
-		config[&quot;LDFLAGS&quot;]=&quot;-pg&quot;
-	end
-	config
-end
-
-def runChecks(config)
-	begin
-		`rake test`
-	rescue
-		puts &quot;Test failed&quot;
-	end
-end
-
-def saveConfigurationFile(config)
-	file=File.open(&quot;antconfig.rb&quot;,&quot;w&quot;)
-	file.puts config.toRuby
-	file.close
-end
-
-# FIXME: add check for darwin
-unless CONFIG[&quot;host_os&quot;]=~/darwin/
-  $LDFLAGS+=&quot; -L/usr/X11R6/lib&quot;
-end
-
-$LDFLAGS+=&quot; -L/opt/local/lib&quot;
-
-
-userInput=getUserInput
-config=generateHardConfiguration(userInput)
-config=searchPrograms(config)
-config=tryAddMissingLibs(config)
-config=addSDLConfig(config,userInput)
-config=addStandardFallbacks(config,userInput)
-config=checkFlags(config,userInput)
-config=splitLDFLAGS(config)
-config=splitCFLAGS(config)
-
-if CONFIG[&quot;host_os&quot;]=~/darwin/
- 
-  [&quot;LDSHARED&quot;,&quot;LDFLAGS&quot;,&quot;CFLAGS&quot;].each{|name|
-    config[name].value=config[name].value.gsub(&quot;-arch ppc&quot;,&quot;&quot;)
-  }
-end
-
-saveConfigurationFile(config)
-runChecks(config)
-
-
-
-#pp config
\ No newline at end of file

Added: antargis/trunk/configure
===================================================================
--- antargis/trunk/configure	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/configure	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,20 @@
+#!/usr/bin/env ruby
+
+require File.join(File.split(__FILE__)[0],&quot;rookey&quot;,&quot;rookey_config.rb&quot;)
+
+config=Rookey::Configure.new
+config.run do |opts|
+
+  opts.on(&quot;--drmuser DRMUSER&quot;,
+    &quot;set user for DRM&quot;) do |v|
+      config.set(:drmuser,v)
+  end
+  
+  opts.on(&quot;--drmpw DRMPASSWORD&quot;,
+    &quot;set password for DRM&quot;) do |v|
+      config.set(:drmpass,v)
+  end  
+end
+puts
+puts &quot;Run 'rake clean' for changes to take effect on already built files!&quot;
+puts

Copied: antargis/trunk/configure.old (from rev 1235, antargis/trunk/configure)


Property changes on: antargis/trunk/configure.old
___________________________________________________________________
Name: svn:executable
   + *

Added: antargis/trunk/dev/3dengine_v2/ant_camera.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_camera.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_camera.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,11 @@
+#ifndef ANT_CAMERA_H
+#define ANT_CAMERA_H
+
+class AntCamera
+  {
+public:
+  virtual void setupView();
+  };
+
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_camera.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_camera_view.cc
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_camera_view.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_camera_view.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,13 @@
+#include &quot;ant_camera_view.h&quot;
+
+AntCameraView::AntCameraView(AntSceneGraph *pScene,AntCamera *pCamera):
+  mScene(pScene),
+  mCamera(pCamera)
+    {
+
+    }
+
+void AntCameraView::render(const AntRenderMode &amp;pMode)
+  {
+    mScene-&gt;render(*mCamera,pMode);
+  }


Property changes on: antargis/trunk/dev/3dengine_v2/ant_camera_view.cc
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_camera_view.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_camera_view.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_camera_view.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,17 @@
+#ifndef ANT_CAMERA_VIEW_H
+#define ANT_CAMERA_VIEW_H
+
+#include &quot;ant_camera.h&quot;
+#include &quot;ant_scene_graph.h&quot;
+
+class AntCameraView
+  {
+    AntSceneGraph *mScene;
+    AntCamera *mCamera;
+public:
+  AntCameraView(AntSceneGraph *pScene,AntCamera *pCamera);
+  
+  void render(const AntRenderMode &amp;pMode);
+  };
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_camera_view.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_example_cube.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_example_cube.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_example_cube.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,6 @@
+#ifndef ANT_EXAMPLE_CUBE_H
+#define ANT_EXAMPLE_CUBE_H
+
+
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_example_cube.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_fbo.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_fbo.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_fbo.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,9 @@
+#ifndef ANT_FBO_H
+#define ANT_FBO_H
+
+class AntFBO
+  {
+    
+  };
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_fbo.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_gl.cc
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_gl.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_gl.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,66 @@
+#include &lt;iostream&gt;
+#include &lt;SDL.h&gt;
+#include &lt;SDL_opengl.h&gt;
+
+#include &quot;ant_gl.h&quot;
+#include &quot;ant_sdl.h&quot;
+
+AntGL::AntGL()
+  {
+    needsSDL();
+    std::cout&lt;&lt;&quot;ANTGL&quot;&lt;&lt;std::endl;
+    mScreenwidth=0;
+    mScreenheight=0;
+    std::cout&lt;&lt;&quot;ANTGL&quot;&lt;&lt;std::endl;
+  }
+
+
+void AntGL::initVideoMode(int w,int h,bool fs)
+  {
+    static const SDL_VideoInfo *videoInfo=0;
+    if(!videoInfo)
+      {
+        videoInfo = SDL_GetVideoInfo();
+        if(!videoInfo)
+          {
+            std::cerr&lt;&lt;&quot;SDL could not get video-info&quot;&lt;&lt;std::endl;
+            exit(1);
+          }
+      }
+    int videoFlags=0;
+
+    videoFlags|=SDL_OPENGL;
+
+    if(fs)
+      videoFlags|=SDL_FULLSCREEN;
+
+    SDL_Surface *ms=SDL_SetVideoMode(w,h,videoInfo-&gt;vfmt-&gt;BitsPerPixel,videoFlags);
+    if(!ms)
+      {
+        std::cerr&lt;&lt;&quot;Initing video mode failed!&quot;&lt;&lt;std::endl;
+        std::cerr&lt;&lt;&quot;SDL:Error:&quot;&lt;&lt;SDL_GetError()&lt;&lt;std::endl;
+        std::cerr&lt;&lt;&quot;If you experience errors here, it may be that one following is true:&quot;&lt;&lt;std::endl;
+        std::cerr&lt;&lt;&quot;* SDL is compiled without OpenGL support&quot;&lt;&lt;std::endl;
+        std::cerr&lt;&lt;&quot;* Your display has no support for GLX&quot;&lt;&lt;std::endl;
+        std::cerr&lt;&lt;&quot;* You're running SDL with framebuffer - instead of X&quot;&lt;&lt;std::endl;
+        exit(1);
+      }
+
+
+    mScreenwidth=w;
+    mScreenheight=h;
+
+
+    SDL_WM_SetCaption(&quot;Antargis&quot;,&quot;Antargis&quot;);
+  }
+
+void AntGL::clearBuffer()
+  {
+    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+  }
+
+
+void AntGL::swapBuffers()
+  {
+    SDL_GL_SwapBuffers();
+  }


Property changes on: antargis/trunk/dev/3dengine_v2/ant_gl.cc
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_gl.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_gl.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_gl.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,18 @@
+#ifndef ANT_GL_H
+#define ANT_GL_H
+
+class AntGL
+  {
+    int mScreenwidth;
+    int mScreenheight;
+public:
+  AntGL();
+  void initVideoMode(int w,int h,bool fs=false);
+  void swapBuffers();
+  void clearBuffer();
+  
+  
+  };
+
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_gl.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_postprocessing.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_postprocessing.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_postprocessing.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,10 @@
+#ifndef ANT_POSTPROCESSING_H
+#define ANT_POSTPROCESSING_H
+
+class AntPostProcessing: public AntRenderPipelet
+  {
+public:
+  AntPostProcessing(AntRenderTarget *pRenderTarget);
+  };
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_postprocessing.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_render_mode.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_render_mode.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_render_mode.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,9 @@
+#ifndef ANT_RENDER_MODE_H
+#define ANT_RENDER_MODE_H
+
+class AntRenderMode
+  {
+    
+  };
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_render_mode.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_render_pipelet.cc
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_render_pipelet.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_render_pipelet.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,34 @@
+#include &quot;ant_render_pipelet.h&quot;
+
+AntRenderPipelet::AntRenderPipelet(AntRenderTarget *pRenderTarget):
+  mRenderTarget(pRenderTarget)
+        {
+
+        }
+AntRenderPipelet::~AntRenderPipelet()
+  {
+
+  }
+
+
+void AntRenderPipelet::render()
+  {
+
+  }
+
+std::set&lt;AntRenderPipelet*&gt; AntRenderPipelet::getPrerequisites() const
+{
+  return mPrerequisites;
+}
+
+void AntRenderPipelet::addPrerequisite(AntRenderPipelet *pPipelet)
+  {
+    mPrerequisites.insert(pPipelet);
+  }
+
+void AntRenderPipelet::doRender()
+  {
+    mRenderTarget-&gt;select();
+    render();
+    
+  }


Property changes on: antargis/trunk/dev/3dengine_v2/ant_render_pipelet.cc
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_render_pipelet.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_render_pipelet.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_render_pipelet.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,26 @@
+#ifndef ANT_RENDER_PIPELET_H
+#define ANT_RENDER_PIPELET_H
+
+#include &lt;set&gt;
+
+#include &quot;ant_render_target.h&quot;
+
+class AntRenderPipelet
+  {
+    std::set&lt;AntRenderPipelet*&gt; mPrerequisites;
+    AntRenderTarget *mRenderTarget;
+public:
+  AntRenderPipelet(AntRenderTarget *pRenderTarget);
+  virtual ~AntRenderPipelet();
+
+  virtual void render();
+  
+  void doRender();
+
+  std::set&lt;AntRenderPipelet*&gt; getPrerequisites() const;
+
+  void addPrerequisite(AntRenderPipelet *pPipelet);
+
+  };
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_render_pipelet.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_render_pipeline.cc
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_render_pipeline.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_render_pipeline.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,57 @@
+#include &quot;ant_render_pipeline.h&quot;
+
+AntRenderPipeline::AntRenderPipeline()
+  {
+
+  }
+AntRenderPipeline::~AntRenderPipeline()
+  {
+
+  }
+void AntRenderPipeline::insert(AntRenderPipelet *pPipelet)
+  {
+    mPipelets.insert(pPipelet);
+  }
+
+void AntRenderPipeline::render()
+  {
+    buildPipeletOrder();
+    
+    for(std::list&lt;AntRenderPipelet*&gt;::iterator i=mPipeletOrder.begin();i!=mPipeletOrder.end();i++)
+      (*i)-&gt;render();
+  }
+
+void AntRenderPipeline::buildPipeletOrder()
+  {
+    if(mPipelets.size()!=mPipeletOrder.size()) {
+      // rebuild order list
+      mPipeletOrder.clear();
+      std::set&lt;AntRenderPipelet*&gt; builtPipelets;
+      
+      // while not all pipelets are ordered
+      while(mPipelets.size()&gt;mPipeletOrder.size()) {
+        std::set&lt;AntRenderPipelet*&gt;::iterator i=mPipelets.begin();
+        for(;i!=mPipelets.end();i++)
+          {
+           if(builtPipelets.find(*i)==builtPipelets.end()) {
+             // not yet built - check if prerequisites ok
+             std::set&lt;AntRenderPipelet*&gt; pre=(*i)-&gt;getPrerequisites();
+             std::set&lt;AntRenderPipelet*&gt;::iterator preIter=pre.begin();
+             for(;preIter!=pre.end();preIter++)
+               {
+                 if(builtPipelets.find(*preIter)==builtPipelets.end())
+                   break;
+               }
+             if(preIter==pre.end()) // ok, none found that wasn't built yet, so it's ok to push it
+               {
+                 builtPipelets.insert(*i);
+                 mPipeletOrder.push_back(*i);
+               }
+             
+           }
+          }
+        
+      }
+    }
+  }
+


Property changes on: antargis/trunk/dev/3dengine_v2/ant_render_pipeline.cc
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_render_pipeline.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_render_pipeline.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_render_pipeline.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,25 @@
+#ifndef ANT_RENDER_PIPELINE_H
+#define ANT_RENDER_PIPELINE_H
+
+#include &lt;set&gt;
+#include &lt;list&gt;
+
+#include &quot;ant_render_pipelet.h&quot;
+
+class AntRenderPipeline
+  {
+    std::set&lt;AntRenderPipelet*&gt; mPipelets;
+    std::list&lt;AntRenderPipelet*&gt; mPipeletOrder;
+
+public:
+  AntRenderPipeline();
+  ~AntRenderPipeline();
+  void insert(AntRenderPipelet *pPipelet);
+  
+  void render();
+
+private:
+  void buildPipeletOrder();
+  };
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_render_pipeline.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_render_scene_pipelet.cc
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_render_scene_pipelet.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_render_scene_pipelet.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,24 @@
+
+#include &quot;ant_render_scene_pipelet.h&quot;
+
+AntRenderScenePipelet::AntRenderScenePipelet(AntRenderTarget *pRenderTarget,AntCameraView *pView,AntRenderMode pMode):
+  AntRenderPipelet(pRenderTarget),
+  mView(pView),
+  mMode(pMode)
+  {
+    
+  }
+AntRenderScenePipelet::~AntRenderScenePipelet()
+  {
+    
+  }
+
+void AntRenderScenePipelet::render()
+  {
+    mView-&gt;render(mMode);
+  }
+AntCameraView *AntRenderScenePipelet::getView()
+  {
+    return mView;
+  }
+


Property changes on: antargis/trunk/dev/3dengine_v2/ant_render_scene_pipelet.cc
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_render_scene_pipelet.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_render_scene_pipelet.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_render_scene_pipelet.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,28 @@
+#ifndef ANT_RENDER_PIPELINE_H
+#define ANT_RENDER_PIPELINE_H
+
+#include &lt;set&gt;
+#include &lt;list&gt;
+
+#include &quot;ant_render_pipelet.h&quot;
+#include &quot;ant_camera_view.h&quot;
+#include &quot;ant_render_mode.h&quot;
+
+class AntRenderScenePipelet:public AntRenderPipelet
+  {
+    std::set&lt;AntRenderPipelet*&gt; mPrerequisites;
+    AntCameraView *mView;
+    AntRenderMode mMode;
+public:
+  AntRenderScenePipelet(AntRenderTarget *pRenderTarget,AntCameraView *pView,AntRenderMode pMode);
+  ~AntRenderScenePipelet();
+
+  void render();
+
+protected:
+  AntCameraView *getView();
+
+  };
+
+#endif
+


Property changes on: antargis/trunk/dev/3dengine_v2/ant_render_scene_pipelet.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_render_target.cc
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_render_target.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_render_target.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,6 @@
+#include &quot;ant_render_target.h&quot;
+
+AntRenderTarget::~AntRenderTarget()
+  {
+    
+  }


Property changes on: antargis/trunk/dev/3dengine_v2/ant_render_target.cc
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_render_target.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_render_target.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_render_target.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,24 @@
+#ifndef ANT_RENDER_TARGET_H
+#define ANT_RENDER_TARGET_H
+
+#include &quot;ant_fbo.h&quot;
+
+class AntRenderTarget
+  {
+public:
+  virtual ~AntRenderTarget();
+  virtual void select()=0;
+  };
+
+
+
+class AntFBORenderTarget:public AntRenderTarget
+  {
+    AntFBO *mFBO;
+public:
+  AntFBORenderTarget(AntFBO &amp;pFBO);
+  ~AntFBORenderTarget();
+  virtual void select(); 
+  };
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_render_target.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_renderable.h
===================================================================


Property changes on: antargis/trunk/dev/3dengine_v2/ant_renderable.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_scene_graph.cc
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_scene_graph.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_scene_graph.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,25 @@
+#include &quot;ant_scene_graph.h&quot;
+
+AntSceneGraph::~AntSceneGraph()
+  {
+
+  }
+
+void AntSceneGraph::add(AntSceneNode *pNode)
+  {
+    mAllNodes.insert(pNode); 
+  }
+void AntSceneGraph::erase(AntSceneNode *pNode)
+  {
+    mAllNodes.erase(pNode); 
+  }
+
+const std::set&lt;AntSceneNode*&gt; AntSceneGraph::getAllNodes() const
+{
+  return mAllNodes;
+}
+
+void AntSceneGraph::render(const AntCamera &amp;pCamera,const AntRenderMode &amp;pRenderMode)
+  {
+    
+  }


Property changes on: antargis/trunk/dev/3dengine_v2/ant_scene_graph.cc
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_scene_graph.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_scene_graph.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_scene_graph.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,24 @@
+#ifndef ANT_SCENE_GRAPH_H
+#define ANT_SCENE_GRAPH_H
+
+#include &lt;set&gt;
+
+#include &quot;ant_scene_node.h&quot;
+#include &quot;ant_camera.h&quot;
+
+class AntSceneGraph
+  {
+    std::set&lt;AntSceneNode*&gt; mAllNodes;
+public:
+  virtual ~AntSceneGraph();
+  
+  virtual void add(AntSceneNode *pNode);
+  virtual void erase(AntSceneNode *pNode);
+  
+  const std::set&lt;AntSceneNode*&gt; getAllNodes() const;
+  
+  virtual void render(const AntCamera &amp;pCamera,const AntRenderMode &amp;pRenderMode);
+
+  };
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_scene_graph.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_scene_node.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_scene_node.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_scene_node.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,12 @@
+#ifndef ANT_SCENE_NODE_H
+#define ANT_SCENE_NODE_H
+
+#include &quot;ant_render_mode.h&quot;
+
+class AntSceneNode
+  {
+public:
+  virtual void render(const AntRenderMode &amp;pMode); 
+  };
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_scene_node.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_screen_render_target.cc
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_screen_render_target.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_screen_render_target.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,7 @@
+#include &quot;ant_screen_render_target.h&quot;
+
+void AntScreenRenderTarget::select()
+  {
+
+  }
+


Property changes on: antargis/trunk/dev/3dengine_v2/ant_screen_render_target.cc
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_screen_render_target.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_screen_render_target.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_screen_render_target.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,12 @@
+#ifndef ANT_SCREEN_RENDER_TARGET_H
+#define ANT_SCREEN_RENDER_TARGET_H
+
+#include &quot;ant_render_target.h&quot;
+
+class AntScreenRenderTarget:public AntRenderTarget
+  {
+public:
+  void select();
+  };
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_screen_render_target.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_sdl.cc
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_sdl.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_sdl.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,32 @@
+#include &quot;ant_sdl.h&quot;
+
+#include &lt;iostream&gt;
+#include &lt;SDL.h&gt;
+
+
+AntSDL *AntSDL::myInstance=0;
+
+AntSDL::AntSDL()
+  {
+    if(SDL_Init(SDL_INIT_VIDEO|SDL_INIT_NOPARACHUTE|SDL_INIT_AUDIO)&lt;0)
+      {
+        std::cerr&lt;&lt;&quot;SDL could not be initialized!&quot;&lt;&lt;std::endl;
+        exit(1);
+      }
+    SDL_EnableUNICODE(1);
+    std::cout&lt;&lt;&quot;SDL initialized!&quot;&lt;&lt;std::endl;
+  }
+
+AntSDL *AntSDL::getInstance()
+  {
+    if(!myInstance)
+      myInstance=new AntSDL();
+    return myInstance;
+  }
+
+void needsSDL()
+  {
+    std::cout&lt;&lt;&quot;NEEDS::&quot;&lt;&lt;std::endl;
+    AntSDL::getInstance();
+    std::cout&lt;&lt;&quot;NEEDS::&quot;&lt;&lt;std::endl;
+  }


Property changes on: antargis/trunk/dev/3dengine_v2/ant_sdl.cc
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_sdl.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_sdl.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_sdl.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,16 @@
+#ifndef ANT_SDL_H
+#define ANT_SDL_H
+
+class AntSDL
+  {
+public:
+  static AntSDL *getInstance();
+private:
+  AntSDL();
+  
+  static AntSDL *myInstance;
+  };
+
+void needsSDL();
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_sdl.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_simple_scene_graph.cc
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_simple_scene_graph.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_simple_scene_graph.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,6 @@
+#include &quot;ant_simple_scene_graph.h&quot;
+
+void AntSimpleSceneGraph::render(const AntCamera &amp;pCamera,const AntRenderMode &amp;pRenderMode)
+  {
+    
+  }


Property changes on: antargis/trunk/dev/3dengine_v2/ant_simple_scene_graph.cc
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_simple_scene_graph.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_simple_scene_graph.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_simple_scene_graph.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,12 @@
+#ifndef ANT_SIMPLE_SCENE_GRAPH_H
+#define ANT_SIMPLE_SCENE_GRAPH_H
+
+#include &quot;ant_scene_graph.h&quot;
+
+class AntSimpleSceneGraph:public AntSceneGraph
+  {
+public:
+    void render(const AntCamera &amp;pCamera,const AntRenderMode &amp;pRenderMode);
+  };
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_simple_scene_graph.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_texture.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_texture.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_texture.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,19 @@
+#ifndef ANT_TEXTURE_H
+#define ANT_TEXTURE_H
+
+class AntTexture
+  {
+    
+  };
+
+class AntTexture2D:public AntTexture
+  {
+    
+  };
+
+class AntTexture3D:public AntTexture
+  {
+    
+  };
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_texture.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/3dengine_v2/ant_world.h
===================================================================
--- antargis/trunk/dev/3dengine_v2/ant_world.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/3dengine_v2/ant_world.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,24 @@
+#ifndef ANT_WORLD
+#define ANT_WORLD
+
+#include &lt;set&gt;
+
+#include &quot;ant_camera_view.h&quot;
+
+class AntWorld
+  {
+    AntSceneGraph *mSceneGraph;
+    std::set&lt;AntCamera&gt; *mCameras;
+    std::set&lt;AntCameraViews&gt; *mViews;
+    std::set&lt;AntRenderPipeline&gt; *mPipelines;
+public:
+  void render();
+  
+  AntCamera *newCamera();
+  AntCamerView *newView(const AntCamera &amp;pCamera);
+  
+  
+  
+  };
+
+#endif


Property changes on: antargis/trunk/dev/3dengine_v2/ant_world.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/Rakefile
===================================================================
--- antargis/trunk/dev/Rakefile	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/Rakefile	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,12 @@
+require File.join(File.split(__FILE__)[0],&quot;..&quot;,'rookey','tasks.rb')
+
+Rookey::getConfig.add(&quot;INCLUDEDIRS&quot;,&quot;3dengine_v2&quot;)
+
+objs=Rookey::compile(Dir[&quot;**/*.cc&quot;])
+exe=Rookey::link_exe(&quot;test3d&quot;,objs)
+
+task :test=&gt;[exe] do
+  sh &quot;./&quot;+exe
+end
+
+task :default =&gt; [:test]
\ No newline at end of file

Added: antargis/trunk/dev/mytest.cc
===================================================================
--- antargis/trunk/dev/mytest.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/mytest.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,14 @@
+#include &quot;ant_gl.h&quot;
+
+#include &lt;SDL.h&gt;
+#include &lt;iostream&gt;
+
+int main(int argc,char *argv[])
+  {
+    AntGL gl;
+    gl.initVideoMode(800,600);
+    gl.clearBuffer();
+    gl.swapBuffers();
+    SDL_Delay(1000);
+    return 0;
+  }


Property changes on: antargis/trunk/dev/mytest.cc
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/dev/rookey_configuration.rb
===================================================================
--- antargis/trunk/dev/rookey_configuration.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/rookey_configuration.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,3 @@
+ROOKEY_CONFIG={
+
+}

Added: antargis/trunk/dev/test
===================================================================
(Binary files differ)


Property changes on: antargis/trunk/dev/test
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: antargis/trunk/dev/test.c
===================================================================
--- antargis/trunk/dev/test.c	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/dev/test.c	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1 @@
+extern &quot;C&quot; void png_get_io_ptr();int main(){return 0;}


Property changes on: antargis/trunk/dev/test.c
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Modified: antargis/trunk/ext/game/entity.cc
===================================================================
--- antargis/trunk/ext/game/entity.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/ext/game/entity.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -26,10 +26,10 @@
 #include &quot;anim_mesh.h&quot;
 
 AntEntity::AntEntity(AntMap *pMap):mMap(pMap),mPos(0,0,0)
-{
-  assert(mMap);
-  init();
-}
+      {
+        assert(mMap);
+        init();
+      }
 
 void AntEntity::init()
   {
@@ -81,7 +81,8 @@
 
 AntEntity::~AntEntity()
   {
-    //  CTRACE;
+    CTRACE;
+    //#error called several times
     for(Meshes::iterator i=mMeshes.begin();i!=mMeshes.end();i++)
       saveDelete(*i);
     mMeshes.clear();
@@ -651,7 +652,9 @@
   {
     AGRubyObject::mark();
     for(Meshes::iterator i=mMeshes.begin();i!=mMeshes.end();i++)
-      markObject(*i);
+      {
+        markObject(*i);
+      }
 
     if(mJob)
       {

Modified: antargis/trunk/ext/gui/ag_local.cc
===================================================================
--- antargis/trunk/ext/gui/ag_local.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/ext/gui/ag_local.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -37,6 +37,7 @@
 
 void setLocalizer(AGLocalizer *p)
   {
+    cdebug(&quot;setLocal:&quot;&lt;&lt;p);
     gLocalizer=p;
   }
 

Added: antargis/trunk/less
===================================================================
--- antargis/trunk/less	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/less	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,251 @@
+(in /Users/davidkamphausen/projects/antargis)
+parent unknown std::exception
+parent unknown std::string
+parent unknown SDL_Color
+AGRubyObject=&gt;c
+AnimMeshData=&gt;c
+Mesh2DData=&gt;c
+MeshData=&gt;c
+SceneBase=&gt;c
+SceneNode=&gt;c
+AGCollector=&gt;c
+AGMain=&gt;c
+AGMessageTransceiver=&gt;c
+AGListener=&gt;c
+AGPlugin=&gt;c
+AGRandomizerBase=&gt;c
+AGSingleton=&gt;c
+AntEntity=&gt;c
+PathWeighter=&gt;c
+SimpleGraph=&gt;c
+Pathfinder=&gt;c
+TerrainBase=&gt;c
+AGPaintTarget=&gt;c
+Scene=&gt;c
+Scene2D=&gt;c
+AntParticle=&gt;c
+Boa3dWireframe=&gt;c
+MeshBase=&gt;c
+TerrainPiece=&gt;c
+WaterPiece=&gt;c
+AGMessageObject=&gt;c
+AGRandomizer=&gt;c
+AGVideoBase=&gt;c
+AGLayoutCreator=&gt;c
+AGFontEngine=&gt;c
+MapPathWeighter=&gt;c
+DecimatedGraph=&gt;c
+Terrain=&gt;c
+AGClipPaintTarget=&gt;c
+AGScreen=&gt;c
+AGSurface=&gt;c
+AGTexture=&gt;c
+AnimMesh=&gt;c
+Mesh=&gt;c
+Mesh2D=&gt;c
+HeightMap=&gt;c
+AGApplication=&gt;c
+AGWidget=&gt;c
+AGSound=&gt;c
+AGVideoManager=&gt;c
+AGGLScreen=&gt;c
+AGSDLScreen=&gt;c
+AGSDLScreen=&gt;c
+AntMap=&gt;c
+GLApp=&gt;c
+AGGLWidget=&gt;c
+MiniMap=&gt;c
+AGButton=&gt;c
+AGColorButton=&gt;c
+AGComboBox=&gt;c
+AGEdit=&gt;c
+AGFrame=&gt;c
+AGImage=&gt;c
+AGLayout=&gt;c
+AGListBox=&gt;c
+AGRadioGroup=&gt;c
+AGScreenWidget=&gt;c
+AGScroller=&gt;c
+AGTable=&gt;c
+AGText=&gt;c
+AGTooltip=&gt;c
+AGCheckBox=&gt;c
+AGMenu=&gt;c
+AGMenuItem=&gt;c
+AGWindow=&gt;c
+AGCaption=&gt;c
+AGRadio=&gt;c
+AGSubMenu=&gt;c
+ ?? (true)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+AGRubyObject ?? (false)
+SceneBase ?? (false)
+SceneBase ?? (false)
+SceneNode ?? (false)
+SceneNode ?? (false)
+SceneNode ?? (false)
+SceneNode ?? (false)
+SceneNode ?? (false)
+AGListener ?? (false)
+AGRandomizerBase ?? (false)
+AGSingleton ?? (false)
+AGSingleton ?? (false)
+AGSingleton ?? (false)
+PathWeighter ?? (false)
+SimpleGraph ?? (false)
+TerrainBase ?? (false)
+AGPaintTarget ?? (false)
+AGPaintTarget ?? (false)
+AGPaintTarget ?? (false)
+AGPaintTarget ?? (false)
+MeshBase ?? (false)
+MeshBase ?? (false)
+MeshBase ?? (false)
+AGMessageObject ?? (false)
+AGMessageObject ?? (false)
+AGMessageObject ?? (false)
+AGMessageObject ?? (false)
+AGVideoBase ?? (false)
+AGScreen ?? (false)
+AGScreen ?? (false)
+AGScreen ?? (false)
+HeightMap ?? (false)
+AGApplication ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGWidget ?? (false)
+AGButton ?? (false)
+AGTable ?? (false)
+AGTable ?? (false)
+AGTable ?? (false)
+AGText ?? (false)
+AGCheckBox ?? (false)
+AGMenuItem ?? (false)
+{&quot;AGRubyObject&quot;=&gt;0}
+MAX:
+6
+{&quot;AGRadio&quot;=&gt;6,
+ &quot;MapPathWeighter&quot;=&gt;2,
+ &quot;GLApp&quot;=&gt;4,
+ &quot;AGFrame&quot;=&gt;4,
+ &quot;AGTooltip&quot;=&gt;4,
+ &quot;AnimMeshData&quot;=&gt;1,
+ &quot;AGScroller&quot;=&gt;4,
+ &quot;Scene&quot;=&gt;2,
+ &quot;AnimMesh&quot;=&gt;3,
+ &quot;AGClipPaintTarget&quot;=&gt;2,
+ &quot;Mesh2D&quot;=&gt;3,
+ &quot;WaterPiece&quot;=&gt;2,
+ &quot;AGText&quot;=&gt;4,
+ &quot;AGScreenWidget&quot;=&gt;4,
+ &quot;AGSubMenu&quot;=&gt;6,
+ &quot;AGRubyObject&quot;=&gt;0,
+ &quot;AGSDLScreen&quot;=&gt;3,
+ &quot;AGApplication&quot;=&gt;3,
+ &quot;AGWidget&quot;=&gt;3,
+ &quot;Mesh2DData&quot;=&gt;1,
+ &quot;AGRandomizerBase&quot;=&gt;1,
+ &quot;AGFontEngine&quot;=&gt;2,
+ &quot;TerrainBase&quot;=&gt;1,
+ &quot;Boa3dWireframe&quot;=&gt;2,
+ &quot;AGComboBox&quot;=&gt;4,
+ &quot;AGTexture&quot;=&gt;2,
+ &quot;Pathfinder&quot;=&gt;1,
+ &quot;AGSingleton&quot;=&gt;1,
+ &quot;AGPlugin&quot;=&gt;1,
+ &quot;AGTable&quot;=&gt;4,
+ &quot;HeightMap&quot;=&gt;3,
+ &quot;AGLayout&quot;=&gt;4,
+ &quot;AGCaption&quot;=&gt;5,
+ &quot;AGListBox&quot;=&gt;4,
+ &quot;MeshData&quot;=&gt;1,
+ &quot;AGMessageObject&quot;=&gt;2,
+ &quot;AGWindow&quot;=&gt;5,
+ &quot;Terrain&quot;=&gt;2,
+ &quot;MeshBase&quot;=&gt;2,
+ &quot;AGRadioGroup&quot;=&gt;4,
+ &quot;AGCollector&quot;=&gt;1,
+ &quot;AGMenuItem&quot;=&gt;5,
+ &quot;AntEntity&quot;=&gt;1,
+ &quot;AGMenu&quot;=&gt;5,
+ &quot;AntMap&quot;=&gt;4,
+ &quot;MiniMap&quot;=&gt;4,
+ &quot;AGColorButton&quot;=&gt;4,
+ &quot;AntParticle&quot;=&gt;2,
+ &quot;PathWeighter&quot;=&gt;1,
+ &quot;AGImage&quot;=&gt;4,
+ &quot;AGMain&quot;=&gt;1,
+ &quot;SceneNode&quot;=&gt;1,
+ &quot;AGLayoutCreator&quot;=&gt;2,
+ &quot;Scene2D&quot;=&gt;2,
+ &quot;AGRandomizer&quot;=&gt;2,
+ &quot;AGGLScreen&quot;=&gt;3,
+ &quot;AGMessageTransceiver&quot;=&gt;1,
+ &quot;SceneBase&quot;=&gt;1,
+ &quot;DecimatedGraph&quot;=&gt;2,
+ &quot;AGGLWidget&quot;=&gt;4,
+ &quot;AGVideoManager&quot;=&gt;3,
+ &quot;AGCheckBox&quot;=&gt;5,
+ &quot;AGScreen&quot;=&gt;2,
+ &quot;AGSurface&quot;=&gt;2,
+ &quot;AGEdit&quot;=&gt;4,
+ &quot;SimpleGraph&quot;=&gt;1,
+ &quot;AGSound&quot;=&gt;3,
+ &quot;AGPaintTarget&quot;=&gt;1,
+ &quot;AGVideoBase&quot;=&gt;2,
+ &quot;AGButton&quot;=&gt;4,
+ &quot;AGListener&quot;=&gt;1,
+ &quot;Mesh&quot;=&gt;3,
+ &quot;TerrainPiece&quot;=&gt;2}
+Running congurator Rookey::SwigConfig
+Running congurator Rookey::SDLConfig
+
+
+Running congurator Rookey::RubyConfig
+Running congurator Rookey::GLConfig
+Running congurator Rookey::CcacheConfig
+Running congurator Rookey::Configurator
+
+#&lt;Rookey::Config:0x560ab8
+ @hash=
+  {&quot;SWIG_OPTIONS&quot;=&gt;&quot; -Wall -DAGEXPORT&quot;,
+   &quot;CCACHE&quot;=&gt;&quot;/opt/local/bin/ccache&quot;,
+   &quot;CFLAGS&quot;=&gt;
+    &quot; -D_GNU_SOURCE=1 -D_THREAD_SAFE -arch ppc -arch i386 -Os -pipe -fno-common&quot;,
+   &quot;host_os&quot;=&gt;&quot;darwin9.0&quot;,
+   &quot;DLEXT&quot;=&gt;&quot;bundle&quot;,
+   &quot;INCLUDEDIRS&quot;=&gt;
+    &quot; /opt/local/include/SDL /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/universal-darwin9.0 /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/include /usr/X11/include&quot;,
+   &quot;LDFLAGS&quot;=&gt;
+    &quot; -L/opt/local/lib -lSDLmain -lSDL -Wl,-framework,Cocoa -lpthread -ldl -lm  -lruby&quot;,
+   &quot;LDSHAREDFLAGS&quot;=&gt;
+    &quot; -arch ppc -arch i386 -pipe -bundle -undefined dynamic_lookup&quot;}&gt;

Modified: antargis/trunk/main/starter.cc
===================================================================
--- antargis/trunk/main/starter.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/main/starter.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -15,7 +15,7 @@
     std::cout&lt;&lt;&quot;Init_antargis out of starter-ready&quot;&lt;&lt;std::endl;
     ruby_options(argc,argv);
     std::cout&lt;&lt;&quot;AAA&quot;&lt;&lt;std::endl;
-    ruby_script(&quot;sdl_starter&quot;);
+    //ruby_script(&quot;sdl_starter&quot;);
     std::cout&lt;&lt;&quot;BBB&quot;&lt;&lt;std::endl;
     ruby_run();
     std::cout&lt;&lt;&quot;CCC&quot;&lt;&lt;std::endl;

Deleted: antargis/trunk/rookey/antargis
===================================================================
(Binary files differ)

Deleted: antargis/trunk/rookey/antargis.bundle
===================================================================
(Binary files differ)

Modified: antargis/trunk/rookey/compile.rb
===================================================================
--- antargis/trunk/rookey/compile.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/compile.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -72,6 +72,8 @@
 	    programcall=getCompiler(:cpp)+&quot; &quot; <A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">+ at config</A>[&quot;LDSHAREDFLAGS&quot;]
       
       options=[]
+      pp t.methods.sort
+      pp t.prerequisites
       
       options &lt;&lt; &quot;-o &quot;+t.name
       options += t.prerequisites

Modified: antargis/trunk/rookey/config_generator.rb
===================================================================
--- antargis/trunk/rookey/config_generator.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/config_generator.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -67,16 +67,23 @@
     end
     
     def searchProgram(program)
+      searchPrograms(program)[0]
+    end
+    
+    def searchPrograms(program)
       programs=[program].flatten
-      programs.each{|program|
-	      getPath.each{|dir|
+      result=programs.map{|program|
+	      getPath.map{|dir|
+	        
 	        p=File.join(dir,program)
-	        if File.exists?(p)
-	          return p
-	        end
+          #puts &quot;TEST:&quot;+p
+	        p=nil unless File.exists?(p)
+          #puts &quot;RES:&quot;+p.to_s
+          p
 	      }
-      }
-      nil
+      }.flatten.uniq-[nil]
+      pp result
+      result
     end
     def checkProgram(program)      
     end
@@ -99,6 +106,10 @@
     end
     private
     def getPath
+      # add paths in externals/build/*/bin
+      getEnvPath+Dir[File.expand_path(File.join(File.split(__FILE__)[0],&quot;externals&quot;,&quot;built&quot;,&quot;*&quot;))].map{|d|File.join(d,&quot;bin&quot;)}
+    end
+    def getEnvPath
       p=ENV[&quot;PATH&quot;]
       if File.join(&quot;a&quot;,&quot;b&quot;)=~/\\/
         p.split(&quot;;&quot;)

Modified: antargis/trunk/rookey/configs/debug.rb
===================================================================
--- antargis/trunk/rookey/configs/debug.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/configs/debug.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -3,8 +3,11 @@
     needs :compiler
     
     def run(config)
-      config.add(&quot;CFLAGS&quot;,&quot;-O0 -g&quot;)
-      config.add(&quot;LDFLAGS&quot;,&quot;-g&quot;)
+      pp ROOKEY_CONFIG
+      if ROOKEY_CONFIG[:debug]
+	      config.add(&quot;CFLAGS&quot;,&quot;-O0 -g&quot;)
+	      config.add(&quot;LDFLAGS&quot;,&quot;-g&quot;)
+      end
     end
   end
 end
\ No newline at end of file

Modified: antargis/trunk/rookey/configs/gl.rb
===================================================================
--- antargis/trunk/rookey/configs/gl.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/configs/gl.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -9,6 +9,7 @@
       case get(&quot;host_os&quot;)
         when /darwin/
           config.add(&quot;INCLUDEDIRS&quot;,&quot;/usr/X11/include&quot;)        
+          config.add(&quot;LDFLAGS&quot;,&quot;-Wl,-framework,OpenGL&quot;)
       end      
     end   
   end 

Added: antargis/trunk/rookey/configs/png.rb
===================================================================
--- antargis/trunk/rookey/configs/png.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/configs/png.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,13 @@
+require 'mkmf'
+require File.join(File.split(__FILE__)[0],&quot;ruby.rb&quot;)
+
+module Rookey
+  class PNGConfig&lt;RubyConfig
+    provides :png
+    needs :compiler
+    
+    def run(config)
+      checkLibrary(config,&quot;png&quot;,&quot;png_get_io_ptr&quot;)
+    end   
+  end 
+end
\ No newline at end of file

Modified: antargis/trunk/rookey/configs/swig.rb
===================================================================
--- antargis/trunk/rookey/configs/swig.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/configs/swig.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -1,11 +1,33 @@
 module Rookey
   class SwigConfig&lt;Configurator
     provides :swig
+    VERSIONS=[&quot;1.3.34&quot;] #[&quot;1.3.33&quot;,&quot;1.3.34&quot;]
     
-    def run(config)
-      # FIXME: search program
-      config.add(&quot;SWIG_OPTIONS&quot;,&quot;-Wall -DAGEXPORT&quot;)
+    def run(config,firstrun=true)
+      swigs=searchPrograms(&quot;swig&quot;).select{|swig|checkVersion(swig)}
+      if swigs.length==0
+        puts &quot;ERROR: no SWIG with version in #{VERSIONS.join(&quot;, &quot;)} not found!&quot;
+        if firstrun
+	        buildSwig
+	        run(config,false)
+        end
+      else
+	      swig=swigs[0]
+	      # FIXME: search program
+	      config.add(&quot;SWIG_OPTIONS&quot;,&quot;-Wall -DAGEXPORT&quot;)
+	      config.add(&quot;SWIG&quot;,swig)
+      end
     end
     
+    private
+    def checkVersion(swig)
+      run=&quot;#{swig} -version&quot;
+      output=`#{run}`
+      VERSIONS.select{|v|output=~/#{v}/}.length&gt;0
+    end
+    def buildSwig
+      ruby File.join(File.split(__FILE__)[0],&quot;..&quot;,&quot;externals&quot;,&quot;swig&quot;,&quot;build.rb&quot;)
+    end
+    
   end
 end
\ No newline at end of file

Modified: antargis/trunk/rookey/cpp/ag_rubyobj.cc
===================================================================
--- antargis/trunk/rookey/cpp/ag_rubyobj.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/cpp/ag_rubyobj.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -17,11 +17,16 @@
 
 bool mRubyQuitting=false;
 
+// this set keeps track of all valid instances of AGRubyObject
+std::set&lt;AGRubyObject*&gt; mRubyObjects;
+
 void setQuitting()
   {
     mRubyQuitting=true;
   }
 
+// swig-function for handling &quot;tracked&quot; objects
+// BEWARE: this does not support multiple libraries yet (FIXME)
 VALUE convertCpp2Ruby(AGRubyObject *cObject);
 
 AGEXPORT void *getAddressOfRubyObject(AGRubyObject *o)
@@ -37,11 +42,13 @@
 
 AGRubyObject::AGRubyObject()
   {
+    mRubyObjects.insert(this);
   }
 AGRubyObject::~AGRubyObject()
   {
     for(std::set&lt;AGBaseObject*&gt;::iterator i=mReferences.begin();i!=mReferences.end();i++)
       (*i)-&gt;baseClear();
+    mRubyObjects.erase(this);
   }
 
 
@@ -52,20 +59,28 @@
 
 
 // call this function with any object you want to mark.
+// recursive should be set true only in one direction, otherwise you'll generate endless-loops (!!)
 void AGRubyObject::markObject(AGRubyObject *o, bool recursive)
   {
+    // o must be a valid ruby-object
+    assert(mRubyObjects.find(o)!=mRubyObjects.end());
+
+    // look up, if it's registered within ruby
     VALUE v=convertCpp2Ruby(o);
     if(v!=Qnil)
-      rb_gc_mark(v);
-    
+      {
+        // then mark it
+        rb_gc_mark(v);
+      }
+
     assert(o);
+    // recurse through hierarchy
     if(recursive)
       o-&gt;mark(); // call this directly
   }
 
 void AGRubyObject::clear()
   {
-    //CTRACE;
   }
 
 void AGRubyObject::addRef(AGBaseObject *o)
@@ -84,17 +99,16 @@
 /// it handles all the AGRubyObjects
 void general_markfunc(void *ptr)
   {
-    //STACKTRACE;
-    //  TRACE;
     if(!ptr)
       {
         // FIXME: add logging!!!
         std::cerr&lt;&lt;(&quot;WARNING: a ptr==0 was given in general_markfunc!&quot;)&lt;&lt;std::endl;
-        //      throw std::runtime_error(&quot;WARNING: a ptr==0 was given in general_markfunc!&quot;);
-        return; // ignore
+        return; // ignore this !
       }
     assert(ptr);
+    // the given object must be a AGRubyObject and it must be valid (it's in mRubyObjects)
     AGRubyObject *o=static_cast&lt;AGRubyObject*&gt;(ptr);
+    assert(mRubyObjects.find(o)!=mRubyObjects.end());
 
 #ifdef GCDEBUG
     printf(&quot;mark: 0x%lx\n&quot;,o-&gt;mRUBY);
@@ -107,48 +121,42 @@
 
 /**
    saveDelete is used to delete AGRubyObjects savely.
-
-   ruby does a gc-run and then deletes everything, which is not marked
-   so eventually sub-instances of a rubyobject are killed before
-   a workaround for this:
-   1) put all deleted objects in a set
-   2) check set before clearing/deleting
-   3) clear this set when marking
  */
 bool saveDelete(AGRubyObject *o)
   {
-    
-    
-    //FIXME: can this really be discarded ?
     if(mRubyQuitting)
       return false; // we are quitting - so memory is discarded anyway - hopefully ;-)
 
+    // check, if this object is existant any longer
+    // in case we're quitting this the deletion order is not defined for ruby-objects !!
+    if(mRubyObjects.find(o)==mRubyObjects.end())
+      {
+        std::cerr&lt;&lt;&quot;RubyObject &quot;&lt;&lt;o&lt;&lt;&quot; no longer existant - maybe we're quitting ?!&quot;&lt;&lt;std::endl;
+        return false;
+      }
+
+    assert(o);
+    // send object a message, that it will be deleted. This can help with detachin connections
+    // between objects.
+    o-&gt;clear();
     
-    
     VALUE v=convertCpp2Ruby(o);
     if(v!=Qnil)
       return false; // do not delete - it's under ruby's control!
-
     
-    assert(o);
-    o-&gt;clear();
+    
     delete o;
     return true;
   }
 
 
 
-
-
-
-
-
 AGBaseObject::AGBaseObject(AGRubyObject *p)
 :mp(p)
-{
-  if(p)
-    p-&gt;addRef(this);
-}
+    {
+      if(p)
+        p-&gt;addRef(this);
+    }
 
 AGBaseObject::~AGBaseObject()
   {

Added: antargis/trunk/rookey/externals/ext_config.rb
===================================================================
--- antargis/trunk/rookey/externals/ext_config.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/externals/ext_config.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,6 @@
+$swigVersion=&quot;1.3.34&quot;
+$swigDir=File.expand_path(File.join(File.split(__FILE__)[0],&quot;swig&quot;,&quot;swig-#{$swigVersion}&quot;))
+$swigTarGz=&quot;#{$swigDir}.tar.gz&quot;
+$swigUrl=&quot;<A HREF="http://downloads.sourceforge.net/swig/">http://downloads.sourceforge.net/swig/</A>&quot;+$swigTarGz
+
+$swigTarget=File.expand_path(File.join(File.split(__FILE__)[0],&quot;built&quot;,&quot;swig&quot;))
\ No newline at end of file

Added: antargis/trunk/rookey/externals/swig/build.rb
===================================================================
--- antargis/trunk/rookey/externals/swig/build.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/externals/swig/build.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,46 @@
+require 'ftools'
+require File.join(File.split(__FILE__)[0],&quot;..&quot;,&quot;ext_config.rb&quot;)
+
+alias :oldSystem :system 
+def system(x)
+  puts x
+  oldSystem(x)
+end
+  
+
+def getFilenameFromUrl(url)
+  url.gsub(/.*\//,&quot;&quot;)
+end
+
+def download(url)
+  filename=getFilenameFromUrl(url)
+  if File.exists?(filename)
+    puts &quot;File #{filename} already exists - so not downloading!&quot;
+    return
+  end
+  puts &quot;Downloading from #{url}...&quot;
+  call=&quot;wget -O '#{filename}.tmp' '#{url}'&quot;
+  system call
+  File.move(filename+&quot;.tmp&quot;,filename)
+  return
+end
+
+def unzipTar(file)
+  puts &quot;Unzipping #{file}&quot;
+  system(&quot;tar xvfz #{file} &gt;/dev/null&quot;)
+  puts &quot;Ready.&quot;
+end
+
+def buildSwig(dir,swigTarget)
+  curDir=Dir.pwd
+  Dir.chdir(dir)
+  a=[&quot;python&quot;,&quot;ocaml&quot;,&quot;php4&quot;,&quot;chicken&quot;,&quot;csharp&quot;,&quot;csharp&quot;,&quot;guilescm&quot;,&quot;java&quot;,&quot;mzscheme&quot;,&quot;perl5&quot;,&quot;pike&quot;,&quot;tcl&quot;,&quot;lua&quot;,&quot;allegrocl&quot;,&quot;clisp&quot;,&quot;r&quot;]
+  system &quot;./configure &quot;+a.map{|f|&quot;--without-#{f}&quot;}.join(&quot; &quot;)+&quot; --prefix=#{swigTarget}&quot;
+  system &quot;make&quot;
+  system &quot;make install&quot;
+end
+
+
+download($swigUrl)
+unzipTar($swigTarGz)
+buildSwig($swigDir,$swigTarget)
\ No newline at end of file

Modified: antargis/trunk/rookey/rookey.rb
===================================================================
--- antargis/trunk/rookey/rookey.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/rookey.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -1,2 +1,12 @@
+ALLCLEAN=[]
+
 require File.join(File.split(__FILE__)[0],'tools.rb')
 
+task :allclean=&gt;:clean do
+  ALLCLEAN.each{|f|
+    begin
+      File.delete(f)
+    rescue
+    end
+  }
+end

Added: antargis/trunk/rookey/rookey_config.rb
===================================================================
--- antargis/trunk/rookey/rookey_config.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/rookey_config.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,121 @@
+require 'pp'
+require 'optparse'
+
+module Rookey
+  class Configure
+    attr_accessor :programs, :input, :filename
+    
+    FILENAME=&quot;rookey_configuration.rb&quot;
+    
+    attr_reader :options
+    
+    def self.load(filename=nil)
+      filename||=FILENAME
+      unless File.exists?(filename)
+        if File.exists?(&quot;configure&quot;)
+          ruby(&quot;configure&quot;)
+        end
+        unless File.exists?(filename)
+          self.new.run
+        end
+      end 
+      Kernel.load(filename)
+    end
+    def self.cleanTask
+      ALLCLEAN &lt;&lt; FILENAME
+    end
+    
+    def initialize
+      @programs=[]
+      @input=nil
+      @ons=[]
+      @options={}
+      @filename=FILENAME
+    end
+        
+    def set(k,v)
+      @options[k]=v
+    end
+    
+	  def run
+	    @input||=ARGV
+	    options={}
+	    opts=OptionParser.new do |opts|
+	      opts.banner = &quot;Usage: configure [options]&quot;
+	
+	      opts.separator &quot;&quot;
+	      opts.separator &quot;Specific options:&quot;
+	
+	      opts.on(&quot;-d&quot;, &quot;--enable-debug&quot;,
+	              &quot;enable debugging&quot;) do 
+	        @options[:debug]=true
+	      end
+	      opts.on(&quot;-g&quot;,&quot;--enable-gc-debug&quot;,
+	              &quot;enable debugging of garbage collector&quot;) do
+	        @options[:gcdebug]=true
+	      end
+	
+	      opts.on(&quot;-p&quot;,&quot;--enable-profile&quot;,
+	              &quot;enable c++ profiling&quot;) do 
+	        @options[:profile]=true
+	      end
+	
+	      opts.on(&quot;--disable-sdlconfig&quot;,
+	              &quot;do not use sdl-config for configuration&quot;) do 
+	        @options[:use_sdlconfig]=false
+	      end
+	      opts.on(&quot;--disable-fallbacks&quot;,
+	              &quot;do not use fallback dirs for X11 and GL&quot;) do 
+	        @options[:use_fallbacks]=false
+	      end
+	
+	      opts.on(&quot;--prefix PREFIXDIR&quot;,
+	              &quot;set prefix directory PREFIXDIR&quot;) do |dir|
+	        @options[:prefix]=dir
+	      end
+
+	      
+	      opts.on(&quot;-v&quot;,&quot;--version&quot;,
+	        &quot;set release version of BoA&quot;) do |v|
+	          @options[:version]=v
+	      end
+	
+	      opts.on(&quot;--ext-config CONFIG&quot;,
+	        &quot;use user-defined config instead of ruby's mkmf&quot;,&quot;CONFIG maybe in mingw32 or unix&quot;) do |extconfig|
+	          @options[:extconfig]=extconfig
+	          @options[:use_mkmf]=false
+	      end
+        
+	
+	      @programs.each{|program|
+	        opts.on(&quot;--path-&quot;+program+&quot; PATH&quot;,
+	          &quot;set path to program '#{program}'&quot;) do |d|
+	          @options[program]=d
+	        end
+	      }
+        if block_given?
+        yield opts
+        end
+
+	    
+		  end	        
+      opts.parse!(@input)
+      save
+      @options
+	  end
+    private
+    def save
+      fd=File.open(@filename,&quot;w&quot;)
+      fd.puts &quot;ROOKEY_CONFIG={&quot;
+      fd.puts @options.map{|k,v|
+        &quot;:#{k}=&gt;'#{v}'&quot;
+      }.join(&quot;,\n&quot;)
+      fd.puts &quot;}&quot;
+      fd.close
+      begin
+        File.delete(&quot;config_cache.rb&quot;)
+      rescue
+      end
+    end
+  end
+end
\ No newline at end of file

Modified: antargis/trunk/rookey/spec/a.h
===================================================================
--- antargis/trunk/rookey/spec/a.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/spec/a.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -2,7 +2,7 @@
 
 //INCLUDE_SWIG
 
-class B:public AGRubyObject
+class A:public AGRubyObject
   {
 public:
   virtual void x()

Modified: antargis/trunk/rookey/spec/b.h
===================================================================
--- antargis/trunk/rookey/spec/b.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/spec/b.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -1,4 +1,4 @@
-class A
+class B
   {
 public:
   void x()

Modified: antargis/trunk/rookey/spec/cpp/ag_rubyobj.cc
===================================================================
--- antargis/trunk/rookey/spec/cpp/ag_rubyobj.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/spec/cpp/ag_rubyobj.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -1,36 +1,38 @@
 ag_rubyobj.o: ../cpp/ag_rubyobj.cc ../cpp/ag_rubyobj.h \
   /usr/include/c++/4.0.0/string \
-  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/c++config.h \
-  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/os_defines.h \
+  /usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++config.h \
+  /usr/include/c++/4.0.0/i686-apple-darwin9/bits/os_defines.h \
   /usr/include/c++/4.0.0/bits/stringfwd.h \
   /usr/include/c++/4.0.0/bits/char_traits.h \
   /usr/include/c++/4.0.0/cstring /usr/include/c++/4.0.0/cstddef \
-  /usr/lib/gcc/powerpc-apple-darwin9/4.0.1/include/stddef.h \
+  /usr/lib/gcc/i686-apple-darwin9/4.0.1/include/stddef.h \
   /usr/include/string.h /usr/include/_types.h /usr/include/sys/_types.h \
   /usr/include/sys/cdefs.h /usr/include/machine/_types.h \
-  /usr/include/ppc/_types.h /usr/include/c++/4.0.0/bits/stl_algobase.h \
+  /usr/include/i386/_types.h /usr/include/c++/4.0.0/bits/stl_algobase.h \
   /usr/include/c++/4.0.0/climits \
-  /usr/lib/gcc/powerpc-apple-darwin9/4.0.1/include/limits.h \
-  /usr/lib/gcc/powerpc-apple-darwin9/4.0.1/include/syslimits.h \
+  /usr/lib/gcc/i686-apple-darwin9/4.0.1/include/limits.h \
+  /usr/lib/gcc/i686-apple-darwin9/4.0.1/include/syslimits.h \
   /usr/include/limits.h /usr/include/machine/limits.h \
-  /usr/include/ppc/limits.h /usr/include/ppc/_limits.h \
+  /usr/include/i386/limits.h /usr/include/i386/_limits.h \
   /usr/include/sys/syslimits.h /usr/include/c++/4.0.0/cstdlib \
   /usr/include/stdlib.h /usr/include/available.h /usr/include/sys/wait.h \
   /usr/include/sys/signal.h /usr/include/sys/appleapiopts.h \
-  /usr/include/machine/signal.h /usr/include/ppc/signal.h \
-  /usr/include/ppc/_structs.h /usr/include/sys/_structs.h \
-  /usr/include/machine/_structs.h /usr/include/mach/ppc/_structs.h \
+  /usr/include/machine/signal.h /usr/include/i386/signal.h \
+  /usr/include/i386/_structs.h /usr/include/sys/_structs.h \
+  /usr/include/machine/_structs.h /usr/include/mach/i386/_structs.h \
   /usr/include/sys/resource.h /usr/include/machine/endian.h \
-  /usr/include/ppc/endian.h /usr/include/sys/_endian.h \
-  /usr/include/alloca.h /usr/include/machine/types.h \
-  /usr/include/ppc/types.h /usr/include/c++/4.0.0/iosfwd \
-  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/c++locale.h \
+  /usr/include/i386/endian.h /usr/include/sys/_endian.h \
+  /usr/include/libkern/_OSByteOrder.h \
+  /usr/include/libkern/i386/_OSByteOrder.h /usr/include/alloca.h \
+  /usr/include/machine/types.h /usr/include/i386/types.h \
+  /usr/include/c++/4.0.0/iosfwd \
+  /usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++locale.h \
   /usr/include/c++/4.0.0/clocale /usr/include/locale.h \
   /usr/include/_locale.h /usr/include/c++/4.0.0/cstdio \
   /usr/include/stdio.h \
-  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/c++io.h \
-  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/gthr.h \
-  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/gthr-default.h \
+  /usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++io.h \
+  /usr/include/c++/4.0.0/i686-apple-darwin9/bits/gthr.h \
+  /usr/include/c++/4.0.0/i686-apple-darwin9/bits/gthr-default.h \
   /usr/include/pthread.h /usr/include/pthread_impl.h /usr/include/sched.h \
   /usr/include/time.h /usr/include/_structs.h /usr/include/unistd.h \
   /usr/include/sys/unistd.h /usr/include/sys/select.h \
@@ -38,9 +40,9 @@
   /usr/include/ctype.h /usr/include/runetype.h \
   /usr/include/c++/4.0.0/bits/postypes.h /usr/include/c++/4.0.0/cwchar \
   /usr/include/c++/4.0.0/ctime /usr/include/wchar.h \
-  /usr/lib/gcc/powerpc-apple-darwin9/4.0.1/include/stdarg.h \
+  /usr/lib/gcc/i686-apple-darwin9/4.0.1/include/stdarg.h \
   /usr/include/_wctype.h \
-  /usr/lib/gcc/powerpc-apple-darwin9/4.0.1/include/stdint.h \
+  /usr/lib/gcc/i686-apple-darwin9/4.0.1/include/stdint.h \
   /usr/include/c++/4.0.0/bits/functexcept.h \
   /usr/include/c++/4.0.0/exception_defines.h \
   /usr/include/c++/4.0.0/bits/stl_pair.h \
@@ -52,7 +54,7 @@
   /usr/include/c++/4.0.0/debug/debug.h /usr/include/c++/4.0.0/cassert \
   /usr/include/assert.h /usr/include/c++/4.0.0/memory \
   /usr/include/c++/4.0.0/bits/allocator.h \
-  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/c++allocator.h \
+  /usr/include/c++/4.0.0/i686-apple-darwin9/bits/c++allocator.h \
   /usr/include/c++/4.0.0/ext/new_allocator.h /usr/include/c++/4.0.0/new \
   /usr/include/c++/4.0.0/exception \
   /usr/include/c++/4.0.0/bits/stl_construct.h \
@@ -62,7 +64,7 @@
   /usr/include/c++/4.0.0/bits/stl_function.h \
   /usr/include/c++/4.0.0/bits/basic_string.h \
   /usr/include/c++/4.0.0/bits/atomicity.h \
-  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/atomic_word.h \
+  /usr/include/c++/4.0.0/i686-apple-darwin9/bits/atomic_word.h \
   /usr/include/c++/4.0.0/algorithm /usr/include/c++/4.0.0/bits/stl_algo.h \
   /usr/include/c++/4.0.0/bits/stl_heap.h \
   /usr/include/c++/4.0.0/bits/stl_tempbuf.h \
@@ -83,11 +85,11 @@
   /usr/include/c++/4.0.0/bits/streambuf_iterator.h \
   /usr/include/c++/4.0.0/bits/locale_facets.h \
   /usr/include/c++/4.0.0/cwctype /usr/include/wctype.h \
-  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/ctype_base.h \
-  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/ctype_inline.h \
+  /usr/include/c++/4.0.0/i686-apple-darwin9/bits/ctype_base.h \
+  /usr/include/c++/4.0.0/i686-apple-darwin9/bits/ctype_inline.h \
   /usr/include/c++/4.0.0/bits/codecvt.h \
-  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/time_members.h \
-  /usr/include/c++/4.0.0/powerpc-apple-darwin9/bits/messages_members.h \
+  /usr/include/c++/4.0.0/i686-apple-darwin9/bits/time_members.h \
+  /usr/include/c++/4.0.0/i686-apple-darwin9/bits/messages_members.h \
   /usr/include/c++/4.0.0/bits/basic_ios.tcc \
   /usr/include/c++/4.0.0/bits/ostream.tcc /usr/include/c++/4.0.0/locale \
   /usr/include/c++/4.0.0/bits/locale_facets.tcc \
@@ -95,7 +97,7 @@
   /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/universal-darwin9.0/ruby.h \
   /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/universal-darwin9.0/config.h \
   /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/universal-darwin9.0/defines.h \
-  /usr/lib/gcc/powerpc-apple-darwin9/4.0.1/include/syslimits.h \
+  /usr/lib/gcc/i686-apple-darwin9/4.0.1/include/syslimits.h \
   /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/universal-darwin9.0/missing.h \
   /usr/include/sys/time.h /usr/include/sys/types.h \
   /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/universal-darwin9.0/intern.h

Added: antargis/trunk/rookey/spec/d.h
===================================================================
--- antargis/trunk/rookey/spec/d.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/spec/d.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,13 @@
+#include &quot;ag_rubyobj.h&quot;
+
+//INCLUDE_SWIG
+
+class D:public A
+  {
+public:
+  virtual void x()
+    {
+    }
+
+  };
+


Property changes on: antargis/trunk/rookey/spec/d.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/rookey/spec/file3_interface.i
===================================================================
--- antargis/trunk/rookey/spec/file3_interface.i	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/spec/file3_interface.i	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,76 @@
+%module(directors=&quot;1&quot;) file3
+%feature(&quot;autodoc&quot;,&quot;1&quot;);
+
+
+
+%include &quot;stl.i&quot;
+%include &quot;std_list.i&quot;
+%{
+#include &quot;../cpp/ag_rubyobj.h&quot;
+#include &quot;a.h&quot;
+%}
+
+%feature(&quot;director&quot;) AGRubyObject;
+%feature(&quot;director&quot;) B;
+%markfunc AGRubyObject &quot;general_markfunc&quot;
+%markfunc B &quot;general_markfunc&quot;
+%{
+      /*
+template&lt;class T&gt;
+VALUE convertCpp2Ruby(T *cObject)
+{
+  return SWIG_RubyInstanceFor(cObject);
+}
+template&lt;AGRubyObject&gt;*/ 
+VALUE convertCpp2Ruby(AGRubyObject *cObject)
+{
+  return SWIG_RubyInstanceFor(cObject);
+}
+  
+
+%}
+
+
+%{
+
+%}
+%insert(&quot;init&quot;) %{
+
+%}
+
+
+%typemaps_std_string(AGString, char, SWIG_AsCharPtrAndSize, SWIG_FromCharPtrAndSize, %checkcode(STDSTRING));
+
+        
+        %typemap(out) AGRubyObject *, AGRubyObject &amp; {
+          swig_type_info *ty = SWIG_TypeDynamicCast($1_descriptor,(void **) &amp;$1);
+          $result = SWIG_NewPointerObj($1, ty, $owner);
+        }        
+        %{
+        
+        swig_type_info* AGRubyObject_dynamic_cast(void **p)
+        {
+                AGRubyObject *a=(AGRubyObject*)(*p);
+        
+                
+                {
+	                B*b=dynamic_cast&lt;B*&gt;(a);
+	                if(b)
+	                {
+	                        *p=(void*)b;
+	                        return SWIGTYPE_p_B;
+	                }
+                }
+
+                return 0;
+        }
+        
+        %}
+        DYNAMIC_CAST(SWIGTYPE_p_AGRubyObject, AGRubyObject_dynamic_cast);
+
+
+%feature(&quot;trackobjects&quot;);
+
+%include &quot;../cpp/ag_rubyobj.h&quot;
+%include &quot;a.h&quot;      
+

Added: antargis/trunk/rookey/spec/file3_swig.cc
===================================================================
--- antargis/trunk/rookey/spec/file3_swig.cc	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/spec/file3_swig.cc	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,5285 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (<A HREF="http://www.swig.org">http://www.swig.org</A>).
+ * Version 1.3.34
+ * 
+ * This file is not intended to be easily readable and contains a number of 
+ * coding conventions designed to improve portability and efficiency. Do not make
+ * changes to this file unless you know what you are doing--modify the SWIG 
+ * interface file instead. 
+ * ----------------------------------------------------------------------------- */
+
+#define SWIGRUBY
+#define SWIG_DIRECTORS
+
+#ifdef __cplusplus
+template&lt;typename T&gt; class SwigValueWrapper {
+    T *tt;
+public:
+    SwigValueWrapper() : tt(0) { }
+    SwigValueWrapper(const SwigValueWrapper&lt;T&gt;&amp; rhs) : tt(new T(*rhs.tt)) { }
+    SwigValueWrapper(const T&amp; t) : tt(new T(t)) { }
+    ~SwigValueWrapper() { delete tt; } 
+    SwigValueWrapper&amp; operator=(const T&amp; t) { delete tt; tt = new T(t); return *this; }
+    operator T&amp;() const { return *tt; }
+    T *operator&amp;() { return tt; }
+private:
+    SwigValueWrapper&amp; operator=(const SwigValueWrapper&lt;T&gt;&amp; rhs);
+};
+
+template &lt;typename T&gt; T SwigValueInit() {
+  return T();
+}
+#endif
+
+/* -----------------------------------------------------------------------------
+ *  This section contains generic SWIG labels for method/variable
+ *  declarations/attributes, and other compiler dependent labels.
+ * ----------------------------------------------------------------------------- */
+
+/* template workaround for compilers that cannot correctly implement the C++ standard */
+#ifndef SWIGTEMPLATEDISAMBIGUATOR
+# if defined(__SUNPRO_CC) &amp;&amp; (__SUNPRO_CC &lt;= 0x560)
+#  define SWIGTEMPLATEDISAMBIGUATOR template
+# elif defined(__HP_aCC)
+/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
+/* If we find a maximum version that requires this, the test would be __HP_aCC &lt;= 35500 for A.03.55 */
+#  define SWIGTEMPLATEDISAMBIGUATOR template
+# else
+#  define SWIGTEMPLATEDISAMBIGUATOR
+# endif
+#endif
+
+/* inline attribute */
+#ifndef SWIGINLINE
+# if defined(__cplusplus) || (defined(__GNUC__) &amp;&amp; !defined(__STRICT_ANSI__))
+#   define SWIGINLINE inline
+# else
+#   define SWIGINLINE
+# endif
+#endif
+
+/* attribute recognised by some compilers to avoid 'unused' warnings */
+#ifndef SWIGUNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ &gt; 3 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4))
+#     define SWIGUNUSED __attribute__ ((__unused__)) 
+#   else
+#     define SWIGUNUSED
+#   endif
+# elif defined(__ICC)
+#   define SWIGUNUSED __attribute__ ((__unused__)) 
+# else
+#   define SWIGUNUSED 
+# endif
+#endif
+
+#ifndef SWIGUNUSEDPARM
+# ifdef __cplusplus
+#   define SWIGUNUSEDPARM(p)
+# else
+#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
+# endif
+#endif
+
+/* internal SWIG method */
+#ifndef SWIGINTERN
+# define SWIGINTERN static SWIGUNUSED
+#endif
+
+/* internal inline SWIG method */
+#ifndef SWIGINTERNINLINE
+# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
+#endif
+
+/* exporting methods */
+#if (__GNUC__ &gt;= 4) || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4)
+#  ifndef GCC_HASCLASSVISIBILITY
+#    define GCC_HASCLASSVISIBILITY
+#  endif
+#endif
+
+#ifndef SWIGEXPORT
+# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#   if defined(STATIC_LINKED)
+#     define SWIGEXPORT
+#   else
+#     define SWIGEXPORT __declspec(dllexport)
+#   endif
+# else
+#   if defined(__GNUC__) &amp;&amp; defined(GCC_HASCLASSVISIBILITY)
+#     define SWIGEXPORT __attribute__ ((visibility(&quot;default&quot;)))
+#   else
+#     define SWIGEXPORT
+#   endif
+# endif
+#endif
+
+/* calling conventions for Windows */
+#ifndef SWIGSTDCALL
+# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#   define SWIGSTDCALL __stdcall
+# else
+#   define SWIGSTDCALL
+# endif 
+#endif
+
+/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
+#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) &amp;&amp; defined(_MSC_VER) &amp;&amp; !defined(_CRT_SECURE_NO_DEPRECATE)
+# define _CRT_SECURE_NO_DEPRECATE
+#endif
+
+/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
+#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) &amp;&amp; defined(_MSC_VER) &amp;&amp; !defined(_SCL_SECURE_NO_DEPRECATE)
+# define _SCL_SECURE_NO_DEPRECATE
+#endif
+
+
+/* -----------------------------------------------------------------------------
+ *  This section contains generic SWIG labels for method/variable
+ *  declarations/attributes, and other compiler dependent labels.
+ * ----------------------------------------------------------------------------- */
+
+/* template workaround for compilers that cannot correctly implement the C++ standard */
+#ifndef SWIGTEMPLATEDISAMBIGUATOR
+# if defined(__SUNPRO_CC) &amp;&amp; (__SUNPRO_CC &lt;= 0x560)
+#  define SWIGTEMPLATEDISAMBIGUATOR template
+# elif defined(__HP_aCC)
+/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
+/* If we find a maximum version that requires this, the test would be __HP_aCC &lt;= 35500 for A.03.55 */
+#  define SWIGTEMPLATEDISAMBIGUATOR template
+# else
+#  define SWIGTEMPLATEDISAMBIGUATOR
+# endif
+#endif
+
+/* inline attribute */
+#ifndef SWIGINLINE
+# if defined(__cplusplus) || (defined(__GNUC__) &amp;&amp; !defined(__STRICT_ANSI__))
+#   define SWIGINLINE inline
+# else
+#   define SWIGINLINE
+# endif
+#endif
+
+/* attribute recognised by some compilers to avoid 'unused' warnings */
+#ifndef SWIGUNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ &gt; 3 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4))
+#     define SWIGUNUSED __attribute__ ((__unused__)) 
+#   else
+#     define SWIGUNUSED
+#   endif
+# elif defined(__ICC)
+#   define SWIGUNUSED __attribute__ ((__unused__)) 
+# else
+#   define SWIGUNUSED 
+# endif
+#endif
+
+#ifndef SWIGUNUSEDPARM
+# ifdef __cplusplus
+#   define SWIGUNUSEDPARM(p)
+# else
+#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
+# endif
+#endif
+
+/* internal SWIG method */
+#ifndef SWIGINTERN
+# define SWIGINTERN static SWIGUNUSED
+#endif
+
+/* internal inline SWIG method */
+#ifndef SWIGINTERNINLINE
+# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
+#endif
+
+/* exporting methods */
+#if (__GNUC__ &gt;= 4) || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4)
+#  ifndef GCC_HASCLASSVISIBILITY
+#    define GCC_HASCLASSVISIBILITY
+#  endif
+#endif
+
+#ifndef SWIGEXPORT
+# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#   if defined(STATIC_LINKED)
+#     define SWIGEXPORT
+#   else
+#     define SWIGEXPORT __declspec(dllexport)
+#   endif
+# else
+#   if defined(__GNUC__) &amp;&amp; defined(GCC_HASCLASSVISIBILITY)
+#     define SWIGEXPORT __attribute__ ((visibility(&quot;default&quot;)))
+#   else
+#     define SWIGEXPORT
+#   endif
+# endif
+#endif
+
+/* calling conventions for Windows */
+#ifndef SWIGSTDCALL
+# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#   define SWIGSTDCALL __stdcall
+# else
+#   define SWIGSTDCALL
+# endif 
+#endif
+
+/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
+#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) &amp;&amp; defined(_MSC_VER) &amp;&amp; !defined(_CRT_SECURE_NO_DEPRECATE)
+# define _CRT_SECURE_NO_DEPRECATE
+#endif
+
+/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
+#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) &amp;&amp; defined(_MSC_VER) &amp;&amp; !defined(_SCL_SECURE_NO_DEPRECATE)
+# define _SCL_SECURE_NO_DEPRECATE
+#endif
+
+
+/* -----------------------------------------------------------------------------
+ * swigrun.swg
+ *
+ * This file contains generic CAPI SWIG runtime support for pointer
+ * type checking.
+ * ----------------------------------------------------------------------------- */
+
+/* This should only be incremented when either the layout of swig_type_info changes,
+   or for whatever reason, the runtime changes incompatibly */
+#define SWIG_RUNTIME_VERSION &quot;4&quot;
+
+/* define SWIG_TYPE_TABLE_NAME as &quot;SWIG_TYPE_TABLE&quot; */
+#ifdef SWIG_TYPE_TABLE
+# define SWIG_QUOTE_STRING(x) #x
+# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
+# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
+#else
+# define SWIG_TYPE_TABLE_NAME
+#endif
+
+/*
+  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
+  creating a static or dynamic library from the swig runtime code.
+  In 99.9% of the cases, swig just needs to declare them as 'static'.
+  
+  But only do this if is strictly necessary, ie, if you have problems
+  with your compiler or so.
+*/
+
+#ifndef SWIGRUNTIME
+# define SWIGRUNTIME SWIGINTERN
+#endif
+
+#ifndef SWIGRUNTIMEINLINE
+# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
+#endif
+
+/*  Generic buffer size */
+#ifndef SWIG_BUFFER_SIZE
+# define SWIG_BUFFER_SIZE 1024
+#endif
+
+/* Flags for pointer conversions */
+#define SWIG_POINTER_DISOWN        0x1
+#define SWIG_CAST_NEW_MEMORY       0x2
+
+/* Flags for new pointer objects */
+#define SWIG_POINTER_OWN           0x1
+
+
+/* 
+   Flags/methods for returning states.
+   
+   The swig conversion methods, as ConvertPtr, return and integer 
+   that tells if the conversion was successful or not. And if not,
+   an error code can be returned (see swigerrors.swg for the codes).
+   
+   Use the following macros/flags to set or process the returning
+   states.
+   
+   In old swig versions, you usually write code as:
+
+     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
+       // success code
+     } else {
+       //fail code
+     }
+
+   Now you can be more explicit as:
+
+    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
+    if (SWIG_IsOK(res)) {
+      // success code
+    } else {
+      // fail code
+    }
+
+   that seems to be the same, but now you can also do
+
+    Type *ptr;
+    int res = SWIG_ConvertPtr(obj,(void **)(&amp;ptr),ty.flags);
+    if (SWIG_IsOK(res)) {
+      // success code
+      if (SWIG_IsNewObj(res) {
+        ...
+	delete *ptr;
+      } else {
+        ...
+      }
+    } else {
+      // fail code
+    }
+    
+   I.e., now SWIG_ConvertPtr can return new objects and you can
+   identify the case and take care of the deallocation. Of course that
+   requires also to SWIG_ConvertPtr to return new result values, as
+
+      int SWIG_ConvertPtr(obj, ptr,...) {         
+        if (&lt;obj is ok&gt;) {			       
+          if (&lt;need new object&gt;) {		       
+            *ptr = &lt;ptr to new allocated object&gt;; 
+            return SWIG_NEWOBJ;		       
+          } else {				       
+            *ptr = &lt;ptr to old object&gt;;	       
+            return SWIG_OLDOBJ;		       
+          } 				       
+        } else {				       
+          return SWIG_BADOBJ;		       
+        }					       
+      }
+
+   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
+   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
+   swig errors code.
+
+   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
+   allows to return the 'cast rank', for example, if you have this
+
+       int food(double)
+       int fooi(int);
+
+   and you call
+ 
+      food(1)   // cast rank '1'  (1 -&gt; 1.0)
+      fooi(1)   // cast rank '0'
+
+   just use the SWIG_AddCast()/SWIG_CheckState()
+
+
+ */
+#define SWIG_OK                    (0) 
+#define SWIG_ERROR                 (-1)
+#define SWIG_IsOK(r)               (r &gt;= 0)
+#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
+
+/* The CastRankLimit says how many bits are used for the cast rank */
+#define SWIG_CASTRANKLIMIT         (1 &lt;&lt; 8)
+/* The NewMask denotes the object was created (using new/malloc) */
+#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  &lt;&lt; 1)
+/* The TmpMask is for in/out typemaps that use temporal objects */
+#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK &lt;&lt; 1)
+/* Simple returning values */
+#define SWIG_BADOBJ                (SWIG_ERROR)
+#define SWIG_OLDOBJ                (SWIG_OK)
+#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
+#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
+/* Check, add and del mask methods */
+#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
+#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r &amp; ~SWIG_NEWOBJMASK) : r)
+#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) &amp;&amp; (r &amp; SWIG_NEWOBJMASK))
+#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
+#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r &amp; ~SWIG_TMPOBJMASK) : r)
+#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) &amp;&amp; (r &amp; SWIG_TMPOBJMASK))
+
+
+/* Cast-Rank Mode */
+#if defined(SWIG_CASTRANK_MODE)
+#  ifndef SWIG_TypeRank
+#    define SWIG_TypeRank             unsigned long
+#  endif
+#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
+#    define SWIG_MAXCASTRANK          (2)
+#  endif
+#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
+#  define SWIG_CastRank(r)           (r &amp; SWIG_CASTRANKMASK)
+SWIGINTERNINLINE int SWIG_AddCast(int r) { 
+  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) &lt; SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
+}
+SWIGINTERNINLINE int SWIG_CheckState(int r) { 
+  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
+}
+#else /* no cast-rank mode */
+#  define SWIG_AddCast
+#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
+#endif
+
+
+
+
+#include &lt;string.h&gt;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef void *(*swig_converter_func)(void *, int *);
+typedef struct swig_type_info *(*swig_dycast_func)(void **);
+
+/* Structure to store information on one type */
+typedef struct swig_type_info {
+  const char             *name;			/* mangled name of this type */
+  const char             *str;			/* human readable name of this type */
+  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
+  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
+  void                   *clientdata;		/* language specific type data */
+  int                    owndata;		/* flag if the structure owns the clientdata */
+} swig_type_info;
+
+/* Structure to store a type and conversion function used for casting */
+typedef struct swig_cast_info {
+  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
+  swig_converter_func     converter;		/* function to cast the void pointers */
+  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
+  struct swig_cast_info  *prev;			/* pointer to the previous cast */
+} swig_cast_info;
+
+/* Structure used to store module information
+ * Each module generates one structure like this, and the runtime collects
+ * all of these structures and stores them in a circularly linked list.*/
+typedef struct swig_module_info {
+  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
+  size_t                 size;		        /* Number of types in this module */
+  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
+  swig_type_info         **type_initial;	/* Array of initially generated type structures */
+  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
+  void                    *clientdata;		/* Language specific module data */
+} swig_module_info;
+
+/* 
+  Compare two type names skipping the space characters, therefore
+  &quot;char*&quot; == &quot;char *&quot; and &quot;Class&lt;int&gt;&quot; == &quot;Class&lt;int &gt;&quot;, etc.
+
+  Return 0 when the two name types are equivalent, as in
+  strncmp, but skipping ' '.
+*/
+SWIGRUNTIME int
+SWIG_TypeNameComp(const char *f1, const char *l1,
+		  const char *f2, const char *l2) {
+  for (;(f1 != l1) &amp;&amp; (f2 != l2); ++f1, ++f2) {
+    while ((*f1 == ' ') &amp;&amp; (f1 != l1)) ++f1;
+    while ((*f2 == ' ') &amp;&amp; (f2 != l2)) ++f2;
+    if (*f1 != *f2) return (*f1 &gt; *f2) ? 1 : -1;
+  }
+  return (int)((l1 - f1) - (l2 - f2));
+}
+
+/*
+  Check type equivalence in a name list like &lt;name1&gt;|&lt;name2&gt;|...
+  Return 0 if not equal, 1 if equal
+*/
+SWIGRUNTIME int
+SWIG_TypeEquiv(const char *nb, const char *tb) {
+  int equiv = 0;
+  const char* te = tb + strlen(tb);
+  const char* ne = nb;
+  while (!equiv &amp;&amp; *ne) {
+    for (nb = ne; *ne; ++ne) {
+      if (*ne == '|') break;
+    }
+    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+    if (*ne) ++ne;
+  }
+  return equiv;
+}
+
+/*
+  Check type equivalence in a name list like &lt;name1&gt;|&lt;name2&gt;|...
+  Return 0 if equal, -1 if nb &lt; tb, 1 if nb &gt; tb
+*/
+SWIGRUNTIME int
+SWIG_TypeCompare(const char *nb, const char *tb) {
+  int equiv = 0;
+  const char* te = tb + strlen(tb);
+  const char* ne = nb;
+  while (!equiv &amp;&amp; *ne) {
+    for (nb = ne; *ne; ++ne) {
+      if (*ne == '|') break;
+    }
+    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+    if (*ne) ++ne;
+  }
+  return equiv;
+}
+
+
+/* think of this as a c++ template&lt;&gt; or a scheme macro */
+#define SWIG_TypeCheck_Template(comparison, ty)         \
+  if (ty) {                                             \
+    swig_cast_info *iter = ty-&gt;cast;                    \
+    while (iter) {                                      \
+      if (comparison) {                                 \
+        if (iter == ty-&gt;cast) return iter;              \
+        /* Move iter to the top of the linked list */   \
+        iter-&gt;prev-&gt;next = iter-&gt;next;                  \
+        if (iter-&gt;next)                                 \
+          iter-&gt;next-&gt;prev = iter-&gt;prev;                \
+        iter-&gt;next = ty-&gt;cast;                          \
+        iter-&gt;prev = 0;                                 \
+        if (ty-&gt;cast) ty-&gt;cast-&gt;prev = iter;            \
+        ty-&gt;cast = iter;                                \
+        return iter;                                    \
+      }                                                 \
+      iter = iter-&gt;next;                                \
+    }                                                   \
+  }                                                     \
+  return 0
+
+/*
+  Check the typename
+*/
+SWIGRUNTIME swig_cast_info *
+SWIG_TypeCheck(const char *c, swig_type_info *ty) {
+  SWIG_TypeCheck_Template(strcmp(iter-&gt;type-&gt;name, c) == 0, ty);
+}
+
+/* Same as previous function, except strcmp is replaced with a pointer comparison */
+SWIGRUNTIME swig_cast_info *
+SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
+  SWIG_TypeCheck_Template(iter-&gt;type == from, into);
+}
+
+/*
+  Cast a pointer up an inheritance hierarchy
+*/
+SWIGRUNTIMEINLINE void *
+SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
+  return ((!ty) || (!ty-&gt;converter)) ? ptr : (*ty-&gt;converter)(ptr, newmemory);
+}
+
+/* 
+   Dynamic pointer casting. Down an inheritance hierarchy
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
+  swig_type_info *lastty = ty;
+  if (!ty || !ty-&gt;dcast) return ty;
+  while (ty &amp;&amp; (ty-&gt;dcast)) {
+    ty = (*ty-&gt;dcast)(ptr);
+    if (ty) lastty = ty;
+  }
+  return lastty;
+}
+
+/*
+  Return the name associated with this type
+*/
+SWIGRUNTIMEINLINE const char *
+SWIG_TypeName(const swig_type_info *ty) {
+  return ty-&gt;name;
+}
+
+/*
+  Return the pretty name associated with this type,
+  that is an unmangled type name in a form presentable to the user.
+*/
+SWIGRUNTIME const char *
+SWIG_TypePrettyName(const swig_type_info *type) {
+  /* The &quot;str&quot; field contains the equivalent pretty names of the
+     type, separated by vertical-bar characters.  We choose
+     to print the last name, as it is often (?) the most
+     specific. */
+  if (!type) return NULL;
+  if (type-&gt;str != NULL) {
+    const char *last_name = type-&gt;str;
+    const char *s;
+    for (s = type-&gt;str; *s; s++)
+      if (*s == '|') last_name = s+1;
+    return last_name;
+  }
+  else
+    return type-&gt;name;
+}
+
+/* 
+   Set the clientdata field for a type
+*/
+SWIGRUNTIME void
+SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
+  swig_cast_info *cast = ti-&gt;cast;
+  /* if (ti-&gt;clientdata == clientdata) return; */
+  ti-&gt;clientdata = clientdata;
+  
+  while (cast) {
+    if (!cast-&gt;converter) {
+      swig_type_info *tc = cast-&gt;type;
+      if (!tc-&gt;clientdata) {
+	SWIG_TypeClientData(tc, clientdata);
+      }
+    }    
+    cast = cast-&gt;next;
+  }
+}
+SWIGRUNTIME void
+SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
+  SWIG_TypeClientData(ti, clientdata);
+  ti-&gt;owndata = 1;
+}
+  
+/*
+  Search for a swig_type_info structure only by mangled name
+  Search is a O(log #types)
+  
+  We start searching at module start, and finish searching when start == end.  
+  Note: if start == end at the beginning of the function, we go all the way around
+  the circular list.
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_MangledTypeQueryModule(swig_module_info *start, 
+                            swig_module_info *end, 
+		            const char *name) {
+  swig_module_info *iter = start;
+  do {
+    if (iter-&gt;size) {
+      register size_t l = 0;
+      register size_t r = iter-&gt;size - 1;
+      do {
+	/* since l+r &gt;= 0, we can (&gt;&gt; 1) instead (/ 2) */
+	register size_t i = (l + r) &gt;&gt; 1; 
+	const char *iname = iter-&gt;types[i]-&gt;name;
+	if (iname) {
+	  register int compare = strcmp(name, iname);
+	  if (compare == 0) {	    
+	    return iter-&gt;types[i];
+	  } else if (compare &lt; 0) {
+	    if (i) {
+	      r = i - 1;
+	    } else {
+	      break;
+	    }
+	  } else if (compare &gt; 0) {
+	    l = i + 1;
+	  }
+	} else {
+	  break; /* should never happen */
+	}
+      } while (l &lt;= r);
+    }
+    iter = iter-&gt;next;
+  } while (iter != end);
+  return 0;
+}
+
+/*
+  Search for a swig_type_info structure for either a mangled name or a human readable name.
+  It first searches the mangled names of the types, which is a O(log #types)
+  If a type is not found it then searches the human readable names, which is O(#types).
+  
+  We start searching at module start, and finish searching when start == end.  
+  Note: if start == end at the beginning of the function, we go all the way around
+  the circular list.
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_TypeQueryModule(swig_module_info *start, 
+                     swig_module_info *end, 
+		     const char *name) {
+  /* STEP 1: Search the name field using binary search */
+  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
+  if (ret) {
+    return ret;
+  } else {
+    /* STEP 2: If the type hasn't been found, do a complete search
+       of the str field (the human readable name) */
+    swig_module_info *iter = start;
+    do {
+      register size_t i = 0;
+      for (; i &lt; iter-&gt;size; ++i) {
+	if (iter-&gt;types[i]-&gt;str &amp;&amp; (SWIG_TypeEquiv(iter-&gt;types[i]-&gt;str, name)))
+	  return iter-&gt;types[i];
+      }
+      iter = iter-&gt;next;
+    } while (iter != end);
+  }
+  
+  /* neither found a match */
+  return 0;
+}
+
+/* 
+   Pack binary data into a string
+*/
+SWIGRUNTIME char *
+SWIG_PackData(char *c, void *ptr, size_t sz) {
+  static const char hex[17] = &quot;0123456789abcdef&quot;;
+  register const unsigned char *u = (unsigned char *) ptr;
+  register const unsigned char *eu =  u + sz;
+  for (; u != eu; ++u) {
+    register unsigned char uu = *u;
+    *(c++) = hex[(uu &amp; 0xf0) &gt;&gt; 4];
+    *(c++) = hex[uu &amp; 0xf];
+  }
+  return c;
+}
+
+/* 
+   Unpack binary data from a string
+*/
+SWIGRUNTIME const char *
+SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
+  register unsigned char *u = (unsigned char *) ptr;
+  register const unsigned char *eu = u + sz;
+  for (; u != eu; ++u) {
+    register char d = *(c++);
+    register unsigned char uu;
+    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
+      uu = ((d - '0') &lt;&lt; 4);
+    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
+      uu = ((d - ('a'-10)) &lt;&lt; 4);
+    else 
+      return (char *) 0;
+    d = *(c++);
+    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
+      uu |= (d - '0');
+    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
+      uu |= (d - ('a'-10));
+    else 
+      return (char *) 0;
+    *u = uu;
+  }
+  return c;
+}
+
+/* 
+   Pack 'void *' into a string buffer.
+*/
+SWIGRUNTIME char *
+SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
+  char *r = buff;
+  if ((2*sizeof(void *) + 2) &gt; bsz) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,&amp;ptr,sizeof(void *));
+  if (strlen(name) + 1 &gt; (bsz - (r - buff))) return 0;
+  strcpy(r,name);
+  return buff;
+}
+
+SWIGRUNTIME const char *
+SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
+  if (*c != '_') {
+    if (strcmp(c,&quot;NULL&quot;) == 0) {
+      *ptr = (void *) 0;
+      return name;
+    } else {
+      return 0;
+    }
+  }
+  return SWIG_UnpackData(++c,ptr,sizeof(void *));
+}
+
+SWIGRUNTIME char *
+SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
+  char *r = buff;
+  size_t lname = (name ? strlen(name) : 0);
+  if ((2*sz + 2 + lname) &gt; bsz) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,ptr,sz);
+  if (lname) {
+    strncpy(r,name,lname+1);
+  } else {
+    *r = 0;
+  }
+  return buff;
+}
+
+SWIGRUNTIME const char *
+SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
+  if (*c != '_') {
+    if (strcmp(c,&quot;NULL&quot;) == 0) {
+      memset(ptr,0,sz);
+      return name;
+    } else {
+      return 0;
+    }
+  }
+  return SWIG_UnpackData(++c,ptr,sz);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+/*  Errors in SWIG */
+#define  SWIG_UnknownError    	   -1 
+#define  SWIG_IOError        	   -2 
+#define  SWIG_RuntimeError   	   -3 
+#define  SWIG_IndexError     	   -4 
+#define  SWIG_TypeError      	   -5 
+#define  SWIG_DivisionByZero 	   -6 
+#define  SWIG_OverflowError  	   -7 
+#define  SWIG_SyntaxError    	   -8 
+#define  SWIG_ValueError     	   -9 
+#define  SWIG_SystemError    	   -10
+#define  SWIG_AttributeError 	   -11
+#define  SWIG_MemoryError    	   -12 
+#define  SWIG_NullReferenceError   -13
+
+
+
+#include &lt;ruby.h&gt;
+
+/* Remove global macros defined in Ruby's win32.h */
+#ifdef write
+# undef write
+#endif
+#ifdef read
+# undef read
+#endif
+
+
+/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
+#ifndef NUM2LL
+#define NUM2LL(x) NUM2LONG((x))
+#endif
+#ifndef LL2NUM
+#define LL2NUM(x) INT2NUM((long) (x))
+#endif
+#ifndef ULL2NUM
+#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
+#endif
+
+/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
+#ifndef NUM2ULL
+#ifdef HAVE_LONG_LONG
+#define NUM2ULL(x) rb_num2ull((x))
+#else
+#define NUM2ULL(x) NUM2ULONG(x)
+#endif
+#endif
+
+/* RSTRING_LEN, etc are new in Ruby 1.9, but -&gt;ptr and -&gt;len no longer work */
+/* Define these for older versions so we can just write code the new way */
+#ifndef RSTRING_LEN
+# define RSTRING_LEN(x) RSTRING(x)-&gt;len
+#endif
+#ifndef RSTRING_PTR
+# define RSTRING_PTR(x) RSTRING(x)-&gt;ptr
+#endif
+#ifndef RSTRING_END
+# define RSTRING_END(x) (RSTRING_PTR(x) + RSTRING_LEN(x))
+#endif
+#ifndef RARRAY_LEN
+# define RARRAY_LEN(x) RARRAY(x)-&gt;len
+#endif
+#ifndef RARRAY_PTR
+# define RARRAY_PTR(x) RARRAY(x)-&gt;ptr
+#endif
+#ifndef RFLOAT_VALUE
+# define RFLOAT_VALUE(x) RFLOAT(x)-&gt;value
+#endif
+#ifndef DOUBLE2NUM
+# define DOUBLE2NUM(x) rb_float_new(x)
+#endif
+#ifndef RHASH_TBL
+# define RHASH_TBL(x) (RHASH(x)-&gt;tbl)
+#endif
+#ifndef RHASH_ITER_LEV
+# define RHASH_ITER_LEV(x) (RHASH(x)-&gt;iter_lev)
+#endif
+#ifndef RHASH_IFNONE
+# define RHASH_IFNONE(x) (RHASH(x)-&gt;ifnone)
+#endif
+#ifndef RHASH_SIZE
+# define RHASH_SIZE(x) (RHASH(x)-&gt;tbl-&gt;num_entries)
+#endif
+#ifndef RHASH_EMPTY_P
+# define RHASH_EMPTY_P(x) (RHASH_SIZE(x) == 0)
+#endif
+#ifndef RSTRUCT_LEN
+# define RSTRUCT_LEN(x) RSTRUCT(x)-&gt;len
+#endif
+#ifndef RSTRUCT_PTR
+# define RSTRUCT_PTR(x) RSTRUCT(x)-&gt;ptr
+#endif
+
+
+
+/*
+ * Need to be very careful about how these macros are defined, especially
+ * when compiling C++ code or C code with an ANSI C compiler.
+ *
+ * VALUEFUNC(f) is a macro used to typecast a C function that implements
+ * a Ruby method so that it can be passed as an argument to API functions
+ * like rb_define_method() and rb_define_singleton_method().
+ *
+ * VOIDFUNC(f) is a macro used to typecast a C function that implements
+ * either the &quot;mark&quot; or &quot;free&quot; stuff for a Ruby Data object, so that it
+ * can be passed as an argument to API functions like Data_Wrap_Struct()
+ * and Data_Make_Struct().
+ */
+ 
+#ifdef __cplusplus
+#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
+#    define PROTECTFUNC(f) ((VALUE (*)()) f)
+#    define VALUEFUNC(f) ((VALUE (*)()) f)
+#    define VOIDFUNC(f)  ((void (*)()) f)
+#  else
+#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
+#      define PROTECTFUNC(f) ((VALUE (*)()) f)
+#      define VALUEFUNC(f) ((VALUE (*)()) f)
+#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
+#    else /* These definitions should work for Ruby 1.7+ */
+#      define PROTECTFUNC(f) ((VALUE (*)(VALUE)) f)
+#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
+#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
+#    endif
+#  endif
+#else
+#  define VALUEFUNC(f) (f)
+#  define VOIDFUNC(f) (f)
+#endif
+
+/* Don't use for expressions have side effect */
+#ifndef RB_STRING_VALUE
+#define RB_STRING_VALUE(s) (TYPE(s) == T_STRING ? (s) : (*(volatile VALUE *)&amp;(s) = rb_str_to_str(s)))
+#endif
+#ifndef StringValue
+#define StringValue(s) RB_STRING_VALUE(s)
+#endif
+#ifndef StringValuePtr
+#define StringValuePtr(s) RSTRING_PTR(RB_STRING_VALUE(s))
+#endif
+#ifndef StringValueLen
+#define StringValueLen(s) RSTRING_LEN(RB_STRING_VALUE(s))
+#endif
+#ifndef SafeStringValue
+#define SafeStringValue(v) do {\
+    StringValue(v);\
+    rb_check_safe_str(v);\
+} while (0)
+#endif
+
+#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
+#define rb_define_alloc_func(klass, func) rb_define_singleton_method((klass), &quot;new&quot;, VALUEFUNC((func)), -1)
+#define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), &quot;new&quot;)
+#endif
+
+static VALUE _mSWIG = Qnil;
+
+/* -----------------------------------------------------------------------------
+ * error manipulation
+ * ----------------------------------------------------------------------------- */
+
+
+/* Define some additional error types */
+#define SWIG_ObjectPreviouslyDeletedError  -100
+
+
+/* Define custom exceptions for errors that do not map to existing Ruby
+   exceptions.  Note this only works for C++ since a global cannot be
+   initialized by a funtion in C.  For C, fallback to rb_eRuntimeError.*/
+
+SWIGINTERN VALUE 
+getNullReferenceError(void) {
+  static int init = 0;
+  static VALUE rb_eNullReferenceError ;
+  if (!init) {
+    init = 1;
+    rb_eNullReferenceError = rb_define_class(&quot;NullReferenceError&quot;, rb_eRuntimeError);
+  }
+  return rb_eNullReferenceError;
+} 
+
+SWIGINTERN VALUE 
+getObjectPreviouslyDeletedError(void) {
+  static int init = 0;
+  static VALUE rb_eObjectPreviouslyDeleted ;
+  if (!init) {
+    init = 1;
+    rb_eObjectPreviouslyDeleted = rb_define_class(&quot;ObjectPreviouslyDeleted&quot;, rb_eRuntimeError);
+  }
+  return rb_eObjectPreviouslyDeleted;
+} 
+
+
+SWIGINTERN VALUE
+SWIG_Ruby_ErrorType(int SWIG_code) {
+  VALUE type;
+  switch (SWIG_code) {
+  case SWIG_MemoryError:
+    type = rb_eNoMemError;
+    break;
+  case SWIG_IOError:
+    type = rb_eIOError;
+    break;
+  case SWIG_RuntimeError:
+    type = rb_eRuntimeError;
+    break;
+  case SWIG_IndexError:
+    type = rb_eIndexError;
+    break;
+  case SWIG_TypeError:
+    type = rb_eTypeError;
+    break;
+  case SWIG_DivisionByZero:
+    type = rb_eZeroDivError;
+    break;
+  case SWIG_OverflowError:
+    type = rb_eRangeError;
+    break;
+  case SWIG_SyntaxError:
+    type = rb_eSyntaxError;
+    break;
+  case SWIG_ValueError:
+    type = rb_eArgError;
+    break;
+  case SWIG_SystemError:
+    type = rb_eFatal;
+    break;
+  case SWIG_AttributeError:
+    type = rb_eRuntimeError;
+    break;
+  case SWIG_NullReferenceError:
+    type = getNullReferenceError();
+    break;
+  case SWIG_ObjectPreviouslyDeletedError:
+    type = getObjectPreviouslyDeletedError();
+    break;
+  case SWIG_UnknownError:
+    type = rb_eRuntimeError;
+    break;
+  default:
+    type = rb_eRuntimeError;
+  }
+  return type;
+}
+
+
+/* This function is called when a user inputs a wrong argument to
+   a method.
+ */
+SWIGINTERN 
+const char* Ruby_Format_TypeError( const char* msg,
+				   const char* type, 
+				   const char* name, 
+				   const int argn,
+				   VALUE input )
+{
+  char buf[128];
+  VALUE str;
+  VALUE asStr;
+  if ( msg &amp;&amp; *msg )
+    {
+      str = rb_str_new2(msg);
+    }
+  else
+    {
+      str = rb_str_new(NULL, 0);
+    }
+
+  str = rb_str_cat2( str, &quot;Expected argument &quot; );
+  sprintf( buf, &quot;%d of type &quot;, argn-1 );
+  str = rb_str_cat2( str, buf );
+  str = rb_str_cat2( str, type );
+  str = rb_str_cat2( str, &quot;, but got &quot; );
+  str = rb_str_cat2( str, rb_obj_classname(input) );
+  str = rb_str_cat2( str, &quot; &quot; );
+  asStr = rb_inspect(input);
+  if ( RSTRING_LEN(asStr) &gt; 30 )
+    {
+      str = rb_str_cat( str, StringValuePtr(asStr), 30 );
+      str = rb_str_cat2( str, &quot;...&quot; );
+    }
+  else
+    {
+      str = rb_str_append( str, asStr );
+    }
+
+  if ( name )
+    {
+      str = rb_str_cat2( str, &quot;\n\tin SWIG method '&quot; );
+      str = rb_str_cat2( str, name );
+      str = rb_str_cat2( str, &quot;'&quot; );
+    }
+
+  return StringValuePtr( str );
+}
+
+/* This function is called when an overloaded method fails */
+SWIGINTERN 
+void Ruby_Format_OverloadedError(
+				 const int argc,
+				 const int maxargs,
+				 const char* method, 
+				 const char* prototypes 
+				 )
+{
+  const char* msg = &quot;Wrong # of arguments&quot;;
+  if ( argc &lt;= maxargs ) msg = &quot;Wrong arguments&quot;;
+  rb_raise(rb_eArgError,&quot;%s for overloaded method '%s'.\n&quot;  
+	   &quot;Possible C/C++ prototypes are:\n%s&quot;,
+	   msg, method, prototypes);
+}
+
+/* -----------------------------------------------------------------------------
+ * See the LICENSE file for information on copyright, usage and redistribution
+ * of SWIG, and the README file for authors - <A HREF="http://www.swig.org/release.html.">http://www.swig.org/release.html.</A>
+ *
+ * rubytracking.swg
+ *
+ * This file contains support for tracking mappings from 
+ * Ruby objects to C++ objects.  This functionality is needed
+ * to implement mark functions for Ruby's mark and sweep
+ * garbage collector.
+ * ----------------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Ruby 1.8 actually assumes the first case. */
+#if SIZEOF_VOIDP == SIZEOF_LONG
+#  define SWIG2NUM(v) LONG2NUM((unsigned long)v)
+#  define NUM2SWIG(x) (unsigned long)NUM2LONG(x)
+#elif SIZEOF_VOIDP == SIZEOF_LONG_LONG
+#  define SWIG2NUM(v) LL2NUM((unsigned long long)v)
+#  define NUM2SWIG(x) (unsigned long long)NUM2LL(x)
+#else
+#  error sizeof(void*) is not the same as long or long long
+#endif
+
+
+/* Global Ruby hash table to store Trackings from C/C++
+   structs to Ruby Objects. 
+*/
+static VALUE swig_ruby_trackings = Qnil;
+
+/* Global variable that stores a reference to the ruby
+   hash table delete function. */
+static ID swig_ruby_hash_delete;
+
+/* Setup a Ruby hash table to store Trackings */
+SWIGRUNTIME void SWIG_RubyInitializeTrackings(void) {
+  /* Create a ruby hash table to store Trackings from C++ 
+     objects to Ruby objects. */
+
+  /* Try to see if some other .so has already created a 
+     tracking hash table, which we keep hidden in an instance var
+     in the SWIG module.
+     This is done to allow multiple DSOs to share the same
+     tracking table.
+  */
+  ID trackings_id = rb_intern( &quot;@__trackings__&quot; );
+  VALUE verbose = rb_gv_get(&quot;VERBOSE&quot;);
+  rb_gv_set(&quot;VERBOSE&quot;, Qfalse);
+  swig_ruby_trackings = rb_ivar_get( _mSWIG, trackings_id );
+  rb_gv_set(&quot;VERBOSE&quot;, verbose);
+
+  /* No, it hasn't.  Create one ourselves */ 
+  if ( swig_ruby_trackings == Qnil )
+    {
+      swig_ruby_trackings = rb_hash_new();
+      rb_ivar_set( _mSWIG, trackings_id, swig_ruby_trackings );
+    }
+
+  /* Now store a reference to the hash table delete function
+     so that we only have to look it up once.*/
+  swig_ruby_hash_delete = rb_intern(&quot;delete&quot;);
+}
+
+/* Get a Ruby number to reference a pointer */
+SWIGRUNTIME VALUE SWIG_RubyPtrToReference(void* ptr) {
+  /* We cast the pointer to an unsigned long
+     and then store a reference to it using
+     a Ruby number object. */
+
+  /* Convert the pointer to a Ruby number */
+  return SWIG2NUM(ptr);
+}
+
+/* Get a Ruby number to reference an object */
+SWIGRUNTIME VALUE SWIG_RubyObjectToReference(VALUE object) {
+  /* We cast the object to an unsigned long
+     and then store a reference to it using
+     a Ruby number object. */
+
+  /* Convert the Object to a Ruby number */
+  return SWIG2NUM(object);
+}
+
+/* Get a Ruby object from a previously stored reference */
+SWIGRUNTIME VALUE SWIG_RubyReferenceToObject(VALUE reference) {
+  /* The provided Ruby number object is a reference
+     to the Ruby object we want.*/
+
+  /* Convert the Ruby number to a Ruby object */
+  return NUM2SWIG(reference);
+}
+
+/* Add a Tracking from a C/C++ struct to a Ruby object */
+SWIGRUNTIME void SWIG_RubyAddTracking(void* ptr, VALUE object) {
+  /* In a Ruby hash table we store the pointer and
+     the associated Ruby object.  The trick here is
+     that we cannot store the Ruby object directly - if
+     we do then it cannot be garbage collected.  So
+     instead we typecast it as a unsigned long and
+     convert it to a Ruby number object.*/
+
+  /* Get a reference to the pointer as a Ruby number */
+  VALUE key = SWIG_RubyPtrToReference(ptr);
+
+  /* Get a reference to the Ruby object as a Ruby number */
+  VALUE value = SWIG_RubyObjectToReference(object);
+
+  /* Store the mapping to the global hash table. */
+  rb_hash_aset(swig_ruby_trackings, key, value);
+}
+
+/* Get the Ruby object that owns the specified C/C++ struct */
+SWIGRUNTIME VALUE SWIG_RubyInstanceFor(void* ptr) {
+  /* Get a reference to the pointer as a Ruby number */
+  VALUE key = SWIG_RubyPtrToReference(ptr);
+
+  /* Now lookup the value stored in the global hash table */
+  VALUE value = rb_hash_aref(swig_ruby_trackings, key);
+	
+  if (value == Qnil) {
+    /* No object exists - return nil. */
+    return Qnil;
+  }
+  else {
+    /* Convert this value to Ruby object */
+    return SWIG_RubyReferenceToObject(value);
+  }
+}
+
+/* Remove a Tracking from a C/C++ struct to a Ruby object.  It
+   is very important to remove objects once they are destroyed
+   since the same memory address may be reused later to create
+   a new object. */
+SWIGRUNTIME void SWIG_RubyRemoveTracking(void* ptr) {
+  /* Get a reference to the pointer as a Ruby number */
+  VALUE key = SWIG_RubyPtrToReference(ptr);
+
+  /* Delete the object from the hash table by calling Ruby's
+     do this we need to call the Hash.delete method.*/
+  rb_funcall(swig_ruby_trackings, swig_ruby_hash_delete, 1, key);
+}
+
+/* This is a helper method that unlinks a Ruby object from its
+   underlying C++ object.  This is needed if the lifetime of the
+   Ruby object is longer than the C++ object */
+SWIGRUNTIME void SWIG_RubyUnlinkObjects(void* ptr) {
+  VALUE object = SWIG_RubyInstanceFor(ptr);
+
+  if (object != Qnil) {
+    DATA_PTR(object) = 0;
+  }
+}
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/* -----------------------------------------------------------------------------
+ * Ruby API portion that goes into the runtime
+ * ----------------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+SWIGINTERN VALUE
+SWIG_Ruby_AppendOutput(VALUE target, VALUE o) {
+  if (NIL_P(target)) {
+    target = o;
+  } else {
+    if (TYPE(target) != T_ARRAY) {
+      VALUE o2 = target;
+      target = rb_ary_new();
+      rb_ary_push(target, o2);
+    }
+    rb_ary_push(target, o);
+  }
+  return target;
+}
+
+/* For ruby1.8.4 and earlier. */
+#ifndef RUBY_INIT_STACK
+   RUBY_EXTERN void Init_stack(VALUE* addr);
+#  define RUBY_INIT_STACK \
+   VALUE variable_in_this_stack_frame; \
+   Init_stack(&amp;variable_in_this_stack_frame);
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+/* -----------------------------------------------------------------------------
+ * See the LICENSE file for information on copyright, usage and redistribution
+ * of SWIG, and the README file for authors - <A HREF="http://www.swig.org/release.html.">http://www.swig.org/release.html.</A>
+ *
+ * rubyrun.swg
+ *
+ * This file contains the runtime support for Ruby modules
+ * and includes code for managing global variables and pointer
+ * type checking.
+ * ----------------------------------------------------------------------------- */
+
+/* For backward compatibility only */
+#define SWIG_POINTER_EXCEPTION  0
+
+/* for raw pointers */
+#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
+#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, own)
+#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Ruby_NewPointerObj(ptr, type, flags)
+#define SWIG_AcquirePtr(ptr, own)                       SWIG_Ruby_AcquirePtr(ptr, own)
+#define swig_owntype                                    ruby_owntype
+
+/* for raw packed data */
+#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty, flags)
+#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)
+
+/* for class or struct pointers */
+#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
+#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)
+
+/* for C or C++ function pointers */
+#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_ConvertPtr(obj, pptr, type, 0)
+#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_NewPointerObj(ptr, type, 0)
+
+/* for C++ member pointers, ie, member methods */
+#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty)
+#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)
+
+
+/* Runtime API */
+
+#define SWIG_GetModule(clientdata)                      SWIG_Ruby_GetModule()	
+#define SWIG_SetModule(clientdata, pointer) 		SWIG_Ruby_SetModule(pointer)
+
+
+/* Error manipulation */
+
+#define SWIG_ErrorType(code)                            SWIG_Ruby_ErrorType(code)               
+#define SWIG_Error(code, msg)            		rb_raise(SWIG_Ruby_ErrorType(code), msg)
+#define SWIG_fail                        		goto fail				 
+
+
+/* Ruby-specific SWIG API */
+
+#define SWIG_InitRuntime()                              SWIG_Ruby_InitRuntime()              
+#define SWIG_define_class(ty)                        	SWIG_Ruby_define_class(ty)
+#define SWIG_NewClassInstance(value, ty)             	SWIG_Ruby_NewClassInstance(value, ty)
+#define SWIG_MangleStr(value)                        	SWIG_Ruby_MangleStr(value)		  
+#define SWIG_CheckConvert(value, ty)                 	SWIG_Ruby_CheckConvert(value, ty)	  
+
+#include &quot;assert.h&quot;
+
+/* -----------------------------------------------------------------------------
+ * pointers/data manipulation
+ * ----------------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+  VALUE klass;
+  VALUE mImpl;
+  void  (*mark)(void *);
+  void  (*destroy)(void *);
+  int trackObjects;
+} swig_class;
+
+
+/* Global pointer used to keep some internal SWIG stuff */
+static VALUE _cSWIG_Pointer = Qnil;
+static VALUE swig_runtime_data_type_pointer = Qnil;
+
+/* Global IDs used to keep some internal SWIG stuff */
+static ID swig_arity_id = 0;
+static ID swig_call_id  = 0;
+
+/*
+  If your swig extension is to be run within an embedded ruby and has
+  director callbacks, you should set -DRUBY_EMBEDDED during compilation.  
+  This will reset ruby's stack frame on each entry point from the main 
+  program the first time a virtual director function is invoked (in a 
+  non-recursive way).
+  If this is not done, you run the risk of Ruby trashing the stack.
+*/
+
+#ifdef RUBY_EMBEDDED
+
+#  define SWIG_INIT_STACK                            \
+      if ( !swig_virtual_calls ) { RUBY_INIT_STACK } \
+      ++swig_virtual_calls;
+#  define SWIG_RELEASE_STACK --swig_virtual_calls;
+#  define Ruby_DirectorTypeMismatchException(x) \
+          rb_raise( rb_eTypeError, x ); return c_result;
+
+      static unsigned int swig_virtual_calls = 0;
+
+#else  /* normal non-embedded extension */
+
+#  define SWIG_INIT_STACK
+#  define SWIG_RELEASE_STACK
+#  define Ruby_DirectorTypeMismatchException(x) \
+          throw Swig::DirectorTypeMismatchException( x );
+
+#endif  /* RUBY_EMBEDDED */
+
+
+SWIGRUNTIME VALUE 
+getExceptionClass(void) {
+  static int init = 0;
+  static VALUE rubyExceptionClass ;
+  if (!init) {
+    init = 1;
+    rubyExceptionClass = rb_const_get(_mSWIG, rb_intern(&quot;Exception&quot;));
+  }
+  return rubyExceptionClass;
+} 
+
+/* This code checks to see if the Ruby object being raised as part
+   of an exception inherits from the Ruby class Exception.  If so,
+   the object is simply returned.  If not, then a new Ruby exception
+   object is created and that will be returned to Ruby.*/
+SWIGRUNTIME VALUE
+SWIG_Ruby_ExceptionType(swig_type_info *desc, VALUE obj) {
+  VALUE exceptionClass = getExceptionClass();
+  if (rb_obj_is_kind_of(obj, exceptionClass)) {
+    return obj;
+  }  else {
+    return rb_exc_new3(rb_eRuntimeError, rb_obj_as_string(obj));
+  }
+}
+
+/* Initialize Ruby runtime support */
+SWIGRUNTIME void
+SWIG_Ruby_InitRuntime(void)
+{
+  if (_mSWIG == Qnil) {
+    _mSWIG = rb_define_module(&quot;SWIG&quot;);
+    swig_call_id  = rb_intern(&quot;call&quot;);
+    swig_arity_id = rb_intern(&quot;arity&quot;);
+  }
+}
+
+/* Define Ruby class for C type */
+SWIGRUNTIME void
+SWIG_Ruby_define_class(swig_type_info *type)
+{
+  VALUE klass;
+  char *klass_name = (char *) malloc(4 + strlen(type-&gt;name) + 1);
+  sprintf(klass_name, &quot;TYPE%s&quot;, type-&gt;name);
+  if (NIL_P(_cSWIG_Pointer)) {
+    _cSWIG_Pointer = rb_define_class_under(_mSWIG, &quot;Pointer&quot;, rb_cObject);
+    rb_undef_method(CLASS_OF(_cSWIG_Pointer), &quot;new&quot;);
+  }
+  klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
+  free((void *) klass_name);
+}
+
+/* Create a new pointer object */
+SWIGRUNTIME VALUE
+SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)
+{
+  int own =  flags &amp; SWIG_POINTER_OWN; 
+  int track;
+  char *klass_name;
+  swig_class *sklass;
+  VALUE klass;
+  VALUE obj;
+  
+  if (!ptr)
+    return Qnil;
+  
+  if (type-&gt;clientdata) {
+    sklass = (swig_class *) type-&gt;clientdata;
+		
+    /* Are we tracking this class and have we already returned this Ruby object? */
+    track = sklass-&gt;trackObjects;
+    if (track) {
+      obj = SWIG_RubyInstanceFor(ptr);
+      
+      /* Check the object's type and make sure it has the correct type.
+        It might not in cases where methods do things like 
+        downcast methods. */
+      if (obj != Qnil) {
+        VALUE value = rb_iv_get(obj, &quot;@__swigtype__&quot;);
+        char* type_name = RSTRING_PTR(value);
+				
+        if (strcmp(type-&gt;name, type_name) == 0) {
+          return obj;
+        }
+      }
+    }
+
+    /* Create a new Ruby object */
+    obj = Data_Wrap_Struct(sklass-&gt;klass, VOIDFUNC(sklass-&gt;mark), 
+			   ( own ? VOIDFUNC(sklass-&gt;destroy) : 
+			     (track ? VOIDFUNC(SWIG_RubyRemoveTracking) : 0 )
+			     ), ptr);
+
+    /* If tracking is on for this class then track this object. */
+    if (track) {
+      SWIG_RubyAddTracking(ptr, obj);
+    }
+  } else {
+    klass_name = (char *) malloc(4 + strlen(type-&gt;name) + 1);
+    sprintf(klass_name, &quot;TYPE%s&quot;, type-&gt;name);
+    klass = rb_const_get(_mSWIG, rb_intern(klass_name));
+    free((void *) klass_name);
+    obj = Data_Wrap_Struct(klass, 0, 0, ptr);
+  }
+  rb_iv_set(obj, &quot;@__swigtype__&quot;, rb_str_new2(type-&gt;name));
+  
+  return obj;
+}
+
+/* Create a new class instance (always owned) */
+SWIGRUNTIME VALUE
+SWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)
+{
+  VALUE obj;
+  swig_class *sklass = (swig_class *) type-&gt;clientdata;
+  obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass-&gt;mark), VOIDFUNC(sklass-&gt;destroy), 0);
+  rb_iv_set(obj, &quot;@__swigtype__&quot;, rb_str_new2(type-&gt;name));
+  return obj;
+}
+
+/* Get type mangle from class name */
+SWIGRUNTIMEINLINE char *
+SWIG_Ruby_MangleStr(VALUE obj)
+{
+  VALUE stype = rb_iv_get(obj, &quot;@__swigtype__&quot;);
+  return StringValuePtr(stype);
+}
+
+/* Acquire a pointer value */
+typedef void (*ruby_owntype)(void*);
+
+SWIGRUNTIME ruby_owntype
+SWIG_Ruby_AcquirePtr(VALUE obj, ruby_owntype own) {
+  if (obj) {
+    ruby_owntype oldown = RDATA(obj)-&gt;dfree;
+    RDATA(obj)-&gt;dfree = own;
+    return oldown;
+  } else {
+    return 0;
+  }
+}
+
+/* Convert a pointer value */
+SWIGRUNTIME int
+SWIG_Ruby_ConvertPtrAndOwn(VALUE obj, void **ptr, swig_type_info *ty, int flags, ruby_owntype *own)
+{
+  char *c;
+  swig_cast_info *tc;
+  void *vptr = 0;
+
+  /* Grab the pointer */
+  if (NIL_P(obj)) {
+    *ptr = 0;
+    return SWIG_OK;
+  } else {
+    if (TYPE(obj) != T_DATA) {
+      return SWIG_ERROR;
+    }
+    Data_Get_Struct(obj, void, vptr);
+  }
+  
+  if (own) *own = RDATA(obj)-&gt;dfree;
+    
+  /* Check to see if the input object is giving up ownership
+     of the underlying C struct or C++ object.  If so then we
+     need to reset the destructor since the Ruby object no 
+     longer owns the underlying C++ object.*/ 
+  if (flags &amp; SWIG_POINTER_DISOWN) {
+    /* Is tracking on for this class? */
+    int track = 0;
+    if (ty &amp;&amp; ty-&gt;clientdata) {
+      swig_class *sklass = (swig_class *) ty-&gt;clientdata;
+      track = sklass-&gt;trackObjects;
+    }
+		
+    if (track) {
+      /* We are tracking objects for this class.  Thus we change the destructor
+       * to SWIG_RubyRemoveTracking.  This allows us to
+       * remove the mapping from the C++ to Ruby object
+       * when the Ruby object is garbage collected.  If we don't
+       * do this, then it is possible we will return a reference 
+       * to a Ruby object that no longer exists thereby crashing Ruby. */
+      RDATA(obj)-&gt;dfree = SWIG_RubyRemoveTracking;
+    } else {    
+      RDATA(obj)-&gt;dfree = 0;
+    }
+  }
+
+  /* Do type-checking if type info was provided */
+  if (ty) {
+    if (ty-&gt;clientdata) {
+      if (rb_obj_is_kind_of(obj, ((swig_class *) (ty-&gt;clientdata))-&gt;klass)) {
+        if (vptr == 0) {
+          /* The object has already been deleted */
+          return SWIG_ObjectPreviouslyDeletedError;
+        }
+        *ptr = vptr;
+        return SWIG_OK;
+      }
+    }
+    if ((c = SWIG_MangleStr(obj)) == NULL) {
+      return SWIG_ERROR;
+    }
+    tc = SWIG_TypeCheck(c, ty);
+    if (!tc) {
+      return SWIG_ERROR;
+    } else {
+      int newmemory = 0;
+      *ptr = SWIG_TypeCast(tc, vptr, &amp;newmemory);
+      assert(!newmemory); /* newmemory handling not yet implemented */
+    }
+  } else {
+    *ptr = vptr;
+  }
+  
+  return SWIG_OK;
+}
+
+/* Check convert */
+SWIGRUNTIMEINLINE int
+SWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)
+{
+  char *c = SWIG_MangleStr(obj);
+  if (!c) return 0;
+  return SWIG_TypeCheck(c,ty) != 0;
+}
+
+SWIGRUNTIME VALUE
+SWIG_Ruby_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
+  char result[1024];
+  char *r = result;
+  if ((2*sz + 1 + strlen(type-&gt;name)) &gt; 1000) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r, ptr, sz);
+  strcpy(r, type-&gt;name);
+  return rb_str_new2(result);
+}
+
+/* Convert a packed value value */
+SWIGRUNTIME int
+SWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty) {
+  swig_cast_info *tc;
+  const char  *c;
+
+  if (TYPE(obj) != T_STRING) goto type_error;
+  c = StringValuePtr(obj);
+  /* Pointer values must start with leading underscore */
+  if (*c != '_') goto type_error;
+  c++;
+  c = SWIG_UnpackData(c, ptr, sz);
+  if (ty) {
+    tc = SWIG_TypeCheck(c, ty);
+    if (!tc) goto type_error;
+  }
+  return SWIG_OK;
+
+ type_error:
+  return SWIG_ERROR;
+}
+
+SWIGRUNTIME swig_module_info *
+SWIG_Ruby_GetModule(void)
+{
+  VALUE pointer;
+  swig_module_info *ret = 0;
+  VALUE verbose = rb_gv_get(&quot;VERBOSE&quot;);
+
+ /* temporarily disable warnings, since the pointer check causes warnings with 'ruby -w' */
+  rb_gv_set(&quot;VERBOSE&quot;, Qfalse);
+  
+  /* first check if pointer already created */
+  pointer = rb_gv_get(&quot;$swig_runtime_data_type_pointer&quot; SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
+  if (pointer != Qnil) {
+    Data_Get_Struct(pointer, swig_module_info, ret);
+  }
+
+  /* reinstate warnings */
+  rb_gv_set(&quot;VERBOSE&quot;, verbose);
+  return ret;
+}
+
+SWIGRUNTIME void 
+SWIG_Ruby_SetModule(swig_module_info *pointer)
+{
+  /* register a new class */
+  VALUE cl = rb_define_class(&quot;swig_runtime_data&quot;, rb_cObject);
+  /* create and store the structure pointer to a global variable */
+  swig_runtime_data_type_pointer = Data_Wrap_Struct(cl, 0, 0, pointer);
+  rb_define_readonly_variable(&quot;$swig_runtime_data_type_pointer&quot; SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &amp;swig_runtime_data_type_pointer);
+}
+
+/* This function can be used to check whether a proc or method or similarly
+   callable function has been passed.  Usually used in a %typecheck, like:
+
+   %typecheck(c_callback_t, precedence=SWIG_TYPECHECK_POINTER) {
+        $result = SWIG_Ruby_isCallable( $input );
+   }
+ */
+SWIGINTERN
+int SWIG_Ruby_isCallable( VALUE proc )
+{
+  if ( rb_respond_to( proc, swig_call_id ) == Qtrue )
+    return 1;
+  return 0;
+}
+
+/* This function can be used to check the arity (number of arguments)
+   a proc or method can take.  Usually used in a %typecheck.
+   Valid arities will be that equal to minimal or those &lt; 0
+   which indicate a variable number of parameters at the end.
+ */
+SWIGINTERN
+int SWIG_Ruby_arity( VALUE proc, int minimal )
+{
+  if ( rb_respond_to( proc, swig_arity_id ) == Qtrue )
+    {
+      VALUE num = rb_funcall( proc, swig_arity_id, 0 );
+      int arity = NUM2INT(num);
+      if ( arity &lt; 0 &amp;&amp; (arity+1) &lt; -minimal ) return 1;
+      if ( arity == minimal ) return 1;
+      return 1;
+    }
+  return 0;
+}
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
+
+#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
+
+
+
+  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg);; } while(0) 
+
+/* -----------------------------------------------------------------------------
+ * See the LICENSE file for information on copyright, usage and redistribution
+ * of SWIG, and the README file for authors - <A HREF="http://www.swig.org/release.html.">http://www.swig.org/release.html.</A>
+ *
+ * director.swg
+ *
+ * This file contains support for director classes that proxy
+ * method calls from C++ to Ruby extensions.
+ * ----------------------------------------------------------------------------- */
+
+/*
+  Use -DSWIG_DIRECTOR_NOUEH if you prefer to avoid the use of the
+  Undefined Exception Handler provided by swift
+*/
+#ifndef SWIG_DIRECTOR_NOUEH
+#ifndef SWIG_DIRECTOR_UEH
+#define SWIG_DIRECTOR_UEH
+#endif
+#endif
+
+#ifdef __cplusplus
+
+#include &lt;string&gt;
+#include &lt;iostream&gt;
+#include &lt;map&gt;
+
+namespace Swig {
+  /* memory handler */
+  struct GCItem 
+  {
+    virtual ~GCItem()
+    {
+    }
+
+    virtual ruby_owntype get_own() const
+    {
+      return 0;
+    }
+  };
+  
+  struct GCItem_var
+  {
+    GCItem_var(GCItem *item = 0) : _item(item)
+    {
+    }
+
+    GCItem_var&amp; operator=(GCItem *item)
+    {
+      GCItem *tmp = _item;
+      _item = item;
+      delete tmp;
+      return *this;
+    }
+    
+    ~GCItem_var() 
+    {
+      delete _item;
+    }
+    
+    GCItem * operator-&gt;() const
+    {
+      return _item;
+    }
+    
+  private:
+    GCItem *_item;
+  };
+
+
+  template &lt;typename Type&gt;
+  struct GCItem_T : GCItem
+  {
+    GCItem_T(Type *ptr) : _ptr(ptr)
+    {
+    }
+    
+    virtual ~GCItem_T() 
+    {
+      delete _ptr;
+    }
+    
+  private:
+    Type *_ptr;
+  };
+
+  struct GCItem_Object : GCItem
+  {
+    GCItem_Object(ruby_owntype own) : _own(own)
+    {
+    }
+    
+    virtual ~GCItem_Object() 
+    {
+    }
+
+    ruby_owntype get_own() const
+    {
+      return _own;
+    }
+    
+  private:
+    ruby_owntype _own;
+  };
+
+
+  template &lt;typename Type&gt;
+  struct GCArray_T : GCItem
+  {
+    GCArray_T(Type *ptr) : _ptr(ptr)
+    {
+    }
+    
+    virtual ~GCArray_T() 
+    {
+      delete[] _ptr;
+    }
+    
+  private:
+    Type *_ptr;
+  };
+
+
+  /* body args */
+  struct body_args {
+    VALUE recv;
+    ID id;
+    int argc;
+    VALUE *argv;
+  };
+  
+  /* Base class for director exceptions */
+  class DirectorException {
+  protected:
+    VALUE swig_error;
+    std::string swig_msg;
+  protected:
+    DirectorException(VALUE error)
+      : swig_error(error)
+    {
+    }
+    
+    DirectorException(VALUE error, const char* hdr, const char* msg =&quot;&quot;) 
+      : swig_error(error), swig_msg(hdr) {
+      if (strlen(msg)) {
+	swig_msg += &quot; &quot;;
+	swig_msg += msg;
+      }
+      if (swig_msg.size()) {
+	VALUE str = rb_str_new(swig_msg.data(), swig_msg.size());
+	swig_error = rb_exc_new3(error, str);
+      } else {
+	swig_error = error;
+      }
+    }
+  public:
+    VALUE getType() const  { 
+      return CLASS_OF(swig_error); 
+    }
+    VALUE getError() const {
+      return swig_error;
+    }
+    const std::string&amp; getMessage() const 
+    {
+      return swig_msg;
+    }
+    
+    virtual ~DirectorException() {}
+  };
+  
+  /* unknown exception handler  */
+
+  class UnknownExceptionHandler 
+  {
+#ifdef SWIG_DIRECTOR_UEH
+    static void handler() {
+      try {
+	throw;
+      } catch (DirectorException&amp; e) {
+	std::cerr &lt;&lt; &quot;Swig Director exception caught:&quot; &lt;&lt; std::endl
+		  &lt;&lt; e.getMessage() &lt;&lt; std::endl;
+      } catch (std::exception&amp; e) {
+	std::cerr &lt;&lt; &quot;std::exception caught: &quot;&lt;&lt; e.what() &lt;&lt; std::endl;
+      } catch (...) {
+	std::cerr &lt;&lt; &quot;Unknown exception caught.&quot; &lt;&lt; std::endl;
+      }      
+      std::cerr &lt;&lt; std::endl
+		&lt;&lt; &quot;Ruby interpreter traceback:&quot; &lt;&lt; std::endl;
+      std::cerr &lt;&lt; std::endl;      
+      std::cerr &lt;&lt; &quot;This exception was caught by the SWIG unexpected exception handler.&quot; &lt;&lt; std::endl
+		&lt;&lt; &quot;Try using %feature(\&quot;director:except\&quot;) to avoid reaching this point.&quot; &lt;&lt; std::endl
+		&lt;&lt; std::endl
+		&lt;&lt; &quot;Exception is being re-thrown, program will like abort/terminate.&quot; &lt;&lt; std::endl;
+      throw;
+    }
+    
+  public:    
+    std::unexpected_handler old;
+    UnknownExceptionHandler(std::unexpected_handler nh = handler)
+    {
+      old = std::set_unexpected(nh);
+    }
+
+    ~UnknownExceptionHandler()
+    {
+      std::set_unexpected(old);
+    }
+#endif
+  };
+
+
+  /* Type mismatch in the return value from a Ruby method call */
+  class DirectorTypeMismatchException : public Swig::DirectorException {
+  public:
+    DirectorTypeMismatchException(VALUE error, const char *msg=&quot;&quot;)
+      : Swig::DirectorException(error, &quot;Swig director type mismatch&quot;, msg) 
+    {
+    }
+
+    DirectorTypeMismatchException(const char *msg=&quot;&quot;)
+      : Swig::DirectorException(rb_eTypeError, &quot;Swig director type mismatch&quot;, msg) 
+    {
+    }
+
+    static void raise(VALUE error, const char *msg) {
+      throw DirectorTypeMismatchException(error, msg);
+    }
+
+    static void raise(const char *msg) {
+      throw DirectorTypeMismatchException(msg);
+    }
+  };
+
+  /* Any Ruby exception that occurs during a director method call */
+  class DirectorMethodException : public Swig::DirectorException {
+  public:
+    DirectorMethodException(VALUE error) 
+      : Swig::DirectorException(error) {
+    }
+
+    DirectorMethodException(const char* msg = &quot;&quot;) 
+      : Swig::DirectorException(rb_eRuntimeError, &quot;Swig director method error.&quot;, msg) {
+    }
+    
+    static void raise(VALUE error)
+    {
+      throw DirectorMethodException(error);
+    }    
+  };
+
+  /* Attempted to call a pure virtual method via a director method */
+  class DirectorPureVirtualException : public Swig::DirectorException
+  {
+  public:
+    DirectorPureVirtualException(const char* msg = &quot;&quot;) 
+      : DirectorException(rb_eRuntimeError, &quot;Swig director pure virtual method called&quot;, msg)
+    { 
+    }
+
+    static void raise(const char *msg) 
+    {
+      throw DirectorPureVirtualException(msg);
+    }
+  };
+
+  /* Simple thread abstraction for pthreads on win32 */
+#ifdef __THREAD__
+# define __PTHREAD__
+# if defined(_WIN32) || defined(__WIN32__)
+#  define pthread_mutex_lock EnterCriticalSection
+#  define pthread_mutex_unlock LeaveCriticalSection
+#  define pthread_mutex_t CRITICAL_SECTION
+#  define SWIG_MUTEX_INIT(var) var
+# else
+#  include &lt;pthread.h&gt;
+#  define SWIG_MUTEX_INIT(var) var = PTHREAD_MUTEX_INITIALIZER 
+# endif
+#endif
+
+#ifdef  __PTHREAD__
+  struct Guard
+  {
+    pthread_mutex_t *_mutex;
+    
+    Guard(pthread_mutex_t &amp;mutex) : _mutex(&amp;mutex)
+    {
+      pthread_mutex_lock(_mutex);
+    }
+    
+    ~Guard()
+    {
+      pthread_mutex_unlock(_mutex);
+    }
+  };
+# define SWIG_GUARD(mutex) Guard _guard(mutex)
+#else
+# define SWIG_GUARD(mutex) 
+#endif
+
+  /* director base class */
+  class Director {
+  private:
+    /* pointer to the wrapped Ruby object */
+    VALUE swig_self;
+    /* flag indicating whether the object is owned by Ruby or c++ */
+    mutable bool swig_disown_flag;
+
+  public:
+    /* wrap a Ruby object, optionally taking ownership */
+    Director(VALUE self) : swig_self(self), swig_disown_flag(false) {
+    }
+
+    /* discard our reference at destruction */
+    virtual ~Director() {
+    }
+
+    /* return a pointer to the wrapped Ruby object */
+    VALUE swig_get_self() const { 
+      return swig_self; 
+    }
+
+    /* acquire ownership of the wrapped Ruby object (the sense of &quot;disown&quot;
+     * is from Ruby) */
+    void swig_disown() const { 
+      if (!swig_disown_flag) { 
+        swig_disown_flag = true;
+      } 
+    }
+
+  /* ownership management */
+  private:
+    typedef std::map&lt;void*, GCItem_var&gt; ownership_map;
+    mutable ownership_map owner;
+#ifdef __PTHREAD__
+    static pthread_mutex_t swig_mutex_own;
+#endif
+
+  public:
+    template &lt;typename Type&gt;
+    void swig_acquire_ownership_array(Type *vptr)  const
+    {
+      if (vptr) {
+	SWIG_GUARD(swig_mutex_own);
+	owner[vptr] = new GCArray_T&lt;Type&gt;(vptr);
+      }
+    }
+    
+    template &lt;typename Type&gt;
+    void swig_acquire_ownership(Type *vptr)  const
+    {
+      if (vptr) {	
+	SWIG_GUARD(swig_mutex_own);
+	owner[vptr] = new GCItem_T&lt;Type&gt;(vptr);
+      }
+    }
+
+    void swig_acquire_ownership_obj(void *vptr, ruby_owntype own) const
+    {
+      if (vptr &amp;&amp; own) {
+	SWIG_GUARD(swig_mutex_own);
+	owner[vptr] = new GCItem_Object(own);
+      }
+    }
+    
+    ruby_owntype swig_release_ownership(void *vptr) const
+    {
+      ruby_owntype own = 0;
+      if (vptr) {
+	SWIG_GUARD(swig_mutex_own);
+	ownership_map::iterator iter = owner.find(vptr);
+	if (iter != owner.end()) {
+	  own = iter-&gt;second-&gt;get_own();
+	  owner.erase(iter);
+	}
+      }
+      return own;
+    }
+  };
+}
+
+#endif /* __cplusplus */
+
+
+
+/* -------- TYPES TABLE (BEGIN) -------- */
+
+#define SWIGTYPE_p_AGBaseObject swig_types[0]
+#define SWIGTYPE_p_AGRubyObject swig_types[1]
+#define SWIGTYPE_p_B swig_types[2]
+#define SWIGTYPE_p_char swig_types[3]
+#define SWIGTYPE_p_p_void swig_types[4]
+#define SWIGTYPE_p_swig__ConstIterator swig_types[5]
+#define SWIGTYPE_p_swig__GC_VALUE swig_types[6]
+#define SWIGTYPE_p_swig__Iterator swig_types[7]
+#define SWIGTYPE_p_void swig_types[8]
+static swig_type_info *swig_types[10];
+static swig_module_info swig_module = {swig_types, 9, 0, 0, 0, 0};
+#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&amp;swig_module, &amp;swig_module, name)
+#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&amp;swig_module, &amp;swig_module, name)
+
+/* -------- TYPES TABLE (END) -------- */
+
+#define SWIG_init    Init_file3
+#define SWIG_name    &quot;File3&quot;
+
+static VALUE mFile3;
+
+#define SWIG_RUBY_THREAD_BEGIN_BLOCK
+#define SWIG_RUBY_THREAD_END_BLOCK
+
+
+#define SWIGVERSION 0x010334 
+#define SWIG_VERSION SWIGVERSION
+
+
+#define SWIG_as_voidptr(a) const_cast&lt; void * &gt;(static_cast&lt; const void * &gt;(a)) 
+#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast&lt; void** &gt;(a)) 
+
+
+#include &lt;stdexcept&gt;
+
+
+#include &lt;stdexcept&gt;
+
+
+namespace swig {
+  class GC_VALUE {
+  protected:
+    // Hash of all GC_VALUE's currently in use
+    static VALUE _hash;
+
+    VALUE  _obj;
+
+    static ID hash_id;
+    static ID   lt_id;
+    static ID   gt_id;
+    static ID   eq_id;
+    static ID   le_id;
+    static ID   ge_id;
+
+    static ID  pos_id;
+    static ID  neg_id;
+    static ID  inv_id;
+
+    static ID  add_id;
+    static ID  sub_id;
+    static ID  mul_id;
+    static ID  div_id;
+    static ID  mod_id;
+
+    static ID  and_id;
+    static ID   or_id;
+    static ID  xor_id;
+
+    static ID  lshift_id;
+    static ID  rshift_id;
+
+    struct OpArgs
+    {
+      VALUE src;
+      ID    id;
+      int   nargs;
+      VALUE target;
+    };
+
+
+  public:
+    static void initialize()
+    {
+      if ( _hash == Qnil ) 
+	{ 
+	  _hash = rb_hash_new();
+	  rb_gc_register_address( &amp;_hash );
+	}
+    }
+
+    // this function is never called.  Provided for symmetry only.
+    static void cleanup()
+    {
+      rb_gc_unregister_address( &amp;_hash );
+    }
+
+    GC_VALUE() : _obj( Qnil )
+    {
+    }
+
+    GC_VALUE(const GC_VALUE&amp; item) : _obj(item._obj)
+    {
+      GC_register();
+    }
+    
+    GC_VALUE(VALUE obj) :_obj(obj)
+    {
+      GC_register();
+    }
+    
+    ~GC_VALUE() 
+    {
+      GC_unregister();
+    }
+    
+    GC_VALUE &amp; operator=(const GC_VALUE&amp; item) 
+    {
+      GC_unregister();
+      _obj = item._obj;
+      GC_register();
+      return *this;
+    }
+
+    void GC_register()
+    {
+      if ( FIXNUM_P(_obj) || SPECIAL_CONST_P(_obj) || SYMBOL_P(_obj) ) 
+	return;
+      VALUE val = rb_hash_aref( _hash, _obj );
+      unsigned n = FIXNUM_P(val) ? NUM2UINT(val) : 0;
+      ++n;
+      rb_hash_aset( _hash, _obj, INT2NUM(n) );
+    }
+
+    void GC_unregister()
+    {
+      if ( FIXNUM_P(_obj) || SPECIAL_CONST_P(_obj) || SYMBOL_P(_obj) ) 
+	return;
+      // this test should not be needed but I've noticed some very erratic
+      // behavior of none being unregistered in some very rare situations.
+      if ( BUILTIN_TYPE(_obj) == T_NONE ) return;
+
+      VALUE val = rb_hash_aref( _hash, _obj );
+      unsigned n = FIXNUM_P(val) ? NUM2UINT(val) : 1;
+      --n;
+      if ( n )
+	rb_hash_aset( _hash, _obj, INT2NUM(n) );
+      else
+	rb_hash_delete( _hash, _obj );
+    }
+    
+    operator VALUE() const
+    {
+      return _obj;
+    }
+
+    VALUE inspect() const
+    {
+      return rb_inspect(_obj);
+    }
+
+    VALUE to_s() const
+    {
+      return rb_inspect(_obj);
+    }
+
+    static VALUE swig_protect_funcall( VALUE p )
+    {
+      OpArgs* args = (OpArgs*) p;
+      return rb_funcall( args-&gt;src, args-&gt;id, args-&gt;nargs, args-&gt;target );
+    }
+
+
+#define GC_VALUE_CMP( op_id, op, cmp, cmpval ) \
+    bool op( const GC_VALUE&amp; other ) const \
+    { \
+      if ( FIXNUM_P(_obj) &amp;&amp; FIXNUM_P(other._obj) ) \
+      { \
+	return _obj cmp other._obj; \
+      } \
+      bool  res = false; \
+      VALUE ret = Qnil; \
+      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
+      if ( rb_respond_to( _obj, op_id ) == Qtrue ) \
+	{ \
+	  int status; \
+	  OpArgs  args; \
+          args.src    = _obj; \
+	  args.id     = op_id; \
+	  args.nargs  = 1; \
+	  args.target = VALUE(other); \
+	  ret = rb_protect( PROTECTFUNC(swig_protect_funcall), \
+                            VALUE(&amp;args), &amp;status ); \
+	} \
+      if ( ret == Qnil ) { \
+	VALUE a = rb_funcall(         _obj, hash_id, 0 ); \
+	VALUE b = rb_funcall( VALUE(other), hash_id, 0 ); \
+	res = a cmp b; \
+      } \
+      else \
+	{ \
+	  res = RTEST( ret ); \
+	} \
+      SWIG_RUBY_THREAD_END_BLOCK; \
+      return res; \
+    }
+
+
+    GC_VALUE_CMP( eq_id, operator==, ==, == 0 )
+    GC_VALUE_CMP( lt_id, operator&lt;,  &lt; , &lt;  0 )
+    GC_VALUE_CMP( le_id, operator&lt;=, &lt;=, &lt;= 0 )
+    GC_VALUE_CMP( gt_id, operator&gt;,  &gt; , &gt;  0 )
+    GC_VALUE_CMP( ge_id, operator&gt;=, &gt;=, &gt;= 0 )
+#undef GC_VALUE_CMP
+
+    bool operator!=( const GC_VALUE&amp; other )
+    {
+      return !(this-&gt;operator==(other));
+    }
+
+#define GC_VALUE_UNARY( proc_id, op ) \
+    GC_VALUE op() const \
+    { \
+      VALUE ret = Qnil; \
+      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
+      int status; \
+      OpArgs  args; \
+      args.src    = _obj; \
+      args.id     = proc_id; \
+      args.nargs  = 0; \
+      args.target = Qnil; \
+      ret = rb_protect( PROTECTFUNC(swig_protect_funcall), VALUE(&amp;args), \
+			&amp;status ); \
+      SWIG_RUBY_THREAD_END_BLOCK; \
+      return ret; \
+    }
+
+    GC_VALUE_UNARY( pos_id, operator+ )
+    GC_VALUE_UNARY( neg_id, operator- )
+    GC_VALUE_UNARY( inv_id, operator~ )
+#undef GC_VALUE_BINARY
+
+#define GC_VALUE_BINARY( proc_id, op ) \
+    GC_VALUE op( const GC_VALUE&amp; other ) const \
+    { \
+      VALUE ret = Qnil; \
+      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
+      int status; \
+      OpArgs  args; \
+      args.src    = _obj; \
+      args.id     = proc_id; \
+      args.nargs  = 1; \
+      args.target = VALUE(other); \
+      ret = rb_protect( PROTECTFUNC(swig_protect_funcall), VALUE(&amp;args), \
+			&amp;status ); \
+      SWIG_RUBY_THREAD_END_BLOCK; \
+      return GC_VALUE(ret); \
+    }
+
+    GC_VALUE_BINARY( add_id, operator+ );
+    GC_VALUE_BINARY( sub_id, operator- );
+    GC_VALUE_BINARY( mul_id, operator* );
+    GC_VALUE_BINARY( div_id, operator/ );
+    GC_VALUE_BINARY( mod_id, operator% );
+    
+    GC_VALUE_BINARY( and_id, operator&amp; );
+    GC_VALUE_BINARY( xor_id, operator^ );
+    GC_VALUE_BINARY(  or_id, operator| );
+
+    GC_VALUE_BINARY( lshift_id, operator&lt;&lt; );
+    GC_VALUE_BINARY( rshift_id, operator&gt;&gt; );
+#undef GC_VALUE_BINARY
+
+  };
+
+  ID  GC_VALUE::hash_id = rb_intern(&quot;hash&quot;);
+  ID  GC_VALUE::lt_id = rb_intern(&quot;&lt;&quot;);
+  ID  GC_VALUE::gt_id = rb_intern(&quot;&gt;&quot;);
+  ID  GC_VALUE::eq_id = rb_intern(&quot;==&quot;);
+  ID  GC_VALUE::le_id = rb_intern(&quot;&lt;=&quot;);
+  ID  GC_VALUE::ge_id = rb_intern(&quot;&gt;=&quot;);
+
+  ID  GC_VALUE::pos_id = rb_intern(&quot;+@&quot;);
+  ID  GC_VALUE::neg_id = rb_intern(&quot;-@&quot;);
+  ID  GC_VALUE::inv_id = rb_intern(&quot;~&quot;);
+
+  ID  GC_VALUE::add_id = rb_intern(&quot;+&quot;);
+  ID  GC_VALUE::sub_id = rb_intern(&quot;-&quot;);
+  ID  GC_VALUE::mul_id = rb_intern(&quot;*&quot;);
+  ID  GC_VALUE::div_id = rb_intern(&quot;/&quot;);
+  ID  GC_VALUE::mod_id = rb_intern(&quot;%&quot;);
+
+  ID  GC_VALUE::and_id = rb_intern(&quot;&amp;&quot;);
+  ID  GC_VALUE::or_id  = rb_intern(&quot;|&quot;);
+  ID  GC_VALUE::xor_id = rb_intern(&quot;^&quot;);
+
+  ID  GC_VALUE::lshift_id = rb_intern(&quot;&lt;&lt;&quot;);
+  ID  GC_VALUE::rshift_id = rb_intern(&quot;&gt;&gt;&quot;);
+
+  VALUE GC_VALUE::_hash = Qnil;
+
+  typedef GC_VALUE LANGUAGE_OBJ;
+
+} // namespace swig
+
+
+
+  
+#if defined(__SUNPRO_CC) &amp;&amp; defined(_RWSTD_VER)
+#  define SWIG_STD_NOASSIGN_STL
+#  define SWIG_STD_NOINSERT_TEMPLATE_STL
+#  define SWIG_STD_NOITERATOR_TRAITS_STL
+#endif
+
+#if defined(__GNUC__)
+#  if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR &lt;= 96
+#     define SWIG_STD_NOMODERN_STL
+#  endif
+#endif
+
+
+
+
+#include &lt;string&gt;
+#include &lt;stdexcept&gt;
+
+
+#include &lt;string&gt;
+
+
+#include &lt;iostream&gt;
+
+  
+namespace swig {
+  struct stop_iteration {
+  };
+
+  /** 
+   * Abstract base class used to represent all iterators of STL containers.
+   */
+  struct ConstIterator {
+  public:
+    typedef ConstIterator self_type;
+
+  protected:
+    GC_VALUE _seq;
+
+  protected:
+    ConstIterator(VALUE seq) : _seq(seq)
+    {
+    }
+
+    // Random access iterator methods, but not required in Ruby
+    virtual ptrdiff_t distance(const ConstIterator &amp;x) const
+    {
+      throw std::invalid_argument(&quot;distance not supported&quot;);
+    }
+
+    virtual bool equal (const ConstIterator &amp;x) const
+    {
+      throw std::invalid_argument(&quot;equal not supported&quot;);
+    }
+
+    virtual self_type* advance(ptrdiff_t n)
+    {
+      throw std::invalid_argument(&quot;advance not supported&quot;);
+    }
+      
+  public:
+    virtual ~ConstIterator() {}
+
+    // Access iterator method, required by Ruby
+    virtual VALUE value() const {
+      throw std::invalid_argument(&quot;value not supported&quot;);
+      return Qnil;
+    };
+
+    virtual VALUE setValue( const VALUE&amp; v ) {
+      throw std::invalid_argument(&quot;value= not supported&quot;);
+      return Qnil;
+    }
+
+    virtual self_type* next( size_t n = 1 )
+    {
+      return this-&gt;advance( n );
+    }
+
+    virtual self_type* previous( size_t n = 1 )
+    {
+      ptrdiff_t nn = n;
+      return this-&gt;advance( -nn );
+    }
+
+    virtual VALUE to_s() const {
+      throw std::invalid_argument(&quot;to_s not supported&quot;);
+      return Qnil;
+    }
+
+    virtual VALUE inspect() const {
+      throw std::invalid_argument(&quot;inspect not supported&quot;);
+      return Qnil;
+    }
+    
+    virtual ConstIterator *dup() const
+    {
+      throw std::invalid_argument(&quot;dup not supported&quot;);
+      return NULL;
+    }
+
+    //
+    // C++ common/needed methods.  We emulate a bidirectional
+    // operator, to be compatible with all the STL.
+    // The iterator traits will then tell the STL what type of
+    // iterator we really are.
+    //
+    ConstIterator() : _seq( Qnil )
+    {
+    }
+
+    ConstIterator( const self_type&amp; b ) : _seq( b._seq )
+    {
+    }
+
+    self_type&amp; operator=( const self_type&amp; b )
+    {
+      _seq = b._seq;
+      return *this;
+    }
+
+    bool operator == (const ConstIterator&amp; x)  const
+    {
+      return equal(x);
+    }
+      
+    bool operator != (const ConstIterator&amp; x) const
+    {
+      return ! operator==(x);
+    }
+      
+    // Pre-decrement operator
+    self_type&amp; operator--()
+    {
+      return *previous();
+    }
+
+    // Pre-increment operator
+    self_type&amp; operator++()
+    {
+      return *next();
+    }
+
+    // Post-decrement operator
+    self_type operator--(int)
+    {
+      self_type r = *this;
+      previous();
+      return r;
+    }
+
+    // Post-increment operator
+    self_type operator++(int)
+    {
+      self_type r = *this;
+      next();
+      return r;
+    }
+
+    ConstIterator&amp; operator += (ptrdiff_t n)
+    {
+      return *advance(n);
+    }
+
+    ConstIterator&amp; operator -= (ptrdiff_t n)
+    {
+      return *advance(-n);
+    }
+
+    ConstIterator* operator + (ptrdiff_t n) const
+    {
+      return dup()-&gt;advance(n);
+    }
+
+    ConstIterator* operator - (ptrdiff_t n) const
+    {
+      return dup()-&gt;advance(-n);
+    }
+      
+    ptrdiff_t operator - (const ConstIterator&amp; x) const
+    {
+      return x.distance(*this);
+    }
+      
+    static swig_type_info* descriptor() {
+      static int init = 0;
+      static swig_type_info* desc = 0;
+      if (!init) {
+	desc = SWIG_TypeQuery(&quot;swig::ConstIterator *&quot;);
+	init = 1;
+      }	
+      return desc;
+    }
+  };
+
+
+  /**
+   * Abstract base class used to represent all non-const iterators of STL containers.
+   * 
+   */
+  struct Iterator : public ConstIterator {
+  public:
+    typedef Iterator self_type;
+
+  protected:
+    Iterator(VALUE seq) : ConstIterator(seq)
+    {
+    }
+
+    virtual self_type* advance(ptrdiff_t n)
+    {
+      throw std::invalid_argument(&quot;operation not supported&quot;);
+    }
+
+  public:
+    static swig_type_info* descriptor() {
+      static int init = 0;
+      static swig_type_info* desc = 0;
+      if (!init) {
+	desc = SWIG_TypeQuery(&quot;swig::Iterator *&quot;);
+	init = 1;
+      }	
+      return desc;
+    }
+    
+    virtual Iterator *dup() const
+    {
+      throw std::invalid_argument(&quot;dup not supported&quot;);
+      return NULL;
+    }
+      
+    virtual self_type* next( size_t n = 1 )
+    {
+      return this-&gt;advance( n );
+    }
+
+    virtual self_type* previous( size_t n = 1 )
+    {
+      ptrdiff_t nn = n;
+      return this-&gt;advance( -nn );
+    }
+
+    bool operator == (const ConstIterator&amp; x)  const
+    {
+      return equal(x);
+    }
+      
+    bool operator != (const Iterator&amp; x) const
+    {
+      return ! operator==(x);
+    }
+      
+    Iterator&amp; operator += (ptrdiff_t n)
+    {
+      return *advance(n);
+    }
+
+    Iterator&amp; operator -= (ptrdiff_t n)
+    {
+      return *advance(-n);
+    }
+      
+    Iterator* operator + (ptrdiff_t n) const
+    {
+      return dup()-&gt;advance(n);
+    }
+
+    Iterator* operator - (ptrdiff_t n) const
+    {
+      return dup()-&gt;advance(-n);
+    }
+      
+    ptrdiff_t operator - (const Iterator&amp; x) const
+    {
+      return x.distance(*this);
+    }
+  };
+
+}
+
+
+SWIGINTERN VALUE
+SWIG_ruby_failed(void)
+{
+  return Qnil;
+} 
+
+
+/*@SWIG:/Users/davidkamphausen/projects/antargis/rookey/externals/built/swig/share/swig/1.3.34/ruby/rubyprimtypes.swg,23,%ruby_aux_method@*/
+SWIGINTERN VALUE SWIG_AUX_NUM2ULONG(VALUE *args)
+{
+  VALUE obj = args[0];
+  VALUE type = TYPE(obj);
+  unsigned long *res = (unsigned long *)(args[1]);
+  *res = type == T_FIXNUM ? NUM2ULONG(obj) : rb_big2ulong(obj);
+  return obj;
+}
+/*@SWIG@*/
+
+SWIGINTERN int
+SWIG_AsVal_unsigned_SS_long (VALUE obj, unsigned long *val) 
+{
+  VALUE type = TYPE(obj);
+  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
+    unsigned long v;
+    VALUE a[2];
+    a[0] = obj;
+    a[1] = (VALUE)(&amp;v);
+    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2ULONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
+      if (val) *val = v;
+      return SWIG_OK;
+    }
+  }
+  return SWIG_TypeError;
+}
+
+
+SWIGINTERNINLINE int
+SWIG_AsVal_size_t (VALUE obj, size_t *val)
+{
+  unsigned long v;
+  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &amp;v : 0);
+  if (SWIG_IsOK(res) &amp;&amp; val) *val = static_cast&lt; size_t &gt;(v);
+  return res;
+}
+
+
+SWIGINTERNINLINE VALUE
+SWIG_From_bool  (bool value)
+{
+  return value ? Qtrue : Qfalse;
+}
+
+
+/*@SWIG:/Users/davidkamphausen/projects/antargis/rookey/externals/built/swig/share/swig/1.3.34/ruby/rubyprimtypes.swg,23,%ruby_aux_method@*/
+SWIGINTERN VALUE SWIG_AUX_NUM2LONG(VALUE *args)
+{
+  VALUE obj = args[0];
+  VALUE type = TYPE(obj);
+  long *res = (long *)(args[1]);
+  *res = type == T_FIXNUM ? NUM2LONG(obj) : rb_big2long(obj);
+  return obj;
+}
+/*@SWIG@*/
+
+SWIGINTERN int
+SWIG_AsVal_long (VALUE obj, long* val)
+{
+  VALUE type = TYPE(obj);
+  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
+    long v;
+    VALUE a[2];
+    a[0] = obj;
+    a[1] = (VALUE)(&amp;v);
+    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2LONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
+      if (val) *val = v;
+      return SWIG_OK;
+    }
+  }
+  return SWIG_TypeError;
+}
+
+
+SWIGINTERNINLINE int
+SWIG_AsVal_ptrdiff_t (VALUE obj, ptrdiff_t *val)
+{
+  long v;
+  int res = SWIG_AsVal_long (obj, val ? &amp;v : 0);
+  if (SWIG_IsOK(res) &amp;&amp; val) *val = static_cast&lt; ptrdiff_t &gt;(v);
+  return res;
+}
+
+
+#include &lt;limits.h&gt;
+#if !defined(SWIG_NO_LLONG_MAX)
+# if !defined(LLONG_MAX) &amp;&amp; defined(__GNUC__) &amp;&amp; defined (__LONG_LONG_MAX__)
+#   define LLONG_MAX __LONG_LONG_MAX__
+#   define LLONG_MIN (-LLONG_MAX - 1LL)
+#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
+# endif
+#endif
+
+
+  #define SWIG_From_long   LONG2NUM 
+
+
+SWIGINTERNINLINE VALUE
+SWIG_From_ptrdiff_t  (ptrdiff_t value)
+{    
+  return SWIG_From_long  (static_cast&lt; long &gt;(value));
+}
+
+
+#include &lt;stdexcept&gt;
+
+
+#include &lt;algorithm&gt;
+
+
+#include &lt;vector&gt;
+
+
+#include &lt;utility&gt;
+
+
+#include &lt;map&gt;
+#include &lt;algorithm&gt;
+#include &lt;stdexcept&gt;
+
+
+#include &lt;list&gt;
+
+
+#include &quot;../cpp/ag_rubyobj.h&quot;
+#include &quot;a.h&quot;
+
+
+      /*
+template&lt;class T&gt;
+VALUE convertCpp2Ruby(T *cObject)
+{
+  return SWIG_RubyInstanceFor(cObject);
+}
+template&lt;AGRubyObject&gt;*/ 
+VALUE convertCpp2Ruby(AGRubyObject *cObject)
+{
+  return SWIG_RubyInstanceFor(cObject);
+}
+  
+
+
+
+
+
+
+        
+        swig_type_info* AGRubyObject_dynamic_cast(void **p)
+        {
+                AGRubyObject *a=(AGRubyObject*)(*p);
+        
+                
+                {
+	                B*b=dynamic_cast&lt;B*&gt;(a);
+	                if(b)
+	                {
+	                        *p=(void*)b;
+	                        return SWIGTYPE_p_B;
+	                }
+                }
+
+                return 0;
+        }
+        
+        
+/* ---------------------------------------------------
+ * C++ director class helpers
+ * --------------------------------------------------- */
+
+
+
+/* ---------------------------------------------------
+ * C++ director class methods
+ * --------------------------------------------------- */
+
+#include &quot;file3_swig.h&quot;
+
+SwigDirector_AGRubyObject::SwigDirector_AGRubyObject(VALUE self): AGRubyObject(), Swig::Director(self) {
+  
+}
+
+
+
+SwigDirector_AGRubyObject::~SwigDirector_AGRubyObject() {
+}
+
+SwigDirector_B::SwigDirector_B(VALUE self): B(), Swig::Director(self) {
+  
+}
+
+
+
+SwigDirector_B::~SwigDirector_B() {
+}
+
+void SwigDirector_B::x() {
+  VALUE result;
+  
+  result = rb_funcall(swig_get_self(), rb_intern(&quot;x&quot;), 0, NULL);
+}
+
+
+
+/*
+  Document-class: File3::GC_VALUE
+
+  Proxy of C++ File3::GC_VALUE class
+
+
+*/
+swig_class cGC_VALUE;
+
+
+/*
+  Document-method: File3::GC_VALUE.inspect
+
+  call-seq:
+    inspect -&gt; VALUE
+
+Inspect class and its contents.
+*/
+SWIGINTERN VALUE
+_wrap_GC_VALUE_inspect(int argc, VALUE *argv, VALUE self) {
+  swig::GC_VALUE *arg1 = (swig::GC_VALUE *) 0 ;
+  VALUE result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__GC_VALUE, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::GC_VALUE const *&quot;,&quot;inspect&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::GC_VALUE * &gt;(argp1);
+  result = (VALUE)((swig::GC_VALUE const *)arg1)-&gt;inspect();
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::GC_VALUE.to_s
+
+  call-seq:
+    to_s -&gt; VALUE
+
+Convert class to a String representation.
+*/
+SWIGINTERN VALUE
+_wrap_GC_VALUE_to_s(int argc, VALUE *argv, VALUE self) {
+  swig::GC_VALUE *arg1 = (swig::GC_VALUE *) 0 ;
+  VALUE result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__GC_VALUE, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::GC_VALUE const *&quot;,&quot;to_s&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::GC_VALUE * &gt;(argp1);
+  result = (VALUE)((swig::GC_VALUE const *)arg1)-&gt;to_s();
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-class: File3::ConstIterator
+
+  Proxy of C++ File3::ConstIterator class
+
+
+*/
+swig_class cConstIterator;
+
+SWIGINTERN void
+free_swig_ConstIterator(swig::ConstIterator *arg1) {
+    delete arg1;
+}
+
+
+/*
+  Document-method: File3::ConstIterator.value
+
+  call-seq:
+    value -&gt; VALUE
+
+An instance method.
+
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator_value(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  VALUE result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::ConstIterator const *&quot;,&quot;value&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::ConstIterator * &gt;(argp1);
+  try {
+    result = (VALUE)((swig::ConstIterator const *)arg1)-&gt;value();
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::ConstIterator.dup
+
+  call-seq:
+    dup -&gt; ConstIterator
+
+Create a duplicate of the class and unfreeze it if needed.
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator_dup(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  swig::ConstIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::ConstIterator const *&quot;,&quot;dup&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::ConstIterator * &gt;(argp1);
+  result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)-&gt;dup();
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::ConstIterator.inspect
+
+  call-seq:
+    inspect -&gt; VALUE
+
+Inspect class and its contents.
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator_inspect(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  VALUE result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::ConstIterator const *&quot;,&quot;inspect&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::ConstIterator * &gt;(argp1);
+  result = (VALUE)((swig::ConstIterator const *)arg1)-&gt;inspect();
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::ConstIterator.to_s
+
+  call-seq:
+    to_s -&gt; VALUE
+
+Convert class to a String representation.
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator_to_s(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  VALUE result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::ConstIterator const *&quot;,&quot;to_s&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::ConstIterator * &gt;(argp1);
+  result = (VALUE)((swig::ConstIterator const *)arg1)-&gt;to_s();
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::ConstIterator.next
+
+  call-seq:
+    next(size_t n=1) -&gt; ConstIterator
+    next -&gt; ConstIterator
+
+An instance method.
+
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator_next__SWIG_0(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  size_t arg2 ;
+  swig::ConstIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::ConstIterator *&quot;,&quot;next&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::ConstIterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[0], &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( &quot;&quot;, &quot;size_t&quot;,&quot;next&quot;, 2, argv[0] ));
+  } 
+  arg2 = static_cast&lt; size_t &gt;(val2);
+  result = (swig::ConstIterator *)(arg1)-&gt;next(arg2);
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_ConstIterator_next__SWIG_1(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  swig::ConstIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::ConstIterator *&quot;,&quot;next&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::ConstIterator * &gt;(argp1);
+  try {
+    result = (swig::ConstIterator *)(arg1)-&gt;next();
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE _wrap_ConstIterator_next(int nargs, VALUE *args, VALUE self) {
+  int argc;
+  VALUE argv[3];
+  int ii;
+  
+  argc = nargs + 1;
+  argv[0] = self;
+  if (argc &gt; 3) SWIG_fail;
+  for (ii = 1; (ii &lt; argc); ++ii) {
+    argv[ii] = args[ii-1];
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__ConstIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_ConstIterator_next__SWIG_1(nargs, args, self);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__ConstIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_ConstIterator_next__SWIG_0(nargs, args, self);
+      }
+    }
+  }
+  
+fail:
+  Ruby_Format_OverloadedError( argc, 3, &quot;ConstIterator.next&quot;, 
+    &quot;    swig::ConstIterator * ConstIterator.next(size_t n)\n&quot;
+    &quot;    swig::ConstIterator * ConstIterator.next()\n&quot;);
+  
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::ConstIterator.previous
+
+  call-seq:
+    previous(size_t n=1) -&gt; ConstIterator
+    previous -&gt; ConstIterator
+
+An instance method.
+
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator_previous__SWIG_0(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  size_t arg2 ;
+  swig::ConstIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::ConstIterator *&quot;,&quot;previous&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::ConstIterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[0], &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( &quot;&quot;, &quot;size_t&quot;,&quot;previous&quot;, 2, argv[0] ));
+  } 
+  arg2 = static_cast&lt; size_t &gt;(val2);
+  result = (swig::ConstIterator *)(arg1)-&gt;previous(arg2);
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_ConstIterator_previous__SWIG_1(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  swig::ConstIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::ConstIterator *&quot;,&quot;previous&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::ConstIterator * &gt;(argp1);
+  try {
+    result = (swig::ConstIterator *)(arg1)-&gt;previous();
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE _wrap_ConstIterator_previous(int nargs, VALUE *args, VALUE self) {
+  int argc;
+  VALUE argv[3];
+  int ii;
+  
+  argc = nargs + 1;
+  argv[0] = self;
+  if (argc &gt; 3) SWIG_fail;
+  for (ii = 1; (ii &lt; argc); ++ii) {
+    argv[ii] = args[ii-1];
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__ConstIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_ConstIterator_previous__SWIG_1(nargs, args, self);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__ConstIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_ConstIterator_previous__SWIG_0(nargs, args, self);
+      }
+    }
+  }
+  
+fail:
+  Ruby_Format_OverloadedError( argc, 3, &quot;ConstIterator.previous&quot;, 
+    &quot;    swig::ConstIterator * ConstIterator.previous(size_t n)\n&quot;
+    &quot;    swig::ConstIterator * ConstIterator.previous()\n&quot;);
+  
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::ConstIterator.==
+
+  call-seq:
+    ==(x) -&gt; bool
+
+Equality comparison operator.
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator___eq__(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  swig::ConstIterator *arg2 = 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::ConstIterator const *&quot;,&quot;operator ==&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::ConstIterator * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &amp;argp2, SWIGTYPE_p_swig__ConstIterator,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::ConstIterator const &amp;&quot;,&quot;operator ==&quot;, 2, argv[0] )); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError(&quot;invalid null reference &quot;, &quot;swig::ConstIterator const &amp;&quot;,&quot;operator ==&quot;, 2, argv[0])); 
+  }
+  arg2 = reinterpret_cast&lt; swig::ConstIterator * &gt;(argp2);
+  result = (bool)((swig::ConstIterator const *)arg1)-&gt;operator ==((swig::ConstIterator const &amp;)*arg2);
+  vresult = SWIG_From_bool(static_cast&lt; bool &gt;(result));
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::ConstIterator.+
+
+  call-seq:
+    +(n) -&gt; ConstIterator
+
+Add operator.
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator___add__(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  ptrdiff_t arg2 ;
+  swig::ConstIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::ConstIterator const *&quot;,&quot;operator +&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::ConstIterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( &quot;&quot;, &quot;ptrdiff_t&quot;,&quot;operator +&quot;, 2, argv[0] ));
+  } 
+  arg2 = static_cast&lt; ptrdiff_t &gt;(val2);
+  try {
+    result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)-&gt;operator +(arg2);
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::ConstIterator.-
+
+  call-seq:
+    -(n) -&gt; ConstIterator
+    -(x) -&gt; ptrdiff_t
+
+Substraction operator.
+*/
+SWIGINTERN VALUE
+_wrap_ConstIterator___sub____SWIG_0(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  ptrdiff_t arg2 ;
+  swig::ConstIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::ConstIterator const *&quot;,&quot;operator -&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::ConstIterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( &quot;&quot;, &quot;ptrdiff_t&quot;,&quot;operator -&quot;, 2, argv[0] ));
+  } 
+  arg2 = static_cast&lt; ptrdiff_t &gt;(val2);
+  try {
+    result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)-&gt;operator -(arg2);
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_ConstIterator___sub____SWIG_1(int argc, VALUE *argv, VALUE self) {
+  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
+  swig::ConstIterator *arg2 = 0 ;
+  ptrdiff_t result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::ConstIterator const *&quot;,&quot;operator -&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::ConstIterator * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &amp;argp2, SWIGTYPE_p_swig__ConstIterator,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::ConstIterator const &amp;&quot;,&quot;operator -&quot;, 2, argv[0] )); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError(&quot;invalid null reference &quot;, &quot;swig::ConstIterator const &amp;&quot;,&quot;operator -&quot;, 2, argv[0])); 
+  }
+  arg2 = reinterpret_cast&lt; swig::ConstIterator * &gt;(argp2);
+  result = ((swig::ConstIterator const *)arg1)-&gt;operator -((swig::ConstIterator const &amp;)*arg2);
+  vresult = SWIG_From_ptrdiff_t(static_cast&lt; ptrdiff_t &gt;(result));
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE _wrap_ConstIterator___sub__(int nargs, VALUE *args, VALUE self) {
+  int argc;
+  VALUE argv[3];
+  int ii;
+  
+  argc = nargs + 1;
+  argv[0] = self;
+  if (argc &gt; 3) SWIG_fail;
+  for (ii = 1; (ii &lt; argc); ++ii) {
+    argv[ii] = args[ii-1];
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__ConstIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &amp;vptr, SWIGTYPE_p_swig__ConstIterator, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_ConstIterator___sub____SWIG_1(nargs, args, self);
+      }
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__ConstIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_ConstIterator___sub____SWIG_0(nargs, args, self);
+      }
+    }
+  }
+  
+fail:
+  Ruby_Format_OverloadedError( argc, 3, &quot;__sub__.new&quot;, 
+    &quot;    __sub__.new(ptrdiff_t n)\n&quot;
+    &quot;    __sub__.new(swig::ConstIterator const &amp;x)\n&quot;);
+  
+  return Qnil;
+}
+
+
+
+/*
+  Document-class: File3::Iterator &lt; File3::swig::ConstIterator
+
+  Proxy of C++ File3::Iterator class
+
+
+*/
+swig_class cIterator;
+
+
+/*
+  Document-method: File3::Iterator.value=
+
+  call-seq:
+    value=(VALUE v) -&gt; VALUE
+
+An instance method.
+
+*/
+SWIGINTERN VALUE
+_wrap_Iterator_valuee___(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  VALUE *arg2 = 0 ;
+  VALUE result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE temp2 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::Iterator *&quot;,&quot;setValue&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::Iterator * &gt;(argp1);
+  temp2 = static_cast&lt; VALUE &gt;(argv[0]);
+  arg2 = &amp;temp2;
+  result = (VALUE)(arg1)-&gt;setValue((VALUE const &amp;)*arg2);
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::Iterator.dup
+
+  call-seq:
+    dup -&gt; Iterator
+
+Create a duplicate of the class and unfreeze it if needed.
+*/
+SWIGINTERN VALUE
+_wrap_Iterator_dup(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  swig::Iterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::Iterator const *&quot;,&quot;dup&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::Iterator * &gt;(argp1);
+  result = (swig::Iterator *)((swig::Iterator const *)arg1)-&gt;dup();
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::Iterator.next
+
+  call-seq:
+    next(size_t n=1) -&gt; Iterator
+    next -&gt; Iterator
+
+An instance method.
+
+*/
+SWIGINTERN VALUE
+_wrap_Iterator_next__SWIG_0(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  size_t arg2 ;
+  swig::Iterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::Iterator *&quot;,&quot;next&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::Iterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[0], &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( &quot;&quot;, &quot;size_t&quot;,&quot;next&quot;, 2, argv[0] ));
+  } 
+  arg2 = static_cast&lt; size_t &gt;(val2);
+  result = (swig::Iterator *)(arg1)-&gt;next(arg2);
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_Iterator_next__SWIG_1(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  swig::Iterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::Iterator *&quot;,&quot;next&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::Iterator * &gt;(argp1);
+  try {
+    result = (swig::Iterator *)(arg1)-&gt;next();
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE _wrap_Iterator_next(int nargs, VALUE *args, VALUE self) {
+  int argc;
+  VALUE argv[3];
+  int ii;
+  
+  argc = nargs + 1;
+  argv[0] = self;
+  if (argc &gt; 3) SWIG_fail;
+  for (ii = 1; (ii &lt; argc); ++ii) {
+    argv[ii] = args[ii-1];
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__Iterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_Iterator_next__SWIG_1(nargs, args, self);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__Iterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_Iterator_next__SWIG_0(nargs, args, self);
+      }
+    }
+  }
+  
+fail:
+  Ruby_Format_OverloadedError( argc, 3, &quot;Iterator.next&quot;, 
+    &quot;    swig::Iterator * Iterator.next(size_t n)\n&quot;
+    &quot;    swig::Iterator * Iterator.next()\n&quot;);
+  
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::Iterator.previous
+
+  call-seq:
+    previous(size_t n=1) -&gt; Iterator
+    previous -&gt; Iterator
+
+An instance method.
+
+*/
+SWIGINTERN VALUE
+_wrap_Iterator_previous__SWIG_0(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  size_t arg2 ;
+  swig::Iterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::Iterator *&quot;,&quot;previous&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::Iterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[0], &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( &quot;&quot;, &quot;size_t&quot;,&quot;previous&quot;, 2, argv[0] ));
+  } 
+  arg2 = static_cast&lt; size_t &gt;(val2);
+  result = (swig::Iterator *)(arg1)-&gt;previous(arg2);
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_Iterator_previous__SWIG_1(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  swig::Iterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::Iterator *&quot;,&quot;previous&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::Iterator * &gt;(argp1);
+  try {
+    result = (swig::Iterator *)(arg1)-&gt;previous();
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE _wrap_Iterator_previous(int nargs, VALUE *args, VALUE self) {
+  int argc;
+  VALUE argv[3];
+  int ii;
+  
+  argc = nargs + 1;
+  argv[0] = self;
+  if (argc &gt; 3) SWIG_fail;
+  for (ii = 1; (ii &lt; argc); ++ii) {
+    argv[ii] = args[ii-1];
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__Iterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_Iterator_previous__SWIG_1(nargs, args, self);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__Iterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_Iterator_previous__SWIG_0(nargs, args, self);
+      }
+    }
+  }
+  
+fail:
+  Ruby_Format_OverloadedError( argc, 3, &quot;Iterator.previous&quot;, 
+    &quot;    swig::Iterator * Iterator.previous(size_t n)\n&quot;
+    &quot;    swig::Iterator * Iterator.previous()\n&quot;);
+  
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::Iterator.inspect
+
+  call-seq:
+    inspect -&gt; VALUE
+
+Inspect class and its contents.
+*/
+SWIGINTERN VALUE
+_wrap_Iterator_inspect(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  VALUE result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::Iterator const *&quot;,&quot;inspect&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::Iterator * &gt;(argp1);
+  result = (VALUE)((swig::Iterator const *)arg1)-&gt;inspect();
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::Iterator.to_s
+
+  call-seq:
+    to_s -&gt; VALUE
+
+Convert class to a String representation.
+*/
+SWIGINTERN VALUE
+_wrap_Iterator_to_s(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  VALUE result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::Iterator const *&quot;,&quot;to_s&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::Iterator * &gt;(argp1);
+  result = (VALUE)((swig::Iterator const *)arg1)-&gt;to_s();
+  vresult = result;
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::Iterator.==
+
+  call-seq:
+    ==(x) -&gt; bool
+
+Equality comparison operator.
+*/
+SWIGINTERN VALUE
+_wrap_Iterator___eq__(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  swig::Iterator *arg2 = 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::Iterator const *&quot;,&quot;operator ==&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::Iterator * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &amp;argp2, SWIGTYPE_p_swig__Iterator,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::Iterator const &amp;&quot;,&quot;operator ==&quot;, 2, argv[0] )); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError(&quot;invalid null reference &quot;, &quot;swig::Iterator const &amp;&quot;,&quot;operator ==&quot;, 2, argv[0])); 
+  }
+  arg2 = reinterpret_cast&lt; swig::Iterator * &gt;(argp2);
+  result = (bool)((swig::Iterator const *)arg1)-&gt;operator ==((swig::Iterator const &amp;)*arg2);
+  vresult = SWIG_From_bool(static_cast&lt; bool &gt;(result));
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::Iterator.+
+
+  call-seq:
+    +(n) -&gt; Iterator
+
+Add operator.
+*/
+SWIGINTERN VALUE
+_wrap_Iterator___add__(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  ptrdiff_t arg2 ;
+  swig::Iterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::Iterator const *&quot;,&quot;operator +&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::Iterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( &quot;&quot;, &quot;ptrdiff_t&quot;,&quot;operator +&quot;, 2, argv[0] ));
+  } 
+  arg2 = static_cast&lt; ptrdiff_t &gt;(val2);
+  try {
+    result = (swig::Iterator *)((swig::Iterator const *)arg1)-&gt;operator +(arg2);
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::Iterator.-
+
+  call-seq:
+    -(n) -&gt; Iterator
+    -(x) -&gt; ptrdiff_t
+
+Substraction operator.
+*/
+SWIGINTERN VALUE
+_wrap_Iterator___sub____SWIG_0(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  ptrdiff_t arg2 ;
+  swig::Iterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::Iterator const *&quot;,&quot;operator -&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::Iterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( &quot;&quot;, &quot;ptrdiff_t&quot;,&quot;operator -&quot;, 2, argv[0] ));
+  } 
+  arg2 = static_cast&lt; ptrdiff_t &gt;(val2);
+  try {
+    result = (swig::Iterator *)((swig::Iterator const *)arg1)-&gt;operator -(arg2);
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_Ruby_ExceptionType(NULL, Qnil);
+      SWIG_fail;
+    }
+  }
+  
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_Iterator___sub____SWIG_1(int argc, VALUE *argv, VALUE self) {
+  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
+  swig::Iterator *arg2 = 0 ;
+  ptrdiff_t result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::Iterator const *&quot;,&quot;operator -&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; swig::Iterator * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &amp;argp2, SWIGTYPE_p_swig__Iterator,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( &quot;&quot;, &quot;swig::Iterator const &amp;&quot;,&quot;operator -&quot;, 2, argv[0] )); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError(&quot;invalid null reference &quot;, &quot;swig::Iterator const &amp;&quot;,&quot;operator -&quot;, 2, argv[0])); 
+  }
+  arg2 = reinterpret_cast&lt; swig::Iterator * &gt;(argp2);
+  result = ((swig::Iterator const *)arg1)-&gt;operator -((swig::Iterator const &amp;)*arg2);
+  vresult = SWIG_From_ptrdiff_t(static_cast&lt; ptrdiff_t &gt;(result));
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE _wrap_Iterator___sub__(int nargs, VALUE *args, VALUE self) {
+  int argc;
+  VALUE argv[3];
+  int ii;
+  
+  argc = nargs + 1;
+  argv[0] = self;
+  if (argc &gt; 3) SWIG_fail;
+  for (ii = 1; (ii &lt; argc); ++ii) {
+    argv[ii] = args[ii-1];
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__Iterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &amp;vptr, SWIGTYPE_p_swig__Iterator, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_Iterator___sub____SWIG_1(nargs, args, self);
+      }
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__Iterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_Iterator___sub____SWIG_0(nargs, args, self);
+      }
+    }
+  }
+  
+fail:
+  Ruby_Format_OverloadedError( argc, 3, &quot;__sub__.new&quot;, 
+    &quot;    __sub__.new(ptrdiff_t n)\n&quot;
+    &quot;    __sub__.new(swig::Iterator const &amp;x)\n&quot;);
+  
+  return Qnil;
+}
+
+
+SWIGINTERN void
+free_swig_Iterator(swig::Iterator *arg1) {
+    delete arg1;
+}
+
+
+/*
+  Document-class: File3::AGBaseObject
+
+  Proxy of C++ File3::AGBaseObject class
+
+
+*/
+swig_class cAGBaseObject;
+
+#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
+SWIGINTERN VALUE
+_wrap_AGBaseObject_allocate(VALUE self) {
+#else
+  SWIGINTERN VALUE
+  _wrap_AGBaseObject_allocate(int argc, VALUE *argv, VALUE self) {
+#endif
+    
+    
+    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGBaseObject);
+#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
+    rb_obj_call_init(vresult, argc, argv);
+#endif
+    return vresult;
+  }
+  
+
+
+/*
+  Document-method: File3::AGBaseObject.new
+
+  call-seq:
+    AGBaseObject.new(AGRubyObject p)
+
+Class constructor.
+
+*/
+SWIGINTERN VALUE
+_wrap_new_AGBaseObject(int argc, VALUE *argv, VALUE self) {
+  AGRubyObject *arg1 = (AGRubyObject *) 0 ;
+  AGBaseObject *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  const char *classname SWIGUNUSED = &quot;File3::AGBaseObject&quot;;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &amp;argp1,SWIGTYPE_p_AGRubyObject, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;AGRubyObject *&quot;,&quot;AGBaseObject&quot;, 1, argv[0] )); 
+  }
+  arg1 = reinterpret_cast&lt; AGRubyObject * &gt;(argp1);
+  result = (AGBaseObject *)new AGBaseObject(arg1);DATA_PTR(self) = result;
+  SWIG_RubyAddTracking(result, self);
+  
+  return self;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN void
+free_AGBaseObject(AGBaseObject *arg1) {
+    SWIG_RubyRemoveTracking(arg1);
+    delete arg1;
+}
+
+
+/*
+  Document-method: File3::AGBaseObject.baseClear
+
+  call-seq:
+    baseClear
+
+An instance method.
+
+*/
+SWIGINTERN VALUE
+_wrap_AGBaseObject_baseClear(int argc, VALUE *argv, VALUE self) {
+  AGBaseObject *arg1 = (AGBaseObject *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_AGBaseObject, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;AGBaseObject *&quot;,&quot;baseClear&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; AGBaseObject * &gt;(argp1);
+  (arg1)-&gt;baseClear();
+  return Qnil;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::AGBaseObject.valid
+
+  call-seq:
+    valid -&gt; bool
+
+An instance method.
+
+*/
+SWIGINTERN VALUE
+_wrap_AGBaseObject_valid(int argc, VALUE *argv, VALUE self) {
+  AGBaseObject *arg1 = (AGBaseObject *) 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_AGBaseObject, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;AGBaseObject *&quot;,&quot;valid&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; AGBaseObject * &gt;(argp1);
+  result = (bool)(arg1)-&gt;valid();
+  vresult = SWIG_From_bool(static_cast&lt; bool &gt;(result));
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-class: File3::AGRubyObject
+
+  Proxy of C++ File3::AGRubyObject class
+
+
+*/
+swig_class cAGRubyObject;
+
+#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
+SWIGINTERN VALUE
+_wrap_AGRubyObject_allocate(VALUE self) {
+#else
+  SWIGINTERN VALUE
+  _wrap_AGRubyObject_allocate(int argc, VALUE *argv, VALUE self) {
+#endif
+    
+    
+    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AGRubyObject);
+#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
+    rb_obj_call_init(vresult, argc, argv);
+#endif
+    return vresult;
+  }
+  
+
+
+/*
+  Document-method: File3::AGRubyObject.new
+
+  call-seq:
+    AGRubyObject.new
+
+Class constructor.
+
+*/
+SWIGINTERN VALUE
+_wrap_new_AGRubyObject(int argc, VALUE *argv, VALUE self) {
+  VALUE arg1 = (VALUE) 0 ;
+  AGRubyObject *result = 0 ;
+  const char *classname SWIGUNUSED = &quot;File3::AGRubyObject&quot;;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  arg1 = self;
+  if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
+    /* subclassed */
+    result = (AGRubyObject *)new SwigDirector_AGRubyObject(arg1); 
+  } else {
+    result = (AGRubyObject *)new AGRubyObject(); 
+  }
+  DATA_PTR(self) = result;
+  SWIG_RubyAddTracking(result, self);
+  
+  return self;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN void
+free_AGRubyObject(AGRubyObject *arg1) {
+    SWIG_RubyRemoveTracking(arg1);
+    delete arg1;
+}
+
+
+/*
+  Document-method: File3::AGRubyObject.general_markfunc
+
+  call-seq:
+    general_markfunc(void ptr)
+
+A module function.
+
+*/
+SWIGINTERN VALUE
+_wrap_general_markfunc(int argc, VALUE *argv, VALUE self) {
+  void *arg1 = (void *) 0 ;
+  int res1 ;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0],SWIG_as_voidptrptr(&amp;arg1), 0, 0);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;void *&quot;,&quot;general_markfunc&quot;, 1, argv[0] )); 
+  }
+  general_markfunc(arg1);
+  return Qnil;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::AGRubyObject.saveDelete
+
+  call-seq:
+    saveDelete(AGRubyObject o) -&gt; bool
+
+A module function.
+
+*/
+SWIGINTERN VALUE
+_wrap_saveDelete(int argc, VALUE *argv, VALUE self) {
+  AGRubyObject *arg1 = (AGRubyObject *) 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &amp;argp1,SWIGTYPE_p_AGRubyObject, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;AGRubyObject *&quot;,&quot;saveDelete&quot;, 1, argv[0] )); 
+  }
+  arg1 = reinterpret_cast&lt; AGRubyObject * &gt;(argp1);
+  result = (bool)saveDelete(arg1);
+  vresult = SWIG_From_bool(static_cast&lt; bool &gt;(result));
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::AGRubyObject.addRef
+
+  call-seq:
+    addRef(AGBaseObject o)
+
+An instance method.
+
+*/
+SWIGINTERN VALUE
+_wrap_AGRubyObject_addRef(int argc, VALUE *argv, VALUE self) {
+  AGRubyObject *arg1 = (AGRubyObject *) 0 ;
+  AGBaseObject *arg2 = (AGBaseObject *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_AGRubyObject, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;AGRubyObject *&quot;,&quot;addRef&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; AGRubyObject * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &amp;argp2,SWIGTYPE_p_AGBaseObject, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( &quot;&quot;, &quot;AGBaseObject *&quot;,&quot;addRef&quot;, 2, argv[0] )); 
+  }
+  arg2 = reinterpret_cast&lt; AGBaseObject * &gt;(argp2);
+  (arg1)-&gt;addRef(arg2);
+  return Qnil;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3::AGRubyObject.deleteRef
+
+  call-seq:
+    deleteRef(AGBaseObject o)
+
+An instance method.
+
+*/
+SWIGINTERN VALUE
+_wrap_AGRubyObject_deleteRef(int argc, VALUE *argv, VALUE self) {
+  AGRubyObject *arg1 = (AGRubyObject *) 0 ;
+  AGBaseObject *arg2 = (AGBaseObject *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_AGRubyObject, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;AGRubyObject *&quot;,&quot;deleteRef&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; AGRubyObject * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(argv[0], &amp;argp2,SWIGTYPE_p_AGBaseObject, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( &quot;&quot;, &quot;AGBaseObject *&quot;,&quot;deleteRef&quot;, 2, argv[0] )); 
+  }
+  arg2 = reinterpret_cast&lt; AGBaseObject * &gt;(argp2);
+  (arg1)-&gt;deleteRef(arg2);
+  return Qnil;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN VALUE
+_wrap_disown_AGRubyObject(int argc, VALUE *argv, VALUE self) {
+  AGRubyObject *arg1 = (AGRubyObject *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &amp;argp1,SWIGTYPE_p_AGRubyObject, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;AGRubyObject *&quot;,&quot;disown_AGRubyObject&quot;, 1, argv[0] )); 
+  }
+  arg1 = reinterpret_cast&lt; AGRubyObject * &gt;(argp1);
+  {
+    Swig::Director *director = dynamic_cast&lt;Swig::Director *&gt;(arg1);
+    if (director) director-&gt;swig_disown();
+  }
+  
+  return Qnil;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3.getAddressOfRubyObject
+
+  call-seq:
+    getAddressOfRubyObject(AGRubyObject object) -&gt; void
+
+A module function.
+
+*/
+SWIGINTERN VALUE
+_wrap_getAddressOfRubyObject(int argc, VALUE *argv, VALUE self) {
+  AGRubyObject *arg1 = (AGRubyObject *) 0 ;
+  void *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &amp;argp1,SWIGTYPE_p_AGRubyObject, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;AGRubyObject *&quot;,&quot;getAddressOfRubyObject&quot;, 1, argv[0] )); 
+  }
+  arg1 = reinterpret_cast&lt; AGRubyObject * &gt;(argp1);
+  result = (void *)getAddressOfRubyObject(arg1);
+  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3.rubyObjectExists
+
+  call-seq:
+    rubyObjectExists(void o) -&gt; bool
+
+A module function.
+
+*/
+SWIGINTERN VALUE
+_wrap_rubyObjectExists(int argc, VALUE *argv, VALUE self) {
+  void *arg1 = (void *) 0 ;
+  bool result;
+  int res1 ;
+  VALUE vresult = Qnil;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0],SWIG_as_voidptrptr(&amp;arg1), 0, 0);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;void *&quot;,&quot;rubyObjectExists&quot;, 1, argv[0] )); 
+  }
+  result = (bool)rubyObjectExists(arg1);
+  vresult = SWIG_From_bool(static_cast&lt; bool &gt;(result));
+  return vresult;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-method: File3.setQuitting
+
+  call-seq:
+    setQuitting
+
+A module function.
+
+*/
+SWIGINTERN VALUE
+_wrap_setQuitting(int argc, VALUE *argv, VALUE self) {
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  setQuitting();
+  return Qnil;
+fail:
+  return Qnil;
+}
+
+
+
+/*
+  Document-class: File3::B &lt; File3::AGRubyObject
+
+  Proxy of C++ File3::B class
+
+
+*/
+swig_class cB;
+
+
+/*
+  Document-method: File3::B.x
+
+  call-seq:
+    x
+
+An instance method.
+
+*/
+SWIGINTERN VALUE
+_wrap_B_x(int argc, VALUE *argv, VALUE self) {
+  B *arg1 = (B *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  Swig::Director *director = 0;
+  bool upcall = false;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(self, &amp;argp1,SWIGTYPE_p_B, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;B *&quot;,&quot;x&quot;, 1, self )); 
+  }
+  arg1 = reinterpret_cast&lt; B * &gt;(argp1);
+  director = dynamic_cast&lt;Swig::Director *&gt;(arg1);
+  upcall = (director &amp;&amp; (director-&gt;swig_get_self() == self));
+  try {
+    if (upcall) {
+      (arg1)-&gt;B::x();
+    } else {
+      (arg1)-&gt;x();
+    }
+  } catch (Swig::DirectorException&amp; e) {
+    rb_exc_raise(e.getError());
+    SWIG_fail;
+  }
+  return Qnil;
+fail:
+  return Qnil;
+}
+
+
+#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
+SWIGINTERN VALUE
+_wrap_B_allocate(VALUE self) {
+#else
+  SWIGINTERN VALUE
+  _wrap_B_allocate(int argc, VALUE *argv, VALUE self) {
+#endif
+    
+    
+    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_B);
+#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
+    rb_obj_call_init(vresult, argc, argv);
+#endif
+    return vresult;
+  }
+  
+
+
+/*
+  Document-method: File3::B.new
+
+  call-seq:
+    B.new
+
+Class constructor.
+
+*/
+SWIGINTERN VALUE
+_wrap_new_B(int argc, VALUE *argv, VALUE self) {
+  VALUE arg1 = (VALUE) 0 ;
+  B *result = 0 ;
+  const char *classname SWIGUNUSED = &quot;File3::B&quot;;
+  
+  if ((argc &lt; 0) || (argc &gt; 0)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 0)&quot;,argc); SWIG_fail;
+  }
+  arg1 = self;
+  if ( strcmp(rb_obj_classname(self), classname) != 0 ) {
+    /* subclassed */
+    result = (B *)new SwigDirector_B(arg1); 
+  } else {
+    result = (B *)new B(); 
+  }
+  DATA_PTR(self) = result;
+  SWIG_RubyAddTracking(result, self);
+  
+  return self;
+fail:
+  return Qnil;
+}
+
+
+SWIGINTERN void
+free_B(B *arg1) {
+    SWIG_RubyRemoveTracking(arg1);
+    delete arg1;
+}
+
+SWIGINTERN VALUE
+_wrap_disown_B(int argc, VALUE *argv, VALUE self) {
+  B *arg1 = (B *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  
+  if ((argc &lt; 1) || (argc &gt; 1)) {
+    rb_raise(rb_eArgError, &quot;wrong # of arguments(%d for 1)&quot;,argc); SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &amp;argp1,SWIGTYPE_p_B, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( &quot;&quot;, &quot;B *&quot;,&quot;disown_B&quot;, 1, argv[0] )); 
+  }
+  arg1 = reinterpret_cast&lt; B * &gt;(argp1);
+  {
+    Swig::Director *director = dynamic_cast&lt;Swig::Director *&gt;(arg1);
+    if (director) director-&gt;swig_disown();
+  }
+  
+  return Qnil;
+fail:
+  return Qnil;
+}
+
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
+
+static void *_p_swig__IteratorTo_p_swig__ConstIterator(void *x, int *newmemory) {
+    return (void *)((swig::ConstIterator *)  ((swig::Iterator *) x));
+}
+static void *_p_BTo_p_AGRubyObject(void *x, int *newmemory) {
+    return (void *)((AGRubyObject *)  ((B *) x));
+}
+static swig_type_info _swigt__p_AGBaseObject = {&quot;_p_AGBaseObject&quot;, &quot;AGBaseObject *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_AGRubyObject = {&quot;_p_AGRubyObject&quot;, &quot;AGRubyObject *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_B = {&quot;_p_B&quot;, &quot;B *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_char = {&quot;_p_char&quot;, &quot;char *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p_void = {&quot;_p_p_void&quot;, &quot;void **|VALUE *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_swig__ConstIterator = {&quot;_p_swig__ConstIterator&quot;, &quot;swig::ConstIterator *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_swig__GC_VALUE = {&quot;_p_swig__GC_VALUE&quot;, &quot;swig::GC_VALUE *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_swig__Iterator = {&quot;_p_swig__Iterator&quot;, &quot;swig::Iterator *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_void = {&quot;_p_void&quot;, &quot;void *&quot;, 0, 0, (void*)0, 0};
+
+static swig_type_info *swig_type_initial[] = {
+  &amp;_swigt__p_AGBaseObject,
+  &amp;_swigt__p_AGRubyObject,
+  &amp;_swigt__p_B,
+  &amp;_swigt__p_char,
+  &amp;_swigt__p_p_void,
+  &amp;_swigt__p_swig__ConstIterator,
+  &amp;_swigt__p_swig__GC_VALUE,
+  &amp;_swigt__p_swig__Iterator,
+  &amp;_swigt__p_void,
+};
+
+static swig_cast_info _swigc__p_AGBaseObject[] = {  {&amp;_swigt__p_AGBaseObject, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_AGRubyObject[] = {  {&amp;_swigt__p_B, _p_BTo_p_AGRubyObject, 0, 0},  {&amp;_swigt__p_AGRubyObject, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_B[] = {  {&amp;_swigt__p_B, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_char[] = {  {&amp;_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_p_void[] = {  {&amp;_swigt__p_p_void, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_swig__ConstIterator[] = {  {&amp;_swigt__p_swig__ConstIterator, 0, 0, 0},  {&amp;_swigt__p_swig__Iterator, _p_swig__IteratorTo_p_swig__ConstIterator, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_swig__GC_VALUE[] = {  {&amp;_swigt__p_swig__GC_VALUE, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_swig__Iterator[] = {  {&amp;_swigt__p_swig__Iterator, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_void[] = {  {&amp;_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};
+
+static swig_cast_info *swig_cast_initial[] = {
+  _swigc__p_AGBaseObject,
+  _swigc__p_AGRubyObject,
+  _swigc__p_B,
+  _swigc__p_char,
+  _swigc__p_p_void,
+  _swigc__p_swig__ConstIterator,
+  _swigc__p_swig__GC_VALUE,
+  _swigc__p_swig__Iterator,
+  _swigc__p_void,
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
+
+/* -----------------------------------------------------------------------------
+ * Type initialization:
+ * This problem is tough by the requirement that no dynamic 
+ * memory is used. Also, since swig_type_info structures store pointers to 
+ * swig_cast_info structures and swig_cast_info structures store pointers back
+ * to swig_type_info structures, we need some lookup code at initialization. 
+ * The idea is that swig generates all the structures that are needed. 
+ * The runtime then collects these partially filled structures. 
+ * The SWIG_InitializeModule function takes these initial arrays out of 
+ * swig_module, and does all the lookup, filling in the swig_module.types
+ * array with the correct data and linking the correct swig_cast_info
+ * structures together.
+ *
+ * The generated swig_type_info structures are assigned staticly to an initial 
+ * array. We just loop through that array, and handle each type individually.
+ * First we lookup if this type has been already loaded, and if so, use the
+ * loaded structure instead of the generated one. Then we have to fill in the
+ * cast linked list. The cast data is initially stored in something like a
+ * two-dimensional array. Each row corresponds to a type (there are the same
+ * number of rows as there are in the swig_type_initial array). Each entry in
+ * a column is one of the swig_cast_info structures for that type.
+ * The cast_initial array is actually an array of arrays, because each row has
+ * a variable number of columns. So to actually build the cast linked list,
+ * we find the array of casts associated with the type, and loop through it 
+ * adding the casts to the list. The one last trick we need to do is making
+ * sure the type pointer in the swig_cast_info struct is correct.
+ *
+ * First off, we lookup the cast-&gt;type name to see if it is already loaded. 
+ * There are three cases to handle:
+ *  1) If the cast-&gt;type has already been loaded AND the type we are adding
+ *     casting info to has not been loaded (it is in this module), THEN we
+ *     replace the cast-&gt;type pointer with the type pointer that has already
+ *     been loaded.
+ *  2) If BOTH types (the one we are adding casting info to, and the 
+ *     cast-&gt;type) are loaded, THEN the cast info has already been loaded by
+ *     the previous module so we just ignore it.
+ *  3) Finally, if cast-&gt;type has not already been loaded, then we add that
+ *     swig_cast_info to the linked list (because the cast-&gt;type) pointer will
+ *     be correct.
+ * ----------------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#if 0
+} /* c-mode */
+#endif
+#endif
+
+#if 0
+#define SWIGRUNTIME_DEBUG
+#endif
+
+
+SWIGRUNTIME void
+SWIG_InitializeModule(void *clientdata) {
+  size_t i;
+  swig_module_info *module_head, *iter;
+  int found, init;
+
+  clientdata = clientdata;
+
+  /* check to see if the circular list has been setup, if not, set it up */
+  if (swig_module.next==0) {
+    /* Initialize the swig_module */
+    swig_module.type_initial = swig_type_initial;
+    swig_module.cast_initial = swig_cast_initial;
+    swig_module.next = &amp;swig_module;
+    init = 1;
+  } else {
+    init = 0;
+  }
+
+  /* Try and load any already created modules */
+  module_head = SWIG_GetModule(clientdata);
+  if (!module_head) {
+    /* This is the first module loaded for this interpreter */
+    /* so set the swig module into the interpreter */
+    SWIG_SetModule(clientdata, &amp;swig_module);
+    module_head = &amp;swig_module;
+  } else {
+    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
+    found=0;
+    iter=module_head;
+    do {
+      if (iter==&amp;swig_module) {
+        found=1;
+        break;
+      }
+      iter=iter-&gt;next;
+    } while (iter!= module_head);
+
+    /* if the is found in the list, then all is done and we may leave */
+    if (found) return;
+    /* otherwise we must add out module into the list */
+    swig_module.next = module_head-&gt;next;
+    module_head-&gt;next = &amp;swig_module;
+  }
+
+  /* When multiple interpeters are used, a module could have already been initialized in
+     a different interpreter, but not yet have a pointer in this interpreter.
+     In this case, we do not want to continue adding types... everything should be
+     set up already */
+  if (init == 0) return;
+
+  /* Now work on filling in swig_module.types */
+#ifdef SWIGRUNTIME_DEBUG
+  printf(&quot;SWIG_InitializeModule: size %d\n&quot;, swig_module.size);
+#endif
+  for (i = 0; i &lt; swig_module.size; ++i) {
+    swig_type_info *type = 0;
+    swig_type_info *ret;
+    swig_cast_info *cast;
+  
+#ifdef SWIGRUNTIME_DEBUG
+    printf(&quot;SWIG_InitializeModule: type %d %s\n&quot;, i, swig_module.type_initial[i]-&gt;name);
+#endif
+
+    /* if there is another module already loaded */
+    if (swig_module.next != &amp;swig_module) {
+      type = SWIG_MangledTypeQueryModule(swig_module.next, &amp;swig_module, swig_module.type_initial[i]-&gt;name);
+    }
+    if (type) {
+      /* Overwrite clientdata field */
+#ifdef SWIGRUNTIME_DEBUG
+      printf(&quot;SWIG_InitializeModule: found type %s\n&quot;, type-&gt;name);
+#endif
+      if (swig_module.type_initial[i]-&gt;clientdata) {
+	type-&gt;clientdata = swig_module.type_initial[i]-&gt;clientdata;
+#ifdef SWIGRUNTIME_DEBUG
+      printf(&quot;SWIG_InitializeModule: found and overwrite type %s \n&quot;, type-&gt;name);
+#endif
+      }
+    } else {
+      type = swig_module.type_initial[i];
+    }
+
+    /* Insert casting types */
+    cast = swig_module.cast_initial[i];
+    while (cast-&gt;type) {
+    
+      /* Don't need to add information already in the list */
+      ret = 0;
+#ifdef SWIGRUNTIME_DEBUG
+      printf(&quot;SWIG_InitializeModule: look cast %s\n&quot;, cast-&gt;type-&gt;name);
+#endif
+      if (swig_module.next != &amp;swig_module) {
+        ret = SWIG_MangledTypeQueryModule(swig_module.next, &amp;swig_module, cast-&gt;type-&gt;name);
+#ifdef SWIGRUNTIME_DEBUG
+	if (ret) printf(&quot;SWIG_InitializeModule: found cast %s\n&quot;, ret-&gt;name);
+#endif
+      }
+      if (ret) {
+	if (type == swig_module.type_initial[i]) {
+#ifdef SWIGRUNTIME_DEBUG
+	  printf(&quot;SWIG_InitializeModule: skip old type %s\n&quot;, ret-&gt;name);
+#endif
+	  cast-&gt;type = ret;
+	  ret = 0;
+	} else {
+	  /* Check for casting already in the list */
+	  swig_cast_info *ocast = SWIG_TypeCheck(ret-&gt;name, type);
+#ifdef SWIGRUNTIME_DEBUG
+	  if (ocast) printf(&quot;SWIG_InitializeModule: skip old cast %s\n&quot;, ret-&gt;name);
+#endif
+	  if (!ocast) ret = 0;
+	}
+      }
+
+      if (!ret) {
+#ifdef SWIGRUNTIME_DEBUG
+	printf(&quot;SWIG_InitializeModule: adding cast %s\n&quot;, cast-&gt;type-&gt;name);
+#endif
+        if (type-&gt;cast) {
+          type-&gt;cast-&gt;prev = cast;
+          cast-&gt;next = type-&gt;cast;
+        }
+        type-&gt;cast = cast;
+      }
+      cast++;
+    }
+    /* Set entry in modules-&gt;types array equal to the type */
+    swig_module.types[i] = type;
+  }
+  swig_module.types[i] = 0;
+
+#ifdef SWIGRUNTIME_DEBUG
+  printf(&quot;**** SWIG_InitializeModule: Cast List ******\n&quot;);
+  for (i = 0; i &lt; swig_module.size; ++i) {
+    int j = 0;
+    swig_cast_info *cast = swig_module.cast_initial[i];
+    printf(&quot;SWIG_InitializeModule: type %d %s\n&quot;, i, swig_module.type_initial[i]-&gt;name);
+    while (cast-&gt;type) {
+      printf(&quot;SWIG_InitializeModule: cast type %s\n&quot;, cast-&gt;type-&gt;name);
+      cast++;
+      ++j;
+    }
+  printf(&quot;---- Total casts: %d\n&quot;,j);
+  }
+  printf(&quot;**** SWIG_InitializeModule: Cast List ******\n&quot;);
+#endif
+}
+
+/* This function will propagate the clientdata field of type to
+* any new swig_type_info structures that have been added into the list
+* of equivalent types.  It is like calling
+* SWIG_TypeClientData(type, clientdata) a second time.
+*/
+SWIGRUNTIME void
+SWIG_PropagateClientData(void) {
+  size_t i;
+  swig_cast_info *equiv;
+  static int init_run = 0;
+
+  if (init_run) return;
+  init_run = 1;
+
+  for (i = 0; i &lt; swig_module.size; i++) {
+    if (swig_module.types[i]-&gt;clientdata) {
+      equiv = swig_module.types[i]-&gt;cast;
+      while (equiv) {
+        if (!equiv-&gt;converter) {
+          if (equiv-&gt;type &amp;&amp; !equiv-&gt;type-&gt;clientdata)
+            SWIG_TypeClientData(equiv-&gt;type, swig_module.types[i]-&gt;clientdata);
+        }
+        equiv = equiv-&gt;next;
+      }
+    }
+  }
+}
+
+#ifdef __cplusplus
+#if 0
+{ /* c-mode */
+#endif
+}
+#endif
+
+/*
+
+*/
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+SWIGEXPORT void Init_file3(void) {
+  size_t i;
+  
+  SWIG_InitRuntime();
+  mFile3 = rb_define_module(&quot;File3&quot;);
+  
+  SWIG_InitializeModule(0);
+  for (i = 0; i &lt; swig_module.size; i++) {
+    SWIG_define_class(swig_module.types[i]);
+  }
+  
+  SWIG_RubyInitializeTrackings();
+  
+  cGC_VALUE.klass = rb_define_class_under(mFile3, &quot;GC_VALUE&quot;, rb_cObject);
+  SWIG_TypeClientData(SWIGTYPE_p_swig__GC_VALUE, (void *) &amp;cGC_VALUE);
+  rb_undef_alloc_func(cGC_VALUE.klass);
+  rb_define_method(cGC_VALUE.klass, &quot;inspect&quot;, VALUEFUNC(_wrap_GC_VALUE_inspect), -1);
+  rb_define_method(cGC_VALUE.klass, &quot;to_s&quot;, VALUEFUNC(_wrap_GC_VALUE_to_s), -1);
+  cGC_VALUE.mark = 0;
+  cGC_VALUE.trackObjects = 0;
+  
+  swig::GC_VALUE::initialize();
+  
+  
+  cConstIterator.klass = rb_define_class_under(mFile3, &quot;ConstIterator&quot;, rb_cObject);
+  SWIG_TypeClientData(SWIGTYPE_p_swig__ConstIterator, (void *) &amp;cConstIterator);
+  rb_undef_alloc_func(cConstIterator.klass);
+  rb_define_method(cConstIterator.klass, &quot;value&quot;, VALUEFUNC(_wrap_ConstIterator_value), -1);
+  rb_define_method(cConstIterator.klass, &quot;dup&quot;, VALUEFUNC(_wrap_ConstIterator_dup), -1);
+  rb_define_method(cConstIterator.klass, &quot;inspect&quot;, VALUEFUNC(_wrap_ConstIterator_inspect), -1);
+  rb_define_method(cConstIterator.klass, &quot;to_s&quot;, VALUEFUNC(_wrap_ConstIterator_to_s), -1);
+  rb_define_method(cConstIterator.klass, &quot;next&quot;, VALUEFUNC(_wrap_ConstIterator_next), -1);
+  rb_define_method(cConstIterator.klass, &quot;previous&quot;, VALUEFUNC(_wrap_ConstIterator_previous), -1);
+  rb_define_method(cConstIterator.klass, &quot;==&quot;, VALUEFUNC(_wrap_ConstIterator___eq__), -1);
+  rb_define_method(cConstIterator.klass, &quot;+&quot;, VALUEFUNC(_wrap_ConstIterator___add__), -1);
+  rb_define_method(cConstIterator.klass, &quot;-&quot;, VALUEFUNC(_wrap_ConstIterator___sub__), -1);
+  cConstIterator.mark = 0;
+  cConstIterator.destroy = (void (*)(void *)) free_swig_ConstIterator;
+  cConstIterator.trackObjects = 0;
+  
+  cIterator.klass = rb_define_class_under(mFile3, &quot;Iterator&quot;, ((swig_class *) SWIGTYPE_p_swig__ConstIterator-&gt;clientdata)-&gt;klass);
+  SWIG_TypeClientData(SWIGTYPE_p_swig__Iterator, (void *) &amp;cIterator);
+  rb_undef_alloc_func(cIterator.klass);
+  rb_define_method(cIterator.klass, &quot;value=&quot;, VALUEFUNC(_wrap_Iterator_valuee___), -1);
+  rb_define_method(cIterator.klass, &quot;dup&quot;, VALUEFUNC(_wrap_Iterator_dup), -1);
+  rb_define_method(cIterator.klass, &quot;next&quot;, VALUEFUNC(_wrap_Iterator_next), -1);
+  rb_define_method(cIterator.klass, &quot;previous&quot;, VALUEFUNC(_wrap_Iterator_previous), -1);
+  rb_define_method(cIterator.klass, &quot;inspect&quot;, VALUEFUNC(_wrap_Iterator_inspect), -1);
+  rb_define_method(cIterator.klass, &quot;to_s&quot;, VALUEFUNC(_wrap_Iterator_to_s), -1);
+  rb_define_method(cIterator.klass, &quot;==&quot;, VALUEFUNC(_wrap_Iterator___eq__), -1);
+  rb_define_method(cIterator.klass, &quot;+&quot;, VALUEFUNC(_wrap_Iterator___add__), -1);
+  rb_define_method(cIterator.klass, &quot;-&quot;, VALUEFUNC(_wrap_Iterator___sub__), -1);
+  cIterator.mark = 0;
+  cIterator.destroy = (void (*)(void *)) free_swig_Iterator;
+  cIterator.trackObjects = 0;
+  
+  
+  
+  
+  SWIGTYPE_p_AGRubyObject-&gt;dcast = (swig_dycast_func) AGRubyObject_dynamic_cast;
+  
+  
+  cAGBaseObject.klass = rb_define_class_under(mFile3, &quot;AGBaseObject&quot;, rb_cObject);
+  SWIG_TypeClientData(SWIGTYPE_p_AGBaseObject, (void *) &amp;cAGBaseObject);
+  rb_define_alloc_func(cAGBaseObject.klass, _wrap_AGBaseObject_allocate);
+  rb_define_method(cAGBaseObject.klass, &quot;initialize&quot;, VALUEFUNC(_wrap_new_AGBaseObject), -1);
+  rb_define_method(cAGBaseObject.klass, &quot;baseClear&quot;, VALUEFUNC(_wrap_AGBaseObject_baseClear), -1);
+  rb_define_method(cAGBaseObject.klass, &quot;valid&quot;, VALUEFUNC(_wrap_AGBaseObject_valid), -1);
+  cAGBaseObject.mark = 0;
+  cAGBaseObject.destroy = (void (*)(void *)) free_AGBaseObject;
+  cAGBaseObject.trackObjects = 1;
+  rb_define_module_function(mFile3, &quot;general_markfunc&quot;, VALUEFUNC(_wrap_general_markfunc), -1);
+  rb_define_module_function(mFile3, &quot;saveDelete&quot;, VALUEFUNC(_wrap_saveDelete), -1);
+  rb_define_module_function(mFile3, &quot;disown_AGRubyObject&quot;, VALUEFUNC(_wrap_disown_AGRubyObject), -1);
+  
+  cAGRubyObject.klass = rb_define_class_under(mFile3, &quot;AGRubyObject&quot;, rb_cObject);
+  SWIG_TypeClientData(SWIGTYPE_p_AGRubyObject, (void *) &amp;cAGRubyObject);
+  rb_define_alloc_func(cAGRubyObject.klass, _wrap_AGRubyObject_allocate);
+  rb_define_method(cAGRubyObject.klass, &quot;initialize&quot;, VALUEFUNC(_wrap_new_AGRubyObject), -1);
+  rb_define_method(cAGRubyObject.klass, &quot;addRef&quot;, VALUEFUNC(_wrap_AGRubyObject_addRef), -1);
+  rb_define_method(cAGRubyObject.klass, &quot;deleteRef&quot;, VALUEFUNC(_wrap_AGRubyObject_deleteRef), -1);
+  cAGRubyObject.mark = (void (*)(void *)) general_markfunc;
+  cAGRubyObject.destroy = (void (*)(void *)) free_AGRubyObject;
+  cAGRubyObject.trackObjects = 1;
+  rb_define_module_function(mFile3, &quot;getAddressOfRubyObject&quot;, VALUEFUNC(_wrap_getAddressOfRubyObject), -1);
+  rb_define_module_function(mFile3, &quot;rubyObjectExists&quot;, VALUEFUNC(_wrap_rubyObjectExists), -1);
+  rb_define_module_function(mFile3, &quot;setQuitting&quot;, VALUEFUNC(_wrap_setQuitting), -1);
+  rb_define_module_function(mFile3, &quot;disown_B&quot;, VALUEFUNC(_wrap_disown_B), -1);
+  
+  cB.klass = rb_define_class_under(mFile3, &quot;B&quot;, ((swig_class *) SWIGTYPE_p_AGRubyObject-&gt;clientdata)-&gt;klass);
+  SWIG_TypeClientData(SWIGTYPE_p_B, (void *) &amp;cB);
+  rb_define_alloc_func(cB.klass, _wrap_B_allocate);
+  rb_define_method(cB.klass, &quot;initialize&quot;, VALUEFUNC(_wrap_new_B), -1);
+  rb_define_method(cB.klass, &quot;x&quot;, VALUEFUNC(_wrap_B_x), -1);
+  cB.mark = (void (*)(void *)) general_markfunc;
+  cB.destroy = (void (*)(void *)) free_B;
+  cB.trackObjects = 1;
+}
+


Property changes on: antargis/trunk/rookey/spec/file3_swig.cc
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/rookey/spec/file3_swig.h
===================================================================
--- antargis/trunk/rookey/spec/file3_swig.h	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/spec/file3_swig.h	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,36 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (<A HREF="http://www.swig.org">http://www.swig.org</A>).
+ * Version 1.3.34
+ * 
+ * This file is not intended to be easily readable and contains a number of 
+ * coding conventions designed to improve portability and efficiency. Do not make
+ * changes to this file unless you know what you are doing--modify the SWIG 
+ * interface file instead. 
+ * ----------------------------------------------------------------------------- */
+
+#ifndef SWIG_File3_WRAP_H_
+#define SWIG_File3_WRAP_H_
+
+namespace Swig {
+  class Director;
+}
+
+
+class SwigDirector_AGRubyObject : public AGRubyObject, public Swig::Director {
+
+public:
+    SwigDirector_AGRubyObject(VALUE self);
+    virtual ~SwigDirector_AGRubyObject();
+};
+
+
+class SwigDirector_B : public B, public Swig::Director {
+
+public:
+    SwigDirector_B(VALUE self);
+    virtual ~SwigDirector_B();
+    virtual void x();
+};
+
+
+#endif


Property changes on: antargis/trunk/rookey/spec/file3_swig.h
___________________________________________________________________
Name: svn:mime-type
   + text/plain

Added: antargis/trunk/rookey/spec/my_vector.i
===================================================================
--- antargis/trunk/rookey/spec/my_vector.i	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/spec/my_vector.i	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1 @@
+%template(APVector) std::vector&lt;A*&gt;;
\ No newline at end of file

Added: antargis/trunk/rookey/spec/rookey_configuration.rb
===================================================================
--- antargis/trunk/rookey/spec/rookey_configuration.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/spec/rookey_configuration.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,3 @@
+ROOKEY_CONFIG={
+
+}

Modified: antargis/trunk/rookey/spec/spec_rookey.rb
===================================================================
--- antargis/trunk/rookey/spec/spec_rookey.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/spec/spec_rookey.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -63,6 +63,16 @@
     
     rakefile.clean
   end
+  it &quot;should generate dyn-casts within containers (vectors e.g.), too&quot; do
+    rakefile=rake do
+      dll=link_dll(compile(swig([&quot;a.h&quot;,&quot;d.h&quot;,&quot;my_vector.i&quot;])))
+    end
+    rakefile.default
+    ruby do
+      require(dll)
+      
+    end
+  end
 end
 
 

Deleted: antargis/trunk/rookey/spec/test
===================================================================
(Binary files differ)

Added: antargis/trunk/rookey/swig/swig_dyn_cast_containers.i
===================================================================
--- antargis/trunk/rookey/swig/swig_dyn_cast_containers.i	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/swig/swig_dyn_cast_containers.i	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,20 @@
+%{
+namespace swig
+{
+  /*
+    Traits that provides the from method for an unknown type
+  */
+  template &lt;int flags, class Type&gt; struct traits_from_ptr {
+    static SWIG_Object from SWIG_FROM_DECL_ARGS(Type *val) {
+    
+      // insert Dynamic_cast(...)
+      swig_type_info *info=type_info&lt;Type&gt;();
+      swig_type_info *ninfo=SWIG_TypeDynamicCast(info,val);
+      if(ninfo==0)
+        ninfo=info;
+    
+      return SWIG_NewPointerObj(val, ninfo, flags);
+    }
+  };
+}
+%}
\ No newline at end of file


Property changes on: antargis/trunk/rookey/swig/swig_dyn_cast_containers.i
___________________________________________________________________
Name: svn:executable
   + *

Modified: antargis/trunk/rookey/swig_interface_builder.rb
===================================================================
--- antargis/trunk/rookey/swig_interface_builder.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/swig_interface_builder.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -77,6 +77,34 @@
       
     end
     
+    # include dyn-casts for template-containers like std::vector&lt;SceneNode*&gt;
+    # this is missing in the dyncast-implementation of swig (at the time of 1.3.34)
+    def dynFroms
+      str=&quot;&quot;
+      str&lt;&lt;&quot;%wrapper %{&quot;
+      str&lt;&lt; &quot;namespace swig{&quot;
+      getClasses.each{|c|
+        name=c.name
+        str &lt;&lt; &quot;
+        template &lt;&gt; struct traits_from_ptr&lt;#{name}&gt; {
+          static VALUE from (#{name} *val,int owner=0) {
+          
+            // insert Dynamic_cast(...)
+            swig_type_info *info=SWIGTYPE_p_#{name}; //type_info&lt;#{name}&gt;();
+            swig_type_info *ninfo=SWIG_TypeDynamicCast(info,(void**)&amp;val);
+            if(ninfo==0)
+              ninfo=info;
+          
+            return SWIG_NewPointerObj(val, ninfo, owner);
+          }
+        };        
+        &quot;
+      }
+      str&lt;&lt;&quot;}&quot;
+      str&lt;&lt;&quot;%}&quot;
+      str
+    end
+    
     def generate
 
 &quot;%module(directors=\&quot;1\&quot;) #{@moduleName}
@@ -89,12 +117,13 @@
 #{headerIncludes}
 %}
 
+#{dynFroms}
+
 #{directors}
 #{markers}
 %{
 #{cpp2RubyFunctions}
 %}
-#{templates}
 
 %{
 #{initDefs}
@@ -108,6 +137,8 @@
 
 #{dynamicCasts}
 
+#{templates}
+
 %feature(\&quot;trackobjects\&quot;);
 
 #{headerSwigIncludes}      

Modified: antargis/trunk/rookey/tasks.rb
===================================================================
--- antargis/trunk/rookey/tasks.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/rookey/tasks.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -1,7 +1,13 @@
-
+require 'rake/clean.rb'
 require File.join(File.split(__FILE__)[0],'rookey.rb')
 require File.join(File.split(__FILE__)[0],'swig.rb')
 require File.join(File.split(__FILE__)[0],'compile.rb')
+
+
+require File.join(File.split(__FILE__)[0],'rookey_config.rb')
+Rookey::Configure.load
+Rookey::Configure.cleanTask
+
 require File.join(File.split(__FILE__)[0],'config_generator.rb')
 require File.join(File.split(__FILE__)[0],'cpp_hierarchy_parser.rb')
 require File.join(File.split(__FILE__)[0],'swig_interface_builder.rb')

Modified: antargis/trunk/ruby/entities/entity.rb
===================================================================
--- antargis/trunk/ruby/entities/entity.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/ruby/entities/entity.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -257,7 +257,11 @@
 		if sym
 			t=sym
 		end
-		super(mesh=AntModels.createModel(self,t,subtype))
+    mesh=AntModels.createModel(self,t,subtype)
+    #print &quot;MESH for #{self}:#{mesh} &quot;
+    #pp mesh
+		super(mesh)
+    #pp getMesh.class,getMesh
 		setupRing
 		return mesh
 	end

Modified: antargis/trunk/ruby/jobs/ant_hljob_states.rb
===================================================================
--- antargis/trunk/ruby/jobs/ant_hljob_states.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/ruby/jobs/ant_hljob_states.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -228,7 +228,7 @@
 		if getMap.path
 			@waypoints=[hero.getPos2D]+getMap.path.computePath(hero.getPos2D,targetPos,hero)+[targetPos]
 			# remove waypoints in between - if they're not necessary - origin must be given, too
-			@waypoints=getMap.path.refinePath(@waypoints,hero)
+			@waypoints=getMap.path.refinePath(@waypoints,hero).dup
 			# remove origin for waypoint-list
 			assert{@waypoints.length&gt;=2}
 			@waypoints.shift

Modified: antargis/trunk/ruby/spec/spec_code_check.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_code_check.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/ruby/spec/spec_code_check.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -1,7 +1,8 @@
 describe &quot;The source code&quot; do
   it &quot;should have no mentioning of rant or Rantfile&quot; do
     extensions=[&quot;rb&quot;,&quot;cc&quot;,&quot;c&quot;,&quot;h&quot;]
-    (extensions.map{|e|Dir[&quot;**/*.&quot;+e]}+Dir[&quot;**/README&quot;]).flatten.select{|filename|not filename=~/spec/}.each{|filename|
+    okdirs=[&quot;ruby&quot;,&quot;ext&quot;,&quot;starter&quot;]
+    (extensions.map{|e|Dir[&quot;**/*.&quot;+e]}+Dir[&quot;**/README&quot;]).flatten.select{|filename|okdirs.inject(true){|a,b|a and filename=~/^#{b}/} and not filename=~/spec/}.each{|filename|
       file=File.open(filename)
       content=file.read
       file.close

Modified: antargis/trunk/ruby/spec/spec_gui.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_gui.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/ruby/spec/spec_gui.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -8,7 +8,10 @@
     @app.setMainWidget(widget)
     @app.step
     key('a')
-    while true; @app.run;end
+    widget.getText.to_s.should == &quot;a&quot;
+    #&quot;it should work&quot;.should == &quot;&quot;
+    
+    #while true; @app.run;end
   end
 end
 

Modified: antargis/trunk/ruby/spec/spec_hljobs.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_hljobs.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/ruby/spec/spec_hljobs.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -19,11 +19,36 @@
 	it &quot;should use only limited count of ll-jobs&quot;
 end
 
+describe &quot;Recruit job&quot; do
+  include LevelTesting
+  before(:each) do
+    getTestApp(:tutorial0)
+  end
+  it &quot;should let hero near the target before starting to recruit&quot; do
+    advance
+    clickAwayStory
+    rowen=hero(&quot;Rowen&quot;)
+    rowen.newHLMoveJob(0,rowen.getPos2D+AGVector2.new(7,7),0)
+    while rowen.getJob.is_a?(AntHeroMoveJob)
+      advance
+    end
+    keep=building(&quot;Keep&quot;)
+    rowen.newHLRecruitJob(keep)
+    (rowen.getPos2D-keep.getPos2D).length.should &gt;12
+    
+    while rowen.getJob.stateName==:moveComplete
+      advance
+    end
+    (rowen.getPos2D-keep.getPos2D).length.should &lt;6
+    
+  end
+end  
+
 describe &quot;Recruit job - run through&quot; do
   include LevelTesting
   before(:all) do
     getTestApp(:tutorial0)
-	@store=Store.new
+	  @store=Store.new
   end
   it &quot;should start off with hero with no men&quot; do
   	advance
@@ -32,8 +57,8 @@
   end
   it &quot;starting recruit-job should work&quot; do
   	rowen=hero(&quot;Rowen&quot;)
-	rowen.newHLRecruitJob(building(&quot;Keep&quot;))
-	rowen.getJob.should be_a_kind_of(AntHeroRecruitJob)
+		rowen.newHLRecruitJob(building(&quot;Keep&quot;))
+		rowen.getJob.should be_a_kind_of(AntHeroRecruitJob)
   end
 
   it &quot;should then send hero to tower (at most 10 low-level move-jobs for format and move)&quot; do
@@ -42,7 +67,7 @@
 
   	# format
     while rowen.getJob.stateName==:moveComplete
-	  advance
+		  advance
     end
 	
 		rowen.getJobName.should ==&quot;moveJob&quot;
@@ -56,27 +81,28 @@
 		rowen.getJobName.should == &quot;moveJob&quot;
 		rowen.getTarget.should be_nil
 		trials=0
-	while rowen.getJobName==&quot;moveJob&quot;
-        runUntilLowLevelJobToFinish(rowen)
-		trials+=1
-		raise &quot;too many trials&quot; if trials&gt;10
-	end
-	(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">rowen.getPos2D- at store</A>[:oldPos]).length.should &lt; 0.1
+		while rowen.getJobName==&quot;moveJob&quot;
+      runUntilLowLevelJobToFinish(rowen)
+			trials+=1
+			raise &quot;too many trials&quot; if trials&gt;10
+		end
+		(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">rowen.getPos2D- at store</A>[:oldPos]).length.should &lt; 0.1
   end
   it &quot;all men should stand at the sitting-position when job is finished&quot; do
   	while rowen.getJob.stateName == :recruit
   		advance
-	end
+	 end
  
 	
-	clickAwayStory
-	rowen.getJob.should_not be_a_kind_of(AntHeroRecruitJob)
-	rowen.formation.should be_a_kind_of(AntFormationRest)
-	rowen.getMen.each{|man|
-		(man.getPos2D-rowen.getFormation(man,rowen.getPos2D)).length.should &lt; 0.1
-	}
+		clickAwayStory
+		rowen.getJob.should_not be_a_kind_of(AntHeroRecruitJob)
+		rowen.formation.should be_a_kind_of(AntFormationRest)
+		rowen.getMen.each{|man|
+			(man.getPos2D-rowen.getFormation(man,rowen.getPos2D)).length.should &lt; 0.1
+		}
   end
   
+  
   def rowen
   	hero(&quot;Rowen&quot;)
   end

Added: antargis/trunk/ruby/spec/spec_local.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_local.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/ruby/spec/spec_local.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,8 @@
+require &quot;ruby/spec/level_testing.rb&quot;
+
+describe &quot;Localizer&quot; do
+  it &quot;should work in Ruby&quot; do
+    _(&quot;Quit&quot;).should == &quot;Beenden&quot; if getLanguage==&quot;de_DE&quot;
+  end
+  it &quot;a ruby one should work in C++,too&quot;
+end

Added: antargis/trunk/ruby/spec/spec_swig.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_swig.rb	2008-03-28 16:59:36 UTC (rev 1237)
+++ antargis/trunk/ruby/spec/spec_swig.rb	2008-04-08 18:02:03 UTC (rev 1238)
@@ -0,0 +1,20 @@
+require 'ruby/spec/level_testing.rb'
+
+
+describe &quot;swig-mapping&quot; do
+  include LevelTesting
+  it &quot;should work correctly on meshlists&quot; do
+    getTestApp(:tutorial0)
+#    map=AntRubyMap.new
+    tower=AntTower.new(map)
+    puts &quot;::GETMESH&quot;
+    l=tower.getMesh
+    l.should be_an_instance_of(Array)
+    l.length.should == 3
+    l.each{|node|
+      #pp node,node.class,node.class.ancestors
+      node.should_not be_an_instance_of(SceneNode)
+      node.should be_a_kind_of(SceneNode)
+    }
+  end
+end
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000195.html">[Antargis-svn] r1239 - in antargis/trunk: . data/gui/layout	data/gui/layout/editor data/gui/layout/editor/campaign dev	dev/3dengine_v2 ext/basic ext/gui ext/math ext/video rookey	rookey/configs rookey/cpp rookey/spec/.deps ruby/editor	ruby/editor/campaign
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#194">[ date ]</a>
              <a href="thread.html#194">[ thread ]</a>
              <a href="subject.html#194">[ subject ]</a>
              <a href="author.html#194">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/antargis-svn">More information about the Antargis-svn
mailing list</a><br>
</body></html>
