From davidkamphausen at mail.berlios.de  Wed May  2 20:18:17 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Wed, 2 May 2007 20:18:17 +0200
Subject: [Antargis-svn] r1080 - in antargis/branches/branch_2d: .
	data/textures data/textures/2d ruby src
Message-ID: <200705021818.l42IIHP1024715@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-02 20:18:15 +0200 (Wed, 02 May 2007)
New Revision: 1080

Added:
   antargis/branches/branch_2d/data/textures/2d/
   antargis/branches/branch_2d/data/textures/2d/terrain/
Modified:
   antargis/branches/branch_2d/Rakefile
   antargis/branches/branch_2d/ruby/ant_arrow.rb
   antargis/branches/branch_2d/ruby/ant_bakery.rb
   antargis/branches/branch_2d/ruby/ant_boat.rb
   antargis/branches/branch_2d/ruby/ant_buildingsite.rb
   antargis/branches/branch_2d/ruby/ant_decal.rb
   antargis/branches/branch_2d/ruby/ant_deco.rb
   antargis/branches/branch_2d/ruby/ant_druid.rb
   antargis/branches/branch_2d/ruby/ant_dwelling.rb
   antargis/branches/branch_2d/ruby/ant_farm.rb
   antargis/branches/branch_2d/ruby/ant_field.rb
   antargis/branches/branch_2d/ruby/ant_fir.rb
   antargis/branches/branch_2d/ruby/ant_fire.rb
   antargis/branches/branch_2d/ruby/ant_fish.rb
   antargis/branches/branch_2d/ruby/ant_fishing_hut.rb
   antargis/branches/branch_2d/ruby/ant_grass.rb
   antargis/branches/branch_2d/ruby/ant_hero.rb
   antargis/branches/branch_2d/ruby/ant_man.rb
   antargis/branches/branch_2d/ruby/ant_mill.rb
   antargis/branches/branch_2d/ruby/ant_mine.rb
   antargis/branches/branch_2d/ruby/ant_models.rb
   antargis/branches/branch_2d/ruby/ant_sack.rb
   antargis/branches/branch_2d/ruby/ant_sheep.rb
   antargis/branches/branch_2d/ruby/ant_stone.rb
   antargis/branches/branch_2d/ruby/ant_tower.rb
   antargis/branches/branch_2d/ruby/ant_townhall.rb
   antargis/branches/branch_2d/ruby/ant_tree.rb
   antargis/branches/branch_2d/ruby/ant_well.rb
   antargis/branches/branch_2d/ruby/ant_wolf.rb
   antargis/branches/branch_2d/ruby/ant_workshop.rb
   antargis/branches/branch_2d/ruby/ents.rb
   antargis/branches/branch_2d/src/antargisgui.h
   antargis/branches/branch_2d/src/impostor.cc
   antargis/branches/branch_2d/src/impostor.h
   antargis/branches/branch_2d/src/nantmarker.hh
Log:
* setMesh(type,subtype) => setMesh(<subtype>)


Modified: antargis/branches/branch_2d/Rakefile
===================================================================
--- antargis/branches/branch_2d/Rakefile	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/Rakefile	2007-05-02 18:18:15 UTC (rev 1080)
@@ -33,7 +33,7 @@
 
 
 interfaceHeadersSRC=["ant_frustum.h","ant_projection.h","ant_camera.h",
-"scenenode.h","anim_mesh.h","anim_mesh_data.h","ant_app.h","entity.h","entptr.h","glsl.h","height_map.h","map.h","mesh_data.h","mesh.h","mesh_optimizer.h","minimap.h","new_decal.h","ant_renderer.h","resource.h","scene_base.h","scene.h","smoke.h","terrain.h","vertex_array.h","water.h","path.h","impostor.h"]
+"scenenode.h","anim_mesh.h","anim_mesh_data.h","ant_app.h","entity.h","entptr.h","glsl.h","height_map.h","map.h","mesh_data.h","mesh.h","mesh_2d_data.h","mesh_2d.h","mesh_optimizer.h","minimap.h","new_decal.h","ant_renderer.h","resource.h","scene_base.h","scene.h","scene_2d.h","smoke.h","terrain.h","vertex_array.h","water.h","path.h","impostor.h"]
 interfaceHeadersGUI=[
 "ag_rubyobj.h","ag_messageobject.h","ag_serial.h","ag_aes.h","ag_singleton.h",
  "ag_geometry.h","ag_font.h","ag_color.h","ag_local.h","ag_config.h","ag_string.h","ag_string_utf8.h",

Modified: antargis/branches/branch_2d/ruby/ant_arrow.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_arrow.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_arrow.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -26,8 +26,7 @@
 	def initialize
 		super(AGVector2.new(0,0))
 		@typeID=(getRand*2).to_i
-		setMesh(createModel(:arrow))
-# 		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/arrow.ant2",0.1,"data/textures/models/arrow.png"),AGVector4.new(0,0,0,0),getRand*360))
+		setMesh
 		setSpeed(10)
 	end
 	def eventNoJob

Modified: antargis/branches/branch_2d/ruby/ant_bakery.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_bakery.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_bakery.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -13,10 +13,7 @@
 	end
 	
 	def setupMesh
-		setMesh(createModel(:bakery))
-		#		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/ant_bakery.ant2",3.2,"data/textures/models/ant_bakery.png"),AGVector4.new(0,0,0),-30)
-		#mesh=Mesh.new(getMap.getScene,getMeshData("data/models/townhall.ant2",3.2,"data/textures/models/townhall.png"),AGVector4.new(0,0,0),-30)
-		#setMesh(mesh)
+		setMesh
 		p=AGVector3.new(0,1.6,2.2)
 		addMesh(@smokeMesh=Smoke.new(getMap.getScene,5),p)
 		checkSmoke

Modified: antargis/branches/branch_2d/ruby/ant_boat.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_boat.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_boat.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -10,8 +10,6 @@
 	end
 private
 	def setupMesh
-# 		mesh=Mesh.new(getMap.getScene,getBoatMeshData,AGVector4.new(0,0,0),0)
-# 		setMesh(mesh)
-		setMesh(createModel(:boat))
+		setMesh
 	end
 end
\ No newline at end of file

Modified: antargis/branches/branch_2d/ruby/ant_buildingsite.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_buildingsite.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_buildingsite.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -13,14 +13,14 @@
 	def incProgress(steps)
 		@steps=steps
 		o=@progress.to_i
-		@progress+=(1.0/steps)*getMeshCount(:buildingsite) #(@@buildingSiteMeshes.length-1)
+		@progress+=(1.0/steps)*AntModels.getMeshCount(:buildingsite)
 		if o!=@progress.to_i
 			setupMesh
 		end
 		@doneSth=true
 	end
 	def ready
-		@progress>getMeshCount(:buildingsite) #@@buildingSiteMeshes.length-1
+		@progress>AntModels.getMeshCount(:buildingsite) #@@buildingSiteMeshes.length-1
 	end
 
 	# removes building site if nothing was done in some time
@@ -46,7 +46,7 @@
 
 	private
 	def setupMesh
-		setMesh(createModel(:buildingsite, at progress.to_i))
+		setMesh(@progress.to_i)
 		
 # 		mesh=Mesh.new(getMap.getScene,AntBuildingSite.getBuildingSiteMeshData(@progress),AGVector4.new(0,0,0),-10)
 # 		setMesh(mesh)

Modified: antargis/branches/branch_2d/ruby/ant_decal.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_decal.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_decal.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -23,8 +23,7 @@
 		super(AGVector2.new(0,0))
 		@typeID=(getRand()*2).to_i
 		setProvide("decal",true)
-# 		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/floor.ant2",0.8,"data/textures/gravel4.png",false),AGVector4.new(0,0,0,0),0))	
-		setMesh(createModel(:floor_gravel))
+		setMesh(:floor_gravel)
 	end
 	def setTreeType(t)
 		@typeID=t

Modified: antargis/branches/branch_2d/ruby/ant_deco.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_deco.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_deco.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -43,7 +43,7 @@
 			@decoType=a[r]
 		end
 		setProvide("deco",true)
-		setMesh(createModel(:floor_deco))
+		setMesh(:floor_deco)
 		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/floor.ant2",0.5,"data/textures/splats/stones1a.png",false),AGVector4.new(0,0,0,0),0))
 	end
 	def setDecoType(t)
@@ -66,7 +66,7 @@
 		@typeID=(getRand()*2).to_i
 		#setType("twig")
 		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/twig.ant2",0.7),AGVector4.new(0,0,0,0),getRand*360))
-		setMesh(mesh=createModel(:twig))
+		mesh=setMesh
 		mesh.setRotation(getRand*360)
 	end
 end

Modified: antargis/branches/branch_2d/ruby/ant_druid.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_druid.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_druid.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -23,10 +23,10 @@
 	def setupMesh
 		case @npcType
 			when "smith"
-				setMesh(createModel(:smith))
+				setMesh(:smith)
 	 			#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/smith_lp.ant2",0.08,"data/textures/models/smith_lp.png"),AGVector4.new(0,0,0,0),0))
 			else
-				setMesh(createModel(:druid))
+				setMesh(:druid)
 	 			#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/druid_lp.ant2",0.08,"data/textures/models/druid_lp.png"),AGVector4.new(0,0,0,0),0))
 		end
 	end

Modified: antargis/branches/branch_2d/ruby/ant_dwelling.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_dwelling.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_dwelling.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -18,9 +18,7 @@
 
 	# setup the mesh
 	def setupMesh
-		setMesh(createModel(:dwelling))
-# 		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/livinghouse.ant2",0.16,"data/textures/models/livinghouse.png"),AGVector4.new(0,0,0),-20)
-# 		setMesh(mesh)
+		setMesh
 	end
 
 protected

Modified: antargis/branches/branch_2d/ruby/ant_farm.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_farm.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_farm.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -35,7 +35,7 @@
 	end
 	
 	def setupMesh
-		setMesh(createModel(:farm))
+		setMesh
 	end
 
 	def neededStock

Modified: antargis/branches/branch_2d/ruby/ant_field.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_field.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_field.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -5,7 +5,7 @@
 		setProvide("field",true)
 		@size=0
 		#init fieldMeshes-var
-		@max=getMeshCount(:field)-1
+		@max=AntModels.getMeshCount(:field)-1
 		setupMesh
 		@growTime=20
 		@begin=true
@@ -37,6 +37,6 @@
 	
 	private
 	def setupMesh
-		setMesh(createModel(:field, at size))		
+		setMesh(@size)
 	end
 end

Modified: antargis/branches/branch_2d/ruby/ant_fir.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_fir.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_fir.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -67,7 +67,7 @@
 # 		else
 # 			data=getMeshData("data/models/fir2.ant2",0.45,"data/textures/models/fir7.png")
 		end
-		setMesh(createModel(:tree,typeId))
+		setMesh(typeId,:tree)
 		#data.setTransparent(true)
 		#data.setCulling(false) # patch for old trees
 

Modified: antargis/branches/branch_2d/ruby/ant_fire.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_fire.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_fire.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -2,7 +2,7 @@
 	def initialize(p=AGVector2.new(0,0))
 		super
 		mp=AGVector3.new(0,0,0)
-		setMesh(createModel(:fire,:on))
+		setMesh(:on)
 # 		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/fire.ant2",0.3,"data/textures/models/fire.png"),AGVector4.new(0,0,0),0)
 # 		setMesh(mesh)
 		@smokeMesh=Smoke.new(getMap.getScene,4)
@@ -15,7 +15,7 @@
 		@enabled=true
 	end
 	def disable
-		setMesh(createModel(:fire,:off))
+		setMesh(:off)
 		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/fire.ant2",0.3,"data/textures/models/fire2.png"),AGVector4.new(0,0,0),0))
 		getMap.getScene.addNode(@smokeMesh) # FIXME: dirty hack - solve this another way!!!
 		addMesh(@smokeMesh,AGVector3.new(0,0,0))

Modified: antargis/branches/branch_2d/ruby/ant_fish.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_fish.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_fish.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -35,7 +35,7 @@
 
 		puts "FISH:#{getPos3D}"
 		
-		setMesh(createModel(:fish))
+		setMesh
 		#mesh=Mesh.new(getMap.getScene,getFishMeshData,AGVector4.new(0,0,0),0)
 		#setMesh(mesh)
 

Modified: antargis/branches/branch_2d/ruby/ant_fishing_hut.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_fishing_hut.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_fishing_hut.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -11,7 +11,7 @@
 	end
 	
 	def setupMesh
-		setMesh(createModel(:fishing_hut))
+		setMesh
 # 
 # 
 # 		data=getMeshData("data/models/fishing_hut.ant2",3.2,"data/textures/models/fishing_hut.png")

Modified: antargis/branches/branch_2d/ruby/ant_grass.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_grass.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_grass.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -222,3 +222,5 @@
 		setMesh(makeBushMesh(@size*3))
 	end
 end
+
+

Modified: antargis/branches/branch_2d/ruby/ant_hero.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_hero.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_hero.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -263,16 +263,12 @@
 		dir=getDirection
 		case name
 			when "row"
-		 		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/hero_lp.ant2",0.08,"data/textures/models/hero_lp.png"),AGVector4.new(0,0,0,0),0))
-				#setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_e_walk.anim")))
-				#getFirstMesh.setAnimation("sit")
-				mesh=Mesh.new(getMap.getScene,getBoatMeshData,AGVector4.new(0,0,0),0)
-				addMesh(mesh,AGVector3.new(0,0,0))
-
+				setMesh
+				addMesh(createModel(:boat),AGVector3.new(0,0,0))
 			when "dead"
-		 		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/grave.ant2",0.2,"data/textures/models/grave3.png"),AGVector4.new(0,0,0,0),0))
+				setMesh(:grave_hero)
 			else
-		 		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/hero_lp.ant2",0.08,"data/textures/models/hero_lp.png"),AGVector4.new(0,0,0,0),0))
+				setMesh
 		end
 		setDirection(dir)
 		setupRing

Modified: antargis/branches/branch_2d/ruby/ant_man.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_man.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_man.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -238,50 +238,27 @@
 		@meshState=name
 		dir=getDirection
 		case name
-			when "wood"
-				setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_wood.anim")))
-				setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_e_wood.anim")))
-			when "stone","flour","corn"
-				setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_stones.anim")))
-				setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_e_stones.anim")))
-			when "walk","sitdown","sit"
-				setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_walk.anim")))
-				setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_e_walk.anim")))
-				getFirstMesh.setAnimation(name)
 			when "fight"
 				if @moving
-					# FIXME: fill in man_e_dagger ...
-					setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_e_walk.anim")))
+					setMesh("walk")
 					getFirstMesh.setAnimation("walk")
 				else
-					case getWeapon
-						when "dagger"
-							setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_e_dagger.anim")))
-						when "shield"
-							setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_e_shield.anim")))
-						when "sword"
-							setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_e_sword.anim")))
-						when "bow"
-							setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_e_bow.anim")))
-					end
-					#end
+					#	raise 1
+					puts "name:#{name}"
+					assert{["dagger","shield","sword","bow"].member?(getWeapon)}
+					setMesh("fight_"+getWeapon)
 				end
-			when "axe"
-				setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_axe.anim")))
-				#getSoundManager.playWave("data/sound/tree_chop.wav")
-			when "pick"
-				setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_pick.anim")))
-			when "stand"
-				setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_e_walk.anim")))
-				getFirstMesh.setAnimation("stand")
 			when "dead"
-				setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_walk.anim")))
-		 		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/grave.ant2",0.2,"data/textures/models/grave.png"),AGVector4.new(0,0,0,0),0))
+				setMesh(:grave)
 			when "row"
-				setMesh(AnimMesh.new(getMap.getScene,getAnimMeshData("data/models/man_e_walk.anim")))
-				getFirstMesh.setAnimation("sit")
-				mesh=Mesh.new(getMap.getScene,getBoatMeshData,AGVector4.new(0,0,0),0)
-				addMesh(mesh,AGVector3.new(0,0,0))
+				mesh=setMesh("sit")
+				mesh.setAnimation("sit")
+				addMesh(createModel(:boat),AGVector3.new(0,0,0))
+			when "stand","axe","pick","wood","stone","flour","corn","walk","sitdown","sit"
+				setMesh(name)
+				if ["stand","walk","sitdown","sit"].member?(name)
+					getFirstMesh.setAnimation(name)
+				end
 		end
 		setDirection(dir)
 	end

Modified: antargis/branches/branch_2d/ruby/ant_mill.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_mill.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_mill.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -10,7 +10,7 @@
 	end
 	
 	def setupMesh
-		setMesh(createModel(:mill))
+		setMesh
 #		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/ant_mill.ant2",3.2,"data/textures/models/ant_mill.png"),AGVector4.new(0,0,0),-30)
 #		setMesh(mesh)
 	end

Modified: antargis/branches/branch_2d/ruby/ant_mine.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_mine.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_mine.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -38,7 +38,7 @@
 	
 	private
 	def setupMesh
-		setMesh(createModel(:mine))
+		setMesh
 		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/mine2.ant2",0.2,"data/textures/models/mine.png"),AGVector4.new(0,0,0),-40))
 	end
 end

Modified: antargis/branches/branch_2d/ruby/ant_models.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_models.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_models.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -1,233 +1,246 @@
 
-$useImpostors=false
-
-def getStaticModelRotation(name)
-	rot={
-		"tower"=>-30,
-		"ant_mill"=>-30,
-		"mine2"=>-40,
-		"workshop"=>-50,
-		"townhall_try2"=>-60,
-		"well"=>-30,
-		"ant_bakery"=>-30,
-		"ant_coach"=>-50,
-		"livinghouse"=>-20,
-		"farm"=>-30,
-	}
-
-	if rot.member?(name)
-		return rot[name]
+module AntModels
+	@@useImpostors=false
+	
+	def AntModels.getStaticModelRotation(name)
+		rot={
+			"tower"=>-30,
+			"ant_mill"=>-30,
+			"mine2"=>-40,
+			"workshop"=>-50,
+			"townhall_try2"=>-60,
+			"well"=>-30,
+			"ant_bakery"=>-30,
+			"ant_coach"=>-50,
+			"livinghouse"=>-20,
+			"farm"=>-30,
+		}
+	
+		if rot.member?(name)
+			return rot[name]
+		end
+		return 0
 	end
-	return 0
-end
-
-def getStaticModelScaling(name)
-	scales={
-		"sack"=>0.3,
-		"stub"=>0.04,
-		"tower"=>3,
-		"ant_mill"=>3.2,
-		"mine2"=>0.2,
-		"workshop"=>0.18,
-		"townhall_try2"=>3.2,
-		"well"=>0.06,
-		"rip"=>0.3,
-		"fish"=>0.02,
-		"arrow"=>0.1,
-		"ant_bakery"=>3.0,
-		"boat_simple"=>0.12,
-		"twig"=>0.7,
-		"ant_coach"=>0.08,
-		"druid_lp"=>0.08,
-		"smith_lp"=>0.08,
-		"livinghouse"=>0.16,
-		"farm"=>0.2,
-		"fire"=>0.3,
-		"big_stone"=>0.7,
-	}
-
-	if scales.member?(name)
-		return scales[name]
+	
+	def AntModels.getStaticModelScaling(name)
+		scales={
+			"sack"=>0.3,
+			"stub"=>0.04,
+			"tower"=>3,
+			"ant_mill"=>3.2,
+			"mine2"=>0.2,
+			"workshop"=>0.18,
+			"townhall_try2"=>3.2,
+			"well"=>0.06,
+			"rip"=>0.3,
+			"fish"=>0.02,
+			"arrow"=>0.1,
+			"ant_bakery"=>3.0,
+			"boat_simple"=>0.12,
+			"twig"=>0.7,
+			"ant_coach"=>0.08,
+			"druid_lp"=>0.08,
+			"smith_lp"=>0.08,
+			"livinghouse"=>0.16,
+			"farm"=>0.2,
+			"fire"=>0.3,
+			"big_stone"=>0.7,
+			"grave"=>0.2,
+			"hero_lp"=>0.08,
+		}
+	
+		if scales.member?(name)
+			return scales[name]
+		end
+		return 1
 	end
-	return 1
-end
-
-def getMeshMap
-	animMeshes={
-		:man=>{
-			["wood"]=>"data/models/man_e_wood.anim",
-			["stone","flour","corn"]=>"data/models/man_e_stones.anim",
-			["walk","sitdown","sit"]=>"data/models/man_e_walk.anim",
-			["fight_dagger"]=>"data/models/man_e_dagger.anim",
-			["fight_shield"]=>"data/models/man_e_shield.anim",
-			["fight_sword"]=>"data/models/man_e_sword.anim",
-			["fight_bow"]=>"data/models/man_e_bow.anim"
-		},
-		:sack=>{
-			[]=>"sack"
-		},
-		:tree=>{
-			["stub"]=>"stub",
-			[0]=>["data/models/fir2.ant2",0.45,"data/textures/models/fir5.png",false],
-			[1]=>["data/models/fir2.ant2",0.45,"data/textures/models/fir7.png",false],
-			[2]=>["data/models/tree5.ant2",0.45,"data/textures/models/tree3.png",false],
-			[3]=>["data/models/tree5.ant2",0.45,"data/textures/models/tree5.png",false],
-			[4]=>["data/models/tree5.ant2",0.45,"data/textures/models/tree9.png",false],
-			[5]=>["data/models/tree6.ant2",0.45,"data/textures/models/tree5.png",false],
-			[6]=>["data/models/tree5.ant2",0.45,"data/textures/models/tree10.png",false],
-			[7]=>["data/models/tree_simple1.ant2",0.3,"data/textures/models/tree_simple1.png"],
-			[8]=>["data/models/tree_simple2.ant2",0.3,"data/textures/models/tree_simple1.png"],
-			[9]=>["data/models/tree_simple5.ant2",0.3,"data/textures/models/tree_simple5.png"]
-		},
-		:buildingsite=>{
-			[0]=>["data/models/building_site0.ant2",1.7,"data/textures/models/building_site0.png"],
-			[1]=>["data/models/building_site0.ant2",1.7,"data/textures/models/building_site1.png"],
-			[2]=>["data/models/building_site2.ant2",1.7,"data/textures/models/building_site1.png"],
-		},
-		:field=>{
-			[0]=>["data/models/crop_tiny.ant2",2.2,"data/textures/models/crop_tiny.png"],
-			[1]=>["data/models/crop_small.ant2",2.2,"data/textures/models/crop_green.png"],
-			[2]=>["data/models/crop_med.ant2",2.2,"data/textures/models/crop_yellow.png"],
-			[3]=>["data/models/crop_high.ant2",2.2,"data/textures/models/crop_gold.png"]
-		},
-		:tower=>{
-			[]=>"tower"
-		},
-		:wolf=>{
-			[]=>"ant_wolf"
-		},
-		:mill=>{
-			[]=>"ant_mill"
-		},
-		:mine=>{
-			[]=>"mine2"
-		},
-		:workshop=>{
-			[]=>"workshop"
-		},
-		:townhall=>{
-			[]=>"townhall_try2"
-		},
-		:well=>{
-			[]=>"well"
-		},
-		:rip=>{
-			[]=>"rip"
-		},
-		:fish=>{
-			[]=>"fish"
-		},
-		:sheep=>{
-			[]=>"data/models/sheep.anim"
-		},
-		:arrow=>{
-			[]=>"arrow"
-		},
-		:bakery=>{
-			[]=>"ant_bakery"
-		},
-		:boat=>{
-			[]=>"boat_simple"
-		},
-		:floor_deco=>{
-			[]=>["data/models/floor.ant2",0.5,"data/textures/splats/stones1a.png"],
-		},
-		:twig=>{	
-			[]=>"twig"
-		},
-		:coach=>{
-			[]=>"ant_coach"
-		},
-		:floor_gravel=>
-		{
-			[]=>["data/models/floor.ant2",0.8,"data/textures/gravel4.png"],
-		},
-		:druid=>
-		{
-			[]=>"druid_lp"
-		},
-		:smith=>
-		{
-			[]=>"smith_lp"
-		},	
-		:dwelling=>
-		{
-			[]=>"livinghouse"
-		},
-		:farm=>
-		{
-			[]=>"farm"
-		},	
-		:fire=>
-		{
-			[:on]=>["data/models/fire.ant2",0.3,"data/textures/models/fire.png"],
-			[:off]=>["data/models/fire.ant2",0.3,"data/textures/models/fire2.png"]
-		},
-		:fishing_hut=>
-		{
-			[]=>["data/models/fishing_hut.ant2",3.2,"data/textures/models/fishing_hut.png",false]
-		},
-		:stone=>
-		{
-			[]=>"big_stone"
-		},
-	}
-end
-
-def getMeshCount(entityType)
-	getMeshMap[entityType].length
-end
-
-def createModel(entityType,subType=nil,angle=nil)
-	mesh=nil
-
-	animMeshes=getMeshMap
-
-	map=animMeshes[entityType]
-
-	map.each{|k,v|
-		if k.member?(subType) or k.length==0
-			mesh=v
-		end
-	}
-	scenenode=nil
-	if mesh
-		if mesh.is_a?(Array)
-			ant2name=mesh[0]
-			scale=mesh[1]
-			pngname=mesh[2]
-			culling=true
-			if mesh.length>3
-				culling=mesh[3]
+	
+	def AntModels.getMeshMap
+		animMeshes={
+			:man=>{
+				[]=>"data/models/man_e_walk.anim",
+				["wood"]=>"data/models/man_e_wood.anim",
+				["stone","flour","corn"]=>"data/models/man_e_stones.anim",
+				["walk","sitdown","sit","stand"]=>"data/models/man_e_walk.anim",
+				["fight_dagger"]=>"data/models/man_e_dagger.anim",
+				["fight_shield"]=>"data/models/man_e_shield.anim",
+				["fight_sword"]=>"data/models/man_e_sword.anim",
+				["fight_bow"]=>"data/models/man_e_bow.anim",
+				["pick"]=>"data/models/man_pick.anim",
+				["axe"]=>"data/models/man_axe.anim",
+				[:grave]=>"grave",
+			},
+			:hero=>{
+				[]=>"hero_lp",
+				[:grave_hero]=>["data/models/grave.ant2",0.2,"data/textures/models/grave3.png"],
+			},
+			:sack=>{
+				[]=>"sack"
+			},
+			:tree=>{
+				[]=>["data/models/fir2.ant2",0.45,"data/textures/models/fir5.png",false],
+				["stub"]=>"stub",
+				[0]=>["data/models/fir2.ant2",0.45,"data/textures/models/fir5.png",false],
+				[1]=>["data/models/fir2.ant2",0.45,"data/textures/models/fir7.png",false],
+				[2]=>["data/models/tree5.ant2",0.45,"data/textures/models/tree3.png",false],
+				[3]=>["data/models/tree5.ant2",0.45,"data/textures/models/tree5.png",false],
+				[4]=>["data/models/tree5.ant2",0.45,"data/textures/models/tree9.png",false],
+				[5]=>["data/models/tree6.ant2",0.45,"data/textures/models/tree5.png",false],
+				[6]=>["data/models/tree5.ant2",0.45,"data/textures/models/tree10.png",false],
+				[7]=>["data/models/tree_simple1.ant2",0.3,"data/textures/models/tree_simple1.png"],
+				[8]=>["data/models/tree_simple2.ant2",0.3,"data/textures/models/tree_simple1.png"],
+				[9]=>["data/models/tree_simple5.ant2",0.3,"data/textures/models/tree_simple5.png"]
+			},
+			:buildingsite=>{
+				[]=>["data/models/building_site0.ant2",1.7,"data/textures/models/building_site0.png"],
+				[0]=>["data/models/building_site0.ant2",1.7,"data/textures/models/building_site0.png"],
+				[1]=>["data/models/building_site0.ant2",1.7,"data/textures/models/building_site1.png"],
+				[2]=>["data/models/building_site2.ant2",1.7,"data/textures/models/building_site1.png"],
+			},
+			:field=>{
+				[]=>["data/models/crop_tiny.ant2",2.2,"data/textures/models/crop_tiny.png"],
+				[0]=>["data/models/crop_tiny.ant2",2.2,"data/textures/models/crop_tiny.png"],
+				[1]=>["data/models/crop_small.ant2",2.2,"data/textures/models/crop_green.png"],
+				[2]=>["data/models/crop_med.ant2",2.2,"data/textures/models/crop_yellow.png"],
+				[3]=>["data/models/crop_high.ant2",2.2,"data/textures/models/crop_gold.png"]
+			},
+			:tower=>{
+				[]=>"tower"
+			},
+			:wolf=>{
+				[]=>"ant_wolf",
+				[:rip]=>"rip"
+			},
+			:mill=>{
+				[]=>"ant_mill"
+			},
+			:mine=>{
+				[]=>"mine2"
+			},
+			:workshop=>{
+				[]=>"workshop"
+			},
+			:townhall=>{
+				[]=>"townhall_try2"
+			},
+			:well=>{
+				[]=>"well"
+			},
+			:fish=>{
+				[]=>"fish"
+			},
+			:sheep=>{
+				[]=>"data/models/sheep.anim",
+				[:rip]=>"rip"
+			},
+			:arrow=>{
+				[]=>"arrow"
+			},
+			:bakery=>{
+				[]=>"ant_bakery"
+			},
+			:boat=>{
+				[]=>"boat_simple"
+			},
+			:deco=>{
+				[:floor_deco]=>["data/models/floor.ant2",0.5,"data/textures/splats/stones1a.png"],
+			},
+			:twig=>{	
+				[]=>"twig"
+			},
+			:coach=>{
+				[]=>"ant_coach"
+			},
+			:decal=>
+			{
+				[:floor_gravel]=>["data/models/floor.ant2",0.8,"data/textures/gravel4.png"],
+			},
+			:npc=>{
+				[:druid]=>"druid_lp",
+				[:smith]=>"smith_lp"
+			},	
+			:dwelling=>
+			{
+				[]=>"livinghouse"
+			},
+			:farm=>
+			{
+				[]=>"farm"
+			},	
+			:fire=>
+			{
+				[]=>["data/models/fire.ant2",0.3,"data/textures/models/fire.png"],
+				[:on]=>["data/models/fire.ant2",0.3,"data/textures/models/fire.png"],
+				[:off]=>["data/models/fire.ant2",0.3,"data/textures/models/fire2.png"]
+			},
+			:fishinghut=>
+			{
+				[]=>["data/models/fishing_hut.ant2",3.2,"data/textures/models/fishing_hut.png",false]
+			},
+			:stone=>
+			{
+				[]=>"big_stone"
+			},
+		}
+	end
+	
+	def AntModels.getMeshCount(entityType)
+		getMeshMap[entityType].length
+	end
+	
+	def AntModels.createModel(entityType,subType=nil,angle=nil)
+		mesh=nil
+	
+		animMeshes=getMeshMap
+	
+		puts "#{entityType}(#{entityType.class})"
+		assert{animMeshes.member?(entityType)}
+		map=animMeshes[entityType]
+	
+		map.each{|k,v|
+			if k.member?(subType) or k.length==0
+				mesh=v
 			end
-			data=getMeshData(ant2name,scale,pngname)
-			data.setCulling(culling)
-			data.setTransparent(true)
-			name=mesh
-			angle||=getStaticModelRotation(name)
-			scenenode=Mesh.new(getMap.getScene,data,AGVector4.new(0,0,0),angle)
-					
-		elsif mesh=~/anim$/
-			scenenode=AnimMesh.new(getMap.getScene,getAnimMeshData(mesh))
-		else
-			ant2name="data/models/"+mesh+".ant2"
-			pngname="data/textures/models/"+mesh+".png"
-			name=mesh
-			angle||=getStaticModelRotation(name)
-			if not fileExists(pngname)
-				pngname=""
+		}
+		scenenode=nil
+		if mesh
+			if mesh.is_a?(Array)
+				ant2name=mesh[0]
+				scale=mesh[1]
+				pngname=mesh[2]
+				culling=true
+				if mesh.length>3
+					culling=mesh[3]
+				end
+				data=getMeshData(ant2name,scale,pngname)
+				data.setCulling(culling)
+				data.setTransparent(true)
+				name=mesh
+				angle||=getStaticModelRotation(name)
+				scenenode=Mesh.new(getMap.getScene,data,AGVector4.new(0,0,0),angle)
+						
+			elsif mesh=~/anim$/
+				scenenode=AnimMesh.new(getMap.getScene,getAnimMeshData(mesh))
+			else
+				ant2name="data/models/"+mesh+".ant2"
+				pngname="data/textures/models/"+mesh+".png"
+				name=mesh
+				angle||=getStaticModelRotation(name)
+				if not fileExists(pngname)
+					pngname=""
+				end
+	
+				scenenode=Mesh.new(getMap.getScene,getMeshData(ant2name,getStaticModelScaling(name),pngname),AGVector4.new(0,0,0),angle)
 			end
-
-			scenenode=Mesh.new(getMap.getScene,getMeshData(ant2name,getStaticModelScaling(name),pngname),AGVector4.new(0,0,0),angle)
 		end
-	end
-
-	if $useImpostors
-		# FIXME:replace by impostor
-		if entityType!=:sack
-			return createModel(:sack)
+	
+		if @@useImpostors
+			# FIXME:replace by impostor
+			if entityType!=:sack
+				return createModel(:sack)
+			end
 		end
+	
+		return scenenode
 	end
-
-	return scenenode
-end
\ No newline at end of file
+end

Modified: antargis/branches/branch_2d/ruby/ant_sack.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_sack.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_sack.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -3,7 +3,7 @@
 class AntSack<AntAnimal
 	def initialize(p=AGVector2.new(0,0))
 		super
-		setMesh(createModel(:sack))
+		setMesh
 		@enabled=true
 		@storeGood=["food","tool","corn","stone","wood"]
 	end

Modified: antargis/branches/branch_2d/ruby/ant_sheep.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_sheep.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_sheep.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -33,7 +33,7 @@
 		@lastBirth=0
 		@foodAdd=0
 		
-		setMesh(createModel(:sheep))
+		setMesh
 # 		data=getAnimMeshData("data/models/sheep.anim")
 # 		setMesh(AnimMesh.new(getMap.getScene,data))
 
@@ -109,7 +109,7 @@
 		"Sheep"
 	end
 	def eventDie
-		setMesh(createModel(:rip))
+		setMesh(:rip)
 		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/rip.ant2",0.3,"data/textures/models/rip.png"),AGVector4.new(0,0,0,0),0))
 		setProvide("sheep",false)
 		@dead=true

Modified: antargis/branches/branch_2d/ruby/ant_stone.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_stone.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_stone.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -24,7 +24,7 @@
 		@typeID=(getRand*2).to_i
 		setProvide("stone",true)
 		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/big_stone.ant2",0.7,"data/textures/models/big_stone.png"),AGVector4.new(0,0,0,0),getRand*360))
-		setMesh(mesh=createModel(:stone))
+		mesh=setMesh
 		mesh.setRotation(getRand*360)
 		resource.set("stone",500)
 	end

Modified: antargis/branches/branch_2d/ruby/ant_tower.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_tower.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_tower.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -9,7 +9,7 @@
 	end
 	
 	def setupMesh
-		setMesh(createModel(:tower))
+		setMesh
 	end	
 	
 

Modified: antargis/branches/branch_2d/ruby/ant_townhall.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_townhall.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_townhall.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -33,7 +33,7 @@
 	end
 	
 	def setupMesh
-		setMesh(createModel(:townhall))
+		setMesh
 	end
 
 	def resourceChanged

Modified: antargis/branches/branch_2d/ruby/ant_tree.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_tree.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_tree.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -66,7 +66,7 @@
 		super(AGVector2.new(0,0))
 		@typeID=typeID
 		#@typeID||=(getRand*getTreeTypes.length).to_i
-		@typeID||=(getRand*(getMeshCount(:tree)-1)).to_i
+		@typeID||=(getRand*(AntModels.getMeshCount(:tree)-1)).to_i
 		setProvide("wood",true)
 		setProvide("fruit",true)
 		@angle=getRand*360
@@ -113,7 +113,8 @@
 		if @typeID>=0
 			typeId=@typeID%10
 		end
-		setMesh(createModel(:tree,typeId, at angle))
+		mesh=setMesh(typeId)
+		mesh.setRotation(@angle)
 	end
 
 	# an old function for display apples - this is too costly

Modified: antargis/branches/branch_2d/ruby/ant_well.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_well.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_well.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -14,7 +14,7 @@
 	end
 	
 	def setupMesh
-		setMesh(createModel(:well))
+		setMesh
 	end
 
 

Modified: antargis/branches/branch_2d/ruby/ant_wolf.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_wolf.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_wolf.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -42,7 +42,7 @@
 		@mypack=[]
 		@leader=nil
 		
-		setMesh(createModel(:wolf))
+		setMesh
 
 		resource.set("food",1)
 		@job=:resting
@@ -236,7 +236,7 @@
 		"Wolf"
 	end
 	def eventDie
-		setMesh(createModel(:rip))
+		setMesh(:rip)
 		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/rip.ant2",0.3,"data/textures/models/rip.png"),AGVector4.new(0,0,0,0),0))
 		@dead=true
 		

Modified: antargis/branches/branch_2d/ruby/ant_workshop.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_workshop.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ant_workshop.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -41,7 +41,7 @@
 	end
 	# sets up the mesh and adds a smoke-particle engine, which is disabled at first
 	def setupMesh
-		setMesh(createModel(:workshop))
+		setMesh
 		p=AGVector3.new(-1.3,-1.2,2.2)
 		addMesh(@smokeMesh=Smoke.new(getMap.getScene,5),p)
 		checkSmoke

Modified: antargis/branches/branch_2d/ruby/ents.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ents.rb	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/ruby/ents.rb	2007-05-02 18:18:15 UTC (rev 1080)
@@ -219,6 +219,25 @@
 # 	def _load(s)
 # 		getMap.getByUID(s.unpack("n"))
 # 	end
+
+
+	def setMesh(subtype="",sym=nil)
+		if subtype.is_a?(SceneNode)
+			puts  "THIS SHOULD NOT BE USED ANY LONGER: setMesh(realMesh) !!!!!!!!!!!!"
+			super(subtype) # wrapper
+			return subtype
+		end
+		@map={:AntSack=>:sack}
+		t=self.class.to_s
+		t=t.gsub("Ant","").downcase
+		t=t.to_sym
+		if sym
+			t=sym
+		end
+		
+		super(mesh=AntModels.createModel(t,subtype))
+		return mesh
+	end
 end
 
 # here comes a list of all the different entity-types BoA currently uses:

Modified: antargis/branches/branch_2d/src/antargisgui.h
===================================================================
--- antargis/branches/branch_2d/src/antargisgui.h	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/src/antargisgui.h	2007-05-02 18:18:15 UTC (rev 1080)
@@ -73,6 +73,8 @@
 #include "../src/map.h"
 #include "../src/mesh_data.h"
 #include "../src/mesh.h"
+#include "../src/mesh_2d_data.h"
+#include "../src/mesh_2d.h"
 #include "../src/mesh_optimizer.h"
 #include "../src/minimap.h"
 #include "../src/new_decal.h"
@@ -80,6 +82,7 @@
 #include "../src/resource.h"
 #include "../src/scene_base.h"
 #include "../src/scene.h"
+#include "../src/scene_2d.h"
 #include "../src/smoke.h"
 #include "../src/terrain.h"
 #include "../src/vertex_array.h"
@@ -161,6 +164,8 @@
 %include "../src/map.h"
 %include "../src/mesh_data.h"
 %include "../src/mesh.h"
+%include "../src/mesh_2d_data.h"
+%include "../src/mesh_2d.h"
 %include "../src/mesh_optimizer.h"
 %include "../src/minimap.h"
 %include "../src/new_decal.h"
@@ -168,6 +173,7 @@
 %include "../src/resource.h"
 %include "../src/scene_base.h"
 %include "../src/scene.h"
+%include "../src/scene_2d.h"
 %include "../src/smoke.h"
 %include "../src/terrain.h"
 %include "../src/vertex_array.h"

Modified: antargis/branches/branch_2d/src/impostor.cc
===================================================================
--- antargis/branches/branch_2d/src/impostor.cc	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/src/impostor.cc	2007-05-02 18:18:15 UTC (rev 1080)
@@ -3,7 +3,7 @@
 #include <ag_screen.h>
 #include <ag_rendercontext.h>
 
-AntImpostorData::AntImpostorData(SceneNode *pNode):mTexture(512,512)
+AntImpostorData::AntImpostorData(SceneNode *pNode,int width,int height):mTexture(width,height)
 {
   glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT); // clear screen and depth buffer
 
@@ -42,8 +42,6 @@
   */
   int sw=getScreen().getWidth(),sh=getScreen().getHeight();
   int w=mTexture.width(),h=mTexture.height();
-  
-  
 
   glViewport(-sw/2+w/2,-sh/2+h/2,sw,sh);
 
@@ -56,12 +54,13 @@
   AGSurface s=getScreen().screenshot(false);
   s.save("impostor.png");
 
-
   mTexture.endPaint();
 
   AGSurface subs=s.getSubSurface(AGRect2(0,sh-h,w,h));
   subs.save("impostor3.png");
 
+  mSurface=subs;
+
   //  mTexture.save("impostor.png");
 }
 
@@ -70,6 +69,11 @@
   return mTexture;
 }
 
+AGSurface &AntImpostorData::getSurface()
+{
+  return mSurface;
+}
+
 void AntImpostorData::mark()
 {
   markObject(&mTexture);

Modified: antargis/branches/branch_2d/src/impostor.h
===================================================================
--- antargis/branches/branch_2d/src/impostor.h	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/src/impostor.h	2007-05-02 18:18:15 UTC (rev 1080)
@@ -7,12 +7,14 @@
 class AntImpostorData:public AGRubyObject
 {
   AGTexture mTexture;
+  AGSurface mSurface;
   
  public:
   // create impostor from a scene-node - to make it as simple as possible
-  AntImpostorData(SceneNode *pNode);
+  AntImpostorData(SceneNode *pNode,int width,int height);
 
   AGTexture &getTexture();
+  AGSurface &getSurface();
 
   void mark();
 

Modified: antargis/branches/branch_2d/src/nantmarker.hh
===================================================================
--- antargis/branches/branch_2d/src/nantmarker.hh	2007-04-29 19:26:46 UTC (rev 1079)
+++ antargis/branches/branch_2d/src/nantmarker.hh	2007-05-02 18:18:15 UTC (rev 1080)
@@ -88,6 +88,16 @@
 	result->mRubyObject=true;
 }
 %markfunc WaterPiece "general_markfunc"
+%exception Mesh2D::Mesh2D {
+	$action
+	result->mRUBY=self;
+#ifdef GCDEBUG
+     result->mObjName=typeid(*result).name();
+     printf("%lx   %s\n",self,typeid(*result).name());
+#endif
+	result->mRubyObject=true;
+}
+%markfunc Mesh2D "general_markfunc"
 %exception AGText::AGText {
 	$action
 	result->mRUBY=self;
@@ -108,6 +118,16 @@
 	result->mRubyObject=true;
 }
 %markfunc AGScreenWidget "general_markfunc"
+%exception Mesh2DData::Mesh2DData {
+	$action
+	result->mRUBY=self;
+#ifdef GCDEBUG
+     result->mObjName=typeid(*result).name();
+     printf("%lx   %s\n",self,typeid(*result).name());
+#endif
+	result->mRubyObject=true;
+}
+%markfunc Mesh2DData "general_markfunc"
 %exception AGRubyObject::AGRubyObject {
 	$action
 	result->mRUBY=self;
@@ -398,6 +418,16 @@
 	result->mRubyObject=true;
 }
 %markfunc AGMain "general_markfunc"
+%exception Scene2D::Scene2D {
+	$action
+	result->mRUBY=self;
+#ifdef GCDEBUG
+     result->mObjName=typeid(*result).name();
+     printf("%lx   %s\n",self,typeid(*result).name());
+#endif
+	result->mRubyObject=true;
+}
+%markfunc Scene2D "general_markfunc"
 %exception SceneNode::SceneNode {
 	$action
 	result->mRUBY=self;
@@ -860,6 +890,34 @@
  }
  else $input=Qnil;
 }
+%typemap(out) Mesh2D*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $result=$1->mRUBY;
+  else
+   {
+     if(false);
+   else
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh2D,0);
+   }
+ }
+ else vresult=Qnil;
+}
+%typemap(directorin) Mesh2D*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $input=$1->mRUBY;
+  else
+   {
+     if(false);
+   else
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Mesh2D,0);
+   }
+ }
+ else $input=Qnil;
+}
 %typemap(out) AGText*{
  if($1)
  {
@@ -1100,6 +1158,34 @@
  }
  else $input=Qnil;
 }
+%typemap(out) Mesh2DData*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $result=$1->mRUBY;
+  else
+   {
+     if(false);
+   else
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh2DData,0);
+   }
+ }
+ else vresult=Qnil;
+}
+%typemap(directorin) Mesh2DData*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $input=$1->mRUBY;
+  else
+   {
+     if(false);
+   else
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Mesh2DData,0);
+   }
+ }
+ else $input=Qnil;
+}
 %typemap(out) AGFontEngine*{
  if($1)
  {
@@ -1962,6 +2048,8 @@
      if(false);
 else if(dynamic_cast<AnimMesh*>(result))
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AnimMesh,0);
+else if(dynamic_cast<Mesh2D*>(result))
+  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh2D,0);
 else if(dynamic_cast<WaterPiece*>(result))
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_WaterPiece,0);
 else if(dynamic_cast<AntImpostor*>(result))
@@ -1990,6 +2078,8 @@
      if(false);
 else if(dynamic_cast<AnimMesh*>($1))
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AnimMesh,0);
+else if(dynamic_cast<Mesh2D*>($1))
+  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Mesh2D,0);
 else if(dynamic_cast<WaterPiece*>($1))
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_WaterPiece,0);
 else if(dynamic_cast<AntImpostor*>($1))
@@ -2036,6 +2126,34 @@
  }
  else $input=Qnil;
 }
+%typemap(out) Scene2D*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $result=$1->mRUBY;
+  else
+   {
+     if(false);
+   else
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene2D,0);
+   }
+ }
+ else vresult=Qnil;
+}
+%typemap(directorin) Scene2D*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $input=$1->mRUBY;
+  else
+   {
+     if(false);
+   else
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Scene2D,0);
+   }
+ }
+ else $input=Qnil;
+}
 %typemap(out) AntImpostor*{
  if($1)
  {
@@ -2130,6 +2248,8 @@
      if(false);
 else if(dynamic_cast<Scene*>(result))
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene,0);
+else if(dynamic_cast<Scene2D*>(result))
+  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene2D,0);
    else
      vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SceneBase,0);
    }
@@ -2146,6 +2266,8 @@
      if(false);
 else if(dynamic_cast<Scene*>($1))
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Scene,0);
+else if(dynamic_cast<Scene2D*>($1))
+  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Scene2D,0);
    else
      $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_SceneBase,0);
    }
@@ -3309,6 +3431,16 @@
  Data_Get_Struct($input,Mesh,b);
  $result=*b;
 }
+%typemap(directorout) Mesh2D {
+ Mesh2D *b;
+ Data_Get_Struct($input,Mesh2D,b);
+ $result=*b;
+}
+%typemap(directorout) Mesh2DData {
+ Mesh2DData *b;
+ Data_Get_Struct($input,Mesh2DData,b);
+ $result=*b;
+}
 %typemap(directorout) MeshData {
  MeshData *b;
  Data_Get_Struct($input,MeshData,b);
@@ -3374,6 +3506,11 @@
  Data_Get_Struct($input,Scene,b);
  $result=*b;
 }
+%typemap(directorout) Scene2D {
+ Scene2D *b;
+ Data_Get_Struct($input,Scene2D,b);
+ $result=*b;
+}
 %typemap(directorout) SceneBase {
  SceneBase *b;
  Data_Get_Struct($input,SceneBase,b);



From davidkamphausen at mail.berlios.de  Wed May  2 20:19:49 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Wed, 2 May 2007 20:19:49 +0200
Subject: [Antargis-svn] r1081 - in antargis/branches/branch_2d: data/models
	ruby/tests src
Message-ID: <200705021819.l42IJnYP024796@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-02 20:19:49 +0200 (Wed, 02 May 2007)
New Revision: 1081

Added:
   antargis/branches/branch_2d/data/models/all_models.xml
   antargis/branches/branch_2d/ruby/tests/impostor.rb
   antargis/branches/branch_2d/ruby/tests/scene_2d.rb
   antargis/branches/branch_2d/src/mesh_2d.cc
   antargis/branches/branch_2d/src/mesh_2d.h
   antargis/branches/branch_2d/src/mesh_2d_data.cc
   antargis/branches/branch_2d/src/mesh_2d_data.h
   antargis/branches/branch_2d/src/scene_2d.cc
   antargis/branches/branch_2d/src/scene_2d.h
   antargis/branches/branch_2d/src/scene_base.cc
   antargis/branches/branch_2d/src/scene_base.h
Log:
* added missing files


Added: antargis/branches/branch_2d/data/models/all_models.xml
===================================================================
--- antargis/branches/branch_2d/data/models/all_models.xml	2007-05-02 18:18:15 UTC (rev 1080)
+++ antargis/branches/branch_2d/data/models/all_models.xml	2007-05-02 18:19:49 UTC (rev 1081)
@@ -0,0 +1,13 @@
+<models>
+	<default name="modelPath" value="data/models"/>
+	<default name="texturePath" value="data/textures/models"/>
+	<model entityType="AntMan">
+		<view>
+			<mesh file="man_e_walk" anim="stand"/>
+		</view>
+		<view name="wood">
+			<mesh file="man_e_wood"/>
+		</view>
+	</model>
+</models>
+	
\ No newline at end of file

Added: antargis/branches/branch_2d/ruby/tests/impostor.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/impostor.rb	2007-05-02 18:18:15 UTC (rev 1080)
+++ antargis/branches/branch_2d/ruby/tests/impostor.rb	2007-05-02 18:19:49 UTC (rev 1081)
@@ -0,0 +1,65 @@
+#!/usr/bin/env ruby
+
+require 'ruby/antargislib.rb'
+require 'ruby/ant_models.rb'
+
+class MMap
+	def getScene
+		$scene
+	end
+end
+
+def getMap
+	MMap.new
+end
+
+class MyApp<GLApp
+	@@types=[]
+	AntModels.getMeshMap.each{|k,v|
+		puts "#{k}(#{k.class}):#{v} #{v.class}"
+		v.each{|x,y|
+			assert{!(k.is_a?(Hash)||x.is_a?(Hash))}
+			@@types<<[k,x[0]]
+			puts "K:#{k}(#{k.class}) Y:#{x}(#{x.class})"
+		}
+	}
+	puts @@types.inspect
+	
+	def initialize(w,h)
+		super
+		$scene=getScene
+
+		tex=nil
+		@@types.each{|t,t2|
+			puts "TRY CREATE #{t}(#{t.class}) #{t2}(#{t2.class})"
+			node=AntModels.createModel(t,t2)
+			puts "#{t}:#{t2} failed creation" if node.nil?
+			$scene.addNode(node)
+			imp=AntImpostorData.new(node,512,512)
+	
+			tex=imp.getTexture
+			name=t.to_s
+			if t2
+				name+="_"+(t2.to_s)	
+			end
+			name+=".png"
+			imp.getSurface.save(name)
+			getScene.removeNode(node)
+		}
+			
+		image=AGImage.new(nil,AGRect2.new(0,0,tex.width,tex.height),tex,false)
+		setMainWidget(image)
+		
+		getScene.removeNode(node)
+	end
+
+	def eventFrame(t)
+		delay(100)
+	puts t
+		return true
+	end
+end
+
+app=MyApp.new(1024,768)
+
+app.run

Added: antargis/branches/branch_2d/ruby/tests/scene_2d.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/scene_2d.rb	2007-05-02 18:18:15 UTC (rev 1080)
+++ antargis/branches/branch_2d/ruby/tests/scene_2d.rb	2007-05-02 18:19:49 UTC (rev 1081)
@@ -0,0 +1,70 @@
+#!/usr/bin/env ruby
+
+require 'ruby/antargislib.rb'
+
+getMain.initVideo(800,600,32,false,false)
+
+def makeExampleMesh(scene,type)
+	t=AGTexture.new(AGSurface.load("data/textures/2d/#{type}.png"))
+	data=Mesh2DData.new(t)
+	mesh=Mesh2D.new(scene,data,AGVector4.new(0,0,0,1),0)
+end
+
+
+class My2dWidget<AGWidget
+	def initialize(p,r)
+		super
+		@scene=Scene2D.new(r.width.to_i,r.height.to_i)
+		mesh=makeExampleMesh(@scene,:farm)
+		@scene.addNode(mesh)
+		mesh=makeExampleMesh(@scene,:tree)
+		mesh.setPos(AGVector3.new(300,50,0))
+		@scene.addNode(mesh)
+	end
+	def draw(p)
+		@scene.setPainter(p)
+		@scene.draw
+		@scene.discardPainter
+	end
+
+	def eventMouseButtonDown(e)
+		#raise 1
+		@mousePos=e.getMousePosition
+		super
+	end
+	def eventMouseButtonUp(e)
+		@mousePos=nil
+		super
+	end
+	def eventMouseMotion(e)
+		if @mousePos
+			diff=e.getMousePosition- at mousePos
+			@mousePos=e.getMousePosition
+			p=@scene.getCamera.dim2+AGVector2.new(-diff[0],diff[1])
+			@scene.setCamera(AGVector4.new(p[0],p[1],0,1))
+			queryRedraw
+		end
+		super
+	end
+
+# 	def prepareDraw
+# 		queryRedraw
+# 	end
+
+end
+
+class My2dTest<AGApplication
+	def initialize
+		super
+		setMainWidget(My2dWidget.new(nil,AGRect2.new(0,0,getMain.width,getMain.height)))
+	end
+	def eventFrame(t)
+		
+		delay(20)
+		super
+	end
+end
+
+app=My2dTest.new
+
+app.run
\ No newline at end of file

Added: antargis/branches/branch_2d/src/mesh_2d.cc
===================================================================
--- antargis/branches/branch_2d/src/mesh_2d.cc	2007-05-02 18:18:15 UTC (rev 1080)
+++ antargis/branches/branch_2d/src/mesh_2d.cc	2007-05-02 18:19:49 UTC (rev 1081)
@@ -0,0 +1,62 @@
+#include "mesh_2d.h"
+#include <ag_debug.h>
+#include <ag_painter.h>
+
+Mesh2D::Mesh2D(Scene2D *pScene):
+  SceneNode(pScene,AGVector4(),AGBox3())
+{
+}
+Mesh2D::Mesh2D(Scene2D *pScene,Mesh2DData &data,const AGVector4 &pPos,float pRot):
+  SceneNode(pScene,pPos,data.bbox()),
+  mData(&data)
+{
+}
+Mesh2D::~Mesh2D()
+{
+}
+
+void Mesh2D::draw()
+{
+  //FIXME: drawing
+  Scene2D *s=dynamic_cast<Scene2D*>(getScene());
+  assert(s);
+  AGPainter *painter=s->getPainter();
+
+  assert(painter);
+  AGTexture *t=mData->getTexture();
+  AGVector2 middle(s->getPosition(getPos()));
+  float w=t->width();
+  float h=t->height();
+  AGRect2 r(middle.getX()-w/2,middle.getY()-h/2,w,h);
+
+  //  cdebug("r:"<<r);
+  painter->blit(*t,r);
+}
+
+AGVector4 Mesh2D::lineHit(const AGLine3 &pLine) const
+{
+  //FIXME
+  return AGVector4();
+}
+
+/// set rotation around y-axis (e.g. turn people)
+void Mesh2D::setRotation(float r)
+{
+}
+/// set color (for rings)
+void Mesh2D::setColor(const AGVector4 &pColor)
+{
+}
+void Mesh2D::setVisible(bool v)
+{
+}
+
+Mesh2DData *Mesh2D::getData()
+{
+  return mData;
+}
+
+void Mesh2D::mark()
+{
+  markObject(mData);
+}

Added: antargis/branches/branch_2d/src/mesh_2d.h
===================================================================
--- antargis/branches/branch_2d/src/mesh_2d.h	2007-05-02 18:18:15 UTC (rev 1080)
+++ antargis/branches/branch_2d/src/mesh_2d.h	2007-05-02 18:19:49 UTC (rev 1081)
@@ -0,0 +1,34 @@
+#ifndef MESH_2D_H
+#define MESH_2D_H
+
+#include "scenenode.h"
+#include "scene_2d.h"
+#include "mesh_2d_data.h"
+
+class Mesh2D:public SceneNode
+{
+ public:
+  Mesh2D(Scene2D *pScene);
+  Mesh2D(Scene2D *pScene,Mesh2DData &data,const AGVector4 &pPos,float pRot);
+  virtual ~Mesh2D();
+
+  void draw();
+
+  virtual AGVector4 lineHit(const AGLine3 &pLine) const;
+
+  /// set rotation around y-axis (e.g. turn people)
+  void setRotation(float r);
+  /// set color (for rings)
+  void setColor(const AGVector4 &pColor); 
+  void setVisible(bool v);
+
+  Mesh2DData *getData();
+
+  void mark();
+
+ public:
+  Mesh2DData *mData;
+};
+
+
+#endif

Added: antargis/branches/branch_2d/src/mesh_2d_data.cc
===================================================================
--- antargis/branches/branch_2d/src/mesh_2d_data.cc	2007-05-02 18:18:15 UTC (rev 1080)
+++ antargis/branches/branch_2d/src/mesh_2d_data.cc	2007-05-02 18:19:49 UTC (rev 1081)
@@ -0,0 +1,22 @@
+#include "mesh_2d_data.h"
+
+Mesh2DData::Mesh2DData(AGTexture *pTexture):
+  mTexture(pTexture)
+{
+}
+  
+void Mesh2DData::mark()
+{
+  markObject(mTexture);
+}
+
+AGTexture *Mesh2DData::getTexture()
+{
+  return mTexture;
+}
+
+AGBox3 Mesh2DData::bbox() const
+{
+  // FIXME
+  return AGBox3();
+}

Added: antargis/branches/branch_2d/src/mesh_2d_data.h
===================================================================
--- antargis/branches/branch_2d/src/mesh_2d_data.h	2007-05-02 18:18:15 UTC (rev 1080)
+++ antargis/branches/branch_2d/src/mesh_2d_data.h	2007-05-02 18:19:49 UTC (rev 1081)
@@ -0,0 +1,21 @@
+#ifndef MESH_2D_DATA
+#define MESH_2D_DATA
+
+#include <ag_texture.h>
+
+class Mesh2DData:public AGRubyObject
+{
+ public:
+  Mesh2DData(AGTexture *pTexture);
+  
+  void mark();
+
+  AGTexture *getTexture();
+
+  AGBox3 bbox() const;
+
+ private:
+  AGTexture *mTexture;
+};
+
+#endif

Added: antargis/branches/branch_2d/src/scene_2d.cc
===================================================================
--- antargis/branches/branch_2d/src/scene_2d.cc	2007-05-02 18:18:15 UTC (rev 1080)
+++ antargis/branches/branch_2d/src/scene_2d.cc	2007-05-02 18:19:49 UTC (rev 1081)
@@ -0,0 +1,83 @@
+#ifndef NO
+
+#include "scene_2d.h"
+#include <ag_debug.h>
+
+Scene2D::Scene2D(int w,int h):
+  SceneBase(w,h),mPainter(0)
+{
+}
+
+Scene2D::~Scene2D()
+{
+}
+
+void Scene2D::draw()
+{
+  // FIXME
+  
+  NodeList nodeList=getCurrentNodes();
+
+  //FIXME:sort!!
+
+  for(NodeList::iterator i=nodeList.begin();i!=nodeList.end();i++)
+    (*i)->draw();
+}
+
+SceneBase::PickResult Scene2D::pick(float x,float y,float w,float h)
+{
+  throw std::runtime_error("FIXME");
+  return PickResult();
+}
+
+AGVector2 Scene2D::getPosition(const AGVector4 &v) const
+{
+  // FIXME: include camera !!
+  AGVector2 center(width()/2,height()/2);
+  AGVector2 cam(mCamera.getPosition().dim2());
+
+  AGVector2 n=v.dim2()+center-cam;
+
+  //  cdebug("n:"<<n);
+
+  return AGVector2(n[0],height()-n[1]);
+
+  throw std::runtime_error("FIXME");
+  return v.dim2();
+}
+
+SceneBase::NodeList Scene2D::getCurrentNodes()
+{
+  //  cdebug("FIXME");
+
+  NodeList l;
+  std::copy(mNodes.begin(),mNodes.end(),std::back_inserter(l));
+
+  //  throw std::runtime_error("FIXME");
+  return l;
+}
+
+//void setEnabled(bool p);
+
+void Scene2D::setPainter(AGPainter *p)
+{
+  CTRACE;
+  assert(mPainter==0);
+  mPainter=p;
+}
+void Scene2D::discardPainter()
+{
+  CTRACE;
+  assert(mPainter!=0);
+  mPainter=0;
+}
+
+AGPainter *Scene2D::getPainter()
+{
+  CTRACE;
+  assert(mPainter);
+  return mPainter;
+}
+
+
+#endif

Added: antargis/branches/branch_2d/src/scene_2d.h
===================================================================
--- antargis/branches/branch_2d/src/scene_2d.h	2007-05-02 18:18:15 UTC (rev 1080)
+++ antargis/branches/branch_2d/src/scene_2d.h	2007-05-02 18:19:49 UTC (rev 1081)
@@ -0,0 +1,47 @@
+#ifndef SCENE_2D_H
+#define SCENE_2D_H
+
+#include "scene_base.h"
+
+class AGPainter;
+
+class Scene2D:public SceneBase
+{
+ public:
+  typedef std::vector<PickNode> PickResult;
+  typedef std::list<SceneNode*> NodeList;
+
+  Scene2D(int w,int h);
+  virtual ~Scene2D();
+
+  void draw();
+
+  /**
+     picking is currently done with opengl. this uses software (at least on my box), which is
+     pretty slow. Some new implementation using BSPs would be cool!
+     VertexArray or MeshData should contain it's data in such a tree. rays can be transformed using
+     inverse transformation-matrices. This way data can stay as is.
+  */
+  PickResult pick(float x,float y,float w,float h);
+
+  AntCamera &getCameraObject();
+
+  AGVector2 getPosition(const AGVector4 &v) const;
+
+  NodeList getCurrentNodes();
+
+  void setEnabled(bool p);
+
+  void setPainter(AGPainter *p);
+  void discardPainter();
+
+  AGPainter *getPainter();
+ private:
+  AGPainter *mPainter;
+  
+  
+  
+
+};
+
+#endif

Added: antargis/branches/branch_2d/src/scene_base.cc
===================================================================
--- antargis/branches/branch_2d/src/scene_base.cc	2007-05-02 18:18:15 UTC (rev 1080)
+++ antargis/branches/branch_2d/src/scene_base.cc	2007-05-02 18:19:49 UTC (rev 1081)
@@ -0,0 +1,143 @@
+#include "ag_profiler.h"
+
+#include "quadtree.h"
+
+#include "scene_base.h"
+
+SceneBase::SceneBase(int w,int h):
+  mTree(new QuadTree<SceneNode>(AGRect2(AGVector2(),AGVector2(w,h)))),
+  mCamera(w,h)
+{
+}
+
+
+SceneBase::~SceneBase()
+{
+  // tell nodes, that I'm no longer there :-)
+  for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
+    (*i)->resetScene(); 
+
+  delete mTree;
+}
+
+
+
+
+
+void SceneBase::addNode(SceneNode *node)
+{
+  if(mNodeSet.find(node)==mNodeSet.end())
+    {
+      node->setScene(this);
+
+      mNodes.push_back(node);
+      mNodeSet.insert(node);
+      assert(node->getScene()==this);
+      mTree->insert(node);
+    }
+}
+
+
+
+void SceneBase::updatePos(SceneNode *node)
+{
+  if(mNodeSet.find(node)==mNodeSet.end())
+    throw std::string("Dont know about this!");
+  mTree->insert(node);
+}
+
+void SceneBase::prepareUpdate(SceneNode *node)
+{
+  if(mNodeSet.find(node)==mNodeSet.end())
+    throw std::string("Dont know about this!");
+  mTree->remove(node);
+}
+
+
+void SceneBase::removeNode(SceneNode *node)
+{
+  if(mNodeSet.find(node)!=mNodeSet.end())
+    {
+      Nodes::iterator i=std::find(mNodes.begin(),mNodes.end(),node);
+      mNodes.erase(i);
+      mNodeSet.erase(node);
+      assert(node->getScene()==this);
+      node->resetScene();
+      assert(mTree->remove(node));
+    }
+  else
+    {
+      throw std::runtime_error("Trying to remove unknown node");
+    }
+}
+
+void SceneBase::clear()
+{
+  for(std::vector<SceneNode*>::iterator i=mNodes.begin();i!=mNodes.end();i++)
+    {
+      assert((*i)->getScene()==this);
+      (*i)->resetScene();
+    }
+  TRACE;
+  mNodes.clear();
+  mNodeSet.clear();
+  mTree->clear();
+}
+
+  // (mx,my,0)
+void SceneBase::setCamera(AGVector4 v)
+{
+  mCamera.setPosition(v.dim3());
+}
+
+void SceneBase::advance(float time)
+{
+  STACKTRACE; 
+
+  //  if(!mEnabled)
+  //    return;
+  // advance only in view
+
+  NodeList l=getCurrentNodes();
+
+  for(NodeList::iterator i=l.begin();i!=l.end();i++)
+    {
+      if((*i)->visible())
+	(*i)->advance(time);
+    }
+}
+
+float SceneBase::width() const
+{
+  return mCamera.getWidth();
+}
+float SceneBase::height() const
+{
+  return mCamera.getHeight();
+}
+
+void SceneBase::mark()
+{
+  SceneBase::Nodes::iterator i=mNodes.begin();
+
+  for(;i!=mNodes.end();i++)
+    {
+      markObject(*i);
+    }
+}
+
+AGVector4 SceneBase::getCamera() const
+{
+  return AGVector4(mCamera.getPosition(),1);
+}
+
+AntCamera &SceneBase::getCameraObject()
+{
+  return mCamera;
+}
+
+SceneBase::NodeList SceneBase::getCurrentNodes()
+{
+  throw std::runtime_error("not implemented!");
+  return NodeList();
+}

Added: antargis/branches/branch_2d/src/scene_base.h
===================================================================
--- antargis/branches/branch_2d/src/scene_base.h	2007-05-02 18:18:15 UTC (rev 1080)
+++ antargis/branches/branch_2d/src/scene_base.h	2007-05-02 18:19:49 UTC (rev 1081)
@@ -0,0 +1,93 @@
+#ifndef SCENE_BASE_H
+#define SCENE_BASE_H
+
+#include "ant_camera.h"
+#include "scenenode.h"
+
+/**
+   some helper structure, which is used for storing
+   results when picking. it holds some information about:
+   * distance to camera (for sorting)
+   * the picked scene-node
+   * and the 3d-position, where the scene-node was touched
+   */
+struct PickNode
+{
+  AGVector4 pos;
+  SceneNode *node;
+  float camDist;
+  
+  bool operator<(const PickNode &n) const;
+};
+
+template<class T>
+class QuadTree;
+
+
+class SceneBase:public AGRubyObject
+{
+ public:
+  typedef std::vector<PickNode> PickResult;
+  typedef std::list<SceneNode*> NodeList;
+
+  SceneBase(int w,int h);
+  virtual ~SceneBase();
+
+  void draw();
+
+  // ATTENTION: nodes are not owned by Scene afterwards - so they won't get deleted!
+  //            You have to do this yourself in the Entities or let ruby's GC do it for you (which would be the normal case)
+  void addNode(SceneNode *node);
+  void removeNode(SceneNode *node);
+  void prepareUpdate(SceneNode *node);
+  void updatePos(SceneNode *node);
+
+  void clear();
+
+  // (mx,my,0)
+  void setCamera(AGVector4 v);
+  AGVector4 getCamera() const;
+  virtual void advance(float time);
+
+  /**
+     picking is currently done with opengl. this uses software (at least on my box), which is
+     pretty slow. Some new implementation using BSPs would be cool!
+     VertexArray or MeshData should contain it's data in such a tree. rays can be transformed using
+     inverse transformation-matrices. This way data can stay as is.
+  */
+  //  virtual PickResult pick(float x,float y,float w,float h);
+
+  AntCamera &getCameraObject();
+
+  size_t getDrawnMeshes() const;
+
+  /// width and height of screen
+  float width() const;
+  float height() const;
+
+  void mark();
+
+
+  /** get currently visible nodes */
+  virtual NodeList getCurrentNodes();
+
+  //  void setEnabled(bool p);
+
+ protected:
+
+  typedef std::vector<SceneNode*> Nodes;
+  typedef std::set<SceneNode*> NodeSet;
+
+  typedef QuadTree<SceneNode> Tree;
+
+  Tree *mTree;
+
+  AntCamera mCamera;
+
+  Nodes mNodes;
+  NodeSet mNodeSet;
+
+};
+
+
+#endif



From davidkamphausen at mail.berlios.de  Wed May  2 21:05:00 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Wed, 2 May 2007 21:05:00 +0200
Subject: [Antargis-svn] r1082 - in antargis/branches/branch_2d:
	data/textures/2d/terrain ruby ruby/tests src
Message-ID: <200705021905.l42J50aF029030@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-02 21:04:59 +0200 (Wed, 02 May 2007)
New Revision: 1082

Added:
   antargis/branches/branch_2d/data/textures/2d/terrain/base_terrain.xcf
   antargis/branches/branch_2d/data/textures/2d/terrain/basic_grass.png
Modified:
   antargis/branches/branch_2d/ruby/ant_models.rb
   antargis/branches/branch_2d/ruby/tests/scene_2d.rb
   antargis/branches/branch_2d/src/height_map.cc
   antargis/branches/branch_2d/src/height_map.h
   antargis/branches/branch_2d/src/nantmarker.hh
   antargis/branches/branch_2d/src/terrain.cc
   antargis/branches/branch_2d/src/terrain.h
Log:
* preparations for 2d-terrain


Added: antargis/branches/branch_2d/data/textures/2d/terrain/base_terrain.xcf
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/terrain/base_terrain.xcf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/terrain/basic_grass.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/terrain/basic_grass.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: antargis/branches/branch_2d/ruby/ant_models.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_models.rb	2007-05-02 18:19:49 UTC (rev 1081)
+++ antargis/branches/branch_2d/ruby/ant_models.rb	2007-05-02 19:04:59 UTC (rev 1082)
@@ -236,11 +236,18 @@
 	
 		if @@useImpostors
 			# FIXME:replace by impostor
-			if entityType!=:sack
-				return createModel(:sack)
+			if entityType!=:fish
+				return createModel(:fish)
 			end
 		end
 	
 		return scenenode
 	end
 end
+
+module Libantargis
+class Mesh
+	def setAnimation(name)
+	end
+end
+end
\ No newline at end of file

Modified: antargis/branches/branch_2d/ruby/tests/scene_2d.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/scene_2d.rb	2007-05-02 18:19:49 UTC (rev 1081)
+++ antargis/branches/branch_2d/ruby/tests/scene_2d.rb	2007-05-02 19:04:59 UTC (rev 1082)
@@ -10,7 +10,10 @@
 	mesh=Mesh2D.new(scene,data,AGVector4.new(0,0,0,1),0)
 end
 
+class MyTerrain<SceneNode
+end
 
+
 class My2dWidget<AGWidget
 	def initialize(p,r)
 		super

Modified: antargis/branches/branch_2d/src/height_map.cc
===================================================================
--- antargis/branches/branch_2d/src/height_map.cc	2007-05-02 18:19:49 UTC (rev 1081)
+++ antargis/branches/branch_2d/src/height_map.cc	2007-05-02 19:04:59 UTC (rev 1082)
@@ -24,11 +24,10 @@
   for(int t=FIRSTTERRAIN;t<LASTTERRAIN; t++)
     mTerrainTypes[TerrainType(t)]=genSomeHeights(w+2,h+2,1);
 
-  if(videoInited())
-    mTerrain=new Terrain(mScene,*this);
-  else
-    mTerrain=0;
+  mTerrain=0;
+  initTerrainMesh();
 
+
   setTerrainScale(WATER,0);
   setTerrainScale(SAND,8/32.0);
   setTerrainScale(EARTH,12/32.0);
@@ -44,6 +43,13 @@
   delete mTerrain;
 }
 
+void HeightMap::initTerrainMesh()
+{
+  if(videoInited())
+    mTerrain=new Terrain(mScene,*this);
+}
+
+
 void HeightMap::setHeight(float height)
 {
   for(size_t y=0;y<mH+2;y++)

Modified: antargis/branches/branch_2d/src/height_map.h
===================================================================
--- antargis/branches/branch_2d/src/height_map.h	2007-05-02 18:19:49 UTC (rev 1081)
+++ antargis/branches/branch_2d/src/height_map.h	2007-05-02 19:04:59 UTC (rev 1082)
@@ -81,6 +81,8 @@
 
   Scene *getScene();
 
+  /// override this function to include another terrain-mesh-type (like 2d-terrain)
+  virtual void initTerrainMesh();
 
  private:
 

Modified: antargis/branches/branch_2d/src/nantmarker.hh
===================================================================
--- antargis/branches/branch_2d/src/nantmarker.hh	2007-05-02 18:19:49 UTC (rev 1081)
+++ antargis/branches/branch_2d/src/nantmarker.hh	2007-05-02 19:04:59 UTC (rev 1082)
@@ -3541,6 +3541,11 @@
  Data_Get_Struct($input,Terrain,b);
  $result=*b;
 }
+%typemap(directorout) TerrainBase {
+ TerrainBase *b;
+ Data_Get_Struct($input,TerrainBase,b);
+ $result=*b;
+}
 %typemap(directorout) TerrainPiece {
  TerrainPiece *b;
  Data_Get_Struct($input,TerrainPiece,b);

Modified: antargis/branches/branch_2d/src/terrain.cc
===================================================================
--- antargis/branches/branch_2d/src/terrain.cc	2007-05-02 18:19:49 UTC (rev 1081)
+++ antargis/branches/branch_2d/src/terrain.cc	2007-05-02 19:04:59 UTC (rev 1082)
@@ -4,6 +4,12 @@
 #include <ag_profiler.h>
 #include <ag_config.h>
 
+bool use3dTextures()
+{
+  return false;
+}
+
+
 //////////////////////////////////////////////////////////////////////////
 // TerrainPiece
 //////////////////////////////////////////////////////////////////////////
@@ -70,10 +76,19 @@
 
 	n=mMap->getNormal(sx,sy);
 
-	float texHeight=mMap->getTerrainScale(sx,sy);
+	if(use3dTextures())
+	  {
+	    float texHeight=mMap->getTerrainScale(sx,sy);
+	    
+	    tp3=AGVector3(-v[0]*texFactor3w,-v[1]*texFactor3w,texHeight);
+	    m3dArray.addVertex(v,white,n,tp3);
+	  }
+	else
+	  {
+	    tp=AGVector2(-v[0]*texFactor3w,-v[1]*texFactor3w);
+	    m3dArray.addVertex(v,white,n,tp);
+	  }
 
-        tp3=AGVector3(-v[0]*texFactor3w,-v[1]*texFactor3w,texHeight);
-        m3dArray.addVertex(v,white,n,tp3);
 
 	bb.include(v.dim3());
       }
@@ -133,8 +148,13 @@
   STACKTRACE;
   AGRenderContext c;
   c.setLighting(true);
-  c.setTexture(mTerrain->get3dTexture()->glTexture());
-  mTerrain->get3dTexture()->setFilter(GL_LINEAR,GL_LINEAR);
+  if(use3dTextures())
+    {
+      c.setTexture(mTerrain->get3dTexture()->glTexture());
+      mTerrain->get3dTexture()->setFilter(GL_LINEAR,GL_LINEAR);
+    }
+  else
+    c.setTexture(mTerrain->getGrassTexture()->glTexture());
 
   c.begin();
 
@@ -191,20 +211,63 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////
-// TerrainMesh
+// TerrainBase
 ////////////////////////////////////////////////////////////////////////////
 
 
+TerrainBase::TerrainBase(Scene *pScene,HeightMap &map):
+  mMap(&map),mScene(pScene)
+{
+  map.sigMapChanged.connect(slot(this,&TerrainBase::slotMapChanged));
+  map.sigMapChangedComplete.connect(slot(this,&TerrainBase::slotMapChangedComplete));
+}
+
+TerrainBase::~TerrainBase()
+{
+}
+
+bool TerrainBase::slotMapChanged(AGEvent *e)
+{
+  mapChanged();
+  return false;
+}
+bool TerrainBase::slotMapChangedComplete(AGEvent *e)
+{
+  mapChangedComplete();
+  return false;
+}
+
+
+Scene *TerrainBase::getScene()
+{
+  return mScene;
+}
+
+HeightMap *TerrainBase::getMap()
+{
+  return mMap;
+}
+
+void TerrainBase::mapChanged()
+{
+}
+
+void TerrainBase::mapChangedComplete()
+{
+}
+
+
+////////////////////////////////////////////////////////////////////////////
+// Terrain
+////////////////////////////////////////////////////////////////////////////
+
 Terrain::Terrain(Scene *pScene,HeightMap &map):
+  TerrainBase(pScene,map),
   m3D(getTextureCache()->get3D("data/textures/terrain/new3d.png",getTerrainDownScale(),getTerrainDownScaleZ())),
-  mGrass(getTextureCache()->get("data/textures/terrain/grass4.png")),
-  mMap(&map),
-  mScene(pScene)
+  mGrass(getTextureCache()->get("data/textures/terrain/grass4.png"))
 {
   init();
 
-  map.sigMapChanged.connect(slot(this,&Terrain::slotMapChanged));
-  map.sigMapChangedComplete.connect(slot(this,&Terrain::slotMapChangedComplete));
 }
 
 void Terrain::init()
@@ -213,11 +276,13 @@
   int tilesize=16;
   size_t tiles=0;
 
-  for(y=0; y<mMap->getH();y+=tilesize)
-    for(x=0;x<mMap->getW();x+=tilesize)
+  HeightMap *map=getMap();
+
+  for(y=0; y<map->getH();y+=tilesize)
+    for(x=0;x<map->getW();x+=tilesize)
       {
-	TerrainPiece *t=new TerrainPiece(getScene(),this,*mMap,x,y,tilesize,tilesize,AGVector4(x,y,0,0),getTerrainTriangleSize());
-	WaterPiece *w=new WaterPiece(getScene(),*mMap,x,y,tilesize,tilesize,AGVector4(x,y,0,0));
+	TerrainPiece *t=new TerrainPiece(getScene(),this,*map,x,y,tilesize,tilesize,AGVector4(x,y,0,0),getTerrainTriangleSize());
+	WaterPiece *w=new WaterPiece(getScene(),*map,x,y,tilesize,tilesize,AGVector4(x,y,0,0));
 	pieces.push_front(t); // at least it's correct at the beginning
 	water.push_front(w);
 	mNodes.push_back(w);
@@ -225,8 +290,8 @@
 	tiles++;
       }
 
-  w=mMap->getW();
-  h=mMap->getH();
+  w=map->getW();
+  h=map->getH();
 }
 
 void Terrain::mapChangedComplete()
@@ -273,18 +338,3 @@
   return &mGrass;
 }
 
-bool Terrain::slotMapChanged(AGEvent *e)
-{
-  mapChanged();
-  return false;
-}
-bool Terrain::slotMapChangedComplete(AGEvent *e)
-{
-  mapChangedComplete();
-  return false;
-}
-
-Scene *Terrain::getScene()
-{
-  return mScene;
-}

Modified: antargis/branches/branch_2d/src/terrain.h
===================================================================
--- antargis/branches/branch_2d/src/terrain.h	2007-05-02 18:19:49 UTC (rev 1081)
+++ antargis/branches/branch_2d/src/terrain.h	2007-05-02 19:04:59 UTC (rev 1082)
@@ -55,13 +55,40 @@
   VertexArray m3dArray;
 };
 
+
+class TerrainBase
+{
+ public:
+  TerrainBase(Scene *pScene,HeightMap &map);
+  virtual ~TerrainBase();
+
+  HeightMap *getMap();
+  Scene *getScene();
+
+  /// some parts of the map are changed
+  virtual void mapChanged();
+  /// the whole map is changed - so better take care of this (texture-upload instead of repainting on GPU)
+  virtual void mapChangedComplete();
+
+
+  virtual bool slotMapChanged(AGEvent *e);
+  virtual bool slotMapChangedComplete(AGEvent *e);
+
+
+ private:
+  /// the height-map
+  HeightMap *mMap;
+  
+  Scene *mScene;
+};
+
 /**
    In a game-world there exists exactly one Terrain-object.
    This object holds references to all water- and terrain-pieces, so
    that in case the terrain changes these will be changed,too.
 
 */
-class Terrain
+class Terrain:public TerrainBase
 {
   // Some containers for all the meshes
   typedef std::list<TerrainPiece*> Pieces;
@@ -79,30 +106,20 @@
   /// some (currently not used) grass-texture
   AGTexture mGrass;
 
-  /// the height-map
-  HeightMap *mMap;
-  
-  Scene *mScene;
 
 public:
   Terrain(Scene *pScene,HeightMap &map);
 
   virtual ~Terrain();
 
+  AGTexture *get3dTexture();
+  AGTexture *getGrassTexture();
+
   /// some parts of the map are changed
   virtual void mapChanged();
   /// the whole map is changed - so better take care of this (texture-upload instead of repainting on GPU)
   virtual void mapChangedComplete();
 
-
-  virtual bool slotMapChanged(AGEvent *e);
-  virtual bool slotMapChangedComplete(AGEvent *e);
-
-  AGTexture *get3dTexture();
-  AGTexture *getGrassTexture();
-
-  Scene *getScene();
-
  private:
   void init();
 };



From davidkamphausen at mail.berlios.de  Sat May  5 12:56:21 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 5 May 2007 12:56:21 +0200
Subject: [Antargis-svn] r1083 - in antargis/branches/branch_2d:
	data/textures/2d data/textures/2d/terrain gui/src ruby
	ruby/tests src
Message-ID: <200705051056.l45AuLkl008848@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-05 12:55:33 +0200 (Sat, 05 May 2007)
New Revision: 1083

Added:
   antargis/branches/branch_2d/data/textures/2d/arrow.png
   antargis/branches/branch_2d/data/textures/2d/bakery.png
   antargis/branches/branch_2d/data/textures/2d/boat.png
   antargis/branches/branch_2d/data/textures/2d/buildingsite.png
   antargis/branches/branch_2d/data/textures/2d/coach.png
   antargis/branches/branch_2d/data/textures/2d/druid.png
   antargis/branches/branch_2d/data/textures/2d/dwelling.png
   antargis/branches/branch_2d/data/textures/2d/farm.png
   antargis/branches/branch_2d/data/textures/2d/field.png
   antargis/branches/branch_2d/data/textures/2d/fire.png
   antargis/branches/branch_2d/data/textures/2d/fish.png
   antargis/branches/branch_2d/data/textures/2d/fishing_hut.png
   antargis/branches/branch_2d/data/textures/2d/floor_deco.png
   antargis/branches/branch_2d/data/textures/2d/floor_gravel.png
   antargis/branches/branch_2d/data/textures/2d/graph.png
   antargis/branches/branch_2d/data/textures/2d/graph2.png
   antargis/branches/branch_2d/data/textures/2d/grave.png
   antargis/branches/branch_2d/data/textures/2d/grave_hero.png
   antargis/branches/branch_2d/data/textures/2d/hero.png
   antargis/branches/branch_2d/data/textures/2d/impostor3.png
   antargis/branches/branch_2d/data/textures/2d/man.png
   antargis/branches/branch_2d/data/textures/2d/mill.png
   antargis/branches/branch_2d/data/textures/2d/mine.png
   antargis/branches/branch_2d/data/textures/2d/rip.png
   antargis/branches/branch_2d/data/textures/2d/sack.png
   antargis/branches/branch_2d/data/textures/2d/sheep.png
   antargis/branches/branch_2d/data/textures/2d/smith.png
   antargis/branches/branch_2d/data/textures/2d/stone.png
   antargis/branches/branch_2d/data/textures/2d/terrain/basic_grass2.png
   antargis/branches/branch_2d/data/textures/2d/terrain/full_grass.png
   antargis/branches/branch_2d/data/textures/2d/terrain/full_grass2.png
   antargis/branches/branch_2d/data/textures/2d/terrain/full_water.png
   antargis/branches/branch_2d/data/textures/2d/tower.png
   antargis/branches/branch_2d/data/textures/2d/townhall.png
   antargis/branches/branch_2d/data/textures/2d/tree.png
   antargis/branches/branch_2d/data/textures/2d/twig.png
   antargis/branches/branch_2d/data/textures/2d/well.png
   antargis/branches/branch_2d/data/textures/2d/wolf.png
   antargis/branches/branch_2d/data/textures/2d/workshop.png
   antargis/branches/branch_2d/ruby/terrain_2d.rb
   antargis/branches/branch_2d/ruby/two_d_app.rb
Modified:
   antargis/branches/branch_2d/gui/src/ag_debug.h
   antargis/branches/branch_2d/gui/src/ag_main.h
   antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc
   antargis/branches/branch_2d/gui/src/ag_sdlsurface.h
   antargis/branches/branch_2d/ruby/ant_fir.rb
   antargis/branches/branch_2d/ruby/ant_fire.rb
   antargis/branches/branch_2d/ruby/ant_grass.rb
   antargis/branches/branch_2d/ruby/ant_ring.rb
   antargis/branches/branch_2d/ruby/ant_workshop.rb
   antargis/branches/branch_2d/ruby/antargislib.rb
   antargis/branches/branch_2d/ruby/tests/scene_2d.rb
   antargis/branches/branch_2d/ruby/view.rb
   antargis/branches/branch_2d/src/height_map.cc
   antargis/branches/branch_2d/src/height_map.h
   antargis/branches/branch_2d/src/map.cc
   antargis/branches/branch_2d/src/map.h
   antargis/branches/branch_2d/src/mesh_2d.cc
   antargis/branches/branch_2d/src/mesh_2d.h
   antargis/branches/branch_2d/src/minimap.cc
   antargis/branches/branch_2d/src/minimap.h
   antargis/branches/branch_2d/src/nantmarker.hh
   antargis/branches/branch_2d/src/scene.cc
   antargis/branches/branch_2d/src/scene_2d.cc
   antargis/branches/branch_2d/src/scene_2d.h
   antargis/branches/branch_2d/src/terrain.cc
   antargis/branches/branch_2d/src/terrain.h
   antargis/branches/branch_2d/src/water.cc
   antargis/branches/branch_2d/src/water.h
Log:
* improvements concercing 2d and added missing files


Added: antargis/branches/branch_2d/data/textures/2d/arrow.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/arrow.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/bakery.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/bakery.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/boat.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/boat.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/buildingsite.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/buildingsite.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/coach.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/coach.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/druid.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/druid.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/dwelling.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/dwelling.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/farm.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/farm.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/field.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/field.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/fire.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/fire.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/fish.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/fish.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/fishing_hut.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/fishing_hut.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/floor_deco.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/floor_deco.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/floor_gravel.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/floor_gravel.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/graph.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/graph.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/graph2.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/graph2.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/grave.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/grave.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/grave_hero.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/grave_hero.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/hero.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/hero.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/impostor3.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/impostor3.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/mill.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/mill.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/mine.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/mine.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/rip.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/rip.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/sack.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/sack.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/sheep.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/sheep.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/smith.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/smith.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/stone.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/stone.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/terrain/basic_grass2.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/terrain/basic_grass2.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/terrain/full_grass.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/terrain/full_grass.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/terrain/full_grass2.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/terrain/full_grass2.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/terrain/full_water.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/terrain/full_water.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/tower.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/tower.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/townhall.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/townhall.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/tree.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/tree.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/twig.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/twig.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/well.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/well.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/wolf.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/wolf.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/workshop.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/workshop.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: antargis/branches/branch_2d/gui/src/ag_debug.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_debug.h	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/gui/src/ag_debug.h	2007-05-05 10:55:33 UTC (rev 1083)
@@ -99,8 +99,8 @@
 void agRaise(const std::string &s);
 
 #ifndef __WIN32__
-//#undef assert
-//#define assert(x) {if(!(x)) agRaise((::toString("assert failed ")+LINEINFO(__STRING(x))).c_str()); }
+#undef assert
+#define assert(x) {if(!(x)) agRaise((::toString("assert failed ")+LINEINFO(__STRING(x))).c_str()); }
 #endif
 
 #define Assert(x) assert(x)

Modified: antargis/branches/branch_2d/gui/src/ag_main.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_main.h	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/gui/src/ag_main.h	2007-05-05 10:55:33 UTC (rev 1083)
@@ -97,6 +97,7 @@
 // from ag_debug
 size_t getDebugLevel();
 void setDebugLevel(size_t t);
+void setRubyRaising(bool flag);
 
 
 #endif

Modified: antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc	2007-05-05 10:55:33 UTC (rev 1083)
@@ -70,6 +70,15 @@
 		      (int)(pRect.y()+pRect.h()-1),
 		      c.mapRGB(s->format),c.a);
 }
+
+void AGSDLScreen::fillRects(const std::vector<std::pair<AGRect2,AGVector4> > &pRects)
+{
+  for(std::vector<std::pair<AGRect2,AGVector4> >::const_iterator i=pRects.begin();i!=pRects.end();i++)
+    {
+      fillRect(i->first,i->second);
+    }
+}
+
 void AGSDLScreen::blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc)
 {
   SDL_Rect sr=pSrc.sdl();

Modified: antargis/branches/branch_2d/gui/src/ag_sdlsurface.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_sdlsurface.h	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/gui/src/ag_sdlsurface.h	2007-05-05 10:55:33 UTC (rev 1083)
@@ -35,6 +35,7 @@
   virtual AGRect2 getRect() const;
 
   virtual void fillRect(const AGRect2 &pRect,const AGColor &c);
+  virtual void fillRects(const std::vector<std::pair<AGRect2,AGVector4> > &pRects);
   virtual void drawLine(const AGVector2 &p0,const AGVector2 &p1,const AGColor &c);
 
   virtual void drawGradientAlpha(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr);

Modified: antargis/branches/branch_2d/ruby/ant_fir.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_fir.rb	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/ruby/ant_fir.rb	2007-05-05 10:55:33 UTC (rev 1083)
@@ -85,6 +85,10 @@
 	
 protected
 	def setupMesh
-		setMesh(makeBirchTreeMesh)
+		if MyAntargislib.opengl
+			setMesh(makeBirchTreeMesh)
+		else
+			puts "NO BIRCHES WITHOUT GL ATM"
+		end
 	end
 end

Modified: antargis/branches/branch_2d/ruby/ant_fire.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_fire.rb	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/ruby/ant_fire.rb	2007-05-05 10:55:33 UTC (rev 1083)
@@ -3,23 +3,25 @@
 		super
 		mp=AGVector3.new(0,0,0)
 		setMesh(:on)
-# 		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/fire.ant2",0.3,"data/textures/models/fire.png"),AGVector4.new(0,0,0),0)
-# 		setMesh(mesh)
-		@smokeMesh=Smoke.new(getMap.getScene,4)
-		addMesh(@smokeMesh,mp)
-		smoke=Smoke.new(getMap.getScene,40)
-		smoke.setFire(true)
-		smoke.setMaxTime(0.8)
-		addMesh(smoke,mp)
+		if MyAntargislib.opengl
+			@smokeMesh=Smoke.new(getMap.getScene,4)
+			addMesh(@smokeMesh,mp)
+			smoke=Smoke.new(getMap.getScene,40)
+			smoke.setFire(true)
+			smoke.setMaxTime(0.8)
+			addMesh(smoke,mp)
+		end
 		setPos(AGVector2.new(p.x,p.y))
 		@enabled=true
 	end
 	def disable
 		setMesh(:off)
-		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/fire.ant2",0.3,"data/textures/models/fire2.png"),AGVector4.new(0,0,0),0))
-		getMap.getScene.addNode(@smokeMesh) # FIXME: dirty hack - solve this another way!!!
-		addMesh(@smokeMesh,AGVector3.new(0,0,0))
-		@smokeMesh.setEnabled(false)
+		if MyAntargislib.opengl
+			#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/fire.ant2",0.3,"data/textures/models/fire2.png"),AGVector4.new(0,0,0),0))
+			getMap.getScene.addNode(@smokeMesh) # FIXME: dirty hack - solve this another way!!!
+			addMesh(@smokeMesh,AGVector3.new(0,0,0))
+			@smokeMesh.setEnabled(false)
+		end
 		@enabled=false
 	end
 	def loadXML(n)

Modified: antargis/branches/branch_2d/ruby/ant_grass.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_grass.rb	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/ruby/ant_grass.rb	2007-05-05 10:55:33 UTC (rev 1083)
@@ -195,7 +195,11 @@
 	
 	private
 	def setupMesh
-		setMesh(makeGrassMesh(@size))
+		if MyAntargislib.opengl
+			setMesh(makeGrassMesh(@size))
+		else
+			puts "PROBLEM: NO GRASS WITHOUT GL!"
+		end
 	end
 end
 
@@ -219,7 +223,11 @@
 	
 	private
 	def setupMesh
-		setMesh(makeBushMesh(@size*3))
+		if MyAntargislib.opengl
+			setMesh(makeBushMesh(@size*3))
+		else
+			puts "PROBLEM: NO GRASS WITHOUT GL!"
+		end
 	end
 end
 

Modified: antargis/branches/branch_2d/ruby/ant_ring.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_ring.rb	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/ruby/ant_ring.rb	2007-05-05 10:55:33 UTC (rev 1083)
@@ -78,12 +78,14 @@
 
 
 def makeRingMesh
+	return AntModels.createModel(:sack) if not opengl # FIXME
 	mesh=ColoredMesh.new(getMap.getScene,RingData.getRingData,AGVector4.new(0,0,0,0),0)
 	mesh.setOrder(RING_Z)
 	return mesh
 end
 
 def makeBigRingMesh
+	return AntModels.createModel(:sack) if not opengl # FIXME
 	mesh=ColoredMesh.new(getMap.getScene,RingData.getRingData(4),AGVector4.new(0,0,0,0),0)
 	mesh.setOrder(RING_Z)
 	return mesh

Modified: antargis/branches/branch_2d/ruby/ant_workshop.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_workshop.rb	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/ruby/ant_workshop.rb	2007-05-05 10:55:33 UTC (rev 1083)
@@ -43,8 +43,10 @@
 	def setupMesh
 		setMesh
 		p=AGVector3.new(-1.3,-1.2,2.2)
-		addMesh(@smokeMesh=Smoke.new(getMap.getScene,5),p)
-		checkSmoke
+		if opengl
+			addMesh(@smokeMesh=Smoke.new(getMap.getScene,5),p)
+			checkSmoke
+		end
 	end
 protected
 	

Modified: antargis/branches/branch_2d/ruby/antargislib.rb
===================================================================
--- antargis/branches/branch_2d/ruby/antargislib.rb	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/ruby/antargislib.rb	2007-05-05 10:55:33 UTC (rev 1083)
@@ -139,6 +139,8 @@
 					when "gui-test"
 						require 'ruby/tests/gui_tests.rb'
 						@@cursorEnabled=true
+					when "ruby-raise"
+						setRubyRaising(true)
 					when "help","h"
 						STDERR.puts "Possible options:
 	--help         show this help message
@@ -162,6 +164,7 @@
 	--debug-level=x
 
 	--nogl         disable GL-mode (3d-acceleration) - THIS IS NOT YET FULLY SUPPORTED!!
+	--ruby-raise   raise exceptions as ruby-exceptions
 	"
 	
 						exit
@@ -225,6 +228,9 @@
 	def MyAntargislib.demoMode
 		$demoMove
 	end
+	def MyAntargislib.opengl
+		@@opengl
+	end
 end
 
 def demoMode

Added: antargis/branches/branch_2d/ruby/terrain_2d.rb
===================================================================
--- antargis/branches/branch_2d/ruby/terrain_2d.rb	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/ruby/terrain_2d.rb	2007-05-05 10:55:33 UTC (rev 1083)
@@ -0,0 +1,40 @@
+class Terrain2D<TerrainBase
+	def initialize(scene,map)
+		super
+		@scene=scene
+		@map=map
+		createTiles
+	end
+
+	def createTiles
+		@textures={
+			:grass=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/full_grass.png")),
+			:grass2=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/full_grass2.png")),
+			:water=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/full_water.png"))
+		}
+		@meshdata={}
+		@textures.each{|k,v|
+			@meshdata[k]=Mesh2DData.new(v)
+		}
+
+		(0..(@map.getW/4-2)).each{|x|
+			(0..(@map.getH/2-1)).each{|y|
+				ix=x
+				iy=y
+				ix*=4
+				iy*=2
+				v=AGVector4.new(ix,iy,0,1)
+				t=:grass
+				if @map.getHeight(ix+2,iy+1)<0
+					t=:water
+				end
+# 				if x+y>5
+# 					t=:grass2
+# 				end
+				mesh=Mesh2D.new(@scene, at meshdata[t],v,0)
+				@scene.addNode(mesh)
+				mesh.setOrder(TERRAIN_Z)
+			}
+		}
+	end
+end

Modified: antargis/branches/branch_2d/ruby/tests/scene_2d.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/scene_2d.rb	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/ruby/tests/scene_2d.rb	2007-05-05 10:55:33 UTC (rev 1083)
@@ -8,9 +8,45 @@
 	t=AGTexture.new(AGSurface.load("data/textures/2d/#{type}.png"))
 	data=Mesh2DData.new(t)
 	mesh=Mesh2D.new(scene,data,AGVector4.new(0,0,0,1),0)
+	mesh.setOrder(TREE_Z)
+	mesh
 end
 
-class MyTerrain<SceneNode
+class MyTerrain #<TerrainBase
+	def initialize(scene,map)
+		#super
+		@scene=scene
+
+		createTiles
+	end
+
+	def createTiles
+		@textures={
+			:grass=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/basic_grass.png")),
+			:grass2=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/basic_grass2.png"))
+		}
+		@meshdata={}
+		@textures.each{|k,v|
+			@meshdata[k]=Mesh2DData.new(v)
+		}
+
+		(0..10).each{|x|
+			(0..100).each{|y|
+				ix=x*2+(y % 2)
+				iy=y
+				ix*=64
+				iy*=32
+				v=AGVector4.new(ix,iy,0,1)
+				t=:grass
+				if x+y>5
+					t=:grass2
+				end
+				mesh=Mesh2D.new(@scene, at meshdata[t],v,0)
+				@scene.addNode(mesh)
+				mesh.setOrder(TERRAIN_Z)
+			}
+		}
+	end
 end
 
 
@@ -19,10 +55,13 @@
 		super
 		@scene=Scene2D.new(r.width.to_i,r.height.to_i)
 		mesh=makeExampleMesh(@scene,:farm)
+		mesh.setPos(AGVector3.new(130,50,0))
 		@scene.addNode(mesh)
 		mesh=makeExampleMesh(@scene,:tree)
 		mesh.setPos(AGVector3.new(300,50,0))
 		@scene.addNode(mesh)
+
+		@terrain=MyTerrain.new(@scene,nil)
 	end
 	def draw(p)
 		@scene.setPainter(p)

Added: antargis/branches/branch_2d/ruby/two_d_app.rb
===================================================================
--- antargis/branches/branch_2d/ruby/two_d_app.rb	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/ruby/two_d_app.rb	2007-05-05 10:55:33 UTC (rev 1083)
@@ -0,0 +1,121 @@
+require 'terrain_2d.rb'
+
+class Scene2D
+	def getPickTriangles
+		0
+	end
+	def getTriangles
+		0
+	end
+	def getDrawnMeshes
+		0
+	end
+end
+
+class GLApp<AGApplication
+	def initialize(w,h)
+		super()
+		@scene=Scene2D.new(w,h)
+		@submain=nil
+	end
+
+	def draw
+		p=AGPainter.new
+		@scene.setPainter(p)
+		@scene.draw
+		@scene.discardPainter
+		super
+	end
+	def getScene
+		@scene
+	end
+	def setCamera(p)
+		@scene.setCamera(AGVector4.new(p.x,p.y,0))
+	end
+	def eventFrame(t)
+	end
+# 	def eventMouseMotion(e)
+# 		super
+# 	end
+	def eventKeyDown(e)
+		super
+	end
+# 	def eventMouseButtonDown(e)
+# 		super
+# 	end
+# 	def eventMouseButtonUp(e)
+# 		super
+# 	end
+
+	def eventMouseButtonDown(e)
+		#raise 1
+		case e.getButton
+			when 1
+				@mousePos=e.getMousePosition
+		end
+		@mayclick=true
+		super
+	end
+	def eventMouseButtonUp(e)
+		case e.getButton
+			when 1
+				@mousePos=nil
+		end
+		if @mayclick
+			nodes=tryClick(e.getMousePosition)
+			nodes.each{|n|
+				puts "NODE:"+(getMap.getEntity(n).to_s)
+			}
+			eventClick(nodes,e.getButton)
+		end
+		super
+	end
+	def eventMouseMotion(e)
+		@mayclick=false
+		if @mousePos
+			diff=e.getMousePosition- at mousePos
+			diff=diff*0.03
+			@mousePos=e.getMousePosition
+			p=@scene.getCamera.dim2+AGVector2.new(-diff[0],diff[1])
+			@scene.setCamera(AGVector4.new(p[0],p[1],0,1))
+			#queryRedraw
+		end
+		super
+	end
+	private
+	def tryClick(pos)
+		nodes=@scene.pick(pos.x,pos.y,1,1)	
+	end
+end
+
+require 'map.rb'
+
+class AntRubyMap
+	def initTerrainMesh
+		setTerrain(Terrain2D.new(getScene,self))
+	end
+end
+
+
+require 'ant_models.rb'
+
+module AntModels
+	def AntModels.createModel(entityType,subType=nil,angle=nil)
+		trace
+		type=entityType
+		t=AGTexture.new(AGSurface.load("data/textures/2d/#{type}.png"))
+		data=Mesh2DData.new(t)
+		mesh=Mesh2D.new(getMap.getScene,data,AGVector4.new(0,0,0,1),0)
+		mesh.setOrder(TREE_Z)
+		mesh
+	end
+end
+
+
+# some hacks
+class Mesh2D
+	def setRingColor(c)
+	end
+	def setAnimation(a)
+	end
+end
\ No newline at end of file

Modified: antargis/branches/branch_2d/ruby/view.rb
===================================================================
--- antargis/branches/branch_2d/ruby/view.rb	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/ruby/view.rb	2007-05-05 10:55:33 UTC (rev 1083)
@@ -28,6 +28,10 @@
 require 'ant_inventory.rb'
 require 'ant_energy.rb'
 
+if (not MyAntargislib.opengl)
+	require 'two_d_app.rb'
+end
+
 class AntRubyView <GLApp
 	def initialize(w,h)
 		super(w,h)

Modified: antargis/branches/branch_2d/src/height_map.cc
===================================================================
--- antargis/branches/branch_2d/src/height_map.cc	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/height_map.cc	2007-05-05 10:55:33 UTC (rev 1083)
@@ -11,7 +11,7 @@
 
 std::vector<float> genSomeHeights(int mW,int mH,float mMaxHeight);
 
-HeightMap::HeightMap(Scene *pScene,int w,int h):
+HeightMap::HeightMap(SceneBase *pScene,int w,int h):
   sigMapChanged(this,"mapChanged"),
   sigMapChangedComplete(this,"mapChangedComplete"),
   mTerrainTypes(LASTTERRAIN+1),
@@ -25,7 +25,7 @@
     mTerrainTypes[TerrainType(t)]=genSomeHeights(w+2,h+2,1);
 
   mTerrain=0;
-  initTerrainMesh();
+  //  initTerrainMesh();
 
 
   setTerrainScale(WATER,0);
@@ -49,7 +49,14 @@
     mTerrain=new Terrain(mScene,*this);
 }
 
+void HeightMap::setTerrain(TerrainBase *pTerrain)
+{
+  assert(pTerrain);
+  assert(!mTerrain);
+  mTerrain=pTerrain;
+}
 
+
 void HeightMap::setHeight(float height)
 {
   for(size_t y=0;y<mH+2;y++)
@@ -273,6 +280,8 @@
 	}
     }
   
+  checkTerrain();
+  
   // compete change
   if(mTerrain)
     mTerrain->mapChangedComplete();
@@ -294,8 +303,11 @@
   for(int t=FIRSTTERRAIN;t<LASTTERRAIN; t++)
     mTerrainTypes[TerrainType(t)]=genSomeHeights(w+2,h+2,1);
   
+  checkTerrain();
+
   // compete change
-  mTerrain->mapChangedComplete();
+  if(mTerrain)
+    mTerrain->mapChangedComplete();
   //  mTerrain->addToScenes();
   mChanges=0;
   mChangeRect=AGRect2(AGVector2(),AGVector2());
@@ -565,7 +577,7 @@
   return s1*(1-mean)+s2*mean;
 }
 
-Scene *HeightMap::getScene()
+SceneBase *HeightMap::getScene()
 {
   return mScene;
 }
@@ -606,3 +618,15 @@
     }
   return found;
 }
+
+void HeightMap::mark()
+{
+  if(mTerrain)
+    markObject(mTerrain);
+}
+
+void HeightMap::checkTerrain()
+{
+  if(!mTerrain)
+    initTerrainMesh();
+}

Modified: antargis/branches/branch_2d/src/height_map.h
===================================================================
--- antargis/branches/branch_2d/src/height_map.h	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/height_map.h	2007-05-05 10:55:33 UTC (rev 1083)
@@ -12,7 +12,7 @@
 class AntEntityPtr;
 class Scene;
 class Mesh;
-class Terrain;
+class TerrainBase;
 
 enum TerrainType { WATER=0, SAND, EARTH, GRASS, GRASS2, FOREST, ROCK, ROCK2, LASTTERRAIN};
 
@@ -21,7 +21,7 @@
 class HeightMap:public AGMessageObject
 {
  public:
-  HeightMap(Scene *pScene,int w,int h);
+  HeightMap(SceneBase *pScene,int w,int h);
   virtual ~HeightMap();
 
   // get status
@@ -79,13 +79,20 @@
   AGSignal sigMapChanged;
   AGSignal sigMapChangedComplete;
 
-  Scene *getScene();
+  SceneBase *getScene();
 
   /// override this function to include another terrain-mesh-type (like 2d-terrain)
   virtual void initTerrainMesh();
 
+  void mark();
+
+  /// to be used by initTerrainMesh() - not otherwise !!!
+  void setTerrain(TerrainBase *pTerrain);
+
  private:
 
+  void checkTerrain();
+
   void loadBinary(BinaryIn &s);
   void saveBinary(BinaryOut &s) const;
 
@@ -104,11 +111,11 @@
   AGRect2 mChangeRect;
   size_t mChanges;
 
-  Scene *mScene;
+  SceneBase *mScene;
 
  protected:
 
-  Terrain *mTerrain;
+  TerrainBase *mTerrain;
   AGString mName;
 };
 

Modified: antargis/branches/branch_2d/src/map.cc
===================================================================
--- antargis/branches/branch_2d/src/map.cc	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/map.cc	2007-05-05 10:55:33 UTC (rev 1083)
@@ -44,7 +44,7 @@
   return myAntargisMap;
 }
 
-AntMap::AntMap(Scene *pScene,int w,int h):
+AntMap::AntMap(SceneBase *pScene,int w,int h):
   HeightMap(pScene,w,h),
   mEntQuad(new QuadTree<AntEntity>(AGRect2(0,0,w,h))),
   mHeuristicFunction(0)
@@ -433,6 +433,17 @@
   return 0;
 }
 
+AntEntity *AntMap::getEntity(const Mesh2D &pMesh)
+{
+  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+    {
+      AntEntity::Meshes meshes=(*i)->getMesh();
+      if(std::find(meshes.begin(),meshes.end(),&pMesh)!=meshes.end())
+	//      if((*i)->getMesh()==&pMesh)
+	return *i;
+    }
+  return 0;
+}
 
 
 

Modified: antargis/branches/branch_2d/src/map.h
===================================================================
--- antargis/branches/branch_2d/src/map.h	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/map.h	2007-05-05 10:55:33 UTC (rev 1083)
@@ -37,13 +37,14 @@
 class QuadTree;
 
 class AnimMesh;
+class Mesh2D;
 
 class AntMap:public HeightMap
 {
  public:
   typedef std::list<AntEntity*> EntityList;
 
-  AntMap(Scene *pScene,int w,int h);
+  AntMap(SceneBase *pScene,int w,int h);
   ~AntMap();
   
   virtual void insertEntity(AntEntity *e);
@@ -62,6 +63,7 @@
 
   AntEntity *getEntity(const Mesh &pMesh);
   AntEntity *getEntity(const AnimMesh &pMesh);
+  AntEntity *getEntity(const Mesh2D &pMesh);
   AntEntity *getEntity(int id) const;
   AntEntity *getByName(const AGString &pName);
 

Modified: antargis/branches/branch_2d/src/mesh_2d.cc
===================================================================
--- antargis/branches/branch_2d/src/mesh_2d.cc	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/mesh_2d.cc	2007-05-05 10:55:33 UTC (rev 1083)
@@ -17,20 +17,31 @@
 
 void Mesh2D::draw()
 {
-  //FIXME: drawing
   Scene2D *s=dynamic_cast<Scene2D*>(getScene());
   assert(s);
   AGPainter *painter=s->getPainter();
 
   assert(painter);
+
+  AGRect2 r=getDrawingRect();
   AGTexture *t=mData->getTexture();
+
+  //  cdebug("r:"<<r);
+  painter->blit(*t,r);
+}
+
+AGRect2 Mesh2D::getDrawingRect()
+{
+  Scene2D *s=dynamic_cast<Scene2D*>(getScene());
+  assert(s);
+
+  AGTexture *t=mData->getTexture();
   AGVector2 middle(s->getPosition(getPos()));
   float w=t->width();
   float h=t->height();
   AGRect2 r(middle.getX()-w/2,middle.getY()-h/2,w,h);
 
-  //  cdebug("r:"<<r);
-  painter->blit(*t,r);
+  return r;
 }
 
 AGVector4 Mesh2D::lineHit(const AGLine3 &pLine) const
@@ -60,3 +71,16 @@
 {
   markObject(mData);
 }
+
+bool Mesh2D::hit(const AGVector2 &screenPos)
+{
+  AGRect2 dRect=getDrawingRect();
+  if(dRect.contains(screenPos))
+    {
+      // check if texture is !=transparent there
+      AGVector2 p=screenPos-dRect.getV0();
+      return mData->getTexture()->getPixel(p[0],p[1]).a>10; // some threshold here
+      
+    }
+  return false;
+}

Modified: antargis/branches/branch_2d/src/mesh_2d.h
===================================================================
--- antargis/branches/branch_2d/src/mesh_2d.h	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/mesh_2d.h	2007-05-05 10:55:33 UTC (rev 1083)
@@ -26,7 +26,12 @@
 
   void mark();
 
+  bool hit(const AGVector2 &screenPos);
+
  public:
+
+  AGRect2 getDrawingRect();
+
   Mesh2DData *mData;
 };
 

Modified: antargis/branches/branch_2d/src/minimap.cc
===================================================================
--- antargis/branches/branch_2d/src/minimap.cc	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/minimap.cc	2007-05-05 10:55:33 UTC (rev 1083)
@@ -252,7 +252,7 @@
       mapChangedComplete(0);
     }
 }
-void MiniMap::setScene(Scene *pScene)
+void MiniMap::setScene(SceneBase *pScene)
 {
   mScene=pScene;
 }

Modified: antargis/branches/branch_2d/src/minimap.h
===================================================================
--- antargis/branches/branch_2d/src/minimap.h	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/minimap.h	2007-05-05 10:55:33 UTC (rev 1083)
@@ -5,7 +5,7 @@
 #include <ag_widget.h>
 #include <ag_texture.h>
 
-class Scene;
+class SceneBase;
 
 /**
    MiniMap is the small map in lower corner.
@@ -34,7 +34,7 @@
   void draw(AGPainter &p);
 
   void setMap(AntMap *pMap);
-  void setScene(Scene *pScene);
+  void setScene(SceneBase *pScene);
 
   virtual bool eventMouseClick(AGEvent *m);
   virtual bool eventMouseButtonDown(AGEvent *m);
@@ -52,7 +52,7 @@
 
   float mMapBorder;
   AntMap *mMap;
-  Scene *mScene;
+  SceneBase *mScene;
   AGTexture *mTexture;
   AGSurface mSurface;
 };

Modified: antargis/branches/branch_2d/src/nantmarker.hh
===================================================================
--- antargis/branches/branch_2d/src/nantmarker.hh	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/nantmarker.hh	2007-05-05 10:55:33 UTC (rev 1083)
@@ -188,6 +188,16 @@
 	result->mRubyObject=true;
 }
 %markfunc Pathfinder "general_markfunc"
+%exception TerrainBase::TerrainBase {
+	$action
+	result->mRUBY=self;
+#ifdef GCDEBUG
+     result->mObjName=typeid(*result).name();
+     printf("%lx   %s\n",self,typeid(*result).name());
+#endif
+	result->mRubyObject=true;
+}
+%markfunc TerrainBase "general_markfunc"
 %exception AGComboBox::AGComboBox {
 	$action
 	result->mRUBY=self;
@@ -308,6 +318,16 @@
 	result->mRubyObject=true;
 }
 %markfunc AntImpostorData "general_markfunc"
+%exception Terrain::Terrain {
+	$action
+	result->mRUBY=self;
+#ifdef GCDEBUG
+     result->mObjName=typeid(*result).name();
+     printf("%lx   %s\n",self,typeid(*result).name());
+#endif
+	result->mRubyObject=true;
+}
+%markfunc Terrain "general_markfunc"
 %exception AGRadioGroup::AGRadioGroup {
 	$action
 	result->mRUBY=self;
@@ -1242,6 +1262,38 @@
  }
  else $input=Qnil;
 }
+%typemap(out) TerrainBase*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $result=$1->mRUBY;
+  else
+   {
+     if(false);
+else if(dynamic_cast<Terrain*>(result))
+  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Terrain,0);
+   else
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_TerrainBase,0);
+   }
+ }
+ else vresult=Qnil;
+}
+%typemap(directorin) TerrainBase*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $input=$1->mRUBY;
+  else
+   {
+     if(false);
+else if(dynamic_cast<Terrain*>($1))
+  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Terrain,0);
+   else
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_TerrainBase,0);
+   }
+ }
+ else $input=Qnil;
+}
 %typemap(out) AGComboBox*{
  if($1)
  {
@@ -1722,6 +1774,34 @@
  }
  else $input=Qnil;
 }
+%typemap(out) Terrain*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $result=$1->mRUBY;
+  else
+   {
+     if(false);
+   else
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Terrain,0);
+   }
+ }
+ else vresult=Qnil;
+}
+%typemap(directorin) Terrain*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $input=$1->mRUBY;
+  else
+   {
+     if(false);
+   else
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Terrain,0);
+   }
+ }
+ else $input=Qnil;
+}
 %typemap(out) AGRadioGroup*{
  if($1)
  {

Modified: antargis/branches/branch_2d/src/scene.cc
===================================================================
--- antargis/branches/branch_2d/src/scene.cc	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/scene.cc	2007-05-05 10:55:33 UTC (rev 1083)
@@ -13,47 +13,15 @@
 #include "quadtree.h"
 #include "ag_profiler.h"
 #include "ag_main.h"
+#include "mesh_sort.h"
 
 bool PickNode::operator<(const PickNode &n) const
 {
   return camDist<n.camDist;
 }
 
-/**
-   The class is for sorting purpose only. It provides the operator() function, that's needed
-   for the STL-sorting algorithms.
-   Here SceneNodes are sorted by their middle distance the camera.
-*/
-class SortDistance
-{
-  AGVector3 cam;
-public:
-  SortDistance(AGVector3 c):cam(c){}
 
-  bool operator()(const SceneNode *n1,const SceneNode *n2)
-  {
-    AGVector3 m1=const_cast<SceneNode*>(n1)->bbox().base+const_cast<SceneNode*>(n1)->bbox().dir*0.5;
-    AGVector3 m2=const_cast<SceneNode*>(n2)->bbox().base+const_cast<SceneNode*>(n2)->bbox().dir*0.5;
 
-    return (m1-cam).length2()<(m2-cam).length2();
-  }
-};
-
-/**
-   This is a sorting class, too. It sorts by the given "SortOrder" of the scene-nodes
-*/
-class SortOrder
-{
-public:
-  SortOrder(){}
-
-  bool operator()(const SceneNode *n1,const SceneNode *n2)
-  {
-    return n1->getOrder()<n2->getOrder();
-  }
-};
-
-
 Scene::Scene(int w,int h):
   SceneBase(w,h)
 {

Modified: antargis/branches/branch_2d/src/scene_2d.cc
===================================================================
--- antargis/branches/branch_2d/src/scene_2d.cc	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/scene_2d.cc	2007-05-05 10:55:33 UTC (rev 1083)
@@ -1,6 +1,8 @@
 #ifndef NO
 
 #include "scene_2d.h"
+#include "mesh_2d.h"
+#include "mesh_sort.h"
 #include <ag_debug.h>
 
 Scene2D::Scene2D(int w,int h):
@@ -17,17 +19,47 @@
   // FIXME
   
   NodeList nodeList=getCurrentNodes();
+  Nodes ns;
+  std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
 
+
+  sort(ns.begin(),ns.end(),SortOrder());
+
   //FIXME:sort!!
 
-  for(NodeList::iterator i=nodeList.begin();i!=nodeList.end();i++)
+  for(Nodes::iterator i=ns.begin();i!=ns.end();i++)
     (*i)->draw();
 }
 
 SceneBase::PickResult Scene2D::pick(float x,float y,float w,float h)
 {
-  throw std::runtime_error("FIXME");
-  return PickResult();
+  PickResult result;
+  NodeList nodeList=getCurrentNodes();
+
+  Nodes ns;
+  std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
+  sort(ns.begin(),ns.end(),SortOrder());
+
+  for(Nodes::reverse_iterator i=ns.rbegin();i!=ns.rend();i++)
+    {
+      Mesh2D*m=dynamic_cast<Mesh2D*>(*i);
+      if(m)
+	{
+	  if(m->hit(AGVector2(x,y)))
+	    {
+	      PickNode node;
+	      node.pos=m->getPos();
+	      node.node=m;
+	      node.camDist=0;
+
+	      cdebug("hit:"<<node.pos<<"   "<<node.node);
+	      result.push_back(node);
+	    }
+	}
+    }
+  
+
+  return result;
 }
 
 AGVector2 Scene2D::getPosition(const AGVector4 &v) const
@@ -36,10 +68,17 @@
   AGVector2 center(width()/2,height()/2);
   AGVector2 cam(mCamera.getPosition().dim2());
 
-  AGVector2 n=v.dim2()+center-cam;
+  AGVector2 n=v.dim2()-cam;
 
   //  cdebug("n:"<<n);
 
+  //  cdebug("n:"<<n);
+  n*=32;
+  //  cdebug("n:"<<n);
+
+  n+=center;
+
+
   return AGVector2(n[0],height()-n[1]);
 
   throw std::runtime_error("FIXME");

Modified: antargis/branches/branch_2d/src/scene_2d.h
===================================================================
--- antargis/branches/branch_2d/src/scene_2d.h	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/scene_2d.h	2007-05-05 10:55:33 UTC (rev 1083)
@@ -24,7 +24,7 @@
   */
   PickResult pick(float x,float y,float w,float h);
 
-  AntCamera &getCameraObject();
+  //  AntCamera &getCameraObject();
 
   AGVector2 getPosition(const AGVector4 &v) const;
 

Modified: antargis/branches/branch_2d/src/terrain.cc
===================================================================
--- antargis/branches/branch_2d/src/terrain.cc	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/terrain.cc	2007-05-05 10:55:33 UTC (rev 1083)
@@ -13,7 +13,7 @@
 //////////////////////////////////////////////////////////////////////////
 // TerrainPiece
 //////////////////////////////////////////////////////////////////////////
-TerrainPiece::TerrainPiece(Scene *pScene,Terrain *t,HeightMap &map,int xs,int ys,int w,int h,const AGVector4 &pPos,int scale):
+TerrainPiece::TerrainPiece(SceneBase *pScene,Terrain *t,HeightMap &map,int xs,int ys,int w,int h,const AGVector4 &pPos,int scale):
   SceneNode(pScene,AGVector4(),AGBox3()),
   mXs(xs),mYs(ys),mW(w),mH(h),
   mMap(&map)
@@ -215,7 +215,7 @@
 ////////////////////////////////////////////////////////////////////////////
 
 
-TerrainBase::TerrainBase(Scene *pScene,HeightMap &map):
+TerrainBase::TerrainBase(SceneBase *pScene,HeightMap &map):
   mMap(&map),mScene(pScene)
 {
   map.sigMapChanged.connect(slot(this,&TerrainBase::slotMapChanged));
@@ -238,7 +238,7 @@
 }
 
 
-Scene *TerrainBase::getScene()
+SceneBase *TerrainBase::getScene()
 {
   return mScene;
 }
@@ -261,7 +261,7 @@
 // Terrain
 ////////////////////////////////////////////////////////////////////////////
 
-Terrain::Terrain(Scene *pScene,HeightMap &map):
+Terrain::Terrain(SceneBase *pScene,HeightMap &map):
   TerrainBase(pScene,map),
   m3D(getTextureCache()->get3D("data/textures/terrain/new3d.png",getTerrainDownScale(),getTerrainDownScaleZ())),
   mGrass(getTextureCache()->get("data/textures/terrain/grass4.png"))

Modified: antargis/branches/branch_2d/src/terrain.h
===================================================================
--- antargis/branches/branch_2d/src/terrain.h	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/terrain.h	2007-05-05 10:55:33 UTC (rev 1083)
@@ -27,7 +27,7 @@
 class TerrainPiece:public SceneNode
 {
  public:
-  TerrainPiece(Scene *pScene,Terrain *t,HeightMap &map,int x,int y,int w,int h,const AGVector4 &pPos,int scale);
+  TerrainPiece(SceneBase *pScene,Terrain *t,HeightMap &map,int x,int y,int w,int h,const AGVector4 &pPos,int scale);
   virtual ~TerrainPiece();
 
   void draw();
@@ -56,14 +56,14 @@
 };
 
 
-class TerrainBase
+class TerrainBase:public AGRubyObject
 {
  public:
-  TerrainBase(Scene *pScene,HeightMap &map);
+  TerrainBase(SceneBase *pScene,HeightMap &map);
   virtual ~TerrainBase();
 
   HeightMap *getMap();
-  Scene *getScene();
+  SceneBase *getScene();
 
   /// some parts of the map are changed
   virtual void mapChanged();
@@ -79,7 +79,7 @@
   /// the height-map
   HeightMap *mMap;
   
-  Scene *mScene;
+  SceneBase *mScene;
 };
 
 /**
@@ -108,7 +108,7 @@
 
 
 public:
-  Terrain(Scene *pScene,HeightMap &map);
+  Terrain(SceneBase *pScene,HeightMap &map);
 
   virtual ~Terrain();
 

Modified: antargis/branches/branch_2d/src/water.cc
===================================================================
--- antargis/branches/branch_2d/src/water.cc	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/water.cc	2007-05-05 10:55:33 UTC (rev 1083)
@@ -28,7 +28,7 @@
 }
 
 
-WaterPiece::WaterPiece(Scene *pScene,HeightMap &map,int x,int y,int w,int h,const AGVector4 &pos):
+WaterPiece::WaterPiece(SceneBase *pScene,HeightMap &map,int x,int y,int w,int h,const AGVector4 &pos):
   SceneNode(pScene,pos,AGBox3()),
   mX(x),mY(y),mW(w),mH(h),mMap(&map)
 {

Modified: antargis/branches/branch_2d/src/water.h
===================================================================
--- antargis/branches/branch_2d/src/water.h	2007-05-02 19:04:59 UTC (rev 1082)
+++ antargis/branches/branch_2d/src/water.h	2007-05-05 10:55:33 UTC (rev 1083)
@@ -23,7 +23,7 @@
 {
   AGTexture tex;
  public:
-  WaterPiece(Scene *pScene,HeightMap &map,int x,int y,int w,int h,const AGVector4 &pos);
+  WaterPiece(SceneBase *pScene,HeightMap &map,int x,int y,int w,int h,const AGVector4 &pos);
   virtual ~WaterPiece();
 
   /// draw in normal mode



From davidkamphausen at mail.berlios.de  Sat May  5 12:57:22 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 5 May 2007 12:57:22 +0200
Subject: [Antargis-svn] r1084 - antargis/branches/branch_2d/src
Message-ID: <200705051057.l45AvM1V010881@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-05 12:57:21 +0200 (Sat, 05 May 2007)
New Revision: 1084

Added:
   antargis/branches/branch_2d/src/mesh_sort.h
Log:
* added missing file


Added: antargis/branches/branch_2d/src/mesh_sort.h
===================================================================
--- antargis/branches/branch_2d/src/mesh_sort.h	2007-05-05 10:55:33 UTC (rev 1083)
+++ antargis/branches/branch_2d/src/mesh_sort.h	2007-05-05 10:57:21 UTC (rev 1084)
@@ -0,0 +1,39 @@
+#ifndef MESH_SORT_H
+#define MESH_SORT_H
+
+/**
+   The class is for sorting purpose only. It provides the operator() function, that's needed
+   for the STL-sorting algorithms.
+   Here SceneNodes are sorted by their middle distance the camera.
+*/
+class SortDistance
+{
+  AGVector3 cam;
+public:
+  SortDistance(AGVector3 c):cam(c){}
+
+  bool operator()(const SceneNode *n1,const SceneNode *n2)
+  {
+    AGVector3 m1=const_cast<SceneNode*>(n1)->bbox().base+const_cast<SceneNode*>(n1)->bbox().dir*0.5;
+    AGVector3 m2=const_cast<SceneNode*>(n2)->bbox().base+const_cast<SceneNode*>(n2)->bbox().dir*0.5;
+
+    return (m1-cam).length2()<(m2-cam).length2();
+  }
+};
+
+/**
+   This is a sorting class, too. It sorts by the given "SortOrder" of the scene-nodes
+*/
+class SortOrder
+{
+public:
+  SortOrder(){}
+
+  bool operator()(const SceneNode *n1,const SceneNode *n2)
+  {
+    return n1->getOrder()<n2->getOrder();
+  }
+};
+
+
+#endif



From davidkamphausen at mail.berlios.de  Sat May  5 15:19:16 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 5 May 2007 15:19:16 +0200
Subject: [Antargis-svn] r1085 - in antargis/branches/branch_2d: ruby src
Message-ID: <200705051319.l45DJGxK027931@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-05 15:19:16 +0200 (Sat, 05 May 2007)
New Revision: 1085

Modified:
   antargis/branches/branch_2d/ruby/terrain_2d.rb
   antargis/branches/branch_2d/ruby/two_d_app.rb
   antargis/branches/branch_2d/ruby/view.rb
   antargis/branches/branch_2d/src/map.cc
Log:
* minor fixes


Modified: antargis/branches/branch_2d/ruby/terrain_2d.rb
===================================================================
--- antargis/branches/branch_2d/ruby/terrain_2d.rb	2007-05-05 10:57:21 UTC (rev 1084)
+++ antargis/branches/branch_2d/ruby/terrain_2d.rb	2007-05-05 13:19:16 UTC (rev 1085)
@@ -1,3 +1,6 @@
+class Terrain2DTile<Mesh2D
+end
+
 class Terrain2D<TerrainBase
 	def initialize(scene,map)
 		super
@@ -31,7 +34,7 @@
 # 				if x+y>5
 # 					t=:grass2
 # 				end
-				mesh=Mesh2D.new(@scene, at meshdata[t],v,0)
+				mesh=Terrain2DTile.new(@scene, at meshdata[t],v,0)
 				@scene.addNode(mesh)
 				mesh.setOrder(TERRAIN_Z)
 			}

Modified: antargis/branches/branch_2d/ruby/two_d_app.rb
===================================================================
--- antargis/branches/branch_2d/ruby/two_d_app.rb	2007-05-05 10:57:21 UTC (rev 1084)
+++ antargis/branches/branch_2d/ruby/two_d_app.rb	2007-05-05 13:19:16 UTC (rev 1085)
@@ -64,7 +64,8 @@
 		if @mayclick
 			nodes=tryClick(e.getMousePosition)
 			nodes.each{|n|
-				puts "NODE:"+(getMap.getEntity(n).to_s)
+        puts "NODE: #{n}(#{n.class})"
+        #puts "NODE:"+(getMap.getEntity(n).to_s)
 			}
 			eventClick(nodes,e.getButton)
 		end

Modified: antargis/branches/branch_2d/ruby/view.rb
===================================================================
--- antargis/branches/branch_2d/ruby/view.rb	2007-05-05 10:57:21 UTC (rev 1084)
+++ antargis/branches/branch_2d/ruby/view.rb	2007-05-05 13:19:16 UTC (rev 1085)
@@ -111,7 +111,7 @@
 		end
 		if list.length>0
 			first=list[0]
-			if [TerrainPiece,WaterPiece].member?(first.node.class)
+			if [TerrainPiece,WaterPiece,Terrain2DTile].member?(first.node.class)
 				eventMapClicked(first.pos,button)
 			else
 				eventEntitiesClicked(list,button)

Modified: antargis/branches/branch_2d/src/map.cc
===================================================================
--- antargis/branches/branch_2d/src/map.cc	2007-05-05 10:57:21 UTC (rev 1084)
+++ antargis/branches/branch_2d/src/map.cc	2007-05-05 13:19:16 UTC (rev 1085)
@@ -29,6 +29,7 @@
 #include "terrain.h"
 #include "quadtree.h"
 #include "anim_mesh.h"
+#include "mesh_2d.h"
 #include "ag_profiler.h"
 
 



From davidkamphausen at mail.berlios.de  Sat May  5 16:35:07 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 5 May 2007 16:35:07 +0200
Subject: [Antargis-svn] r1086 - in antargis/branches/branch_2d: gui/src src
Message-ID: <200705051435.l45EZ7qf000846@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-05 16:35:06 +0200 (Sat, 05 May 2007)
New Revision: 1086

Modified:
   antargis/branches/branch_2d/gui/src/ag_surface.cc
   antargis/branches/branch_2d/gui/src/ag_surface.h
   antargis/branches/branch_2d/src/interface.i
Log:
* minor changes for cutting surfaces


Modified: antargis/branches/branch_2d/gui/src/ag_surface.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_surface.cc	2007-05-05 13:19:16 UTC (rev 1085)
+++ antargis/branches/branch_2d/gui/src/ag_surface.cc	2007-05-05 14:35:06 UTC (rev 1086)
@@ -547,7 +547,48 @@
     }
 }
 
+/**
 
+ at returns hot-spot int the left upper corner
+
+*/
+AGVector2 AGSurface::shrink2Fit(int alphaThresh)
+{
+  int x0,x1;
+  int y0,y1;
+  int x,y;
+
+  x0=width();
+  y0=height();
+  x1=0;
+  y1=0;
+  for(y=0;y<height();y++)
+    for(x=0;x<width();x++)
+      {
+	if(getPixel(x,y).a>alphaThresh)
+	  {
+	    x0=std::min(x0,x);
+	    y0=std::min(y0,y);
+	    x1=std::max(x1,x);
+	    y1=std::max(y1,y);
+	  }
+      }
+  int nw=std::max(0,x1-x0+1);
+  int nh=std::max(0,y1-y0+1);
+
+  AGSurface n(nw,nh);
+
+  for(x=0;x<nw;x++)
+    for(y=0;y<nh;y++)
+      {
+	n.putPixel(x,y,getPixel(x+x0,y+y0));
+      }
+  (*this)=n;
+  return AGVector2(x0,x1);
+
+}
+
+
 void AGSurface::setDecryptor(AGDecryptor *pDecryptor)
 {
   mDecryptor=pDecryptor;

Modified: antargis/branches/branch_2d/gui/src/ag_surface.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_surface.h	2007-05-05 13:19:16 UTC (rev 1085)
+++ antargis/branches/branch_2d/gui/src/ag_surface.h	2007-05-05 14:35:06 UTC (rev 1086)
@@ -122,6 +122,8 @@
 
   static void setDecryptor(AGDecryptor *pDecryptor);
 
+  AGVector2 shrink2Fit(int alphaThresh=20);
+
  private:
 
   AGSurface(AGInternalSurface *i);

Modified: antargis/branches/branch_2d/src/interface.i
===================================================================
--- antargis/branches/branch_2d/src/interface.i	2007-05-05 13:19:16 UTC (rev 1085)
+++ antargis/branches/branch_2d/src/interface.i	2007-05-05 14:35:06 UTC (rev 1086)
@@ -67,6 +67,7 @@
 %include "std_string.i"
 %include "AGString.i"
 %include "std_vector.i"
+%include "std_pair.i"
 %include "std_map.i"
 
 %template(StringVector) std::vector<std::string>;
@@ -80,6 +81,7 @@
 %template(AGNodePList) std::vector<Node*>;
 %template(AGMatrixVector) std::vector<AGMatrix4>;
 %template(AGVector2List) std::vector<AGVector2>;
+%template(AGPairVec2Surface) std::pair<AGVector2,AGSurface*>;
 
 %include "antargisgui.h"
 



From davidkamphausen at mail.berlios.de  Sun May  6 10:03:47 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 6 May 2007 10:03:47 +0200
Subject: [Antargis-svn] r1087 - website/screenies
Message-ID: <200705060803.l4683l2E018087@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-06 10:03:45 +0200 (Sun, 06 May 2007)
New Revision: 1087

Added:
   website/screenies/nogltest_0.jpg
   website/screenies/nogltest_0_thumb.jpg
   website/screenies/nogltest_1.jpg
   website/screenies/nogltest_1_thumb.jpg
Log:
* added some screenies


Added: website/screenies/nogltest_0.jpg
===================================================================
(Binary files differ)


Property changes on: website/screenies/nogltest_0.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: website/screenies/nogltest_0_thumb.jpg
===================================================================
(Binary files differ)


Property changes on: website/screenies/nogltest_0_thumb.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: website/screenies/nogltest_1.jpg
===================================================================
(Binary files differ)


Property changes on: website/screenies/nogltest_1.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: website/screenies/nogltest_1_thumb.jpg
===================================================================
(Binary files differ)


Property changes on: website/screenies/nogltest_1_thumb.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From davidkamphausen at mail.berlios.de  Sun May  6 10:05:53 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 6 May 2007 10:05:53 +0200
Subject: [Antargis-svn] r1088 - website/screenshots
Message-ID: <200705060805.l4685rbY018237@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-06 10:05:52 +0200 (Sun, 06 May 2007)
New Revision: 1088

Modified:
   website/screenshots/view.inc.php
Log:
* added screenshots


Modified: website/screenshots/view.inc.php
===================================================================
--- website/screenshots/view.inc.php	2007-05-06 08:03:45 UTC (rev 1087)
+++ website/screenshots/view.inc.php	2007-05-06 08:05:52 UTC (rev 1088)
@@ -15,6 +15,10 @@
 function getScreenies()
 {
 	$screenies=array(
+		array("Additional included display for those without OpenGL-support (07-05-06)",array(
+			new Screenshot("screenies/nogltest_0","Some test screenshots"),
+			new Screenshot("screenies/nogltest_0","Some test screenshots"),
+		)),
 		array("Version 0.1.9 (06-09-20)",array(
 			new Screenshot("screenies/village","You can build your own village now."),
 			new Screenshot("screenies/new_terrain","Some new terrain textures."),



From davidkamphausen at mail.berlios.de  Sun May  6 10:06:50 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 6 May 2007 10:06:50 +0200
Subject: [Antargis-svn] r1089 - website/screenshots
Message-ID: <200705060806.l4686o1k018349@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-06 10:06:50 +0200 (Sun, 06 May 2007)
New Revision: 1089

Modified:
   website/screenshots/view.inc.php
Log:
* small fix


Modified: website/screenshots/view.inc.php
===================================================================
--- website/screenshots/view.inc.php	2007-05-06 08:05:52 UTC (rev 1088)
+++ website/screenshots/view.inc.php	2007-05-06 08:06:50 UTC (rev 1089)
@@ -17,7 +17,7 @@
 	$screenies=array(
 		array("Additional included display for those without OpenGL-support (07-05-06)",array(
 			new Screenshot("screenies/nogltest_0","Some test screenshots"),
-			new Screenshot("screenies/nogltest_0","Some test screenshots"),
+			new Screenshot("screenies/nogltest_1","Some other test screenshots"),
 		)),
 		array("Version 0.1.9 (06-09-20)",array(
 			new Screenshot("screenies/village","You can build your own village now."),



From davidkamphausen at mail.berlios.de  Sun May  6 12:04:16 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 6 May 2007 12:04:16 +0200
Subject: [Antargis-svn] r1090 - in antargis/branches/branch_2d: ruby src
Message-ID: <200705061004.l46A4GMW028689@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-06 12:04:15 +0200 (Sun, 06 May 2007)
New Revision: 1090

Modified:
   antargis/branches/branch_2d/ruby/two_d_app.rb
   antargis/branches/branch_2d/ruby/view.rb
   antargis/branches/branch_2d/src/height_map.cc
   antargis/branches/branch_2d/src/map.cc
Log:
* fixed a segfault


Modified: antargis/branches/branch_2d/ruby/two_d_app.rb
===================================================================
--- antargis/branches/branch_2d/ruby/two_d_app.rb	2007-05-06 08:06:50 UTC (rev 1089)
+++ antargis/branches/branch_2d/ruby/two_d_app.rb	2007-05-06 10:04:15 UTC (rev 1090)
@@ -12,7 +12,7 @@
 	end
 end
 
-class GLApp<AGApplication
+class AntBaseMapView<AGApplication
 	def initialize(w,h)
 		super()
 		@scene=Scene2D.new(w,h)
@@ -34,18 +34,10 @@
 	end
 	def eventFrame(t)
 	end
-# 	def eventMouseMotion(e)
+
+# 	def eventKeyDown(e)
 # 		super
 # 	end
-	def eventKeyDown(e)
-		super
-	end
-# 	def eventMouseButtonDown(e)
-# 		super
-# 	end
-# 	def eventMouseButtonUp(e)
-# 		super
-# 	end
 
 	def eventMouseButtonDown(e)
 		#raise 1

Modified: antargis/branches/branch_2d/ruby/view.rb
===================================================================
--- antargis/branches/branch_2d/ruby/view.rb	2007-05-06 08:06:50 UTC (rev 1089)
+++ antargis/branches/branch_2d/ruby/view.rb	2007-05-06 10:04:15 UTC (rev 1090)
@@ -27,12 +27,16 @@
 
 require 'ant_inventory.rb'
 require 'ant_energy.rb'
+require 'terrain_2d.rb' # used in 2d-display, but needed anywhere
 
 if (not MyAntargislib.opengl)
 	require 'two_d_app.rb'
+else
+	class AntBaseMapView<GLApp
+	end
 end
 
-class AntRubyView <GLApp
+class AntRubyView <AntBaseMapView
 	def initialize(w,h)
 		super(w,h)
 		@mousepos=AGVector2.new(200,200)

Modified: antargis/branches/branch_2d/src/height_map.cc
===================================================================
--- antargis/branches/branch_2d/src/height_map.cc	2007-05-06 08:06:50 UTC (rev 1089)
+++ antargis/branches/branch_2d/src/height_map.cc	2007-05-06 10:04:15 UTC (rev 1090)
@@ -40,7 +40,7 @@
 
 HeightMap::~HeightMap()
 {
-  delete mTerrain;
+  saveDelete(mTerrain);
 }
 
 void HeightMap::initTerrainMesh()

Modified: antargis/branches/branch_2d/src/map.cc
===================================================================
--- antargis/branches/branch_2d/src/map.cc	2007-05-06 08:06:50 UTC (rev 1089)
+++ antargis/branches/branch_2d/src/map.cc	2007-05-06 10:04:15 UTC (rev 1090)
@@ -465,7 +465,6 @@
   // mark to del, too, otherwise it crashes when tidying before move() is called
   for(i=mToDel.begin();i!=mToDel.end();i++)
     markObject(*i);
-  
 }
 
 



From davidkamphausen at mail.berlios.de  Mon May  7 21:01:06 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Mon, 7 May 2007 21:01:06 +0200
Subject: [Antargis-svn] r1091 - in antargis/branches/new_hl_jobs: . ruby src
Message-ID: <200705071901.l47J16dD015949@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-07 21:01:05 +0200 (Mon, 07 May 2007)
New Revision: 1091

Added:
   antargis/branches/new_hl_jobs/ruby/ai/
Modified:
   antargis/branches/new_hl_jobs/TODO
   antargis/branches/new_hl_jobs/ruby/ant_fire.rb
   antargis/branches/new_hl_jobs/ruby/ant_hero.rb
   antargis/branches/new_hl_jobs/ruby/ant_hljob_states.rb
   antargis/branches/new_hl_jobs/ruby/ant_man.rb
   antargis/branches/new_hl_jobs/ruby/ant_manbase.rb
   antargis/branches/new_hl_jobs/ruby/ant_new_hljobs.rb
   antargis/branches/new_hl_jobs/ruby/antargislib.rb
   antargis/branches/new_hl_jobs/src/terrain.cc
   antargis/branches/new_hl_jobs/src/terrain.h
Log:
* improve hl-jobs


Modified: antargis/branches/new_hl_jobs/TODO
===================================================================
--- antargis/branches/new_hl_jobs/TODO	2007-05-06 10:04:15 UTC (rev 1090)
+++ antargis/branches/new_hl_jobs/TODO	2007-05-07 19:01:05 UTC (rev 1091)
@@ -1,3 +1,6 @@
+* walk faster when aggression is higher, but lower mood then, too
+
+
 * List of project-parts and progress bar
 
 * check if reachable before fetching !!! (in house) - or even better use heuristic for estimating distance in getNear(...)

Modified: antargis/branches/new_hl_jobs/ruby/ant_fire.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_fire.rb	2007-05-06 10:04:15 UTC (rev 1090)
+++ antargis/branches/new_hl_jobs/ruby/ant_fire.rb	2007-05-07 19:01:05 UTC (rev 1091)
@@ -31,7 +31,8 @@
 				getMap.removeEntity(self)
 			else
 				@dead=true
-				newRestJob(10)
+				# wait 20 seconds, before we delete this entity - the smoke must fade away at least ;-)
+				newRestJob(20)
 			end
 		end
 	end

Modified: antargis/branches/new_hl_jobs/ruby/ant_hero.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_hero.rb	2007-05-06 10:04:15 UTC (rev 1090)
+++ antargis/branches/new_hl_jobs/ruby/ant_hero.rb	2007-05-07 19:01:05 UTC (rev 1091)
@@ -341,22 +341,24 @@
 	end
 
 	def eventDie
+		#raise "herodie"
 		puts "ENERGY:#{self} #{self.getEnergy}"
-		super
+		
 		puts "ENERGY:#{self} #{self.getEnergy}"
 		puts "hero #{self} died.(#{getName})"
 		# release all men
 		puts "# men:#{@men.length}"
-		@men.each{|man|
+		@men.clone.each{|man|
 			puts "myMen:#{man}:#{man.getName}"
 			if man.is_a?(AntMan)
 				puts "#{man} #{man.getName}:setBoss(nil)"
-				man.setBoss(nil)
+				man.setNoBoss
 				@men.delete(man)
 			end
 		}
-
+		
 		killJob
+		super
 		if @player
 			@player.remove(self)
 		end

Modified: antargis/branches/new_hl_jobs/ruby/ant_hljob_states.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_hljob_states.rb	2007-05-06 10:04:15 UTC (rev 1090)
+++ antargis/branches/new_hl_jobs/ruby/ant_hljob_states.rb	2007-05-07 19:01:05 UTC (rev 1091)
@@ -617,6 +617,9 @@
 			return
 		end
 
+		if not man.canFight	
+			man.hlJobMode[:defeated]=true
+		end
 
 		if man.hlJobMode[:defeated]
 			# FIXME:send away
@@ -678,6 +681,7 @@
 			machine.eventLost(target)
 			@ready=true
 		end
+			
 		return @ready
 	end
 

Modified: antargis/branches/new_hl_jobs/ruby/ant_man.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_man.rb	2007-05-06 10:04:15 UTC (rev 1090)
+++ antargis/branches/new_hl_jobs/ruby/ant_man.rb	2007-05-07 19:01:05 UTC (rev 1091)
@@ -78,7 +78,11 @@
 		end
 		
 		setFighting(false)
-		
+
+ 		if @boss
+			assert{@boss.getEnergy>0}
+ 		end
+ 		
 		if @boss.nil?
 			if @bossName=="" then
 			
@@ -111,6 +115,8 @@
 		end
 		if @boss
 			assert{@boss.getEnergy>0}
+			assert{getEnergy>0}
+			#assert{canFight}
 			@boss.assignJob(self)
 		end
 	end	

Modified: antargis/branches/new_hl_jobs/ruby/ant_manbase.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_manbase.rb	2007-05-06 10:04:15 UTC (rev 1090)
+++ antargis/branches/new_hl_jobs/ruby/ant_manbase.rb	2007-05-07 19:01:05 UTC (rev 1091)
@@ -77,6 +77,7 @@
 	end
 
 	def sitStill
+		checkEat
 		newRestJob(2)
 		setMeshState("sit")
 	end
@@ -117,6 +118,7 @@
 	end
 
 	def eventDie
+
 		assert{@dead!=true}
 		simDeath
 		#eventDefeated
@@ -228,6 +230,16 @@
 				getMap.insertEntity(arrow)
 		end
 	end
+	def checkEat
+		puts "CHECKEAT"
+		if getFood<0.5
+			if resource.get("food")>0
+				incFood(1)
+				resource.sub("food",1)
+			end
+		end
+	end
+
 protected
 	def haveBoat
 		resource.get("boat")>=1

Modified: antargis/branches/new_hl_jobs/ruby/ant_new_hljobs.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_new_hljobs.rb	2007-05-06 10:04:15 UTC (rev 1090)
+++ antargis/branches/new_hl_jobs/ruby/ant_new_hljobs.rb	2007-05-07 19:01:05 UTC (rev 1091)
@@ -229,8 +229,15 @@
 	end
 
 	def eventWon(opponent)
+
+		trace
+		puts hero,hero.getName
+		raise 1
 	end
 	def eventLost(opponent)
+		trace
+		puts hero,hero.getName
+		raise 1
 		hero.setOwner(opponent)
 	end
 

Modified: antargis/branches/new_hl_jobs/ruby/antargislib.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/antargislib.rb	2007-05-06 10:04:15 UTC (rev 1090)
+++ antargis/branches/new_hl_jobs/ruby/antargislib.rb	2007-05-07 19:01:05 UTC (rev 1091)
@@ -141,6 +141,8 @@
 					when "gui-test"
 						require 'ruby/tests/gui_tests.rb'
 						@@cursorEnabled=true
+					when "no-3d-textures"
+						setUsing3dTextures(false)
 					when "help","h"
 						STDERR.puts "Possible options:
 	--help         show this help message
@@ -166,6 +168,8 @@
 	--nogl         disable GL-mode (3d-acceleration) - THIS IS NOT YET FULLY SUPPORTED!!
 
 	--ruby-raise   raises ruby-exception when assertions fail
+
+	--no-3d-textures disables 3d-textures - they're bad on some graphics chipsets (esp. Intel)
 	"
 	
 						exit

Modified: antargis/branches/new_hl_jobs/src/terrain.cc
===================================================================
--- antargis/branches/new_hl_jobs/src/terrain.cc	2007-05-06 10:04:15 UTC (rev 1090)
+++ antargis/branches/new_hl_jobs/src/terrain.cc	2007-05-07 19:01:05 UTC (rev 1091)
@@ -4,9 +4,15 @@
 #include <ag_profiler.h>
 #include <ag_config.h>
 
+static bool gUse3dTextures=true;
+void setUsing3dTextures(bool use3dTextures)
+{
+  gUse3dTextures=use3dTextures;
+}
+
 bool use3dTextures()
 {
-  return false;
+  return gUse3dTextures;
 }
 
 

Modified: antargis/branches/new_hl_jobs/src/terrain.h
===================================================================
--- antargis/branches/new_hl_jobs/src/terrain.h	2007-05-06 10:04:15 UTC (rev 1090)
+++ antargis/branches/new_hl_jobs/src/terrain.h	2007-05-07 19:01:05 UTC (rev 1091)
@@ -107,5 +107,7 @@
   void init();
 };
 
+void setUsing3dTextures(bool use3dTextures);
 
+
 #endif



From davidkamphausen at mail.berlios.de  Mon May  7 21:01:26 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Mon, 7 May 2007 21:01:26 +0200
Subject: [Antargis-svn] r1092 - antargis/branches/new_hl_jobs/ruby/ai
Message-ID: <200705071901.l47J1Q33015998@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-07 21:01:26 +0200 (Mon, 07 May 2007)
New Revision: 1092

Added:
   antargis/branches/new_hl_jobs/ruby/ai/ant_ai_hl_sensors.rb
Log:
* added new file


Added: antargis/branches/new_hl_jobs/ruby/ai/ant_ai_hl_sensors.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ai/ant_ai_hl_sensors.rb	2007-05-07 19:01:05 UTC (rev 1091)
+++ antargis/branches/new_hl_jobs/ruby/ai/ant_ai_hl_sensors.rb	2007-05-07 19:01:26 UTC (rev 1092)
@@ -0,0 +1,5 @@
+# This file implements high-level sensors. For the mathematics: These are heuristic functions
+# based on the current state of the game. They're used in the game-tree for estimating a current
+# "goodnees"-value of the game-state.
+#
+# For ease of use they'r based on low-level sensors that're implemted in ant_ai_interface.rb
\ No newline at end of file



From davidkamphausen at mail.berlios.de  Wed May  9 20:35:21 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Wed, 9 May 2007 20:35:21 +0200
Subject: [Antargis-svn] r1093 - in antargis/branches/branch_2d:
	data/textures/2d gui/src ruby ruby/tests src
Message-ID: <200705091835.l49IZLn5000654@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-09 20:34:55 +0200 (Wed, 09 May 2007)
New Revision: 1093

Modified:
   antargis/branches/branch_2d/data/textures/2d/arrow.png
   antargis/branches/branch_2d/data/textures/2d/bakery.png
   antargis/branches/branch_2d/data/textures/2d/boat.png
   antargis/branches/branch_2d/data/textures/2d/buildingsite.png
   antargis/branches/branch_2d/data/textures/2d/coach.png
   antargis/branches/branch_2d/data/textures/2d/dwelling.png
   antargis/branches/branch_2d/data/textures/2d/farm.png
   antargis/branches/branch_2d/data/textures/2d/field.png
   antargis/branches/branch_2d/data/textures/2d/fire.png
   antargis/branches/branch_2d/data/textures/2d/fish.png
   antargis/branches/branch_2d/data/textures/2d/hero.png
   antargis/branches/branch_2d/data/textures/2d/man.png
   antargis/branches/branch_2d/data/textures/2d/mill.png
   antargis/branches/branch_2d/data/textures/2d/mine.png
   antargis/branches/branch_2d/data/textures/2d/sack.png
   antargis/branches/branch_2d/data/textures/2d/sheep.png
   antargis/branches/branch_2d/data/textures/2d/stone.png
   antargis/branches/branch_2d/data/textures/2d/tower.png
   antargis/branches/branch_2d/data/textures/2d/townhall.png
   antargis/branches/branch_2d/data/textures/2d/tree.png
   antargis/branches/branch_2d/data/textures/2d/twig.png
   antargis/branches/branch_2d/data/textures/2d/well.png
   antargis/branches/branch_2d/data/textures/2d/wolf.png
   antargis/branches/branch_2d/data/textures/2d/workshop.png
   antargis/branches/branch_2d/gui/src/ag_messageobject.cc
   antargis/branches/branch_2d/gui/src/ag_painter.cc
   antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc
   antargis/branches/branch_2d/gui/src/ag_surface.cc
   antargis/branches/branch_2d/gui/src/ag_surface.h
   antargis/branches/branch_2d/gui/src/ag_texture.cc
   antargis/branches/branch_2d/gui/src/ag_widget.cc
   antargis/branches/branch_2d/ruby/ant_energy.rb
   antargis/branches/branch_2d/ruby/antargis.rb
   antargis/branches/branch_2d/ruby/tests/impostor.rb
   antargis/branches/branch_2d/ruby/two_d_app.rb
   antargis/branches/branch_2d/src/anim_mesh_data.cc
   antargis/branches/branch_2d/src/anim_mesh_data.h
   antargis/branches/branch_2d/src/impostor.cc
   antargis/branches/branch_2d/src/interface.i
   antargis/branches/branch_2d/src/mesh_sort.h
   antargis/branches/branch_2d/src/scene_2d.cc
Log:
* some more improvements on 2d


Modified: antargis/branches/branch_2d/data/textures/2d/arrow.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/bakery.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/boat.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/buildingsite.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/coach.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/dwelling.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/farm.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/field.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/fire.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/fish.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/hero.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/man.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/mill.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/mine.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/sack.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/sheep.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/stone.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/tower.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/townhall.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/tree.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/twig.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/well.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/wolf.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/data/textures/2d/workshop.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/gui/src/ag_messageobject.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_messageobject.cc	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/gui/src/ag_messageobject.cc	2007-05-09 18:34:55 UTC (rev 1093)
@@ -667,7 +667,7 @@
 }
 bool eventOk(const SDL_Event &pEvent)
 {
-  dbout(1,"eventOk: check "<<(int)pEvent.type<<"!="<<SDL_NOEVENT<<" ???");
+  //  dbout(1,"eventOk: check "<<(int)pEvent.type<<"!="<<SDL_NOEVENT<<" ???");
   return (int)pEvent.type!=SDL_NOEVENT;
 }
 

Modified: antargis/branches/branch_2d/gui/src/ag_painter.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_painter.cc	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/gui/src/ag_painter.cc	2007-05-09 18:34:55 UTC (rev 1093)
@@ -419,7 +419,8 @@
 	    
 	  if(sdlScreen)
 	    {
-	      sdlScreen->drawGradient(r,c0,c1,c2,c3);
+	      sdlScreen->drawGradient(d,pc0,pc1,pc2,pc3);
+	      //	      sdlScreen->drawGradient(r,c0,c1,c2,c3);
 	    }
 	  else
 	    {

Modified: antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc	2007-05-09 18:34:55 UTC (rev 1093)
@@ -29,6 +29,8 @@
 #include "ag_sgeexport.h"
 #include <math.h>
 
+static bool gUseSDLclipping=true;
+
 SDL_Surface *AGCreate32BitSurface(size_t width,size_t height);
 
 AGSDLScreen::AGSDLScreen(SDL_Surface *S):s(S)
@@ -223,13 +225,19 @@
 void AGSDLScreen::clip(const AGRect2 &r)
 {
   //  cdebug(r);
-  SDL_Rect sr=r.sdl();
-  SDL_SetClipRect(s,&sr);
+  if(gUseSDLclipping)
+    {
+      SDL_Rect sr=r.sdl();
+      SDL_SetClipRect(s,&sr);
+    }
 }
 void AGSDLScreen::unclip()
 {
-  SDL_Rect sr=getRect().sdl();
-  SDL_SetClipRect(s,&sr);
+  if(gUseSDLclipping)
+    {
+      SDL_Rect sr=getRect().sdl();
+      SDL_SetClipRect(s,&sr);
+    }
 }
 
 AGSurface AGSDLScreen::screenshot(bool frontBuffer)

Modified: antargis/branches/branch_2d/gui/src/ag_surface.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_surface.cc	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/gui/src/ag_surface.cc	2007-05-09 18:34:55 UTC (rev 1093)
@@ -573,9 +573,12 @@
 	    y1=std::max(y1,y);
 	  }
       }
-  int nw=std::max(0,x1-x0+1);
-  int nh=std::max(0,y1-y0+1);
 
+  
+
+  int nw=std::max(1,x1-x0+1);
+  int nh=std::max(1,y1-y0+1);
+
   AGSurface n(nw,nh);
 
   for(x=0;x<nw;x++)

Modified: antargis/branches/branch_2d/gui/src/ag_surface.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_surface.h	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/gui/src/ag_surface.h	2007-05-09 18:34:55 UTC (rev 1093)
@@ -124,10 +124,12 @@
 
   AGVector2 shrink2Fit(int alphaThresh=20);
 
- private:
+  // private:
 
   AGSurface(AGInternalSurface *i);
 
+ private:
+
   Uint32 color(const AGColor &c) const;
 
   AGInternalSurface *s;
@@ -141,4 +143,5 @@
 
 void AGFreeSurface(SDL_Surface *s);
 
+std::ostream &operator<<(std::ostream &o,SDL_PixelFormat *f);
 #endif

Modified: antargis/branches/branch_2d/gui/src/ag_texture.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_texture.cc	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/gui/src/ag_texture.cc	2007-05-09 18:34:55 UTC (rev 1093)
@@ -27,6 +27,7 @@
 #include "ag_profiler.h"
 #include "ag_glpainter.h"
 #include "ag_fbo.h"
+#include "ag_main.h"
 #include <stdexcept>
 
 size_t nextpow2(size_t i)
@@ -165,7 +166,7 @@
 
 bool AGTexture::hasTexture() const
 {
-  return mTexture;
+  return mTexture || !glMode();
 }
 void AGTexture::clearTexture()
 {
@@ -184,6 +185,9 @@
   if(mSDLTexture==0)
     {
       mSDLTexture=new AGInternalSurface;
+      assert(s);
+      if(!s)
+	s=AGSurface(w,h).surface();
       mSDLTexture->surface=SDL_DisplayFormatAlpha(s->surface);
       s->sdlTexture=mSDLTexture;
     }
@@ -359,6 +363,10 @@
     }
   else
     {
+      sdlTexture();
+      sge_PutPixel(mSDLTexture->surface,x,y,c.mapRGB(mSDLTexture->surface->format));
+
+
       sge_PutPixel(s->surface,x,y,c.mapRGB(s->surface->format));
     }
 }
@@ -373,7 +381,13 @@
       AGGLPainter::fillRect(pRect,c);
     }
   else
-    throw std::runtime_error("implement fillRect for sdl-texture");
+    {
+      for(int x=(int)pRect.x0();x<=pRect.x1();x++)
+	for(int y=(int)pRect.y0();y<=pRect.y1();y++)
+	  putPixel(x,y,c);
+      
+      //      throw std::runtime_error("implement fillRect for sdl-texture");
+    }
   
 }
 
@@ -393,13 +407,41 @@
     }
   else
     {
+      SDL_Rect clip;
+
+      //      throw std::runtime_error("my blitting");
       SDL_Rect sr,dr;
       sr=pSrc.sdl();
       dr=pDest.sdl();
+
+      const_cast<AGTexture&>(pSource).sdlTexture();
+      cdebug("sr:"<<sr<<" dr:"<<dr);
+      cdebug(pSource.mSDLTexture);
+      cdebug(pSource.mSDLTexture->surface);
+      cdebug(sdlTexture()->surface);
+
+      AGSurface(pSource.s).save("source.s.png");
+      AGSurface(pSource.mSDLTexture).save("source.tex.png");
+      SDL_GetClipRect(s->surface,&clip);
+      cdebug("clip:"<<clip);
+      cdebug("format:"<<*s->surface->format);
+      AGRect2 my(0,0,64,64);
+      SDL_SetClipRect(s->surface,&my.sdl());
+      SDL_UnlockSurface(s->surface);
+      if(SDL_BlitSurface(pSource.s->surface,&sr,s->surface,&dr))
+	cdebug("ERROR");
+      /*
+      for(int x=0;x<64;x++)
+	for(int y=0;y<64;y++)
+	  putPixel(x,y,pSource.getPixel(x,y));
+      */
+      AGSurface(s).save("dest.s.png");
+
+
       if(pSource.mSDLTexture)
-	SDL_BlitSurface(pSource.mSDLTexture->surface,&sr,mSDLTexture->surface,&dr);
+	SDL_BlitSurface(pSource.mSDLTexture->surface,&sr,sdlTexture()->surface,&dr);
       else
-	SDL_BlitSurface(pSource.s->surface,&sr,mSDLTexture->surface,&dr);
+	SDL_BlitSurface(pSource.s->surface,&sr,sdlTexture()->surface,&dr);
     }
 }
 void AGTexture::blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc,const AGColor &pColor)

Modified: antargis/branches/branch_2d/gui/src/ag_widget.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_widget.cc	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/gui/src/ag_widget.cc	2007-05-09 18:34:55 UTC (rev 1093)
@@ -878,17 +878,37 @@
 
 	  setDrawn();
 
+
+	  {
+	    static int i=0;
+	    i++;
+	    std::ostringstream os;
+	    os<<"widget_"<<i<<".png";
+	    AGSurface ms(mCache->sdlTexture());
+	    ms.save(os.str());
+	    
+	  }
+
+
 	  if(mParent)
 	    {
+	      //CTRACE;
+	      cdebug("parent->queryRedraw::"<<typeid(*this).name()<<":"<<getName());
 	      mParent->queryRedraw();
 	    }
 
 	  assert(checkRedraw()==false);
+	  assert(mCache->hasTexture());
 	}
     }
 }
 void AGWidget::setCaching(bool pEnable)
 {
+  // FIXME: really no caching without GL? 
+  //  if(!glMode())
+  //    return;
+
+
   if(getConfig()->get("widgetTextureCache")=="false")
     return;
   getConfig()->set("widgetTextureCache","true");
@@ -919,6 +939,7 @@
 
 void AGWidget::queryRedraw()
 {
+  cdebug(getName()<<"::"<<typeid(*this).name());
   mCacheTouched=true;
   regChange();
 }

Modified: antargis/branches/branch_2d/ruby/ant_energy.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_energy.rb	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/ruby/ant_energy.rb	2007-05-09 18:34:55 UTC (rev 1093)
@@ -72,6 +72,7 @@
 	def set(n,v)
 		o=@values[n]
 		if ((o-v).abs>0.1) or (o!=v and (v==0 or v==1))
+			puts "queryRedraw in ant_energy"
 			queryRedraw
 			@values[n]=v
 		end

Modified: antargis/branches/branch_2d/ruby/antargis.rb
===================================================================
--- antargis/branches/branch_2d/ruby/antargis.rb	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/ruby/antargis.rb	2007-05-09 18:34:55 UTC (rev 1093)
@@ -357,7 +357,7 @@
 		ent=nil
 		list.each{|node|
 			mesh=node.node
-			if [Mesh,AnimMesh].member?(mesh.class)
+			if [Mesh,AnimMesh,Mesh2D].member?(mesh.class)
 				ent=getMap.getEntity(mesh)
 				break if ent
 			end

Modified: antargis/branches/branch_2d/ruby/tests/impostor.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/impostor.rb	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/ruby/tests/impostor.rb	2007-05-09 18:34:55 UTC (rev 1093)
@@ -19,8 +19,10 @@
 		puts "#{k}(#{k.class}):#{v} #{v.class}"
 		v.each{|x,y|
 			assert{!(k.is_a?(Hash)||x.is_a?(Hash))}
-			@@types<<[k,x[0]]
-			puts "K:#{k}(#{k.class}) Y:#{x}(#{x.class})"
+			x.each{|xi|
+				@@types<<[k,xi]
+				puts "K:#{k}(#{k.class}) Y:#{x}(#{x.class})"
+			}
 		}
 	}
 	puts @@types.inspect
@@ -29,11 +31,32 @@
 		super
 		$scene=getScene
 
+		hotpoints={}
+
+		#@@types=[[:man,"stand"]]
+
 		tex=nil
 		@@types.each{|t,t2|
 			puts "TRY CREATE #{t}(#{t.class}) #{t2}(#{t2.class})"
 			node=AntModels.createModel(t,t2)
 			puts "#{t}:#{t2} failed creation" if node.nil?
+			if node.is_a?(AnimMesh)
+				anims=node.getData.getAnimations
+				puts "# anims:#{anims.length}"
+				anims.collect!{|s|s.to_s+""}
+				anim=anims[0]
+				if anims.member?(t2.to_s)
+					anim=t2
+# 				else
+# 					anims.each{|a|puts "#{a}(#{a.class})"}
+# 					puts "t2:#{t2} (#{t2.class})"
+# 					raise 1
+				end
+				puts "anim:#{anim}"
+				node.setAnimation(anim.to_s)
+				node.advance(0.1)
+				node.setRotation(30)
+			end
 			$scene.addNode(node)
 			imp=AntImpostorData.new(node,512,512)
 	
@@ -43,23 +66,33 @@
 				name+="_"+(t2.to_s)	
 			end
 			name+=".png"
-			imp.getSurface.save(name)
+			surface=imp.getSurface
+			p=surface.shrink2Fit
+	
+			hotpoints[name]=p
+			surface.save(name)
 			getScene.removeNode(node)
 		}
+
+		text=""
+		hotpoints.each{|k,v|text+=k+":"+(v.to_s)+"\n"}
+		saveFile("hotspots.txt",text)
 			
-		image=AGImage.new(nil,AGRect2.new(0,0,tex.width,tex.height),tex,false)
-		setMainWidget(image)
+# 		image=AGImage.new(nil,AGRect2.new(0,0,tex.width,tex.height),tex,false)
+# 		setMainWidget(image)
 		
-		getScene.removeNode(node)
+		#getScene.removeNode(node)
 	end
 
 	def eventFrame(t)
-		delay(100)
+# 		delay(100)
 	puts t
 		return true
 	end
 end
 
+#getMain.initVideo(512,512,32,false,true)
+
 app=MyApp.new(1024,768)
 
 app.run

Modified: antargis/branches/branch_2d/ruby/two_d_app.rb
===================================================================
--- antargis/branches/branch_2d/ruby/two_d_app.rb	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/ruby/two_d_app.rb	2007-05-09 18:34:55 UTC (rev 1093)
@@ -20,10 +20,17 @@
 	end
 
 	def draw
-		p=AGPainter.new
-		@scene.setPainter(p)
-		@scene.draw
-		@scene.discardPainter
+		@frame||=0
+		@frame+=1
+
+		if (@frame%2)==0
+			p=AGPainter.new
+			@scene.setPainter(p)
+			@scene.draw
+			@scene.discardPainter
+			p=nil
+			GC.start
+		end
 		super
 	end
 	def getScene
@@ -57,7 +64,7 @@
 			nodes=tryClick(e.getMousePosition)
 			nodes.each{|n|
         puts "NODE: #{n}(#{n.class})"
-        #puts "NODE:"+(getMap.getEntity(n).to_s)
+        puts "NODE:"+(getMap.getEntity(n.node).to_s)
 			}
 			eventClick(nodes,e.getButton)
 		end
@@ -95,7 +102,10 @@
 module AntModels
 	def AntModels.createModel(entityType,subType=nil,angle=nil)
 		trace
-		type=entityType
+		type=entityType.to_s
+		if subType.to_s!=""
+			type+="_"+subType.to_s
+		end
 		t=AGTexture.new(AGSurface.load("data/textures/2d/#{type}.png"))
 		data=Mesh2DData.new(t)
 		mesh=Mesh2D.new(getMap.getScene,data,AGVector4.new(0,0,0,1),0)

Modified: antargis/branches/branch_2d/src/anim_mesh_data.cc
===================================================================
--- antargis/branches/branch_2d/src/anim_mesh_data.cc	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/src/anim_mesh_data.cc	2007-05-09 18:34:55 UTC (rev 1093)
@@ -325,3 +325,13 @@
 
 
 }
+
+std::vector<std::string> AnimMeshData::getAnimations() const
+{
+  std::vector<std::string> l;
+
+  for(std::map<AGString,Animation>::const_iterator i=mAnimations.begin();i!=mAnimations.end();i++)
+    l.push_back(i->first);
+
+  return l;
+}

Modified: antargis/branches/branch_2d/src/anim_mesh_data.h
===================================================================
--- antargis/branches/branch_2d/src/anim_mesh_data.h	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/src/anim_mesh_data.h	2007-05-09 18:34:55 UTC (rev 1093)
@@ -100,6 +100,8 @@
   const AGMatrix4 &getTransform() const;
 
   friend class AnimMesh;
+
+  std::vector<std::string> getAnimations() const;
 };
 
 #endif

Modified: antargis/branches/branch_2d/src/impostor.cc
===================================================================
--- antargis/branches/branch_2d/src/impostor.cc	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/src/impostor.cc	2007-05-09 18:34:55 UTC (rev 1093)
@@ -52,12 +52,12 @@
   //  mTexture.endPaint();
 
   AGSurface s=getScreen().screenshot(false);
-  s.save("impostor.png");
+  //  s.save("impostor.png");
 
   mTexture.endPaint();
 
   AGSurface subs=s.getSubSurface(AGRect2(0,sh-h,w,h));
-  subs.save("impostor3.png");
+  //  subs.save("impostor3.png");
 
   mSurface=subs;
 

Modified: antargis/branches/branch_2d/src/interface.i
===================================================================
--- antargis/branches/branch_2d/src/interface.i	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/src/interface.i	2007-05-09 18:34:55 UTC (rev 1093)
@@ -1,6 +1,11 @@
 %module(directors="1") libantargis
 %feature("director");
 %include "typemaps.i"
+%include "std_string.i"
+%include "AGString.i"
+%include "std_vector.i"
+%include "std_pair.i"
+%include "std_map.i"
 
 %include "nantmarker.hh"
 /*
@@ -59,16 +64,10 @@
 
 
 
-
 %{
 #include "scene.h"
 #include "antargisgui.h"
 %}
-%include "std_string.i"
-%include "AGString.i"
-%include "std_vector.i"
-%include "std_pair.i"
-%include "std_map.i"
 
 %template(StringVector) std::vector<std::string>;
 %template(AGStringVector) std::vector<AGString>;

Modified: antargis/branches/branch_2d/src/mesh_sort.h
===================================================================
--- antargis/branches/branch_2d/src/mesh_sort.h	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/src/mesh_sort.h	2007-05-09 18:34:55 UTC (rev 1093)
@@ -1,6 +1,9 @@
 #ifndef MESH_SORT_H
 #define MESH_SORT_H
 
+#include <ag_geometry.h>
+#include "scenenode.h"
+
 /**
    The class is for sorting purpose only. It provides the operator() function, that's needed
    for the STL-sorting algorithms.
@@ -12,13 +15,7 @@
 public:
   SortDistance(AGVector3 c):cam(c){}
 
-  bool operator()(const SceneNode *n1,const SceneNode *n2)
-  {
-    AGVector3 m1=const_cast<SceneNode*>(n1)->bbox().base+const_cast<SceneNode*>(n1)->bbox().dir*0.5;
-    AGVector3 m2=const_cast<SceneNode*>(n2)->bbox().base+const_cast<SceneNode*>(n2)->bbox().dir*0.5;
-
-    return (m1-cam).length2()<(m2-cam).length2();
-  }
+  bool operator()(const SceneNode *n1,const SceneNode *n2);
 };
 
 /**
@@ -29,11 +26,16 @@
 public:
   SortOrder(){}
 
-  bool operator()(const SceneNode *n1,const SceneNode *n2)
-  {
-    return n1->getOrder()<n2->getOrder();
-  }
+  bool operator()(const SceneNode *n1,const SceneNode *n2);
 };
 
+class SortYCoord
+{
+ public:
+  SortYCoord(){}
+  
+  bool operator()(const SceneNode *n1,const SceneNode *n2);
+};
 
+
 #endif

Modified: antargis/branches/branch_2d/src/scene_2d.cc
===================================================================
--- antargis/branches/branch_2d/src/scene_2d.cc	2007-05-07 19:01:26 UTC (rev 1092)
+++ antargis/branches/branch_2d/src/scene_2d.cc	2007-05-09 18:34:55 UTC (rev 1093)
@@ -23,7 +23,7 @@
   std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
 
 
-  sort(ns.begin(),ns.end(),SortOrder());
+  sort(ns.begin(),ns.end(),SortYCoord());
 
   //FIXME:sort!!
 



From davidkamphausen at mail.berlios.de  Wed May  9 20:36:30 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Wed, 9 May 2007 20:36:30 +0200
Subject: [Antargis-svn] r1094 - antargis/branches/branch_2d/data/textures/2d
Message-ID: <200705091836.l49IaUsw000750@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-09 20:36:18 +0200 (Wed, 09 May 2007)
New Revision: 1094

Added:
   antargis/branches/branch_2d/data/textures/2d/buildingsite_0.png
   antargis/branches/branch_2d/data/textures/2d/buildingsite_1.png
   antargis/branches/branch_2d/data/textures/2d/buildingsite_2.png
   antargis/branches/branch_2d/data/textures/2d/decal_floor_gravel.png
   antargis/branches/branch_2d/data/textures/2d/deco_floor_deco.png
   antargis/branches/branch_2d/data/textures/2d/field_0.png
   antargis/branches/branch_2d/data/textures/2d/field_1.png
   antargis/branches/branch_2d/data/textures/2d/field_2.png
   antargis/branches/branch_2d/data/textures/2d/field_3.png
   antargis/branches/branch_2d/data/textures/2d/fire_off.png
   antargis/branches/branch_2d/data/textures/2d/fire_on.png
   antargis/branches/branch_2d/data/textures/2d/fishinghut.png
   antargis/branches/branch_2d/data/textures/2d/hero_grave_hero.png
   antargis/branches/branch_2d/data/textures/2d/man_axe.png
   antargis/branches/branch_2d/data/textures/2d/man_corn.png
   antargis/branches/branch_2d/data/textures/2d/man_fight_bow.png
   antargis/branches/branch_2d/data/textures/2d/man_fight_dagger.png
   antargis/branches/branch_2d/data/textures/2d/man_fight_shield.png
   antargis/branches/branch_2d/data/textures/2d/man_fight_sword.png
   antargis/branches/branch_2d/data/textures/2d/man_flour.png
   antargis/branches/branch_2d/data/textures/2d/man_grave.png
   antargis/branches/branch_2d/data/textures/2d/man_pick.png
   antargis/branches/branch_2d/data/textures/2d/man_sit.png
   antargis/branches/branch_2d/data/textures/2d/man_sitdown.png
   antargis/branches/branch_2d/data/textures/2d/man_stand.png
   antargis/branches/branch_2d/data/textures/2d/man_stone.png
   antargis/branches/branch_2d/data/textures/2d/man_walk.png
   antargis/branches/branch_2d/data/textures/2d/man_wood.png
   antargis/branches/branch_2d/data/textures/2d/npc_druid.png
   antargis/branches/branch_2d/data/textures/2d/npc_smith.png
   antargis/branches/branch_2d/data/textures/2d/sheep_rip.png
   antargis/branches/branch_2d/data/textures/2d/tree_0.png
   antargis/branches/branch_2d/data/textures/2d/tree_1.png
   antargis/branches/branch_2d/data/textures/2d/tree_2.png
   antargis/branches/branch_2d/data/textures/2d/tree_3.png
   antargis/branches/branch_2d/data/textures/2d/tree_4.png
   antargis/branches/branch_2d/data/textures/2d/tree_5.png
   antargis/branches/branch_2d/data/textures/2d/tree_6.png
   antargis/branches/branch_2d/data/textures/2d/tree_7.png
   antargis/branches/branch_2d/data/textures/2d/tree_8.png
   antargis/branches/branch_2d/data/textures/2d/tree_9.png
   antargis/branches/branch_2d/data/textures/2d/tree_stub.png
   antargis/branches/branch_2d/data/textures/2d/wolf_rip.png
Log:
* added some pics


Added: antargis/branches/branch_2d/data/textures/2d/buildingsite_0.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/buildingsite_0.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/buildingsite_1.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/buildingsite_1.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/buildingsite_2.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/buildingsite_2.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/decal_floor_gravel.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/decal_floor_gravel.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/deco_floor_deco.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/deco_floor_deco.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/field_0.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/field_0.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/field_1.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/field_1.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/field_2.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/field_2.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/field_3.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/field_3.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/fire_off.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/fire_off.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/fire_on.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/fire_on.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/fishinghut.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/fishinghut.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/hero_grave_hero.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/hero_grave_hero.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_axe.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_axe.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_corn.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_corn.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_fight_bow.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_fight_bow.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_fight_dagger.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_fight_dagger.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_fight_shield.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_fight_shield.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_fight_sword.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_fight_sword.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_flour.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_flour.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_grave.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_grave.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_pick.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_pick.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_sit.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_sit.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_sitdown.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_sitdown.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_stand.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_stand.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_stone.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_stone.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_walk.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_walk.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/man_wood.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/man_wood.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/npc_druid.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/npc_druid.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/npc_smith.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/npc_smith.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/sheep_rip.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/sheep_rip.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/tree_0.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/tree_0.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/tree_1.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/tree_1.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/tree_2.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/tree_2.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/tree_3.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/tree_3.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/tree_4.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/tree_4.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/tree_5.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/tree_5.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/tree_6.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/tree_6.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/tree_7.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/tree_7.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/tree_8.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/tree_8.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/tree_9.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/tree_9.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/tree_stub.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/tree_stub.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/branch_2d/data/textures/2d/wolf_rip.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/branch_2d/data/textures/2d/wolf_rip.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From davidkamphausen at mail.berlios.de  Wed May  9 20:37:14 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Wed, 9 May 2007 20:37:14 +0200
Subject: [Antargis-svn] r1095 - in antargis/branches/branch_2d: ruby/tests
	src
Message-ID: <200705091837.l49IbEHG000813@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-09 20:37:14 +0200 (Wed, 09 May 2007)
New Revision: 1095

Added:
   antargis/branches/branch_2d/ruby/tests/sdl_texture.rb
   antargis/branches/branch_2d/src/mesh_sort.cc
Log:
* added missing files


Added: antargis/branches/branch_2d/ruby/tests/sdl_texture.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/sdl_texture.rb	2007-05-09 18:36:18 UTC (rev 1094)
+++ antargis/branches/branch_2d/ruby/tests/sdl_texture.rb	2007-05-09 18:37:14 UTC (rev 1095)
@@ -0,0 +1,56 @@
+#!/usr/bin/env ruby
+
+require 'ruby/antargislib.rb'
+
+getMain.initVideo(800,600,32,false,false)
+
+
+
+class MyWidget<AGWidget
+	def initialize(p,r)
+		super
+
+a=AGSurface.new(64,64)
+p=AGPainter.new(a)
+
+p.fillRect(AGRect2.new(10,10,10,10),AGColor.new(0xFF,0,0))
+p=nil
+a.save("test0.png")
+	@t1=AGTexture.new(a)
+
+
+t=AGTexture.new(64,64)
+p=AGPainter.new(t)
+
+p.fillRect(AGRect2.new(10,10,10,10),AGColor.new(0xFF,0,0))
+p=nil
+s=AGSurface.new(t.sdlTexture)
+s.save("test1.png")
+
+
+	@t2=AGTexture.new(s)
+
+		@t3=AGTexture.new(64,64)
+		@t3.beginPaint
+		@t3.blit(@t2,AGRect2.new(0,0,64,64),AGRect2.new(0,0,64,64))
+		@t3.endPaint
+s=AGSurface.new(@t3.sdlTexture)
+s.save("test2.png")
+
+	end
+	def draw(p)
+		#p.
+		p.blit(@t1,AGRect2.new(0,0,64,64))
+		p.blit(@t2,AGRect2.new(64,0,64,64))
+		p.blit(@t3,AGRect2.new(128,0,64,64))
+	end
+end
+
+
+
+app=AGApplication.new
+
+imw=MyWidget.new(nil,AGRect2.new(0,0,800,600))
+
+app.setMainWidget(imw)
+app.run
\ No newline at end of file

Added: antargis/branches/branch_2d/src/mesh_sort.cc
===================================================================
--- antargis/branches/branch_2d/src/mesh_sort.cc	2007-05-09 18:36:18 UTC (rev 1094)
+++ antargis/branches/branch_2d/src/mesh_sort.cc	2007-05-09 18:37:14 UTC (rev 1095)
@@ -0,0 +1,23 @@
+#include "mesh_sort.h"
+
+
+bool SortDistance::operator()(const SceneNode *n1,const SceneNode *n2)
+{
+  AGVector3 m1=const_cast<SceneNode*>(n1)->bbox().base+const_cast<SceneNode*>(n1)->bbox().dir*0.5;
+  AGVector3 m2=const_cast<SceneNode*>(n2)->bbox().base+const_cast<SceneNode*>(n2)->bbox().dir*0.5;
+  
+  return (m1-cam).length2()<(m2-cam).length2();
+}
+
+bool SortOrder::operator()(const SceneNode *n1,const SceneNode *n2)
+{
+  return n1->getOrder()<n2->getOrder();
+}
+
+
+
+bool SortYCoord::operator()(const SceneNode *n1,const SceneNode *n2)
+{
+  //  return n1->getPos()[1]>n2->getPos()[1];
+  return n1->getOrder()<n2->getOrder() || (n1->getOrder()==n2->getOrder() && n1->getPos()[1]>n2->getPos()[1]);
+}



From davidkamphausen at mail.berlios.de  Sun May 13 10:43:38 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 13 May 2007 10:43:38 +0200
Subject: [Antargis-svn] r1096 - in antargis/branches/branch_2d: gui/src ruby
	ruby/tests
Message-ID: <200705130843.l4D8hcid012087@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-13 10:43:36 +0200 (Sun, 13 May 2007)
New Revision: 1096

Modified:
   antargis/branches/branch_2d/gui/src/ag_application.cc
   antargis/branches/branch_2d/gui/src/ag_debug.cc
   antargis/branches/branch_2d/gui/src/ag_screen.cc
   antargis/branches/branch_2d/gui/src/ag_screen.h
   antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc
   antargis/branches/branch_2d/gui/src/ag_sdlsurface.h
   antargis/branches/branch_2d/gui/src/ag_surface.cc
   antargis/branches/branch_2d/gui/src/ag_surface.h
   antargis/branches/branch_2d/gui/src/ag_texture.cc
   antargis/branches/branch_2d/gui/src/ag_widget.cc
   antargis/branches/branch_2d/gui/src/ag_widget.h
   antargis/branches/branch_2d/ruby/tests/sdl_texture.rb
   antargis/branches/branch_2d/ruby/two_d_app.rb
Log:
* sdl-improvements
* started new dirty-rects method


Modified: antargis/branches/branch_2d/gui/src/ag_application.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_application.cc	2007-05-09 18:37:14 UTC (rev 1095)
+++ antargis/branches/branch_2d/gui/src/ag_application.cc	2007-05-13 08:43:36 UTC (rev 1096)
@@ -353,6 +353,7 @@
   if(!videoInited())
     return;
 
+  bool oldClippingTechnique=false;
 
   STACKTRACE;
   beginRender();
@@ -362,11 +363,18 @@
       AGPainter p;
       if(pLastDrawn==mainWidget && !opengl())
 	{
-	  AGRect2 r=mainWidget->getChangeRect();
-	  if(mCursor)
-	    r+=mCursorOld;
-
-	  p.clip(r);
+	  if(oldClippingTechnique)
+	    {
+	      AGRect2 r=mainWidget->getChangeRect();
+	      if(mCursor)
+		r+=mCursorOld;
+	      
+	      p.clip(r);
+	    }
+	  else
+	    {
+	      // FIXME: do some advanced clipping
+	    }
 	}
       mainWidget->drawAll(p);
 
@@ -384,8 +392,19 @@
       pLastDrawn=mainWidget;
     }
   drawCursor();
-  getScreen().flip();
+
+  std::list<AGRect2> changeList;
+  if(mainWidget)
+    {
+      changeList=mainWidget->aquireChanges();
+      mainWidget->clearChangeRects();
+    }
+  if(changeList.size())
+    getScreen().update(changeList);
+  else
+    getScreen().flip();
   endRender();
+  cdebug("end render");
 }
 
 /**

Modified: antargis/branches/branch_2d/gui/src/ag_debug.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_debug.cc	2007-05-09 18:37:14 UTC (rev 1095)
+++ antargis/branches/branch_2d/gui/src/ag_debug.cc	2007-05-13 08:43:36 UTC (rev 1096)
@@ -36,7 +36,7 @@
   quietLog=true;
 }
 
-static bool gRubyRaising=true;
+static bool gRubyRaising=false;
 void agRaise(const std::string &s)
 {
   cdebug("assertion failed:"<<s);

Modified: antargis/branches/branch_2d/gui/src/ag_screen.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_screen.cc	2007-05-09 18:37:14 UTC (rev 1095)
+++ antargis/branches/branch_2d/gui/src/ag_screen.cc	2007-05-13 08:43:36 UTC (rev 1096)
@@ -33,6 +33,11 @@
 void AGScreen::flip()
 {
 }
+void AGScreen::update(const std::list<AGRect2> &rs)
+{
+}
+
+
 size_t AGScreen::getWidth() const
 {
   return 0;

Modified: antargis/branches/branch_2d/gui/src/ag_screen.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_screen.h	2007-05-09 18:37:14 UTC (rev 1095)
+++ antargis/branches/branch_2d/gui/src/ag_screen.h	2007-05-13 08:43:36 UTC (rev 1096)
@@ -33,6 +33,7 @@
  public:
   virtual void begin(); // call before start drawing
   virtual void flip();
+  virtual void update(const std::list<AGRect2> &rs); // call this instead of flip, if you want
 
   virtual size_t getWidth() const;
   virtual size_t getHeight() const;

Modified: antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc	2007-05-09 18:37:14 UTC (rev 1095)
+++ antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc	2007-05-13 08:43:36 UTC (rev 1096)
@@ -40,9 +40,37 @@
 
 void AGSDLScreen::flip()
 {
+  CTRACE;
   SDL_Flip(s);
 }
 
+void AGSDLScreen::update(const std::list<AGRect2> &rs)
+{
+  CTRACE;
+  SDL_Rect *nrs=new SDL_Rect[rs.size()];
+
+  cdebug("RS:"<<rs.size());
+
+  AGRect2 scr=getRect();
+  size_t j=0;
+  for(std::list<AGRect2>::const_iterator i=rs.begin();i!=rs.end();i++,j++)
+    {
+      AGRect2 n=scr.intersect(*i);
+      //      #warning "FIXME: 
+      nrs[j].x=n.x();
+      nrs[j].y=n.y();
+      nrs[j].w=n.w();
+      nrs[j].h=n.h();
+      cdebug(*i);
+      ///      #error FIXME
+    }
+
+  SDL_UpdateRects(s,rs.size(),nrs);
+
+  delete [] nrs;
+}
+
+
 AGRect2 AGSDLScreen::getRect() const
 {
   return AGRect2(0,0,s->w,s->h);
@@ -52,6 +80,13 @@
 {
   if(c.a<0xFF)
     {
+  sge_FilledRectAlpha(s,
+		      (int)pRect.x(),
+		      (int)pRect.y(),
+		      (int)(pRect.x()+pRect.w()-1),
+		      (int)(pRect.y()+pRect.h()-1),
+		      c.mapRGB(s->format),c.a);
+  return;
       for(int x=(int)pRect.x0();x<(int)pRect.x1();x++)
 	for(int y=(int)pRect.y0();y<(int)pRect.y1();y++)
 	  {
@@ -60,6 +95,9 @@
     }
   else
     {
+      SDL_Rect r=pRect.sdl();
+      SDL_FillRect(s,&r,c.mapRGB(s->format));
+      return;
       for(int x=(int)pRect.x0();x<(int)pRect.x1();x++)
 	for(int y=(int)pRect.y0();y<(int)pRect.y1();y++)
 	  putPixel(x,y,c);

Modified: antargis/branches/branch_2d/gui/src/ag_sdlsurface.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_sdlsurface.h	2007-05-09 18:37:14 UTC (rev 1095)
+++ antargis/branches/branch_2d/gui/src/ag_sdlsurface.h	2007-05-13 08:43:36 UTC (rev 1096)
@@ -31,6 +31,7 @@
   virtual void blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc);
 
   virtual void flip();
+  virtual void update(const std::list<AGRect2> &rs);
 
   virtual AGRect2 getRect() const;
 

Modified: antargis/branches/branch_2d/gui/src/ag_surface.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_surface.cc	2007-05-09 18:37:14 UTC (rev 1095)
+++ antargis/branches/branch_2d/gui/src/ag_surface.cc	2007-05-13 08:43:36 UTC (rev 1096)
@@ -602,3 +602,50 @@
 {
   return (AGDecryptor*)(p);
 }
+
+std::ostream &operator<<(std::ostream &o,SDL_PixelFormat *f)
+{
+  o<<"(";
+    //    SDL_Palette *palette;
+  o<<(int)f->BitsPerPixel<<";";
+  o<<(int)f->BytesPerPixel<<";";
+  o<<(int)f->Rloss<<";";
+  o<<(int)f->Gloss<<";";
+  o<<(int)f->Bloss<<";";
+  o<<(int)f->Aloss<<";";
+  o<<(int)f->Rshift<<";";
+  o<<(int)f->Gshift<<";";
+  o<<(int)f->Bshift<<";";
+  o<<(int)f->Ashift<<";";
+  o<<(int)f->Rmask<<";";
+  o<<(int)f->Gmask<<";";
+  o<<(int)f->Bmask<<";";
+  o<<(int)f->Amask<<";";
+  o<<(int)f->colorkey<<";";
+  o<<(int)f->alpha<<")";
+  o<<"\n";
+
+
+  return o;
+}
+
+std::ostream &operator<<(std::ostream &o,SDL_Surface *f)
+{
+  o<<"(";
+  o<<f->flags<<",";
+  o<<f->format<<",";                /* Read-only */
+  o<<f->w<<","<<f->h<<",";
+  o<<f->pitch<<";";                           /* Read-only */
+  o<<f->offset<<";";                             /* Private */
+
+  o<<f->clip_rect<<";";                     /* Read-only */
+
+  o<<f->locked<<";";                          /* Private */
+
+  o<<f->format_version<<";";            /* Private */
+
+        /* Reference count -- used when freeing surface */
+  o<<f->refcount<<")\n";
+
+  return o;
+}

Modified: antargis/branches/branch_2d/gui/src/ag_surface.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_surface.h	2007-05-09 18:37:14 UTC (rev 1095)
+++ antargis/branches/branch_2d/gui/src/ag_surface.h	2007-05-13 08:43:36 UTC (rev 1096)
@@ -144,4 +144,6 @@
 void AGFreeSurface(SDL_Surface *s);
 
 std::ostream &operator<<(std::ostream &o,SDL_PixelFormat *f);
+std::ostream &operator<<(std::ostream &o,SDL_Surface *f);
+
 #endif

Modified: antargis/branches/branch_2d/gui/src/ag_texture.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_texture.cc	2007-05-09 18:37:14 UTC (rev 1095)
+++ antargis/branches/branch_2d/gui/src/ag_texture.cc	2007-05-13 08:43:36 UTC (rev 1096)
@@ -186,9 +186,20 @@
     {
       mSDLTexture=new AGInternalSurface;
       assert(s);
+      bool sempty=false;
       if(!s)
-	s=AGSurface(w,h).surface();
+	{
+	  s=AGSurface(w,h).surface();
+	  //SDL_SetColorKey(s->surface,0,0);
+	  //	  SDL_SetAlpha(s->surface,0,0);
+	  sempty=true;
+	}
+      
       mSDLTexture->surface=SDL_DisplayFormatAlpha(s->surface);
+      //      if(!sempty)
+      //      	SDL_SetAlpha(mSDLTexture->surface,0,0);
+	//SDL_SetColorKey(mSDLTexture->surface,0,0);
+
       s->sdlTexture=mSDLTexture;
     }
   return mSDLTexture;
@@ -407,41 +418,37 @@
     }
   else
     {
-      SDL_Rect clip;
-
-      //      throw std::runtime_error("my blitting");
       SDL_Rect sr,dr;
       sr=pSrc.sdl();
       dr=pDest.sdl();
 
       const_cast<AGTexture&>(pSource).sdlTexture();
-      cdebug("sr:"<<sr<<" dr:"<<dr);
-      cdebug(pSource.mSDLTexture);
-      cdebug(pSource.mSDLTexture->surface);
-      cdebug(sdlTexture()->surface);
 
-      AGSurface(pSource.s).save("source.s.png");
-      AGSurface(pSource.mSDLTexture).save("source.tex.png");
-      SDL_GetClipRect(s->surface,&clip);
-      cdebug("clip:"<<clip);
-      cdebug("format:"<<*s->surface->format);
-      AGRect2 my(0,0,64,64);
-      SDL_SetClipRect(s->surface,&my.sdl());
-      SDL_UnlockSurface(s->surface);
       if(SDL_BlitSurface(pSource.s->surface,&sr,s->surface,&dr))
 	cdebug("ERROR");
-      /*
-      for(int x=0;x<64;x++)
-	for(int y=0;y<64;y++)
-	  putPixel(x,y,pSource.getPixel(x,y));
-      */
-      AGSurface(s).save("dest.s.png");
 
+      Uint32 saved_flags;
+      Uint8  saved_alpha;
 
+      SDL_Surface *sourceSurface;
+
       if(pSource.mSDLTexture)
-	SDL_BlitSurface(pSource.mSDLTexture->surface,&sr,sdlTexture()->surface,&dr);
+	sourceSurface=pSource.mSDLTexture->surface;
       else
-	SDL_BlitSurface(pSource.s->surface,&sr,sdlTexture()->surface,&dr);
+	sourceSurface=pSource.s->surface;
+      
+      // save alpha-settings
+      saved_flags = sourceSurface->flags&(SDL_SRCALPHA|SDL_RLEACCELOK);
+      saved_alpha = sourceSurface->format->alpha;
+      
+      // clear alpha-settings, so that rgba is copied completely
+      SDL_SetAlpha(sourceSurface,0,0);
+	    
+      if(SDL_BlitSurface(sourceSurface,&sr,sdlTexture()->surface,&dr))
+	cdebug("ERROR Blitting");
+
+      // restore settings
+      SDL_SetAlpha(sourceSurface,saved_flags,saved_alpha);
     }
 }
 void AGTexture::blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc,const AGColor &pColor)

Modified: antargis/branches/branch_2d/gui/src/ag_widget.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_widget.cc	2007-05-09 18:37:14 UTC (rev 1095)
+++ antargis/branches/branch_2d/gui/src/ag_widget.cc	2007-05-13 08:43:36 UTC (rev 1096)
@@ -878,7 +878,7 @@
 
 	  setDrawn();
 
-
+	  /*
 	  {
 	    static int i=0;
 	    i++;
@@ -888,8 +888,8 @@
 	    ms.save(os.str());
 	    
 	  }
+	  */
 
-
 	  if(mParent)
 	    {
 	      //CTRACE;
@@ -1033,3 +1033,27 @@
     return mParent->isParent(pParent);
   return false;
 }
+
+
+std::list<AGRect2> AGWidget::aquireChanges()
+{
+  std::list<AGRect2> l;
+
+  for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();i++)
+    {
+      std::list<AGRect2> t=(*i)->aquireChanges();
+      // FIXME: check, if opaque and truncates rectangles
+      std::copy(t.begin(),t.end(),std::back_inserter(l));
+    }
+  std::copy(mMyChanges.begin(),mMyChanges.end(),std::back_inserter(l));
+  
+  return l;
+}
+void AGWidget::pushChangeRect(const AGRect2 &pRect)
+{
+  mMyChanges.push_back(pRect);
+}
+void AGWidget::clearChangeRects()
+{
+  mMyChanges.clear();
+}

Modified: antargis/branches/branch_2d/gui/src/ag_widget.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_widget.h	2007-05-09 18:37:14 UTC (rev 1095)
+++ antargis/branches/branch_2d/gui/src/ag_widget.h	2007-05-13 08:43:36 UTC (rev 1096)
@@ -199,7 +199,12 @@
 
   void setTooltip(const AGStringUtf8 &pTooltip);
 
+  std::list<AGRect2> aquireChanges();
+  void pushChangeRect(const AGRect2 &pRect);
+  void clearChangeRects();
+
  private:
+  std::list<AGRect2> mMyChanges;
 
   void regChange();
 

Modified: antargis/branches/branch_2d/ruby/tests/sdl_texture.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/sdl_texture.rb	2007-05-09 18:37:14 UTC (rev 1095)
+++ antargis/branches/branch_2d/ruby/tests/sdl_texture.rb	2007-05-13 08:43:36 UTC (rev 1096)
@@ -40,6 +40,7 @@
 	end
 	def draw(p)
 		#p.
+		p.fillRect(AGRect2.new(0,0,256,256),AGColor.new(0,0xFF,0))
 		p.blit(@t1,AGRect2.new(0,0,64,64))
 		p.blit(@t2,AGRect2.new(64,0,64,64))
 		p.blit(@t3,AGRect2.new(128,0,64,64))

Modified: antargis/branches/branch_2d/ruby/two_d_app.rb
===================================================================
--- antargis/branches/branch_2d/ruby/two_d_app.rb	2007-05-09 18:37:14 UTC (rev 1095)
+++ antargis/branches/branch_2d/ruby/two_d_app.rb	2007-05-13 08:43:36 UTC (rev 1096)
@@ -23,14 +23,14 @@
 		@frame||=0
 		@frame+=1
 
-		if (@frame%2)==0
+		#if (@frame%2)==0
 			p=AGPainter.new
 			@scene.setPainter(p)
 			@scene.draw
 			@scene.discardPainter
 			p=nil
 			GC.start
-		end
+		#end
 		super
 	end
 	def getScene



From davidkamphausen at mail.berlios.de  Sun May 13 10:45:12 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 13 May 2007 10:45:12 +0200
Subject: [Antargis-svn] r1097 - antargis/branches/branch_2d/ruby/tests
Message-ID: <200705130845.l4D8jCTq012208@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-13 10:45:12 +0200 (Sun, 13 May 2007)
New Revision: 1097

Added:
   antargis/branches/branch_2d/ruby/tests/dirty_rects.rb
Log:
* added missing file


Added: antargis/branches/branch_2d/ruby/tests/dirty_rects.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/dirty_rects.rb	2007-05-13 08:43:36 UTC (rev 1096)
+++ antargis/branches/branch_2d/ruby/tests/dirty_rects.rb	2007-05-13 08:45:12 UTC (rev 1097)
@@ -0,0 +1,44 @@
+#!/usr/bin/env ruby
+
+require 'ruby/antargislib.rb'
+
+getMain.initVideo(800,600,32,false,false)
+
+
+class MyWidget<AGWidget
+	def initialize(p,r)
+		super
+		@x=0
+		@y=0
+	end
+	def prepareDraw
+	end
+	def draw(p)
+		p.fillRect(AGRect2.new(0,0,300,300),AGColor.new(0,0,0))
+		p.fillRect(AGRect2.new(@x, at y,10,10),AGColor.new(0xFF,0,0))
+	end
+	def eventFrame(t)
+		@x+=2
+		@y+=1
+		@x%=207
+		@y%=293
+		#queryRedraw
+		pushChangeRect(AGRect2.new(@x-2, at y-2,12,12))
+	end
+end
+
+class MyApp<AGApplication
+	def initialize
+		super
+		@imw=MyWidget.new(nil,AGRect2.new(0,0,800,600))
+		setMainWidget(@imw)
+	end
+	def eventFrame(t)
+		@imw.eventFrame(t)
+		delay(5)
+		true
+	end
+end
+
+app=MyApp.new
+app.run
\ No newline at end of file



From davidkamphausen at mail.berlios.de  Sat May 19 16:30:17 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 19 May 2007 16:30:17 +0200
Subject: [Antargis-svn] r1098 - in antargis/branches/branch_2d: . gui/src
	ruby ruby/tests src
Message-ID: <200705191430.l4JEUH3D010015@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-19 16:30:14 +0200 (Sat, 19 May 2007)
New Revision: 1098

Added:
   antargis/branches/branch_2d/gui/src/ag_algebra.cc
   antargis/branches/branch_2d/gui/src/ag_algebra.h
   antargis/branches/branch_2d/gui/src/ag_clip.cc
   antargis/branches/branch_2d/gui/src/ag_clip.h
   antargis/branches/branch_2d/gui/src/ag_clip_painttarget.cc
   antargis/branches/branch_2d/gui/src/ag_clip_painttarget.h
   antargis/branches/branch_2d/gui/src/ag_gauss.h
   antargis/branches/branch_2d/gui/src/ag_projection.cc
   antargis/branches/branch_2d/gui/src/ag_projection.h
   antargis/branches/branch_2d/ruby/tests/algebra_test.rb
   antargis/branches/branch_2d/ruby/tests/basis_test.rb
   antargis/branches/branch_2d/ruby/tests/clip_test.rb
   antargis/branches/branch_2d/ruby/tests/clip_widget_test.rb
   antargis/branches/branch_2d/ruby/tests/rect_test.rb
Modified:
   antargis/branches/branch_2d/Rakefile
   antargis/branches/branch_2d/gui/src/ag_application.cc
   antargis/branches/branch_2d/gui/src/ag_button.cc
   antargis/branches/branch_2d/gui/src/ag_button.h
   antargis/branches/branch_2d/gui/src/ag_geometry.cc
   antargis/branches/branch_2d/gui/src/ag_geometry.h
   antargis/branches/branch_2d/gui/src/ag_glscreen.cc
   antargis/branches/branch_2d/gui/src/ag_glscreen.h
   antargis/branches/branch_2d/gui/src/ag_painter.cc
   antargis/branches/branch_2d/gui/src/ag_painter.h
   antargis/branches/branch_2d/gui/src/ag_string_utf8.cc
   antargis/branches/branch_2d/gui/src/ag_string_utf8.h
   antargis/branches/branch_2d/gui/src/ag_widget.cc
   antargis/branches/branch_2d/gui/src/ag_widget.h
   antargis/branches/branch_2d/gui/src/interface.i
   antargis/branches/branch_2d/ruby/ant_local.rb
   antargis/branches/branch_2d/ruby/tests/dirty_rects.rb
   antargis/branches/branch_2d/src/antargisgui.h
   antargis/branches/branch_2d/src/interface.i
   antargis/branches/branch_2d/src/nantmarker.hh
   antargis/branches/branch_2d/src/path.cc
Log:
* some algebra-functions
* some more work on dirty-rects


Modified: antargis/branches/branch_2d/Rakefile
===================================================================
--- antargis/branches/branch_2d/Rakefile	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/Rakefile	2007-05-19 14:30:14 UTC (rev 1098)
@@ -36,7 +36,7 @@
 "scenenode.h","anim_mesh.h","anim_mesh_data.h","ant_app.h","entity.h","entptr.h","glsl.h","height_map.h","map.h","mesh_data.h","mesh.h","mesh_2d_data.h","mesh_2d.h","mesh_optimizer.h","minimap.h","new_decal.h","ant_renderer.h","resource.h","scene_base.h","scene.h","scene_2d.h","smoke.h","terrain.h","vertex_array.h","water.h","path.h","impostor.h"]
 interfaceHeadersGUI=[
 "ag_rubyobj.h","ag_messageobject.h","ag_serial.h","ag_aes.h","ag_singleton.h",
- "ag_geometry.h","ag_font.h","ag_color.h","ag_local.h","ag_config.h","ag_string.h","ag_string_utf8.h",
+ "ag_geometry.h","ag_projection.h","ag_algebra.h","ag_clip.h","ag_font.h","ag_color.h","ag_local.h","ag_config.h","ag_string.h","ag_string_utf8.h",
  "ag_widget.h","ag_colorbutton.h","ag_glwidget.h","ag_xml.h","ag_layout.h","ag_dialog.h","ag_mutex.h",
  "ag_application.h","ag_background.h","ag_border.h","ag_button.h","ag_text.h","ag_caption.h","ag_checkbox.h","ag_combo.h","ag_edit.h","ag_fontengine.h","ag_fs.h","ag_painttarget.h","ag_surface.h","ag_texture.h","ag_surfacemanager.h","ag_image.h","ag_layoutfactory.h","ag_listbox.h","ag_list.h","ag_main.h","ag_menu.h","ag_menuitem.h","ag_mixer.h","ag_mutex.h","ag_painter.h","ag_png.h","ag_radio.h","ag_screen.h","ag_glscreen.h","ag_table.h","ag_texturecache.h","ag_theme.h","ag_tools.h","ag_window.h","ag_xml.h","ag_screenwidget.h","ag_scroller.h","ag_plugin.h","ag_destructor.h","ag_rand.h"]
 

Added: antargis/branches/branch_2d/gui/src/ag_algebra.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_algebra.cc	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_algebra.cc	2007-05-19 14:30:14 UTC (rev 1098)
@@ -0,0 +1,208 @@
+#include "ag_algebra.h"
+#include "ag_debug.h"
+#include "ag_gauss.h"
+#include "ag_stringstream.h"
+
+
+
+AGMatrixN::AGMatrixN(size_t w,size_t h):m(w*h,0),
+					mW(w),mH(h)
+{
+}
+
+AGMatrixN::AGMatrixN(const AGMatrixN &n):m(n.m),
+					mW(n.mW),
+					mH(n.mH)
+{
+}
+
+void AGMatrixN::set(size_t x,size_t y,float v)
+{
+  assert(x<mW);
+  assert(y<mH);
+  m[index(x,y)]=v;
+}
+float AGMatrixN::get(size_t x,size_t y) const
+{
+  assert(x<mW);
+  assert(y<mH);
+  return m[index(x,y)];
+}
+
+AGMatrixN &AGMatrixN::operator*=(const AGMatrixN &p)
+{
+  assert(mW==p.mH);
+  AGMatrixN n(p.mW,mH);
+  for(size_t x=0;x<p.mW;x++)
+    for(size_t y=0;y<mH;y++)
+      {
+	float v=0;
+	for(size_t k=0;k<mW;k++)
+	  v+=get(k,y)*p.get(x,k);
+	n.set(x,y,v);
+      }
+  *this=n;
+  return *this;
+    
+}
+AGMatrixN AGMatrixN::operator*(const AGMatrixN &p) const
+{
+  assert(mW==p.mH);
+  AGMatrixN n(p.mW,mH);
+  for(size_t x=0;x<p.mW;x++)
+    for(size_t y=0;y<mH;y++)
+      {
+	float v=0;
+	for(size_t k=0;k<mW;k++)
+	  v+=get(k,y)*p.get(x,k);
+	n.set(x,y,v);
+      }
+  return n;
+}
+
+AGMatrixN AGMatrixN::operator-(const AGMatrixN &p) const
+{
+  assert(mW==p.mW);
+  assert(mH==p.mH);
+  AGMatrixN n(mW,mH);
+
+  for(size_t x=0;x<mW;x++)
+    for(size_t y=0;y<mH;y++)
+      n.set(x,y,get(x,y)-p.get(x,y));
+  return n;
+}
+
+float AGMatrixN::scalar() const
+{
+  float s=0;
+  float v;
+  for(size_t x=0;x<mW;x++)
+    for(size_t y=0;y<mH;y++)
+      {
+	v=get(x,y);
+	s+=v*v;
+      }
+  return sqrt(s);
+}
+
+
+AGMatrixN AGMatrixN::makeQuadratic() const
+{
+  size_t nw=std::max(mW,mH);
+  AGMatrixN a(nw,nw);
+  a.copyFrom(*this);
+  return a;
+}
+
+/// a very simple way to compute a pseudo-inverse
+/// using svd may be better - no matter ;-)
+/// for details go to http://en.wikipedia.org/wiki/Pseudoinverse
+AGMatrixN AGMatrixN::pseudoInverse() const
+{
+  AGMatrixN t=transposed();
+  if(mW<mH)
+    return (t*(*this)).inverse()*t;
+  else
+    return t*((*this)*t).inverse();
+}
+
+AGMatrixN AGMatrixN::transposed() const
+{
+  AGMatrixN a(mH,mW);
+  for(size_t x=0;x<mW;x++)
+    for(size_t y=0;y<mH;y++)
+      a.set(y,x,get(x,y));
+  return a;
+}
+
+
+
+AGMatrixN AGMatrixN::inverse() const
+{
+  size_t nw=std::max(mW,mH);
+  AGMatrixN a(nw,nw),b(nw,nw);
+
+  a.makeUnitMatrix();
+  b.copyFrom(*this);
+  /*
+  std::cout<<"A:"<<std::endl;
+  a.output();
+  std::cout<<"B:"<<std::endl;
+  b.output();
+  */
+  gauss(a,b,nw);
+  /*
+  std::cout<<"A:"<<std::endl;
+  a.output();
+  std::cout<<"B:"<<std::endl;
+  b.output();*/
+  return a;
+}
+
+void AGMatrixN::makeUnitMatrix()
+{
+  for(size_t x=0;x<mW;x++)
+    for(size_t y=0;y<mH;y++)
+      set(x,y,(x==y?1:0));
+}
+  
+void AGMatrixN::copyFrom(const AGMatrixN &p)
+{
+  for(size_t x=0;x<mW && x<p.mW;x++)
+    for(size_t y=0;y<mH && y<p.mH;y++)
+      set(x,y,p.get(x,y));
+}
+
+void AGMatrixN::output() const
+{
+  for(size_t y=0;y<mH;y++)
+    {
+      for(size_t x=0;x<mW;x++)
+	{
+	  std::cout<<get(x,y)<<"\t";
+	}
+      std::cout<<"\n";
+    }
+
+}
+
+AGString AGMatrixN::toString() const
+{
+  AGStringStream s;
+  for(size_t y=0;y<mH;y++)
+    {
+      for(size_t x=0;x<mW;x++)
+	{
+	  s<<get(x,y)<<"\t";
+	}
+      s<<"\n";
+    }
+  return s.str();
+}
+
+void AGMatrixN::swapRows(size_t a,size_t b)
+{
+  if(a==b)
+    return;
+  assert(a<mH);
+  assert(b<mH);
+  for(size_t x=0;x<mW;x++)
+    {
+      float t=get(x,a);
+      set(x,a,get(x,b));
+      set(x,b,t);
+    }
+}
+void AGMatrixN::swapCols(size_t a,size_t b)
+{
+  if(a==b)
+    return;
+  assert(a<mW);
+  assert(b<mW);
+  for(size_t y=0;y<mH;y++)
+    {
+      float t=get(a,y);
+      set(a,y,get(b,y));
+      set(b,y,t);
+    }
+}

Added: antargis/branches/branch_2d/gui/src/ag_algebra.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_algebra.h	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_algebra.h	2007-05-19 14:30:14 UTC (rev 1098)
@@ -0,0 +1,48 @@
+#ifndef AG_ALGEBRA_H
+#define AG_ALGEBRA_H
+
+#include <vector>
+#include <ag_string.h>
+
+class AGMatrixN
+{
+ public:
+  AGMatrixN(size_t w,size_t h);
+  AGMatrixN(const AGMatrixN &p);
+
+  void set(size_t x,size_t y,float v);
+  float get(size_t x,size_t y) const;
+
+  AGMatrixN &operator*=(const AGMatrixN &p);
+  AGMatrixN operator*(const AGMatrixN &p) const;
+
+  AGMatrixN operator-(const AGMatrixN &p) const;
+
+  float scalar() const;
+
+  AGMatrixN inverse() const;
+  AGMatrixN pseudoInverse() const;
+  AGMatrixN makeQuadratic() const;
+
+  AGMatrixN transposed() const;
+
+  void makeUnitMatrix();
+
+  void copyFrom(const AGMatrixN &p);
+
+  void output() const;
+
+  AGString toString() const;
+
+  void swapRows(size_t a,size_t b);
+  void swapCols(size_t a,size_t b);
+
+ private:
+  
+  inline size_t index(size_t x,size_t y) const { return x+y*mW; }
+
+  std::vector<float> m;
+  size_t mW,mH;
+};
+
+#endif

Modified: antargis/branches/branch_2d/gui/src/ag_application.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_application.cc	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_application.cc	2007-05-19 14:30:14 UTC (rev 1098)
@@ -27,6 +27,7 @@
 #include "ag_mixer.h"
 #include "ag_texturecache.h"
 #include "ag_profiler.h"
+#include "ag_clip_painttarget.h"
 
 #include <ruby.h>
 
@@ -354,13 +355,16 @@
     return;
 
   bool oldClippingTechnique=false;
+  AGClipping clip;
 
   STACKTRACE;
   beginRender();
   if(mainWidget)
     {
       getScreen().begin();
-      AGPainter p;
+      AGClipPaintTarget paintTarget(&getScreen());
+      AGPainter p(paintTarget);
+      clip.exclude(mainWidget->getScreenRect());
       if(pLastDrawn==mainWidget && !opengl())
 	{
 	  if(oldClippingTechnique)
@@ -374,8 +378,12 @@
 	  else
 	    {
 	      // FIXME: do some advanced clipping
+	      mainWidget->acquireClipping(clip);
 	    }
 	}
+
+      cdebug("CLIP:"<<clip.toString());
+      paintTarget.clip(clip);
       mainWidget->drawAll(p);
 
       if(mTooltip)
@@ -391,6 +399,8 @@
 
       pLastDrawn=mainWidget;
     }
+  else
+    cdebug("no mainwidget");
   drawCursor();
 
   std::list<AGRect2> changeList;
@@ -399,10 +409,16 @@
       changeList=mainWidget->aquireChanges();
       mainWidget->clearChangeRects();
     }
-  if(changeList.size())
-    getScreen().update(changeList);
+  if(opengl())// || true)
+    getScreen().flip();
   else
-    getScreen().flip();
+    {
+      std::vector<AGRect2> changeV=clip.clip(mainWidget->getScreenRect());
+      changeList.clear();
+      std::copy(changeV.begin(),changeV.end(),std::back_inserter(changeList));
+      getScreen().update(changeList);
+    }
+
   endRender();
   cdebug("end render");
 }

Modified: antargis/branches/branch_2d/gui/src/ag_button.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_button.cc	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_button.cc	2007-05-19 14:30:14 UTC (rev 1098)
@@ -383,3 +383,8 @@
   for(std::map<State,AGBorder>::iterator i=mBorder.begin();i!=mBorder.end();++i)
     i->second.useTextures();
 }
+
+bool AGButton::isOpaque() const
+{
+  return true;
+}

Modified: antargis/branches/branch_2d/gui/src/ag_button.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_button.h	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_button.h	2007-05-19 14:30:14 UTC (rev 1098)
@@ -89,6 +89,8 @@
 
   virtual void useTextures();
 
+  bool isOpaque() const;
+
  private:
   AGStringUtf8 mText;
   int mID;

Added: antargis/branches/branch_2d/gui/src/ag_clip.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_clip.cc	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_clip.cc	2007-05-19 14:30:14 UTC (rev 1098)
@@ -0,0 +1,84 @@
+#include "ag_clip.h"
+#include "ag_stringstream.h"
+#include <stdexcept>
+
+void AGClipping::exclude(const AGRect2 &r)
+{
+  mExclude.push_back(r);
+  //FIXME: check for intersections
+}
+ 
+void AGClipping::include(const AGRect2 &r)
+{
+  std::vector<AGRect2> n;
+  
+  for(std::vector<AGRect2>::iterator i=mExclude.begin();i!=mExclude.end();i++)
+    {
+      std::vector<AGRect2> t=(*i).difference(r);
+      std::copy(t.begin(),t.end(),std::back_inserter(n));
+    }
+  mExclude=n;
+}
+  
+std::vector<AGRect2> AGClipping::clip(const AGRect2&r)
+{
+  std::vector<AGRect2> t,n;
+
+  t.push_back(r);
+
+  for(std::vector<AGRect2>::iterator i=mExclude.begin();i!=mExclude.end();i++)
+    {
+      for(std::vector<AGRect2>::iterator j=t.begin();j!=t.end();j++)
+	{
+	  std::vector<AGRect2> t2=j->difference(*i);
+	  for(std::vector<AGRect2>::iterator k=t2.begin();k!=t2.end();k++)
+	    {
+	      if(k->w()>0 && k->h()>0)
+		n.push_back(*k);
+	    }
+	}
+      t=n;
+      n.clear();
+      
+    }
+
+  // FIXME: check for optimization
+
+  return t;
+  
+}
+
+bool AGClipping::included(const AGVector2 &v)
+{
+  for(std::vector<AGRect2>::iterator i=mExclude.begin();i!=mExclude.end();i++)
+    if(i->contains(v))
+      return false;
+  return true;
+}
+
+
+std::vector<std::pair<AGRect2,AGRect2> > AGClipping::clip(const AGRect2&r,const AGRect2 &sync)
+{
+  std::vector<std::pair<AGRect2,AGRect2> > n;
+
+  std::vector<AGRect2> t=clip(r);
+  
+  for(std::vector<AGRect2>::iterator i=t.begin();i!=t.end();i++)
+    {
+      
+    }
+  throw std::runtime_error("not implemented yet!");
+  return n;
+}
+
+AGString AGClipping::toString() const
+{
+  AGStringStream os;
+
+  os<<"[AGClipping:";
+  for(std::vector<AGRect2>::const_iterator i=mExclude.begin();i!=mExclude.end();i++)
+    os<<i->toString()<<";";
+  os<<"]";
+
+  return os.str();
+}

Added: antargis/branches/branch_2d/gui/src/ag_clip.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_clip.h	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_clip.h	2007-05-19 14:30:14 UTC (rev 1098)
@@ -0,0 +1,31 @@
+#ifndef AG_CLIP_H
+#define AG_CLIP_H
+
+#include <ag_geometry.h>
+
+class AGClipping
+{
+ public:
+  void include(const AGRect2 &r);
+  void exclude(const AGRect2 &r);
+  
+  std::vector<AGRect2> clip(const AGRect2&r);
+  std::vector<std::pair<AGRect2,AGRect2> > clip(const AGRect2&r,const AGRect2 &sync);
+
+  std::vector<AGLine2> clip(const AGLine2 &p);
+
+  bool included(const AGVector2 &v);
+
+  bool valid() const;
+
+  AGString toString() const;
+
+ private:
+
+  void optimize();
+
+  //  std::vector<AGRect2> mInclude;
+  std::vector<AGRect2> mExclude;
+};
+
+#endif

Added: antargis/branches/branch_2d/gui/src/ag_clip_painttarget.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_clip_painttarget.cc	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_clip_painttarget.cc	2007-05-19 14:30:14 UTC (rev 1098)
@@ -0,0 +1,113 @@
+#include "ag_clip_painttarget.h"
+#include "ag_debug.h"
+
+AGClipPaintTarget::AGClipPaintTarget(AGPaintTarget *pTarget):mTarget(pTarget)
+{
+}
+
+void AGClipPaintTarget::blitTri(const AGTexture &pSource,const AGTriangle2 &pSrc,const AGTriangle2 &pDest)
+{
+  cdebug("NOT IMPLEMENTED!");
+}
+
+void AGClipPaintTarget::blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc,const AGColor &pColor)
+{
+  std::vector<std::pair<AGRect2,AGRect2> > l=mClipping.clip(pDest,pSrc);
+  for(std::vector<std::pair<AGRect2,AGRect2> >::iterator i=l.begin();i!=l.end();i++)
+    {
+      mTarget->blit(pSource,i->first,i->second,pColor);
+    }
+}
+
+void AGClipPaintTarget::blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc)
+{
+  std::vector<std::pair<AGRect2,AGRect2> > l=mClipping.clip(pDest,pSrc);
+  for(std::vector<std::pair<AGRect2,AGRect2> >::iterator i=l.begin();i!=l.end();i++)
+    {
+      mTarget->blit(pSource,i->first,i->second);
+    }
+}
+
+void AGClipPaintTarget::blit(const AGSurface &pSource,const AGRect2 &pDest,const AGRect2 &pSrc)
+{
+  std::vector<std::pair<AGRect2,AGRect2> > l=mClipping.clip(pDest,pSrc);
+  for(std::vector<std::pair<AGRect2,AGRect2> >::iterator i=l.begin();i!=l.end();i++)
+    {
+      mTarget->blit(pSource,i->first,i->second);
+    }
+}
+
+void AGClipPaintTarget::drawLine(const AGVector2 &p0,const AGVector2 &p1,const AGColor &c)
+{
+  std::vector<AGLine2> l=mClipping.clip(AGLine2(p0,p1));
+  for(std::vector<AGLine2>::iterator i=l.begin();i!=l.end();i++)
+    mTarget->drawLine(i->getV0(),i->getV1(),c);
+}
+
+void AGClipPaintTarget::fillRect(const AGRect2 &pr,const AGColor &c)
+{
+  std::vector<AGRect2> l=mClipping.clip(pr);
+  for(std::vector<AGRect2>::iterator i=l.begin();i!=l.end();i++)
+    mTarget->fillRect(*i,c);
+}
+
+void AGClipPaintTarget::fillRects(const std::vector<std::pair<AGRect2,AGVector4> > &pr)
+{
+  std::vector<std::pair<AGRect2,AGVector4> > l;
+
+  // collect clippings
+  for(std::vector<std::pair<AGRect2,AGVector4> >::const_iterator i=pr.begin();i!=pr.end();i++)
+    {
+      std::vector<AGRect2> l2=mClipping.clip(i->first);
+      for(std::vector<AGRect2>::iterator i2=l2.begin();i2!=l2.end();i2++)
+	l.push_back(std::make_pair(*i2,i->second));
+    }
+  mTarget->fillRects(l);
+}
+   
+void AGClipPaintTarget::blit(const AGTexture &pSource,const std::vector<std::pair<AGRect2,AGRect2> > &pSrcDestRects,const AGColor &pColor)
+{
+  std::vector<std::pair<AGRect2,AGRect2> > l;
+
+  // collect clippings
+  for(std::vector<std::pair<AGRect2,AGRect2> >::const_iterator i=pSrcDestRects.begin();i!=pSrcDestRects.end();i++)
+    {
+      std::vector<std::pair<AGRect2,AGRect2> > l2=mClipping.clip(i->first,i->second);
+      std::copy(l2.begin(),l2.end(),std::back_inserter(l));
+    }
+  mTarget->blit(pSource,l,pColor);
+}
+
+void AGClipPaintTarget::tile(const AGTexture &pSource,const AGRect2 &pTarget, const AGColor &pColor)
+{
+  //std::vector<std::pair<AGRect2,AGRect2> > l2=mClipping.clip(i->first);
+  
+  cdebug("WARNING: AGClipPaintTarget::tile not implemented yet!");
+}
+   
+void AGClipPaintTarget::putPixel(int x,int y,const AGColor &c)
+{
+  if(mClipping.included(AGVector2(x,y)))
+    mTarget->putPixel(x,y,c);
+}
+
+AGColor AGClipPaintTarget::getPixel(int x,int y) const
+{
+  return mTarget->getPixel(x,y);
+}
+
+  // manage painting sessions
+void AGClipPaintTarget::clip(const AGClipping &c)
+{
+  mClipping=c;
+}
+
+void AGClipPaintTarget::unclip()
+{
+  mClipping=AGClipping();
+}
+
+AGRect2 AGClipPaintTarget::getRect() const
+{
+  return mTarget->getRect();
+}

Added: antargis/branches/branch_2d/gui/src/ag_clip_painttarget.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_clip_painttarget.h	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_clip_painttarget.h	2007-05-19 14:30:14 UTC (rev 1098)
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_painttarget.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef __AG_CLIP_PAINTTARGET_H
+#define __AG_CLIP_PAINTTARGET_H
+
+#include <ag_painttarget.h>
+#include <ag_clip.h>
+
+/// virtual paint target - use this for advanced clipping !
+class AGClipPaintTarget:public AGPaintTarget
+{
+ public:
+  AGClipPaintTarget(AGPaintTarget *pTarget);
+
+  virtual void blitTri(const AGTexture &pSource,const AGTriangle2 &pSrc,const AGTriangle2 &pDest);
+
+  virtual void blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc,const AGColor &pColor);
+  virtual void blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc);
+  virtual void blit(const AGSurface &pSource,const AGRect2 &pDest,const AGRect2 &pSrc);
+
+  virtual void drawLine(const AGVector2 &p0,const AGVector2 &p1,const AGColor &c);
+  virtual void fillRect(const AGRect2 &pr,const AGColor &c);
+
+  virtual void fillRects(const std::vector<std::pair<AGRect2,AGVector4> > &pr);
+   
+  virtual void blit(const AGTexture &pSource,const std::vector<std::pair<AGRect2,AGRect2> > &pSrcDestRects,const AGColor &pColor);
+
+  virtual void tile(const AGTexture &pSource,const AGRect2 &pTarget, const AGColor &pColor);
+   
+  virtual AGRect2 getRect() const;
+
+  virtual void putPixel(int x,int y,const AGColor &c);
+  virtual AGColor getPixel(int x,int y) const;
+
+  // manage painting sessions
+  virtual void clip(const AGClipping &c);
+
+  virtual void unclip();
+
+ private:
+  AGPaintTarget *mTarget;
+  AGClipping mClipping;
+};
+
+
+#endif
+

Added: antargis/branches/branch_2d/gui/src/ag_gauss.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_gauss.h	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_gauss.h	2007-05-19 14:30:14 UTC (rev 1098)
@@ -0,0 +1,97 @@
+#ifndef AG_GAUSS_H
+#define AG_GAUSS_H
+
+#include <math.h>
+
+/// input:a should be a unit-matrix, b contains the matrix to be inverted!
+/// afterwards a contains the result 
+template<class TMatrix>
+bool gauss(TMatrix &a,TMatrix &b,int size)
+{
+  TRACE;
+  // cdebug("A:\n"<<a.toString());
+  // cdebug("B:\n"<<b.toString());
+
+  // lower-left triangle
+  for(int c=0;c<size-1;c++) // cols
+    {
+      //FIXME: check that we have a one in (c,c) - otherwise swap rows !
+      if(fabs(b.get(c,c))<0.0001)
+	{
+	  int k;
+	  // find a row where b.get(c,c+n)!=0 for n>1 
+	  for(k=1;k+c<size;k++)
+	    if(fabs(b.get(c,c+k))>0)
+	      {
+		// swap rows
+		b.swapRows(c,c+k);
+		a.swapRows(c,c+k);
+		break;
+	      }
+	  if(k+c==size)
+	    return false; // PROBLEM!!!!
+	}
+
+      for(int r=c+1;r<size;r++) // rows
+	{
+	  if(fabs(b.get(c,r))>0.0001)
+	    {
+	      float f=-b.get(c,c)/b.get(c,r);
+	      //	      // cdebug("f:"<<f);
+	      for(int i=0;i<size;i++)
+		{
+		  // modify row
+		  a.set(i,r,a.get(i,c)+a.get(i,r)*f);
+		  //		  if(i==0)
+		  //		    // cdebug(b.get(c,r-1)<<"    "<<b.get(c,r));
+		  b.set(i,r,b.get(i,c)+b.get(i,r)*f);
+		}
+	      // cdebug("c:"<<c<<" r:"<<r);
+	      // cdebug("INTERMED A:\n"<<a.toString());
+	      // cdebug("INTERMED B:\n"<<b.toString());
+	    }
+	}
+    }
+  // cdebug("A:\n"<<a.toString());
+  // cdebug("B:\n"<<b.toString());
+
+  // upper-right triangle
+  for(int c=size-1;c>0;c--) // cols
+    {
+      for(int r=0;r<c;r++) // rows
+	{
+	  if(fabs(b.get(c,r))>0.0001)
+	    {
+	      float f=-b.get(c,r+1)/b.get(c,r);
+	      for(int i=0;i<size;i++)
+		{
+		  // modify row
+		  a.set(i,r,a.get(i,r+1)+a.get(i,r)*f);
+		  b.set(i,r,b.get(i,r+1)+b.get(i,r)*f);
+		}
+	    }
+	}
+    }
+    // cdebug("A:\n"<<a.toString());
+    // cdebug("B:\n"<<b.toString());
+
+  // norming
+
+  for(int r=0;r<size;r++)
+    {
+      float v=b.get(r,r);
+      if(v!=0)
+      for(int c=0;c<size;c++)
+	{
+	  a.set(c,r,a.get(c,r)/v);
+	  b.set(c,r,b.get(c,r)/v);
+	}
+    }
+    // cdebug("A:\n"<<a.toString());
+    // cdebug("B:\n"<<b.toString());
+    return true; // everythin ok
+}
+
+
+#endif
+

Modified: antargis/branches/branch_2d/gui/src/ag_geometry.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_geometry.cc	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_geometry.cc	2007-05-19 14:30:14 UTC (rev 1098)
@@ -29,6 +29,7 @@
 #include <ag_xml.h>
 #include <ag_debug.h>
 #include <ag_stringstream.h>
+#include <ag_gauss.h>
 
 #include <ruby.h>
 
@@ -201,7 +202,12 @@
   v[1]=node.get("y").toFloat();
 }
 
+AGVector2 AGVector2::operator-() const
+{
+  return AGVector2(-v[0],-v[1]);
+}
 
+
 float getArcInternal(float x,float y)
 {
   if(y==0.0)
@@ -646,6 +652,19 @@
   a[2][1]=n[1];
 }
 
+AGMatrix3::AGMatrix3(float x,float y)
+{
+  a[0][0]=x;
+  a[1][1]=y;
+  a[2][2]=1.0f;
+  a[0][1]=a[0][2]=
+    a[1][0]=a[1][2]=
+    a[2][0]=a[2][1]=0.0f;
+  a[2][0]=0.0f;
+  a[2][1]=0.0f;
+  
+}
+
 AGMatrix3 AGMatrix3::transposed() const
 {
   AGMatrix3 a;
@@ -656,69 +675,6 @@
 }
 
 
-template<class AGMatrix3>
-void gauss(AGMatrix3 &a,AGMatrix3 &b,int size)
-{
-  // lower-left triangle
-  for(int c=0;c<size-1;c++) // cols
-    {
-      for(int r=c+1;r<size;r++) // rows
-	{
-	  if(fabs(b.get(c,r))>0.0001)
-	    {
-	      float f=-b.get(c,r-1)/b.get(c,r);
-	      //	      cdebug("f:"<<f);
-	      for(int i=0;i<size;i++)
-		{
-		  // modify row
-		  a.set(i,r,a.get(i,r-1)+a.get(i,r)*f);
-		  //		  if(i==0)
-		  //		    cdebug(b.get(c,r-1)<<"    "<<b.get(c,r));
-		  b.set(i,r,b.get(i,r-1)+b.get(i,r)*f);
-		}
-	    }
-	}
-    }
-  //  cdebug("A:\n"<<a.toString());
-  //  cdebug("B:\n"<<b.toString());
-
-  // upper-right triangle
-  for(int c=size-1;c>0;c--) // cols
-    {
-      for(int r=0;r<c;r++) // rows
-	{
-	  if(fabs(b.get(c,r))>0.0001)
-	    {
-	      float f=-b.get(c,r+1)/b.get(c,r);
-	      for(int i=0;i<size;i++)
-		{
-		  // modify row
-		  a.set(i,r,a.get(i,r+1)+a.get(i,r)*f);
-		  b.set(i,r,b.get(i,r+1)+b.get(i,r)*f);
-		}
-	    }
-	}
-    }
-  //  cdebug("A:\n"<<a.toString());
-  //  cdebug("B:\n"<<b.toString());
-
-  // norming
-
-  for(int r=0;r<size;r++)
-    {
-      float v=b.get(r,r);
-      if(v!=0)
-      for(int c=0;c<size;c++)
-	{
-	  a.set(c,r,a.get(c,r)/v);
-	  b.set(c,r,b.get(c,r)/v);
-	}
-    }
-  //  cdebug("A:\n"<<a.toString());
-  //  cdebug("B:\n"<<b.toString());
-
-}
-
 AGMatrix3 AGMatrix3::inverted() const
 {
   // gauss-alg.
@@ -729,7 +685,35 @@
   return a;
 }
 
+void AGMatrix3::swapRows(size_t a,size_t b)
+{
+  if(a==b)
+    return;
+  assert(a<3);
+  assert(b<3);
+  for(size_t x=0;x<3;x++)
+    {
+      float t=get(x,a);
+      set(x,a,get(x,b));
+      set(x,b,t);
+    }
+}
 
+void AGMatrix3::swapCols(size_t a,size_t b)
+{
+  if(a==b)
+    return;
+  assert(a<3);
+  assert(b<3);
+  for(size_t y=0;y<3;y++)
+    {
+      float t=get(a,y);
+      set(a,y,get(b,y));
+      set(b,y,t);
+    }
+}
+
+
 void AGMatrix3::set(size_t x,size_t y,float f)
 {
   assert(x>=0 && x<3);
@@ -1267,7 +1251,58 @@
 		 AGVector2(mx1,my1));
 }
 
+std::vector<AGRect2> AGRect2::difference(const AGRect2 &r) const
+{
+  std::vector<AGRect2> l;
+  for(int i=0;i<3;i++)
+    for(int j=0;j<3;j++)
+      {
+	
+	float nx,ny,nw,nh;
+	
+	switch(i)
+	  {
+	  case 0:
+	    nx=x0();
+	    nw=r.x0()-x0();
+	    break;
+	  case 1:
+	    nx=r.x0();
+	    nw=r.x1()-r.x0();
+	    break;
+	  case 2:
+	    nx=r.x1();
+	    nw=x1()-r.x1();
+	    break;
+	  };
+	switch(j)
+	  {
+	  case 0:
+	    ny=y0();
+	    nh=r.y0()-y0();
+	    break;
+	  case 1:
+	    ny=r.y0();
+	    nh=r.y1()-r.y0();
+	    break;
+	  case 2:
+	    ny=r.y1();
+	    nh=y1()-r.y1();
+	    break;
+	  };
+	if(nw>0 && nh>0)
+	  {
+	    AGRect2 n=intersect(AGRect2(nx,ny,nw,nh));
+	    if(n.w()>0 && n.h()>0)
+	      if(!r.contains(n))
+		l.push_back(n);
+	  }
+      }
+  return l;
+}
 
+
+
 AGVector2 AGRect2::operator[](size_t i) const
 {
   switch(i)
@@ -1363,7 +1398,12 @@
   return AGRect2(0,0,w(),h());
 }
 
+float AGRect2::content() const
+{
+  return (v1[0]-v0[0])*(v1[1]-v0[1]);
+}
 
+
 void AGRect2::include(const AGVector2 &v)
 {
   v0[0]=std::min(v0[0],v[0]);
@@ -2090,7 +2130,35 @@
   return a;
 }
 
+void AGMatrix4::swapRows(size_t a,size_t b)
+{
+  if(a==b)
+    return;
+  assert(a<4);
+  assert(b<4);
+  for(size_t x=0;x<4;x++)
+    {
+      float t=get(x,a);
+      set(x,a,get(x,b));
+      set(x,b,t);
+    }
+}
 
+void AGMatrix4::swapCols(size_t a,size_t b)
+{
+  if(a==b)
+    return;
+  assert(a<4);
+  assert(b<4);
+  for(size_t y=0;y<4;y++)
+    {
+      float t=get(a,y);
+      set(a,y,get(b,y));
+      set(b,y,t);
+    }
+}
+
+
 AGMatrix3 AGMatrix4::get3x3(size_t x,size_t y) const
 {
   AGMatrix3 m;

Modified: antargis/branches/branch_2d/gui/src/ag_geometry.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_geometry.h	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_geometry.h	2007-05-19 14:30:14 UTC (rev 1098)
@@ -85,6 +85,7 @@
 
   AGAngle getAngle() const;
 
+  AGVector2 operator-() const;
   AGVector2 operator-(const AGVector2 &p) const;
   AGVector2 operator+(const AGVector2 &p) const;
   AGVector2 &operator+=(const AGVector2 &p);
@@ -227,8 +228,9 @@
   };
 
   AGMatrix3();
-  AGMatrix3(const AGAngle &a);
-  AGMatrix3(const AGVector3 &a);
+  AGMatrix3(const AGAngle &a); // rotate
+  AGMatrix3(const AGVector3 &a); // transpose
+  AGMatrix3(float x,float y); // scale
   void set(size_t x,size_t y,float f);
   float get(size_t x,size_t y) const;
   float &get(size_t x,size_t y);
@@ -247,6 +249,10 @@
   Row operator[](size_t y);
   const Row operator[](size_t y) const;
 
+  void swapRows(size_t a,size_t b);
+  void swapCols(size_t a,size_t b);
+  
+
 #ifdef SWIG
   %rename(to_s) toString() const;
 #endif
@@ -461,6 +467,9 @@
 
   AGRect2 intersect(const AGRect2 &r) const;
 
+  //result=this-r
+  std::vector<AGRect2> difference(const AGRect2 &r) const;
+
   SDL_Rect sdl() const;
 
   bool operator==(const AGRect2 &r) const;
@@ -470,6 +479,8 @@
 
   AGRect2 alignGrid() const; // align to integer grid
 
+  float content() const;
+
 #ifdef SWIG
   %rename(to_s) toString() const;
 #endif
@@ -613,6 +624,9 @@
   MRow operator[](size_t y);
   //  const Row operator[](size_t y) const;
 
+  void swapRows(size_t a,size_t b);
+  void swapCols(size_t a,size_t b);
+
 #ifdef SWIG
   %rename(to_s) toString() const;
 #endif

Modified: antargis/branches/branch_2d/gui/src/ag_glscreen.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_glscreen.cc	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_glscreen.cc	2007-05-19 14:30:14 UTC (rev 1098)
@@ -251,7 +251,12 @@
 
   initGUIView(w,h);
 }
+void AGGLScreen::update(const std::list<AGRect2> &rs)
+{
+  flip();
+}
 
+
 size_t next2pow(size_t i)
 {
   size_t j=1;

Modified: antargis/branches/branch_2d/gui/src/ag_glscreen.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_glscreen.h	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_glscreen.h	2007-05-19 14:30:14 UTC (rev 1098)
@@ -80,6 +80,7 @@
   AGSurface screenshot(bool frontBuffer=true);
 
   void flip();
+  virtual void update(const std::list<AGRect2> &rs); // call this instead of flip, if you want
   bool inScreen(const AGRect2 &r) const;
 
   virtual size_t getWidth() const;

Modified: antargis/branches/branch_2d/gui/src/ag_painter.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_painter.cc	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_painter.cc	2007-05-19 14:30:14 UTC (rev 1098)
@@ -48,6 +48,20 @@
   a.set(2,2,0);
 }
 
+AGProjection::AGProjection(const AGClipping &pClip):advancedClipping(pClip)
+{
+  a.set(0,0,1);
+  a.set(0,1,0);
+  a.set(0,2,0);
+  a.set(1,0,0);
+  a.set(1,1,1);
+  a.set(1,2,0);
+  a.set(2,0,0);
+  a.set(2,1,0);
+  a.set(2,2,0);
+}
+
+
 AGVector2 AGProjection::project(const AGVector2 &p) const
 {
   AGVector2 r=(a*AGVector3(p[0],p[1],1)).dim2();
@@ -356,17 +370,6 @@
   STACKTRACE;
   float x,y;
 
-  /*
-  for(y=pDest.y0();y<pDest.y1();y+=pSrc.h())
-    for(x=pDest.x0();x<pDest.x1();x+=pSrc.w())
-      {
-	float w=std::min(pSrc.w(),pDest.x1()-x);
-	float h=std::min(pSrc.h(),pDest.y1()-y);
-	blit(pSource,AGRect2(x,y,w,h),AGRect2(pSrc.x0(),pSrc.y0(),w,h));
-      }
-  */
-
-  
   std::vector<std::pair<AGRect2,AGRect2> > rects;
   for(y=pDest.y0();y<pDest.y1();y+=pSrc.h())
     for(x=pDest.x0();x<pDest.x1();x+=pSrc.w())
@@ -377,8 +380,6 @@
 	rects.push_back(std::make_pair(AGRect2(pSrc.x0(),pSrc.y0(),w,h),AGRect2(x,y,w,h)));
       }
   mTarget->blit(pSource,rects,AGColor(0xff,0xff,0xff,0xff));
-  
-
 }
 
 AGColor calcColor(AGVector2 p,const AGColor &pc0,const AGColor &pc1,const AGColor &pc2,const AGColor &pc3)

Modified: antargis/branches/branch_2d/gui/src/ag_painter.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_painter.h	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_painter.h	2007-05-19 14:30:14 UTC (rev 1098)
@@ -26,6 +26,7 @@
 #include <ag_geometry.h>
 #include <ag_font.h>
 #include <ag_painttarget.h>
+#include <ag_clip.h>
 #include <ag_base.h>
 
 
@@ -38,8 +39,10 @@
 {
   AGMatrix3 a;
   AGRect2 clip;
+  AGClipping advancedClipping;
 
   AGProjection(const AGRect2 &pClip);
+  AGProjection(const AGClipping &pClip);
 
   AGVector2 project(const AGVector2 &p) const;
   bool pointOk(const AGVector2 &p) const;
@@ -110,6 +113,9 @@
   void translate(const AGVector2 &v);
   void scale(const AGVector2 &v);
   void clip(const AGRect2 &r);
+
+  void clip(const AGClipping &clip);
+
   void transform(const AGRect2 &r);
 
   AGVector2 project(const AGVector2 &p) const;

Added: antargis/branches/branch_2d/gui/src/ag_projection.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_projection.cc	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_projection.cc	2007-05-19 14:30:14 UTC (rev 1098)
@@ -0,0 +1,27 @@
+#include "ag_projection.h"
+#include "ag_debug.h"
+
+
+AGProjection2D::AGProjection2D(const AGRect2 &from, const AGRect2 &to)
+{
+  assert(from.content()>0 && to.content()>0);
+
+  float sx=to.w()/from.w();
+  float sy=to.h()/from.h();
+
+  m=AGMatrix3(-from.getV0())*AGMatrix3(sx,sy)*AGMatrix3(to.getV0());
+}
+  
+AGRect2 AGProjection2D::project(const AGRect2 &r)
+{
+  return AGRect2((m*r.getV0()).dim2(),(m*r.getV1()).dim2());
+}
+AGVector2 AGProjection2D::project(const AGVector2 &p)
+{
+  return (m*p).dim2();
+}
+
+void AGProjection2D::pushProjection(const AGProjection2D &p)
+{
+  m*=p.m;
+}

Added: antargis/branches/branch_2d/gui/src/ag_projection.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_projection.h	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_projection.h	2007-05-19 14:30:14 UTC (rev 1098)
@@ -0,0 +1,21 @@
+#ifndef AG_PROJECTION
+#define AG_PROJECTION
+
+#include <ag_geometry.h>
+
+
+class AGProjection2D
+{
+  AGMatrix3 m;
+ public:
+  AGProjection2D(const AGRect2 &from, const AGRect2 &to);
+  
+  AGRect2 project(const AGRect2 &r);
+  AGVector2 project(const AGVector2 &p);
+
+  void pushProjection(const AGProjection2D &p);
+};
+
+
+
+#endif

Modified: antargis/branches/branch_2d/gui/src/ag_string_utf8.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_string_utf8.cc	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_string_utf8.cc	2007-05-19 14:30:14 UTC (rev 1098)
@@ -305,6 +305,21 @@
   return n;
 }
 
+AGStringUtf8 AGStringUtf8::operator+(const AGString &s) const
+{
+  AGStringUtf8 n(*this);
+  n+=AGStringUtf8(s);
+  return n;
+}
+
+AGStringUtf8 AGStringUtf8::operator+(const char *s) const
+{
+  AGStringUtf8 n(*this);
+  n+=AGStringUtf8(s);
+  return n;
+}
+
+
 bool AGStringUtf8::operator==(const AGStringUtf8 &p) const
 {
   return s==p.s;

Modified: antargis/branches/branch_2d/gui/src/ag_string_utf8.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_string_utf8.h	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_string_utf8.h	2007-05-19 14:30:14 UTC (rev 1098)
@@ -7,6 +7,7 @@
 #include <ag_base.h>
 
 class AGStringUtf8;
+class AGString;
 
 class AGCharUtf8
 {
@@ -106,6 +107,8 @@
   AGStringUtf8 replace(const AGStringUtf8 &what, const AGStringUtf8 &by) const;
   
   AGStringUtf8 operator+(const AGStringUtf8 &s) const;
+  AGStringUtf8 operator+(const AGString &s) const;
+  AGStringUtf8 operator+(const char *s) const;
 
 
   bool operator==(const AGStringUtf8 &p) const;

Modified: antargis/branches/branch_2d/gui/src/ag_widget.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_widget.cc	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_widget.cc	2007-05-19 14:30:14 UTC (rev 1098)
@@ -32,6 +32,7 @@
 #include "ag_application.h"
 #include "ag_layout.h"
 #include "ag_config.h"
+#include "ag_clip.h"
 
 #define FOCUS_BY_SORT
 
@@ -40,6 +41,19 @@
 
 //AGWidget *agNoParent=0;
 
+static bool gNewClippingTechnique=true;
+
+void setNewClippingTechnique(bool f)
+{
+  gNewClippingTechnique=f;
+}
+bool getNewClippingTechnique()
+{
+  return gNewClippingTechnique;
+}
+
+
+
 class MWidgetSet:public std::set<AGWidget*>
 {
 public:
@@ -399,7 +413,10 @@
 
 void AGWidget::regChange()
 {
-  AGRect2 t=getScreenRect().grow(20);
+  AGRect2 t=getScreenRect().grow(5);
+
+  pushChangeRect(t);
+
   if(mChangeRect.width()==0 || mChangeRect.height()==0)
     mChangeRect=t;
   else
@@ -777,7 +794,14 @@
   return mVisible;
 }
 
+/// override this and return true, if widget is opaque and you want to increase performance
+bool AGWidget::isOpaque() const
+{
+  return false;
+}
 
+
+
 AGWidget *AGWidget::getChild(const AGString &pName)
 {
   if(mName==pName)
@@ -1034,7 +1058,28 @@
   return false;
 }
 
+void AGWidget::acquireClipping(AGClipping &p)
+{
+  if(!visible())
+    return;
 
+  cdebug("clipping before:"<<p.toString());
+  if(isOpaque())
+    p.exclude(getScreenRect());
+  
+  for(std::list<AGRect2>::iterator i=mMyChanges.begin();i!=mMyChanges.end();i++)
+    p.include(*i+getScreenPosition());
+
+  cdebug("clipping in:"<<p.toString());
+  
+  for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();i++)
+    (*i)->acquireClipping(p);
+
+  cdebug("clipping after:"<<p.toString());
+  return;
+}
+
+
 std::list<AGRect2> AGWidget::aquireChanges()
 {
   std::list<AGRect2> l;
@@ -1051,9 +1096,13 @@
 }
 void AGWidget::pushChangeRect(const AGRect2 &pRect)
 {
+  cdebug("push:"<<pRect);
   mMyChanges.push_back(pRect);
 }
 void AGWidget::clearChangeRects()
 {
+  cdebug("clearing - size was:"<<mMyChanges.size());
   mMyChanges.clear();
+  for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();i++)
+    (*i)->clearChangeRects();
 }

Modified: antargis/branches/branch_2d/gui/src/ag_widget.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_widget.h	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/ag_widget.h	2007-05-19 14:30:14 UTC (rev 1098)
@@ -30,6 +30,7 @@
 
 class AGTooltip;
 class AGLayout;
+class AGClipping;
 
 /** 
     \defgroup widgets Widgets
@@ -127,6 +128,7 @@
 
   bool visible() const;
   void setVisible(bool v);
+  bool isOpaque() const;
 
   virtual void setWidth(float w);
   virtual void setHeight(float w);
@@ -199,6 +201,8 @@
 
   void setTooltip(const AGStringUtf8 &pTooltip);
 
+  void acquireClipping(AGClipping &p);
+
   std::list<AGRect2> aquireChanges();
   void pushChangeRect(const AGRect2 &pRect);
   void clearChangeRects();
@@ -250,6 +254,8 @@
 
 AGWidget *toAGWidget(AGMessageObject *o);
 
-//extern AGWidget *agNoParent;
+void setNewClippingTechnique(bool f);
+bool getNewClippingTechnique();
 
+
 #endif

Modified: antargis/branches/branch_2d/gui/src/interface.i
===================================================================
--- antargis/branches/branch_2d/gui/src/interface.i	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/gui/src/interface.i	2007-05-19 14:30:14 UTC (rev 1098)
@@ -30,6 +30,7 @@
 %include "std_string.i"
 %include "std_vector.i"
 %include "std_map.i"
+%include "std_list.i"
 
 %template(StringVector) std::vector<std::string>;
 %template(NodeVector) std::vector<Node*>;

Modified: antargis/branches/branch_2d/ruby/ant_local.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_local.rb	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/ruby/ant_local.rb	2007-05-19 14:30:14 UTC (rev 1098)
@@ -52,7 +52,7 @@
 		read
 	end
 	def process(x)
-		x=x.gsub("\n","\\n")
+		x=x.to_s.gsub("\n","\\n")
 		r=myprocess(x)
 		#puts "TRANSLATE: #{x} #{r.class}"
 		return r

Added: antargis/branches/branch_2d/ruby/tests/algebra_test.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/algebra_test.rb	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/ruby/tests/algebra_test.rb	2007-05-19 14:30:14 UTC (rev 1098)
@@ -0,0 +1,67 @@
+#!/usr/bin/env ruby
+
+require 'libantargis.so'
+include Libantargis
+
+setDebugLevel(0)
+
+def inverseTest
+	m=AGMatrixN.new(4,4)
+	
+	a=
+	[[1,-1,0,0],
+	[0,1,-1,0],
+	[0,0,1,-1],
+	[1,0,0,1]]
+	
+	(0..3).each{|x|
+		(0..3).each{|y|
+			m.set(x,y,a[y][x])
+		}
+	}
+	puts "M:"
+	m.output
+	
+	x=m.inverse
+	
+	y=m*x
+	puts "Y:"
+	y.output
+end
+
+def multTest
+	a=AGMatrixN.new(2,2)
+	b=AGMatrixN.new(2,2)
+	a.makeUnitMatrix
+	b.makeUnitMatrix
+	a.set(0,1,10)
+	b.set(0,1,10)
+	puts "a:"	
+	a.output
+	puts "b:"	
+	b.output
+	c=a*b
+	puts "c:"	
+	c.output
+end
+
+def invTest2
+	a=AGMatrixN.new(3,3)
+	a.set(0,0,1)
+	a.set(0,1,1)
+	a.set(1,0,1)
+	a.set(2,2,2)
+	puts "a:"
+	a.output
+	i=a.inverse
+	puts "i:"
+	i.output
+
+	t=a*i
+	puts "t:"
+	t.output
+end
+
+#multTest
+#invTest2
+inverseTest
\ No newline at end of file

Added: antargis/branches/branch_2d/ruby/tests/basis_test.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/basis_test.rb	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/ruby/tests/basis_test.rb	2007-05-19 14:30:14 UTC (rev 1098)
@@ -0,0 +1,101 @@
+#!/usr/bin/env ruby
+
+require 'libantargis.so'
+include Libantargis
+
+setDebugLevel(0)
+
+def makeBasis
+	m=AGMatrixN.new(2,8)
+	
+	a=[
+	[1,1,1,1],
+	[1,1,-1,-1],
+	[1,-1,0,0],
+	[0,0,1,-1],
+	]
+
+	a=[
+	[1,1,1,1,1,1,1,1],
+	[1,1,1,1,-1,-1,-1,-1],
+	[1,1,-1,-1,0,0,0,0],
+	[0,0,0,0,1,1,-1,-1],
+	[-1,1,0,0,0,0,0,0],
+	[0,0,-1,1,0,0,0,0],
+	[0,0,0,0,-1,1,0,0],
+	]
+
+	
+	(0..7).each{|x|
+		(0..1).each{|y|
+			m.set(y,x,a[y][x])
+		}
+	}
+	m
+end
+
+def makeSample(w)
+	v=AGMatrixN.new(1,w)
+	(0..(w-1)).each{|c|
+		v.set(0,c,rand)
+	}
+	v
+end
+
+def encode(basePair,v)
+	inv=basePair[1]
+	inv*v
+end
+
+def decode(basePair,encodedV)
+	m=basePair[0]
+	m*encodedV
+end
+
+basis=makeBasis
+
+basis.output
+
+inv=basis.pseudoInverse
+
+basePair=[basis,inv]
+
+inv.output
+
+puts "CHECK unit-matrix:"
+(basis*inv).output
+#exit
+
+sample=makeSample(8)
+
+puts "sample:"
+sample.output
+puts "encoded:"
+enc=encode(basePair,sample)
+enc.output
+puts "decoded:"
+dec=decode(basePair,enc)
+dec.output
+
+puts "ERR:"
+puts (dec-sample).scalar
+
+
+err=0
+err2=0
+count=10000
+(0..count).each{|i|
+	sample=makeSample(8)
+	sample2=makeSample(8)
+	err2+=(sample-sample2).scalar
+	enc=encode(basePair,sample)
+	dec=decode(basePair,enc)
+	c=(dec-sample).scalar
+	#puts c
+	err+=c
+	
+}
+
+puts err/count
+puts err2/count
+

Added: antargis/branches/branch_2d/ruby/tests/clip_test.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/clip_test.rb	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/ruby/tests/clip_test.rb	2007-05-19 14:30:14 UTC (rev 1098)
@@ -0,0 +1,37 @@
+#!/usr/bin/env ruby
+
+require 'ruby/antargislib.rb'
+
+r=AGRect2.new(0,0,20,20)
+
+class MyWidget<AGWidget
+	def initialize(p,r)
+		super
+		@a=AGClipping.new
+		@a.exclude(AGRect2.new(0,0,500,500))
+		@a.include(AGRect2.new(100,100,200,200))
+		@a.exclude(AGRect2.new(150,150,50,50))
+	end
+	def draw(p)
+		rs=@a.clip(AGRect2.new(0,0,400,400))
+		rs.each{|r|
+			p.fillRect(r,AGColor.new(
+				(rand*0xFF).to_i,
+				(rand*0xFF).to_i,
+				(rand*0xFF).to_i))
+		}
+	end
+end
+
+class MyApp<AGApplication
+	def initialize
+		super
+		setMainWidget(MyWidget.new(nil,AGRect2.new(0,0,640,480)))
+	end
+	def eventFrame(t)	
+		delay(100)
+		true
+	end
+end
+app=MyApp.new
+app.run
\ No newline at end of file

Added: antargis/branches/branch_2d/ruby/tests/clip_widget_test.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/clip_widget_test.rb	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/ruby/tests/clip_widget_test.rb	2007-05-19 14:30:14 UTC (rev 1098)
@@ -0,0 +1,70 @@
+#!/usr/bin/env ruby
+
+require 'ruby/antargislib.rb'
+
+getMain.initVideo(640,480,32,false,false)
+
+setDebugLevel(0)
+
+class MyWidget<AGWidget
+	def initialize(p,r)
+		super
+	end
+	def draw(p)
+		c=AGColor.new(0xFF,0,0)#(rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
+		p.fillRect(getRect.origin,c)
+	end
+end
+
+class MyWidget2<AGWidget
+	def initialize(p,r)
+		super
+		@x=@y=0
+		eventFrame(0)
+		queryRedraw
+	end
+	def draw(p)
+		c=AGColor.new((rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
+		p.fillRect(getRect.origin,c) #AGColor.new(0,0,0))
+		c=AGColor.new(0,0xFF,0) #(rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
+		p.fillRect(@r,c)
+	end
+	def eventFrame(t)
+		if @inited
+		else
+			pushChangeRect(getRect.origin) #queryRedraw
+			@inited=true
+		end
+		@x+=1
+		@y+=3
+		@x%=width
+		@y%=height
+		@r=AGRect2.new(@x, at y,10,10)
+		pushChangeRect(@r.grow(3))
+		#queryRedraw
+		true
+	end
+end
+
+class MyApp<AGApplication
+	def initialize
+		super
+		@ws=[]
+		@m=MyWidget2.new(nil,AGRect2.new(50,50,200,200))
+		setMainWidget(@m)
+		@ws << MyWidget.new(@m,AGRect2.new(5,5,110,70))
+		@ws << AGButton.new(@m,AGRect2.new(10,10,100,50),AGStringUtf8.new("halo"))
+		puts "adddd..."
+		#@ws.each{|w|@m.addChild(w)}
+		
+
+	end
+	def eventFrame(t)
+		delay(10)
+		@m.eventFrame(t)
+		true
+	end
+end
+
+a=MyApp.new
+a.run
\ No newline at end of file

Modified: antargis/branches/branch_2d/ruby/tests/dirty_rects.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/dirty_rects.rb	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/ruby/tests/dirty_rects.rb	2007-05-19 14:30:14 UTC (rev 1098)
@@ -14,7 +14,7 @@
 	def prepareDraw
 	end
 	def draw(p)
-		p.fillRect(AGRect2.new(0,0,300,300),AGColor.new(0,0,0))
+		#p.fillRect(AGRect2.new(0,0,300,300),AGColor.new(0,0,0))
 		p.fillRect(AGRect2.new(@x, at y,10,10),AGColor.new(0xFF,0,0))
 	end
 	def eventFrame(t)

Added: antargis/branches/branch_2d/ruby/tests/rect_test.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/rect_test.rb	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/ruby/tests/rect_test.rb	2007-05-19 14:30:14 UTC (rev 1098)
@@ -0,0 +1,30 @@
+#!/usr/bin/env ruby
+
+#require 'ruby/antargislib.rb'
+require 'libantargis.so'
+include Libantargis
+
+r=AGRect2.new(0,0,20,20)
+
+def checkPair(a,b)
+	l=a.difference(b)
+	l.each{|r|
+		puts "ERROR: #{r} not in #{a}!" unless a.contains(r)
+		puts "ERROR: #{r} is in #{b}!" if b.contains(r)
+	}
+	puts "size:#{l.length}"
+	#puts l
+end
+
+[5,10].each{|w|
+	[5,10].each{|h|
+		[-20,-10,-5,0,5,10,20,30].each{|x|
+			[-20,-10,-5,0,5,10,20,30].each{|y|
+				a=AGRect2.new(x,y,w,h)
+				checkPair(r,a)
+			}
+		}
+	}
+}
+
+puts "seems ok"
\ No newline at end of file

Modified: antargis/branches/branch_2d/src/antargisgui.h
===================================================================
--- antargis/branches/branch_2d/src/antargisgui.h	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/src/antargisgui.h	2007-05-19 14:30:14 UTC (rev 1098)
@@ -6,6 +6,9 @@
 #include "../gui/src/ag_aes.h"
 #include "../gui/src/ag_singleton.h"
 #include "../gui/src/ag_geometry.h"
+#include "../gui/src/ag_projection.h"
+#include "../gui/src/ag_algebra.h"
+#include "../gui/src/ag_clip.h"
 #include "../gui/src/ag_font.h"
 #include "../gui/src/ag_color.h"
 #include "../gui/src/ag_local.h"
@@ -97,6 +100,9 @@
 %include "../gui/src/ag_aes.h"
 %include "../gui/src/ag_singleton.h"
 %include "../gui/src/ag_geometry.h"
+%include "../gui/src/ag_projection.h"
+%include "../gui/src/ag_algebra.h"
+%include "../gui/src/ag_clip.h"
 %include "../gui/src/ag_font.h"
 %include "../gui/src/ag_color.h"
 %include "../gui/src/ag_local.h"

Modified: antargis/branches/branch_2d/src/interface.i
===================================================================
--- antargis/branches/branch_2d/src/interface.i	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/src/interface.i	2007-05-19 14:30:14 UTC (rev 1098)
@@ -6,6 +6,7 @@
 %include "std_vector.i"
 %include "std_pair.i"
 %include "std_map.i"
+//%include "std_list.i"
 
 %include "nantmarker.hh"
 /*
@@ -81,6 +82,8 @@
 %template(AGMatrixVector) std::vector<AGMatrix4>;
 %template(AGVector2List) std::vector<AGVector2>;
 %template(AGPairVec2Surface) std::pair<AGVector2,AGSurface*>;
+%template(AGRect2Vector) std::vector<AGRect2>;
+//%template(AGRect2List) std::list<AGRect2>;
 
 %include "antargisgui.h"
 

Modified: antargis/branches/branch_2d/src/nantmarker.hh
===================================================================
--- antargis/branches/branch_2d/src/nantmarker.hh	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/src/nantmarker.hh	2007-05-19 14:30:14 UTC (rev 1098)
@@ -2981,6 +2981,11 @@
  Data_Get_Struct($input,AGCircle2,b);
  $result=*b;
 }
+%typemap(directorout) AGClipping {
+ AGClipping *b;
+ Data_Get_Struct($input,AGClipping,b);
+ $result=*b;
+}
 %typemap(directorout) AGCollisionData {
  AGCollisionData *b;
  Data_Get_Struct($input,AGCollisionData,b);
@@ -3151,6 +3156,11 @@
  Data_Get_Struct($input,AGMatrix4,b);
  $result=*b;
 }
+%typemap(directorout) AGMatrixN {
+ AGMatrixN *b;
+ Data_Get_Struct($input,AGMatrixN,b);
+ $result=*b;
+}
 %typemap(directorout) AGMenu {
  AGMenu *b;
  Data_Get_Struct($input,AGMenu,b);
@@ -3186,6 +3196,11 @@
  Data_Get_Struct($input,AGPlugin,b);
  $result=*b;
 }
+%typemap(directorout) AGProjection2D {
+ AGProjection2D *b;
+ Data_Get_Struct($input,AGProjection2D,b);
+ $result=*b;
+}
 %typemap(directorout) AGRadio {
  AGRadio *b;
  Data_Get_Struct($input,AGRadio,b);

Modified: antargis/branches/branch_2d/src/path.cc
===================================================================
--- antargis/branches/branch_2d/src/path.cc	2007-05-13 08:45:12 UTC (rev 1097)
+++ antargis/branches/branch_2d/src/path.cc	2007-05-19 14:30:14 UTC (rev 1098)
@@ -798,7 +798,7 @@
 
   size_t tries=0;
 
-  while(tries<50000 && pathSet.size()>0)
+  while(tries<1000 && pathSet.size()>0)
     {
       Path path=*pathSet.begin();
 



From davidkamphausen at mail.berlios.de  Sun May 27 16:35:55 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 27 May 2007 16:35:55 +0200
Subject: [Antargis-svn] r1099 - in antargis/branches/branch_2d: gui/src ruby
	ruby/tests src
Message-ID: <200705271435.l4REZtE6020554@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-27 16:35:54 +0200 (Sun, 27 May 2007)
New Revision: 1099

Added:
   antargis/branches/branch_2d/src/tests/
Modified:
   antargis/branches/branch_2d/gui/src/ag_application.cc
   antargis/branches/branch_2d/gui/src/ag_clip.cc
   antargis/branches/branch_2d/gui/src/ag_clip_painttarget.cc
   antargis/branches/branch_2d/gui/src/ag_clip_painttarget.h
   antargis/branches/branch_2d/gui/src/ag_draw.h
   antargis/branches/branch_2d/gui/src/ag_gradient.cc
   antargis/branches/branch_2d/gui/src/ag_painter.cc
   antargis/branches/branch_2d/gui/src/ag_painttarget.h
   antargis/branches/branch_2d/gui/src/ag_projection.cc
   antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc
   antargis/branches/branch_2d/gui/src/ag_surface.cc
   antargis/branches/branch_2d/gui/src/ag_texture.cc
   antargis/branches/branch_2d/gui/src/ag_widget.cc
   antargis/branches/branch_2d/gui/src/createmarker.rb
   antargis/branches/branch_2d/ruby/tests/clip_widget_test.rb
   antargis/branches/branch_2d/ruby/two_d_app.rb
   antargis/branches/branch_2d/ruby/view.rb
   antargis/branches/branch_2d/src/interface.i
   antargis/branches/branch_2d/src/mesh_2d.cc
   antargis/branches/branch_2d/src/mesh_2d.h
   antargis/branches/branch_2d/src/nantmarker.hh
Log:
* some speed improvements on sdl-mode
* some cleanup with swig


Modified: antargis/branches/branch_2d/gui/src/ag_application.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_application.cc	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/gui/src/ag_application.cc	2007-05-27 14:35:54 UTC (rev 1099)
@@ -343,6 +343,7 @@
 
 void AGApplication::draw()
 {
+  CTRACE;
   if(delCue.size()>0)
     {
       for(std::list<AGWidget*>::iterator i=delCue.begin();i!=delCue.end();i++)
@@ -359,11 +360,20 @@
 
   STACKTRACE;
   beginRender();
+
+  cdebug("mainWidget:"<<mainWidget);
   if(mainWidget)
     {
       getScreen().begin();
+      
+      AGPainter *p;
       AGClipPaintTarget paintTarget(&getScreen());
-      AGPainter p(paintTarget);
+
+      if(opengl())
+	p=new AGPainter(getScreen());
+      else
+	p=new AGPainter(paintTarget);
+
       clip.exclude(mainWidget->getScreenRect());
       if(pLastDrawn==mainWidget && !opengl())
 	{
@@ -373,7 +383,7 @@
 	      if(mCursor)
 		r+=mCursorOld;
 	      
-	      p.clip(r);
+	      p->clip(r);
 	    }
 	  else
 	    {
@@ -381,10 +391,14 @@
 	      mainWidget->acquireClipping(clip);
 	    }
 	}
+      else
+	{
+	  clip.include(mainWidget->getScreenRect());
+	}
 
       cdebug("CLIP:"<<clip.toString());
       paintTarget.clip(clip);
-      mainWidget->drawAll(p);
+      mainWidget->drawAll(*p);
 
       if(mTooltip)
 	{
@@ -398,6 +412,8 @@
 	}
 
       pLastDrawn=mainWidget;
+
+      delete p;
     }
   else
     cdebug("no mainwidget");

Modified: antargis/branches/branch_2d/gui/src/ag_clip.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_clip.cc	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/gui/src/ag_clip.cc	2007-05-27 14:35:54 UTC (rev 1099)
@@ -1,4 +1,5 @@
 #include "ag_clip.h"
+#include "ag_projection.h"
 #include "ag_stringstream.h"
 #include <stdexcept>
 
@@ -62,12 +63,14 @@
   std::vector<std::pair<AGRect2,AGRect2> > n;
 
   std::vector<AGRect2> t=clip(r);
+
+  AGProjection2D p(r,sync);
   
   for(std::vector<AGRect2>::iterator i=t.begin();i!=t.end();i++)
     {
-      
+      n.push_back(std::make_pair(*i,p.project(*i)));
     }
-  throw std::runtime_error("not implemented yet!");
+
   return n;
 }
 
@@ -82,3 +85,11 @@
 
   return os.str();
 }
+
+std::vector<AGLine2> AGClipping::clip(const AGLine2 &p)
+{
+  #warning "implement me"
+  std::vector<AGLine2> l;
+  l.push_back(p);
+  return l;
+}

Modified: antargis/branches/branch_2d/gui/src/ag_clip_painttarget.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_clip_painttarget.cc	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/gui/src/ag_clip_painttarget.cc	2007-05-27 14:35:54 UTC (rev 1099)
@@ -1,5 +1,6 @@
 #include "ag_clip_painttarget.h"
 #include "ag_debug.h"
+#include "ag_projection.h"
 
 AGClipPaintTarget::AGClipPaintTarget(AGPaintTarget *pTarget):mTarget(pTarget)
 {
@@ -111,3 +112,86 @@
 {
   return mTarget->getRect();
 }
+
+void AGClipPaintTarget::drawGradientAlpha(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr)
+{
+  CTRACE;
+  std::vector<AGRect2> rs=mClipping.clip(rect);
+
+  AGRect2 t(0,0,1,1);
+  AGProjection2D p(rect,t);
+
+  for(std::vector<AGRect2>::iterator i=rs.begin();i!=rs.end();i++)
+    {
+      AGRect2 r2=p.project(*i);
+      float x,y;
+      AGColor ul2,ur2,dl2,dr2;
+      
+      x=r2.x0();y=r2.y0();
+      ul2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x1();y=r2.y0();
+      ur2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x0();y=r2.y1();
+      dl2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x1();y=r2.y1();
+      dr2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      mTarget->drawGradientAlpha(*i,ul2,ur2,dl2,dr2);
+			    
+    }
+}
+
+void AGClipPaintTarget::drawGradient(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr)
+{
+  std::vector<AGRect2> rs=mClipping.clip(rect);
+
+  AGRect2 t(0,0,1,1);
+  AGProjection2D p(rect,t);
+
+  for(std::vector<AGRect2>::iterator i=rs.begin();i!=rs.end();i++)
+    {
+      AGRect2 r2=p.project(*i);
+      float x,y;
+      AGColor ul2,ur2,dl2,dr2;
+
+      cdebug("rect:"<<rect);
+      cdebug("r2:"<<r2);
+      cdebug("i:"<<*i);
+      
+      x=r2.x0();y=r2.y0();
+      ul2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x1();y=r2.y0();
+      ur2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x0();y=r2.y1();
+      dl2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x1();y=r2.y1();
+      dr2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      cdebug("ul:"<<ul);
+      cdebug("ur:"<<ur);
+      cdebug("dl:"<<dl);
+      cdebug("dr:"<<dr);
+
+      cdebug("ul2:"<<ul2);
+      cdebug("ur2:"<<ur2);
+      cdebug("dl2:"<<dl2);
+      cdebug("dr2:"<<dr2);
+
+      mTarget->drawGradient(*i,ul2,ur2,dl2,dr2);
+			    
+    }
+}

Modified: antargis/branches/branch_2d/gui/src/ag_clip_painttarget.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_clip_painttarget.h	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/gui/src/ag_clip_painttarget.h	2007-05-27 14:35:54 UTC (rev 1099)
@@ -44,6 +44,9 @@
   virtual void blit(const AGTexture &pSource,const std::vector<std::pair<AGRect2,AGRect2> > &pSrcDestRects,const AGColor &pColor);
 
   virtual void tile(const AGTexture &pSource,const AGRect2 &pTarget, const AGColor &pColor);
+
+  virtual void drawGradientAlpha(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr);
+  virtual void drawGradient(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr);
    
   virtual AGRect2 getRect() const;
 

Modified: antargis/branches/branch_2d/gui/src/ag_draw.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_draw.h	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/gui/src/ag_draw.h	2007-05-27 14:35:54 UTC (rev 1099)
@@ -24,9 +24,9 @@
 #include "ag_surface.h"
 #include "ag_geometry.h"
 #include "ag_color.h"
-
+/*
 void AGDrawGradient(SDL_Surface *surface, const AGRect2& prect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr);
 void AGDrawGradientAlpha(SDL_Surface *surface, const AGRect2& prect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr);
 void AGDrawBorder(SDL_Surface *surface, const AGRect2& rect,int width, const AGColor& c1, const AGColor& c2);
-
+*/
 #endif

Modified: antargis/branches/branch_2d/gui/src/ag_gradient.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_gradient.cc	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/gui/src/ag_gradient.cc	2007-05-27 14:35:54 UTC (rev 1099)
@@ -27,7 +27,9 @@
 #include "ag_draw.h"
 #include "ag_sgeexport.h"
 
-void AGDrawGradient(SDL_Surface *surface, const AGRect2& prect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr) 
+namespace AGSDLPainter
+{
+void drawGradient(SDL_Surface *surface, const AGRect2& prect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr) 
   {
     AGRect2 rect=prect;
     Sint32 v00,v01,v02;
@@ -199,7 +201,7 @@
     }		
   }
 
-void AGDrawGradientAlpha(SDL_Surface *surface, const AGRect2& prect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr) 
+void drawGradientAlpha(SDL_Surface *surface, const AGRect2& prect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr) 
   {
     AGRect2 rect=prect;
     Sint32 v00,v01,v02,v03;
@@ -429,7 +431,7 @@
   }
 
 
-void AGDrawBorder(SDL_Surface *surface, const AGRect2& rect,int width, const AGColor& c1, const AGColor& c2)
+void drawBorder(SDL_Surface *surface, const AGRect2& rect,int width, const AGColor& c1, const AGColor& c2)
 {
   AGRect2 r=rect;
 
@@ -463,3 +465,5 @@
   surface->drawBorder(rect,width,c1,c2);
 }
 */
+
+}

Modified: antargis/branches/branch_2d/gui/src/ag_painter.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_painter.cc	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/gui/src/ag_painter.cc	2007-05-27 14:35:54 UTC (rev 1099)
@@ -406,6 +406,8 @@
 
   if(p.first.w()>0 && p.first.h()>0 && p.second.w()>0 && p.second.h()>0)
     {
+      mTarget->drawGradient(r,c0,c1,c2,c3);
+      /*
       if(glScreen)
 	{
 	  glScreen->drawGradient(r,c0,c1,c2,c3);
@@ -433,7 +435,7 @@
 		  putPixel(AGVector2(x,y),(c0*(1-cx)+c1*cx)*(1-cy)+(c2*(1-cx)+c3*cx)*cy);
 	    }
 
-	}
+	    }*/
     }
 }
 void AGPainter::renderText(const AGStringUtf8 &pText,const AGVector2 &p,const AGFont &f)

Modified: antargis/branches/branch_2d/gui/src/ag_painttarget.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_painttarget.h	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/gui/src/ag_painttarget.h	2007-05-27 14:35:54 UTC (rev 1099)
@@ -51,6 +51,9 @@
   virtual void blit(const AGTexture &pSource,const std::vector<std::pair<AGRect2,AGRect2> > &pSrcDestRects,const AGColor &pColor)
     MSTUB
 
+  virtual void drawGradientAlpha(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr) MSTUB
+  virtual void drawGradient(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr) MSTUB
+
   virtual void tile(const AGTexture &pSource,const AGRect2 &pTarget, const AGColor &pColor) MSTUB
    
   virtual AGRect2 getRect() const

Modified: antargis/branches/branch_2d/gui/src/ag_projection.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_projection.cc	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/gui/src/ag_projection.cc	2007-05-27 14:35:54 UTC (rev 1099)
@@ -8,8 +8,19 @@
 
   float sx=to.w()/from.w();
   float sy=to.h()/from.h();
+  AGMatrix3 m1(-from.getV0());
+  AGMatrix3 m2(sx,sy);
+  AGMatrix3 m3(to.getV0());
 
-  m=AGMatrix3(-from.getV0())*AGMatrix3(sx,sy)*AGMatrix3(to.getV0());
+  m=m3*m2*m1;
+  /*  cdebug("m1:"<<m1.toString());
+  cdebug("m2:"<<m2.toString());
+  cdebug("m3:"<<m3.toString());
+  
+
+  cdebug("sx:"<<sx);
+  cdebug("sy:"<<sy);
+  cdebug("M:"<<m.toString());*/
 }
   
 AGRect2 AGProjection2D::project(const AGRect2 &r)

Modified: antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/gui/src/ag_sdlsurface.cc	2007-05-27 14:35:54 UTC (rev 1099)
@@ -29,6 +29,8 @@
 #include "ag_sgeexport.h"
 #include <math.h>
 
+#include "ag_sdlpainter.h"
+
 static bool gUseSDLclipping=true;
 
 SDL_Surface *AGCreate32BitSurface(size_t width,size_t height);
@@ -124,15 +126,8 @@
   SDL_Rect sr=pSrc.sdl();
   SDL_Rect dr=pDest.sdl();
 
-  //  cdebug(pDest<<"  "<<pSrc);
-
   SDL_Surface *source=const_cast<AGTexture&>(pSource).sdlTexture()->surface;
 
-  //  cdebug(source->w<<"  "<<source->h);
-
-  //  cdebug(sr.x<<" "<<sr.y<<" "<<sr.w<<" "<<sr.h);
-  //  cdebug(dr.x<<" "<<dr.y<<" "<<dr.w<<" "<<dr.h);
-
   SDL_BlitSurface(source,&sr,s,&dr);
 }
 
@@ -171,84 +166,17 @@
 
 void AGSDLScreen::drawGradientAlpha(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr)
 {
-  AGDrawGradientAlpha(s,rect,ul,ur,dl,dr);
+  AGSDLPainter::drawGradientAlpha(s,rect,ul,ur,dl,dr);
 
 }
 void AGSDLScreen::drawGradient(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr)
 {
-  AGDrawGradient(s,rect,ul,ur,dl,dr);
+  AGSDLPainter::drawGradient(s,rect,ul,ur,dl,dr);
 }
 
 void AGSDLScreen::drawLine(const AGVector2 &pp0,const AGVector2 &pp1,const AGColor &c)
 {
-  AGVector2 p0,p1;
-
-  p0=pp0;
-  p1=pp1;
-
-  float dx=p1[0]-p0[0];
-  float dy=p1[1]-p0[1];
-
-  if(fabs(dx)>fabs(dy))
-    {
-      if(dx<0)
-	{
-	  p0=pp1;
-	  p1=pp0;
-	}
-
-      dx=p1[0]-p0[0];
-      dy=p1[1]-p0[1];
-
-      float y=p0[1];
-      float e=0;
-      float de=((float)dy)/dx;
-      for(float x=p0[0];x<=p1[0];x++)
-	{
-	  sge_PutPixel(s,int(x),int(y),c.mapRGB(s->format));
-	  e+=de;
-	  if(e>0.5)
-	    {
-	      e-=1.0;
-	      y++;
-	    }
-	  else if(e<-0.5)
-	    {
-	      e+=1.0;
-	      y--;
-	    }
-	}
-    }
-  else
-    {
-      if(dy<0)
-	{
-	  p0=pp1;
-	  p1=pp0;
-	}
-
-      dx=p1[0]-p0[0];
-      dy=p1[1]-p0[1];
-
-      float x=p0[0];
-      float e=0;
-      float de=((float)dx)/dy;
-      for(float y=p0[1];y<=p1[1];y++)
-	{
-	  sge_PutPixel(s,int(x),int(y),c.mapRGB(s->format));
-	  e+=de;
-	  if(e>0.5)
-	    {
-	      e-=1.0;
-	      x++;
-	    }
-	  else if(e<-0.5)
-	    {
-	      e+=1.0;
-	      x--;
-	    }
-	}
-    }
+  AGSDLPainter::drawLine(s,pp0,pp1,c);
 }
 
 size_t AGSDLScreen::getWidth() const
@@ -284,10 +212,3 @@
   surface->surface=s;
   return AGSurface(surface).copy();
 }
-/*
-extern "C"
-BOOL APIENTRY DllMain (HINSTANCE hInst, DWORD reason, LPVOID reserved)
-{
-	return true;
-}
-*/

Modified: antargis/branches/branch_2d/gui/src/ag_surface.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_surface.cc	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/gui/src/ag_surface.cc	2007-05-27 14:35:54 UTC (rev 1099)
@@ -30,6 +30,7 @@
 #include "ag_kill.h"
 #include "ag_png.h"
 #include "ag_glscreen.h"
+#include "ag_sdlpainter.h"
 #include "ag_surfacemanager.h"
 
 #include "SDL_image.h"
@@ -274,20 +275,20 @@
 void AGSurface::drawGradient(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr)
 {
   CHECK_ZERO(s);
-  AGDrawGradientAlpha(s->surface,rect,ul,ur,dl,dr);
+  AGSDLPainter::drawGradientAlpha(s->surface,rect,ul,ur,dl,dr);
   s->version++;
 }
 
 void AGSurface::drawGradientAlpha(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr)
 {
   CHECK_ZERO(s);
-  AGDrawGradientAlpha(s->surface,rect,ul,ur,dl,dr);
+  AGSDLPainter::drawGradientAlpha(s->surface,rect,ul,ur,dl,dr);
   s->version++;
 }
 void AGSurface::drawBorder(const AGRect2& rect,int W, const AGColor& c1, const AGColor& c2)
 {
   CHECK_ZERO(s);
-  AGDrawBorder(s->surface,rect,W,c1,c2);
+  AGSDLPainter::drawBorder(s->surface,rect,W,c1,c2);
   s->version++;
 }
 

Modified: antargis/branches/branch_2d/gui/src/ag_texture.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_texture.cc	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/gui/src/ag_texture.cc	2007-05-27 14:35:54 UTC (rev 1099)
@@ -28,6 +28,7 @@
 #include "ag_glpainter.h"
 #include "ag_fbo.h"
 #include "ag_main.h"
+#include "ag_sdlpainter.h"
 #include <stdexcept>
 
 size_t nextpow2(size_t i)
@@ -470,7 +471,8 @@
       AGGLPainter::drawLine(p0,p1,c,2);
     }
   else
-    throw std::runtime_error("implement drawLine for sdl-texture");
+    AGSDLPainter::drawLine(mSDLTexture->surface,p0,p1,c);
+  //    throw std::runtime_error("implement drawLine for sdl-texture");
 }
 
 void AGTexture::drawGradient(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr)
@@ -481,7 +483,8 @@
       AGGLPainter::drawGradientAlpha(rect,ul,ur,dl,dr);
     }
   else
-    throw std::runtime_error("implement drawLine for sdl-texture");
+    AGSDLPainter::drawGradientAlpha(mSDLTexture->surface,rect,ul,ur,dl,dr);
+  //    throw std::runtime_error("implement drawLine for sdl-texture");
 }
 
 void AGTexture::drawGradientAlpha(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr)
@@ -492,7 +495,8 @@
       AGGLPainter::drawGradientAlpha(rect,ul,ur,dl,dr);
     }
   else
-    throw std::runtime_error("implement drawLine for sdl-texture");
+    AGSDLPainter::drawGradientAlpha(mSDLTexture->surface,rect,ul,ur,dl,dr);
+  //    throw std::runtime_error("implement drawLine for sdl-texture");
 }
 
 

Modified: antargis/branches/branch_2d/gui/src/ag_widget.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_widget.cc	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/gui/src/ag_widget.cc	2007-05-27 14:35:54 UTC (rev 1099)
@@ -1063,19 +1063,19 @@
   if(!visible())
     return;
 
-  cdebug("clipping before:"<<p.toString());
+  //  cdebug("clipping before:"<<p.toString());
   if(isOpaque())
     p.exclude(getScreenRect());
   
   for(std::list<AGRect2>::iterator i=mMyChanges.begin();i!=mMyChanges.end();i++)
-    p.include(*i+getScreenPosition());
+    p.include(*i);//+getScreenPosition());
 
-  cdebug("clipping in:"<<p.toString());
+  //  cdebug("clipping in:"<<p.toString());
   
   for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();i++)
     (*i)->acquireClipping(p);
 
-  cdebug("clipping after:"<<p.toString());
+  //  cdebug("clipping after:"<<p.toString());
   return;
 }
 

Modified: antargis/branches/branch_2d/gui/src/createmarker.rb
===================================================================
--- antargis/branches/branch_2d/gui/src/createmarker.rb	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/gui/src/createmarker.rb	2007-05-27 14:35:54 UTC (rev 1099)
@@ -124,25 +124,27 @@
 		file.puts "%typemap(out) #{s}*{"
 		file.puts " if($1)"
 		file.puts " {"
-		file.puts "  if($1->mRubyObject)"
-		file.puts "    $result=$1->mRUBY;"
-		file.puts "  else"
-		file.puts "   {"
-		file.puts "     if(false);"
-		for i in 0..30
-			derivations.each{|a,cs|
-				if cs.length==i && derivations[s].member?(a)
-					#puts s+"  "+a+" "+i.to_s
-					file.puts "else if(dynamic_cast<#{a}*>(result))"
-					file.puts "  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_#{a},0);"
-				end
-			}
-		end
-		file.puts "   else"
-		file.puts "     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_#{s},0);"
-		file.puts "   }"
+		file.puts "   $result=AG_NewPointerObj($1,SWIGTYPE_p_#{s},0);"
 		file.puts " }"
-		file.puts " else vresult=Qnil;"
+# 		file.puts "  if($1->mRubyObject)"
+# 		file.puts "    $result=$1->mRUBY;"
+# 		file.puts "  else"
+# 		file.puts "   {"
+# 		file.puts "     if(false);"
+# 		for i in 0..30
+# 			derivations.each{|a,cs|
+# 				if cs.length==i && derivations[s].member?(a)
+# 					#puts s+"  "+a+" "+i.to_s
+# 					file.puts "else if(dynamic_cast<#{a}*>(result))"
+# 					file.puts "  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_#{a},0);"
+# 				end
+# 			}
+# 		end
+# 		file.puts "   else"
+# 		file.puts "     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_#{s},0);"
+# 		file.puts "   }"
+# 		file.puts " }"
+# 		file.puts " else vresult=Qnil;"
 		file.puts "}"
 
 
@@ -150,25 +152,27 @@
 		file.puts "%typemap(directorin) #{s}*{"
 		file.puts " if($1)"
 		file.puts " {"
-		file.puts "  if($1->mRubyObject)"
-		file.puts "    $input=$1->mRUBY;"
-		file.puts "  else"
-		file.puts "   {"
-		file.puts "     if(false);"
-		for i in 0..30
-			derivations.each{|a,cs|
-				if cs.length==i && derivations[s].member?(a)
-					#puts s+"  "+a+" "+i.to_s
-					file.puts "else if(dynamic_cast<#{a}*>($1))"
-					file.puts "  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_#{a},0);"
-				end
-			}
-		end
-		file.puts "   else"
-		file.puts "     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_#{s},0);"
-		file.puts "   }"
+		file.puts "   $input=AG_NewPointerObj($1,SWIGTYPE_p_#{s},0);"
 		file.puts " }"
-		file.puts " else $input=Qnil;"
+# 		file.puts "  if($1->mRubyObject)"
+# 		file.puts "    $input=$1->mRUBY;"
+# 		file.puts "  else"
+# 		file.puts "   {"
+# 		file.puts "     if(false);"
+# 		for i in 0..30
+# 			derivations.each{|a,cs|
+# 				if cs.length==i && derivations[s].member?(a)
+# 					#puts s+"  "+a+" "+i.to_s
+# 					file.puts "else if(dynamic_cast<#{a}*>($1))"
+# 					file.puts "  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_#{a},0);"
+# 				end
+# 			}
+# 		end
+# 		file.puts "   else"
+# 		file.puts "     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_#{s},0);"
+# 		file.puts "   }"
+# 		file.puts " }"
+# 		file.puts " else $input=Qnil;"
 		file.puts "}"
 end
 
@@ -186,6 +190,45 @@
 file.puts "%typemap(directorout) Uint8 {"
 file.puts " $result=NUM2INT($input);"
 file.puts "}"
+
+
+truncClasses={}
+
+deriveList.each{|b,a|
+	if rubyClasses[b] and rubyClasses[a]
+		#puts "DERIVE #{a} #{b}"
+		truncClasses[a]||=[]
+		truncClasses[a] << b
+	end
+}
+truncClasses.each{|k,a|
+	file.puts <<EOT
+%{
+static swig_type_info* #{k}_dynamic_cast(void **ptr) {
+EOT
+			a.each{|x|
+				file.puts <<EOT
+  {
+		#{x} *e = dynamic_cast<#{x} *>((#{k}*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_#{x};
+		}
+  }
+EOT
+			}
+	file.puts <<EOT
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_#{k}, #{k}_dynamic_cast);
+EOT
+
+
+}
+exit
+
 file.close
 
 # now generate antargis.h

Modified: antargis/branches/branch_2d/ruby/tests/clip_widget_test.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/clip_widget_test.rb	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/ruby/tests/clip_widget_test.rb	2007-05-27 14:35:54 UTC (rev 1099)
@@ -25,9 +25,10 @@
 	end
 	def draw(p)
 		c=AGColor.new((rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
+		#c=AGColor.new(0,0,0)
 		p.fillRect(getRect.origin,c) #AGColor.new(0,0,0))
 		c=AGColor.new(0,0xFF,0) #(rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
-		p.fillRect(@r,c)
+		#p.fillRect(@r,c)
 	end
 	def eventFrame(t)
 		if @inited

Modified: antargis/branches/branch_2d/ruby/two_d_app.rb
===================================================================
--- antargis/branches/branch_2d/ruby/two_d_app.rb	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/ruby/two_d_app.rb	2007-05-27 14:35:54 UTC (rev 1099)
@@ -12,27 +12,70 @@
 	end
 end
 
-class AntBaseMapView<AGApplication
-	def initialize(w,h)
-		super()
-		@scene=Scene2D.new(w,h)
-		@submain=nil
+class AntBaseMapViewWidget<AGWidget
+	def initialize(p,r,scene)
+		super(p,r)
+		@scene=scene
 	end
 
-	def draw
+	def draw(p)
 		@frame||=0
 		@frame+=1
 
 		#if (@frame%2)==0
-			p=AGPainter.new
+			#p=AGPainter.new
 			@scene.setPainter(p)
 			@scene.draw
 			@scene.discardPainter
-			p=nil
-			GC.start
+			#p=nil
+			#GC.start
 		#end
 		super
 	end
+	def prepareDraw
+		queryRedraw
+		return
+		currentNodes=@scene.getCurrentNodes
+		puts "currentNodes:#{currentNodes}(#{currentNodes.class})!"
+		currentNodes.each{|n|
+			r=n.getLastDrawingRect
+			r2=n.getDrawingRect
+			if r!=r2
+				pushChangeRect(r)
+				pushChangeRect(r2)
+			end
+		}
+
+	end
+end
+
+class AntBaseMapView<AGApplication
+	def initialize(w,h)
+		super()
+		@scene=Scene2D.new(w,h)
+		@submain=nil
+		@mainWidget=nil
+		setMainWidget(@realMainWidget=AntBaseMapViewWidget.new(nil,AGRect2.new(0,0,w,h), at scene))
+	end
+
+ 	def setMainWidget(w)
+ 		if w.is_a?(AntBaseMapViewWidget)
+ 			super(w)
+ 		else
+ 			@realMainWidget.removeChild(@mainWidget) if @mainWidget
+ 			@mainWidget=w
+ 			@realMainWidget.addChild(w)
+ 		end
+ 	end
+ 
+ 	def getMainWidget
+ 		@mainWidget
+ 	end
+# 	def draw()
+# 		super()
+# 	end
+
+
 	def getScene
 		@scene
 	end

Modified: antargis/branches/branch_2d/ruby/view.rb
===================================================================
--- antargis/branches/branch_2d/ruby/view.rb	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/ruby/view.rb	2007-05-27 14:35:54 UTC (rev 1099)
@@ -43,7 +43,7 @@
 		@controls=true
 	end
 
-	def draw
+	def prepareDraw
 		updateNamePositions
 		super
 	end

Modified: antargis/branches/branch_2d/src/interface.i
===================================================================
--- antargis/branches/branch_2d/src/interface.i	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/src/interface.i	2007-05-27 14:35:54 UTC (rev 1099)
@@ -6,8 +6,40 @@
 %include "std_vector.i"
 %include "std_pair.i"
 %include "std_map.i"
-//%include "std_list.i"
+%include "std_list.i"
+#include "antargis.h"
 
+%{
+#include "scene.h"
+#include "antargisgui.h"
+
+%}
+
+%{
+
+SWIGRUNTIME VALUE
+AG_NewPointerObj(void *ptr, swig_type_info *type, int flags)
+{
+/* 	cdebug("ptr:"<<ptr); */
+	AGRubyObject *o=(AGRubyObject*)ptr;
+/*	cdebug("o:"<<o);
+	cdebug("o:"<<o->mRubyObject);
+	cdebug("o:"<<o->mRUBY);*/
+	if(o->mRubyObject)
+		return o->mRUBY;
+
+	swig_type_info *t=SWIG_TypeDynamicCast(type,(void**)&o);
+
+	o->mRubyObject=true;
+	o->mRUBY=SWIG_NewPointerObj((void *) o, t,flags);
+/*	cdebug("o:"<<o);
+	cdebug("o:"<<o->mRubyObject);
+	cdebug("o:"<<o->mRUBY);*/
+	return o->mRUBY;
+}
+
+%}
+
 %include "nantmarker.hh"
 /*
 %typemap(typecheck) AGString= char *;
@@ -68,6 +100,7 @@
 %{
 #include "scene.h"
 #include "antargisgui.h"
+
 %}
 
 %template(StringVector) std::vector<std::string>;
@@ -83,7 +116,8 @@
 %template(AGVector2List) std::vector<AGVector2>;
 %template(AGPairVec2Surface) std::pair<AGVector2,AGSurface*>;
 %template(AGRect2Vector) std::vector<AGRect2>;
-//%template(AGRect2List) std::list<AGRect2>;
+%template(AGRect2List) std::list<AGRect2>;
+%template(SceneNodeList) std::list<SceneNode*>;
 
 %include "antargisgui.h"
 

Modified: antargis/branches/branch_2d/src/mesh_2d.cc
===================================================================
--- antargis/branches/branch_2d/src/mesh_2d.cc	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/src/mesh_2d.cc	2007-05-27 14:35:54 UTC (rev 1099)
@@ -41,9 +41,16 @@
   float h=t->height();
   AGRect2 r(middle.getX()-w/2,middle.getY()-h/2,w,h);
 
+  mLast=r;
+
   return r;
 }
 
+AGRect2 Mesh2D::getLastDrawingRect()
+{
+  return mLast;
+}
+
 AGVector4 Mesh2D::lineHit(const AGLine3 &pLine) const
 {
   //FIXME

Modified: antargis/branches/branch_2d/src/mesh_2d.h
===================================================================
--- antargis/branches/branch_2d/src/mesh_2d.h	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/src/mesh_2d.h	2007-05-27 14:35:54 UTC (rev 1099)
@@ -31,8 +31,13 @@
  public:
 
   AGRect2 getDrawingRect();
+  AGRect2 getLastDrawingRect();
 
   Mesh2DData *mData;
+
+
+ private:
+  AGRect2 mLast;
 };
 
 

Modified: antargis/branches/branch_2d/src/nantmarker.hh
===================================================================
--- antargis/branches/branch_2d/src/nantmarker.hh	2007-05-19 14:30:14 UTC (rev 1098)
+++ antargis/branches/branch_2d/src/nantmarker.hh	2007-05-27 14:35:54 UTC (rev 1099)
@@ -661,2270 +661,782 @@
 %typemap(out) MapPathWeighter*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MapPathWeighter,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_MapPathWeighter,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) MapPathWeighter*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MapPathWeighter,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_MapPathWeighter,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGRadio*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGRadio,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGRadio*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRadio,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGRadio,0);
  }
- else $input=Qnil;
 }
 %typemap(out) GLApp*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GLApp,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_GLApp,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) GLApp*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_GLApp,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_GLApp,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGDialog*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGDialog,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGDialog*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGDialog,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGDialog,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AnimMeshData*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AnimMeshData,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AnimMeshData,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AnimMeshData*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AnimMeshData,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AnimMeshData,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGScroller*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScroller,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGScroller,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGScroller*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGScroller,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGScroller,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AnimMesh*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AnimMesh,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AnimMesh,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AnimMesh*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AnimMesh,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AnimMesh,0);
  }
- else $input=Qnil;
 }
 %typemap(out) Scene*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_Scene,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) Scene*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Scene,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_Scene,0);
  }
- else $input=Qnil;
 }
 %typemap(out) WaterPiece*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_WaterPiece,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_WaterPiece,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) WaterPiece*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_WaterPiece,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_WaterPiece,0);
  }
- else $input=Qnil;
 }
 %typemap(out) Mesh2D*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh2D,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_Mesh2D,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) Mesh2D*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Mesh2D,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_Mesh2D,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGText*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGCaption*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGText,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGText*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGCaption*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGCaption,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGText,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGText,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGScreenWidget*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreenWidget,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGScreenWidget,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGScreenWidget*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGScreenWidget,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGScreenWidget,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGSubMenu*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGSubMenu,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGSubMenu*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGSubMenu,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGSubMenu,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGWidget*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGRadio*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
-else if(dynamic_cast<AGDialog*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
-else if(dynamic_cast<AGScroller*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScroller,0);
-else if(dynamic_cast<AGScreenWidget*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreenWidget,0);
-else if(dynamic_cast<AGSubMenu*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
-else if(dynamic_cast<AGComboBox*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGComboBox,0);
-else if(dynamic_cast<AGListBox*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
-else if(dynamic_cast<AGCaption*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
-else if(dynamic_cast<AGRadioGroup*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
-else if(dynamic_cast<AGWindow*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
-else if(dynamic_cast<MiniMap*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
-else if(dynamic_cast<AGMenu*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
-else if(dynamic_cast<AGColorButton*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
-else if(dynamic_cast<AGImage*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
-else if(dynamic_cast<AGGLWidget*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
-else if(dynamic_cast<AGEdit*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
-else if(dynamic_cast<AGSound*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
-else if(dynamic_cast<AGText*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
-else if(dynamic_cast<AGLayout*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
-else if(dynamic_cast<AGMenuItem*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
-else if(dynamic_cast<AGCheckBox*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
-else if(dynamic_cast<AGButton*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
-else if(dynamic_cast<AGTable*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGWidget,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGWidget*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGRadio*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRadio,0);
-else if(dynamic_cast<AGDialog*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGDialog,0);
-else if(dynamic_cast<AGScroller*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGScroller,0);
-else if(dynamic_cast<AGScreenWidget*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGScreenWidget,0);
-else if(dynamic_cast<AGSubMenu*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGSubMenu,0);
-else if(dynamic_cast<AGComboBox*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGComboBox,0);
-else if(dynamic_cast<AGListBox*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGListBox,0);
-else if(dynamic_cast<AGCaption*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGCaption,0);
-else if(dynamic_cast<AGRadioGroup*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRadioGroup,0);
-else if(dynamic_cast<AGWindow*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGWindow,0);
-else if(dynamic_cast<MiniMap*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MiniMap,0);
-else if(dynamic_cast<AGMenu*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenu,0);
-else if(dynamic_cast<AGColorButton*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGColorButton,0);
-else if(dynamic_cast<AGImage*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGImage,0);
-else if(dynamic_cast<AGGLWidget*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGGLWidget,0);
-else if(dynamic_cast<AGEdit*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGEdit,0);
-else if(dynamic_cast<AGSound*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGSound,0);
-else if(dynamic_cast<AGText*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGText,0);
-else if(dynamic_cast<AGLayout*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGLayout,0);
-else if(dynamic_cast<AGMenuItem*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenuItem,0);
-else if(dynamic_cast<AGCheckBox*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGCheckBox,0);
-else if(dynamic_cast<AGButton*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGButton,0);
-else if(dynamic_cast<AGTable*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGTable,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGWidget,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGWidget,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGApplication*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<GLApp*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GLApp,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGApplication,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGApplication,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGApplication*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<GLApp*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_GLApp,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGApplication,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGApplication,0);
  }
- else $input=Qnil;
 }
 %typemap(out) Mesh2DData*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh2DData,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_Mesh2DData,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) Mesh2DData*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Mesh2DData,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_Mesh2DData,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGFontEngine*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGFontEngine,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGFontEngine,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGFontEngine*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGFontEngine,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGFontEngine,0);
  }
- else $input=Qnil;
 }
 %typemap(out) Pathfinder*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Pathfinder,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_Pathfinder,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) Pathfinder*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Pathfinder,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_Pathfinder,0);
  }
- else $input=Qnil;
 }
 %typemap(out) TerrainBase*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<Terrain*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Terrain,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_TerrainBase,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_TerrainBase,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) TerrainBase*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<Terrain*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Terrain,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_TerrainBase,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_TerrainBase,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGComboBox*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGComboBox,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGComboBox,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGComboBox*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGComboBox,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGComboBox,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGTexture*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTexture,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGTexture,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGTexture*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGTexture,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGTexture,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGSingleton*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGFontEngine*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGFontEngine,0);
-else if(dynamic_cast<AGLayoutCreator*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayoutCreator,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSingleton,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGSingleton,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGSingleton*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGFontEngine*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGFontEngine,0);
-else if(dynamic_cast<AGLayoutCreator*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGLayoutCreator,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGSingleton,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGSingleton,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGPlugin*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGPlugin,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGPlugin,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGPlugin*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGPlugin,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGPlugin,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGTable*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGSubMenu*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
-else if(dynamic_cast<AGWindow*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
-else if(dynamic_cast<AGMenu*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
-else if(dynamic_cast<AGMenuItem*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGTable,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGTable*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGSubMenu*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGSubMenu,0);
-else if(dynamic_cast<AGWindow*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGWindow,0);
-else if(dynamic_cast<AGMenu*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenu,0);
-else if(dynamic_cast<AGMenuItem*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenuItem,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGTable,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGTable,0);
  }
- else $input=Qnil;
 }
 %typemap(out) HeightMap*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AntMap*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntMap,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_HeightMap,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_HeightMap,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) HeightMap*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AntMap*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntMap,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_HeightMap,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_HeightMap,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGLayout*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGDialog*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGLayout,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGLayout*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGDialog*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGDialog,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGLayout,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGLayout,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGListBox*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGListBox,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGListBox*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGListBox,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGListBox,0);
  }
- else $input=Qnil;
 }
 %typemap(out) MeshData*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MeshData,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_MeshData,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) MeshData*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MeshData,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_MeshData,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGMessageObject*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGRadio*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
-else if(dynamic_cast<GLApp*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GLApp,0);
-else if(dynamic_cast<AGDialog*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
-else if(dynamic_cast<AGScroller*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScroller,0);
-else if(dynamic_cast<AGScreenWidget*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreenWidget,0);
-else if(dynamic_cast<AGSubMenu*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
-else if(dynamic_cast<AGComboBox*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGComboBox,0);
-else if(dynamic_cast<AGListBox*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
-else if(dynamic_cast<AGCaption*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
-else if(dynamic_cast<AGRadioGroup*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
-else if(dynamic_cast<AGWindow*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
-else if(dynamic_cast<AntMap*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntMap,0);
-else if(dynamic_cast<MiniMap*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
-else if(dynamic_cast<AGMenu*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
-else if(dynamic_cast<AGColorButton*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
-else if(dynamic_cast<AGImage*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
-else if(dynamic_cast<AGGLWidget*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
-else if(dynamic_cast<AGEdit*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
-else if(dynamic_cast<AGSound*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
-else if(dynamic_cast<AGText*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
-else if(dynamic_cast<AGApplication*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGApplication,0);
-else if(dynamic_cast<HeightMap*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_HeightMap,0);
-else if(dynamic_cast<AGLayout*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
-else if(dynamic_cast<AGMenuItem*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
-else if(dynamic_cast<AGCheckBox*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
-else if(dynamic_cast<AGButton*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
-else if(dynamic_cast<AGTable*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
-else if(dynamic_cast<AGWidget*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMessageObject,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGMessageObject,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGMessageObject*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGRadio*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRadio,0);
-else if(dynamic_cast<GLApp*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_GLApp,0);
-else if(dynamic_cast<AGDialog*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGDialog,0);
-else if(dynamic_cast<AGScroller*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGScroller,0);
-else if(dynamic_cast<AGScreenWidget*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGScreenWidget,0);
-else if(dynamic_cast<AGSubMenu*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGSubMenu,0);
-else if(dynamic_cast<AGComboBox*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGComboBox,0);
-else if(dynamic_cast<AGListBox*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGListBox,0);
-else if(dynamic_cast<AGCaption*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGCaption,0);
-else if(dynamic_cast<AGRadioGroup*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRadioGroup,0);
-else if(dynamic_cast<AGWindow*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGWindow,0);
-else if(dynamic_cast<AntMap*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntMap,0);
-else if(dynamic_cast<MiniMap*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MiniMap,0);
-else if(dynamic_cast<AGMenu*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenu,0);
-else if(dynamic_cast<AGColorButton*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGColorButton,0);
-else if(dynamic_cast<AGImage*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGImage,0);
-else if(dynamic_cast<AGGLWidget*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGGLWidget,0);
-else if(dynamic_cast<AGEdit*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGEdit,0);
-else if(dynamic_cast<AGSound*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGSound,0);
-else if(dynamic_cast<AGText*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGText,0);
-else if(dynamic_cast<AGApplication*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGApplication,0);
-else if(dynamic_cast<HeightMap*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_HeightMap,0);
-else if(dynamic_cast<AGLayout*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGLayout,0);
-else if(dynamic_cast<AGMenuItem*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenuItem,0);
-else if(dynamic_cast<AGCheckBox*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGCheckBox,0);
-else if(dynamic_cast<AGButton*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGButton,0);
-else if(dynamic_cast<AGTable*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGTable,0);
-else if(dynamic_cast<AGWidget*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGWidget,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMessageObject,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGMessageObject,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGCaption*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGCaption,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGCaption*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGCaption,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGCaption,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AntImpostorData*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntImpostorData,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AntImpostorData,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AntImpostorData*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntImpostorData,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AntImpostorData,0);
  }
- else $input=Qnil;
 }
 %typemap(out) Terrain*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Terrain,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_Terrain,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) Terrain*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Terrain,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_Terrain,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGRadioGroup*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGRadioGroup,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGRadioGroup*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRadioGroup,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGRadioGroup,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGWindow*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGWindow,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGWindow*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGWindow,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGWindow,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AntEntity*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntEntity,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AntEntity,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AntEntity*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntEntity,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AntEntity,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGMenuItem*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGSubMenu*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGMenuItem,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGMenuItem*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGSubMenu*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGSubMenu,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenuItem,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGMenuItem,0);
  }
- else $input=Qnil;
 }
 %typemap(out) PathWeighter*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<MapPathWeighter*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MapPathWeighter,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PathWeighter,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_PathWeighter,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) PathWeighter*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<MapPathWeighter*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MapPathWeighter,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_PathWeighter,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_PathWeighter,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AntMap*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntMap,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AntMap,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AntMap*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntMap,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AntMap,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGMenu*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGMenu,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGMenu*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenu,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGMenu,0);
  }
- else $input=Qnil;
 }
 %typemap(out) MiniMap*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_MiniMap,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) MiniMap*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MiniMap,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_MiniMap,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGColorButton*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGColorButton,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGColorButton*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGColorButton,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGColorButton,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGImage*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGImage,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGImage*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGImage,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGImage,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGMain*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMain,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGMain,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGMain*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMain,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGMain,0);
  }
- else $input=Qnil;
 }
 %typemap(out) SceneNode*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AnimMesh*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AnimMesh,0);
-else if(dynamic_cast<Mesh2D*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh2D,0);
-else if(dynamic_cast<WaterPiece*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_WaterPiece,0);
-else if(dynamic_cast<AntImpostor*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntImpostor,0);
-else if(dynamic_cast<Smoke*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Smoke,0);
-else if(dynamic_cast<Mesh*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh,0);
-else if(dynamic_cast<NewDecal*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NewDecal,0);
-else if(dynamic_cast<TerrainPiece*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_TerrainPiece,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SceneNode,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_SceneNode,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) SceneNode*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AnimMesh*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AnimMesh,0);
-else if(dynamic_cast<Mesh2D*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Mesh2D,0);
-else if(dynamic_cast<WaterPiece*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_WaterPiece,0);
-else if(dynamic_cast<AntImpostor*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntImpostor,0);
-else if(dynamic_cast<Smoke*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Smoke,0);
-else if(dynamic_cast<Mesh*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Mesh,0);
-else if(dynamic_cast<NewDecal*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_NewDecal,0);
-else if(dynamic_cast<TerrainPiece*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_TerrainPiece,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_SceneNode,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_SceneNode,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGLayoutCreator*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayoutCreator,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGLayoutCreator,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGLayoutCreator*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGLayoutCreator,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGLayoutCreator,0);
  }
- else $input=Qnil;
 }
 %typemap(out) Scene2D*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene2D,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_Scene2D,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) Scene2D*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Scene2D,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_Scene2D,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AntImpostor*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntImpostor,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AntImpostor,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AntImpostor*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntImpostor,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AntImpostor,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGRandomizer*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRandomizer,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGRandomizer,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGRandomizer*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRandomizer,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGRandomizer,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGGLScreen*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLScreen,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGGLScreen,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGGLScreen*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGGLScreen,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGGLScreen,0);
  }
- else $input=Qnil;
 }
 %typemap(out) SceneBase*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<Scene*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene,0);
-else if(dynamic_cast<Scene2D*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene2D,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SceneBase,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_SceneBase,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) SceneBase*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<Scene*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Scene,0);
-else if(dynamic_cast<Scene2D*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Scene2D,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_SceneBase,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_SceneBase,0);
  }
- else $input=Qnil;
 }
 %typemap(out) DecimatedGraph*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_DecimatedGraph,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_DecimatedGraph,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) DecimatedGraph*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_DecimatedGraph,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_DecimatedGraph,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGGLWidget*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGGLWidget,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGGLWidget*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGGLWidget,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGGLWidget,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGSurface*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSurface,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGSurface,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGSurface*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGSurface,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGSurface,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGScreen*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGGLScreen*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLScreen,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreen,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGScreen,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGScreen*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGGLScreen*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGGLScreen,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGScreen,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGScreen,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGEdit*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGEdit,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGEdit*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGEdit,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGEdit,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGCheckBox*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGRadio*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGCheckBox,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGCheckBox*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGRadio*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRadio,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGCheckBox,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGCheckBox,0);
  }
- else $input=Qnil;
 }
 %typemap(out) Smoke*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Smoke,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_Smoke,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) Smoke*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Smoke,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_Smoke,0);
  }
- else $input=Qnil;
 }
 %typemap(out) SimpleGraph*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<DecimatedGraph*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_DecimatedGraph,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SimpleGraph,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_SimpleGraph,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) SimpleGraph*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<DecimatedGraph*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_DecimatedGraph,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_SimpleGraph,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_SimpleGraph,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGSound*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGSound,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGSound*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGSound,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGSound,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGPaintTarget*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGTexture*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTexture,0);
-else if(dynamic_cast<AGGLScreen*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLScreen,0);
-else if(dynamic_cast<AGSurface*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSurface,0);
-else if(dynamic_cast<AGScreen*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreen,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGPaintTarget,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGPaintTarget,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGPaintTarget*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGTexture*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGTexture,0);
-else if(dynamic_cast<AGGLScreen*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGGLScreen,0);
-else if(dynamic_cast<AGSurface*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGSurface,0);
-else if(dynamic_cast<AGScreen*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGScreen,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGPaintTarget,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGPaintTarget,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGButton*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGRadio*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
-else if(dynamic_cast<AGCheckBox*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGButton,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGButton*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGRadio*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRadio,0);
-else if(dynamic_cast<AGCheckBox*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGCheckBox,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGButton,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGButton,0);
  }
- else $input=Qnil;
 }
 %typemap(out) AGListener*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGRadio*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
-else if(dynamic_cast<GLApp*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GLApp,0);
-else if(dynamic_cast<AGDialog*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGDialog,0);
-else if(dynamic_cast<AGScroller*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScroller,0);
-else if(dynamic_cast<AGScreenWidget*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGScreenWidget,0);
-else if(dynamic_cast<AGSubMenu*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSubMenu,0);
-else if(dynamic_cast<AGComboBox*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGComboBox,0);
-else if(dynamic_cast<AGListBox*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListBox,0);
-else if(dynamic_cast<AGCaption*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
-else if(dynamic_cast<AGRadioGroup*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
-else if(dynamic_cast<AGWindow*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
-else if(dynamic_cast<AntMap*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntMap,0);
-else if(dynamic_cast<MiniMap*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
-else if(dynamic_cast<AGMenu*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
-else if(dynamic_cast<AGColorButton*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
-else if(dynamic_cast<AGImage*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
-else if(dynamic_cast<AGGLWidget*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGGLWidget,0);
-else if(dynamic_cast<AGEdit*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGEdit,0);
-else if(dynamic_cast<AGSound*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGSound,0);
-else if(dynamic_cast<AGText*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
-else if(dynamic_cast<AGApplication*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGApplication,0);
-else if(dynamic_cast<HeightMap*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_HeightMap,0);
-else if(dynamic_cast<AGLayout*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGLayout,0);
-else if(dynamic_cast<AGMenuItem*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenuItem,0);
-else if(dynamic_cast<AGCheckBox*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCheckBox,0);
-else if(dynamic_cast<AGButton*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGButton,0);
-else if(dynamic_cast<AGTable*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGTable,0);
-else if(dynamic_cast<AGWidget*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWidget,0);
-else if(dynamic_cast<AGMessageObject*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMessageObject,0);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGListener,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_AGListener,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) AGListener*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-else if(dynamic_cast<AGRadio*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRadio,0);
-else if(dynamic_cast<GLApp*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_GLApp,0);
-else if(dynamic_cast<AGDialog*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGDialog,0);
-else if(dynamic_cast<AGScroller*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGScroller,0);
-else if(dynamic_cast<AGScreenWidget*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGScreenWidget,0);
-else if(dynamic_cast<AGSubMenu*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGSubMenu,0);
-else if(dynamic_cast<AGComboBox*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGComboBox,0);
-else if(dynamic_cast<AGListBox*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGListBox,0);
-else if(dynamic_cast<AGCaption*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGCaption,0);
-else if(dynamic_cast<AGRadioGroup*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRadioGroup,0);
-else if(dynamic_cast<AGWindow*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGWindow,0);
-else if(dynamic_cast<AntMap*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntMap,0);
-else if(dynamic_cast<MiniMap*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MiniMap,0);
-else if(dynamic_cast<AGMenu*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenu,0);
-else if(dynamic_cast<AGColorButton*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGColorButton,0);
-else if(dynamic_cast<AGImage*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGImage,0);
-else if(dynamic_cast<AGGLWidget*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGGLWidget,0);
-else if(dynamic_cast<AGEdit*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGEdit,0);
-else if(dynamic_cast<AGSound*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGSound,0);
-else if(dynamic_cast<AGText*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGText,0);
-else if(dynamic_cast<AGApplication*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGApplication,0);
-else if(dynamic_cast<HeightMap*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_HeightMap,0);
-else if(dynamic_cast<AGLayout*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGLayout,0);
-else if(dynamic_cast<AGMenuItem*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenuItem,0);
-else if(dynamic_cast<AGCheckBox*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGCheckBox,0);
-else if(dynamic_cast<AGButton*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGButton,0);
-else if(dynamic_cast<AGTable*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGTable,0);
-else if(dynamic_cast<AGWidget*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGWidget,0);
-else if(dynamic_cast<AGMessageObject*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMessageObject,0);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGListener,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_AGListener,0);
  }
- else $input=Qnil;
 }
 %typemap(out) Mesh*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Mesh,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_Mesh,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) Mesh*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Mesh,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_Mesh,0);
  }
- else $input=Qnil;
 }
 %typemap(out) TerrainPiece*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_TerrainPiece,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_TerrainPiece,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) TerrainPiece*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_TerrainPiece,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_TerrainPiece,0);
  }
- else $input=Qnil;
 }
 %typemap(out) NewDecal*{
  if($1)
  {
-  if($1->mRubyObject)
-    $result=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NewDecal,0);
-   }
+   $result=AG_NewPointerObj($1,SWIGTYPE_p_NewDecal,0);
  }
- else vresult=Qnil;
 }
 %typemap(directorin) NewDecal*{
  if($1)
  {
-  if($1->mRubyObject)
-    $input=$1->mRUBY;
-  else
-   {
-     if(false);
-   else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_NewDecal,0);
-   }
+   $input=AG_NewPointerObj($1,SWIGTYPE_p_NewDecal,0);
  }
- else $input=Qnil;
 }
 %typemap(directorout) AGApplication {
  AGApplication *b;
@@ -3669,3 +2181,643 @@
 %typemap(directorout) Uint8 {
  $result=NUM2INT($input);
 }
+%{
+static swig_type_info* AGMessageObject_dynamic_cast(void **ptr) {
+  {
+		AGWidget *e = dynamic_cast<AGWidget *>((AGMessageObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGWidget;
+		}
+  }
+  {
+		AGApplication *e = dynamic_cast<AGApplication *>((AGMessageObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGApplication;
+		}
+  }
+  {
+		HeightMap *e = dynamic_cast<HeightMap *>((AGMessageObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_HeightMap;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_AGMessageObject, AGMessageObject_dynamic_cast);
+%{
+static swig_type_info* SceneBase_dynamic_cast(void **ptr) {
+  {
+		Scene *e = dynamic_cast<Scene *>((SceneBase*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_Scene;
+		}
+  }
+  {
+		Scene2D *e = dynamic_cast<Scene2D *>((SceneBase*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_Scene2D;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_SceneBase, SceneBase_dynamic_cast);
+%{
+static swig_type_info* AGTable_dynamic_cast(void **ptr) {
+  {
+		AGWindow *e = dynamic_cast<AGWindow *>((AGTable*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGWindow;
+		}
+  }
+  {
+		AGMenuItem *e = dynamic_cast<AGMenuItem *>((AGTable*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGMenuItem;
+		}
+  }
+  {
+		AGMenu *e = dynamic_cast<AGMenu *>((AGTable*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGMenu;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_AGTable, AGTable_dynamic_cast);
+%{
+static swig_type_info* AGText_dynamic_cast(void **ptr) {
+  {
+		AGCaption *e = dynamic_cast<AGCaption *>((AGText*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGCaption;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_AGText, AGText_dynamic_cast);
+%{
+static swig_type_info* AGMenuItem_dynamic_cast(void **ptr) {
+  {
+		AGSubMenu *e = dynamic_cast<AGSubMenu *>((AGMenuItem*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGSubMenu;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_AGMenuItem, AGMenuItem_dynamic_cast);
+%{
+static swig_type_info* AGCheckBox_dynamic_cast(void **ptr) {
+  {
+		AGRadio *e = dynamic_cast<AGRadio *>((AGCheckBox*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGRadio;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_AGCheckBox, AGCheckBox_dynamic_cast);
+%{
+static swig_type_info* AGWidget_dynamic_cast(void **ptr) {
+  {
+		AGScroller *e = dynamic_cast<AGScroller *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGScroller;
+		}
+  }
+  {
+		AGText *e = dynamic_cast<AGText *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGText;
+		}
+  }
+  {
+		AGScreenWidget *e = dynamic_cast<AGScreenWidget *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGScreenWidget;
+		}
+  }
+  {
+		AGComboBox *e = dynamic_cast<AGComboBox *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGComboBox;
+		}
+  }
+  {
+		AGTable *e = dynamic_cast<AGTable *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGTable;
+		}
+  }
+  {
+		AGLayout *e = dynamic_cast<AGLayout *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGLayout;
+		}
+  }
+  {
+		AGListBox *e = dynamic_cast<AGListBox *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGListBox;
+		}
+  }
+  {
+		AGRadioGroup *e = dynamic_cast<AGRadioGroup *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGRadioGroup;
+		}
+  }
+  {
+		MiniMap *e = dynamic_cast<MiniMap *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_MiniMap;
+		}
+  }
+  {
+		AGColorButton *e = dynamic_cast<AGColorButton *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGColorButton;
+		}
+  }
+  {
+		AGImage *e = dynamic_cast<AGImage *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGImage;
+		}
+  }
+  {
+		AGGLWidget *e = dynamic_cast<AGGLWidget *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGGLWidget;
+		}
+  }
+  {
+		AGEdit *e = dynamic_cast<AGEdit *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGEdit;
+		}
+  }
+  {
+		AGSound *e = dynamic_cast<AGSound *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGSound;
+		}
+  }
+  {
+		AGButton *e = dynamic_cast<AGButton *>((AGWidget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGButton;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_AGWidget, AGWidget_dynamic_cast);
+%{
+static swig_type_info* AGApplication_dynamic_cast(void **ptr) {
+  {
+		GLApp *e = dynamic_cast<GLApp *>((AGApplication*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_GLApp;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_AGApplication, AGApplication_dynamic_cast);
+%{
+static swig_type_info* PathWeighter_dynamic_cast(void **ptr) {
+  {
+		MapPathWeighter *e = dynamic_cast<MapPathWeighter *>((PathWeighter*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_MapPathWeighter;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_PathWeighter, PathWeighter_dynamic_cast);
+%{
+static swig_type_info* AGListener_dynamic_cast(void **ptr) {
+  {
+		AGMessageObject *e = dynamic_cast<AGMessageObject *>((AGListener*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGMessageObject;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_AGListener, AGListener_dynamic_cast);
+%{
+static swig_type_info* AGLayout_dynamic_cast(void **ptr) {
+  {
+		AGDialog *e = dynamic_cast<AGDialog *>((AGLayout*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGDialog;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_AGLayout, AGLayout_dynamic_cast);
+%{
+static swig_type_info* AGButton_dynamic_cast(void **ptr) {
+  {
+		AGCheckBox *e = dynamic_cast<AGCheckBox *>((AGButton*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGCheckBox;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_AGButton, AGButton_dynamic_cast);
+%{
+static swig_type_info* SimpleGraph_dynamic_cast(void **ptr) {
+  {
+		DecimatedGraph *e = dynamic_cast<DecimatedGraph *>((SimpleGraph*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_DecimatedGraph;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_SimpleGraph, SimpleGraph_dynamic_cast);
+%{
+static swig_type_info* AGScreen_dynamic_cast(void **ptr) {
+  {
+		AGGLScreen *e = dynamic_cast<AGGLScreen *>((AGScreen*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGGLScreen;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_AGScreen, AGScreen_dynamic_cast);
+%{
+static swig_type_info* SceneNode_dynamic_cast(void **ptr) {
+  {
+		AnimMesh *e = dynamic_cast<AnimMesh *>((SceneNode*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AnimMesh;
+		}
+  }
+  {
+		WaterPiece *e = dynamic_cast<WaterPiece *>((SceneNode*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_WaterPiece;
+		}
+  }
+  {
+		Mesh2D *e = dynamic_cast<Mesh2D *>((SceneNode*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_Mesh2D;
+		}
+  }
+  {
+		AntImpostor *e = dynamic_cast<AntImpostor *>((SceneNode*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AntImpostor;
+		}
+  }
+  {
+		Smoke *e = dynamic_cast<Smoke *>((SceneNode*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_Smoke;
+		}
+  }
+  {
+		Mesh *e = dynamic_cast<Mesh *>((SceneNode*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_Mesh;
+		}
+  }
+  {
+		TerrainPiece *e = dynamic_cast<TerrainPiece *>((SceneNode*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_TerrainPiece;
+		}
+  }
+  {
+		NewDecal *e = dynamic_cast<NewDecal *>((SceneNode*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_NewDecal;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_SceneNode, SceneNode_dynamic_cast);
+%{
+static swig_type_info* AGPaintTarget_dynamic_cast(void **ptr) {
+  {
+		AGTexture *e = dynamic_cast<AGTexture *>((AGPaintTarget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGTexture;
+		}
+  }
+  {
+		AGSurface *e = dynamic_cast<AGSurface *>((AGPaintTarget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGSurface;
+		}
+  }
+  {
+		AGScreen *e = dynamic_cast<AGScreen *>((AGPaintTarget*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGScreen;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_AGPaintTarget, AGPaintTarget_dynamic_cast);
+%{
+static swig_type_info* AGSingleton_dynamic_cast(void **ptr) {
+  {
+		AGFontEngine *e = dynamic_cast<AGFontEngine *>((AGSingleton*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGFontEngine;
+		}
+  }
+  {
+		AGLayoutCreator *e = dynamic_cast<AGLayoutCreator *>((AGSingleton*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGLayoutCreator;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_AGSingleton, AGSingleton_dynamic_cast);
+%{
+static swig_type_info* AGRubyObject_dynamic_cast(void **ptr) {
+  {
+		AnimMeshData *e = dynamic_cast<AnimMeshData *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AnimMeshData;
+		}
+  }
+  {
+		Mesh2DData *e = dynamic_cast<Mesh2DData *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_Mesh2DData;
+		}
+  }
+  {
+		Pathfinder *e = dynamic_cast<Pathfinder *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_Pathfinder;
+		}
+  }
+  {
+		TerrainBase *e = dynamic_cast<TerrainBase *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_TerrainBase;
+		}
+  }
+  {
+		AGSingleton *e = dynamic_cast<AGSingleton *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGSingleton;
+		}
+  }
+  {
+		AGPlugin *e = dynamic_cast<AGPlugin *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGPlugin;
+		}
+  }
+  {
+		MeshData *e = dynamic_cast<MeshData *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_MeshData;
+		}
+  }
+  {
+		AntImpostorData *e = dynamic_cast<AntImpostorData *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AntImpostorData;
+		}
+  }
+  {
+		AntEntity *e = dynamic_cast<AntEntity *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AntEntity;
+		}
+  }
+  {
+		PathWeighter *e = dynamic_cast<PathWeighter *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_PathWeighter;
+		}
+  }
+  {
+		AGMain *e = dynamic_cast<AGMain *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGMain;
+		}
+  }
+  {
+		SceneNode *e = dynamic_cast<SceneNode *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_SceneNode;
+		}
+  }
+  {
+		AGRandomizer *e = dynamic_cast<AGRandomizer *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGRandomizer;
+		}
+  }
+  {
+		SceneBase *e = dynamic_cast<SceneBase *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_SceneBase;
+		}
+  }
+  {
+		SimpleGraph *e = dynamic_cast<SimpleGraph *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_SimpleGraph;
+		}
+  }
+  {
+		AGPaintTarget *e = dynamic_cast<AGPaintTarget *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGPaintTarget;
+		}
+  }
+  {
+		AGListener *e = dynamic_cast<AGListener *>((AGRubyObject*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AGListener;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_AGRubyObject, AGRubyObject_dynamic_cast);
+%{
+static swig_type_info* HeightMap_dynamic_cast(void **ptr) {
+  {
+		AntMap *e = dynamic_cast<AntMap *>((HeightMap*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_AntMap;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_HeightMap, HeightMap_dynamic_cast);
+%{
+static swig_type_info* TerrainBase_dynamic_cast(void **ptr) {
+  {
+		Terrain *e = dynamic_cast<Terrain *>((TerrainBase*)*ptr);
+		if (e) 
+		{
+			*ptr = (void *) e;
+			return SWIGTYPE_p_Terrain;
+		}
+  }
+  return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_TerrainBase, TerrainBase_dynamic_cast);



From davidkamphausen at mail.berlios.de  Sun May 27 16:36:45 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 27 May 2007 16:36:45 +0200
Subject: [Antargis-svn] r1100 - in antargis/branches/branch_2d: gui/src
	ruby/tests src
Message-ID: <200705271436.l4REajvu020639@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-27 16:36:45 +0200 (Sun, 27 May 2007)
New Revision: 1100

Added:
   antargis/branches/branch_2d/gui/src/ag_sdlpainter.cc
   antargis/branches/branch_2d/gui/src/ag_sdlpainter.h
   antargis/branches/branch_2d/ruby/tests/clip_gradient_test.rb
   antargis/branches/branch_2d/ruby/tests/swig_derivation_test.rb
   antargis/branches/branch_2d/src/std_list.i
Log:
* added missing files


Added: antargis/branches/branch_2d/gui/src/ag_sdlpainter.cc
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_sdlpainter.cc	2007-05-27 14:35:54 UTC (rev 1099)
+++ antargis/branches/branch_2d/gui/src/ag_sdlpainter.cc	2007-05-27 14:36:45 UTC (rev 1100)
@@ -0,0 +1,80 @@
+#include "ag_sdlpainter.h"
+#include <math.h>
+#include "ag_sgeexport.h"
+
+namespace AGSDLPainter
+{
+void drawLine(SDL_Surface *s,const AGVector2 &pp0,const AGVector2 &pp1,const AGColor &c)
+{
+  AGVector2 p0,p1;
+
+  p0=pp0;
+  p1=pp1;
+
+  float dx=p1[0]-p0[0];
+  float dy=p1[1]-p0[1];
+
+  if(fabs(dx)>fabs(dy))
+    {
+      if(dx<0)
+	{
+	  p0=pp1;
+	  p1=pp0;
+	}
+
+      dx=p1[0]-p0[0];
+      dy=p1[1]-p0[1];
+
+      float y=p0[1];
+      float e=0;
+      float de=((float)dy)/dx;
+      for(float x=p0[0];x<=p1[0];x++)
+	{
+	  sge_PutPixel(s,int(x),int(y),c.mapRGB(s->format));
+	  e+=de;
+	  if(e>0.5)
+	    {
+	      e-=1.0;
+	      y++;
+	    }
+	  else if(e<-0.5)
+	    {
+	      e+=1.0;
+	      y--;
+	    }
+	}
+    }
+  else
+    {
+      if(dy<0)
+	{
+	  p0=pp1;
+	  p1=pp0;
+	}
+
+      dx=p1[0]-p0[0];
+      dy=p1[1]-p0[1];
+
+      float x=p0[0];
+      float e=0;
+      float de=((float)dx)/dy;
+      for(float y=p0[1];y<=p1[1];y++)
+	{
+	  sge_PutPixel(s,int(x),int(y),c.mapRGB(s->format));
+	  e+=de;
+	  if(e>0.5)
+	    {
+	      e-=1.0;
+	      x++;
+	    }
+	  else if(e<-0.5)
+	    {
+	      e+=1.0;
+	      x--;
+	    }
+	}
+    }
+}
+
+
+}

Added: antargis/branches/branch_2d/gui/src/ag_sdlpainter.h
===================================================================
--- antargis/branches/branch_2d/gui/src/ag_sdlpainter.h	2007-05-27 14:35:54 UTC (rev 1099)
+++ antargis/branches/branch_2d/gui/src/ag_sdlpainter.h	2007-05-27 14:36:45 UTC (rev 1100)
@@ -0,0 +1,17 @@
+#ifndef AG_SDLPAINTER_H
+#define AG_SDLPAINTER_H
+
+#include <ag_surface.h>
+
+namespace AGSDLPainter
+{
+  void drawGradient(SDL_Surface *surface, const AGRect2& prect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr);
+  void drawGradientAlpha(SDL_Surface *surface, const AGRect2& prect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr);
+  void drawBorder(SDL_Surface *surface, const AGRect2& rect,int width, const AGColor& c1, const AGColor& c2);
+
+  void drawLine(SDL_Surface *s,const AGVector2 &pp0,const AGVector2 &pp1,const AGColor &c);
+}
+
+
+#endif
+

Added: antargis/branches/branch_2d/ruby/tests/clip_gradient_test.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/clip_gradient_test.rb	2007-05-27 14:35:54 UTC (rev 1099)
+++ antargis/branches/branch_2d/ruby/tests/clip_gradient_test.rb	2007-05-27 14:36:45 UTC (rev 1100)
@@ -0,0 +1,6 @@
+#!/usr/bin/env ruby
+
+require 'ruby/antargislib.rb'
+
+initVideo(640,480,32,false,false)
+

Added: antargis/branches/branch_2d/ruby/tests/swig_derivation_test.rb
===================================================================
--- antargis/branches/branch_2d/ruby/tests/swig_derivation_test.rb	2007-05-27 14:35:54 UTC (rev 1099)
+++ antargis/branches/branch_2d/ruby/tests/swig_derivation_test.rb	2007-05-27 14:36:45 UTC (rev 1100)
@@ -0,0 +1,40 @@
+#!/usr/bin/env ruby
+
+require 'libantargis.so'
+
+include Libantargis
+s=Scene2D.new(32,32)
+
+m=Mesh2D.new(s)
+
+puts m,m.object_id
+l=s.getCurrentNodes
+puts "C:"
+puts l,l.object_id,l.class
+l.each{|i|
+	puts i,i.object_id,i.class
+}
+
+l=s.getCurrentNodes
+
+l.each{|i|
+	puts i,i.object_id
+}
+
+l.each{|i|
+	puts i,i.object_id
+}
+
+l.each{|i|
+	puts i,i.object_id
+}
+
+l.each{|i|
+	puts i,i.object_id
+}
+
+l=s.getCurrentNodes
+
+l.each{|i|
+	puts i,i.object_id
+}

Added: antargis/branches/branch_2d/src/std_list.i
===================================================================
--- antargis/branches/branch_2d/src/std_list.i	2007-05-27 14:35:54 UTC (rev 1099)
+++ antargis/branches/branch_2d/src/std_list.i	2007-05-27 14:36:45 UTC (rev 1100)
@@ -0,0 +1,448 @@
+/* -----------------------------------------------------------------------------
+ * See the LICENSE file for information on copyright, usage and redistribution
+ * of SWIG, and the README file for authors - http://www.swig.org/release.html.
+ *
+ * std_vector.i
+ *
+ * SWIG typemaps for std::vector
+ * ----------------------------------------------------------------------------- */
+
+%include <std_common.i>
+
+// ------------------------------------------------------------------------
+// std::list
+// 
+// The aim of all that follows would be to integrate std::list with 
+// Ruby as much as possible, namely, to allow the user to pass and 
+// be returned Ruby arrays
+// const declarations are used to guess the intent of the function being
+// exported; therefore, the following rationale is applied:
+// 
+//   -- f(std::list<T>), f(const std::list<T>&), f(const std::list<T>*):
+//      the parameter being read-only, either a Ruby array or a
+//      previously wrapped std::list<T> can be passed.
+//   -- f(std::list<T>&), f(std::list<T>*):
+//      the parameter must be modified; therefore, only a wrapped std::list
+//      can be passed.
+//   -- std::list<T> f():
+//      the list is returned by copy; therefore, a Ruby array of T:s 
+//      is returned which is most easily used in other Ruby functions
+//   -- std::list<T>& f(), std::list<T>* f(), const std::list<T>& f(),
+//      const std::list<T>* f():
+//      the list is returned by reference; therefore, a wrapped std::list
+//      is returned
+// ------------------------------------------------------------------------
+
+%{
+#include <list>
+#include <algorithm>
+#include <stdexcept>
+%}
+
+// exported class
+
+namespace std {
+
+    %mixin list "Enumerable";
+
+    template<class T> class list {
+        %typemap(in) list<T> {
+            if (rb_obj_is_kind_of($input,rb_cArray)) {
+                unsigned int size = RARRAY_LEN($input);
+                $1;
+                for (unsigned int i=0; i<size; i++) {
+                    VALUE o = RARRAY_PTR($input)[i];
+                    T* x;
+		    SWIG_ConvertPtr(o, (void **) &x, $descriptor(T *), 1);
+                    $1.push_back(*x);
+                }
+            } else {
+	        void *ptr;
+                SWIG_ConvertPtr($input, &ptr, $&1_descriptor, 1);
+                $1 = *(($&1_type) ptr);
+            }
+        }
+        %typemap(in) const list<T>& (std::list<T> temp),
+                     const list<T>* (std::list<T> temp) {
+            if (rb_obj_is_kind_of($input,rb_cArray)) {
+                unsigned int size = RARRAY_LEN($input);
+                $1 = &temp;
+                for (unsigned int i=0; i<size; i++) {
+                    VALUE o = RARRAY_PTR($input)[i];
+                    T* x;
+                    SWIG_ConvertPtr(o, (void **) &x, $descriptor(T *), 1);
+                    temp.push_back(*x);
+                }
+            } else {
+                SWIG_ConvertPtr($input, (void **) &$1, $1_descriptor, 1);
+            }
+        }
+        %typemap(out) list<T> {
+            $result = rb_ary_new2($1.size());
+	    size_t j=0;
+	    for($1_type::iterator i=$1.begin();i!=$1.end();i++,j++)
+	    {
+                T* x = new T(*i);
+		rb_ary_store($result,j,AG_NewPointerObj((void*)x,$descriptor(T*),1));
+            }
+        }
+        %typecheck(SWIG_TYPECHECK_LIST) list<T> {
+            /* native sequence? */
+            if (rb_obj_is_kind_of($input,rb_cArray)) {
+                unsigned int size = RARRAY_LEN($input);
+                if (size == 0) {
+                    /* an empty sequence can be of any type */
+                    $1 = 1;
+                } else {
+                    /* check the first element only */
+                    T* x;
+                    VALUE o = RARRAY_PTR($input)[0];
+                    if ((SWIG_ConvertPtr(o,(void **) &x, 
+                                         $descriptor(T *),0)) != -1)
+                        $1 = 1;
+                    else
+                        $1 = 0;
+                }
+            } else {
+                /* wrapped list? */
+                std::list<T >* v;
+                if (SWIG_ConvertPtr($input,(void **) &v, 
+                                    $&1_descriptor,0) != -1)
+                    $1 = 1;
+                else
+                    $1 = 0;
+            }
+        }
+        %typecheck(SWIG_TYPECHECK_LIST) const list<T>&,
+                                          const list<T>* {
+            /* native sequence? */
+            if (rb_obj_is_kind_of($input,rb_cArray)) {
+                unsigned int size = RARRAY_LEN($input);
+                if (size == 0) {
+                    /* an empty sequence can be of any type */
+                    $1 = 1;
+                } else {
+                    /* check the first element only */
+                    T* x;
+                    VALUE o = RARRAY_PTR($input)[0];
+                    if ((SWIG_ConvertPtr(o,(void **) &x, 
+                                         $descriptor(T *),0)) != -1)
+                        $1 = 1;
+                    else
+                        $1 = 0;
+                }
+            } else {
+                /* wrapped list? */
+                std::list<T >* v;
+                if (SWIG_ConvertPtr($input,(void **) &v, 
+                                    $1_descriptor,0) != -1)
+                    $1 = 1;
+                else
+                    $1 = 0;
+            }
+        }
+      public:
+        list();
+        list(unsigned int size);
+        list(unsigned int size, const T& value);
+        list(const list<T> &);
+
+        %rename(__len__) size;
+        unsigned int size() const;
+        %rename("empty?") empty;
+        bool empty() const;
+        void clear();
+        %rename(push) push_back;
+        void push_back(const T& x);
+        %extend {
+            T pop() throw (std::out_of_range) {
+                if (self->size() == 0)
+                    throw std::out_of_range("pop from empty list");
+                T x = self->back();
+                self->pop_back();
+                return x;
+            }
+
+            void each() {
+	        for(std::list<T>::iterator i=self->begin();i!=self->end();i++) // without ptr
+                {
+		    rb_yield(AG_NewPointerObj((void*)&(*i),$descriptor(T*),0));
+                }
+            }
+        }
+    };
+
+    // Partial specialization for lists of pointers.  [ beazley ]
+
+    %mixin list<T*> "Enumerable";
+    template<class T> class list<T*> {
+        %typemap(in) list<T*> {
+            if (rb_obj_is_kind_of($input,rb_cArray)) {
+                unsigned int size = RARRAY_LEN($input);
+                $1 = std::list<T* >();//(size);
+                for (unsigned int i=0; i<size; i++) {
+                    VALUE o = RARRAY_PTR($input)[i];
+                    T* x;
+                    SWIG_ConvertPtr(o, (void **) &x, $descriptor(T *), 1);
+		    $1.push_back(x);
+                }
+            } else {
+                void *ptr;
+                SWIG_ConvertPtr($input, &ptr, $&1_descriptor, 1);
+                $1 = *(($&1_type) ptr);
+            }
+        }
+        %typemap(in) const list<T*>& (std::list<T*> temp),
+                     const list<T*>* (std::list<T*> temp) {
+            if (rb_obj_is_kind_of($input,rb_cArray)) {
+                unsigned int size = RARRAY_LEN($input);
+                temp = std::list<T* >();//(size);
+                $1 = &temp;
+                for (unsigned int i=0; i<size; i++) {
+                    VALUE o = RARRAY_PTR($input)[i];
+                    T* x;
+                    SWIG_ConvertPtr(o, (void **) &x, $descriptor(T *), 1);
+                    temp.push_back(x);
+                }
+            } else {
+                SWIG_ConvertPtr($input, (void **) &$1, $1_descriptor, 1);
+            }
+        }
+        %typemap(out) list<T*> {
+            $result = rb_ary_new2($1.size());
+            size_t j=0;
+             for($1_type::iterator i=$1.begin();i!=$1.end();i++) {
+		rb_ary_store($result,j,AG_NewPointerObj(*i,$descriptor(T*),1));
+            }
+        }
+        %typecheck(SWIG_TYPECHECK_LIST) list<T*> {
+            /* native sequence? */
+            if (rb_obj_is_kind_of($input,rb_cArray)) {
+                unsigned int size = RARRAY_LEN($input);
+                if (size == 0) {
+                    /* an empty sequence can be of any type */
+                    $1 = 1;
+                } else {
+                    /* check the first element only */
+                    T* x;
+                    VALUE o = RARRAY_PTR($input)[0];
+                    if ((SWIG_ConvertPtr(o,(void **) &x, 
+                                         $descriptor(T *),0)) != -1)
+                        $1 = 1;
+                    else
+                        $1 = 0;
+                }
+            } else {
+                /* wrapped list? */
+                std::list<T* >* v;
+                if (SWIG_ConvertPtr($input,(void **) &v, 
+                                    $&1_descriptor,0) != -1)
+                    $1 = 1;
+                else
+                    $1 = 0;
+            }
+        }
+        %typecheck(SWIG_TYPECHECK_LIST) const list<T*>&,
+                                          const list<T*>* {
+            /* native sequence? */
+            if (rb_obj_is_kind_of($input,rb_cArray)) {
+                unsigned int size = RARRAY_LEN($input);
+                if (size == 0) {
+                    /* an empty sequence can be of any type */
+                    $1 = 1;
+                } else {
+                    /* check the first element only */
+                    T* x;
+                    VALUE o = RARRAY_PTR($input)[0];
+                    if ((SWIG_ConvertPtr(o,(void **) &x, 
+                                         $descriptor(T *),0)) != -1)
+                        $1 = 1;
+                    else
+                        $1 = 0;
+                }
+            } else {
+                /* wrapped list? */
+                std::list<T* >* v;
+                if (SWIG_ConvertPtr($input,(void **) &v, 
+                                    $1_descriptor,0) != -1)
+                    $1 = 1;
+                else
+                    $1 = 0;
+            }
+        }
+      public:
+        list();
+        list(unsigned int size);
+        list(unsigned int size, T * &value);
+        list(const list<T*> &);
+
+        %rename(__len__) size;
+        unsigned int size() const;
+        %rename("empty?") empty;
+        bool empty() const;
+        void clear();
+        %rename(push) push_back;
+        void push_back(T* x);
+        %extend {
+            T* pop() throw (std::out_of_range) {
+                if (self->size() == 0)
+                    throw std::out_of_range("pop from empty list");
+                T* x = self->back();
+                self->pop_back();
+                return x;
+            }
+
+            void each() {
+                for(std::list<T*>::iterator i=self->begin();i!=self->end();i++) // with ptr
+                {
+                    rb_yield(AG_NewPointerObj(*i,$descriptor(T*),0));
+		}
+            }
+        }
+    };
+        
+
+    // specializations for built-ins
+
+    %define specialize_std_list(T,CHECK,CONVERT_FROM,CONVERT_TO)
+    %mixin list<T> "Enumerable";
+    template<> class list<T> {
+        %typemap(in) list<T> {
+            if (rb_obj_is_kind_of($input,rb_cArray)) {
+                unsigned int size = RARRAY_LEN($input);
+                $1 = std::list<T >();//(size);
+                for (unsigned int i=0; i<size; i++) {
+                    VALUE o = RARRAY_PTR($input)[i];
+                    if (CHECK(o))
+                        (($1_type &)$1)[i] = (T)(CONVERT_FROM(o));
+                    else
+                        rb_raise(rb_eTypeError,
+                                 "wrong argument type"
+                                 " (expected list<" #T ">)");
+                }
+            } else {
+	        void *ptr;
+                SWIG_ConvertPtr($input, &ptr, $&1_descriptor, 1);
+                $1 = *(($&1_type) ptr);
+            }
+        }
+        %typemap(in) const list<T>& (std::list<T> temp),
+                     const list<T>* (std::list<T> temp) {
+            if (rb_obj_is_kind_of($input,rb_cArray)) {
+                unsigned int size = RARRAY_LEN($input);
+                temp = std::list<T >();//(size);
+                $1 = &temp;
+                for (unsigned int i=0; i<size; i++) {
+                    VALUE o = RARRAY_PTR($input)[i];
+                    if (CHECK(o))
+                        temp.push_back((T)(CONVERT_FROM(o)));
+                    else
+                        rb_raise(rb_eTypeError,
+                                 "wrong argument type"
+                                 " (expected list<" #T ">)");
+                }
+            } else {
+                SWIG_ConvertPtr($input, (void **) &$1, $1_descriptor, 1);
+            }
+        }
+        %typemap(out) list<T> {
+            $result = rb_ary_new2($1.size());
+            for (($1_type)::iterator i=$1.begin();i!=$1.end();i++) //unsigned int i=0; i<$1.size(); i++)
+                rb_ary_store($result,i,CONVERT_TO(*i));
+        }
+        %typecheck(SWIG_TYPECHECK_LIST) list<T> {
+            /* native sequence? */
+            if (rb_obj_is_kind_of($input,rb_cArray)) {
+                unsigned int size = RARRAY_LEN($input);
+                if (size == 0) {
+                    /* an empty sequence can be of any type */
+                    $1 = 1;
+                } else {
+                    /* check the first element only */
+                    VALUE o = RARRAY_PTR($input)[0];
+                    if (CHECK(o))
+                        $1 = 1;
+                    else
+                        $1 = 0;
+                }
+            } else {
+                /* wrapped list? */
+                std::list<T >* v;
+                if (SWIG_ConvertPtr($input,(void **) &v, 
+                                    $&1_descriptor,0) != -1)
+                    $1 = 1;
+                else
+                    $1 = 0;
+            }
+        }
+        %typecheck(SWIG_TYPECHECK_LIST) const list<T>&,
+                                          const list<T>* {
+            /* native sequence? */
+            if (rb_obj_is_kind_of($input,rb_cArray)) {
+                unsigned int size = RARRAY_LEN($input);
+                if (size == 0) {
+                    /* an empty sequence can be of any type */
+                    $1 = 1;
+                } else {
+                    /* check the first element only */
+                    VALUE o = RARRAY_PTR($input)[0];
+                    if (CHECK(o))
+                        $1 = 1;
+                    else
+                        $1 = 0;
+                }
+            } else {
+                /* wrapped list? */
+                std::list<T >* v;
+                if (SWIG_ConvertPtr($input,(void **) &v, 
+                                    $1_descriptor,0) != -1)
+                    $1 = 1;
+                else
+                    $1 = 0;
+            }
+        }
+      public:
+        list();
+        list(unsigned int size);
+        list(unsigned int size, const T& value);
+        list(const list<T> &);
+
+        %rename(__len__) size;
+        unsigned int size() const;
+        %rename("empty?") empty;
+        bool empty() const;
+        void clear();
+        %rename(push) push_back;
+        void push_back(T x);
+        %extend {
+            T pop() throw (std::out_of_range) {
+                if (self->size() == 0)
+                    throw std::out_of_range("pop from empty list");
+                T x = self->back();
+                self->pop_back();
+                return x;
+            }
+		
+            void each() {
+		for(std::list<T*>::iterator i=self->begin();i!=self->end();i++) // with ptr2
+                    rb_yield(CONVERT_TO(&(*i));
+            }
+        }
+    };
+    %enddef
+
+    specialize_std_list(bool,SWIG_BOOL_P,SWIG_RB2BOOL,SWIG_BOOL2RB);
+    specialize_std_list(char,FIXNUM_P,FIX2INT,INT2NUM);
+    specialize_std_list(int,FIXNUM_P,FIX2INT,INT2NUM);
+    specialize_std_list(short,FIXNUM_P,FIX2INT,INT2NUM);
+    specialize_std_list(long,FIXNUM_P,FIX2INT,INT2NUM);
+    specialize_std_list(unsigned char,FIXNUM_P,FIX2INT,INT2NUM);
+    specialize_std_list(unsigned int,FIXNUM_P,FIX2INT,INT2NUM);
+    specialize_std_list(unsigned short,FIXNUM_P,FIX2INT,INT2NUM);
+    specialize_std_list(unsigned long,FIXNUM_P,FIX2INT,INT2NUM);
+    specialize_std_list(double,SWIG_FLOAT_P,SWIG_NUM2DBL,rb_float_new);
+    specialize_std_list(float,SWIG_FLOAT_P,SWIG_NUM2DBL,rb_float_new);
+    specialize_std_list(std::string,SWIG_STRING_P,SWIG_RB2STR,SWIG_STR2RB);
+
+}
+



From davidkamphausen at mail.berlios.de  Mon May 28 16:41:38 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Mon, 28 May 2007 16:41:38 +0200
Subject: [Antargis-svn] r1101 - in antargis/branches/branch_2d: . ruby src
Message-ID: <200705281441.l4SEfbPI022373@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-05-28 16:41:36 +0200 (Mon, 28 May 2007)
New Revision: 1101

Modified:
   antargis/branches/branch_2d/Rakefile
   antargis/branches/branch_2d/ruby/antargislib.rb
   antargis/branches/branch_2d/src/terrain.cc
   antargis/branches/branch_2d/src/terrain.h
Log:
* smaller bugfixes


Modified: antargis/branches/branch_2d/Rakefile
===================================================================
--- antargis/branches/branch_2d/Rakefile	2007-05-27 14:36:45 UTC (rev 1100)
+++ antargis/branches/branch_2d/Rakefile	2007-05-28 14:41:36 UTC (rev 1101)
@@ -54,7 +54,7 @@
 if $xcompile
 	$CFLAGS+=`./contrib/usr/bin/sdl-config --cflags`.chomp
 	$INCLUDEDIRS+=`./contrib/usr/bin/sdl-config --cflags`.chomp
-	$LDFLAGS+=`./contrib/usr/bin/sdl-config --libs`.chomp+" "+$libs
+	$LDFLAGS+=" "+`./contrib/usr/bin/sdl-config --libs`.chomp+" "+$libs+" "
 elsif not windows
 	# standard way (unix)
 	$CFLAGS+=`sdl-config --cflags`.chomp

Modified: antargis/branches/branch_2d/ruby/antargislib.rb
===================================================================
--- antargis/branches/branch_2d/ruby/antargislib.rb	2007-05-27 14:36:45 UTC (rev 1100)
+++ antargis/branches/branch_2d/ruby/antargislib.rb	2007-05-28 14:41:36 UTC (rev 1101)
@@ -141,6 +141,8 @@
 						@@cursorEnabled=true
 					when "ruby-raise"
 						setRubyRaising(true)
+					when "no-3d-textures"
+          	setUsing3dTextures(false)
 					when "help","h"
 						STDERR.puts "Possible options:
 	--help         show this help message
@@ -165,6 +167,8 @@
 
 	--nogl         disable GL-mode (3d-acceleration) - THIS IS NOT YET FULLY SUPPORTED!!
 	--ruby-raise   raise exceptions as ruby-exceptions
+
+	--no-3d-textures disables 3d-textures - they're bad on some graphics chipsets (esp. Intel)
 	"
 	
 						exit

Modified: antargis/branches/branch_2d/src/terrain.cc
===================================================================
--- antargis/branches/branch_2d/src/terrain.cc	2007-05-27 14:36:45 UTC (rev 1100)
+++ antargis/branches/branch_2d/src/terrain.cc	2007-05-28 14:41:36 UTC (rev 1101)
@@ -4,12 +4,17 @@
 #include <ag_profiler.h>
 #include <ag_config.h>
 
+static bool gUse3dTextures=true;
+void setUsing3dTextures(bool use3dTextures)
+{
+  gUse3dTextures=use3dTextures;
+}
+
 bool use3dTextures()
 {
-  return false;
+  return gUse3dTextures;
 }
 
-
 //////////////////////////////////////////////////////////////////////////
 // TerrainPiece
 //////////////////////////////////////////////////////////////////////////

Modified: antargis/branches/branch_2d/src/terrain.h
===================================================================
--- antargis/branches/branch_2d/src/terrain.h	2007-05-27 14:36:45 UTC (rev 1100)
+++ antargis/branches/branch_2d/src/terrain.h	2007-05-28 14:41:36 UTC (rev 1101)
@@ -124,5 +124,7 @@
   void init();
 };
 
+void setUsing3dTextures(bool use3dTextures);
 
+
 #endif



