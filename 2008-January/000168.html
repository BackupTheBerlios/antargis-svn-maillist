<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Antargis-svn] r1211 - in antargis/trunk: . build build/swig ext	ext/basic ext/game ext/video ruby
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/antargis-svn/2008-January/index.html" >
   <LINK REL="made" HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1211%20-%20in%20antargis/trunk%3A%20.%20build%20build/swig%20ext%0A%09ext/basic%20ext/game%20ext/video%20ruby&In-Reply-To=%3C200801061608.m06G8ddO003299%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000167.html">
   <LINK REL="Next"  HREF="000169.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Antargis-svn] r1211 - in antargis/trunk: . build build/swig ext	ext/basic ext/game ext/video ruby</H1>
    <B>davidkamphausen at BerliOS</B> 
    <A HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1211%20-%20in%20antargis/trunk%3A%20.%20build%20build/swig%20ext%0A%09ext/basic%20ext/game%20ext/video%20ruby&In-Reply-To=%3C200801061608.m06G8ddO003299%40sheep.berlios.de%3E"
       TITLE="[Antargis-svn] r1211 - in antargis/trunk: . build build/swig ext	ext/basic ext/game ext/video ruby">davidkamphausen at mail.berlios.de
       </A><BR>
    <I>Sun Jan  6 17:08:39 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000167.html">[Antargis-svn] r1210 - antargis/tags
</A></li>
        <LI>Next message: <A HREF="000169.html">[Antargis-svn] r1212 - antargis/trunk/build/swig/tests
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#168">[ date ]</a>
              <a href="thread.html#168">[ thread ]</a>
              <a href="subject.html#168">[ subject ]</a>
              <a href="author.html#168">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: davidkamphausen
Date: 2008-01-06 17:08:38 +0100 (Sun, 06 Jan 2008)
New Revision: 1211

Added:
   antargis/trunk/build/swig/
   antargis/trunk/build/swig/AGString.i
   antargis/trunk/build/swig/ag_data.i
   antargis/trunk/build/swig/ag_filename.i
   antargis/trunk/build/swig/ag_string.i
   antargis/trunk/build/swig/common.i
   antargis/trunk/build/swig/std_list.i
   antargis/trunk/build/swig/std_string.i
   antargis/trunk/build/swig/tests/
   antargis/trunk/ext/test/
Removed:
   antargis/trunk/build/AGString.i
   antargis/trunk/build/ag_data.i
   antargis/trunk/build/ag_filename.i
   antargis/trunk/build/ag_string.i
   antargis/trunk/build/common.i
   antargis/trunk/build/std_list.i
   antargis/trunk/build/std_string.i
Modified:
   antargis/trunk/TODO
   antargis/trunk/build/interface_template.rb
   antargis/trunk/ext/Rakefile
   antargis/trunk/ext/basic/ag_fs.cc
   antargis/trunk/ext/basic/templates.i
   antargis/trunk/ext/game/entity.cc
   antargis/trunk/ext/game/entity.h
   antargis/trunk/ext/game/height_map.cc
   antargis/trunk/ext/game/map.cc
   antargis/trunk/ext/video/ag_surface.cc
   antargis/trunk/ext/video/templates.i
   antargis/trunk/ruby/campaign.rb
   antargis/trunk/ruby/dialogs.rb
   antargis/trunk/ruby/editview.rb
   antargis/trunk/ruby/map.rb
Log:
* many changes concerning swig


Modified: antargis/trunk/TODO
===================================================================
--- antargis/trunk/TODO	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/TODO	2008-01-06 16:08:38 UTC (rev 1211)
@@ -1,3 +1,5 @@
+
+* fix saving - problem occurs only if game is loaded ? (in editor, too)
 * move build/*.rb files to build/unused_tools/* if they're not used
 * google for &quot;/tmp/cciSLVG5.s:932678: Warning: .stabs: description field '1c216' too big, try a different debug format&quot;
 
@@ -18,7 +20,6 @@
 * moveto doesn't really work with &quot;near&quot; (hljob)
 * heroes don't die in reasonable fashion - starving men too
 * add seasons
-* take food - near doesn't work - same for attack (in some cases?)
 
 * Spreading should be done only for men who need it!
 

Deleted: antargis/trunk/build/AGString.i
===================================================================
--- antargis/trunk/build/AGString.i	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/build/AGString.i	2008-01-06 16:08:38 UTC (rev 1211)
@@ -1,86 +0,0 @@
-//
-// SWIG typemaps for AGString
-// Luigi Ballabio
-// Apr 8, 2002
-//
-// Ruby implementation
-
-
-// ------------------------------------------------------------------------
-// AGString is typemapped by value
-// This can prevent exporting methods which return a string
-// in order for the user to modify it.
-// However, I think I'll wait until someone asks for it...
-// ------------------------------------------------------------------------
-
-%include exception.i
-
-%{
-#include &lt;ag_string.h&gt;
-%}
-
-//namespace std {
-
-    // Ruby wants class names to start with a capital letter
-    //%rename(String) AGString;
-    class AGString;
-
-    /* Overloading check */
-    %typemap(typecheck) AGString = char *;
-    %typemap(typecheck) const AGString &amp; = char *;
-
-    %typemap(in) AGString {
-        if (TYPE($input) == T_STRING) {
-//            $1 = AGString(StringValuePtr($input));
-            $1 = AGString(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;not a string&quot;);
-        }
-    }
-
-    %typemap(in) const AGString &amp; (AGString temp) {
-        if (TYPE($input) == T_STRING) {
-//            temp = AGString(StringValuePtr($input));
-            temp = AGString(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-            $1 = &temp;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;not a string&quot;);
-        }
-    }
-
-    %typemap(out) AGString {
-        $result = rb_str_new($1.c_str(),$1.length());
-    }
-
-    %typemap(out) const AGString &amp; {
-        $result = rb_str_new($1-&gt;c_str(),$1-&gt;length());
-    }
-
-    %typemap(directorin) AGString, const AGString &amp;, AGString &amp; &quot;$input=rb_str_new2($1_name.c_str());&quot;;
-
-    %typemap(directorin) AGString *, const AGString * &quot;$1_name-&gt;c_str()&quot;;
-    
-    %typemap(directorout) AGString {
-        if (TYPE($input) == T_STRING)
-//            $result = AGString(StringValuePtr($input));
-            $result = AGString(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-        else
-            throw Swig::DirectorTypeMismatchException(&quot;string expected&quot;);
-    }
-    
-    %typemap(directorout) const string &amp; (AGString temp) {
-        if (TYPE($input) == T_STRING) {
-//            temp = AGString(StringValuePtr($input));
-            temp = AGString(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-            $result = &temp;
-        } else {
-            throw Swig::DirectorTypeMismatchException(&quot;string expected&quot;);
-        }
-    }
-
-    %typemap(throws) AGString, const AGString &amp;
-        &quot;rb_raise(rb_eRuntimeError, $1.c_str());&quot;;
-
-    %typemap(throws) AGString *, const AGString *
-        &quot;rb_raise(rb_eRuntimeError, $1-&gt;c_str());&quot;;
-//}

Deleted: antargis/trunk/build/ag_data.i
===================================================================
--- antargis/trunk/build/ag_data.i	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/build/ag_data.i	2008-01-06 16:08:38 UTC (rev 1211)
@@ -1,82 +0,0 @@
-//
-// SWIG typemaps for std::string
-// Luigi Ballabio
-// Apr 8, 2002
-//
-// Ruby implementation
-
-
-// ------------------------------------------------------------------------
-// std::string is typemapped by value
-// This can prevent exporting methods which return a string
-// in order for the user to modify it.
-// However, I think I'll wait until someone asks for it...
-// ------------------------------------------------------------------------
-
-%include exception.i
-
-%{
-#include &lt;ag_string.h&gt;
-#include &lt;ag_fs.h&gt;
-%}
-
-
-    // Ruby wants class names to start with a capital letter
-    // %rename(String) string;
-    class AGData;
-
-    /* Overloading check */
-    %typemap(typecheck) AGData = char *;
-    %typemap(typecheck) const AGData &amp; = char *;
-
-    %typemap(in) AGData {
-        if (TYPE($input) == T_STRING) {
-            $1 = AGData(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;not a string&quot;);
-        }
-    }
-
-    %typemap(in) const AGData &amp; (AGData temp) {
-        if (TYPE($input) == T_STRING) {
-            temp = AGData(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-            $1 = &temp;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;not a string&quot;);
-        }
-    }
-
-    %typemap(out) AGData {
-        $result = rb_str_new($1.c_str(),$1.length());
-    }
-
-    %typemap(out) const AGData &amp; {
-        $result = rb_str_new($1-&gt;c_str(),$1-&gt;length());
-    }
-
-    %typemap(directorin) AGData, const AGData &amp;, AGData &amp; &quot;$input=rb_str_new($1_name.c_str(),$1_name.length());&quot;;
-
-    %typemap(directorin) AGData *, const AGData * &quot;$1_name-&gt;c_str()&quot;;
-    
-    %typemap(directorout) AGData {
-        if (TYPE($input) == T_STRING)
-            $result = AGData(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-        else
-            throw Swig::DirectorTypeMismatchException(&quot;string expected&quot;);
-    }
-    
-    %typemap(directorout) const AGData &amp; (AGData temp) {
-        if (TYPE($input) == T_STRING) {
-            temp = AGData(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-            $result = &temp;
-        } else {
-            throw Swig::DirectorTypeMismatchException(&quot;string expected&quot;);
-        }
-    }
-/*
-    %typemap(throws) AGData, const string &amp;
-        &quot;rb_raise(rb_eRuntimeError, $1.c_str());&quot;;
-
-    %typemap(throws) string *, const string *
-        &quot;rb_raise(rb_eRuntimeError, $1-&gt;c_str());&quot;;
-*/

Deleted: antargis/trunk/build/ag_filename.i
===================================================================
--- antargis/trunk/build/ag_filename.i	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/build/ag_filename.i	2008-01-06 16:08:38 UTC (rev 1211)
@@ -1,82 +0,0 @@
-//
-// SWIG typemaps for std::string
-// Luigi Ballabio
-// Apr 8, 2002
-//
-// Ruby implementation
-
-
-// ------------------------------------------------------------------------
-// std::string is typemapped by value
-// This can prevent exporting methods which return a string
-// in order for the user to modify it.
-// However, I think I'll wait until someone asks for it...
-// ------------------------------------------------------------------------
-
-%include exception.i
-
-%{
-#include &lt;ag_string.h&gt;
-#include &lt;ag_fs.h&gt;
-%}
-
-
-    // Ruby wants class names to start with a capital letter
-    // %rename(String) string;
-    class AGFilename;
-
-    /* Overloading check */
-    %typemap(typecheck) AGFilename = char *;
-    %typemap(typecheck) const AGFilename &amp; = char *;
-
-    %typemap(in) AGFilename {
-        if (TYPE($input) == T_STRING) {
-            $1 = AGFilename(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;not a string&quot;);
-        }
-    }
-
-    %typemap(in) const AGFilename &amp; (AGFilename temp) {
-        if (TYPE($input) == T_STRING) {
-            temp = AGFilename(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-            $1 = &temp;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;not a string&quot;);
-        }
-    }
-
-    %typemap(out) AGFilename {
-        $result = rb_str_new($1.c_str(),$1.length());
-    }
-
-    %typemap(out) const AGFilename &amp; {
-        $result = rb_str_new($1-&gt;c_str(),$1-&gt;length());
-    }
-
-    %typemap(directorin) AGFilename, const AGFilename &amp;, AGFilename &amp; &quot;$input=rb_str_new($1_name.c_str(),$1_name.length());&quot;;
-
-    %typemap(directorin) AGFilename *, const AGFilename * &quot;$1_name-&gt;c_str()&quot;;
-    
-    %typemap(directorout) AGFilename {
-        if (TYPE($input) == T_STRING)
-            $result = AGFilename(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-        else
-            throw Swig::DirectorTypeMismatchException(&quot;string expected&quot;);
-    }
-    
-    %typemap(directorout) const AGFilename &amp; (AGFilename temp) {
-        if (TYPE($input) == T_STRING) {
-            temp = AGFilename(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-            $result = &temp;
-        } else {
-            throw Swig::DirectorTypeMismatchException(&quot;string expected&quot;);
-        }
-    }
-/*
-    %typemap(throws) AGFilename, const string &amp;
-        &quot;rb_raise(rb_eRuntimeError, $1.c_str());&quot;;
-
-    %typemap(throws) string *, const string *
-        &quot;rb_raise(rb_eRuntimeError, $1-&gt;c_str());&quot;;
-*/

Deleted: antargis/trunk/build/ag_string.i
===================================================================
--- antargis/trunk/build/ag_string.i	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/build/ag_string.i	2008-01-06 16:08:38 UTC (rev 1211)
@@ -1,96 +0,0 @@
-//
-// SWIG typemaps for std::string
-// Luigi Ballabio
-// Apr 8, 2002
-//
-// Ruby implementation
-
-
-// ------------------------------------------------------------------------
-// std::string is typemapped by value
-// This can prevent exporting methods which return a string
-// in order for the user to modify it.
-// However, I think I'll wait until someone asks for it...
-// ------------------------------------------------------------------------
-
-%include exception.i
-
-%{
-#include &lt;ag_string.h&gt;
-%}
-
-
-    // Ruby wants class names to start with a capital letter
-%rename(String) AGString;
-class AGString;
-
-    /* Overloading check */
-    %typemap(typecheck) AGString = char *;
-    %typemap(typecheck) const AGString &amp; = char *;
-
-    %typemap(in) AGString {
-        if (TYPE($input) == T_STRING) {
-            $1 = AGString(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;not a string&quot;);
-        }
-    }
-
-    %typemap(in) const AGString &amp; (AGString temp) {
-        if (TYPE($input) == T_STRING) {
-            temp = AGString(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-            $1 = &temp;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;not a string&quot;);
-        }
-    }
-
-    %typemap(out) AGString {
-        $result = rb_str_new($1.c_str(),$1.length());
-    }
-
-    %typemap(out) const AGString &amp; {
-        $result = rb_str_new($1-&gt;c_str(),$1-&gt;length());
-    }
-
-    %typemap(directorin) AGString, const AGString &amp;, AGString &amp; &quot;$input=rb_str_new($1_name.c_str(),$1_name.length());&quot;;
-
-    %typemap(directorin) AGString *, const AGString * &quot;$1_name-&gt;c_str()&quot;;
-    
-    %typemap(directorout) AGString {
-        if (TYPE($input) == T_STRING)
-            $result = AGString(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-        else
-            throw Swig::DirectorTypeMismatchException(&quot;string expected&quot;);
-    }
-    
-    %typemap(directorout) const AGString &amp; (AGString temp) {
-        if (TYPE($input) == T_STRING) {
-            temp = AGString(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-            $result = &temp;
-        } else {
-            throw Swig::DirectorTypeMismatchException(&quot;string expected&quot;);
-        }
-    }
-/*
-    %typemap(throws) AGString, const string &amp;
-        &quot;rb_raise(rb_eRuntimeError, $1.c_str());&quot;;
-
-    %typemap(throws) string *, const string *
-        &quot;rb_raise(rb_eRuntimeError, $1-&gt;c_str());&quot;;
-*/
-
-%{
-AGString SWIG_RB2AGSTR(VALUE x) {
-    return AGString(RSTRING_PTR(x), RSTRING_LEN(x));
-}
-VALUE SWIG_AGSTR2RB(const AGString&amp; s) {
-    return rb_str_new(s.data(), s.size());
-}
-%}
-namespace std
-{
-	specialize_std_vector(AGString,SWIG_STRING_P,SWIG_RB2AGSTR,SWIG_AGSTR2RB);
-	specialize_std_vector(AGFilename,SWIG_STRING_P,SWIG_RB2AGSTR,SWIG_AGSTR2RB);
-	specialize_std_vector(AGData,SWIG_STRING_P,SWIG_RB2AGSTR,SWIG_AGSTR2RB);
-}
\ No newline at end of file

Deleted: antargis/trunk/build/common.i
===================================================================
--- antargis/trunk/build/common.i	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/build/common.i	2008-01-06 16:08:38 UTC (rev 1211)
@@ -1,37 +0,0 @@
-%feature(&quot;director&quot;);
-%include &quot;typemaps.i&quot;
-%include &quot;std_string.i&quot;
-//%include &quot;AGString.i&quot;
-%include &quot;std_vector.i&quot;
-%include &quot;std_pair.i&quot;
-%include &quot;std_map.i&quot;
-%include &quot;std_list.i&quot;
-%include &quot;ag_string.i&quot;
-%include &quot;ag_filename.i&quot;
-%include &quot;ag_data.i&quot;
-
-%{
-#include &lt;ag_rubyobj.h&gt;
-
-SWIGRUNTIME VALUE
-AG_NewPointerObj(void *ptr, swig_type_info *type, int flags)
-{
-	AGRubyObject *o=(AGRubyObject*)ptr;
-#ifdef GCDEBUG
-	printf(&quot;AG_NewPointerObj o:0x%lx , ruby:0x%lx vl:0x%lx\n&quot;,o,o-&gt;mRubyObject,o-&gt;mRUBY);
-#endif
-	if(o-&gt;mRubyObject)
-		return o-&gt;mRUBY;
-
-	swig_type_info *t=SWIG_TypeDynamicCast(type,(void**)&amp;o);
-
-	o-&gt;mRubyObject=true;
-	o-&gt;mRUBY=SWIG_NewPointerObj((void *) o, t,flags);
-#ifdef GCDEBUG
-	printf(&quot;NEW AG_NewPointerObj o:0x%lx , ruby:0x%lx vl:0x%lx\n&quot;,o,o-&gt;mRubyObject,o-&gt;mRUBY);
-#endif
-	return o-&gt;mRUBY;
-}
-
-%}
-

Modified: antargis/trunk/build/interface_template.rb
===================================================================
--- antargis/trunk/build/interface_template.rb	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/build/interface_template.rb	2008-01-06 16:08:38 UTC (rev 1211)
@@ -6,7 +6,7 @@
 %module(directors=&quot;1&quot;) #{moduleName}
 
 // include common (stdc++) thingies and set options
-%include &quot;build/common.i&quot;
+%include &quot;build/swig/common.i&quot;
 
 %{
 	void AG_Init_lib#{moduleName}();
@@ -44,7 +44,6 @@
 def interface_templateBAK(moduleName,files)
 &lt;&lt;EOT
 %module(directors=&quot;1&quot;) #{moduleName}
-//%include &quot;build/common.i&quot;
 
 
 

Deleted: antargis/trunk/build/std_list.i
===================================================================
--- antargis/trunk/build/std_list.i	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/build/std_list.i	2008-01-06 16:08:38 UTC (rev 1211)
@@ -1,452 +0,0 @@
-/* -----------------------------------------------------------------------------
- * See the LICENSE file for information on copyright, usage and redistribution
- * of SWIG, and the README file for authors - <A HREF="http://www.swig.org/release.html.">http://www.swig.org/release.html.</A>
- *
- * std_vector.i
- *
- * SWIG typemaps for std::vector
- * ----------------------------------------------------------------------------- */
-
-%include &lt;std_common.i&gt;
-
-// ------------------------------------------------------------------------
-// std::list
-// 
-// The aim of all that follows would be to integrate std::list with 
-// Ruby as much as possible, namely, to allow the user to pass and 
-// be returned Ruby arrays
-// const declarations are used to guess the intent of the function being
-// exported; therefore, the following rationale is applied:
-// 
-//   -- f(std::list&lt;T&gt;), f(const std::list&lt;T&gt;&amp;), f(const std::list&lt;T&gt;*):
-//      the parameter being read-only, either a Ruby array or a
-//      previously wrapped std::list&lt;T&gt; can be passed.
-//   -- f(std::list&lt;T&gt;&amp;), f(std::list&lt;T&gt;*):
-//      the parameter must be modified; therefore, only a wrapped std::list
-//      can be passed.
-//   -- std::list&lt;T&gt; f():
-//      the list is returned by copy; therefore, a Ruby array of T:s 
-//      is returned which is most easily used in other Ruby functions
-//   -- std::list&lt;T&gt;&amp; f(), std::list&lt;T&gt;* f(), const std::list&lt;T&gt;&amp; f(),
-//      const std::list&lt;T&gt;* f():
-//      the list is returned by reference; therefore, a wrapped std::list
-//      is returned
-// ------------------------------------------------------------------------
-
-%{
-#include &lt;list&gt;
-#include &lt;algorithm&gt;
-#include &lt;stdexcept&gt;
-%}
-
-// exported class
-
-namespace std {
-
-    %mixin list &quot;Enumerable&quot;;
-
-    template&lt;class T&gt; class list {
-        %typemap(in) list&lt;T&gt; {
-            if (rb_obj_is_kind_of($input,rb_cArray)) {
-                unsigned int size = RARRAY_LEN($input);
-                $1;
-                for (unsigned int i=0; i&lt;size; i++) {
-                    VALUE o = RARRAY_PTR($input)[i];
-                    T* x;
-		    SWIG_ConvertPtr(o, (void **) &amp;x, $descriptor(T *), 1);
-                    $1.push_back(*x);
-                }
-            } else {
-	        void *ptr;
-                SWIG_ConvertPtr($input, &amp;ptr, $&amp;1_descriptor, 1);
-                $1 = *(($&amp;1_type) ptr);
-            }
-        }
-        %typemap(in) const list&lt;T&gt;&amp; (std::list&lt;T&gt; temp),
-                     const list&lt;T&gt;* (std::list&lt;T&gt; temp) {
-            if (rb_obj_is_kind_of($input,rb_cArray)) {
-                unsigned int size = RARRAY_LEN($input);
-                $1 = &temp;
-                for (unsigned int i=0; i&lt;size; i++) {
-                    VALUE o = RARRAY_PTR($input)[i];
-                    T* x;
-                    SWIG_ConvertPtr(o, (void **) &amp;x, $descriptor(T *), 1);
-                    temp.push_back(*x);
-                }
-            } else {
-                SWIG_ConvertPtr($input, (void **) &amp;$1, $1_descriptor, 1);
-            }
-        }
-        %typemap(out) list&lt;T&gt; {
-            $result = rb_ary_new2($1.size());
-            size_t j=0;
-            for($1_type::iterator i=$1.begin();i!=$1.end();i++,j++)
-            {
-                T* x = new T(*i);
-                assert(x);
-                // no AG_NewPointerObj needed, because object is definitely created above and thus has no mRubyObject defined
-                rb_ary_store($result,j,SWIG_NewPointerObj((void*)x,$descriptor(T*),1));
-            }
-            assert(j==$1.size());
-        }
-        %typecheck(SWIG_TYPECHECK_LIST) list&lt;T&gt; {
-            /* native sequence? */
-            if (rb_obj_is_kind_of($input,rb_cArray)) {
-                unsigned int size = RARRAY_LEN($input);
-                if (size == 0) {
-                    /* an empty sequence can be of any type */
-                    $1 = 1;
-                } else {
-                    /* check the first element only */
-                    T* x;
-                    VALUE o = RARRAY_PTR($input)[0];
-                    if ((SWIG_ConvertPtr(o,(void **) &amp;x, 
-                                         $descriptor(T *),0)) != -1)
-                        $1 = 1;
-                    else
-                        $1 = 0;
-                }
-            } else {
-                /* wrapped list? */
-                std::list&lt;T &gt;* v;
-                if (SWIG_ConvertPtr($input,(void **) &amp;v, 
-                                    $&amp;1_descriptor,0) != -1)
-                    $1 = 1;
-                else
-                    $1 = 0;
-            }
-        }
-        %typecheck(SWIG_TYPECHECK_LIST) const list&lt;T&gt;&amp;,
-                                          const list&lt;T&gt;* {
-            /* native sequence? */
-            if (rb_obj_is_kind_of($input,rb_cArray)) {
-                unsigned int size = RARRAY_LEN($input);
-                if (size == 0) {
-                    /* an empty sequence can be of any type */
-                    $1 = 1;
-                } else {
-                    /* check the first element only */
-                    T* x;
-                    VALUE o = RARRAY_PTR($input)[0];
-                    if ((SWIG_ConvertPtr(o,(void **) &amp;x, 
-                                         $descriptor(T *),0)) != -1)
-                        $1 = 1;
-                    else
-                        $1 = 0;
-                }
-            } else {
-                /* wrapped list? */
-                std::list&lt;T &gt;* v;
-                if (SWIG_ConvertPtr($input,(void **) &amp;v, 
-                                    $1_descriptor,0) != -1)
-                    $1 = 1;
-                else
-                    $1 = 0;
-            }
-        }
-      public:
-        list();
-        list(unsigned int size);
-        list(unsigned int size, const T&amp; value);
-        list(const list&lt;T&gt; &amp;);
-
-        %rename(__len__) size;
-        unsigned int size() const;
-        %rename(&quot;empty?&quot;) empty;
-        bool empty() const;
-        void clear();
-        %rename(push) push_back;
-        void push_back(const T&amp; x);
-        %extend {
-            T pop() throw (std::out_of_range) {
-                if (self-&gt;size() == 0)
-                    throw std::out_of_range(&quot;pop from empty list&quot;);
-                T x = self-&gt;back();
-                self-&gt;pop_back();
-                return x;
-            }
-
-            void each() {
-	        for(std::list&lt;T&gt;::iterator i=self-&gt;begin();i!=self-&gt;end();i++) // without ptr
-                {
-		    rb_yield(AG_NewPointerObj((void*)&amp;(*i),$descriptor(T*),0));
-                }
-            }
-        }
-    };
-
-    // Partial specialization for lists of pointers.  [ beazley ]
-
-    %mixin list&lt;T*&gt; &quot;Enumerable&quot;;
-    template&lt;class T&gt; class list&lt;T*&gt; {
-        %typemap(in) list&lt;T*&gt; {
-            if (rb_obj_is_kind_of($input,rb_cArray)) {
-                unsigned int size = RARRAY_LEN($input);
-                $1 = std::list&lt;T* &gt;();//(size);
-                for (unsigned int i=0; i&lt;size; i++) {
-                    VALUE o = RARRAY_PTR($input)[i];
-                    T* x;
-                    SWIG_ConvertPtr(o, (void **) &amp;x, $descriptor(T *), 1);
-		    $1.push_back(x);
-                }
-            } else {
-                void *ptr;
-                SWIG_ConvertPtr($input, &amp;ptr, $&amp;1_descriptor, 1);
-                $1 = *(($&amp;1_type) ptr);
-            }
-        }
-        %typemap(in) const list&lt;T*&gt;&amp; (std::list&lt;T*&gt; temp),
-                     const list&lt;T*&gt;* (std::list&lt;T*&gt; temp) {
-            if (rb_obj_is_kind_of($input,rb_cArray)) {
-                unsigned int size = RARRAY_LEN($input);
-                temp = std::list&lt;T* &gt;();//(size);
-                $1 = &temp;
-                for (unsigned int i=0; i&lt;size; i++) {
-                    VALUE o = RARRAY_PTR($input)[i];
-                    T* x;
-                    SWIG_ConvertPtr(o, (void **) &amp;x, $descriptor(T *), 1);
-                    temp.push_back(x);
-                }
-            } else {
-                SWIG_ConvertPtr($input, (void **) &amp;$1, $1_descriptor, 1);
-            }
-        }
-        %typemap(out) list&lt;T*&gt; {
-            $result = rb_ary_new2($1.size());
-            size_t j=0;
-             for($1_type::iterator i=$1.begin();i!=$1.end();i++,j++) {
-               rb_ary_store($result,j,AG_NewPointerObj(*i,$descriptor(T*),1));
-             }
-            assert(j==$1.size());
-        }
-        %typecheck(SWIG_TYPECHECK_LIST) list&lt;T*&gt; {
-            /* native sequence? */
-            if (rb_obj_is_kind_of($input,rb_cArray)) {
-                unsigned int size = RARRAY_LEN($input);
-                if (size == 0) {
-                    /* an empty sequence can be of any type */
-                    $1 = 1;
-                } else {
-                    /* check the first element only */
-                    T* x;
-                    VALUE o = RARRAY_PTR($input)[0];
-                    if ((SWIG_ConvertPtr(o,(void **) &amp;x, 
-                                         $descriptor(T *),0)) != -1)
-                        $1 = 1;
-                    else
-                        $1 = 0;
-                }
-            } else {
-                /* wrapped list? */
-                std::list&lt;T* &gt;* v;
-                if (SWIG_ConvertPtr($input,(void **) &amp;v, 
-                                    $&amp;1_descriptor,0) != -1)
-                    $1 = 1;
-                else
-                    $1 = 0;
-            }
-        }
-        %typecheck(SWIG_TYPECHECK_LIST) const list&lt;T*&gt;&amp;,
-                                          const list&lt;T*&gt;* {
-            /* native sequence? */
-            if (rb_obj_is_kind_of($input,rb_cArray)) {
-                unsigned int size = RARRAY_LEN($input);
-                if (size == 0) {
-                    /* an empty sequence can be of any type */
-                    $1 = 1;
-                } else {
-                    /* check the first element only */
-                    T* x;
-                    VALUE o = RARRAY_PTR($input)[0];
-                    if ((SWIG_ConvertPtr(o,(void **) &amp;x, 
-                                         $descriptor(T *),0)) != -1)
-                        $1 = 1;
-                    else
-                        $1 = 0;
-                }
-            } else {
-                /* wrapped list? */
-                std::list&lt;T* &gt;* v;
-                if (SWIG_ConvertPtr($input,(void **) &amp;v, 
-                                    $1_descriptor,0) != -1)
-                    $1 = 1;
-                else
-                    $1 = 0;
-            }
-        }
-      public:
-        list();
-        list(unsigned int size);
-        list(unsigned int size, T * &amp;value);
-        list(const list&lt;T*&gt; &amp;);
-
-        %rename(__len__) size;
-        unsigned int size() const;
-        %rename(&quot;empty?&quot;) empty;
-        bool empty() const;
-        void clear();
-        %rename(push) push_back;
-        void push_back(T* x);
-        %extend {
-            T* pop() throw (std::out_of_range) {
-                if (self-&gt;size() == 0)
-                    throw std::out_of_range(&quot;pop from empty list&quot;);
-                T* x = self-&gt;back();
-                self-&gt;pop_back();
-                return x;
-            }
-
-            void each() {
-                for(std::list&lt;T*&gt;::iterator i=self-&gt;begin();i!=self-&gt;end();i++) // with ptr
-                {
-                    rb_yield(AG_NewPointerObj(*i,$descriptor(T*),0));
-		}
-            }
-        }
-    };
-        
-
-    // specializations for built-ins
-
-    %define specialize_std_list(T,CHECK,CONVERT_FROM,CONVERT_TO)
-    %mixin list&lt;T&gt; &quot;Enumerable&quot;;
-    template&lt;&gt; class list&lt;T&gt; {
-        %typemap(in) list&lt;T&gt; {
-            if (rb_obj_is_kind_of($input,rb_cArray)) {
-                unsigned int size = RARRAY_LEN($input);
-                $1 = std::list&lt;T &gt;();//(size);
-                for (unsigned int i=0; i&lt;size; i++) {
-                    VALUE o = RARRAY_PTR($input)[i];
-                    if (CHECK(o))
-                        (($1_type &amp;)$1)[i] = (T)(CONVERT_FROM(o));
-                    else
-                        rb_raise(rb_eTypeError,
-                                 &quot;wrong argument type&quot;
-                                 &quot; (expected list&lt;&quot; #T &quot;&gt;)&quot;);
-                }
-            } else {
-	        void *ptr;
-                SWIG_ConvertPtr($input, &amp;ptr, $&amp;1_descriptor, 1);
-                $1 = *(($&amp;1_type) ptr);
-            }
-        }
-        %typemap(in) const list&lt;T&gt;&amp; (std::list&lt;T&gt; temp),
-                     const list&lt;T&gt;* (std::list&lt;T&gt; temp) {
-            if (rb_obj_is_kind_of($input,rb_cArray)) {
-                unsigned int size = RARRAY_LEN($input);
-                temp = std::list&lt;T &gt;();//(size);
-                $1 = &temp;
-                for (unsigned int i=0; i&lt;size; i++) {
-                    VALUE o = RARRAY_PTR($input)[i];
-                    if (CHECK(o))
-                        temp.push_back((T)(CONVERT_FROM(o)));
-                    else
-                        rb_raise(rb_eTypeError,
-                                 &quot;wrong argument type&quot;
-                                 &quot; (expected list&lt;&quot; #T &quot;&gt;)&quot;);
-                }
-            } else {
-                SWIG_ConvertPtr($input, (void **) &amp;$1, $1_descriptor, 1);
-            }
-        }
-        %typemap(out) list&lt;T&gt; {
-            $result = rb_ary_new2($1.size());
-            for (($1_type)::iterator i=$1.begin();i!=$1.end();i++) //unsigned int i=0; i&lt;$1.size(); i++)
-                rb_ary_store($result,i,CONVERT_TO(*i));
-        }
-        %typecheck(SWIG_TYPECHECK_LIST) list&lt;T&gt; {
-            /* native sequence? */
-            if (rb_obj_is_kind_of($input,rb_cArray)) {
-                unsigned int size = RARRAY_LEN($input);
-                if (size == 0) {
-                    /* an empty sequence can be of any type */
-                    $1 = 1;
-                } else {
-                    /* check the first element only */
-                    VALUE o = RARRAY_PTR($input)[0];
-                    if (CHECK(o))
-                        $1 = 1;
-                    else
-                        $1 = 0;
-                }
-            } else {
-                /* wrapped list? */
-                std::list&lt;T &gt;* v;
-                if (SWIG_ConvertPtr($input,(void **) &amp;v, 
-                                    $&amp;1_descriptor,0) != -1)
-                    $1 = 1;
-                else
-                    $1 = 0;
-            }
-        }
-        %typecheck(SWIG_TYPECHECK_LIST) const list&lt;T&gt;&amp;,
-                                          const list&lt;T&gt;* {
-            /* native sequence? */
-            if (rb_obj_is_kind_of($input,rb_cArray)) {
-                unsigned int size = RARRAY_LEN($input);
-                if (size == 0) {
-                    /* an empty sequence can be of any type */
-                    $1 = 1;
-                } else {
-                    /* check the first element only */
-                    VALUE o = RARRAY_PTR($input)[0];
-                    if (CHECK(o))
-                        $1 = 1;
-                    else
-                        $1 = 0;
-                }
-            } else {
-                /* wrapped list? */
-                std::list&lt;T &gt;* v;
-                if (SWIG_ConvertPtr($input,(void **) &amp;v, 
-                                    $1_descriptor,0) != -1)
-                    $1 = 1;
-                else
-                    $1 = 0;
-            }
-        }
-      public:
-        list();
-        list(unsigned int size);
-        list(unsigned int size, const T&amp; value);
-        list(const list&lt;T&gt; &amp;);
-
-        %rename(__len__) size;
-        unsigned int size() const;
-        %rename(&quot;empty?&quot;) empty;
-        bool empty() const;
-        void clear();
-        %rename(push) push_back;
-        void push_back(T x);
-        %extend {
-            T pop() throw (std::out_of_range) {
-                if (self-&gt;size() == 0)
-                    throw std::out_of_range(&quot;pop from empty list&quot;);
-                T x = self-&gt;back();
-                self-&gt;pop_back();
-                return x;
-            }
-		
-            void each() {
-		for(std::list&lt;T&gt;::iterator i=self-&gt;begin();i!=self-&gt;end();i++) // with ptr2
-                    rb_yield(CONVERT_TO(*i));
-            }
-        }
-    };
-    %enddef
-
-    specialize_std_list(bool,SWIG_BOOL_P,SWIG_RB2BOOL,SWIG_BOOL2RB);
-    specialize_std_list(char,FIXNUM_P,FIX2INT,INT2NUM);
-    specialize_std_list(int,FIXNUM_P,FIX2INT,INT2NUM);
-    specialize_std_list(short,FIXNUM_P,FIX2INT,INT2NUM);
-    specialize_std_list(long,FIXNUM_P,FIX2INT,INT2NUM);
-    specialize_std_list(unsigned char,FIXNUM_P,FIX2INT,INT2NUM);
-    specialize_std_list(unsigned int,FIXNUM_P,FIX2INT,INT2NUM);
-    specialize_std_list(unsigned short,FIXNUM_P,FIX2INT,INT2NUM);
-    specialize_std_list(unsigned long,FIXNUM_P,FIX2INT,INT2NUM);
-    specialize_std_list(double,SWIG_FLOAT_P,SWIG_NUM2DBL,rb_float_new);
-    specialize_std_list(float,SWIG_FLOAT_P,SWIG_NUM2DBL,rb_float_new);
-    specialize_std_list(std::string,SWIG_STRING_P,SWIG_RB2STR,SWIG_STR2RB);
-
-}
-

Deleted: antargis/trunk/build/std_string.i
===================================================================
--- antargis/trunk/build/std_string.i	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/build/std_string.i	2008-01-06 16:08:38 UTC (rev 1211)
@@ -1,86 +0,0 @@
-//
-// SWIG typemaps for std::string
-// Luigi Ballabio
-// Apr 8, 2002
-//
-// Ruby implementation
-
-
-// ------------------------------------------------------------------------
-// std::string is typemapped by value
-// This can prevent exporting methods which return a string
-// in order for the user to modify it.
-// However, I think I'll wait until someone asks for it...
-// ------------------------------------------------------------------------
-
-%include exception.i
-
-%{
-#include &lt;string&gt;
-%}
-
-namespace std {
-
-    // Ruby wants class names to start with a capital letter
-    %rename(String) string;
-    class string;
-
-    /* Overloading check */
-    %typemap(typecheck) string = char *;
-    %typemap(typecheck) const string &amp; = char *;
-
-    %typemap(in) string {
-        if (TYPE($input) == T_STRING) {
-//            $1 = std::string(StringValuePtr($input));
-            $1 = std::string(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;not a string&quot;);
-        }
-    }
-
-    %typemap(in) const string &amp; (std::string temp) {
-        if (TYPE($input) == T_STRING) {
-//            temp = std::string(StringValuePtr($input));
-            temp = std::string(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-            $1 = &temp;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;not a string&quot;);
-        }
-    }
-
-    %typemap(out) string {
-        $result = rb_str_new($1.c_str(),$1.length());
-    }
-
-    %typemap(out) const string &amp; {
-        $result = rb_str_new($1-&gt;c_str(),$1.length());
-    }
-
-    %typemap(directorin) string, const string &amp;, string &amp; &quot;$input=rb_str_new2($1_name.c_str());&quot;;
-
-    %typemap(directorin) string *, const string * &quot;$1_name-&gt;c_str()&quot;;
-    
-    %typemap(directorout) string {
-        if (TYPE($input) == T_STRING)
-//            $result = std::string(StringValuePtr($input));
-            $result = std::string(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-        else
-            throw Swig::DirectorTypeMismatchException(&quot;string expected&quot;);
-    }
-    
-    %typemap(directorout) const string &amp; (std::string temp) {
-        if (TYPE($input) == T_STRING) {
-//            temp = std::string(StringValuePtr($input));
-            temp = std::string(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
-            $result = &temp;
-        } else {
-            throw Swig::DirectorTypeMismatchException(&quot;string expected&quot;);
-        }
-    }
-
-    %typemap(throws) string, const string &amp;
-        &quot;rb_raise(rb_eRuntimeError, $1.c_str());&quot;;
-
-    %typemap(throws) string *, const string *
-        &quot;rb_raise(rb_eRuntimeError, $1-&gt;c_str());&quot;;
-}

Copied: antargis/trunk/build/swig/AGString.i (from rev 1201, antargis/trunk/build/AGString.i)

Copied: antargis/trunk/build/swig/ag_data.i (from rev 1201, antargis/trunk/build/ag_data.i)

Copied: antargis/trunk/build/swig/ag_filename.i (from rev 1201, antargis/trunk/build/ag_filename.i)

Copied: antargis/trunk/build/swig/ag_string.i (from rev 1201, antargis/trunk/build/ag_string.i)
===================================================================
--- antargis/trunk/build/ag_string.i	2007-12-26 09:56:05 UTC (rev 1201)
+++ antargis/trunk/build/swig/ag_string.i	2008-01-06 16:08:38 UTC (rev 1211)
@@ -0,0 +1,113 @@
+//
+// SWIG typemaps for std::string
+// Luigi Ballabio
+// Apr 8, 2002
+//
+// Ruby implementation
+
+
+// ------------------------------------------------------------------------
+// std::string is typemapped by value
+// This can prevent exporting methods which return a string
+// in order for the user to modify it.
+// However, I think I'll wait until someone asks for it...
+// ------------------------------------------------------------------------
+
+%include exception.i
+
+%{
+#include &lt;ag_string.h&gt;
+%}
+
+
+// Ruby wants class names to start with a capital letter
+%rename(String) AGString;
+class AGString;
+
+    //
+    %typemap(typecheck) AGString = char *;
+    %typemap(typecheck) const AGString &amp; = char *;
+
+    %typemap(in) AGString {
+        if (TYPE($input) == T_STRING) {
+            $1 = AGString(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
+        } else {
+            SWIG_exception(SWIG_TypeError, &quot;not a string&quot;);
+        }
+    }
+
+    %typemap(in) const AGString &amp; (AGString res) {
+        if (TYPE($input) == T_STRING) {
+            res = AGString(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
+            $1 = &res;
+        } else {
+            SWIG_exception(SWIG_TypeError, &quot;not a string&quot;);
+        }
+    }
+
+    %typemap(out) AGString {
+        $result = rb_str_new($1.c_str(),$1.length());
+    }
+
+    %typemap(out) const AGString &amp; {
+        $result = rb_str_new($1-&gt;c_str(),$1-&gt;length());
+    }
+
+    %typemap(directorin) AGString, const AGString &amp;, AGString &amp; &quot;$input=rb_str_new($1_name.c_str(),$1_name.length());&quot;;
+
+    %typemap(directorin) AGString *, const AGString * &quot;$1_name-&gt;c_str()&quot;;
+    
+    %typemap(directorout) AGString {
+        if (TYPE($input) == T_STRING)
+            $result = AGString(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
+        else
+            throw Swig::DirectorTypeMismatchException(&quot;string expected&quot;);
+    }
+    
+    %typemap(directorout) const AGString &amp; (AGString res) {
+        if (TYPE($input) == T_STRING) {
+            res = AGString(RSTRING($input)-&gt;ptr,RSTRING($input)-&gt;len);
+            $result = &res;
+        } else {
+            throw Swig::DirectorTypeMismatchException(&quot;string expected&quot;);
+        }
+    }
+
+
+%{
+AGString SWIG_RB2AGSTR(VALUE x) {
+    return AGString(RSTRING_PTR(x), RSTRING_LEN(x));
+}
+VALUE SWIG_AGSTR2RB(const AGString&amp; s) {
+    return rb_str_new(s.data(), s.size());
+}
+%}
+namespace std
+{
+	specialize_std_vector(AGString,SWIG_STRING_P,SWIG_RB2AGSTR,SWIG_AGSTR2RB);
+	specialize_std_vector(AGFilename,SWIG_STRING_P,SWIG_RB2AGSTR,SWIG_AGSTR2RB);
+	specialize_std_vector(AGData,SWIG_STRING_P,SWIG_RB2AGSTR,SWIG_AGSTR2RB);
+}
+
+
+
+/*
+%apply std::string { AGString };  
+%apply const std::string { const AGString }; 
+
+%apply std::string* { AGString* };  
+// Not defined yet 
+//%apply const std::string* { const AGString* }; 
+ 
+%apply std::string&amp; { AGString&amp; }; 
+%apply const std::string&amp; { const AGString&amp; };  
+*/
+/*
+
+%include &lt;typemaps/std_string.swg&gt;
+
+%naturalvar AGString;
+//typedef std::string AGString;
+class AGString:public std::string {
+};
+*/
\ No newline at end of file

Copied: antargis/trunk/build/swig/common.i (from rev 1201, antargis/trunk/build/common.i)
===================================================================
--- antargis/trunk/build/common.i	2007-12-26 09:56:05 UTC (rev 1201)
+++ antargis/trunk/build/swig/common.i	2008-01-06 16:08:38 UTC (rev 1211)
@@ -0,0 +1,37 @@
+%feature(&quot;director&quot;);
+%include &quot;typemaps.i&quot;
+%include &quot;std_string.i&quot;
+%include &quot;std_vector.i&quot;
+%include &quot;std_pair.i&quot;
+%include &quot;std_map.i&quot;
+%include &quot;std_list.i&quot;
+%include &quot;ag_string_new.i&quot;
+%include &quot;ag_string.i&quot;
+%include &quot;ag_filename.i&quot;
+%include &quot;ag_data.i&quot;
+
+%{
+#include &lt;ag_rubyobj.h&gt;
+
+SWIGRUNTIME VALUE
+AG_NewPointerObj(void *ptr, swig_type_info *type, int flags)
+{
+	AGRubyObject *o=(AGRubyObject*)ptr;
+#ifdef GCDEBUG
+	printf(&quot;AG_NewPointerObj o:0x%lx , ruby:0x%lx vl:0x%lx\n&quot;,o,o-&gt;mRubyObject,o-&gt;mRUBY);
+#endif
+	if(o-&gt;mRubyObject)
+		return o-&gt;mRUBY;
+
+	swig_type_info *t=SWIG_TypeDynamicCast(type,(void**)&amp;o);
+
+	o-&gt;mRubyObject=true;
+	o-&gt;mRUBY=SWIG_NewPointerObj((void *) o, t,flags);
+#ifdef GCDEBUG
+	printf(&quot;NEW AG_NewPointerObj o:0x%lx , ruby:0x%lx vl:0x%lx\n&quot;,o,o-&gt;mRubyObject,o-&gt;mRUBY);
+#endif
+	return o-&gt;mRUBY;
+}
+
+%}
+

Copied: antargis/trunk/build/swig/std_list.i (from rev 1201, antargis/trunk/build/std_list.i)

Copied: antargis/trunk/build/swig/std_string.i (from rev 1201, antargis/trunk/build/std_string.i)

Modified: antargis/trunk/ext/Rakefile
===================================================================
--- antargis/trunk/ext/Rakefile	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/ext/Rakefile	2008-01-06 16:08:38 UTC (rev 1211)
@@ -70,7 +70,7 @@
 	input=dir+&quot;/interface.i&quot;
 	cflags=$CONFIG[&quot;INCLUDEPATH&quot;]+&quot; &quot;+$CONFIG[&quot;DEFINES&quot;]+&quot; -DAGEXPORT&quot;
 	puts &quot;&quot;
-	cmd=$CONFIG[&quot;SWIG&quot;]+&quot; #{cflags} -ruby -c++ -M #{input} &gt;#{output}&quot;
+	cmd=$CONFIG[&quot;SWIG&quot;]+&quot; #{cflags} -ruby -c++ -Ibuild/swig -M #{input} &gt;#{output}&quot;
 	sh cmd
 	$?
 end
@@ -79,7 +79,7 @@
 	output=dir+&quot;/swig.cc&quot;
 	input=dir+&quot;/interface.i&quot;
 	cflags=$CONFIG[&quot;INCLUDEPATH&quot;]+&quot; &quot;+$CONFIG[&quot;DEFINES&quot;]+&quot; -DAGEXPORT&quot;
-	cmd=$CONFIG[&quot;SWIG&quot;]+&quot; #{cflags} -v -Wall -ruby -c++ -o #{output} #{input}&quot;
+	cmd=$CONFIG[&quot;SWIG&quot;]+&quot; #{cflags} -v -Wall -ruby -c++ -Ibuild/swig -o #{output} #{input}&quot;
 	puts &quot;&quot;
 	pp cmd
 	sh cmd
@@ -263,8 +263,22 @@
 task :library=&gt;&quot;ext/antargis.so&quot; do
 end
 
-if SWIG_ENABLED
+if SWIG_ENABLED and false
+	mSwigDeps=Dir[&quot;ext/*/*.h&quot;].select{|file|not file=~/swig/}
+	
+	# this can be used with a later version of rake - 0.7.1 makes problems with rules and more than one dependency
+	mSwigDepLambda=lambda{|t|
+		mSwigDeps
+	}
+	
+	task &quot;ext/swig.cc&quot; =&gt; mSwigDeps do
+		# FIXME
+		system($CONFIG[&quot;RUBY&quot;]+&quot; &quot;+File.join(&quot;ext&quot;,&quot;create_interface_test.rb&quot;))
+	end
 
+
+elsif SWIG_ENABLED
+
 	
 	def importsForInterface(name)
 		mdeps=[]
@@ -311,7 +325,7 @@
 		input.each{|filename|file.puts &quot;%include \&quot;#{filename}\&quot;&quot;}
 		file.close
 		cflags=$CONFIG[&quot;INCLUDEPATH&quot;]+&quot; &quot;+$CONFIG[&quot;DEFINES&quot;]+&quot; -DAGEXPORT&quot;
-		cmd=$CONFIG[&quot;SWIG&quot;]+&quot; #{cflags} -v -Wall -ruby -c++ -o #{output} ext/interface.i&quot;
+		cmd=$CONFIG[&quot;SWIG&quot;]+&quot; #{cflags} -v -Wall -ruby -c++ -Ibuild/swig -o #{output} ext/interface.i&quot;
 		puts &quot;&quot;
 		sh cmd
 		$?

Modified: antargis/trunk/ext/basic/ag_fs.cc
===================================================================
--- antargis/trunk/ext/basic/ag_fs.cc	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/ext/basic/ag_fs.cc	2008-01-06 16:08:38 UTC (rev 1211)
@@ -457,19 +457,19 @@
 {
 #ifdef WIN32
   if(GetFileAttributes(pName.c_str()) == INVALID_FILE_ATTRIBUTES)
-	return false;
+    return false;
   return true;
 #endif
 
   FILE *f=fopen(pName.c_str(),&quot;r&quot;);
-	bool found=false;
+  bool found=false;
 	
   if(f)
     {
 			found=true;
       fclose(f);
     }
-	cdebug(&quot;file exists:&quot;&lt;&lt;pName&lt;&lt;&quot;:&quot;&lt;&lt;found);
+  //	cdebug(&quot;file exists:&quot;&lt;&lt;pName&lt;&lt;&quot;:&quot;&lt;&lt;found);
 
   return found;
 #ifdef USE_PHYSFS

Modified: antargis/trunk/ext/basic/templates.i
===================================================================
--- antargis/trunk/ext/basic/templates.i	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/ext/basic/templates.i	2008-01-06 16:08:38 UTC (rev 1211)
@@ -8,6 +8,7 @@
 
 %template(StringVector) std::vector&lt;std::string&gt;;
 %template(AGStringVector) std::vector&lt;AGString&gt;;
+%template(AGStringUtf8Vector) std::vector&lt;AGStringUtf8&gt;;
 %template(AGFilenameVector) std::vector&lt;AGFilename&gt;;
 %template(AGVector2List) std::list&lt;AGVector2&gt;;
 

Modified: antargis/trunk/ext/game/entity.cc
===================================================================
--- antargis/trunk/ext/game/entity.cc	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/ext/game/entity.cc	2008-01-06 16:08:38 UTC (rev 1211)
@@ -449,6 +449,15 @@
 {
   return &quot;antEntity&quot;;
 }
+std::string AntEntity::xmlName2() const
+{
+  return &quot;antEntity&quot;;
+}
+AGString AntEntity::xmlName3() const
+{
+  return &quot;antEntity&quot;;
+}
+
 float AntEntity::getDirection() const
 {
   return mDir;

Modified: antargis/trunk/ext/game/entity.h
===================================================================
--- antargis/trunk/ext/game/entity.h	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/ext/game/entity.h	2008-01-06 16:08:38 UTC (rev 1211)
@@ -151,6 +151,8 @@
 
     // saving and loading
     virtual AGString xmlName() const;
+    virtual std::string xmlName2() const;
+    virtual AGString xmlName3() const;
 
     virtual void saveXML(Node &amp;node) const;
     virtual void loadXML(const Node &amp;node);

Modified: antargis/trunk/ext/game/height_map.cc
===================================================================
--- antargis/trunk/ext/game/height_map.cc	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/ext/game/height_map.cc	2008-01-06 16:08:38 UTC (rev 1211)
@@ -376,14 +376,19 @@
       std::string name=mName.replace(&quot;.antlvl&quot;,&quot;.hmap&quot;);
       BinaryFileOut os(name);
       saveBinary(os);
+      cdebug(&quot;try setting filename:&quot;);
       node.set(&quot;filename&quot;,AGString(name));
+      cdebug(&quot;done&quot;);
     }
   else
     {
       BinaryStringOut os;
       saveBinary(os);
+      cdebug(&quot;try setting data:&quot;);
       Node &amp;n=node.addChild(&quot;data&quot;);
+      cdebug(&quot;done1&quot;);
       n.setContent(AGString(binaryToHex(os.getString())));
+      cdebug(&quot;done2&quot;);
     }
 }
 

Modified: antargis/trunk/ext/game/map.cc
===================================================================
--- antargis/trunk/ext/game/map.cc	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/ext/game/map.cc	2008-01-06 16:08:38 UTC (rev 1211)
@@ -91,13 +91,18 @@
 void AntMap::saveXML(Node &amp;node) const
 {
   HeightMap::saveXML(node);
-  
+  cdebug(&quot;height map saving ready&quot;);
   // entities
   std::list&lt;AntEntity*&gt;::const_iterator i=mEntities.begin();
   for(;i!=mEntities.end();i++)
     {
-      Node &amp;child=node.addChild((*i)-&gt;xmlName());
+      cdebug(&quot;try saving child1 &quot;&lt;&lt;*i);
+			AGString s=(*i)-&gt;xmlName();
+			cdebug(&quot;xmlName:&quot;&lt;&lt;s);
+      Node &amp;child=node.addChild(s);
+      cdebug(&quot;try saving child2 &quot;&lt;&lt;*i);
       (*i)-&gt;saveXML(child);
+      cdebug(&quot;try saving child3 &quot;&lt;&lt;*i);
     }
   
 }
@@ -364,11 +369,12 @@
 }
 void AntMap::saveMap(const AGFilename &amp;pFilename)
 {
+	CTRACE;
   mName=AGString(pFilename);
   Document d;
   Node &amp;root=d.root();
   root.setName(&quot;antargisLevel&quot;);
-  //  cdebug(&quot;root:&quot;&lt;&lt;root);
+  cdebug(&quot;root:&quot;&lt;&lt;&amp;root);
   saveXML(root);
 
   AGData c=d.toString();

Modified: antargis/trunk/ext/video/ag_surface.cc
===================================================================
--- antargis/trunk/ext/video/ag_surface.cc	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/ext/video/ag_surface.cc	2008-01-06 16:08:38 UTC (rev 1211)
@@ -328,8 +328,8 @@
 
 AGSurface AGSurface::load(const std::string &amp;pFilename)
 {
-  cdebug(&quot;load:&quot;&lt;&lt;pFilename);
-	assertGL;
+  //  cdebug(&quot;load:&quot;&lt;&lt;pFilename);
+  assertGL;
   assert(&amp;getScreen());
 
   assertGL;

Modified: antargis/trunk/ext/video/templates.i
===================================================================
--- antargis/trunk/ext/video/templates.i	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/ext/video/templates.i	2008-01-06 16:08:38 UTC (rev 1211)
@@ -0,0 +1,6 @@
+typedef struct SDL_Color {
+	Uint8 r;
+	Uint8 g;
+	Uint8 b;
+	Uint8 unused;
+} SDL_Color;

Modified: antargis/trunk/ruby/campaign.rb
===================================================================
--- antargis/trunk/ruby/campaign.rb	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/ruby/campaign.rb	2008-01-06 16:08:38 UTC (rev 1211)
@@ -36,7 +36,7 @@
 			raise 'Problem - $campaign not net' if $campaign==nil
 			sname=$campaign.savename.gsub(&quot;antcmp&quot;,&quot;antlvl&quot;)
 			n.set(&quot;current&quot;,sname)
-			getMap.saveMap(sname)
+			@app.getMap.saveMap(sname)
 		end
 	end
 

Modified: antargis/trunk/ruby/dialogs.rb
===================================================================
--- antargis/trunk/ruby/dialogs.rb	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/ruby/dialogs.rb	2008-01-06 16:08:38 UTC (rev 1211)
@@ -259,7 +259,9 @@
 			filename=filename.to_s+&quot;.antlvl&quot;
 		end
 		hide
-		getApp.getMap.saveMap(getSavePath+&quot;/&quot;+filename)
+		map=getApp.getMap
+		path=getSavePath+&quot;/&quot;+filename
+		map.saveMap(path)
 		takeSmallScreenshot.save(getSavePath+&quot;/#{filename.gsub(&quot;antlvl&quot;,&quot;png&quot;)}&quot;)
 		getApp.getMap.pause=false
 		AntSound.setNormalVolumeWave

Modified: antargis/trunk/ruby/editview.rb
===================================================================
--- antargis/trunk/ruby/editview.rb	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/ruby/editview.rb	2008-01-06 16:08:38 UTC (rev 1211)
@@ -31,6 +31,8 @@
 		$scene=getScene
 	
 		@layout=AGLayout.new(nil)
+
+		@layout.setApp(self)
 		@layout.loadXML(loadFile(&quot;data/gui/layout/edit_layout.xml&quot;))
 		
 		setMainWidget(@layout)

Modified: antargis/trunk/ruby/map.rb
===================================================================
--- antargis/trunk/ruby/map.rb	2008-01-01 17:07:05 UTC (rev 1210)
+++ antargis/trunk/ruby/map.rb	2008-01-06 16:08:38 UTC (rev 1211)
@@ -326,7 +326,9 @@
 		super
 	end
 
-	def saveXML(n)
+	def saveXMLTRest(n)
+		puts self
+		pp n
 		super(n)
 		@players.each{|player|
 			c=n.addChild(player.xmlName)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000167.html">[Antargis-svn] r1210 - antargis/tags
</A></li>
	<LI>Next message: <A HREF="000169.html">[Antargis-svn] r1212 - antargis/trunk/build/swig/tests
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#168">[ date ]</a>
              <a href="thread.html#168">[ thread ]</a>
              <a href="subject.html#168">[ subject ]</a>
              <a href="author.html#168">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/antargis-svn">More information about the Antargis-svn
mailing list</a><br>
</body></html>
