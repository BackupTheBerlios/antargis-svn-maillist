From davidkamphausen at mail.berlios.de  Thu Jun  5 21:24:56 2008
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Thu, 5 Jun 2008 21:24:56 +0200
Subject: [Antargis-svn] r1263 - in antargis/trunk: .
	data/gui/layout/editor/campaign ext/3dengine ext/basic
	ext/gui ext/video rookey ruby ruby/editor/campaign
	ruby/entities ruby/entities/spec ruby/gui ruby/jobs
	ruby/jobs/spec ruby/meshes ruby/spec ruby/state_machine
	ruby/state_machine/spec ruby/state_machine/tests ruby/tests
	ruby/tests/3d_engine ruby/tests/path ruby/tools ruby/widgets
Message-ID: <200806051924.m55JOudO013506@sheep.berlios.de>

Author: davidkamphausen
Date: 2008-06-05 21:24:45 +0200 (Thu, 05 Jun 2008)
New Revision: 1263

Added:
   antargis/trunk/ruby/spec/spec_drawing.rb
Removed:
   antargis/trunk/ruby/spec/spec_translation.rb
Modified:
   antargis/trunk/TODO
   antargis/trunk/data/gui/layout/editor/campaign/main.xml
   antargis/trunk/ext/3dengine/vertex_array.cc
   antargis/trunk/ext/basic/ag_gauss.h
   antargis/trunk/ext/basic/ag_geometry.cc
   antargis/trunk/ext/basic/ag_geometry.h
   antargis/trunk/ext/basic/ag_messageobject.cc
   antargis/trunk/ext/basic/ag_messageobject.h
   antargis/trunk/ext/gui/ag_button.cc
   antargis/trunk/ext/gui/ag_widget.cc
   antargis/trunk/ext/gui/ag_widget.h
   antargis/trunk/ext/video/ag_gltexture.cc
   antargis/trunk/ext/video/ag_painter.cc
   antargis/trunk/ext/video/ag_painter.h
   antargis/trunk/ext/video/ag_projection.cc
   antargis/trunk/ext/video/ag_projection.h
   antargis/trunk/rookey/tasks.rb
   antargis/trunk/ruby/editor/campaign/drag_grid.rb
   antargis/trunk/ruby/entities/ant_wolf.rb
   antargis/trunk/ruby/entities/ant_workshop.rb
   antargis/trunk/ruby/entities/entity.rb
   antargis/trunk/ruby/entities/spec/entities.rb
   antargis/trunk/ruby/game_result.rb
   antargis/trunk/ruby/gen_tree.rb
   antargis/trunk/ruby/gui/ag_tools.rb
   antargis/trunk/ruby/gui/testing.rb
   antargis/trunk/ruby/intro.rb
   antargis/trunk/ruby/jobs/ant_state_machine.rb
   antargis/trunk/ruby/jobs/spec/recruit.rb
   antargis/trunk/ruby/level.rb
   antargis/trunk/ruby/mainmenu.rb
   antargis/trunk/ruby/map_generator.rb
   antargis/trunk/ruby/map_generator2.rb
   antargis/trunk/ruby/mesh_view.rb
   antargis/trunk/ruby/meshes/grass.rb
   antargis/trunk/ruby/mpmap.rb
   antargis/trunk/ruby/obj_import.rb
   antargis/trunk/ruby/runtests.rb
   antargis/trunk/ruby/spec/level_testing.rb
   antargis/trunk/ruby/spec/spec_basic.rb
   antargis/trunk/ruby/spec/spec_call.rb
   antargis/trunk/ruby/spec/spec_campaign.rb
   antargis/trunk/ruby/spec/spec_formation.rb
   antargis/trunk/ruby/spec/spec_gc.rb
   antargis/trunk/ruby/spec/spec_geometry.rb
   antargis/trunk/ruby/spec/spec_hljob_saving.rb
   antargis/trunk/ruby/spec/spec_map.rb
   antargis/trunk/ruby/spec/spec_math.rb
   antargis/trunk/ruby/spec/spec_menu.rb
   antargis/trunk/ruby/spec/spec_minimap.rb
   antargis/trunk/ruby/spec/spec_run_tutorial.rb
   antargis/trunk/ruby/spec/spec_screenshot.rb
   antargis/trunk/ruby/spec/spec_scrollingwidget.rb
   antargis/trunk/ruby/state_machine/ant_hl_job_states.rb
   antargis/trunk/ruby/state_machine/spec/job_states.rb
   antargis/trunk/ruby/state_machine/spec/state_machine.rb
   antargis/trunk/ruby/state_machine/state_machine.rb
   antargis/trunk/ruby/state_machine/tests/state_machine_test.rb
   antargis/trunk/ruby/storyflow.rb
   antargis/trunk/ruby/terrain_2d.rb
   antargis/trunk/ruby/test_ant3.rb
   antargis/trunk/ruby/tests/3d_engine/wireframe.rb
   antargis/trunk/ruby/tests/algebra_test.rb
   antargis/trunk/ruby/tests/basis_test.rb
   antargis/trunk/ruby/tests/clip_test.rb
   antargis/trunk/ruby/tests/clip_widget_test.rb
   antargis/trunk/ruby/tests/dirty_rects.rb
   antargis/trunk/ruby/tests/graph_test.rb
   antargis/trunk/ruby/tests/gui_tests.rb
   antargis/trunk/ruby/tests/impostor.rb
   antargis/trunk/ruby/tests/path/fields_test.rb
   antargis/trunk/ruby/tests/path/fields_test2.rb
   antargis/trunk/ruby/tests/path/heuristic_test.rb
   antargis/trunk/ruby/tests/rect_test.rb
   antargis/trunk/ruby/tests/scene_2d.rb
   antargis/trunk/ruby/tests/scissor_test.rb
   antargis/trunk/ruby/tests/sdl_texture.rb
   antargis/trunk/ruby/tests/swig_derivation_test.rb
   antargis/trunk/ruby/tests/test_path.rb
   antargis/trunk/ruby/tools/anim_import.rb
   antargis/trunk/ruby/tools/anim_import4.rb
   antargis/trunk/ruby/tools/ant2obj.rb
   antargis/trunk/ruby/two_d_app.rb
   antargis/trunk/ruby/widgets/ant_buttonpanel.rb
   antargis/trunk/ruby/widgets/ant_name_display.rb
Log:
Incomplete - task 6: Cleanup 
http://localhost:3000/issues/show/6
Incomplete - task 9: Scrollingwidget 
http://localhost:3000/issues/show/9
Incomplete - task 45: Check clipping when hovering 
http://localhost:3000/issues/show/45
Complete - task 44: Gauss implementation is buggy 
http://localhost:3000/issues/show/44

Modified: antargis/trunk/TODO
===================================================================
--- antargis/trunk/TODO	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/TODO	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,17 +1,3 @@
-* move build/*.rb files to build/unused_tools/* if they're not used
-* issue with mingw: 
-** google for "/tmp/cciSLVG5.s:932678: Warning: .stabs: description field '1c216' too big, try a different debug format"
-
-* check how many times AG_NewPointer is called !!!! - not so often - could be replaced by traceobjects from swig
-** check if it's any good to switch over to standard-swig ??? seems so.
-
-!!! AGTexture - not wrapped correctly in bliTri etc ???
-
-
-* moveto doesn't really work with "near" (hljob)
-* heroes don't die in reasonable fashion - starving men too
-* add seasons
-
 * Spreading should be done only for men who need it!
 
 * why is the story-telling dialog taking so much time ??
@@ -20,7 +6,6 @@
 * check level-editor
 ** make wish-list
 
-* check dep-handling with swig
 * move single entities with path-finder, too?
 
 * docs

Modified: antargis/trunk/data/gui/layout/editor/campaign/main.xml
===================================================================
--- antargis/trunk/data/gui/layout/editor/campaign/main.xml	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/data/gui/layout/editor/campaign/main.xml	2008-06-05 19:24:45 UTC (rev 1263)
@@ -5,7 +5,7 @@
   <rowsize row="0" fixed="50"/>
   
   <cell col="0" row="0">
-    <toolBar>
+    <toolBar name="toolbar">
          <toolButton text="Save" name="save" caption="muh" caption-image="gui/save.png"/>
          <toolButton text="Load" name="load" caption="muh" caption-image="gui/load.png"/>
     </toolBar>
@@ -59,8 +59,8 @@
   </table>
   </cell>
   </table>
-  
+  <!--
   <appearEffect name="showEdit" table="bigTable" row="1" size="40" duration="0.2"/>
-  
+-->  
 </dragEnvironment>
 </layout>
\ No newline at end of file

Modified: antargis/trunk/ext/3dengine/vertex_array.cc
===================================================================
--- antargis/trunk/ext/3dengine/vertex_array.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/3dengine/vertex_array.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -38,7 +38,7 @@
   mArrays=GLEE_EXT_vertex_array && useVertexArrays();
 
   if(videoInited())
-    assert(GLEE_EXT_vertex_array || GLEE_VERSION_1_2); //FIXME: check if this really version 1.2
+    assert(GLEE_EXT_vertex_array || GLEE_VERSION_1_2); // vertex-arrays were introduced in GL 1.1, but glee has no flag for  that
 
   displayListInited=false;
 

Modified: antargis/trunk/ext/basic/ag_gauss.h
===================================================================
--- antargis/trunk/ext/basic/ag_gauss.h	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/basic/ag_gauss.h	2008-06-05 19:24:45 UTC (rev 1263)
@@ -23,6 +23,7 @@
             for(k=1;k+c<size;k++)
               if(fabs(b.get(c,c+k))>0)
                 {
+                  //cdebug("SWAP:"<<c<<" and "<<c+k);
                   // swap rows
                   b.swapRows(c,c+k);
                   a.swapRows(c,c+k);
@@ -39,6 +40,7 @@
                 float f=-b.get(c,c)/b.get(c,r);
                 for(int i=0;i<size;i++)
                   {
+                    //cdebug("modrows:("<<r<<")=("<<c<<")+("<<r<<")*"<<f);
                     // modify row
                     a.set(i,r,a.get(i,c)+a.get(i,r)*f);
                     b.set(i,r,b.get(i,c)+b.get(i,r)*f);
@@ -49,28 +51,41 @@
               }
           }
       }
-    // cdebug("A:\n"<<a.toString());
-    // cdebug("B:\n"<<b.toString());
+    //cdebug("A:\n"<<a.toString());
+    //cdebug("B:\n"<<b.toString());
 
     // upper-right triangle
     for(int c=size-1;c>0;c--) // cols
       {
         for(int r=0;r<c;r++) // rows
           {
+            // (c,r) is to be set to zero
             if(fabs(b.get(c,r))>0.0001)
               {
-                float f=-b.get(c,r+1)/b.get(c,r);
+                // search a line >r, that is !=0
+                int r2;
+                for(r2=r+1;r2<size;r2++)
+                  if(b.get(c,r2)>0.0001)
+                    break;
+                if(r2>=size)
+                  throw GeometryException("Matrix is not invertable - no cell!=0 found in upper-right triangle.");
+                
+                float f=-b.get(c,r2)/b.get(c,r);
+                if(f==0)
+                  throw GeometryException("Matrix is not invertable - f=0");
+
+                //cdebug("modifyrow:("<<r<<")=("<<r+1<<")+("<<r<<")*"<<f);
                 for(int i=0;i<size;i++)
                   {
                     // modify row
-                    a.set(i,r,a.get(i,r+1)+a.get(i,r)*f);
-                    b.set(i,r,b.get(i,r+1)+b.get(i,r)*f);
+                    a.set(i,r,a.get(i,r2)+a.get(i,r)*f);
+                    b.set(i,r,b.get(i,r2)+b.get(i,r)*f);
                   }
               }
           }
       }
-    // cdebug("A:\n"<<a.toString());
-    // cdebug("B:\n"<<b.toString());
+    //cdebug("A:\n"<<a.toString());
+    //cdebug("B:\n"<<b.toString());
 
     // norming
 
@@ -84,8 +99,8 @@
               b.set(c,r,b.get(c,r)/v);
             }
       }
-    // cdebug("A:\n"<<a.toString());
-    // cdebug("B:\n"<<b.toString());
+    //cdebug("A:\n"<<a.toString());
+    //cdebug("B:\n"<<b.toString());
     return true; // everythin ok
   }
 

Modified: antargis/trunk/ext/basic/ag_geometry.cc
===================================================================
--- antargis/trunk/ext/basic/ag_geometry.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/basic/ag_geometry.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -150,8 +150,8 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGAngle::AGAngle(float p):angle(p)
-  {
-  }
+      {
+      }
 
 /////////////////////////////////////////////////////////////////////////////
 // AGVector2
@@ -297,9 +297,9 @@
 }
 
 (AGVector2::operator float*)()
-  {
-    return v;
-  }
+      {
+        return v;
+      }
 (AGVector2::operator const float*)() const
 {
   return v;
@@ -314,34 +314,34 @@
   return AGVector2(v[0]+p.v[0],v[1]+p.v[1]);
 }
 AGVector2 &AGVector2::operator+=(const AGVector2 &p)
-  {
-    v[0]+=p.v[0];
-    v[1]+=p.v[1];
-    return *this;
-  }
+      {
+        v[0]+=p.v[0];
+        v[1]+=p.v[1];
+        return *this;
+      }
 AGVector2 &AGVector2::operator-=(const AGVector2 &p)
-  {
-    v[0]-=p.v[0];
-    v[1]-=p.v[1];
-    return *this;
-  }
+      {
+        v[0]-=p.v[0];
+        v[1]-=p.v[1];
+        return *this;
+      }
 
 float AGVector2::operator*(const AGVector2 &p) const
 {
   return v[0]*p.v[0]+v[1]*p.v[1];
 }
 AGVector2 &AGVector2::operator*=(float f)
-  {
-    v[0]*=f;
-    v[1]*=f;
-    return *this;
-  }
+      {
+        v[0]*=f;
+        v[1]*=f;
+        return *this;
+      }
 AGVector2 &AGVector2::operator/=(float f)
-  {
-    v[0]/=f;
-    v[1]/=f;
-    return *this;
-  }
+      {
+        v[0]/=f;
+        v[1]/=f;
+        return *this;
+      }
 AGVector2 AGVector2::operator*(float f) const
 {
   return AGVector2(v[0]*f,v[1]*f);
@@ -376,10 +376,10 @@
   return v[index];
 }
 float &AGVector2::operator[](int index)
-  {
-    assert(index>=0 && index<2);
-    return v[index];
-  }
+      {
+        assert(index>=0 && index<2);
+        return v[index];
+      }
 
 
 /////////////////////////////////////////////////////////////////////////////
@@ -537,9 +537,9 @@
 }
 
 (AGVector3::operator float*)()
-  {
-    return v;
-  }
+      {
+        return v;
+      }
 AGVector3 AGVector3::operator%(const AGVector3 &a) const
 {
   return AGVector3(v[1] * a.v[2] - v[2] * a.v[1],
@@ -557,34 +557,34 @@
   return AGVector3(v[0]+p.v[0],v[1]+p.v[1],v[2]+p.v[2]);
 }
 AGVector3 &AGVector3::operator+=(const AGVector3 &p)
-  {
-    v[0]+=p.v[0];
-    v[1]+=p.v[1];
-    v[2]+=p.v[2];
-    return *this;
-  }
+      {
+        v[0]+=p.v[0];
+        v[1]+=p.v[1];
+        v[2]+=p.v[2];
+        return *this;
+      }
 AGVector3 &AGVector3::operator-=(const AGVector3 &p)
-  {
-    v[0]+=p.v[0];
-    v[1]+=p.v[1];
-    v[2]+=p.v[2];
-    return *this;
-  }
+      {
+        v[0]+=p.v[0];
+        v[1]+=p.v[1];
+        v[2]+=p.v[2];
+        return *this;
+      }
 
 AGVector3 &AGVector3::operator*=(float f)
-  {
-    v[0]*=f;
-    v[1]*=f;
-    v[2]*=f;
-    return *this;
-  }
+      {
+        v[0]*=f;
+        v[1]*=f;
+        v[2]*=f;
+        return *this;
+      }
 AGVector3 &AGVector3::operator/=(float f)
-  {
-    v[0]/=f;
-    v[1]/=f;
-    v[2]/=f;
-    return *this;
-  }
+      {
+        v[0]/=f;
+        v[1]/=f;
+        v[2]/=f;
+        return *this;
+      }
 AGVector3 AGVector3::operator*(float f) const
 {
   return AGVector3(v[0]*f,v[1]*f,v[2]*f);
@@ -619,10 +619,10 @@
   return v[index];
 }
 float &AGVector3::operator[](int index)
-  {
-    assert(index>=0 && index<3);
-    return v[index];
-  }
+      {
+        assert(index>=0 && index<3);
+        return v[index];
+      }
 
 
 ////////////////////////////////////////////////////////////////////////////
@@ -688,17 +688,23 @@
 }
 
 
-AGMatrix3 AGMatrix3::inverted() const
-{
-  CTRACE;
-  // gauss-alg.
-  AGMatrix3 a;
-  AGMatrix3 b(*this);
+AGMatrix3 AGMatrix3::inverted() const throw(GeometryException)
+    {
+      CTRACE;
+      // gauss-alg.
+      AGMatrix3 a;
+      AGMatrix3 b(*this);
+      try
+      {
+        gauss(a,b,3);
+      }
+      catch(...)
+      {
+        throw GeometryException("Matrix is not invertable");
+      }
+      return a;
+    }
 
-  gauss(a,b,3);
-  return a;
-}
-
 void AGMatrix3::swapRows(size_t a,size_t b)
   {
     if(a==b)
@@ -761,12 +767,12 @@
 
 
 AGMatrix3::Row AGMatrix3::operator[](size_t y)
-  {
-    Row r;
-    r.matrix=this;
-    r.y=y;
-    return r;
-  }
+      {
+        Row r;
+        r.matrix=this;
+        r.y=y;
+        return r;
+      }
 const AGMatrix3::Row AGMatrix3::operator[](size_t y) const
 {
   Row r;
@@ -798,10 +804,10 @@
   return n;
 }
 AGMatrix3 &AGMatrix3::operator*=(const AGMatrix3 &m)
-  {
-    *this=(*this)*m;
-    return *this;
-  }
+      {
+        *this=(*this)*m;
+        return *this;
+      }
 
 AGVector3 AGMatrix3::operator*(const AGVector3 &v) const
 {
@@ -1095,8 +1101,8 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGCircle2::AGCircle2(const AGVector2 &v,float rad):p(v),radius(rad)
-  {
-  }
+      {
+      }
 
 std::list<AGVector2> AGCircle2::collide(const AGLine2 &pLine) const
 {
@@ -1265,13 +1271,13 @@
 
 AGRect2::AGRect2(const AGVector2 &pv0,const AGVector2 &pv1):
   v0(pv0),v1(pv1)
-    {
-    }
+        {
+        }
 
 AGRect2::AGRect2(float x,float y,float w,float h):
   v0(x,y),v1(x+w,y+h)
-    {
-    }
+        {
+        }
 
 AGVector2 AGRect2::clip(const AGVector2 &v) const
 {
@@ -1310,16 +1316,16 @@
 }
 
 AGRect2& AGRect2::operator+=(const AGRect2 &r)
-  {
-    if(width()==0 || height()==0)
-      *this=r;
-    else
       {
-        include(r[0]);
-        include(r[1]);
+        if(width()==0 || height()==0)
+          *this=r;
+        else
+          {
+            include(r[0]);
+            include(r[1]);
+          }
+        return *this;
       }
-    return *this;
-  }
 
 
 
@@ -1408,18 +1414,18 @@
   return v0;
 }
 AGVector2 &AGRect2::operator[](size_t i)
-  {
-    switch(i)
       {
-    case 0:
-      return v0;
-    case 1:
-      return v1;
-    default:
-      throw AGString("invalid index in AGRect2::operator[]");
+        switch(i)
+          {
+        case 0:
+          return v0;
+        case 1:
+          return v1;
+        default:
+          throw AGString("invalid index in AGRect2::operator[]");
+          }
+        return v0;
       }
-    return v0;
-  }
 
 AGRect2 AGRect2::shrink(float f) const
 {
@@ -1608,18 +1614,18 @@
   return AGRect2(v0-v,v1-v);
 }
 AGRect2 &AGRect2::operator+=(const AGVector2 &v)
-  {
-    v0+=v;
-    v1+=v;
-    return *this;
-  }
+      {
+        v0+=v;
+        v1+=v;
+        return *this;
+      }
 
 AGRect2 &AGRect2::operator-=(const AGVector2 &v)
-  {
-    v0-=v;
-    v1-=v;
-    return *this;
-  }
+      {
+        v0-=v;
+        v1-=v;
+        return *this;
+      }
 
 float AGRect2::x() const
 {
@@ -1658,22 +1664,22 @@
 
 AGLine2::AGLine2(const AGVector2 &pv0,const AGVector2 &pv1):
   v0(pv0),v1(pv1)
-    {
-    }
+        {
+        }
 
 AGVector2 &AGLine2::operator[](size_t i)
-  {
-    switch(i)
       {
-    case 0:
-      return v0;
-    case 1:
-      return v1;
-    default:
-      throw AGString("wrong index in AGLine::op[]");
+        switch(i)
+          {
+        case 0:
+          return v0;
+        case 1:
+          return v1;
+        default:
+          throw AGString("wrong index in AGLine::op[]");
+          }
+        return v0;
       }
-    return v0;
-  }
 AGVector2 AGLine2::operator[](size_t i) const
 {
   switch(i)
@@ -1836,8 +1842,8 @@
 
 AGLine3::AGLine3(const AGVector3 &pv0,const AGVector3 &pv1):
   v0(pv0),v1(pv1)
-    {
-    }
+        {
+        }
 
 float AGLine3::distance(const AGVector3 &p) const
 {
@@ -1982,21 +1988,21 @@
       v[3]+p.v[3]);
 }
 AGVector4 &AGVector4::operator+=(const AGVector4 &p)
-  {
-    v[0]+=p.v[0];
-    v[1]+=p.v[1];
-    v[2]+=p.v[2];
-    v[3]+=p.v[3];
-    return *this;
-  }
+      {
+        v[0]+=p.v[0];
+        v[1]+=p.v[1];
+        v[2]+=p.v[2];
+        v[3]+=p.v[3];
+        return *this;
+      }
 AGVector4 &AGVector4::operator-=(const AGVector4 &p)
-  {
-    v[0]-=p.v[0];
-    v[1]-=p.v[1];
-    v[2]-=p.v[2];
-    v[3]-=p.v[3];
-    return *this;
-  }
+      {
+        v[0]-=p.v[0];
+        v[1]-=p.v[1];
+        v[2]-=p.v[2];
+        v[3]-=p.v[3];
+        return *this;
+      }
 
 float AGVector4::operator*(const AGVector4 &p) const
 {
@@ -2006,21 +2012,21 @@
   v[3]*p.v[3];
 }
 AGVector4 &AGVector4::operator*=(float f)
-  {
-    v[0]*=f;
-    v[1]*=f;
-    v[2]*=f;
-    v[3]*=f;
-    return *this;
-  }
+      {
+        v[0]*=f;
+        v[1]*=f;
+        v[2]*=f;
+        v[3]*=f;
+        return *this;
+      }
 AGVector4 &AGVector4::operator/=(float f)
-  {
-    v[0]/=f;
-    v[1]/=f;
-    v[2]/=f;
-    v[3]/=f;
-    return *this;
-  }
+      {
+        v[0]/=f;
+        v[1]/=f;
+        v[2]/=f;
+        v[3]/=f;
+        return *this;
+      }
 AGVector4 AGVector4::operator*(float f) const
 {
   return AGVector4(v[0]*f,v[1]*f,v[2]*f,v[3]*f);
@@ -2078,10 +2084,10 @@
   }
 
 float &AGVector4::operator[](int index)
-  {
-    assert(index>=0 && index<4);
-    return v[index];
-  }
+      {
+        assert(index>=0 && index<4);
+        return v[index];
+      }
 
 float AGVector4::operator[](int index) const
 {
@@ -2105,9 +2111,9 @@
 }
 
 (AGVector4::operator float*)()
-  {
-    return v;
-  }
+      {
+        return v;
+      }
 
 (AGVector4::operator const float*)() const
 {
@@ -2193,12 +2199,12 @@
   }
 
 AGMatrix4 &AGMatrix4::operator+=(const AGMatrix4 &m)
-  {
-    for(size_t x=0;x<4;x++)
-      for(size_t y=0;y<4;y++)
-        get(x,y)+=m.get(x,y);
-    return *this;
-  }
+      {
+        for(size_t x=0;x<4;x++)
+          for(size_t y=0;y<4;y++)
+            get(x,y)+=m.get(x,y);
+        return *this;
+      }
 
 AGMatrix4 AGMatrix4::transposed() const
 {
@@ -2295,10 +2301,10 @@
   return n;
 }
 AGMatrix4 &AGMatrix4::operator*=(const AGMatrix4 &m)
-  {
-    *this=(*this)*m;
-    return *this;
-  }
+      {
+        *this=(*this)*m;
+        return *this;
+      }
 
 AGVector4 AGMatrix4::operator*(const AGVector4 &v) const
 {
@@ -2319,9 +2325,9 @@
 }
 
 (AGMatrix4::operator float*)()
-  {
-    return a;
-  }
+      {
+        return a;
+      }
 
 (AGMatrix4::operator const float*)() const
 {
@@ -2342,9 +2348,9 @@
   return get(x,y);
 }
 float &AGMatrix4::operator()(size_t x,size_t y)
-  {
-    return get(x,y);
-  }
+      {
+        return get(x,y);
+      }
 
 AGVector4 AGMatrix4::getRow(size_t i) const
 {
@@ -2354,12 +2360,12 @@
 
 
 AGMatrix4::MRow AGMatrix4::operator[](size_t y)
-  {
-    MRow r;
-    r.matrix=this;
-    r.y=y;
-    return r;
-  }
+      {
+        MRow r;
+        r.matrix=this;
+        r.y=y;
+        return r;
+      }
 /*
 const AGMatrix4::Row AGMatrix4::operator[](size_t y) const
 {
@@ -2376,23 +2382,23 @@
 
 AGBox3::AGBox3(const AGVector3 &pBase,const AGVector3 &pDir):
   base(pBase),dir(pDir)
-    {
-      // assert that pDir[i]>0
-      for(size_t i=0;i<3;i++)
-        if(dir[i]<0)
-          {
-            base[i]+=dir[i];
-            dir[i]=-dir[i];
-          }
-      mValid=true;
-    }
+        {
+          // assert that pDir[i]>0
+          for(size_t i=0;i<3;i++)
+            if(dir[i]<0)
+              {
+                base[i]+=dir[i];
+                dir[i]=-dir[i];
+              }
+          mValid=true;
+        }
 
 
 
 AGBox3::AGBox3():base(AGVector3(0,0,0)),dir(AGVector3(0,0,0))
-  {
-    mValid=false;
-  }
+      {
+        mValid=false;
+      }
 
 bool AGBox3::valid() const
 {
@@ -2585,15 +2591,15 @@
 
 AGRect3::AGRect3(const AGVector3 &pBase,const AGVector3 &pDir):
   base(pBase),dir(pDir)
-    {
-      // assert that dir[i]>=0
-      for(size_t i=0;i<3;i++)
-        if(dir[i]<0)
-          {
-            base[i]+=dir[i];
-            dir[i]=-dir[i];
-          }
-    }
+        {
+          // assert that dir[i]>=0
+          for(size_t i=0;i<3;i++)
+            if(dir[i]<0)
+              {
+                base[i]+=dir[i];
+                dir[i]=-dir[i];
+              }
+        }
 
 bool AGRect3::collides(const AGLine3&pLine) const
 {
@@ -2679,3 +2685,23 @@
     o<<"("<<v.base<<" "<<v.dir<<"/"<<v.valid()<<")";
     return o;
   }
+
+std::ostream &operator<<(std::ostream &o,const AGMatrix3&v)
+  {
+    o<<"(";
+    o<<"("<<v.get(0,0)<<";"<<v.get(1,0)<<";"<<v.get(2,0)<<"),";
+    o<<"("<<v.get(0,1)<<";"<<v.get(1,1)<<";"<<v.get(2,1)<<"),";
+    o<<"("<<v.get(0,2)<<";"<<v.get(1,2)<<";"<<v.get(2,2)<<"),";
+    o<<")";
+    return o;
+  }
+std::ostream &operator<<(std::ostream &o,const AGMatrix4&v)
+  {
+    o<<"(";
+    o<<"("<<v.get(0,0)<<";"<<v.get(1,0)<<";"<<v.get(2,0)<<v.get(3,0)<<"),";
+    o<<"("<<v.get(0,1)<<";"<<v.get(1,1)<<";"<<v.get(2,1)<<v.get(3,1)<<"),";
+    o<<"("<<v.get(0,2)<<";"<<v.get(1,2)<<";"<<v.get(2,2)<<v.get(3,2)<<"),";
+    o<<"("<<v.get(0,3)<<";"<<v.get(1,3)<<";"<<v.get(2,3)<<v.get(3,3)<<"),";
+    o<<")";
+    return o;
+  }

Modified: antargis/trunk/ext/basic/ag_geometry.h
===================================================================
--- antargis/trunk/ext/basic/ag_geometry.h	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/basic/ag_geometry.h	2008-06-05 19:24:45 UTC (rev 1263)
@@ -29,6 +29,7 @@
 #include <vector>
 #include <ag_base.h>
 #include <ag_string.h>
+#include <stdexcept>
 
 /* There are following classes:
 
@@ -61,154 +62,171 @@
     explicit AGAngle(float a);
   };
 
+class GeometryException
+  {
+    public:
+      GeometryException(const std::string &p):s(p)
+    {}
+#ifdef SWIG
+      %rename(to_s) what() const;
+#endif
+      std::string what() const
+      {
+        return s;
+      }
+      
+    private:
+      std::string s;
+  };
+
 class AGEXPORT AGVector2
   {
-public:
-  float v[2];
+  public:
+    float v[2];
 
-  AGVector2(const AGString &s);
-  AGVector2(float pX,float pY);
-  AGVector2(const AGAngle &a);
-  AGVector2(const AGVector2 &a);
-  AGVector2();
+    AGVector2(const AGString &s);
+    AGVector2(float pX,float pY);
+    AGVector2(const AGAngle &a);
+    AGVector2(const AGVector2 &a);
+    AGVector2();
 
-  void setX(float pX);
-  void setY(float pY);
+    void setX(float pX);
+    void setY(float pY);
 
-  AGVector2 dim2() const;
+    AGVector2 dim2() const;
 
 
 #ifdef SWIG
-  %rename(x) getX() const;
-  %rename(y) getY() const;
+    %rename(x) getX() const;
+    %rename(y) getY() const;
 #endif
-  float getX() const;
-  float getY() const;
+    float getX() const;
+    float getY() const;
 
-  AGAngle getAngle() const;
+    AGAngle getAngle() const;
 
 
-  bool operator<(const AGVector2 &p) const;
+    bool operator<(const AGVector2 &p) const;
 
-  AGVector2 operator-() const;
-  AGVector2 operator-(const AGVector2 &p) const;
-  AGVector2 operator+(const AGVector2 &p) const;
-  AGVector2 &operator+=(const AGVector2 &p);
-  AGVector2 &operator-=(const AGVector2 &p);
+    AGVector2 operator-() const;
+    AGVector2 operator-(const AGVector2 &p) const;
+    AGVector2 operator+(const AGVector2 &p) const;
+    AGVector2 &operator+=(const AGVector2 &p);
+    AGVector2 &operator-=(const AGVector2 &p);
 
-  float operator*(const AGVector2 &p) const;
-  AGVector2 &operator*=(float f);
-  AGVector2 &operator/=(float f);
-  AGVector2 operator*(float f) const;
-  AGVector2 operator/(float f) const;
+    float operator*(const AGVector2 &p) const;
+    AGVector2 &operator*=(float f);
+    AGVector2 &operator/=(float f);
+    AGVector2 operator*(float f) const;
+    AGVector2 operator/(float f) const;
 
-  bool operator==(const AGVector2 &a) const;
-  bool operator!=(const AGVector2 &a) const;
+    bool operator==(const AGVector2 &a) const;
+    bool operator!=(const AGVector2 &a) const;
 
-  float length() const;
-  float length2() const;
+    float length() const;
+    float length2() const;
 
-  AGVector2 normalized() const;
-  void normalize();
+    AGVector2 normalized() const;
+    void normalize();
 
-  AGVector2 normal() const;
+    AGVector2 normal() const;
 
 #ifdef SWIG
-  %rename(__getitem__) operator[](int index) const;
+    %rename(__getitem__) operator[](int index) const;
 #endif
-  float operator[](int index) const;
-  float &operator[](int index);
+    float operator[](int index) const;
+    float &operator[](int index);
 
-  bool nonZero() const;
+    bool nonZero() const;
 
-  void saveXML(Node &node) const;
-  void loadXML(const Node &node);
+    void saveXML(Node &node) const;
+    void loadXML(const Node &node);
 
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
 
 #ifndef SWIG
-  (operator float*)();
-  (operator const float*)() const;
+    (operator float*)();
+    (operator const float*)() const;
 #endif
   };
 
 // 2-dim homogenous vector
 class AGEXPORT AGVector3
   {
-public:
-  float v[3];
+  public:
+    float v[3];
 
-  AGVector3(const AGVector2 &p,float h=1.0f);
-  AGVector3(float pX,float pY,float pZ=0.0f);
-  AGVector3(const AGAngle &a);
-  AGVector3(const AGVector3 &a);
-  AGVector3();
+    AGVector3(const AGVector2 &p,float h=1.0f);
+    AGVector3(float pX,float pY,float pZ=0.0f);
+    AGVector3(const AGAngle &a);
+    AGVector3(const AGVector3 &a);
+    AGVector3();
 
-  void setX(float pX);
-  void setY(float pY);
-  void setZ(float pZ);
+    void setX(float pX);
+    void setY(float pY);
+    void setZ(float pZ);
 
 
 #ifdef SWIG
-  %rename(x) getX() const;
-  %rename(y) getY() const;
-  %rename(z) getZ() const;
+    %rename(x) getX() const;
+    %rename(y) getY() const;
+    %rename(z) getZ() const;
 #endif
-  float getX() const;
-  float getY() const;
-  float getZ() const;
+    float getX() const;
+    float getY() const;
+    float getZ() const;
 
-  AGAngle getAngle() const;
+    AGAngle getAngle() const;
 
-  AGVector3 operator-() const;
+    AGVector3 operator-() const;
 
-  AGVector3 operator-(const AGVector3 &p) const;
-  AGVector3 operator+(const AGVector3 &p) const;
+    AGVector3 operator-(const AGVector3 &p) const;
+    AGVector3 operator+(const AGVector3 &p) const;
 #ifdef SWIG
-  %rename(add) operator+=(const AGVector3 &p);
-  %rename(sub) operator-=(const AGVector3 &p);
+    %rename(add) operator+=(const AGVector3 &p);
+    %rename(sub) operator-=(const AGVector3 &p);
 #endif
-  AGVector3 &operator+=(const AGVector3 &p);
-  AGVector3 &operator-=(const AGVector3 &p);
+    AGVector3 &operator+=(const AGVector3 &p);
+    AGVector3 &operator-=(const AGVector3 &p);
 
-  float operator*(const AGVector3 &p) const;
-  AGVector3 &operator*=(float f);
-  AGVector3 &operator/=(float f);
-  AGVector3 operator*(float f) const;
-  AGVector3 operator/(float f) const;
-  AGVector3 operator%(const AGVector3 &a) const;
+    float operator*(const AGVector3 &p) const;
+    AGVector3 &operator*=(float f);
+    AGVector3 &operator/=(float f);
+    AGVector3 operator*(float f) const;
+    AGVector3 operator/(float f) const;
+    AGVector3 operator%(const AGVector3 &a) const;
 
-  bool operator==(const AGVector3 &a) const;
-  bool operator!=(const AGVector3 &a) const;
+    bool operator==(const AGVector3 &a) const;
+    bool operator!=(const AGVector3 &a) const;
 
-  float length() const;
-  float length2() const;
+    float length() const;
+    float length2() const;
 
-  AGVector3 normalized() const;
-  void normalize();
+    AGVector3 normalized() const;
+    void normalize();
 
-  AGVector3 normal() const;
+    AGVector3 normal() const;
 
-  float operator[](int index) const;
-  float &operator[](int index);
+    float operator[](int index) const;
+    float &operator[](int index);
 
-  bool nonZero() const;
+    bool nonZero() const;
 
-  void saveXML(Node &node) const;
-  void loadXML(const Node &node);
+    void saveXML(Node &node) const;
+    void loadXML(const Node &node);
 
-  AGVector2 dim2() const;
+    AGVector2 dim2() const;
 
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
 
 #ifndef SWIG
-  (operator float*)();
+    (operator float*)();
 #endif
   };
 
@@ -216,120 +234,120 @@
 class AGEXPORT AGMatrix3
   {
     float a[3][3];
-public:
-  struct Row
-    {
-      AGMatrix3 *matrix;
-      int y;
-
-      float &operator[](size_t x)
+  public:
+    struct Row
       {
-        return matrix->get(x,y);
-      }
-      float operator[](size_t x) const
-      {
-        return matrix->get(x,y);
-      }
-    };
+        AGMatrix3 *matrix;
+        int y;
 
-  AGMatrix3();
-  AGMatrix3(const AGAngle &a); // rotate
-  AGMatrix3(const AGVector3 &a); // transpose
-  AGMatrix3(float x,float y); // scale
-  AGMatrix3(const AGMatrix3 &m);
-  void set(size_t x,size_t y,float f);
-  float get(size_t x,size_t y) const;
-  float &get(size_t x,size_t y);
+        float &operator[](size_t x)
+        {
+          return matrix->get(x,y);
+        }
+        float operator[](size_t x) const
+        {
+          return matrix->get(x,y);
+        }
+      };
 
-  AGMatrix3 operator*(const AGMatrix3 &m) const;
-  AGMatrix3 &operator*=(const AGMatrix3 &m);
+    AGMatrix3();
+    AGMatrix3(const AGAngle &a); // rotate
+    AGMatrix3(const AGVector3 &a); // transpose
+    AGMatrix3(float x,float y); // scale
+    AGMatrix3(const AGMatrix3 &m);
+    void set(size_t x,size_t y,float f);
+    float get(size_t x,size_t y) const;
+    float &get(size_t x,size_t y);
 
-  AGVector3 operator*(const AGVector3 &v) const;
-  //  AGVector2 operator*(const AGVector2 &v) const;
+    AGMatrix3 operator*(const AGMatrix3 &m) const;
+    AGMatrix3 &operator*=(const AGMatrix3 &m);
 
-  AGMatrix3 operator-() const;
+    AGVector3 operator*(const AGVector3 &v) const;
+    //  AGVector2 operator*(const AGVector2 &v) const;
 
-  AGMatrix3 inverted() const;
-  AGMatrix3 transposed() const;
+    AGMatrix3 operator-() const;
 
-  Row operator[](size_t y);
-  const Row operator[](size_t y) const;
+    AGMatrix3 inverted() const throw (GeometryException);
+    AGMatrix3 transposed() const;
 
-  void swapRows(size_t a,size_t b);
-  void swapCols(size_t a,size_t b);
-  
-  bool operator==(const AGMatrix3&p) const;
+    Row operator[](size_t y);
+    const Row operator[](size_t y) const;
 
+    void swapRows(size_t a,size_t b);
+    void swapCols(size_t a,size_t b);
 
+    bool operator==(const AGMatrix3&p) const;
+
+
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
   };
 
 class AGEXPORT AGLine2
   {
     AGVector2 v0,v1;
-public:
-  AGLine2();
-  AGLine2(const AGVector2 &pv0,const AGVector2 &pv1);
+  public:
+    AGLine2();
+    AGLine2(const AGVector2 &pv0,const AGVector2 &pv1);
 
-  AGVector2 getV0() const;
-  AGVector2 getV1() const;
+    AGVector2 getV0() const;
+    AGVector2 getV1() const;
 
-  bool has(const AGVector2 &v) const;
+    bool has(const AGVector2 &v) const;
 
-  bool collide(const AGLine2 &l) const;
-  AGVector2 collisionPoint(const AGLine2 &l) const;
-  AGVector2 collisionPointNI(const AGLine2 &l) const; // no inclusion test
-  bool includes(const AGVector2 &v) const;
+    bool collide(const AGLine2 &l) const;
+    AGVector2 collisionPoint(const AGLine2 &l) const;
+    AGVector2 collisionPointNI(const AGLine2 &l) const; // no inclusion test
+    bool includes(const AGVector2 &v) const;
 
-  AGRect2 getBBox() const;
+    AGRect2 getBBox() const;
 
-  AGVector2 normal() const;
-  AGVector2 direction() const;
+    AGVector2 normal() const;
+    AGVector2 direction() const;
 
-  float distance(const AGVector2 &v) const;
+    float distance(const AGVector2 &v) const;
 
-  AGVector2 &operator[](size_t i);
-  AGVector2 operator[](size_t i) const;
+    AGVector2 &operator[](size_t i);
+    AGVector2 operator[](size_t i) const;
 
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
   };
 
 class AGEXPORT AGLine3
   {
     AGVector3 v0,v1;
-public:
-  AGLine3();
-  AGLine3(const AGVector3 &pv0,const AGVector3 &pv1);
+  public:
+    AGLine3();
+    AGLine3(const AGVector3 &pv0,const AGVector3 &pv1);
 
-  AGVector3 getV0() const;
-  AGVector3 getV1() const;
+    AGVector3 getV0() const;
+    AGVector3 getV1() const;
 
-  bool has(const AGVector3 &v) const;
-  /*
+    bool has(const AGVector3 &v) const;
+    /*
   bool collide(const AGLine3 &l) const;
   AGVector3 collisionPoint(const AGLine3 &l) const;
   AGVector3 collisionPointNI(const AGLine3 &l) const; // no inclusion test
   bool includes(const AGVector3 &v) const;
-   */
-  //  AGBox3 getBBox() const;
+     */
+    //  AGBox3 getBBox() const;
 
-  //  AGVector3 normal() const;
-  AGVector3 direction() const;
+    //  AGVector3 normal() const;
+    AGVector3 direction() const;
 
-  float distance(const AGVector3 &p) const;
+    float distance(const AGVector3 &p) const;
 
-  //  float distance(const AGVector3 &v) const;
+    //  float distance(const AGVector3 &v) const;
 
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
   };
 
 class AGEXPORT AGCollisionData
@@ -341,368 +359,368 @@
 class AGEXPORT AGTriangle2
   {
     AGVector2 p[3];
-public:
-  AGTriangle2();
-  AGTriangle2(const AGVector2 &v0,const AGVector2 &v1,const AGVector2 &v2);
+  public:
+    AGTriangle2();
+    AGTriangle2(const AGVector2 &v0,const AGVector2 &v1,const AGVector2 &v2);
 
-  AGVector2 operator[](int index) const;
+    AGVector2 operator[](int index) const;
 
-  AGVector2 get(int index) const;
+    AGVector2 get(int index) const;
 
-  bool collide(const AGTriangle2 &t) const;
+    bool collide(const AGTriangle2 &t) const;
 
-  // FIXME: sweep-based test
-  //  AGCollisionData collide(const AGTriangle &t,const AGVector &v0,const AGVector &v1) const;
+    // FIXME: sweep-based test
+    //  AGCollisionData collide(const AGTriangle &t,const AGVector &v0,const AGVector &v1) const;
 
-  std::vector<AGVector2> getNormals() const;
+    std::vector<AGVector2> getNormals() const;
 
-  void apply(const AGMatrix3 &m);
-  AGTriangle2 applied(const AGMatrix3 &m) const;
+    void apply(const AGMatrix3 &m);
+    AGTriangle2 applied(const AGMatrix3 &m) const;
 
-  // estimate touching point (or middle of touching area)
-  AGVector2 touchPoint(const AGTriangle2 &t) const;
-  AGVector2 touchVector(const AGTriangle2 &t) const;
+    // estimate touching point (or middle of touching area)
+    AGVector2 touchPoint(const AGTriangle2 &t) const;
+    AGVector2 touchVector(const AGTriangle2 &t) const;
 
-  std::vector<AGVector2> collisionPoints(const AGLine2 &l) const;
+    std::vector<AGVector2> collisionPoints(const AGLine2 &l) const;
 
-  bool contains(const AGVector2 &p) const;
+    bool contains(const AGVector2 &p) const;
 
-  AGRect2 getBBox() const;
+    AGRect2 getBBox() const;
 
-  AGLine2 nearestLine(const AGVector2 &v) const;
+    AGLine2 nearestLine(const AGVector2 &v) const;
 
-  std::vector<AGLine2> getLines() const;
+    std::vector<AGLine2> getLines() const;
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
   };
 
 class AGEXPORT AGCircle2
   {
     AGVector2 p;
     float radius;
-public:
-  AGCircle2(const AGVector2 &v,float rad);
+  public:
+    AGCircle2(const AGVector2 &v,float rad);
 
-  bool inCircle(const AGTriangle2 &t) const;
-  bool outCircle(const AGTriangle2 &t) const;
-  bool inCircle(const AGVector2 &v) const;
-  bool outCircle(const AGVector2 &v) const;
+    bool inCircle(const AGTriangle2 &t) const;
+    bool outCircle(const AGTriangle2 &t) const;
+    bool inCircle(const AGVector2 &v) const;
+    bool outCircle(const AGVector2 &v) const;
 
-  AGVector2 getPos() const;
-  float getRadius() const;
+    AGVector2 getPos() const;
+    float getRadius() const;
 
-  std::list<AGVector2> collide(const AGLine2 &pLine) const;
+    std::list<AGVector2> collide(const AGLine2 &pLine) const;
   };
 
 class AGVector4;
 class AGEXPORT AGTriangle3
   {
     AGVector3 p[3];
-public:
-  AGTriangle3(const AGVector3 &v0,const AGVector3 &v1,const AGVector3 &v2);
+  public:
+    AGTriangle3(const AGVector3 &v0,const AGVector3 &v1,const AGVector3 &v2);
 
-  // (x,y,z,0) for no collision 
-  // (x,y,z,1) for collision in point (x,y,z)
-  AGVector4 collide(const AGLine3 &pLine) const;
+    // (x,y,z,0) for no collision 
+    // (x,y,z,1) for collision in point (x,y,z)
+    AGVector4 collide(const AGLine3 &pLine) const;
 
-  AGString toString() const;
+    AGString toString() const;
 
-  AGVector3 operator[](int index) const;
+    AGVector3 operator[](int index) const;
   };
 
 class AGEXPORT AGRect2
   {
     AGVector2 v0,v1;
-public:
-  AGRect2();
-  AGRect2(const AGVector2 &pv0,const AGVector2 &pv1);
-  AGRect2(float x,float y,float w,float h);
-  AGRect2(const AGString &ps);
-  AGRect2(const SDL_Rect &r);
+  public:
+    AGRect2();
+    AGRect2(const AGVector2 &pv0,const AGVector2 &pv1);
+    AGRect2(float x,float y,float w,float h);
+    AGRect2(const AGString &ps);
+    AGRect2(const SDL_Rect &r);
 
-  bool collide(const AGRect2 &r) const;
+    bool collide(const AGRect2 &r) const;
 
-  void include(const AGVector2 &v);
+    void include(const AGVector2 &v);
 
-  AGRect2 operator+(const AGVector2 &v) const;
-  AGRect2 operator-(const AGVector2 &v) const;
-  AGRect2 &operator+=(const AGVector2 &v);
-  AGRect2 &operator-=(const AGVector2 &v);
+    AGRect2 operator+(const AGVector2 &v) const;
+    AGRect2 operator-(const AGVector2 &v) const;
+    AGRect2 &operator+=(const AGVector2 &v);
+    AGRect2 &operator-=(const AGVector2 &v);
 
-  AGRect2& operator+=(const AGRect2 &r);
+    AGRect2& operator+=(const AGRect2 &r);
 
-  bool contains(const AGVector2 &v) const;
-  bool contains(const AGRect2 &v) const;
+    bool contains(const AGVector2 &v) const;
+    bool contains(const AGRect2 &v) const;
 
-  std::list<AGRect2> split() const;
+    std::list<AGRect2> split() const;
 
-  AGVector2 operator[](size_t i) const;
-  AGVector2 &operator[](size_t i);
+    AGVector2 operator[](size_t i) const;
+    AGVector2 &operator[](size_t i);
 
-  AGVector2 getV0() const;
-  AGVector2 getV1() const;
-  AGVector2 getV01() const;
-  AGVector2 getV10() const;
+    AGVector2 getV0() const;
+    AGVector2 getV1() const;
+    AGVector2 getV01() const;
+    AGVector2 getV10() const;
 
-  AGVector2 getMiddle() const;
+    AGVector2 getMiddle() const;
 
-  AGRect2 shrink(float f) const;
-  AGRect2 shrinkToTopLeft(float w,float h) const;
-  AGRect2 grow(float f) const;
+    AGRect2 shrink(float f) const;
+    AGRect2 shrinkToTopLeft(float w,float h) const;
+    AGRect2 grow(float f) const;
 
-  void setX(float p);
-  void setY(float p);
+    void setX(float p);
+    void setY(float p);
 
-  void setLeft(float p); // attention - modifies right, too
-  void setTop(float p);  // attention - modifies bottom, too
+    void setLeft(float p); // attention - modifies right, too
+    void setTop(float p);  // attention - modifies bottom, too
 
-  void setRight(float p);
-  void setBottom(float p);
+    void setRight(float p);
+    void setBottom(float p);
 
-  float setWidth(float w);
-  float setHeight(float w);
+    float setWidth(float w);
+    float setHeight(float w);
 
-  float x() const;
-  float y() const;
-  float w() const;
-  float h() const;
+    float x() const;
+    float y() const;
+    float w() const;
+    float h() const;
 
-  float width() const;
-  float height() const;
+    float width() const;
+    float height() const;
 
-  float x0() const;
-  float y0() const;
-  float x1() const;
-  float y1() const;
+    float x0() const;
+    float y0() const;
+    float x1() const;
+    float y1() const;
 
-  AGVector2 clip(const AGVector2 &v) const;
+    AGVector2 clip(const AGVector2 &v) const;
 
-  AGRect2 origin() const;
+    AGRect2 origin() const;
 
-  AGRect2 intersect(const AGRect2 &r) const;
+    AGRect2 intersect(const AGRect2 &r) const;
 
-  //result=this-r
-  std::vector<AGRect2> difference(const AGRect2 &r) const;
+    //result=this-r
+    std::vector<AGRect2> difference(const AGRect2 &r) const;
 
-  SDL_Rect sdl() const;
+    SDL_Rect sdl() const;
 
-  bool operator==(const AGRect2 &r) const;
-  bool operator!=(const AGRect2 &r) const;
+    bool operator==(const AGRect2 &r) const;
+    bool operator!=(const AGRect2 &r) const;
 
-  void check() const;
+    void check() const;
 
-  AGRect2 alignGrid() const; // align to integer grid
+    AGRect2 alignGrid() const; // align to integer grid
 
-  float content() const;
+    float content() const;
 
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
   };
 
 
 class AGEXPORT AGVector4
   {
-public:
-  float v[4];
+  public:
+    float v[4];
 
-  AGVector4(float pX,float pY,float pZ,float pW=1.0f);
-  AGVector4(const AGVector4 &a);
-  AGVector4(const AGVector3 &a,float h);
-  AGVector4();
+    AGVector4(float pX,float pY,float pZ,float pW=1.0f);
+    AGVector4(const AGVector4 &a);
+    AGVector4(const AGVector3 &a,float h);
+    AGVector4();
 
-  void setX(float pX);
-  void setY(float pY);
-  void setZ(float pZ);
-  void setW(float pW);
+    void setX(float pX);
+    void setY(float pY);
+    void setZ(float pZ);
+    void setW(float pW);
 
 
 #ifdef SWIG
-  %rename(x) getX() const;
-  %rename(y) getY() const;
-  %rename(z) getZ() const;
-  %rename(w) getW() const;
+    %rename(x) getX() const;
+    %rename(y) getY() const;
+    %rename(z) getZ() const;
+    %rename(w) getW() const;
 #endif
-  float getX() const;
-  float getY() const;
-  float getZ() const;
-  float getW() const;
+    float getX() const;
+    float getY() const;
+    float getZ() const;
+    float getW() const;
 
-  AGVector4 operator-(const AGVector4 &p) const;
-  AGVector4 operator+(const AGVector4 &p) const;
+    AGVector4 operator-(const AGVector4 &p) const;
+    AGVector4 operator+(const AGVector4 &p) const;
 #ifdef SWIG
-  %rename(add) operator+=(const AGVector4 &p);
-  %rename(sub) operator-=(const AGVector4 &p);
+    %rename(add) operator+=(const AGVector4 &p);
+    %rename(sub) operator-=(const AGVector4 &p);
 #endif
-  AGVector4 &operator+=(const AGVector4 &p);
-  AGVector4 &operator-=(const AGVector4 &p);
+    AGVector4 &operator+=(const AGVector4 &p);
+    AGVector4 &operator-=(const AGVector4 &p);
 
-  float operator*(const AGVector4 &p) const;
-  AGVector4 &operator*=(float f);
-  AGVector4 &operator/=(float f);
-  AGVector4 operator*(float f) const;
-  AGVector4 operator/(float f) const;
-  AGVector4 operator-() const;
+    float operator*(const AGVector4 &p) const;
+    AGVector4 &operator*=(float f);
+    AGVector4 &operator/=(float f);
+    AGVector4 operator*(float f) const;
+    AGVector4 operator/(float f) const;
+    AGVector4 operator-() const;
 
-  bool operator==(const AGVector4 &a) const;
-  bool operator!=(const AGVector4 &a) const;
+    bool operator==(const AGVector4 &a) const;
+    bool operator!=(const AGVector4 &a) const;
 
-  float length() const;
-  // length^2
-  float length2() const;
+    float length() const;
+    // length^2
+    float length2() const;
 
-  // length 3-dim vector
-  float length3() const;
+    // length 3-dim vector
+    float length3() const;
 
 
-  AGVector4 normalized() const;
-  void normalize();
+    AGVector4 normalized() const;
+    void normalize();
 
-  // 3-dimensional
-  AGVector4 normalized3() const;
-  void normalize3();
+    // 3-dimensional
+    AGVector4 normalized3() const;
+    void normalize3();
 
 
-  float operator[](int index) const;
-  float &operator[](int index);
+    float operator[](int index) const;
+    float &operator[](int index);
 
-  bool nonZero() const;
+    bool nonZero() const;
 
-  // vector-cross-product
-  // ignores 4th coordinate
-  AGVector4 operator%(const AGVector4 &a) const;
-  AGVector4 cross(const AGVector4 &a) const
-  {
-    return operator%(a);
-  }
+    // vector-cross-product
+    // ignores 4th coordinate
+    AGVector4 operator%(const AGVector4 &a) const;
+    AGVector4 cross(const AGVector4 &a) const
+    {
+      return operator%(a);
+    }
 
 
-  AGVector3 dim3() const;
-  AGVector2 dim2() const;
+    AGVector3 dim3() const;
+    AGVector2 dim2() const;
 
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
 
 #ifndef SWIG
-  (operator float*)();
-  (operator const float*)() const;
+    (operator float*)();
+    (operator const float*)() const;
 #endif
   };
 
 class AGEXPORT AGMatrix4
   {
     float a[16];
-public:
-  struct MRow
-    {
-      AGMatrix4 *matrix;
-      int y;
-
-      float &operator[](size_t x)
+  public:
+    struct MRow
       {
-        return matrix->get(x,y);
-      }
-      float operator[](size_t x) const
-      {
-        return matrix->get(x,y);
-      }
-    };
+        AGMatrix4 *matrix;
+        int y;
 
-  AGMatrix4();
-  AGMatrix4(float v[16]);
-  AGMatrix4(float angle,const AGVector3 &d);
-  AGMatrix4(const AGVector4 &a);
-  void set(size_t x,size_t y,float f);
-  float get(size_t x,size_t y) const;
-  float &get(size_t x,size_t y);
+        float &operator[](size_t x)
+        {
+          return matrix->get(x,y);
+        }
+        float operator[](size_t x) const
+        {
+          return matrix->get(x,y);
+        }
+      };
 
-  AGMatrix4 operator*(const AGMatrix4 &m) const;
-  AGMatrix4 &operator*=(const AGMatrix4 &m);
-  AGMatrix4 &operator+=(const AGMatrix4 &m);
+    AGMatrix4();
+    AGMatrix4(float v[16]);
+    AGMatrix4(float angle,const AGVector3 &d);
+    AGMatrix4(const AGVector4 &a);
+    void set(size_t x,size_t y,float f);
+    float get(size_t x,size_t y) const;
+    float &get(size_t x,size_t y);
 
-  AGMatrix3 get3x3(size_t x,size_t y) const;
+    AGMatrix4 operator*(const AGMatrix4 &m) const;
+    AGMatrix4 &operator*=(const AGMatrix4 &m);
+    AGMatrix4 &operator+=(const AGMatrix4 &m);
 
-  AGVector4 operator*(const AGVector4 &v) const;
+    AGMatrix3 get3x3(size_t x,size_t y) const;
 
-  float operator()(size_t x,size_t y) const;
-  float &operator()(size_t x,size_t y);
+    AGVector4 operator*(const AGVector4 &v) const;
 
-  AGMatrix4 inverted() const;
-  AGMatrix4 transposed() const;
+    float operator()(size_t x,size_t y) const;
+    float &operator()(size_t x,size_t y);
 
-  MRow operator[](size_t y);
-  //  const Row operator[](size_t y) const;
+    AGMatrix4 inverted() const;
+    AGMatrix4 transposed() const;
 
-  void swapRows(size_t a,size_t b);
-  void swapCols(size_t a,size_t b);
+    MRow operator[](size_t y);
+    //  const Row operator[](size_t y) const;
 
+    void swapRows(size_t a,size_t b);
+    void swapCols(size_t a,size_t b);
+
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
 
 #ifndef SWIG
-  (operator float*)();
-  (operator const float*)() const;
-  //  (operator const double*)() const;
+    (operator float*)();
+    (operator const float*)() const;
+    //  (operator const double*)() const;
 #endif
 
-  AGVector4 getRow(size_t i) const;
+    AGVector4 getRow(size_t i) const;
   };
 
 // axis-aligned
 class AGEXPORT AGRect3
   {
     AGVector3 base,dir;
-public:
-  AGRect3(const AGVector3 &pBase,const AGVector3 &pDir);
+  public:
+    AGRect3(const AGVector3 &pBase,const AGVector3 &pDir);
 
-  bool collides(const AGLine3&pLine) const;
+    bool collides(const AGLine3&pLine) const;
 
-  AGString toString() const;
+    AGString toString() const;
   };
 
 // axis-aligned
 class AGEXPORT AGBox3
   {
-public:
-  AGVector3 base,dir;
+  public:
+    AGVector3 base,dir;
 
-  AGBox3();
-  AGBox3(const AGVector3 &pBase,const AGVector3 &pDir);
+    AGBox3();
+    AGBox3(const AGVector3 &pBase,const AGVector3 &pDir);
 
-  void include(const AGVector3&p);
-  bool includes(const AGBox3 &b);
-  bool collides(const AGVector3&p) const;
+    void include(const AGVector3&p);
+    bool includes(const AGBox3 &b);
+    bool collides(const AGVector3&p) const;
 
-  bool collides(const AGLine3&p) const;
-  bool collides(const AGBox3 &b) const;
+    bool collides(const AGLine3&p) const;
+    bool collides(const AGBox3 &b) const;
 
-  bool contains(const AGTriangle3 &t) const;
+    bool contains(const AGTriangle3 &t) const;
 
-  std::vector<AGRect3> getSides() const;
+    std::vector<AGRect3> getSides() const;
 
-  AGString toString() const;
+    AGString toString() const;
 
-  std::vector<AGBox3> split() const;
+    std::vector<AGBox3> split() const;
 
-  bool collides(const AGMatrix4 &frustum) const;
+    bool collides(const AGMatrix4 &frustum) const;
 
-  std::vector<AGVector3> getVertices() const;
-  void calcVertices(std::vector<AGVector3> &vs) const;
+    std::vector<AGVector3> getVertices() const;
+    void calcVertices(std::vector<AGVector3> &vs) const;
 
-  AGBox3 operator+(const AGVector3 &v) const;
-  AGBox3 operator-(const AGVector3 &v) const;
+    AGBox3 operator+(const AGVector3 &v) const;
+    AGBox3 operator-(const AGVector3 &v) const;
 
-  bool valid() const;
+    bool valid() const;
 
-private:
-  bool mValid;
+  private:
+    bool mValid;
   };
 
 #ifndef SWIG
@@ -711,6 +729,9 @@
 AGEXPORT std::ostream &operator<<(std::ostream &o,const AGVector4&v);
 AGEXPORT std::ostream &operator<<(std::ostream &o,const AGRect2&v);
 AGEXPORT std::ostream &operator<<(std::ostream &o,const AGBox3&v);
+
+AGEXPORT std::ostream &operator<<(std::ostream &o,const AGMatrix3&v);
+AGEXPORT std::ostream &operator<<(std::ostream &o,const AGMatrix4&v);
 #endif
 
 #include "ag_geometry_inline.cc"

Modified: antargis/trunk/ext/basic/ag_messageobject.cc
===================================================================
--- antargis/trunk/ext/basic/ag_messageobject.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/basic/ag_messageobject.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -29,6 +29,7 @@
 AGEvent::AGEvent(AGListener *pCaller,const AGString &pName,const SDL_Event &e):mCaller(pCaller),mName(pName),mEvent(e),
   mMousePosition(0),mRelMousePosition(0)
   {
+    mClipped=false;
   }
 AGEvent::~AGEvent()
   {
@@ -38,7 +39,23 @@
       delete mRelMousePosition;
   }
 
+bool AGEvent::isMouseEvent() const
+{
+  return (mEvent.type==SDL_MOUSEMOTION||mEvent.type==SDL_MOUSEBUTTONUP||mEvent.type==SDL_MOUSEBUTTONDOWN);
+}
 
+
+bool AGEvent::isClipped() const
+{
+  return mClipped; 
+}
+void AGEvent::setClipped(bool f)
+  {
+    mClipped=f;
+  }
+
+
+
 void AGEvent::setVector(const AGVector2 &v)
   {
     mVector=v;

Modified: antargis/trunk/ext/basic/ag_messageobject.h
===================================================================
--- antargis/trunk/ext/basic/ag_messageobject.h	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/basic/ag_messageobject.h	2008-06-05 19:24:45 UTC (rev 1263)
@@ -85,7 +85,12 @@
 
   void setVector(const AGVector2 &v);
   AGVector2 getVector() const;
+  
+  bool isClipped() const;
+  void setClipped(bool f);
 
+  bool isMouseEvent() const;
+  
  private:
   AGListener *mCaller;
   AGString mName;
@@ -95,6 +100,8 @@
   AGVector2 mVector;
   AGVector2 *mMousePosition;
   AGVector2 *mRelMousePosition;
+  
+  bool mClipped;
 
  protected:
   static SDL_Event NullEvent;
@@ -166,8 +173,6 @@
 class AGEXPORT AGSignal
 {
  public:
-  //AGSignal();
-  //AGSignal(AGMessageObject *pCaller);
   AGSignal(AGMessageObject *pCaller,const AGString &pName);
 
   virtual ~AGSignal();

Modified: antargis/trunk/ext/gui/ag_button.cc
===================================================================
--- antargis/trunk/ext/gui/ag_button.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/gui/ag_button.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -114,7 +114,6 @@
 void AGButton::draw(AGPainter &p)
   {
     assert(mTextW);
-//    cdebug(mTextW->getText());
     p.pushMatrix();
     p.transform(AGRect2(0,0,width(),height()).shrink(borderWidth));
     AGRect2 pr=getRect().origin();

Modified: antargis/trunk/ext/gui/ag_widget.cc
===================================================================
--- antargis/trunk/ext/gui/ag_widget.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/gui/ag_widget.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -34,7 +34,9 @@
 #include "ag_config.h"
 #include "ag_clip.h"
 #include "ag_painter.h"
+#include "ag_algebra.h" // FIXME: remove this ASAP
 
+
 #define FOCUS_BY_SORT
 
 
@@ -166,7 +168,9 @@
       {
         p.pushMatrix();
 
-        p.transform(getRect());
+        p.clip(getRect());
+        //p.transform(getRect());
+        p.transform(innerToOuter().getMatrix());
 
         if(!mChildrenDrawFirst)
           draw(p);
@@ -187,7 +191,7 @@
   }
 
 void AGWidget::drawChild(AGPainter &p,AGWidget *pWidget)
-  {
+  {/*
     if(mUseClientRect)
       {
         p.pushMatrix();
@@ -195,8 +199,8 @@
         pWidget->drawAll(p);
         p.popMatrix();
       }
-    else
-      pWidget->drawAll(p);
+    else*/
+    pWidget->drawAll(p);
   }
 
 AGProjection2D AGWidget::getClientProjection() const
@@ -226,6 +230,7 @@
   {
     mClientWorld=pWorld;
     mClientProj=pProjection;
+    assert(isInvertable(mClientProj.getMatrix()));
     mUseClientRect=true;
   }
 
@@ -265,14 +270,21 @@
   {
     bool retValue;
     AGVector2 old=event->getRelMousePosition();
-    AGVector2 newP;
+    AGVector2 newP=outerToInner().project(old);
+    /*
     if(mUseClientRect)
-      newP=mClientProj.inverse().project(old);
+      newP=mClientProj.inverse().project(old-mRect.getV0()); //FIXME - mRect must influence this, too (????)
     else
       newP=old-getRect().getV0();
+     */
     event->setRelMousePosition(newP);
+    bool wasClipped=event->isClipped();
+    
+    event->setClipped(wasClipped || (!getRect().contains(old)));
 
     retValue=pChild->processEvent(event);
+    
+    event->setClipped(wasClipped);
     event->setRelMousePosition(old);
 
     return retValue;
@@ -321,7 +333,8 @@
 
     if(e->isSDLEvent())
       {
-        if(getRect().contains(e->getRelMousePosition()))
+        //cdebug(e->isFocusTaken()<<"::"<<getName());
+        if(getRect().contains(e->getRelMousePosition()) && !e->isClipped())
           {
             if(!mMouseIn)
               {
@@ -639,21 +652,57 @@
   return getScreenRect().getV0();
 }
 
-
+/**
+ * returns the extends of this widget wrt. to the screen-coordinates
+ */
 AGRect2 AGWidget::getScreenRect() const
 {
+  //return toScreen(getRect());
   AGRect2 r=getRect();
   if(mParent)
-    r+=mParent->getScreenPosition();
+    {
+      return mParent->toScreen(getRect());
+    }
   return r;
 }
 
+AGRect2 AGWidget::toScreen(const AGRect2&p) const
+{
+  AGRect2 r=innerToOuter(p);
+  if(mParent)
+    r=mParent->toScreen(r);
+  return r;
+}
+
+AGVector2 AGWidget::toScreen(const AGVector2&p) const
+{
+  AGVector2 r=innerToOuter(p);
+  if(mParent)
+    r=mParent->toScreen(r);
+  return r;
+}
+
+
+AGRect2 AGWidget::fromScreen(const AGRect2 &p) const
+{
+  AGRect2 r=outerToInner(p);
+  if(mParent)
+    r=mParent->toScreen(r);
+  return r;
+}
+
+
+
 AGVector2 AGWidget::fromScreen(const AGVector2 &p) const
 {
-  if(!mParent)
+  AGVector2 r=outerToInner(p);
+  if(mParent)
+    r=mParent->toScreen(r);
+  return r;
+  /*  if(!mParent)
     return p;
   AGRect2 r(mParent->getScreenRect());
-  return p-r[0];
+  return p-r[0];*/
 }
 
 bool AGWidget::canFocus() const
@@ -1201,3 +1250,51 @@
     mOldMousePos=startVector;
     mButtonDown=value;
   }
+
+AGProjection2D AGWidget::innerToOuter() const
+{
+  AGRect2 u(0,0,1,1);
+  return AGProjection2D(u,innerToOuter(u));
+}
+AGProjection2D AGWidget::outerToInner() const
+{
+  AGRect2 u(0,0,1,1);
+  return AGProjection2D(u,outerToInner(u));
+}
+
+AGRect2 AGWidget::innerToOuter(const AGRect2 &p) const
+{
+  AGRect2 m=p;
+
+  if(mUseClientRect)
+    m=mClientProj.project(m);
+  return m+getRect().getV0();
+}
+AGVector2 AGWidget::innerToOuter(const AGVector2 &p) const
+{
+  AGVector2 m=p;
+
+  if(mUseClientRect)
+    m=mClientProj.project(m);
+  return m+getRect().getV0();
+}
+AGRect2 AGWidget::outerToInner(const AGRect2 &p) const
+{
+  AGRect2 m=p;
+
+  if(mUseClientRect)
+    {
+      cdebug(mClientProj.getMatrix());
+      m=mClientProj.inverse().project(m);
+    }
+  return m-getRect().getV0();
+}
+AGVector2 AGWidget::outerToInner(const AGVector2 &p) const
+{
+  AGVector2 m=p;
+
+  if(mUseClientRect)
+    m=mClientProj.inverse().project(m);
+  return m-getRect().getV0();
+}
+

Modified: antargis/trunk/ext/gui/ag_widget.h
===================================================================
--- antargis/trunk/ext/gui/ag_widget.h	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/gui/ag_widget.h	2008-06-05 19:24:45 UTC (rev 1263)
@@ -180,15 +180,31 @@
   // to prevent this, use this function to "use" them in each frame
   virtual void useTextures(); // when caching
   void useTexturesRecursive(); // when caching
+  
+  
+  
+  
+  // geometry calculation
+  AGRect2 innerToOuter(const AGRect2 &pRect) const;
+  AGVector2 innerToOuter(const AGVector2 &pRect) const;
+  AGRect2 outerToInner(const AGRect2 &pRect) const;
+  AGVector2 outerToInner(const AGVector2 &pRect) const;
 
 
   // clear children
   void clear();
 
   AGRect2 getScreenRect() const;
+  AGRect2 toScreen(const AGRect2&p) const;
+  AGVector2 toScreen(const AGVector2&p) const;
+  AGRect2 fromScreen(const AGRect2 &p) const;
+  AGVector2 fromScreen(const AGVector2 &p) const;
+
+  AGProjection2D innerToOuter() const;
+  AGProjection2D outerToInner() const;
+  
   AGVector2 getScreenPosition() const;
   
-  AGVector2 fromScreen(const AGVector2 &p) const;
 
   // focus
 
@@ -237,6 +253,8 @@
   virtual bool eventMouseMotionClipped(AGEvent *pEvent,const AGVector2 &pPosition);
 
   void addChildRef(AGWidget *pWidget);
+ 
+  
 protected:
   virtual bool letChildProcess(AGWidget *pChild,AGEvent *event);
 

Modified: antargis/trunk/ext/video/ag_gltexture.cc
===================================================================
--- antargis/trunk/ext/video/ag_gltexture.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/video/ag_gltexture.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -63,7 +63,7 @@
 
 AGGLTexture::AGGLTexture(size_t W,size_t H,GLint format):w(W),h(H),d(1),m3d(false),mRectTex(false),mTarget(GL_TEXTURE_2D)
   {
-    cdebug("HUPE");
+    //cdebug("HUPE");
     initDMABuffer();
     assertGL;
     getSurfaceManager()->registerMe(this);
@@ -73,10 +73,10 @@
     bool inited=false;
     mTarget=GL_TEXTURE_2D;
 
-    cdebug(w<<":"<<h);
+    //cdebug(w<<":"<<h);
     if(!(isPowerOf2(w) && isPowerOf2(h)))
       {
-        cdebug("not power of 2");
+        //cdebug("not power of 2");
         if(GLEE_ARB_texture_rectangle && false)
           {
             mTarget=GL_TEXTURE_RECTANGLE_ARB;
@@ -86,9 +86,9 @@
             h=w=nextPowerOf2(std::max(w,h));
           }
       }
-    cdebug("1");
+    //cdebug("1");
     glEnable(mTarget);
-    cdebug("2");
+    //cdebug("2");
     glBindTexture( mTarget,mID);
     assertGL;
 
@@ -104,6 +104,7 @@
     cdebug("3");
     if(buffer)
       memset(buffer,0,bufSize);
+    /*
     cdebug("5");
     cdebug(mTarget);
     cdebug(format);
@@ -114,17 +115,18 @@
     cdebug("w:"<<w<<" h:"<<h);
     cdebug("texmem:"<<gUsedTexMemory);
     cdebug((void*)buffer);
+    */
     assertGL;
     glTexImage2D(mTarget, 0, format, w, h, 0, GL_RGBA,
         GL_UNSIGNED_BYTE, buffer);
     assertGL;
-    cdebug("6");
+    //cdebug("6");
 
     if(buffer)
       delete [] buffer;
 
-    cdebug("7");
-    cdebug("W:"<<w<<" h:"<<h);
+    //cdebug("7");
+    //cdebug("W:"<<w<<" h:"<<h);
     assertGL;
     gUsedTexMemory+=w*h*4;
 

Modified: antargis/trunk/ext/video/ag_painter.cc
===================================================================
--- antargis/trunk/ext/video/ag_painter.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/video/ag_painter.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -27,6 +27,7 @@
 #include <ag_sdlsurface.h>
 #include <ag_texture.h>
 #include <math.h>
+#include <ag_geometry.h>
 
 #include <stdexcept>
 
@@ -38,30 +39,30 @@
 
 
 AGPaintProjection::AGPaintProjection(const AGRect2 &pClip):clip(pClip)
-{
-  a.set(0,0,1);
-  a.set(0,1,0);
-  a.set(0,2,0);
-  a.set(1,0,0);
-  a.set(1,1,1);
-  a.set(1,2,0);
-  a.set(2,0,0);
-  a.set(2,1,0);
-  a.set(2,2,0);
-}
+  {
+    a.set(0,0,1);
+    a.set(0,1,0);
+    a.set(0,2,0);
+    a.set(1,0,0);
+    a.set(1,1,1);
+    a.set(1,2,0);
+    a.set(2,0,0);
+    a.set(2,1,0);
+    a.set(2,2,0);
+  }
 
 AGPaintProjection::AGPaintProjection(const AGClipping &pClip):advancedClipping(pClip)
-{
-  a.set(0,0,1);
-  a.set(0,1,0);
-  a.set(0,2,0);
-  a.set(1,0,0);
-  a.set(1,1,1);
-  a.set(1,2,0);
-  a.set(2,0,0);
-  a.set(2,1,0);
-  a.set(2,2,0);
-}
+  {
+    a.set(0,0,1);
+    a.set(0,1,0);
+    a.set(0,2,0);
+    a.set(1,0,0);
+    a.set(1,1,1);
+    a.set(1,2,0);
+    a.set(2,0,0);
+    a.set(2,1,0);
+    a.set(2,2,0);
+  }
 
 
 AGVector2 AGPaintProjection::project(const AGVector2 &p) const
@@ -217,19 +218,19 @@
 /////////////////////////////////////////////////////////////////////////////////
 
 AGPainter::AGPainter():mCurrent(getScreen().getRect()),mTarget(&getScreen())
-{
-  mTarget->beginPaint();
-}
+  {
+    mTarget->beginPaint();
+  }
 
 AGPainter::AGPainter(const AGPainter &p):ps(p.ps),mCurrent(p.mCurrent),mTarget(p.mTarget)
-{
-  mTarget->beginPaint();
-}
+  {
+    mTarget->beginPaint();
+  }
 
 AGPainter::AGPainter(AGPaintTarget &pTarget):mCurrent(pTarget.getRect()),mTarget(&pTarget)
-{
-  mTarget->beginPaint();
-}
+  {
+    mTarget->beginPaint();
+  }
 
 
 AGPainter::~AGPainter()
@@ -476,22 +477,22 @@
 void AGPainter::fillPoly(const std::vector<AGVector2> &pPoly,const AGColor &c)
   {
     //FIXME: add clipping for none-GL (?) - for performance ?
-    
+
     std::vector<AGVector2> projected;
     for(std::vector<AGVector2>::const_iterator i=pPoly.begin();i!=pPoly.end();i++)
       projected.push_back(mCurrent.project(*i));
-     
+
     mTarget->fillPoly(projected,c);
   }
 
 void AGPainter::drawPoly(const std::vector<AGVector2> &pPoly,const AGColor &c)
   {
     //FIXME: add clipping for none-GL (?) - for performance ?
-    
+
     std::vector<AGVector2> projected;
     for(std::vector<AGVector2>::const_iterator i=pPoly.begin();i!=pPoly.end();i++)
       projected.push_back(mCurrent.project(*i));
-     
+
     mTarget->drawPoly(projected,c);
   }
 
@@ -626,3 +627,9 @@
     return mTarget.getPtr();
   }
 
+
+void AGPainter::debugOutput()
+  {
+    cdebug(mCurrent.a);
+    cdebug(mCurrent.clip);
+  }

Modified: antargis/trunk/ext/video/ag_painter.h
===================================================================
--- antargis/trunk/ext/video/ag_painter.h	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/video/ag_painter.h	2008-06-05 19:24:45 UTC (rev 1263)
@@ -131,6 +131,8 @@
   bool pointOk(const AGVector2 &p) const;
 
   AGPaintTarget *getTarget();
+  
+  void debugOutput();
 
  private:
   std::list<AGPaintProjection> ps;

Modified: antargis/trunk/ext/video/ag_projection.cc
===================================================================
--- antargis/trunk/ext/video/ag_projection.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/video/ag_projection.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,10 +7,15 @@
   {
   }
 
-AGProjection2D::AGProjection2D(const AGMatrix3 &pMatrix) :
+AGProjection2D::AGProjection2D(const AGMatrix3 &pMatrix) throw (GeometryException) :
   mInited(true), m(pMatrix)
   {
-    assert(isInvertable(m));
+    bool invertable=isInvertable(m);
+    if(!invertable)
+      {
+        throw GeometryException(AGString("Matrix ")+m.toString()+" is not invertible");
+      }
+    assert(invertable);
   }
 
 AGProjection2D::AGProjection2D(const AGProjection2D &p) :
@@ -30,20 +35,20 @@
     AGMatrix3 m3(to.getV0());
 
     m=m3*m2*m1;
-    
+
     assert(isInvertable(m));
   }
 
 AGRect2 AGProjection2D::project(const AGRect2 &r) const
-  {
-    assert(mInited);
-    return AGRect2((m*r.getV0()).dim2(), (m*r.getV1()).dim2());
-  }
+{
+  assert(mInited);
+  return AGRect2((m*r.getV0()).dim2(), (m*r.getV1()).dim2());
+}
 AGVector2 AGProjection2D::project(const AGVector2 &p) const
-  {
-    assert(mInited);
-    return (m*p).dim2();
-  }
+{
+  assert(mInited);
+  return (m*p).dim2();
+}
 
 void AGProjection2D::pushProjection(const AGProjection2D &p)
   {
@@ -51,15 +56,20 @@
     m*=p.m;
   }
 
-AGProjection2D AGProjection2D::inverse() const
+AGProjection2D AGProjection2D::inverse() const throw (GeometryException)
   {
     CTRACE;
-    assert(isInvertable(m));
-    cdebug("1");
-    return AGProjection2D(m.inverted());
+    bool invertable=isInvertable(m);
+    if(!invertable)
+      {
+        cdebug("Matrix:"<<m);
+        throw GeometryException(AGString("Matrix ")+m.toString()+" is not invertible");
+      }
+    AGMatrix3 inv=m.inverted();
+    return AGProjection2D(inv);
   }
 
 AGMatrix3 AGProjection2D::getMatrix() const
-  {
-    return m;
-  }
+{
+  return m;
+}

Modified: antargis/trunk/ext/video/ag_projection.h
===================================================================
--- antargis/trunk/ext/video/ag_projection.h	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/video/ag_projection.h	2008-06-05 19:24:45 UTC (rev 1263)
@@ -13,12 +13,12 @@
   AGProjection2D();
   AGProjection2D(const AGProjection2D &p);
   AGProjection2D(const AGRect2 &from, const AGRect2 &to);
-  AGProjection2D(const AGMatrix3 &pMatrix);
+  AGProjection2D(const AGMatrix3 &pMatrix) throw (GeometryException);
 
   AGRect2 project(const AGRect2 &r) const;
   AGVector2 project(const AGVector2 &p) const;
   
-  AGProjection2D inverse() const;
+  AGProjection2D inverse() const throw (GeometryException);
 
   void pushProjection(const AGProjection2D &p);
   

Modified: antargis/trunk/rookey/tasks.rb
===================================================================
--- antargis/trunk/rookey/tasks.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/rookey/tasks.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -110,7 +110,7 @@
     linker=Rookey::Compiler.new(config)
     
     target=linker.dllName(name)
-    
+    #pp target
     desc "Link DLL #{name}"
     task target=>files do |t|
       linker.linkDLL(t)

Modified: antargis/trunk/ruby/editor/campaign/drag_grid.rb
===================================================================
--- antargis/trunk/ruby/editor/campaign/drag_grid.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/editor/campaign/drag_grid.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -101,6 +101,7 @@
       getChildren.map{|child|[child]+child.getAllDescendants}.flatten
     end
     def moveToContext(to)
+      
       o=getScreenRect
       p=getParent
       p.removeChild(self)

Modified: antargis/trunk/ruby/entities/ant_wolf.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_wolf.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/entities/ant_wolf.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -30,225 +30,223 @@
 # the whole pack moves on to find some food (sheep or men)
 
 class AntWolf<AntAnimal
-	attr_accessor :leader,:mypack
+  attr_accessor :leader,:mypack
 
-	def initialize(map)
-		super
-		setProvide("wolf",true)
-		setProvide("wolf_leader",true)
-		setSpeed 3
-		@lastBirth=0
-		@foodAdd=0
-		@mypack=[]
-		@leader=nil
-		
-		setMesh
+  def initialize(map)
+    super
+    setProvide("wolf",true)
+    setProvide("wolf_leader",true)
+    setSpeed 3
+    @lastBirth=0
+    @foodAdd=0
+    @mypack=[]
+    @leader=nil
+    
+    setMesh
 
-		resource.set("food",1)
-		@job=:resting
-		setHunger(0.01)
-		setMode("resting")
-	end
-	def eventNoJob
-		eventJobFinished
-	end
-	def eventJobFinished
-		super
+    resource.set("food",1)
+    @job=:resting
+    setHunger(0.01)
+    setMode("resting")
+  end
+  def eventNoJob
+    eventJobFinished
+  end
+  def eventJobFinished
+    super
 
-		if @dead
-			newRestJob(30)
-			if @alreadyDead
-				getMap.removeEntity(self)
-			end
-			@alreadyDead=true
-	
-			return
-		end
+    if @dead
+      newRestJob(30)
+      if @alreadyDead
+        getMap.removeEntity(self)
+      end
+      @alreadyDead=true
+  
+      return
+    end
 
-		if getFood<=0
-			eventDie
-			return
-		end
+    if getFood<=0
+      eventDie
+      return
+    end
 
-		# BIRTHRATE is here:
-		if @lastBirth>40 then
-			# make child
-			puts "A WOLF IS BORN"
-			wolf=AntWolf.new
-			wolf.setPos(getPos2D)
-			getMap.insertEntity(wolf)
-			#getMap.endChange
-			newRestJob(2)
-			@lastBirth=-getRand*10
-		else
-			checkPackMerge
-			if @leader
-				assignJob(self)
-			else
-				decideWhatsToDo
-			end
-		end
+    # BIRTHRATE is here:
+    if @lastBirth>40 then
+      # make child
+      puts "A WOLF IS BORN"
+      wolf=AntWolf.new
+      wolf.setPos(getPos2D)
+      getMap.insertEntity(wolf)
+      #getMap.endChange
+      newRestJob(2)
+      @lastBirth=-getRand*10
+    else
+      checkPackMerge
+      if @leader
+        assignJob(self)
+      else
+        decideWhatsToDo
+      end
+    end
 # 
-# 		elsif rand<0.5 then
-# 			newMoveJob(0,getTargetPos,0)
-# 			setMeshState("go")
-# 		else
-# 			newRestJob(3)
-# 			setMeshState("eat")
-# 			playSound("wolf")
-# 		end
+#       newMoveJob(0,getTargetPos,0)
+#       setMeshState("go")
+#     else
+#       newRestJob(3)
+#       setMeshState("eat")
+#       playSound("wolf")
+#     end
+    @foodAdd+=1
+    #puts "FOOOOOD #{@foodAdd}"
+    if @foodAdd>3 and resource.get("food")<10
+      #puts "RESOURCE: #{resource.get("food")}"
+      resource.add("food",1)
+      #puts "RESOURCE: #{resource.get("food")}"
+      @foodAdd=0
+    end
 
-		@foodAdd+=1
-		#puts "FOOOOOD #{@foodAdd}"
-		if @foodAdd>3 and resource.get("food")<10
-			#puts "RESOURCE: #{resource.get("food")}"
-			resource.add("food",1)
-			#puts "RESOURCE: #{resource.get("food")}"
-			@foodAdd=0
-		end
+    @lastBirth+=1
+  end
 
-		@lastBirth+=1
-	end
+  def checkPackMerge
+    # find next leader
+    setProvide("wolf_leader",false)
 
-	def checkPackMerge
-		# find next leader
-		setProvide("wolf_leader",false)
+    tent=getMap.getNext(self,"wolf_leader")
+    if tent
+      if (tent.getPos2D-getPos2D).length<10
+        if not tent.inPack(self)
+          # simple take me as leader
+          tent.setLeader(self)
+        end
+      end
+    end
+  end
 
-		tent=getMap.getNext(self,"wolf_leader")
-		if tent
-			if (tent.getPos2D-getPos2D).length<10
-				if not tent.inPack(self)
-					# simple take me as leader
-					tent.setLeader(self)
-				end
-			end
-		end
-	end
+  def assignLeader(pack)
+    oldpack=@mypack.dup
+    @mypack+=pack
+    @mypack.uniq!
+    @leader=nil
+    @mypack.delete(self)
+    if @mypack.length!=oldpack.length
+      @mypack.each{|w|w.setLeaderDirect(self)}
+    end
+    setProvide("wolf_leader",true)
+  end
 
-	def assignLeader(pack)
-		oldpack=@mypack.dup
-		@mypack+=pack
-		@mypack.uniq!
-		@leader=nil
-		@mypack.delete(self)
-		if @mypack.length!=oldpack.length
-			@mypack.each{|w|w.setLeaderDirect(self)}
-		end
-		setProvide("wolf_leader",true)
-	end
+  def inPack(wolf)
+    @mypack.member?(wolf)
+  end
+    
 
-	def inPack(wolf)
-		@mypack.member?(wolf)
-	end
-		
+  def setLeader(leader)
+    leader.assignLeader(@mypack+[self])
+    setLeaderDirect(leader)
+  end
 
-	def setLeader(leader)
-		leader.assignLeader(@mypack+[self])
-		setLeaderDirect(leader)
-	end
+  def setLeaderDirect(leader)
+    @mypack=[]
+    @leader=leader
+    setProvide("wolf_leader",false)
+  end
+  
+  def decideWhatsToDo
+    if @job==:resting
+      if getFood>0.5
+        @job=:resting
+      else
+        puts "GETTING NEW SHEEP"
+        @sheep=getMap.getNext(self,"sheep")
+        if @sheep
+          @job=:killsheep
+        else
+          @job=:resting
+        end
+      end
+    
+      assignJobToAll
+    else
+      assignJob(self)
+    end
+  end
 
-	def setLeaderDirect(leader)
-		@mypack=[]
-		@leader=leader
-		setProvide("wolf_leader",false)
-	end
-	
-	def decideWhatsToDo
-		if @job==:resting
-			if getFood>0.5
-				@job=:resting
-			else
-				puts "GETTING NEW SHEEP"
-				@sheep=getMap.getNext(self,"sheep")
-				if @sheep
-					@job=:killsheep
-				else
-					@job=:resting
-				end
-			end
-		
-			assignJobToAll
-		else
-			assignJob(self)
-		end
-	end
+  def assignJobToAll
+    all=@mypack+[self]
+    all.each{|w|assignJob(w)}
+  end
 
-	def assignJobToAll
-		all=@mypack+[self]
-		all.each{|w|assignJob(w)}
-	end
+  def assignJob(wolf)
+    case @job
+      when :resting
+        wolf.newRestJob(4)
+        wolf.setMode("resting")
+      when :killsheep
+        if @sheep
+          puts "KILLSHEEP #{@sheep} #{self}"
+          if (@sheep.getPos2D-wolf.getPos2D).length>0.5
+            wolf.newMoveJob(0, at sheep.getPos2D,0)
+          else
+            @sheep.eventDie  
+            if @leader
+              @leader.shareFood
+            else
+              shareFood
+            end
+          end
+        end
+    end
+  end
 
-	def assignJob(wolf)
-		case @job
-			when :resting
-				wolf.newRestJob(4)
-				wolf.setMode("resting")
-			when :killsheep
-				if @sheep
-					puts "KILLSHEEP #{@sheep} #{self}"
-					if (@sheep.getPos2D-wolf.getPos2D).length>0.5
-						wolf.newMoveJob(0, at sheep.getPos2D,0)
-					else
-						@sheep.eventDie	
-						if @leader
-							@leader.shareFood
-						else
-							shareFood
-						end
-					end
-				end
-		end
-	end
+  def shareFood
+    ([self]+ at mypack).each{|w|w.incFood(1.5)}
+    @job=:resting
+    decideWhatsToDo
+  end
+  
+  def getTargetPos
+    p=getPos2D
+    t=p
+    ok=true
+    radius=4
+    # assure that sheep doesn't walk into water
+    while getMap.getHeight(t.x,t.y)<0.1 or ok do
+      d=AGVector2.new(getRand-0.5,getRand-0.5).normalized*radius
+      t=p+d
+      t=getMap.truncPos(t)
+      ok=false
+    end 
+    return t
+  end
+  def getMen
+    (@mypack+[self]).uniq.dup
+  end
+  def menCount
+    getMen.length
+  end
+  def setMeshState(s)
+    #getFirstMesh.setAnimation(s)
+  end
+  def getName
+    return "Corpse" if @dead
+    return "Wolfleader2" if provides("wolf_leader")
+    return "Wolfleader" if @leader.nil?
+    "Wolf"
+  end
+  def eventDie
+    setMesh(:rip)
+    #setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/rip.ant2",0.3,"data/textures/models/rip.png"),AGVector4.new(0,0,0,0),0))
+    @dead=true
+    
+    newRestJob(1)
 
-	def shareFood
-		([self]+ at mypack).each{|w|w.incFood(1.5)}
-		@job=:resting
-		decideWhatsToDo
-	end
-	
-	def getTargetPos
-		p=getPos2D
-		t=p
-		ok=true
-		radius=4
-		# assure that sheep doesn't walk into water
-		while getMap.getHeight(t.x,t.y)<0.1 or ok do
-			d=AGVector2.new(getRand-0.5,getRand-0.5).normalized*radius
-			t=p+d
-			t=getMap.truncPos(t)
-			ok=false
-		end 
-		return t
-	end
-	def getMen
-		(@mypack+[self]).uniq.dup
-	end
-	def menCount
-		getMen.length
-	end
-	def setMeshState(s)
-		#getFirstMesh.setAnimation(s)
-	end
-	def getName
-		return "Corpse" if @dead
-		return "Wolfleader2" if provides("wolf_leader")
-		return "Wolfleader" if @leader.nil?
-		"Wolf"
-	end
-	def eventDie
-		setMesh(:rip)
-		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/rip.ant2",0.3,"data/textures/models/rip.png"),AGVector4.new(0,0,0,0),0))
-		@dead=true
-		
-		newRestJob(1)
-
-		if @leader.nil?
-			# choose new leader
-			if @mypack.length>0
-				l=@mypack[0]
-				l.assignLeader(@mypack[1..-1])
-				@mypack=[]
-			end
-		end
-	end
+    if @leader.nil?
+      # choose new leader
+      if @mypack.length>0
+        l=@mypack[0]
+        l.assignLeader(@mypack[1..-1])
+        @mypack=[]
+      end
+    end
+  end
 end

Modified: antargis/trunk/ruby/entities/ant_workshop.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_workshop.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/entities/ant_workshop.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,100 +1,100 @@
 # This is a workshop. Residents will produce tools and fetch needed resources
 # which are wood and stone. Apart from this they'll try to gather food so they won't starve
 class AntWorkshop<AntHouse
-	def initialize(map)
-		super
-		setProvide("workshop",true)
-		setProvide("tool",true)
-		@lastBirth=0
-		setDirection(-50)
-		@smoke=0
-	end
+  def initialize(map)
+    super
+    setProvide("workshop",true)
+    setProvide("tool",true)
+    @lastBirth=0
+    setDirection(-50)
+    @smoke=0
+  end
 
-	# increase smoke by one
-	def incSmoke
-		@smoke+=1
-		checkSmoke
-	end
-	def decSmoke
-		@smoke-=1
-		checkSmoke
-	end
+  # increase smoke by one
+  def incSmoke
+    @smoke+=1
+    checkSmoke
+  end
+  def decSmoke
+    @smoke-=1
+    checkSmoke
+  end
 
-	# assign my men a job.
-	# this is simple tool-production in case there is no defend-job
-	# * e - entity (= one of my men)
-	def assignJob(e)
-		if e.getMode=="invent"
-			produceOneTool
-			e.setMode("any")
-			decSmoke
-		end
-		if not @job
-			if allThereForTool && notEnoughTools && atHome(e)
-				e.setMode("invent")
-				e.newRestJob(10)
-				startToolProduction
-				return
-			end
-		end
-		super(e)
-	end
-	# sets up the mesh and adds a smoke-particle engine, which is disabled at first
-	def setupMesh
-		return if getScene.nil?
-		setMesh
-		p=AGVector3.new(-1.3,-1.2,2.2)
-		if opengl
-			addMesh(@smokeMesh=AntParticle.new(getMap.getScene,5),p)
-			checkSmoke
-		end
-	end
+  # assign my men a job.
+  # this is simple tool-production in case there is no defend-job
+  # * e - entity (= one of my men)
+  def assignJob(e)
+    if e.getMode=="invent"
+      produceOneTool
+      e.setMode("any")
+      decSmoke
+    end
+    if not @job
+      if allThereForTool && notEnoughTools && atHome(e)
+        e.setMode("invent")
+        e.newRestJob(10)
+        startToolProduction
+        return
+      end
+    end
+    super(e)
+  end
+  # sets up the mesh and adds a smoke-particle engine, which is disabled at first
+  def setupMesh
+    return if getScene.nil?
+    setMesh
+    p=AGVector3.new(-1.3,-1.2,2.2)
+    if opengl
+      addMesh(@smokeMesh=AntParticle.new(getMap.getScene,5),p)
+      checkSmoke
+    end
+  end
 protected
-	
-	# start tool production (=remove 1 wood and 1 stone)
-	def startToolProduction
-		resource.sub("wood",1)
-		resource.sub("stone",1)
-		playSound("construct")
-		incSmoke
-	end
-	
+  
+  # start tool production (=remove 1 wood and 1 stone)
+  def startToolProduction
+    resource.sub("wood",1)
+    resource.sub("stone",1)
+    playSound("construct")
+    incSmoke
+  end
+  
 
-	# produce one tool
-	def produceOneTool
-		resource.add("tool",1)
-	end
-	
-	# check if there are enough resources to build a tool (wood>=1 && stone=>1)
-	def allThereForTool
-		resource.get("wood")>=1 && resource.get("stone")>=1
-	end
-	
-	# check if there are enough tools (10)
-	def notEnoughTools
-		resource.get("tool")<10
-	end
+  # produce one tool
+  def produceOneTool
+    resource.add("tool",1)
+  end
+  
+  # check if there are enough resources to build a tool (wood>=1 && stone=>1)
+  def allThereForTool
+    resource.get("wood")>=1 && resource.get("stone")>=1
+  end
+  
+  # check if there are enough tools (10)
+  def notEnoughTools
+    resource.get("tool")<10
+  end
 
-	# returns my name "workshop"
-	def houseType
-		"workshop"
-	end
+  # returns my name "workshop"
+  def houseType
+    "workshop"
+  end
 
-	def neededStock
-		{"wood"=>10,"stone"=>10,"food"=>10}
-	end
-	
+  def neededStock
+    {"wood"=>10,"stone"=>10,"food"=>10}
+  end
+  
 
 private
-	# checks if smoke should be displayed
-	def checkSmoke
-		return if getScene.nil?
-		if @smokeMesh
-			if @smoke
-				@smokeMesh.setEnabled((@smoke>0))
-			else
-				@smokeMesh.setEnabled(false)
-			end
-		end
-	end
-end
\ No newline at end of file
+  # checks if smoke should be displayed
+  def checkSmoke
+    return if getScene.nil?
+    if @smokeMesh
+      if @smoke
+        @smokeMesh.setEnabled((@smoke>0))
+      else
+        @smokeMesh.setEnabled(false)
+      end
+    end
+  end
+end

Modified: antargis/trunk/ruby/entities/entity.rb
===================================================================
--- antargis/trunk/ruby/entities/entity.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/entities/entity.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,312 +7,312 @@
 # AntRubyEntity slighty enhances the functionality already provided by AntEntity.
 # This should be used for all the entity-types.
 class AntRubyEntity<AntEntity
-	attr_accessor :birthday
-	attr_reader :uid, :selected
+  attr_accessor :birthday
+  attr_reader :uid, :selected
 
-	# get the 3d-scene-object out of the Map-object
-	def getScene
-		getMap.getScene
-	end
+  # get the 3d-scene-object out of the Map-object
+  def getScene
+    getMap.getScene
+  end
 
-	# create a new entity at the position *p*
-	# set some default settings
-	# get a unique ID
-	# loading must be done externally in loadXML !
-	def initialize(map)
-		@hovered=@selected=false
-		assert{map.is_a?(AntMap)}
-		super(map)
-		@xmlProps={}
-		@birthday=getMap.getTime
-		@mode=""
-		@handlers={}
-		self.learnAmount=0.05
-	
-		@uid=getMap.getUniqueID
-		setHunger(0) # general entities have no hunger
-	end
+  # create a new entity at the position *p*
+  # set some default settings
+  # get a unique ID
+  # loading must be done externally in loadXML !
+  def initialize(map)
+    @hovered=@selected=false
+    assert{map.is_a?(AntMap)}
+    super(map)
+    @xmlProps={}
+    @birthday=getMap.getTime
+    @mode=""
+    @handlers={}
+    self.learnAmount=0.05
+  
+    @uid=getMap.getUniqueID
+    setHunger(0) # general entities have no hunger
+  end
 
 
-	# play a sound identified by +name+. Sounds of this type shouldn't called when they were only called
-	# +minDiff+ (or less) seconds before. Note that the sound is played at the place where this entity is placed.
-	# So it's not hearable far away from it.
-	def playSound(name,minDiff=0.5)
-		scene=getScene
-		d=((scene.getCamera.dim2-getPos2D).length-INNER_VOL_SIZE)
-		vol=1
-		if d>0
-			vol=[(OUTER_VOL_SIZE-d)/OUTER_VOL_SIZE,0].max
-		end
-		AntSound.playSoundGlobal(name,vol,minDiff)
-	end
+  # play a sound identified by +name+. Sounds of this type shouldn't called when they were only called
+  # +minDiff+ (or less) seconds before. Note that the sound is played at the place where this entity is placed.
+  # So it's not hearable far away from it.
+  def playSound(name,minDiff=0.5)
+    scene=getScene
+    d=((scene.getCamera.dim2-getPos2D).length-INNER_VOL_SIZE)
+    vol=1
+    if d>0
+      vol=[(OUTER_VOL_SIZE-d)/OUTER_VOL_SIZE,0].max
+    end
+    AntSound.playSoundGlobal(name,vol,minDiff)
+  end
 
-	
-	# :section: Editing
+  
+  # :section: Editing
 
-	# Within the editor you can change additional properties, e.g. count of men for a hero. This functions are used for this.
-	def setXMLProp(n,v)
-		@xmlProps[n]=v
-	end
-	def getXMLProp(n)
-		if @xmlProps[n]==nil
-			return ""
-		else
-			return @xmlProps[n]
-		end
-	end
+  # Within the editor you can change additional properties, e.g. count of men for a hero. This functions are used for this.
+  def setXMLProp(n,v)
+    @xmlProps[n]=v
+  end
+  def getXMLProp(n)
+    if @xmlProps[n]==nil
+      return ""
+    else
+      return @xmlProps[n]
+    end
+  end
 
-	# :section: XML loading/saving
+  # :section: XML loading/saving
 
-	def preloadXML(node)
-		if node.get("birthday")!=""
-			@birthday=node.get("birthday").to_f
-		end
-		@mode=node.get("mode")
-		if node.get("uid")!=""
-			@uid=node.get("uid").to_i
-			getMap.checkUID(@uid)
-		end
-		setName(node.get("name"))
-	end
+  def preloadXML(node)
+    if node.get("birthday")!=""
+      @birthday=node.get("birthday").to_f
+    end
+    @mode=node.get("mode")
+    if node.get("uid")!=""
+      @uid=node.get("uid").to_i
+      getMap.checkUID(@uid)
+    end
+    setName(node.get("name"))
+  end
 
-	def loadXML(node)
-		super
-	end
-	def saveXML(node)
-		super(node)
-		@xmlProps.each{|n,v|
-			node.set(n,v)
-		}
-		if @birthday
-			node.set("birthday", at birthday.to_s)
-		end
-		node.set("mode", at mode)
-		node.set("uid", at uid.to_s)
-	end
-	def getDescription
-		_("This is an entity - no more info here.")
-	end
+  def loadXML(node)
+    super
+  end
+  def saveXML(node)
+    super(node)
+    @xmlProps.each{|n,v|
+      node.set(n,v)
+    }
+    if @birthday
+      node.set("birthday", at birthday.to_s)
+    end
+    node.set("mode", at mode)
+    node.set("uid", at uid.to_s)
+  end
+  def getDescription
+    _("This is an entity - no more info here.")
+  end
 
-	# :section: miscellanous
+  # :section: miscellanous
 
-	# simple comparison operator, so that ents can be distinguished
-	# for what is this needed ???
-	def <=>(e)
-		to_s<=>e.to_s
-	end
+  # simple comparison operator, so that ents can be distinguished
+  # for what is this needed ???
+  def <=>(e)
+    to_s<=>e.to_s
+  end
 
-	def menCount
-		0
-	end
-	def getPlayer
-		nil
-	end
-	def fightTarget
-		@fightTarget
-	end
-	def getRand
-		if false
-			# FIXME - implement me (network code)
-			#rand
-			@mrand||=AGRandomizer.new("")
-			val=@mrand.randFloat(1)
-	
-			return val
-		end
-		agRand(1.0)
-	end
+  def menCount
+    0
+  end
+  def getPlayer
+    nil
+  end
+  def fightTarget
+    @fightTarget
+  end
+  def getRand
+    if false
+      # FIXME - implement me (network code)
+      #rand
+      @mrand||=AGRandomizer.new("")
+      val=@mrand.randFloat(1)
+  
+      return val
+    end
+    agRand(1.0)
+  end
 
-	def setStrength(v)
-		super
-		setMoraleStrength(v*2)
-	end
+  def setStrength(v)
+    super
+    setMoraleStrength(v*2)
+  end
 
-	# get the age of this entity - computed from @birthday
-	def age
-		((getMap.getTime- at birthday).to_f/YEAR).to_i
-	end
-	# @birthday will be set according to the current date (get it by calling getMap.getTime)
-	def age=(years)
-		@birthday=getMap.getTime-years*YEAR
-	end
-	def getMen
-		[]
-	end
+  # get the age of this entity - computed from @birthday
+  def age
+    ((getMap.getTime- at birthday).to_f/YEAR).to_i
+  end
+  # @birthday will be set according to the current date (get it by calling getMap.getTime)
+  def age=(years)
+    @birthday=getMap.getTime-years*YEAR
+  end
+  def getMen
+    []
+  end
 
-	
-	def setMode(mode)
-		@mode=mode
-	end
-	def getMode
-		@mode
-	end
+  
+  def setMode(mode)
+    @mode=mode
+  end
+  def getMode
+    @mode
+  end
 
 
 
-	def isOnOpenWater(p=nil)
-		if (not p)
-			p=getPos2D
-		end
-		if (not p.is_a?(AGVector2))
-			p=p.getPos2D
-		end
-		assert{p.is_a?(AGVector2)}
-		getMap.getPos(p).z<-0.2
-	end
-	def isOnWater
-		getMap.getPos(getPos2D).z<0
-	end
+  def isOnOpenWater(p=nil)
+    if (not p)
+      p=getPos2D
+    end
+    if (not p.is_a?(AGVector2))
+      p=p.getPos2D
+    end
+    assert{p.is_a?(AGVector2)}
+    getMap.getPos(p).z<-0.2
+  end
+  def isOnWater
+    getMap.getPos(getPos2D).z<0
+  end
 
-	# give name under which this entity is stored in xml. It's generated from the classname. The first character is downcased.
-	# The rest is camel-case as usual.
-	# For instace: AntShop => antShop
-	def xmlName
-		xml=self.class.to_s
-		xml=xml[0..0].downcase+xml[1..1000]
-		return xml
-	end
+  # give name under which this entity is stored in xml. It's generated from the classname. The first character is downcased.
+  # The rest is camel-case as usual.
+  # For instace: AntShop => antShop
+  def xmlName
+    xml=self.class.to_s
+    xml=xml[0..0].downcase+xml[1..1000]
+    return xml
+  end
 
-	def addHandler(eventName,&block)
-		@handlers[eventName]||=[]
-		@handlers[eventName].push(block)
-	end
+  def addHandler(eventName,&block)
+    @handlers[eventName]||=[]
+    @handlers[eventName].push(block)
+  end
 
-	def doEvent(name)
-		if @handlers[name]
-			@handlers[name].each{|b|
-				b.call
-			}
-		end
-	end
+  def doEvent(name)
+    if @handlers[name]
+      @handlers[name].each{|b|
+        b.call
+      }
+    end
+  end
 
-	# :section: job-handling
-	# These functions add support for event-Handling within Entities' jobs. This is (will be) used for
-	# scripting and AI.
-	#	
-	# FIXME: THis should be moved somewhere else (?)
-	#
-	# For more information on scripting link:files/ruby/scripting/README.html
+  # :section: job-handling
+  # These functions add support for event-Handling within Entities' jobs. This is (will be) used for
+  # scripting and AI.
+  #  
+  # FIXME: THis should be moved somewhere else (?)
+  #
+  # For more information on scripting link:files/ruby/scripting/README.html
 
-	def newFightJob(p,target,distance)
-		@fightTarget=target
-		super
-		doEvent(:eventNewFightJob)
-	end
-	def newRestJob(t,working=false)
-		super
-		doEvent(:eventNewRestJob)
-	end
+  def newFightJob(p,target,distance)
+    @fightTarget=target
+    super
+    doEvent(:eventNewFightJob)
+  end
+  def newRestJob(t,working=false)
+    super
+    doEvent(:eventNewRestJob)
+  end
 
-	# :section eventHandling
-	def eventNoJob
-		super
-		doEvent(:eventNoJob)
-	end
-	def eventJobFinished
-		super
-		doEvent(:eventJobFinished)
-	end
+  # :section eventHandling
+  def eventNoJob
+    super
+    doEvent(:eventNoJob)
+  end
+  def eventJobFinished
+    super
+    doEvent(:eventJobFinished)
+  end
 
-	def experienceFull
-		super
-		self.experience=1
-	end
+  def experienceFull
+    super
+    self.experience=1
+  end
 
 
-	# :section: status-information
+  # :section: status-information
 
-	# an event-handler for resources being changed. In this case a possible view on the inventory is updated
-	def resourceChanged	
-		super
-		begin
-			AntInventory.update(self)
-		rescue NameError
-		end
-	end
+  # an event-handler for resources being changed. In this case a possible view on the inventory is updated
+  def resourceChanged  
+    super
+    begin
+      AntInventory.update(self)
+    rescue NameError
+    end
+  end
 
-	# is this entity under attack - here this is always false, because it doesn't make sense for all entities
-	def underAttack
-		false
-	end
+  # is this entity under attack - here this is always false, because it doesn't make sense for all entities
+  def underAttack
+    false
+  end
 
-	# :section: state-changes
+  # :section: state-changes
 
-	# set a mesh for this entity - have a look at AntModels for more information on how this works
-	# * normally you give a subtype or nothing at all to this function and AntModels will take care of the right
-	#   mesh. *sym* override the current entities type.
-	# * you can pipe in a SceneNode-based object through *subtype* though this is no good !
-	def setMesh(subtype="",sym=nil)
-		return if getMap.getScene.nil?
-		if subtype.is_a?(SceneNode)
-			raise  "THIS SHOULD NOT BE USED ANY LONGER: setMesh(realMesh) !!!!!!!!!!!!"
-			super(subtype) # wrapper
-			setupRing
-			return subtype
-		end
-		@map={:AntSack=>:sack}
-		t=self.class.to_s
-		t=t.gsub("Ant","").downcase
-		t=t.to_sym
-		if sym
-			t=sym
-		end
+  # set a mesh for this entity - have a look at AntModels for more information on how this works
+  # * normally you give a subtype or nothing at all to this function and AntModels will take care of the right
+  #   mesh. *sym* override the current entities type.
+  # * you can pipe in a SceneNode-based object through *subtype* though this is no good !
+  def setMesh(subtype="",sym=nil)
+    return if getMap.getScene.nil?
+    if subtype.is_a?(SceneNode)
+      raise  "THIS SHOULD NOT BE USED ANY LONGER: setMesh(realMesh) !!!!!!!!!!!!"
+      super(subtype) # wrapper
+      setupRing
+      return subtype
+    end
+    @map={:AntSack=>:sack}
+    t=self.class.to_s
+    t=t.gsub("Ant","").downcase
+    t=t.to_sym
+    if sym
+      t=sym
+    end
     mesh=AntModels.createModel(self,t,subtype)
     #print "MESH for #{self}:#{mesh} "
     #pp mesh
-		super(mesh)
+    super(mesh)
     #pp getMesh.class,getMesh
-		setupRing
-		return mesh
-	end
+    setupRing
+    return mesh
+  end
 
 
 
-	# :section: hovering/selection display with ring
-	def hovered=(s)
-		@hovered=s
-		updateRingColor
-	end
-	def selected=(s)
-		@selected=s
-		updateRingColor
-	end
+  # :section: hovering/selection display with ring
+  def hovered=(s)
+    @hovered=s
+    updateRingColor
+  end
+  def selected=(s)
+    @selected=s
+    updateRingColor
+  end
 
-	def getRing
-		makeRingMesh
-	end
+  def getRing
+    makeRingMesh
+  end
 
-	def setupRing
-		@ring=getRing
-		return if @ring.nil?
-		if @selected
-			#f6c108
-			@ring.setRingColor(AGVector4.new(1,0.7,0.1,0.8))
-		else
-			@ring.setRingColor(AGVector4.new(0.7,0.7,1,0.8))
-		end
-		addMesh(@ring,AGVector3.new(0,0,0))
-		#@ring.setVisible(false)
-		updateRingColor
-	end
+  def setupRing
+    @ring=getRing
+    return if @ring.nil?
+    if @selected
+      #f6c108
+      @ring.setRingColor(AGVector4.new(1,0.7,0.1,0.8))
+    else
+      @ring.setRingColor(AGVector4.new(0.7,0.7,1,0.8))
+    end
+    addMesh(@ring,AGVector3.new(0,0,0))
+    #@ring.setVisible(false)
+    updateRingColor
+  end
 
 private
-	def updateRingColor
-		setupRing if @ring.nil?
-		@ring.setVisible((@hovered or @selected))
-		if @hovered and not @selected
-			@ring.setRingColor(AGVector4.new(0.7,0.7,1,0.8))
-		elsif @selected
-			@ring.setRingColor(AGVector4.new(1,0.7,0.1,0.8))
-		end
-	end
+  def updateRingColor
+    setupRing if @ring.nil?
+    @ring.setVisible((@hovered or @selected))
+    if @hovered and not @selected
+      @ring.setRingColor(AGVector4.new(0.7,0.7,1,0.8))
+    elsif @selected
+      @ring.setRingColor(AGVector4.new(1,0.7,0.1,0.8))
+    end
+  end
 public
 
-	# :section: deprecated
+  # :section: deprecated
 
 
-	# FIXME: remove this - this is a backward-compability function 
-	def get
-		self
-	end
+  # FIXME: remove this - this is a backward-compability function 
+  def get
+    self
+  end
 end

Modified: antargis/trunk/ruby/entities/spec/entities.rb
===================================================================
--- antargis/trunk/ruby/entities/spec/entities.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/entities/spec/entities.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -4,26 +4,26 @@
 require 'ruby/map.rb'
 
 class AntRubyEntity
-	alias :resourceChangedOld :resourceChanged
-	def resourceChanged
-		$ok=true
-	end
+  alias :resourceChangedOld :resourceChanged
+  def resourceChanged
+    $ok=true
+  end
 end
 
 (AntRubyEntity.descendants-[AntRubyEntity]).each{|aClass|
-	describe aClass do
-		it "(#{aClass}) should call AntRubyEntity.resourceChanged when resourceChanges is called on a descendant" do
-			#puts "TESTING #{aClass}"
-			$ok=false
-			app=GLApp.new(800,600)
-			scene=app.getScene
-			map=AntRubyMap.new(app,scene,32,32)
-			object=aClass.new(map)
-			object.setPos(AGVector2.new(1,1))
-			object.resourceChanged
-			$ok.should == true
-			
-		end
-		it "should run without a scene-object defined"
-	end
-}
\ No newline at end of file
+  describe aClass do
+    it "(#{aClass}) should call AntRubyEntity.resourceChanged when resourceChanges is called on a descendant" do
+      #puts "TESTING #{aClass}"
+      $ok=false
+      app=GLApp.new(800,600)
+      scene=app.getScene
+      map=AntRubyMap.new(app,scene,32,32)
+      object=aClass.new(map)
+      object.setPos(AGVector2.new(1,1))
+      object.resourceChanged
+      $ok.should == true
+      
+    end
+    it "should run without a scene-object defined"
+  end
+}

Modified: antargis/trunk/ruby/game_result.rb
===================================================================
--- antargis/trunk/ruby/game_result.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/game_result.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,6 +1,6 @@
 class GameResult
-	attr_reader :won
-	def initialize(pWon="canceled")
-		@won=pWon
-	end
-end
\ No newline at end of file
+  attr_reader :won
+  def initialize(pWon="canceled")
+    @won=pWon
+  end
+end

Modified: antargis/trunk/ruby/gen_tree.rb
===================================================================
--- antargis/trunk/ruby/gen_tree.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/gen_tree.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,67 +1,67 @@
 
 def genTree
-	f=loadFile("data/models/tree4.ant2")
-	opt=loadFromText(f,true,0.5)
-	
-		r=4
-		y0=11
-		y1=12
-		stepy=0.7
-		for k in 0..9
-			r=[1.3,1.3,1.5,2,2.5,3,3.5,4,4.3,4.5,4.5][k]
-			if k<3
-				stepy=0.5
-			else
-				stepy=1
-			end
-		
-			segs=8
-			for i in 0..(segs-1)
-				a0=2*Math::PI/segs*i
-				a1=2*Math::PI/segs*(i+1)
-			
-				mv0=MeshVertex.new
-				mv1=MeshVertex.new
-				mv2=MeshVertex.new
-			
-				mv0.c=AGVector4.new(1,1,1,1)
-				mv1.c=AGVector4.new(1,1,1,1)
-				mv2.c=AGVector4.new(1,1,1,1)
-				
-				mv0.v=AGVector4.new(Math::cos(a0)*r,Math::sin(a0)*r,y0,1)
-				mv1.v=AGVector4.new(Math::cos(a1)*r,Math::sin(a1)*r,y0,1)
-				mv2.v=AGVector4.new(0,0,y1,1)
-				
-				n=(mv0.v-mv1.v)%(mv2.v-mv1.v)
-			
-				n=n.dim3
-				n=-n.normalized	
-			
-				mv0.n=n
-				mv1.n=n
-				mv2.n=n
-				
-				middle=AGVector2.new(0.5,0.75)
-				
-				mv0.t=AGVector2.new(Math::cos(a0+k),Math::sin(a0+k)*0.5)*0.5+middle
-				mv1.t=AGVector2.new(Math::cos(a1+k),Math::sin(a1+k)*0.5)*0.5+middle
-				mv2.t=middle
-				
-				# front
-				opt.add(mv2)
-				opt.add(mv1)
-				opt.add(mv0)		
-			end
-			y0-=stepy
-			y1-=stepy
-		end
-	
-	va=opt.getArray
-	data=MeshData.new(va,"data/textures/models/fir5.png",true)
-	data.setTransparent(true)
-	data.save("treetest2.ant2")
-	puts data.getTriangles
-	data
+  f=loadFile("data/models/tree4.ant2")
+  opt=loadFromText(f,true,0.5)
+  
+    r=4
+    y0=11
+    y1=12
+    stepy=0.7
+    for k in 0..9
+      r=[1.3,1.3,1.5,2,2.5,3,3.5,4,4.3,4.5,4.5][k]
+      if k<3
+        stepy=0.5
+      else
+        stepy=1
+      end
+    
+      segs=8
+      for i in 0..(segs-1)
+        a0=2*Math::PI/segs*i
+        a1=2*Math::PI/segs*(i+1)
+      
+        mv0=MeshVertex.new
+        mv1=MeshVertex.new
+        mv2=MeshVertex.new
+      
+        mv0.c=AGVector4.new(1,1,1,1)
+        mv1.c=AGVector4.new(1,1,1,1)
+        mv2.c=AGVector4.new(1,1,1,1)
+        
+        mv0.v=AGVector4.new(Math::cos(a0)*r,Math::sin(a0)*r,y0,1)
+        mv1.v=AGVector4.new(Math::cos(a1)*r,Math::sin(a1)*r,y0,1)
+        mv2.v=AGVector4.new(0,0,y1,1)
+        
+        n=(mv0.v-mv1.v)%(mv2.v-mv1.v)
+      
+        n=n.dim3
+        n=-n.normalized  
+      
+        mv0.n=n
+        mv1.n=n
+        mv2.n=n
+        
+        middle=AGVector2.new(0.5,0.75)
+        
+        mv0.t=AGVector2.new(Math::cos(a0+k),Math::sin(a0+k)*0.5)*0.5+middle
+        mv1.t=AGVector2.new(Math::cos(a1+k),Math::sin(a1+k)*0.5)*0.5+middle
+        mv2.t=middle
+        
+        # front
+        opt.add(mv2)
+        opt.add(mv1)
+        opt.add(mv0)    
+      end
+      y0-=stepy
+      y1-=stepy
+    end
+  
+  va=opt.getArray
+  data=MeshData.new(va,"data/textures/models/fir5.png",true)
+  data.setTransparent(true)
+  data.save("treetest2.ant2")
+  puts data.getTriangles
+  data
 end
 
 

Modified: antargis/trunk/ruby/gui/ag_tools.rb
===================================================================
--- antargis/trunk/ruby/gui/ag_tools.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/gui/ag_tools.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -36,140 +36,140 @@
 # and also include this module into each class in which you want to use this :-)
 # this is not needed if you're using an AGWidget or AGApplication object
 module AGHandler
-	# clear all handlers
-	def clearHandlers
-		@handlers={}
-	end
-	# add Event Handler - this function should go into AGRubyApp
-	def addHandler(object,event,func)
-		if not defined? @handlers then
-			@handlers={}
-		end
-		if object.nil? then
-			raise "AGHandler.addHandler: object does not exist!"
-		else
-			object.send(event).connect(self)
-			hname=makeHandlerName(object,event)
-			#hname=object.getName+":"+event.to_s
-			@handlers[hname]||=[]
-			@handlers[hname].push(func)
-		end
-	end
-	# event dispatcher
-	def signal(e)
-		@handlers||={}
-		mcaller=e.getCaller
-		evName=makeHandlerName(mcaller,e.getName)
-		#callerName=e.getCaller.getName
-		#evName=callerName+":"+e.getName
-		#puts "#{callerName} #{evName}"
-		if @handlers.has_key?(evName) then
-			value=false
-			@handlers[evName].each{|handler|
-				m=method(handler)
-				if m.arity==1 || m.arity==-1
-					# ok
-					if self.send(handler,e)
-						value=true
-					end
-				elsif m.arity==0
-					if self.send(handler)
-						value=true
-					end
-				else
-					puts "AR:",m.arity
-					raise "SLOT is invalid! event:"+evName+" slotname:"+handler.to_s+" in class:"+(self.class).to_s
-				end
-			}
-			return value
-		end
-		return super(e)
-	end
+  # clear all handlers
+  def clearHandlers
+    @handlers={}
+  end
+  # add Event Handler - this function should go into AGRubyApp
+  def addHandler(object,event,func)
+    if not defined? @handlers then
+      @handlers={}
+    end
+    if object.nil? then
+      raise "AGHandler.addHandler: object does not exist!"
+    else
+      object.send(event).connect(self)
+      hname=makeHandlerName(object,event)
+      #hname=object.getName+":"+event.to_s
+      @handlers[hname]||=[]
+      @handlers[hname].push(func)
+    end
+  end
+  # event dispatcher
+  def signal(e)
+    @handlers||={}
+    mcaller=e.getCaller
+    evName=makeHandlerName(mcaller,e.getName)
+    #callerName=e.getCaller.getName
+    #evName=callerName+":"+e.getName
+    #puts "#{callerName} #{evName}"
+    if @handlers.has_key?(evName) then
+      value=false
+      @handlers[evName].each{|handler|
+        m=method(handler)
+        if m.arity==1 || m.arity==-1
+          # ok
+          if self.send(handler,e)
+            value=true
+          end
+        elsif m.arity==0
+          if self.send(handler)
+            value=true
+          end
+        else
+          puts "AR:",m.arity
+          raise "SLOT is invalid! event:"+evName+" slotname:"+handler.to_s+" in class:"+(self.class).to_s
+        end
+      }
+      return value
+    end
+    return super(e)
+  end
 
-	private
-	def makeHandlerName(object,event)
-		#if object.respond_to?(:getName)
-		#	return object.getName+":"+event.to_s
-		#else
-			return object.object_id.to_s+":"+event.to_s
-		#end
-	end
+  private
+  def makeHandlerName(object,event)
+    #if object.respond_to?(:getName)
+    #  return object.getName+":"+event.to_s
+    #else
+      return object.object_id.to_s+":"+event.to_s
+    #end
+  end
 end
 
 # this function adds a signal to the current object
 # you can call this with signalName(e) afterwards
 def addSignal(name)
-	eval <<EOT
+  eval <<EOT
 class #{self.class}
-	def #{name}(e=nil)
-		if e
-			e.setCaller(self)
-			return @#{name}.signal(e)
-		else
-			return @#{name}
-		end
-	end
+  def #{name}(e=nil)
+    if e
+      e.setCaller(self)
+      return @#{name}.signal(e)
+    else
+      return @#{name}
+    end
+  end
 end
 EOT
-	eval("@#{name}=AGSignal.new(self,'#{name}')\n")
+  eval("@#{name}=AGSignal.new(self,'#{name}')\n")
 end
 
 module Antargis
-	class AGApplication
-		include AGHandler
-	end
-	class AGWidget
-		include AGHandler
-	end
+  class AGApplication
+    include AGHandler
+  end
+  class AGWidget
+    include AGHandler
+  end
 end
 
 class Array
-	# extend Array-class with a shuffle function
-	def shuffle
-		sort{0.5 <=> rand}
-	end
+  # extend Array-class with a shuffle function
+  def shuffle
+    sort{0.5 <=> rand}
+  end
 end
 # just in case it isn't defined
 class AGString
 end
 # class String
-# 	alias oldadd +
-# 	def +(p)
-# 		#puts "puh"
-# 		if p.is_a?(AGString)
-# 			p=p.to_s
-# 		end
-# 		oldadd(p)
-# 	end
+#   alias oldadd +
+#   def +(p)
+#     #puts "puh"
+#     if p.is_a?(AGString)
+#       p=p.to_s
+#     end
+#     oldadd(p)
+#   end
 # end
 
 module Antargis
-	class AGVector3
-		def x=(p)
-			setX(p)
-		end
-		def y=(p)
-			setY(p)
-		end
-		def z=(p)
-			setZ(p)
-		end
-	end
-	class AGVector2
-		def x=(p)
-			setX(p)
-		end
-		def y=(p)
-			setY(p)
-		end
-		def _dump(depth)
-			[x,y].pack("gg")
-		end
-		def AGVector2._load(s)
-			a,b=s.unpack("gg")
-			AGVector2.new(a,b)
-		end
-	end
+  class AGVector3
+    def x=(p)
+      setX(p)
+    end
+    def y=(p)
+      setY(p)
+    end
+    def z=(p)
+      setZ(p)
+    end
+  end
+  class AGVector2
+    def x=(p)
+      setX(p)
+    end
+    def y=(p)
+      setY(p)
+    end
+    def _dump(depth)
+      [x,y].pack("gg")
+    end
+    def AGVector2._load(s)
+      a,b=s.unpack("gg")
+      AGVector2.new(a,b)
+    end
+  end
   class AGRubyMessageObject<AGMessageObject
     def initialize()
       super

Modified: antargis/trunk/ruby/gui/testing.rb
===================================================================
--- antargis/trunk/ruby/gui/testing.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/gui/testing.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,114 +1,114 @@
 require 'ruby/spec_helper.rb'
 module TestModule
-	attr_reader :quitCounter
-	def step
-		run
-		puts "step end"
-	end
-	def eventFrame(t)
-		super
-		puts "FRAME - try Quit..."
-		tryQuit
-		true
-	end
-	def tryQuit
-		super
-		@quitCounter||=0
-		@quitCounter+=1
-	end
+  attr_reader :quitCounter
+  def step
+    run
+    puts "step end"
+  end
+  def eventFrame(t)
+    super
+    puts "FRAME - try Quit..."
+    tryQuit
+    true
+  end
+  def tryQuit
+    super
+    @quitCounter||=0
+    @quitCounter+=1
+  end
 end
 
 def makeTestAppClass(pClass)
-	mClass=Class.new(pClass)
-	mClass.class_eval{||include TestModule}
-	mClass
+  mClass=Class.new(pClass)
+  mClass.class_eval{||include TestModule}
+  mClass
 end
 # class TestApp<AntEditorApp
-# 	def step
-# 		run
-# 	end
-# 	def eventFrame(t)
-# 		puts "FRAME"
-# 		super
-# 		tryQuit
-# 		true
-# 	end
+#   def step
+#     run
+#   end
+#   def eventFrame(t)
+#     puts "FRAME"
+#     super
+#     tryQuit
+#     true
+#   end
 # end
 
 class TestWidget
-	attr_reader :widget
-	def initialize(widget)
-		@widget=widget
-	end
-	def click
-# 		r=@widget.getScreenRect
-# 		x=r.x+r.w/2
-# 		y=r.y+r.h/2
-# 		pp r,x,y
+  attr_reader :widget
+  def initialize(widget)
+    @widget=widget
+  end
+  def click
+#     r=@widget.getScreenRect
+#     x=r.x+r.w/2
+#     y=r.y+r.h/2
+#     pp r,x,y
 # 
-# 		sdlEvent=toSDLEvent("SDL_MOUSEBUTTONDOWN:0:1:1:#{x.to_i}:#{y.to_i}")
-# 		@widget.eventMouseButtonDown(newEvent(nil,"",sdlEvent))
-# 		sdlEvent=toSDLEvent("SDL_MOUSEBUTTONUP:0:1:1:#{x.to_i}:#{y.to_i}")
-# 		event=newEvent(nil,"",sdlEvent)
-# 		@widget.eventMouseButtonUp(event)
+#     sdlEvent=toSDLEvent("SDL_MOUSEBUTTONDOWN:0:1:1:#{x.to_i}:#{y.to_i}")
+#     @widget.eventMouseButtonDown(newEvent(nil,"",sdlEvent))
+#     sdlEvent=toSDLEvent("SDL_MOUSEBUTTONUP:0:1:1:#{x.to_i}:#{y.to_i}")
+#     event=newEvent(nil,"",sdlEvent)
+#     @widget.eventMouseButtonUp(event)
 
-# # 		@widget.eventMouseButtonDown(AGEvent.new(@widget, at widget.getName))
-# # 		@widget.eventMouseButtonDown(AGEvent.new(@widget, at widget.getName))
-# 		@widget.sigClick.signal(AGEvent.new(@widget, at widget.getName))
- 		@widget.doClick(AGEvent.new(@widget, at widget.getName))
-	end
-	def child(widgetName)
-		return TestWidget.new(nil) if @widget.nil?
-		TestWidget.new(@widget.getChild(widgetName))
-	end
-	def visible
-		return false if @widget.nil?
-		@widget.visible
-	end
-	def valid
-		(not @widget.nil?)
-	end
-	def is_a?(type)
-		@widget.is_a?(type)
-	end
-	def method_missing(*s)
-		@widget.send(*s)
-	end
-	def printVisible
-		widget=@widget
-		puts "--"
-		while widget
-			puts "#{widget} #{widget.getName} #{widget.visible}"
-			widget=widget.getParent
-		end
-		puts "--"
-	end
-	def kind_of?(type)
-		@widget.kind_of?(type)
-	end
-	def instance_of?(type)
-		@widget.instance_of?(type)
-	end
-	def visible?
-		@widget.visible
-	end
-	def nil?
-		@widget.nil?
-	end
-	def checked?
-		@widget.isChecked
-	end
+# #     @widget.eventMouseButtonDown(AGEvent.new(@widget, at widget.getName))
+# #     @widget.eventMouseButtonDown(AGEvent.new(@widget, at widget.getName))
+#     @widget.sigClick.signal(AGEvent.new(@widget, at widget.getName))
+     @widget.doClick(AGEvent.new(@widget, at widget.getName))
+  end
+  def child(widgetName)
+    return TestWidget.new(nil) if @widget.nil?
+    TestWidget.new(@widget.getChild(widgetName))
+  end
+  def visible
+    return false if @widget.nil?
+    @widget.visible
+  end
+  def valid
+    (not @widget.nil?)
+  end
+  def is_a?(type)
+    @widget.is_a?(type)
+  end
+  def method_missing(*s)
+    @widget.send(*s)
+  end
+  def printVisible
+    widget=@widget
+    puts "--"
+    while widget
+      puts "#{widget} #{widget.getName} #{widget.visible}"
+      widget=widget.getParent
+    end
+    puts "--"
+  end
+  def kind_of?(type)
+    @widget.kind_of?(type)
+  end
+  def instance_of?(type)
+    @widget.instance_of?(type)
+  end
+  def visible?
+    @widget.visible
+  end
+  def nil?
+    @widget.nil?
+  end
+  def checked?
+    @widget.isChecked
+  end
 end
 
 
 module GuiTest
 protected
-	def widget(widgetName)
-		TestWidget.new(@app.getMainWidget.getChild(widgetName))
-	end
-	def clickScreen(x,y)
-	  click(AGVector2.new(x,y))
-	end
+  def widget(widgetName)
+    TestWidget.new(@app.getMainWidget.getChild(widgetName))
+  end
+  def clickScreen(x,y)
+    click(AGVector2.new(x,y))
+  end
   
   def click(pos)
     mouseDown(pos)

Modified: antargis/trunk/ruby/intro.rb
===================================================================
--- antargis/trunk/ruby/intro.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/intro.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,24 +7,24 @@
 # draws a black rectangle with varying alpha-channel. This way you
 # can fade in and out pictures and text-displays.
 class BlackFade<AGWidget
-	# alpha-value is set to 0 by default
-	def initialize(p,r)
-		super(p,r)
-		@r=r
-		@alpha=0.0
-	end
-	# set the alpha-value *a* in range from 0.0 to 1.0
-	# the default-value is 0
-	def setAlpha(a)
-		@alpha=a
-		queryRedraw
-	end
+  # alpha-value is set to 0 by default
+  def initialize(p,r)
+    super(p,r)
+    @r=r
+    @alpha=0.0
+  end
+  # set the alpha-value *a* in range from 0.0 to 1.0
+  # the default-value is 0
+  def setAlpha(a)
+    @alpha=a
+    queryRedraw
+  end
 
-	# draws the black rectangle with set pre-set alpha-value
-	def draw(painter)
-		#painter.fillRect(@r,AGColor.new(0,0,0,0x1F))
-		painter.fillRect(@r,AGColor.new(0,0,0,(0xFF*@alpha).to_i))
-	end
+  # draws the black rectangle with set pre-set alpha-value
+  def draw(painter)
+    #painter.fillRect(@r,AGColor.new(0,0,0,0x1F))
+    painter.fillRect(@r,AGColor.new(0,0,0,(0xFF*@alpha).to_i))
+  end
 end
 
 
@@ -32,127 +32,127 @@
 # It's able to display images and text-elements (that are drawn using the intro.font-Font from the theme)
 # Each image/text-element is faded-in and faded-out. While the intro runs some music-track is played
 class IntroApp<AntApplication
-	include AGHandler
-	def initialize
-		puts "introApp..."
-		super
-		puts "introApp!"
-		
-		@pics=["data/gui/rough_lands.png","data/gui/strong_heroes.png","data/gui/logoGold.png","data/gui/your_mission.png","data/gui/unify_the_people.png","data/gui/castle_small.png"]
+  include AGHandler
+  def initialize
+    puts "introApp..."
+    super
+    puts "introApp!"
+    
+    @pics=["data/gui/rough_lands.png","data/gui/strong_heroes.png","data/gui/logoGold.png","data/gui/your_mission.png","data/gui/unify_the_people.png","data/gui/castle_small.png"]
 
-		@pics=["rough lands","strong heroes","data/gui/logoGold.png","your mission","unify the people","data/gui/castle_small.png"]
+    @pics=["rough lands","strong heroes","data/gui/logoGold.png","your mission","unify the people","data/gui/castle_small.png"]
 
-		font=getTheme.getFont("intro.font")
-		@surfaces=@pics.collect{|x|
-			r=nil
-			if x=~/\.png/ or x=~/\.jpg/
-				r=AGSurface.load(x)
-			else
-				r=getFontEngine.renderText(0,0,_(x),font)
-			end
-			r
-		}
-		@s=0
-		@img=AGImage.new(nil,AGRect.new(0,0,getScreen.getWidth,getScreen.getHeight), at surfaces[0],false)
-		@black=BlackFade.new(@img,AGRect.new(0,0,getScreen.getWidth,getScreen.getHeight))
-		@img.addChild(@black)
-		setMainWidget(@img)
-		@time=0
-		
-		@blendin=0.9
-		@blendout=0.6
-		@show=1.2
-		@hide=0.3
-		@phase=0
-		@phases=[2,2,2,1]
-		getSoundManager.playMp3("data/music/battle1.ogg")
-		
-		addHandler(getSoundManager,:sigMp3Finished,:musicEnd)
-	end
-	
+    font=getTheme.getFont("intro.font")
+    @surfaces=@pics.collect{|x|
+      r=nil
+      if x=~/\.png/ or x=~/\.jpg/
+        r=AGSurface.load(x)
+      else
+        r=getFontEngine.renderText(0,0,_(x),font)
+      end
+      r
+    }
+    @s=0
+    @img=AGImage.new(nil,AGRect.new(0,0,getScreen.getWidth,getScreen.getHeight), at surfaces[0],false)
+    @black=BlackFade.new(@img,AGRect.new(0,0,getScreen.getWidth,getScreen.getHeight))
+    @img.addChild(@black)
+    setMainWidget(@img)
+    @time=0
+    
+    @blendin=0.9
+    @blendout=0.6
+    @show=1.2
+    @hide=0.3
+    @phase=0
+    @phases=[2,2,2,1]
+    getSoundManager.playMp3("data/music/battle1.ogg")
+    
+    addHandler(getSoundManager,:sigMp3Finished,:musicEnd)
+  end
+  
 
-	# if a key was pressed, we cancel the intro playing
-	def eventKeyDown(e)
-		cancel
-		return super
-	end
-	
-	# cancel the intro
-	# resets the *@phases*
-	def cancel
-		@canceled=true
-		@phases=[0.2,0.2,2,10]
-	end	
+  # if a key was pressed, we cancel the intro playing
+  def eventKeyDown(e)
+    cancel
+    return super
+  end
+  
+  # cancel the intro
+  # resets the *@phases*
+  def cancel
+    @canceled=true
+    @phases=[0.2,0.2,2,10]
+  end  
 
-	# if the music has finished, we cancel the intro
-	def musicEnd
-		cancel
-	end
-	
+  # if the music has finished, we cancel the intro
+  def musicEnd
+    cancel
+  end
+  
 
-	# this function is called, when you press F10 to quit the application
-	# the first call cancels the intro (thus it will still fade out)
-	# the second call will quit the intro directly
-	def tryQuit
-		if @canceled
-			#getSoundManager.stopMp3
-			#getSoundManager.fadeOutMusic(1000)
-			super
-		else
-			cancel
-		end
-	end
+  # this function is called, when you press F10 to quit the application
+  # the first call cancels the intro (thus it will still fade out)
+  # the second call will quit the intro directly
+  def tryQuit
+    if @canceled
+      #getSoundManager.stopMp3
+      #getSoundManager.fadeOutMusic(1000)
+      super
+    else
+      cancel
+    end
+  end
 
-	# this function does:
-	# * increase the phase - set alpha for BlackFade-Widget
-	# * switch to newer textures/text-elements
-	# * quit the intro, when its finished
-	def checkPhase
-		#puts "#{@time}>#{@phases[@phase]}"
-		if @time>@phases[@phase]
-			@time-=@phases[@phase]
-			@phase+=1
-			if @phase==4
-				@phase=0
-			elsif @phase==3 # switch surface early, so there won't be a timing problem
-				@s=@s+1
-				if @s==@surfaces.length
-					@s=0
-					@canceled=true
-				end
-				if @surfaces[@s].is_a?(AGSurface)
-					@img.setSurface(@surfaces[@s])
-				else
-					@img.setTexture(@surfaces[@s])
-				end
-			end
-		end
-		case @phase
-			when 0
-				@black.setAlpha(1- at time/@phases[@phase])
-			when 2
-				@black.setAlpha(@time/@phases[@phase])
-			when 3
-				if @canceled
-					tryQuit
-				end
-		end
-		@img.redraw
-	end
-	
-	# gets called in each frame (and sets a delay of 10ms between frames)
-	def eventFrame(t)
-		@time+=t
-		checkPhase
-		delay(10)
-		return true
-	end
+  # this function does:
+  # * increase the phase - set alpha for BlackFade-Widget
+  # * switch to newer textures/text-elements
+  # * quit the intro, when its finished
+  def checkPhase
+    #puts "#{@time}>#{@phases[@phase]}"
+    if @time>@phases[@phase]
+      @time-=@phases[@phase]
+      @phase+=1
+      if @phase==4
+        @phase=0
+      elsif @phase==3 # switch surface early, so there won't be a timing problem
+        @s=@s+1
+        if @s==@surfaces.length
+          @s=0
+          @canceled=true
+        end
+        if @surfaces[@s].is_a?(AGSurface)
+          @img.setSurface(@surfaces[@s])
+        else
+          @img.setTexture(@surfaces[@s])
+        end
+      end
+    end
+    case @phase
+      when 0
+        @black.setAlpha(1- at time/@phases[@phase])
+      when 2
+        @black.setAlpha(@time/@phases[@phase])
+      when 3
+        if @canceled
+          tryQuit
+        end
+    end
+    @img.redraw
+  end
+  
+  # gets called in each frame (and sets a delay of 10ms between frames)
+  def eventFrame(t)
+    @time+=t
+    checkPhase
+    delay(10)
+    return true
+  end
 
-	# when a mouse-button is clicked the intro is canceled
-	def eventMouseButtonDown(e)
-	  puts "HU"
-		tryQuit
-		return super(e)
-	end
-	
+  # when a mouse-button is clicked the intro is canceled
+  def eventMouseButtonDown(e)
+    puts "HU"
+    tryQuit
+    return super(e)
+  end
+  
 end

Modified: antargis/trunk/ruby/jobs/ant_state_machine.rb
===================================================================
--- antargis/trunk/ruby/jobs/ant_state_machine.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/jobs/ant_state_machine.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,181 +1,181 @@
 class BaseState
   attr_reader :started
-	@@states={}
-	@@edges={}
-	@@endstates={}
-	@@startstate={}
-	def BaseState.state(p)
-	  @started=false
-		s=@@states[self]
-		s||={}
-		p.each{|k,v|s[k]=v}
-		@@states[self]=s
-	end
-	def BaseState.edge(v0,v1,f=nil)
-		@@edges[self]||=[]
-		@@edges[self]<<[v0,v1,f]
-	end
-	def BaseState.startState(s)
-		#puts "setting startstate for #{self}:#{s}"
-		@@startstate[self]=s
-	end
-	def BaseState.endState(s)
-		@@endstates[self]||=[]
-		@@endstates[self].push(s)
-	end
+  @@states={}
+  @@edges={}
+  @@endstates={}
+  @@startstate={}
+  def BaseState.state(p)
+    @started=false
+    s=@@states[self]
+    s||={}
+    p.each{|k,v|s[k]=v}
+    @@states[self]=s
+  end
+  def BaseState.edge(v0,v1,f=nil)
+    @@edges[self]||=[]
+    @@edges[self]<<[v0,v1,f]
+  end
+  def BaseState.startState(s)
+    #puts "setting startstate for #{self}:#{s}"
+    @@startstate[self]=s
+  end
+  def BaseState.endState(s)
+    @@endstates[self]||=[]
+    @@endstates[self].push(s)
+  end
 
-	def BaseState.inheritMachine
-		me=ancestors[0]
-		anc=ancestors[1]
-		@@states[me]=@@states[anc].dup
-		@@edges[me]=@@edges[anc].dup
-		@@endstates[me]=@@endstates[anc].dup
-		@@startstate[me]=@@startstate[anc]
-	end
-	
-	def initialize(startState=nil)
-		@states={}
-		@@states[self.class].each{|k,v|@states[k]=v.new;@states[k].machine=self}
-		@state=startState
-		@state||=@@startstate[self.class]
-		@firstRun=false
-	end
-	
-	def ready
-		return true if @state.nil?
-		if @@endstates[self.class]
-			if @@endstates[self.class].length>0
-				return true if @@endstates[self.class].member?(@state)
-			end
-		end
-		return false
-	end		
+  def BaseState.inheritMachine
+    me=ancestors[0]
+    anc=ancestors[1]
+    @@states[me]=@@states[anc].dup
+    @@edges[me]=@@edges[anc].dup
+    @@endstates[me]=@@endstates[anc].dup
+    @@startstate[me]=@@startstate[anc]
+  end
+  
+  def initialize(startState=nil)
+    @states={}
+    @@states[self.class].each{|k,v|@states[k]=v.new;@states[k].machine=self}
+    @state=startState
+    @state||=@@startstate[self.class]
+    @firstRun=false
+  end
+  
+  def ready
+    return true if @state.nil?
+    if @@endstates[self.class]
+      if @@endstates[self.class].length>0
+        return true if @@endstates[self.class].member?(@state)
+      end
+    end
+    return false
+  end    
 
-	def advance
-		if @states.length==0
-			puts "no states here"
-			return
-		end
-		if hasState
-			stepState
-		end
-	end
+  def advance
+    if @states.length==0
+      puts "no states here"
+      return
+    end
+    if hasState
+      stepState
+    end
+  end
 
-	def firstCall
-	  @started=true
-		enterRecursive
-	end
+  def firstCall
+    @started=true
+    enterRecursive
+  end
 
-	def hasState
-		if @state
-			return (not @states[@state].nil?)
-		end
-		false
-	end
+  def hasState
+    if @state
+      return (not @states[@state].nil?)
+    end
+    false
+  end
 
-	def state
-		if @state
-			if @states[@state]
-				return @states[@state]
-			end
-		end
-		raise "no state defined!"
-	end
-	
-	def stateName
-		@state
-	end
+  def state
+    if @state
+      if @states[@state]
+        return @states[@state]
+      end
+    end
+    raise "no state defined!"
+  end
+  
+  def stateName
+    @state
+  end
 
-	def stateCall(*s)
-		if @state
-			if @states[@state]
-				#puts "(#{s})(#{s[0]})"
-				if @states[@state].respond_to?(s[0])
-					@states[@state].send(*s) #(s[1..-1]))
-				end
-			end
-		end
-	end
+  def stateCall(*s)
+    if @state
+      if @states[@state]
+        #puts "(#{s})(#{s[0]})"
+        if @states[@state].respond_to?(s[0])
+          @states[@state].send(*s) #(s[1..-1]))
+        end
+      end
+    end
+  end
 
 protected
-	def enterRecursive(selftoo=true)
-		#puts "#{self}:enterRecursive"
+  def enterRecursive(selftoo=true)
+    #puts "#{self}:enterRecursive"
 
-		if self.respond_to?("enter") and selftoo
-			#puts "#{self}:enterRecursive - enter..."
-			enter
-			#puts "#{self}:enterRecursive - enter.ok"
-		end
+    if self.respond_to?("enter") and selftoo
+      #puts "#{self}:enterRecursive - enter..."
+      enter
+      #puts "#{self}:enterRecursive - enter.ok"
+    end
 
-		#puts "#{self}:enterRecursive - hasState:#{hasState}"
-		if hasState
-			#puts "#{self}:enterRecursive - respond_to(enterRec):#{state.respond_to?("enterRecursive")}"
-			#puts "#{self}:enterRecursive - state:#{state}"
-			if state.respond_to?("enterRecursive")
-				state.enterRecursive
-			else
-				#puts "#{self}:enterRecursive - statecall-enter..."
-				stateCall("enter")
-			end
-		end
-	end
+    #puts "#{self}:enterRecursive - hasState:#{hasState}"
+    if hasState
+      #puts "#{self}:enterRecursive - respond_to(enterRec):#{state.respond_to?("enterRecursive")}"
+      #puts "#{self}:enterRecursive - state:#{state}"
+      if state.respond_to?("enterRecursive")
+        state.enterRecursive
+      else
+        #puts "#{self}:enterRecursive - statecall-enter..."
+        stateCall("enter")
+      end
+    end
+  end
 
 private
-	def stepState
-		assert {hasState}
-		stateCall("advance")
-		if state.ready
-			toNextState
-		else
-			true
-		end
-	end
-	
-	def toNextState
-		#puts "#{self} toNextState:#{@state}:#{state}"
-		nstate=nil
-		@@edges[self.class].each{|e|
-			if e[0]==@state
-				ok=true
-				if not e[2].nil?
-					ok=self.send(e[2]) #.call
-				end
-				if ok
-					nstate=e[1]
-				end
-			end
-		}
-		if nstate
-			switch2(nstate)
-			return true
-		elsif @@endstates[self.class].member?(@state)
-			switch2(nil)
-		end
-		false
-	end
-	
-	def left
-		@firstRun=false
-	end
-		
-	def switch2(s)
-		stateCall("leave")
-		stateCall("left")
-		@state=s
-		#stateCall("enterRecursive")
-		enterRecursive(false)
-	end
+  def stepState
+    assert {hasState}
+    stateCall("advance")
+    if state.ready
+      toNextState
+    else
+      true
+    end
+  end
+  
+  def toNextState
+    #puts "#{self} toNextState:#{@state}:#{state}"
+    nstate=nil
+    @@edges[self.class].each{|e|
+      if e[0]==@state
+        ok=true
+        if not e[2].nil?
+          ok=self.send(e[2]) #.call
+        end
+        if ok
+          nstate=e[1]
+        end
+      end
+    }
+    if nstate
+      switch2(nstate)
+      return true
+    elsif @@endstates[self.class].member?(@state)
+      switch2(nil)
+    end
+    false
+  end
+  
+  def left
+    @firstRun=false
+  end
+    
+  def switch2(s)
+    stateCall("leave")
+    stateCall("left")
+    @state=s
+    #stateCall("enterRecursive")
+    enterRecursive(false)
+  end
 end
 
 class BaseMachine<BaseState
-# 	def initialize(start=nil)
-# 		super(start)
-# 		if start.nil?
-# 			@state=@@startstate[self.class]
-# 			puts "startstate: #{@@startstate[self.class]}"
-# 		else
-# 			@state=start
-# 		end
-# 	end
+#   def initialize(start=nil)
+#     super(start)
+#     if start.nil?
+#       @state=@@startstate[self.class]
+#       puts "startstate: #{@@startstate[self.class]}"
+#     else
+#       @state=start
+#     end
+#   end
 end
 

Modified: antargis/trunk/ruby/jobs/spec/recruit.rb
===================================================================
--- antargis/trunk/ruby/jobs/spec/recruit.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/jobs/spec/recruit.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -4,57 +4,57 @@
 #require 'ruby/state_machine/ant_hl_job_states.rb'
 
 module Testing
-	@@testing=false
-	def Testing.initTesting
-		return if @@testing
-		@@testing=true
+  @@testing=false
+  def Testing.initTesting
+    return if @@testing
+    @@testing=true
 
-		@@app=AGApplication.new
-		@@scene=Scene.new(800,600)
-	end
+    @@app=AGApplication.new
+    @@scene=Scene.new(800,600)
+  end
 
-	def Testing.getTestMapFor(test)
-		initTesting
-		case test
-			when :recruit
-				#map=AntRubyMap.new(@@app,@@scene,800,600)
-				map=AntRubyMap.new(nil,nil,800,600)
-				map.loadMap("data/levels/tutorial/tutorial0.antlvl")
-				map
-		end
-	end
+  def Testing.getTestMapFor(test)
+    initTesting
+    case test
+      when :recruit
+        #map=AntRubyMap.new(@@app,@@scene,800,600)
+        map=AntRubyMap.new(nil,nil,800,600)
+        map.loadMap("data/levels/tutorial/tutorial0.antlvl")
+        map
+    end
+  end
 end
 
 describe AntHeroRecruitJob,"Test-map for recruiting" do
-	before(:all) do
-		@map=Testing.getTestMapFor(:recruit)
-	end
-	it "should include a hero called 'Rowen'" do
-		@map.getByName("Rowen").should is_a?(AntHero)
-	end
+  before(:all) do
+    @map=Testing.getTestMapFor(:recruit)
+  end
+  it "should include a hero called 'Rowen'" do
+    @map.getByName("Rowen").should is_a?(AntHero)
+  end
 end
 
 describe AntHeroRecruitJob,"A hero recruit job" do
-	before(:each) do
-		@map=Testing.getTestMapFor(:recruit)
+  before(:each) do
+    @map=Testing.getTestMapFor(:recruit)
 
-		@hero=@map.getByName("Rowen")
-	end
+    @hero=@map.getByName("Rowen")
+  end
 
-	it "map should include Rowen" do
-		@hero.should_not be_nil
-	end
+  it "map should include Rowen" do
+    @hero.should_not be_nil
+  end
 
 
-# 	it "should at any time determine how strong the aggression of the hero is and thus should not start new ll-jobs to recruit people if there are already enough"
-# 	it "should take care when the aggression level is raised"
-# 	it "should assign a low-level job to the men - according to the amount of needed people" 
-# 	it "should return each man after recruiting of being recruited to the starting point"
-# 	it "should use sit-formation for the starting-point"
-# 	it "should let people sit, when they don't have anything to do"
+#   it "should at any time determine how strong the aggression of the hero is and thus should not start new ll-jobs to recruit people if there are already enough"
+#   it "should take care when the aggression level is raised"
+#   it "should assign a low-level job to the men - according to the amount of needed people" 
+#   it "should return each man after recruiting of being recruited to the starting point"
+#   it "should use sit-formation for the starting-point"
+#   it "should let people sit, when they don't have anything to do"
 # 
-# 	it "aggression of 3 implies all people"		
-# 	
-# 	it "aggression of 2 implies 2/3 of all people"
-# 	it "aggression of 1 implies 1/3 of all people"
-end
\ No newline at end of file
+#   it "aggression of 3 implies all people"    
+#   
+#   it "aggression of 2 implies 2/3 of all people"
+#   it "aggression of 1 implies 1/3 of all people"
+end

Modified: antargis/trunk/ruby/level.rb
===================================================================
--- antargis/trunk/ruby/level.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/level.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,78 +1,78 @@
 
 class Level
-	def initialize(app)
-		@app=app
-	end
+  def initialize(app)
+    @app=app
+  end
 
-	def eventTrigger(hero,t)
-		return false
-	end
-	def eventOwnerChanged(ent)
-	end
-	def eventHeroDied(ent)
-	end
-	def eventHLJobFinished(hero,job)
-	end
-	def eventDismissed(hero)
-	end
-	def eventLevelStarted
-	end
+  def eventTrigger(hero,t)
+    return false
+  end
+  def eventOwnerChanged(ent)
+  end
+  def eventHeroDied(ent)
+  end
+  def eventHLJobFinished(hero,job)
+  end
+  def eventDismissed(hero)
+  end
+  def eventLevelStarted
+  end
 
-	def saveXML(node)
-		saveLocals(node)
-	end
-	def loadXML(node)
-		loadLocals(node)
-	end
+  def saveXML(node)
+    saveLocals(node)
+  end
+  def loadXML(node)
+    loadLocals(node)
+  end
 
-	# use this to end a level
-	def wonLevel
-		@app.setResult(GameResult.new("won"))
-	end
-	def lostLevel
-		@app.setResult(GameResult.new("lost"))
-	end
-	def endLevel
-		@app.tryQuit
-	end
-	def tellStory(flow)
-		@app.tellStory(flow)
-		@story=flow
-	end
+  # use this to end a level
+  def wonLevel
+    @app.setResult(GameResult.new("won"))
+  end
+  def lostLevel
+    @app.setResult(GameResult.new("lost"))
+  end
+  def endLevel
+    @app.tryQuit
+  end
+  def tellStory(flow)
+    @app.tellStory(flow)
+    @story=flow
+  end
 
 private
-	def getLocals
-		a={}
-		instance_variables.each{|v|
-			a[v]=instance_variable_get(v)
-		}
-		return a
-	end
-	def saveLocals(node)
-		getLocals.each{|n,v|
-			c=node.addChild("local")
-			c.set("name",n)
-			c.set("type",v.class.to_s)
-			c.set("value",v.to_s)
-		}
-	end
-	def loadLocals(node)
-		node.getChildren("local").each{|c|
-			n=c.get("name")
-			v=nil
-			case c.get("type")
-				when "TrueClass"
-					v=true
-				when "FalseClass"
-					v=false
-				when "Fixnum","Bignum"
-					v=c.get("value").to_i
-				when "Float"
-					v=c.get("value").to_f
-				when "String"
-					v=c.get("value")
-			end
-			instance_variable_set(n,v)
-		}
-	end
-end
\ No newline at end of file
+  def getLocals
+    a={}
+    instance_variables.each{|v|
+      a[v]=instance_variable_get(v)
+    }
+    return a
+  end
+  def saveLocals(node)
+    getLocals.each{|n,v|
+      c=node.addChild("local")
+      c.set("name",n)
+      c.set("type",v.class.to_s)
+      c.set("value",v.to_s)
+    }
+  end
+  def loadLocals(node)
+    node.getChildren("local").each{|c|
+      n=c.get("name")
+      v=nil
+      case c.get("type")
+        when "TrueClass"
+          v=true
+        when "FalseClass"
+          v=false
+        when "Fixnum","Bignum"
+          v=c.get("value").to_i
+        when "Float"
+          v=c.get("value").to_f
+        when "String"
+          v=c.get("value")
+      end
+      instance_variable_set(n,v)
+    }
+  end
+end

Modified: antargis/trunk/ruby/mainmenu.rb
===================================================================
--- antargis/trunk/ruby/mainmenu.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/mainmenu.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -43,448 +43,448 @@
 # not to name events the same!
 #
 class AntMenuApp <AntApplication
-	include AGHandler
-	def initialize
-		super()
-		# init menues
-		@menues=[]
-		
-		# setup all the 
-		setupMain
-		setupCredits
-		setupCampaign
-		setupOptions
-		setupLoadMenu
-		setupSingle
-		@sound=true
+  include AGHandler
+  def initialize
+    super()
+    # init menues
+    @menues=[]
+    
+    # setup all the 
+    setupMain
+    setupCredits
+    setupCampaign
+    setupOptions
+    setupLoadMenu
+    setupSingle
+    @sound=true
 
-		# add handler for music finished, simply restart music
-		addHandler(getSoundManager,:sigMp3Finished,:eventMusicEnd)
-	end
+    # add handler for music finished, simply restart music
+    addHandler(getSoundManager,:sigMp3Finished,:eventMusicEnd)
+  end
 
 
-	# overrides AGWidget.setMainWidget, so that the given Widget *w* is
-	# embedded into an outer AGScreenWidget. The reason for this is
-	# redrawing AFAIK (?)
-	def setMainWidget(w)
-		if @myScreen.nil?
-			@myScreen||=AGScreenWidget.new
-			super(@myScreen)
-		end
-		@myScreen.removeChild(@curMainWidget)
-		@myScreen.addChild(w)
-		@curMainWidget=w
-	end
-	
+  # overrides AGWidget.setMainWidget, so that the given Widget *w* is
+  # embedded into an outer AGScreenWidget. The reason for this is
+  # redrawing AFAIK (?)
+  def setMainWidget(w)
+    if @myScreen.nil?
+      @myScreen||=AGScreenWidget.new
+      super(@myScreen)
+    end
+    @myScreen.removeChild(@curMainWidget)
+    @myScreen.addChild(w)
+    @curMainWidget=w
+  end
+  
 
 
-	# :section: set up the menus
+  # :section: set up the menus
 
 
-	# this function sets up the main-menu layout of out data/gui/layout/mainmenu.xml
-	# * event handlers are initialized
-	# * the MainWidget is set to this menu at startup
-	def setupMain()
-		@mainMenu=AGLayout.new(nil)
-		@mainMenu.loadXML(loadFile("data/gui/layout/mainmenu.xml"))
-		@menues.push(@mainMenu)
-		setMainWidget(@mainMenu)
-		addHandler(@mainMenu.getChild("quit"),:sigClick,:eventQuit)
-		addHandler(@mainMenu.getChild("credits"),:sigClick,:eventCredits)
-		addHandler(@mainMenu.getChild("campaign"),:sigClick,:eventCampaign)
-		addHandler(@mainMenu.getChild("single"),:sigClick,:eventSingle)
-		addHandler(@mainMenu.getChild("tutorial"),:sigClick,:eventTutorial)
-		addHandler(@mainMenu.getChild("load"),:sigClick,:eventLoadGame)
-		addHandler(@mainMenu.getChild("options"),:sigClick,:eventOptions)
-	end
+  # this function sets up the main-menu layout of out data/gui/layout/mainmenu.xml
+  # * event handlers are initialized
+  # * the MainWidget is set to this menu at startup
+  def setupMain()
+    @mainMenu=AGLayout.new(nil)
+    @mainMenu.loadXML(loadFile("data/gui/layout/mainmenu.xml"))
+    @menues.push(@mainMenu)
+    setMainWidget(@mainMenu)
+    addHandler(@mainMenu.getChild("quit"),:sigClick,:eventQuit)
+    addHandler(@mainMenu.getChild("credits"),:sigClick,:eventCredits)
+    addHandler(@mainMenu.getChild("campaign"),:sigClick,:eventCampaign)
+    addHandler(@mainMenu.getChild("single"),:sigClick,:eventSingle)
+    addHandler(@mainMenu.getChild("tutorial"),:sigClick,:eventTutorial)
+    addHandler(@mainMenu.getChild("load"),:sigClick,:eventLoadGame)
+    addHandler(@mainMenu.getChild("options"),:sigClick,:eventOptions)
+  end
 
 
 
-	# LOAD GAME MENU
-	def setupLoadMenu
-		@loadMenu=AGLayout.new(nil)
-		@loadMenu.loadXML(loadFile("data/gui/layout/loadmenu.xml"))
-		@menues.push(@loadMenu)
-		addHandler(@loadMenu.getChild("exit"),:sigClick,:eventExit)
-		addHandler(@loadMenu.getChild("list"),:sigSelect,:eventLoadSelect)
-		addHandler(@loadMenu.getChild("doLoad"),:sigClick,:eventLoad)
-		updateLoadMenu
-	end
+  # LOAD GAME MENU
+  def setupLoadMenu
+    @loadMenu=AGLayout.new(nil)
+    @loadMenu.loadXML(loadFile("data/gui/layout/loadmenu.xml"))
+    @menues.push(@loadMenu)
+    addHandler(@loadMenu.getChild("exit"),:sigClick,:eventExit)
+    addHandler(@loadMenu.getChild("list"),:sigSelect,:eventLoadSelect)
+    addHandler(@loadMenu.getChild("doLoad"),:sigClick,:eventLoad)
+    updateLoadMenu
+  end
 
-	def updateLoadMenu
-		fs=getDirectory(getWriteDir+"/savegames").select{|f|f=~/\.antcmp/}.sort.uniq
-		l=@loadMenu.getChild("list")
-		l.clearList
-		fs.each{|f|
-			x=f.gsub(".antcmp","")
-			l.insertItem(f,AGStringUtf8.new(x))  # FIXME: _() ??
-		}
-		if fs.length>0
-			fn="savegames/"+fs[0].gsub("antcmp","png")
-			if findFile(fn)!=""
-				@loadMenu.getChild("screenshot").setSurface(AGSurface.load(fn))
-			end
-		end
-	end
+  def updateLoadMenu
+    fs=getDirectory(getWriteDir+"/savegames").select{|f|f=~/\.antcmp/}.sort.uniq
+    l=@loadMenu.getChild("list")
+    l.clearList
+    fs.each{|f|
+      x=f.gsub(".antcmp","")
+      l.insertItem(f,AGStringUtf8.new(x))  # FIXME: _() ??
+    }
+    if fs.length>0
+      fn="savegames/"+fs[0].gsub("antcmp","png")
+      if findFile(fn)!=""
+        @loadMenu.getChild("screenshot").setSurface(AGSurface.load(fn))
+      end
+    end
+  end
 
-	def eventLoadSelect(e)
-		if @curMainWidget==@singleMenu
-			@singleMenu.getChild("desc").setText(AGStringUtf8.new(""))
-			filename=id=@singleMenu.getChild("list").getSelectedID
-			fn="data/levels/"+id.gsub(".antlvl",".png")
-			if findFile(fn)!=""
-				s=AGSurface.load(fn)
-				if s.valid
-					@singleMenu.getChild("screenshot").setSurface(s)
-				end
-			else
-				puts "Screenshot-file #{fn} not found!"
-			end
-			doc=Document.new("data/levels/"+filename)
-			d=doc.root.get("desc")
-			@singleMenu.getChild("desc").setText(AGStringUtf8.new(d))
-			return true
-		end
-		@loadMenu.getChild("desc").setText(AGStringUtf8.new(""))
-		filename=id=@loadMenu.getChild("list").getSelectedID
-		fn="savegames/"+id.gsub(".antcmp",".png")
-		if findFile(fn)!=""
-			s=AGSurface.load(fn)
-			if s.valid
-				@loadMenu.getChild("screenshot").setSurface(s)
-			end
-		end
-		return true
-	end
-	def eventLoad(e)
-		id=@loadMenu.getChild("list").getSelectedID
-		if id!=""
-			c=Campaign.new(getWriteDir+"/savegames/"+id)
-			continueCampaign(c)
-		end
-		setMainWidget(@mainMenu)
-		return true
-	end
+  def eventLoadSelect(e)
+    if @curMainWidget==@singleMenu
+      @singleMenu.getChild("desc").setText(AGStringUtf8.new(""))
+      filename=id=@singleMenu.getChild("list").getSelectedID
+      fn="data/levels/"+id.gsub(".antlvl",".png")
+      if findFile(fn)!=""
+        s=AGSurface.load(fn)
+        if s.valid
+          @singleMenu.getChild("screenshot").setSurface(s)
+        end
+      else
+        puts "Screenshot-file #{fn} not found!"
+      end
+      doc=Document.new("data/levels/"+filename)
+      d=doc.root.get("desc")
+      @singleMenu.getChild("desc").setText(AGStringUtf8.new(d))
+      return true
+    end
+    @loadMenu.getChild("desc").setText(AGStringUtf8.new(""))
+    filename=id=@loadMenu.getChild("list").getSelectedID
+    fn="savegames/"+id.gsub(".antcmp",".png")
+    if findFile(fn)!=""
+      s=AGSurface.load(fn)
+      if s.valid
+        @loadMenu.getChild("screenshot").setSurface(s)
+      end
+    end
+    return true
+  end
+  def eventLoad(e)
+    id=@loadMenu.getChild("list").getSelectedID
+    if id!=""
+      c=Campaign.new(getWriteDir+"/savegames/"+id)
+      continueCampaign(c)
+    end
+    setMainWidget(@mainMenu)
+    return true
+  end
 
 
-	# SINGLE GAME MENU
-	def updateSingleMenu
-		fs=getDirectory("./data/levels")
-		fs=fs.select{|f|f=~/\.antlvl/ and (not f=~/~/)}.sort.uniq
-		l=@singleMenu.getChild("list")
-		l.clearList
-		fs.each{|f|
-			x=f.gsub(".antlvl","")
-			l.insertItem(f,AGStringUtf8.new(x))
-		}
-		if fs.length>0
-			fn="data/levels/"+fs[0].gsub("antlvl","png")
-			if findFile(fn)!=""
-				@singleMenu.getChild("screenshot").setSurface(AGSurface.load(fn))
-			end
-		end
-	end
-	def setupSingle
-		@singleMenu=AGLayout.new(nil)
-		@singleMenu.loadXML(loadFile("data/gui/layout/single.xml"))
-		@menues.push(@singleMenu)
-		addHandler(@singleMenu.getChild("singleExit"),:sigClick,:eventExit)
-		addHandler(@singleMenu.getChild("singleStart"),:sigClick,:eventSingleStart)
-		addHandler(@singleMenu.getChild("list"),:sigSelect,:eventLoadSelect)
-		updateSingleMenu
-	end
+  # SINGLE GAME MENU
+  def updateSingleMenu
+    fs=getDirectory("./data/levels")
+    fs=fs.select{|f|f=~/\.antlvl/ and (not f=~/~/)}.sort.uniq
+    l=@singleMenu.getChild("list")
+    l.clearList
+    fs.each{|f|
+      x=f.gsub(".antlvl","")
+      l.insertItem(f,AGStringUtf8.new(x))
+    }
+    if fs.length>0
+      fn="data/levels/"+fs[0].gsub("antlvl","png")
+      if findFile(fn)!=""
+        @singleMenu.getChild("screenshot").setSurface(AGSurface.load(fn))
+      end
+    end
+  end
+  def setupSingle
+    @singleMenu=AGLayout.new(nil)
+    @singleMenu.loadXML(loadFile("data/gui/layout/single.xml"))
+    @menues.push(@singleMenu)
+    addHandler(@singleMenu.getChild("singleExit"),:sigClick,:eventExit)
+    addHandler(@singleMenu.getChild("singleStart"),:sigClick,:eventSingleStart)
+    addHandler(@singleMenu.getChild("list"),:sigSelect,:eventLoadSelect)
+    updateSingleMenu
+  end
 
-	# OPTIONS MENU
-	def setupOptions
-		@optionsMenu=AGLayout.new(nil)
-		@optionSubMenus=["VideoOptionsMenu","AudioOptionsMenu","GameOptionsMenu"]
-		@optionsMenu.loadXML(loadFile("data/gui/layout/options.xml"))
-		@menues.push(@optionsMenu)
-		addHandler(@optionsMenu.getChild("exit"),:sigClick,:eventExit)
-		
-		addHandler(@optionsMenu.getChild("fullscreen"),:sigClick,:eventFullscreen)
-		["640","800","1024","1280","1400"].each{|n|
-			addHandler(@optionsMenu.getChild(n),:sigClick,:eventResChange)
-		}
-		#addHandler(@optionsMenu.getChild("1280"),:sigClick,:eventResChange)
-		addHandler(@optionsMenu.getChild("1400"),:sigClick,:eventResChange)
+  # OPTIONS MENU
+  def setupOptions
+    @optionsMenu=AGLayout.new(nil)
+    @optionSubMenus=["VideoOptionsMenu","AudioOptionsMenu","GameOptionsMenu"]
+    @optionsMenu.loadXML(loadFile("data/gui/layout/options.xml"))
+    @menues.push(@optionsMenu)
+    addHandler(@optionsMenu.getChild("exit"),:sigClick,:eventExit)
+    
+    addHandler(@optionsMenu.getChild("fullscreen"),:sigClick,:eventFullscreen)
+    ["640","800","1024","1280","1400"].each{|n|
+      addHandler(@optionsMenu.getChild(n),:sigClick,:eventResChange)
+    }
+    #addHandler(@optionsMenu.getChild("1280"),:sigClick,:eventResChange)
+    addHandler(@optionsMenu.getChild("1400"),:sigClick,:eventResChange)
 
-		addHandler(@optionsMenu.getChild("gameOptions"),:sigClick,:eventGameOptions)
-		addHandler(@optionsMenu.getChild("videoOptions"),:sigClick,:eventVideoOptions)
+    addHandler(@optionsMenu.getChild("gameOptions"),:sigClick,:eventGameOptions)
+    addHandler(@optionsMenu.getChild("videoOptions"),:sigClick,:eventVideoOptions)
 
-		addHandler(@optionsMenu.getChild("optionIntro"),:sigClick,:eventOptionsChanged)
+    addHandler(@optionsMenu.getChild("optionIntro"),:sigClick,:eventOptionsChanged)
 
-		@optionsMenu.getChild("optionIntro").setChecked(getConfig.get("intro")!="false")
+    @optionsMenu.getChild("optionIntro").setChecked(getConfig.get("intro")!="false")
 
-		# texture quality
-		texQ=@optionsMenu.getChild("textureQuality")
-		texQ.setSelected({"1"=>"high","2"=>"medium","3"=>"low",nil=>"high",""=>"high"}[getConfig.get("terrainDownScaleExp")])
-		addHandler(texQ,:sigSelect,:eventTextureQuality)
+    # texture quality
+    texQ=@optionsMenu.getChild("textureQuality")
+    texQ.setSelected({"1"=>"high","2"=>"medium","3"=>"low",nil=>"high",""=>"high"}[getConfig.get("terrainDownScaleExp")])
+    addHandler(texQ,:sigSelect,:eventTextureQuality)
 
-		# FBO
-		@optionsMenu.getChild("UseFBO").setChecked(getConfig.get("useFBO")=="true")
-		addHandler(@optionsMenu.getChild("UseFBO"),:sigClick,:eventOptionsChanged)
-		
-		# Anim
-		@optionsMenu.getChild("UseAnim").setChecked(getConfig.get("animationType")=="true")
-		addHandler(@optionsMenu.getChild("UseAnim"),:sigClick,:eventOptionsChanged)
+    # FBO
+    @optionsMenu.getChild("UseFBO").setChecked(getConfig.get("useFBO")=="true")
+    addHandler(@optionsMenu.getChild("UseFBO"),:sigClick,:eventOptionsChanged)
+    
+    # Anim
+    @optionsMenu.getChild("UseAnim").setChecked(getConfig.get("animationType")=="true")
+    addHandler(@optionsMenu.getChild("UseAnim"),:sigClick,:eventOptionsChanged)
 
-		# particle
-		@optionsMenu.getChild("UseParticle").setChecked(getConfig.get("particleEffects")=="true")
-		addHandler(@optionsMenu.getChild("UseParticle"),:sigClick,:eventOptionsChanged)
-	end
+    # particle
+    @optionsMenu.getChild("UseParticle").setChecked(getConfig.get("particleEffects")=="true")
+    addHandler(@optionsMenu.getChild("UseParticle"),:sigClick,:eventOptionsChanged)
+  end
 
 
-	
-	def eventSingleStart(e)
+  
+  def eventSingleStart(e)
 
-		id=@singleMenu.getChild("list").getSelectedID
-		if id!=""
-			soundOff
-			#c=Campaign.new(getWriteDir+"/savegames/"+id)
-			startGame("data/levels/"+id) #ampaign(c)
-			soundOn
-		end
-		setMainWidget(@mainMenu)
-		return true
+    id=@singleMenu.getChild("list").getSelectedID
+    if id!=""
+      soundOff
+      #c=Campaign.new(getWriteDir+"/savegames/"+id)
+      startGame("data/levels/"+id) #ampaign(c)
+      soundOn
+    end
+    setMainWidget(@mainMenu)
+    return true
 
-	end
+  end
 
 
 
 
-	# CREDITS MENU
-	def setupCredits
-		@creditsMenu=AGLayout.new(nil)
-		@creditsMenu.loadXML(loadFile("data/gui/layout/credits.xml"))
-		@menues.push(@creditsMenu)
-		addHandler(@creditsMenu.getChild("exit"),:sigClick,:eventExit)
+  # CREDITS MENU
+  def setupCredits
+    @creditsMenu=AGLayout.new(nil)
+    @creditsMenu.loadXML(loadFile("data/gui/layout/credits.xml"))
+    @menues.push(@creditsMenu)
+    addHandler(@creditsMenu.getChild("exit"),:sigClick,:eventExit)
 
-		@creditsMenu.getChild("ticker").menuapp=self
-	end
+    @creditsMenu.getChild("ticker").menuapp=self
+  end
 
-	# CAMPAIGN MENU	
-	def setupCampaign
-		@campaignMenu=AGLayout.new(nil)
-		@campaignMenu.loadXML(loadFile("data/gui/layout/campaign.xml"))
-		@menues.push(@campaignMenu)
-		addHandler(@campaignMenu.getChild("exit"),:sigClick,:eventExit)
-		addHandler(@campaignMenu.getChild("start"),:sigClick,:eventStart)
-		
-		@campaigns=getCampaigns
-		
-		buttonCount=6
-		campaignButtons=(0..(buttonCount-1)).to_a.collect{|c|"campaign#{c}"}
-		i=0
-		campaignButtons.each{|b|
-			c=@campaignMenu.getChild(b)
-			addHandler(c,:sigClick,:eventMission)
-			if @campaigns.length>i
-				c.setCaption(_(@campaigns[i].name))
-			else
-				c.hide
-			end
-			i+=1
-		}
-	end
+  # CAMPAIGN MENU  
+  def setupCampaign
+    @campaignMenu=AGLayout.new(nil)
+    @campaignMenu.loadXML(loadFile("data/gui/layout/campaign.xml"))
+    @menues.push(@campaignMenu)
+    addHandler(@campaignMenu.getChild("exit"),:sigClick,:eventExit)
+    addHandler(@campaignMenu.getChild("start"),:sigClick,:eventStart)
+    
+    @campaigns=getCampaigns
+    
+    buttonCount=6
+    campaignButtons=(0..(buttonCount-1)).to_a.collect{|c|"campaign#{c}"}
+    i=0
+    campaignButtons.each{|b|
+      c=@campaignMenu.getChild(b)
+      addHandler(c,:sigClick,:eventMission)
+      if @campaigns.length>i
+        c.setCaption(_(@campaigns[i].name))
+      else
+        c.hide
+      end
+      i+=1
+    }
+  end
 
-	# :section: Campaign Menu Event Handlers
+  # :section: Campaign Menu Event Handlers
 
-	def eventMission(e)
-		callerName=e.getCaller.getName
-		number=callerName[8..12].to_i
-		@selCampaign=@campaigns[number]
-		@campaignMenu.getChild("campaignImage").setTexture(@selCampaign.texture)
-		@campaignMenu.getChild("campaignDescription").setText(_(@selCampaign.description))
-		return true
-	end
-	
-	def eventStart(e)
-		if @selCampaign
-			soundOff
-			#startGame(@selCampaign)
-			startCampaign(@selCampaign)
-			soundOn
-		end
-		return true
-	end
-	
-	# :section: Options Menu Event handlers
-	
-	def eventTextureQuality(e)
-		scale={"low"=>3,"medium"=>2,"high"=>1}[@optionsMenu.getChild("textureQuality").getSelected]
-		getConfig.set("terrainDownScaleExp",scale.to_s)
-		getConfig.set("meshDownScaleExp",scale.to_s)
-		return true
-	end
+  def eventMission(e)
+    callerName=e.getCaller.getName
+    number=callerName[8..12].to_i
+    @selCampaign=@campaigns[number]
+    @campaignMenu.getChild("campaignImage").setTexture(@selCampaign.texture)
+    @campaignMenu.getChild("campaignDescription").setText(_(@selCampaign.description))
+    return true
+  end
+  
+  def eventStart(e)
+    if @selCampaign
+      soundOff
+      #startGame(@selCampaign)
+      startCampaign(@selCampaign)
+      soundOn
+    end
+    return true
+  end
+  
+  # :section: Options Menu Event handlers
+  
+  def eventTextureQuality(e)
+    scale={"low"=>3,"medium"=>2,"high"=>1}[@optionsMenu.getChild("textureQuality").getSelected]
+    getConfig.set("terrainDownScaleExp",scale.to_s)
+    getConfig.set("meshDownScaleExp",scale.to_s)
+    return true
+  end
 
-	def eventOptionsChanged(e)
-		case e.getCaller.getName
-			when "optionIntro"
-				getConfig.set("intro", at optionsMenu.getChild("optionIntro").isChecked.to_s)
-				#getScreen.screenshot.save("muh76.png")
-			when "UseFBO"
-				getConfig.set("useFBO", at optionsMenu.getChild("UseFBO").isChecked.to_s)
-			when "UseAnim"
-				getConfig.set("animationType", at optionsMenu.getChild("UseAnim").isChecked.to_s)
-			when "UseParticle"
-				getConfig.set("particleEffects", at optionsMenu.getChild("UseParticle").isChecked.to_s)
-		end
-	end
+  def eventOptionsChanged(e)
+    case e.getCaller.getName
+      when "optionIntro"
+        getConfig.set("intro", at optionsMenu.getChild("optionIntro").isChecked.to_s)
+        #getScreen.screenshot.save("muh76.png")
+      when "UseFBO"
+        getConfig.set("useFBO", at optionsMenu.getChild("UseFBO").isChecked.to_s)
+      when "UseAnim"
+        getConfig.set("animationType", at optionsMenu.getChild("UseAnim").isChecked.to_s)
+      when "UseParticle"
+        getConfig.set("particleEffects", at optionsMenu.getChild("UseParticle").isChecked.to_s)
+    end
+  end
 
-	def eventVideoOptions
-		@optionSubMenus.each{|m|@optionsMenu.getChild(m).hide}
-		@optionsMenu.getChild("VideoOptionsMenu").show
-	end
-	def eventGameOptions
-		@optionSubMenus.each{|m|@optionsMenu.getChild(m).hide}
-		@optionsMenu.getChild("GameOptionsMenu").show
-	end
+  def eventVideoOptions
+    @optionSubMenus.each{|m|@optionsMenu.getChild(m).hide}
+    @optionsMenu.getChild("VideoOptionsMenu").show
+  end
+  def eventGameOptions
+    @optionSubMenus.each{|m|@optionsMenu.getChild(m).hide}
+    @optionsMenu.getChild("GameOptionsMenu").show
+  end
 
-	def eventFullscreen
-		getMain.getVideo.initVideo(getMain.getVideo.realWidth,getMain.getVideo.realHeight,32,(not getMain.getVideo.fullscreen),true,1024,768)
-		getConfig.set("fullscreen",getMain.getVideo.fullscreen.to_s)
-		return true
-	end
+  def eventFullscreen
+    getMain.getVideo.initVideo(getMain.getVideo.realWidth,getMain.getVideo.realHeight,32,(not getMain.getVideo.fullscreen),true,1024,768)
+    getConfig.set("fullscreen",getMain.getVideo.fullscreen.to_s)
+    return true
+  end
 
-	def eventResChange(e)
-		case e.getCaller.getName
-			when "640"
-				setRes(640,480)
-			when "800"
-				setRes(800,600)
-			when "1024"
-				setRes(1024,768)
-			when "1280"
-				setRes(1280,1024)
-			when "1400"
-				setRes(1400,1050)
-		end
-		return true
-	end
+  def eventResChange(e)
+    case e.getCaller.getName
+      when "640"
+        setRes(640,480)
+      when "800"
+        setRes(800,600)
+      when "1024"
+        setRes(1024,768)
+      when "1280"
+        setRes(1280,1024)
+      when "1400"
+        setRes(1400,1050)
+    end
+    return true
+  end
 
-	
+  
 
 
-	# :section: Global Event Handlers
+  # :section: Global Event Handlers
 
-	# simple frame-event-handler - only counts how much FPS we have
-	# and displays this on CLI
-	def eventFrame(t)
-		delay(5)
-		@frameTime||=0
-		@frames||=0
-		@frameTime+=t
-		@frames+=1
-		if @frames>100
-			log "FPS:#{100.0/@frameTime}"
-			@frameTime=0
-			@frames=0
-		end
-		return true
-	end
-	# idle-event - sets a delay of 20ms
-	def eventIdle
-		delay(20)
-		return true
-	end
+  # simple frame-event-handler - only counts how much FPS we have
+  # and displays this on CLI
+  def eventFrame(t)
+    delay(5)
+    @frameTime||=0
+    @frames||=0
+    @frameTime+=t
+    @frames+=1
+    if @frames>100
+      log "FPS:#{100.0/@frameTime}"
+      @frameTime=0
+      @frames=0
+    end
+    return true
+  end
+  # idle-event - sets a delay of 20ms
+  def eventIdle
+    delay(20)
+    return true
+  end
 
-	# quits the application (is called by the Quit-button in the main-menu
-	# current you won't be asked if this is ok.
-	def eventQuit(e)
-		tryQuit
-		return true
-	end
+  # quits the application (is called by the Quit-button in the main-menu
+  # current you won't be asked if this is ok.
+  def eventQuit(e)
+    tryQuit
+    return true
+  end
 
 
-	# event-handler for end of music-playing
-	# start another track (a different one)
-	def eventMusicEnd
-		if @sound
-			getSoundManager.playMp3("data/music/calm1.ogg")
-		end
-		return true
-	end
+  # event-handler for end of music-playing
+  # start another track (a different one)
+  def eventMusicEnd
+    if @sound
+      getSoundManager.playMp3("data/music/calm1.ogg")
+    end
+    return true
+  end
 
-	# -------------------------------
-	# :section: Menu Event Handlers
-	# -------------------------------
+  # -------------------------------
+  # :section: Menu Event Handlers
+  # -------------------------------
 
-	# called by exit-button in submenus and always exits to mainmenu	
-	def eventExit(e)
-		setMainWidget(@mainMenu)
-		return true
-	end
+  # called by exit-button in submenus and always exits to mainmenu  
+  def eventExit(e)
+    setMainWidget(@mainMenu)
+    return true
+  end
 
-	# -------------------------------
-	# :section: Main Menu Event Handlers
-	# -------------------------------
-	
-	# open the credits screen
-	def eventCredits(e)
-		setMainWidget(@creditsMenu)
-		return true
-	end
-	# go to the single-game selection screen
-	def eventSingle(e)
-		setMainWidget(@singleMenu)
-		return true
-	end
-	# start the tutorial-campaign directly for new users, so
-	# they won't have to deal with "campaigning", where tutorial can be found, too
-	def eventTutorial(e)
-		tutCampaign=Campaign.new("data/campaigns/tutorial.xml")
-		soundOff
-		startCampaign(tutCampaign)
-		soundOn
-		return true
-	end
-	# go to the campaign-selection screen
-	def eventCampaign(e)
-		setMainWidget(@campaignMenu)
-		return true
-	end
-	# loading a game-screen will follow after this event
-	def eventLoadGame(e)
-		updateLoadMenu
-		setMainWidget(@loadMenu)
-		return true
-	end
-	# go to the options-screen
-	def eventOptions(e)
-		setMainWidget(@optionsMenu)
-		return true
-	end
+  # -------------------------------
+  # :section: Main Menu Event Handlers
+  # -------------------------------
+  
+  # open the credits screen
+  def eventCredits(e)
+    setMainWidget(@creditsMenu)
+    return true
+  end
+  # go to the single-game selection screen
+  def eventSingle(e)
+    setMainWidget(@singleMenu)
+    return true
+  end
+  # start the tutorial-campaign directly for new users, so
+  # they won't have to deal with "campaigning", where tutorial can be found, too
+  def eventTutorial(e)
+    tutCampaign=Campaign.new("data/campaigns/tutorial.xml")
+    soundOff
+    startCampaign(tutCampaign)
+    soundOn
+    return true
+  end
+  # go to the campaign-selection screen
+  def eventCampaign(e)
+    setMainWidget(@campaignMenu)
+    return true
+  end
+  # loading a game-screen will follow after this event
+  def eventLoadGame(e)
+    updateLoadMenu
+    setMainWidget(@loadMenu)
+    return true
+  end
+  # go to the options-screen
+  def eventOptions(e)
+    setMainWidget(@optionsMenu)
+    return true
+  end
 
 
-	
+  
 protected
-	# -------------------------------
-	# :section: changing settings
-	# -------------------------------
+  # -------------------------------
+  # :section: changing settings
+  # -------------------------------
 
-	# fades the sound out
-	def soundOff
-		@sound=false
-		getSoundManager.fadeOutMusic(1000)
-	end
+  # fades the sound out
+  def soundOff
+    @sound=false
+    getSoundManager.fadeOutMusic(1000)
+  end
 
-	# if there is music running it gets stopped
-	# and eventMusicEnd is called, so that a new track is started
-	def soundOn
-		@sound=true
-		getSoundManager.stopMp3
-		eventMusicEnd
-	end	
+  # if there is music running it gets stopped
+  # and eventMusicEnd is called, so that a new track is started
+  def soundOn
+    @sound=true
+    getSoundManager.stopMp3
+    eventMusicEnd
+  end  
 
-	# switch to the video-resolution with pixel-width *w* and height *h*
-	def setRes(w,h)
-		getMain.getVideo.initVideo(w,h,32,true,true,1024,768) #getMain.fullscreen,true)
-		getConfig.set("xRes",getMain.getVideo.realWidth.to_s)
-		getConfig.set("yRes",getMain.getVideo.realHeight.to_s)
-		#puts getSurfaceManager.getUsedTexMem
-		#raise 1
-	end
+  # switch to the video-resolution with pixel-width *w* and height *h*
+  def setRes(w,h)
+    getMain.getVideo.initVideo(w,h,32,true,true,1024,768) #getMain.fullscreen,true)
+    getConfig.set("xRes",getMain.getVideo.realWidth.to_s)
+    getConfig.set("yRes",getMain.getVideo.realHeight.to_s)
+    #puts getSurfaceManager.getUsedTexMem
+    #raise 1
+  end
 
 end
 

Modified: antargis/trunk/ruby/map_generator.rb
===================================================================
--- antargis/trunk/ruby/map_generator.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/map_generator.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -19,220 +19,220 @@
 #
 
 class GeneratorParameters
-	attr_accessor :size,:water,:hills,:population,:enemies
-	attr_reader :params
-	def initialize
-		@params=[:size,:water,:hills,:population,:enemies]
-		@size=128
-		@water=0.4
-		@hills=1
-		@population=40
-		@enemies=2
-	end
-	def readFromDialog(d)
-		@params.each{|p|
-			v=d.edits[p].getText.to_s
-			case p	
-				when :water
-					v=v.to_f
-				else
-					v=v.to_i
-			end
-			eval("self.#{p}=v")
-		}
-	end
+  attr_accessor :size,:water,:hills,:population,:enemies
+  attr_reader :params
+  def initialize
+    @params=[:size,:water,:hills,:population,:enemies]
+    @size=128
+    @water=0.4
+    @hills=1
+    @population=40
+    @enemies=2
+  end
+  def readFromDialog(d)
+    @params.each{|p|
+      v=d.edits[p].getText.to_s
+      case p  
+        when :water
+          v=v.to_f
+        else
+          v=v.to_i
+      end
+      eval("self.#{p}=v")
+    }
+  end
 end
 
 def addFlatOnMap(map,x,y,amount,size)
-	w=map.getW
-	h=map.getH
-	s2=size/2
-	x0=[0,w-1,x-s2].sort[1].to_i
-	x1=[0,w-1,x+s2].sort[1].to_i
-	y0=[0,w-1,y-s2].sort[1].to_i
-	y1=[0,w-1,y+s2].sort[1].to_i
-	(x0..x1).each{|mx|
-		(y0..y1).each{|my|
-			if (mx-x)**2+(my-y)**2<s2**2
-				h=map.get(mx,my)
-				a=[amount+h,rand*2+6].min # not too high
-				map.set(mx,my,a)
-			end
-		}
-	}
+  w=map.getW
+  h=map.getH
+  s2=size/2
+  x0=[0,w-1,x-s2].sort[1].to_i
+  x1=[0,w-1,x+s2].sort[1].to_i
+  y0=[0,w-1,y-s2].sort[1].to_i
+  y1=[0,w-1,y+s2].sort[1].to_i
+  (x0..x1).each{|mx|
+    (y0..y1).each{|my|
+      if (mx-x)**2+(my-y)**2<s2**2
+        h=map.get(mx,my)
+        a=[amount+h,rand*2+6].min # not too high
+        map.set(mx,my,a)
+      end
+    }
+  }
 end
 
 def addFlatOnMapTerrain(map,x,y,amount,size,tt)
-	w=map.getW
-	h=map.getH
-	s2=size/2
-	x0=[0,w-1,x-s2].sort[1].to_i
-	x1=[0,w-1,x+s2].sort[1].to_i
-	y0=[0,w-1,y-s2].sort[1].to_i
-	y1=[0,w-1,y+s2].sort[1].to_i
-	(x0..x1).each{|mx|
-		(y0..y1).each{|my|
-			if (mx-x)**2+(my-y)**2<s2**2
-				h=map.getTerrain(mx,my,tt)
-				a=[amount+h,rand*2+6].min # not too high
-				map.setTerrain(mx,my,tt,a)
-			end
-		}
-	}
+  w=map.getW
+  h=map.getH
+  s2=size/2
+  x0=[0,w-1,x-s2].sort[1].to_i
+  x1=[0,w-1,x+s2].sort[1].to_i
+  y0=[0,w-1,y-s2].sort[1].to_i
+  y1=[0,w-1,y+s2].sort[1].to_i
+  (x0..x1).each{|mx|
+    (y0..y1).each{|my|
+      if (mx-x)**2+(my-y)**2<s2**2
+        h=map.getTerrain(mx,my,tt)
+        a=[amount+h,rand*2+6].min # not too high
+        map.setTerrain(mx,my,tt,a)
+      end
+    }
+  }
 end
 
 def blurMap(map)
-	vps=[[0,0],[1,0],[0,1],[1,1]]
-	(0..(map.getW-2)).each{|x|
-		(0..(map.getH-2)).each{|y|
-			c=0
-			vps.each{|v|
-				c+=map.get(x+v[0],y+v[1])
-			}
-			c/=vps.length
-			map.set(x,y,c)
-		}
-	}
+  vps=[[0,0],[1,0],[0,1],[1,1]]
+  (0..(map.getW-2)).each{|x|
+    (0..(map.getH-2)).each{|y|
+      c=0
+      vps.each{|v|
+        c+=map.get(x+v[0],y+v[1])
+      }
+      c/=vps.length
+      map.set(x,y,c)
+    }
+  }
 end
 
 # ensure that beaches are steep enough, so that water doesn't run too far
 def checkBeachSteepness(map)
-	thres=0.1
-	(0..(map.getW-1)).each{|x|
-		(0..(map.getH-1)).each{|y|
-			h=map.get(x,y)
-			if h>-thres and h<0
-				h=-thres
-			elsif h>=0 and h<thres
-				h=thres
-			end
-			map.set(x,y,h)
-		}
-	}
+  thres=0.1
+  (0..(map.getW-1)).each{|x|
+    (0..(map.getH-1)).each{|y|
+      h=map.get(x,y)
+      if h>-thres and h<0
+        h=-thres
+      elsif h>=0 and h<thres
+        h=thres
+      end
+      map.set(x,y,h)
+    }
+  }
 end
 
 def addWaterTerrain(map)
-	tt=WATER
-	(0..(map.getW-1)).each{|x|
-		(0..(map.getH-1)).each{|y|
-			if map.get(x,y)<0
-				map.setTerrain(x,y,tt,0.7)
-			end
-		}
-	}
+  tt=WATER
+  (0..(map.getW-1)).each{|x|
+    (0..(map.getH-1)).each{|y|
+      if map.get(x,y)<0
+        map.setTerrain(x,y,tt,0.7)
+      end
+    }
+  }
 end
 
 def blurTerrain(map,tt)
-	vps=[[0,0],[1,0],[0,1],[1,1]]
-	(0..(map.getW-2)).each{|x|
-		(0..(map.getH-2)).each{|y|
-			c=0
-			vps.each{|v|
-				c+=map.getTerrain(x+v[0],y+v[1],tt)
-			}
-			c/=vps.length
-			map.setTerrain(x,y,tt,c)
-		}
-	}
+  vps=[[0,0],[1,0],[0,1],[1,1]]
+  (0..(map.getW-2)).each{|x|
+    (0..(map.getH-2)).each{|y|
+      c=0
+      vps.each{|v|
+        c+=map.getTerrain(x+v[0],y+v[1],tt)
+      }
+      c/=vps.length
+      map.setTerrain(x,y,tt,c)
+    }
+  }
 end
 
 def addGrass(map)
-	tt=GRASS
-	thres=0.3
-	(0..(map.getW-1)).each{|x|
-		(0..(map.getH-1)).each{|y|
-			if map.get(x,y)>thres
-				map.setTerrain(x,y,tt,rand)
-			end
-		}
-	}
-	
-	tt=GRASS2
-	thres=1.3
-	(0..(map.getW-1)).each{|x|
-		(0..(map.getH-1)).each{|y|
-			if map.get(x,y)>thres
-#				map.setTerrain(x,y,tt,rand)
-				r=rand
-				map.setTerrain(x,y,tt,r)
-				if r>0.97
-					# add tree
-					t=AntGrass.new(map)
-					t.setPos(AGVector2.new(x,y))
-					map.insertEntity(t)
-				end
-			end
-		}
-	}
+  tt=GRASS
+  thres=0.3
+  (0..(map.getW-1)).each{|x|
+    (0..(map.getH-1)).each{|y|
+      if map.get(x,y)>thres
+        map.setTerrain(x,y,tt,rand)
+      end
+    }
+  }
+  
+  tt=GRASS2
+  thres=1.3
+  (0..(map.getW-1)).each{|x|
+    (0..(map.getH-1)).each{|y|
+      if map.get(x,y)>thres
+#        map.setTerrain(x,y,tt,rand)
+        r=rand
+        map.setTerrain(x,y,tt,r)
+        if r>0.97
+          # add tree
+          t=AntGrass.new(map)
+          t.setPos(AGVector2.new(x,y))
+          map.insertEntity(t)
+        end
+      end
+    }
+  }
 end
 
 def addRock(map)
-	w=map.getW
-	h=map.getH
-	flat=[[5,10],[4,10],[3,20],[2,20]]
-	flat.each{|add|
-		for i in 1..add[1]
-			rad=add[0]
-			x=rand*(w-2*rad)+rad
-			y=rand*(h-2*rad)+rad
-			#map.addFlat(x,y,30,rad)
-			if map.get(x.to_i,y.to_i)>1
-				addFlatOnMapTerrain(map,x,y,1,rad,ROCK)
-			end
-		end
-	}
+  w=map.getW
+  h=map.getH
+  flat=[[5,10],[4,10],[3,20],[2,20]]
+  flat.each{|add|
+    for i in 1..add[1]
+      rad=add[0]
+      x=rand*(w-2*rad)+rad
+      y=rand*(h-2*rad)+rad
+      #map.addFlat(x,y,30,rad)
+      if map.get(x.to_i,y.to_i)>1
+        addFlatOnMapTerrain(map,x,y,1,rad,ROCK)
+      end
+    end
+  }
 end
 
 def addForest(map)
-	tt=FOREST
-	thres=1.0
-	(0..(map.getW-1)).each{|x|
-		(0..(map.getH-1)).each{|y|
-			if map.get(x,y)>thres
-				r=rand
-				map.setTerrain(x,y,tt,r)
-				if r>0.97 and map.getTerrain(x,y,ROCK)<0.3
-					# add tree
-					t=AntTree.new(map)
-					t.setPos(AGVector2.new(x,y))
-					map.insertEntity(t)
-				end
-			end
-		}
-	}
+  tt=FOREST
+  thres=1.0
+  (0..(map.getW-1)).each{|x|
+    (0..(map.getH-1)).each{|y|
+      if map.get(x,y)>thres
+        r=rand
+        map.setTerrain(x,y,tt,r)
+        if r>0.97 and map.getTerrain(x,y,ROCK)<0.3
+          # add tree
+          t=AntTree.new(map)
+          t.setPos(AGVector2.new(x,y))
+          map.insertEntity(t)
+        end
+      end
+    }
+  }
 end
 
 
 def generateMap(map,params)
-	w=params.size
-	h=params.size
+  w=params.size
+  h=params.size
 
-	map.newMap(w,h)
-	getMap.setHeight(2) # everything deep water
+  map.newMap(w,h)
+  getMap.setHeight(2) # everything deep water
 
- 		flat=[[30,10],[15,20],[10,8],[5,40],[4,10],[3,20],[2,20],[1,70]]
- 		flat.each{|add|
- 			for i in 1..add[1]
- 				rad=add[0]
- 				x=rand*(w-2*rad)+rad
- 				y=rand*(h-2*rad)+rad
- 				#map.addFlat(x,y,30,rad)
-				addFlatOnMap(map,x,y,2,rad)
- 			end
- 		}
+     flat=[[30,10],[15,20],[10,8],[5,40],[4,10],[3,20],[2,20],[1,70]]
+     flat.each{|add|
+       for i in 1..add[1]
+         rad=add[0]
+         x=rand*(w-2*rad)+rad
+         y=rand*(h-2*rad)+rad
+         #map.addFlat(x,y,30,rad)
+        addFlatOnMap(map,x,y,2,rad)
+       end
+     }
 
-	blurMap(map)
-	blurMap(map)
-	blurMap(map)
-	
-	checkBeachSteepness(map)
+  blurMap(map)
+  blurMap(map)
+  blurMap(map)
+  
+  checkBeachSteepness(map)
 
-	addWaterTerrain(map)
-	blurTerrain(map,WATER)
+  addWaterTerrain(map)
+  blurTerrain(map,WATER)
 
-	addGrass(map)
-	addRock(map)
-	addForest(map)
+  addGrass(map)
+  addRock(map)
+  addForest(map)
 
-	map.mapChanged
-end
\ No newline at end of file
+  map.mapChanged
+end

Modified: antargis/trunk/ruby/map_generator2.rb
===================================================================
--- antargis/trunk/ruby/map_generator2.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/map_generator2.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -3,519 +3,519 @@
 require 'ruby/antargislib.rb'
 
 class Array
-	def cross(p)
-		n=[]
-		self.each{|x|
-			p.each{|y|
-				n<<=[x,y]
-			}
-		}
-		n
-	end
+  def cross(p)
+    n=[]
+    self.each{|x|
+      p.each{|y|
+        n<<=[x,y]
+      }
+    }
+    n
+  end
 end
 
 
 class MyBaseMap
-	attr_reader :w,:h
-	def initialize(pw,ph)
-		@w=pw
-		@h=ph
-		@a=[]
-		(1.. at w).each{|x|
-			(1.. at h).each{|y|
-				set(x,y,:undefined)
-			}
-		}
-	end
-	def set(x,y,v)
-		@a[x+ at w*y]=v
-	end
-	def get(x,y)
-		return :undefined unless x>0 and x<=@w and y>0 and y<=@h
-		@a[x+ at w*y]
-	end
-	def to_surface
-		i=AGSurface.new(w,h)
-		
-		begin
-			p=AGPainter.new(i)
-			(1.. at w).each{|x|
-				(1.. at h).each{|y|
-					c=getColor(x,y)
-					p.putPixel(AGVector2.new(x-1,y-1),c)
-				}
-			}
-		end
-		i
-	end
-	def getColor(x,y)
-		t=get(x,y)
-		c=toColor(t)
-	end
+  attr_reader :w,:h
+  def initialize(pw,ph)
+    @w=pw
+    @h=ph
+    @a=[]
+    (1.. at w).each{|x|
+      (1.. at h).each{|y|
+        set(x,y,:undefined)
+      }
+    }
+  end
+  def set(x,y,v)
+    @a[x+ at w*y]=v
+  end
+  def get(x,y)
+    return :undefined unless x>0 and x<=@w and y>0 and y<=@h
+    @a[x+ at w*y]
+  end
+  def to_surface
+    i=AGSurface.new(w,h)
+    
+    begin
+      p=AGPainter.new(i)
+      (1.. at w).each{|x|
+        (1.. at h).each{|y|
+          c=getColor(x,y)
+          p.putPixel(AGVector2.new(x-1,y-1),c)
+        }
+      }
+    end
+    i
+  end
+  def getColor(x,y)
+    t=get(x,y)
+    c=toColor(t)
+  end
 
-	def toColor(t)
-		case t
-			when :undefined
-				return AGColor.new(0xFF,0x70,0)
-			when :water
-				return AGColor.new(0,0,0x70)
-			when :green
-				return AGColor.new(0,0xFF,0)
-			when :wood
-				return AGColor.new(0,0x7F,0)
-			when :rock
-				return AGColor.new(0x7f,0x7F,0x7f)
-		end
-		return AGColor.new(0,0,0)
-	end
+  def toColor(t)
+    case t
+      when :undefined
+        return AGColor.new(0xFF,0x70,0)
+      when :water
+        return AGColor.new(0,0,0x70)
+      when :green
+        return AGColor.new(0,0xFF,0)
+      when :wood
+        return AGColor.new(0,0x7F,0)
+      when :rock
+        return AGColor.new(0x7f,0x7F,0x7f)
+    end
+    return AGColor.new(0,0,0)
+  end
 end
 
 class MyMap<MyBaseMap
-	def initialize(w,h)
-		super
-		initRandom
-	end
+  def initialize(w,h)
+    super
+    initRandom
+  end
 
 
-	def putAtRandPos(v)
-		x=rand*@w.to_i+1
-		y=rand*@h.to_i+1
-		set(x,y,v)
-	end
+  def putAtRandPos(v)
+    x=rand*@w.to_i+1
+    y=rand*@h.to_i+1
+    set(x,y,v)
+  end
 
-	def someX(amount,what)
-		(1..amount).each{|v|
-			putAtRandPos(what)
-		}
-	end
+  def someX(amount,what)
+    (1..amount).each{|v|
+      putAtRandPos(what)
+    }
+  end
 
-	def blurAt(x,y)
-		cv=get(x,y)
-		return nil unless cv==:undefined
-		what={}
-		(-1..1).each{|dx|
-			(-1..1).each{|dy|
-				t=get(x+dx,y+dy)
-				what[t]||=0
-				what[t]+=1
-			}
-		}
-		what[:undefined]=0
-		ps=[]
-		what.each{|k,v|
-			ps.push([k,v])
-		}
-		ps=ps.shuffle.sort{|a,b|b[1]<=>a[1]}
-		#puts ps[0][0]
-		ps[0][0]
-	end
+  def blurAt(x,y)
+    cv=get(x,y)
+    return nil unless cv==:undefined
+    what={}
+    (-1..1).each{|dx|
+      (-1..1).each{|dy|
+        t=get(x+dx,y+dy)
+        what[t]||=0
+        what[t]+=1
+      }
+    }
+    what[:undefined]=0
+    ps=[]
+    what.each{|k,v|
+      ps.push([k,v])
+    }
+    ps=ps.shuffle.sort{|a,b|b[1]<=>a[1]}
+    #puts ps[0][0]
+    ps[0][0]
+  end
 
 
-	def initRandom
-		@cs=[]
-		(1.. at h).each{|y|
-			(1.. at w).each{|x|
-				@cs<<[x,y]
-			}
-		}
-		
-		@cs=@cs.shuffle
-	end
+  def initRandom
+    @cs=[]
+    (1.. at h).each{|y|
+      (1.. at w).each{|x|
+        @cs<<[x,y]
+      }
+    }
+    
+    @cs=@cs.shuffle
+  end
 
-	def blur
-		modified=false
-		@cs.each{|p|
-			x,y=p
-			v=blurAt(x,y)
-			if v.nil?
-				#modified=true
-			elsif v!=:undefined
-				set(x,y,v)
-				modified=true
-			end
-		}
-		modified
-	end
+  def blur
+    modified=false
+    @cs.each{|p|
+      x,y=p
+      v=blurAt(x,y)
+      if v.nil?
+        #modified=true
+      elsif v!=:undefined
+        set(x,y,v)
+        modified=true
+      end
+    }
+    modified
+  end
 
-	def blurAll
-		modified=true
-		tries=0
-		while modified and tries<1000
-			modified=blur
-			tries+=1
-		end
-	end
+  def blurAll
+    modified=true
+    tries=0
+    while modified and tries<1000
+      modified=blur
+      tries+=1
+    end
+  end
 end
 
 class MyHeightMap<MyMap
-	def initialize(pw,ph)
-		super
-		@hs=[]
-		@hschange=[]
-		@dist=[]
-		@ndist=[]
-		(1.. at w).each{|x|
-			(1.. at h).each{|y|
-				setHeight(x,y,0)
-			}
-		}
-		applyHeightChanges
-	end
-	def setHeight(x,y,v)
-		@hschange[x+ at w*y]=v
-	end
-	def applyHeightChanges
-		@hs=@hschange.clone
-	end
-	def getHeight(x,y)
-		return 0 unless x>0 and x<=@w and y>0 and y<=@h
-		@hs[x+ at w*y]
-	end
+  def initialize(pw,ph)
+    super
+    @hs=[]
+    @hschange=[]
+    @dist=[]
+    @ndist=[]
+    (1.. at w).each{|x|
+      (1.. at h).each{|y|
+        setHeight(x,y,0)
+      }
+    }
+    applyHeightChanges
+  end
+  def setHeight(x,y,v)
+    @hschange[x+ at w*y]=v
+  end
+  def applyHeightChanges
+    @hs=@hschange.clone
+  end
+  def getHeight(x,y)
+    return 0 unless x>0 and x<=@w and y>0 and y<=@h
+    @hs[x+ at w*y]
+  end
 
 
-	def computeHeights(type)
-		puts "computing height #{type}"
-		(1.. at w).each{|x|
-			(1.. at h).each{|y|
-				addRandomHeight(x,y,type)
-			}
-		}
-		applyHeightChanges
-	end
+  def computeHeights(type)
+    puts "computing height #{type}"
+    (1.. at w).each{|x|
+      (1.. at h).each{|y|
+        addRandomHeight(x,y,type)
+      }
+    }
+    applyHeightChanges
+  end
 
-	def blurHeights(w)
-		a=filterMatrix(w)
-# 		a=[1,2,1]
-# 		case w
-# 			when 5
-# 				a=[1,6,15,20,15,6,1]
-# 			when 4
-# 				a=[1,5,10,10,5,1]
-# 			when 3
-# 				a=[1,4,6,4,1]
-# 			when 2
-# 				a=[1,3,3,1]
-# 		end
-		n=crossProductVecVec(a,a)
-		arr=toIndexMap(n)
+  def blurHeights(w)
+    a=filterMatrix(w)
+#     a=[1,2,1]
+#     case w
+#       when 5
+#         a=[1,6,15,20,15,6,1]
+#       when 4
+#         a=[1,5,10,10,5,1]
+#       when 3
+#         a=[1,4,6,4,1]
+#       when 2
+#         a=[1,3,3,1]
+#     end
+    n=crossProductVecVec(a,a)
+    arr=toIndexMap(n)
 
-		f=arr.inject(0){|a,b|a+b[2]}
-	
-		(1.. at w).each{|x|
-			(1.. at h).each{|y|
-				v=0
-				arr.each{|p|
-					v+=getHeight(x+p[0],y+p[1])*p[2]
-				}
-				v/=f
-					
-				setHeight(x,y,v)
-			}
-		}
-		applyHeightChanges
-	end
+    f=arr.inject(0){|a,b|a+b[2]}
+  
+    (1.. at w).each{|x|
+      (1.. at h).each{|y|
+        v=0
+        arr.each{|p|
+          v+=getHeight(x+p[0],y+p[1])*p[2]
+        }
+        v/=f
+          
+        setHeight(x,y,v)
+      }
+    }
+    applyHeightChanges
+  end
 
-	def addRandomHeight(x,y,type)
-		v=get(x,y)
-		r=range(v,type)
-		h=r[0]+(r[1]-r[0])*rand
-		setHeight(x,y,getHeight(x,y)+h)
-	end
+  def addRandomHeight(x,y,type)
+    v=get(x,y)
+    r=range(v,type)
+    h=r[0]+(r[1]-r[0])*rand
+    setHeight(x,y,getHeight(x,y)+h)
+  end
 
-	def getShadow(x,y)
-		a=[[-1,0,-1],
-				[0,-1,-1],
-				[1,0,1],
-				[0,1,1]]
-		v=0
-		a.each{|t|
-			v+=getHeight(x+t[0],y+t[1])*t[2]
-		}
-		v=[-0.5,v,0.5].sort[1]
-		#puts v
-		0.5+v
-	end
+  def getShadow(x,y)
+    a=[[-1,0,-1],
+        [0,-1,-1],
+        [1,0,1],
+        [0,1,1]]
+    v=0
+    a.each{|t|
+      v+=getHeight(x+t[0],y+t[1])*t[2]
+    }
+    v=[-0.5,v,0.5].sort[1]
+    #puts v
+    0.5+v
+  end
 
-	def getColor(x,y)
-		#AGColor.new(0xFF,0xFF,0xFF)*getShadow(x,y)
-		super*getShadow(x,y)
-	end
+  def getColor(x,y)
+    #AGColor.new(0xFF,0xFF,0xFF)*getShadow(x,y)
+    super*getShadow(x,y)
+  end
 
 
-	def range(v,type)
-		case type
-			when :veryrough
-				case v
-					when :undefined
-						return [0,0]
-					when :green
-						return [0.3,6]
-					when :water
-						return [0,1]
-					when :wood
-						return [0.3,8]
-					when :rock
-						return [0.4,15]
-				end
-			when :rough
-				case v
-					when :undefined
-						return [0,0]
-					when :green
-						return [0.3,0.6]
-					when :water
-						return [0,0.1]
-					when :wood
-						return [0.3,0.8]
-					when :rock
-						return [0.4,1.5]
-				end
-			else
-				case v
-					when :undefined
-						return [0,0]
-					when :green
-						return [0,0.2]
-					when :water
-						return [0,0.1]
-					when :wood
-						return [0,0.1]
-					when :rock
-						return [0,0.4]
-					else
-						return [0,0]
-				end
-		end
-	end
+  def range(v,type)
+    case type
+      when :veryrough
+        case v
+          when :undefined
+            return [0,0]
+          when :green
+            return [0.3,6]
+          when :water
+            return [0,1]
+          when :wood
+            return [0.3,8]
+          when :rock
+            return [0.4,15]
+        end
+      when :rough
+        case v
+          when :undefined
+            return [0,0]
+          when :green
+            return [0.3,0.6]
+          when :water
+            return [0,0.1]
+          when :wood
+            return [0.3,0.8]
+          when :rock
+            return [0.4,1.5]
+        end
+      else
+        case v
+          when :undefined
+            return [0,0]
+          when :green
+            return [0,0.2]
+          when :water
+            return [0,0.1]
+          when :wood
+            return [0,0.1]
+          when :rock
+            return [0,0.4]
+          else
+            return [0,0]
+        end
+    end
+  end
 
-	def rockIncreaseAbove(level,types,inc)
-		#a=[1,6,15,20,15,6,1]
-		a=[1,5,10,10,5,1]
-		n=crossProductVecVec(a,a)
-		arr=toIndexMap(n)
+  def rockIncreaseAbove(level,types,inc)
+    #a=[1,6,15,20,15,6,1]
+    a=[1,5,10,10,5,1]
+    n=crossProductVecVec(a,a)
+    arr=toIndexMap(n)
 
-		f=arr.inject(0){|a,b|a+b[2]}
+    f=arr.inject(0){|a,b|a+b[2]}
 
-		increased=0
-		checked=0
-		#a=[-1,0,1]
-		#a=a.cross(a)
-		(1.. at w).each{|x|
-			(1.. at h).each{|y|
-				if types.member?(get(x,y))
-					checked+=1
-					v=0
-					arr.each{|p|
-						cx=x+p[0]
-						cy=y+p[1]
-						#if types.member?(get(cx,cy))
-							v+=getHeight(cx,cy)*p[2]
-						#end						
-					}
-					v/=f
-					#puts "#{v} #{v*f} #{f} #{level}"
-					if v>level
-						setHeight(x,y,getHeight(x,y)+inc)
-						increased+=1
-					end
-				end
-			}
-		}
-		puts "INCREASED:#{increased} CHECKED:#{checked} on level #{level}"
-		applyHeightChanges
-	end
+    increased=0
+    checked=0
+    #a=[-1,0,1]
+    #a=a.cross(a)
+    (1.. at w).each{|x|
+      (1.. at h).each{|y|
+        if types.member?(get(x,y))
+          checked+=1
+          v=0
+          arr.each{|p|
+            cx=x+p[0]
+            cy=y+p[1]
+            #if types.member?(get(cx,cy))
+              v+=getHeight(cx,cy)*p[2]
+            #end            
+          }
+          v/=f
+          #puts "#{v} #{v*f} #{f} #{level}"
+          if v>level
+            setHeight(x,y,getHeight(x,y)+inc)
+            increased+=1
+          end
+        end
+      }
+    }
+    puts "INCREASED:#{increased} CHECKED:#{checked} on level #{level}"
+    applyHeightChanges
+  end
 
-	def erode(terrainTypes,amount=0.3)
-		eroded=0
-		(1.. at w).each{|x|
-			(1.. at h).each{|y|
-				if terrainTypes.member?(get(x,y))
-					vs=[]
-					(-1..1).each{|dy|
-						(-1..1).each{|dx|	
-							vs.push(getHeight(x+dx,y+dy))
-						}
-					}
-					ch=getHeight(x,y)
-					if ch<vs.sort[4]
-						setHeight(x,y,ch-amount)
-						eroded+=1
-					end
-				end
-			}
-		}		
-		puts "ERODED: #{eroded}"
-		applyHeightChanges
-	end
+  def erode(terrainTypes,amount=0.3)
+    eroded=0
+    (1.. at w).each{|x|
+      (1.. at h).each{|y|
+        if terrainTypes.member?(get(x,y))
+          vs=[]
+          (-1..1).each{|dy|
+            (-1..1).each{|dx|  
+              vs.push(getHeight(x+dx,y+dy))
+            }
+          }
+          ch=getHeight(x,y)
+          if ch<vs.sort[4]
+            setHeight(x,y,ch-amount)
+            eroded+=1
+          end
+        end
+      }
+    }    
+    puts "ERODED: #{eroded}"
+    applyHeightChanges
+  end
 
-	def rockIncrease
-		h=0.6
-		while h<3
-			#rockIncreaseAbove(h,[:rock,:wood],0.3)
-			rockIncreaseAbove(h,[:rock],0.15)
-			h+=0.3
-		end
-		#}
-	end
+  def rockIncrease
+    h=0.6
+    while h<3
+      #rockIncreaseAbove(h,[:rock,:wood],0.3)
+      rockIncreaseAbove(h,[:rock],0.15)
+      h+=0.3
+    end
+    #}
+  end
 
-	def getDistance(x,y)
-		return 0 unless x>0 and x<=@w and y>0 and y<=@h
-		d=@dist[x+ at w*y]
-		if d
-			return d
-		end
-		return 0
-	end
+  def getDistance(x,y)
+    return 0 unless x>0 and x<=@w and y>0 and y<=@h
+    d=@dist[x+ at w*y]
+    if d
+      return d
+    end
+    return 0
+  end
 
-	def applyDistChanges
-		@dist=@ndist.clone
-	end
+  def applyDistChanges
+    @dist=@ndist.clone
+  end
 
-	def setDistance(x,y,d)
-		@ndist[x+ at w*y]=d
-	end
+  def setDistance(x,y,d)
+    @ndist[x+ at w*y]=d
+  end
 
-	def computeDistances(myTerrain)
-		ar=[]
-		(-1..1).each{|x|
-			(-1..1).each{|y|
-				ar.push([x,y,Math::sqrt(x*x+y*y)])
-			}
-		}
+  def computeDistances(myTerrain)
+    ar=[]
+    (-1..1).each{|x|
+      (-1..1).each{|y|
+        ar.push([x,y,Math::sqrt(x*x+y*y)])
+      }
+    }
 
-		found=0
-		nfound=0
-		# initial run
-		(1.. at w).each{|x|
-			(1.. at h).each{|y|
-				if get(x,y)==myTerrain
-					test=0
-					ar.each{|p|
-						dx=x+p[0]
-						dy=y+p[1]
-						if get(dx,dy)!=myTerrain
-							setDistance(x,y,p[2]+rand)
-							found+=1
-							test+=1
-							break
-						end
-					}
-					if test==0
-						nfound+=1
-					end
-				end
-			}
-		}
+    found=0
+    nfound=0
+    # initial run
+    (1.. at w).each{|x|
+      (1.. at h).each{|y|
+        if get(x,y)==myTerrain
+          test=0
+          ar.each{|p|
+            dx=x+p[0]
+            dy=y+p[1]
+            if get(dx,dy)!=myTerrain
+              setDistance(x,y,p[2]+rand)
+              found+=1
+              test+=1
+              break
+            end
+          }
+          if test==0
+            nfound+=1
+          end
+        end
+      }
+    }
 
-		applyDistChanges
-		# fill in random valleys
-		(1..20).each{|i|
-			ok=true
-			while ok
-				x=(rand*@w).to_i+1
-				y=(rand*@h).to_i+1
-				if get(x,y)==myTerrain and getDistance(x,y)==0
-					setDistance(x,y,1+rand)
-					found+=1
-					ok=false
-				end
-			end
-		}
+    applyDistChanges
+    # fill in random valleys
+    (1..20).each{|i|
+      ok=true
+      while ok
+        x=(rand*@w).to_i+1
+        y=(rand*@h).to_i+1
+        if get(x,y)==myTerrain and getDistance(x,y)==0
+          setDistance(x,y,1+rand)
+          found+=1
+          ok=false
+        end
+      end
+    }
 
 
 
-		applyDistChanges
-		puts "FOUND #{found} NFOUND #{nfound}"
-		
-		modified=true
-		try=0
-		while modified
-			modified=false
-			try+=1
-			puts "TRY #{try}"
-			if try>20
-				break
-			end
+    applyDistChanges
+    puts "FOUND #{found} NFOUND #{nfound}"
+    
+    modified=true
+    try=0
+    while modified
+      modified=false
+      try+=1
+      puts "TRY #{try}"
+      if try>20
+        break
+      end
 
-			# do loop and increase distances where distance==0
-			(1.. at w).each{|x|
-				(1.. at h).each{|y|
-					if get(x,y)==myTerrain and getDistance(x,y)==0
-						ar.each{|p|
-							dx=x+p[0]
-							dy=y+p[1]
-							r=rand+p[2]
-							cd=getDistance(dx,dy)
-							if cd>0 and (cd+r<getDistance(x,y) or getDistance(x,y)==0)
-								found+=1
-								setDistance(x,y,cd+r)
-								setHeight(x,y,getHeight(x,y)+(cd+r)*0.1)
-								modified=true
-							end
-						}			
-					end
-				}
-			}
-			puts "FOUND #{found}"
-			applyDistChanges
-		end
-		applyHeightChanges
-	end
+      # do loop and increase distances where distance==0
+      (1.. at w).each{|x|
+        (1.. at h).each{|y|
+          if get(x,y)==myTerrain and getDistance(x,y)==0
+            ar.each{|p|
+              dx=x+p[0]
+              dy=y+p[1]
+              r=rand+p[2]
+              cd=getDistance(dx,dy)
+              if cd>0 and (cd+r<getDistance(x,y) or getDistance(x,y)==0)
+                found+=1
+                setDistance(x,y,cd+r)
+                setHeight(x,y,getHeight(x,y)+(cd+r)*0.1)
+                modified=true
+              end
+            }      
+          end
+        }
+      }
+      puts "FOUND #{found}"
+      applyDistChanges
+    end
+    applyHeightChanges
+  end
 
 private
-	def computeNextFilter(a)
-		n=[]
-		l=0
-		a.each{|c|
-			n.push(l+c)
-			l=c
-		}
-		n.push(l)
-		n
-	end
-	def filterMatrix(n)
-		m=[1,1]
-		while n>1
-			m=computeNextFilter(m)
-			n-=1
-		end
-		m
-	end
-	
-	def crossProductVecVec(a,b)
-		n=[]
-		a.each{|x|
-			l=[]
-			b.each{|y|
-				l.push(x*y)
-			}
-			n.push(l)
-		}
-		n
-	end
-	
-	def toIndexMap(a)
-		n=[]
-		y=0
-		h=a.length
-		w=a[0].length
-		dy=h/2
-		dx=w/2
-		a.each{|r|
-			x=0
-			r.each{|v|
-				n.push([x-dx,y-dy,v])
-				x+=1
-			}
-			y+=1
-		}
-		n
-	end
+  def computeNextFilter(a)
+    n=[]
+    l=0
+    a.each{|c|
+      n.push(l+c)
+      l=c
+    }
+    n.push(l)
+    n
+  end
+  def filterMatrix(n)
+    m=[1,1]
+    while n>1
+      m=computeNextFilter(m)
+      n-=1
+    end
+    m
+  end
+  
+  def crossProductVecVec(a,b)
+    n=[]
+    a.each{|x|
+      l=[]
+      b.each{|y|
+        l.push(x*y)
+      }
+      n.push(l)
+    }
+    n
+  end
+  
+  def toIndexMap(a)
+    n=[]
+    y=0
+    h=a.length
+    w=a[0].length
+    dy=h/2
+    dx=w/2
+    a.each{|r|
+      x=0
+      r.each{|v|
+        n.push([x-dx,y-dy,v])
+        x+=1
+      }
+      y+=1
+    }
+    n
+  end
 
 
 end
 
-	
+  
 
 w=h=128
 
@@ -528,26 +528,26 @@
 myMap.blurAll
 myMap.to_surface.save("mapgen0.png")
 if false
-	myMap.computeHeights(:rough)
-	myMap.blurHeights(5)
-	myMap.computeHeights(:medium)
-	myMap.blurHeights(2)
-	myMap.computeHeights(:fine)
-	myMap.blurHeights(1)
-	myMap.to_surface.save("mapgen1.png")
-	myMap.rockIncrease
-	myMap.to_surface.save("mapgen2.png")
-	myMap.blurHeights(1)
-	myMap.erode([:rock])
-	myMap.erode([:rock])
+  myMap.computeHeights(:rough)
+  myMap.blurHeights(5)
+  myMap.computeHeights(:medium)
+  myMap.blurHeights(2)
+  myMap.computeHeights(:fine)
+  myMap.blurHeights(1)
+  myMap.to_surface.save("mapgen1.png")
+  myMap.rockIncrease
+  myMap.to_surface.save("mapgen2.png")
+  myMap.blurHeights(1)
+  myMap.erode([:rock])
+  myMap.erode([:rock])
 else
-	myMap.computeHeights(:veryrough)
-	myMap.blurHeights(10)
-	myMap.computeHeights(:rough)
-	myMap.blurHeights(5)
-	myMap.computeDistances(:rock)
-	myMap.computeHeights(:fine)
-	myMap.blurHeights(1)
+  myMap.computeHeights(:veryrough)
+  myMap.blurHeights(10)
+  myMap.computeHeights(:rough)
+  myMap.blurHeights(5)
+  myMap.computeDistances(:rock)
+  myMap.computeHeights(:fine)
+  myMap.blurHeights(1)
 end
 myMap.to_surface.save("mapgen3.png")
 app=AGApplication.new

Modified: antargis/trunk/ruby/mesh_view.rb
===================================================================
--- antargis/trunk/ruby/mesh_view.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/mesh_view.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -3,52 +3,52 @@
 require 'ruby/antargislib.rb'
 
 class App<GLApp
-	def initialize(w,h,file,tex,zoom=0.1)
-		super(w,h)
-		@anim=false
-		if file==nil
-			require 'gen_tree.rb'
-			data=genTree
-			@n=Mesh.new(getScene,data,AGVector4.new(0,0,0),-30)
-		elsif file=~/.*anim/
-			data=AnimMeshData.new("data/models/sheep.anim")
-			data.setTransform(AGMatrix4.new(Math::PI,AGVector3.new(0,0,1))*AGMatrix4.new(Math::PI/2,AGVector3.new(1,0,0)))
-		
-			puts "YAY"
-			@n=AnimMesh.new(getScene,data)
-			@anim=true
-		else
-			zoom||=0.1
-			zoom=zoom.to_f
-			data=MeshData.new(file,zoom,tex)
-			@n=Mesh.new(getScene,data,AGVector4.new(0,0,0),-30)
-		end
-			
-		if @anim
-			@n.setAnimation("go")
-		end
-		getScene.addNode(@n)
-		@rot=0.0
-	end
-	
-	def eventFrame(s)
-		super(s)
-		delay(10)
-		if not @anim
-			return
-		end
-		@rot+=2
-		@n.setRotation(AGVector3.new(0,0,1), at rot)
-		if @rot>180
-			@n.setAnimation("eat")
-		end
-	end
+  def initialize(w,h,file,tex,zoom=0.1)
+    super(w,h)
+    @anim=false
+    if file==nil
+      require 'gen_tree.rb'
+      data=genTree
+      @n=Mesh.new(getScene,data,AGVector4.new(0,0,0),-30)
+    elsif file=~/.*anim/
+      data=AnimMeshData.new("data/models/sheep.anim")
+      data.setTransform(AGMatrix4.new(Math::PI,AGVector3.new(0,0,1))*AGMatrix4.new(Math::PI/2,AGVector3.new(1,0,0)))
+    
+      puts "YAY"
+      @n=AnimMesh.new(getScene,data)
+      @anim=true
+    else
+      zoom||=0.1
+      zoom=zoom.to_f
+      data=MeshData.new(file,zoom,tex)
+      @n=Mesh.new(getScene,data,AGVector4.new(0,0,0),-30)
+    end
+      
+    if @anim
+      @n.setAnimation("go")
+    end
+    getScene.addNode(@n)
+    @rot=0.0
+  end
+  
+  def eventFrame(s)
+    super(s)
+    delay(10)
+    if not @anim
+      return
+    end
+    @rot+=2
+    @n.setRotation(AGVector3.new(0,0,1), at rot)
+    if @rot>180
+      @n.setAnimation("eat")
+    end
+  end
 end
 
 a=nil
 if ARGV.length<2
-	a=App.new(800,600,nil,nil)
+  a=App.new(800,600,nil,nil)
 else
-	a=App.new(800,600,ARGV[0],ARGV[1],ARGV[2])
+  a=App.new(800,600,ARGV[0],ARGV[1],ARGV[2])
 end
-a.run
\ No newline at end of file
+a.run

Modified: antargis/trunk/ruby/meshes/grass.rb
===================================================================
--- antargis/trunk/ruby/meshes/grass.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/meshes/grass.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,173 +1,173 @@
 def getGrassMeshData(size,many=4,texture=nil,bush=false)
-	size=(size*10).to_i/10.0
+  size=(size*10).to_i/10.0
 
-	$grassdata||={}
- 	if $grassdata[size]
-		return $grassdata[size]
-	end
-	
-	opt=MeshOptimizer.new
-	mv0=MeshVertex.new
-	mv1=MeshVertex.new
-	mv2=MeshVertex.new
-	mv3=MeshVertex.new
-	
-	for i in 1..many
-	
-	mv0.c=AGVector4.new(1,1,1,1)
-	mv1.c=AGVector4.new(1,1,1,1)
-	mv2.c=AGVector4.new(1,1,1,1)
-	mv3.c=AGVector4.new(1,1,1,1)
-	
-	if bush
-		mv0.t=AGVector2.new(0,1-0)
-		mv1.t=AGVector2.new(1,1-0)
-		mv2.t=AGVector2.new(1,1-0.5)
-		mv3.t=AGVector2.new(0,1-0.5)
-	else
-		mv0.t=AGVector2.new(0,1-0)
-		mv1.t=AGVector2.new(1,1-0)
-		mv2.t=AGVector2.new(1,1-1)
-		mv3.t=AGVector2.new(0,1-1)
-	end
-	
-	w=size
-	h=w
-	
-	if bush
-		h*=0.6
-	end
+  $grassdata||={}
+   if $grassdata[size]
+    return $grassdata[size]
+  end
+  
+  opt=MeshOptimizer.new
+  mv0=MeshVertex.new
+  mv1=MeshVertex.new
+  mv2=MeshVertex.new
+  mv3=MeshVertex.new
+  
+  for i in 1..many
+  
+  mv0.c=AGVector4.new(1,1,1,1)
+  mv1.c=AGVector4.new(1,1,1,1)
+  mv2.c=AGVector4.new(1,1,1,1)
+  mv3.c=AGVector4.new(1,1,1,1)
+  
+  if bush
+    mv0.t=AGVector2.new(0,1-0)
+    mv1.t=AGVector2.new(1,1-0)
+    mv2.t=AGVector2.new(1,1-0.5)
+    mv3.t=AGVector2.new(0,1-0.5)
+  else
+    mv0.t=AGVector2.new(0,1-0)
+    mv1.t=AGVector2.new(1,1-0)
+    mv2.t=AGVector2.new(1,1-1)
+    mv3.t=AGVector2.new(0,1-1)
+  end
+  
+  w=size
+  h=w
+  
+  if bush
+    h*=0.6
+  end
 
-	v0=AGVector4.new(-w,0,0)
-	v1=AGVector4.new(w,0,0)
-	v2=AGVector4.new(w,0,h*2)
-	v3=AGVector4.new(-w,0,h*2)
-	
-	if i==1
-		vadd=AGVector4.new(0,0,0,0)
-	else
-		vadd=AGVector4.new(agRand(1.0)*2,agRand(1.0)*2,0,0)
-	end
-	
-	mv0.v=v0+vadd
-	mv1.v=v1+vadd
-	mv2.v=v2+vadd
-	mv3.v=v3+vadd
-	
-	mv0.n=AGVector3.new(0,-1,0)
-	mv1.n=AGVector3.new(0,-1,0)
-	mv2.n=AGVector3.new(0,-1,0)
-	mv3.n=AGVector3.new(0,-1,0)
-	
-	opt.add(mv0)
-	opt.add(mv1)
-	opt.add(mv2)
-	
-	opt.add(mv0)
-	opt.add(mv2)
-	opt.add(mv3)
-	
-	turn=AGMatrix4.new(Math::PI/3,AGVector3.new(0,0,1))
-	
-	mv0.v=turn*v0+vadd
-	mv1.v=turn*v1+vadd
-	mv2.v=turn*v2+vadd
-	mv3.v=turn*v3+vadd
-	
- 	opt.add(mv0)
- 	opt.add(mv1)
- 	opt.add(mv2)
-# 	
- 	opt.add(mv0)
- 	opt.add(mv2)
- 	opt.add(mv3)
-	
-	turn=AGMatrix4.new(-1*Math::PI/3,AGVector3.new(0,0,1))
-	
-	mv0.v=turn*v0+vadd
-	mv1.v=turn*v1+vadd
-	mv2.v=turn*v2+vadd
-	mv3.v=turn*v3+vadd
-	
- 	opt.add(mv0)
- 	opt.add(mv1)
- 	opt.add(mv2)
-# 	
- 	opt.add(mv0)
- 	opt.add(mv2)
- 	opt.add(mv3)
-	
-	if bush
-		mv0.t=AGVector2.new(0,1-0.5)
-		mv1.t=AGVector2.new(1,1-0.5)
-		mv2.t=AGVector2.new(1,1-1)
-		mv3.t=AGVector2.new(0,1-1)
-		mv0.n=AGVector3.new(0,0,1)
-		mv1.n=AGVector3.new(0,0,1)
-		mv2.n=AGVector3.new(0,0,1)
-		mv3.n=AGVector3.new(0,0,1)
-		mv0.v=AGVector4.new(-w,-w,h/3)
-		mv1.v=AGVector4.new( w,-w,h/3)
-		mv2.v=AGVector4.new( w, w,h/3)
-		mv3.v=AGVector4.new(-w, w,h/3)
-		opt.add(mv0)
-		opt.add(mv1)
-		opt.add(mv2)
-		
-		opt.add(mv0)
-		opt.add(mv2)
-		opt.add(mv3)
-		mv0.v=AGVector4.new(-w*0.7,-w*0.7,h*0.7)
-		mv1.v=AGVector4.new( w*0.7,-w*0.7,h*0.7)
-		mv2.v=AGVector4.new( w*0.7, w*0.7,h*0.7)
-		mv3.v=AGVector4.new(-w*0.7, w*0.7,h*0.7)
-		opt.add(mv0)
-		opt.add(mv1)
-		opt.add(mv2)
-		
-		opt.add(mv0)
-		opt.add(mv2)
-		opt.add(mv3)
-		
-		mv0.v=AGVector4.new(-w/2,-w/2,h/2*3)
-		mv1.v=AGVector4.new( w/2,-w/2,h/2*3)
-		mv2.v=AGVector4.new( w/2, w/2,h/2*3)
-		mv3.v=AGVector4.new(-w/2, w/2,h/2*3)
- 		opt.add(mv0)
- 		opt.add(mv1)
- 		opt.add(mv2)
- 		
- 		opt.add(mv0)
- 		opt.add(mv2)
- 		opt.add(mv3)
-	end
-	
-	
-	end
-	
-	#$grassdata[size]=MeshData.new(opt.getArray,"data/textures/models/high_grass2.png",true) #false)
-	$grassdata[size]=MeshData.new(opt.getArray,texture,true) #false) # last is shadow
-	$grassdata[size].setTransparent(true)
-	
-	if nil
-		$grassdata[size]=MeshData.new(opt.getArray,"data/textures/terrain/reed.png",true) #false)
-		$grassdata[size].setLighting(false)
-		#$grassdata[size].setOverdraw(true)
-		$grassdata[size].setTransparent(true)
-	end
-	#$grassdata[size]=MeshData.new(opt.getArray,"data/textures/models/flower1.png",false)
-	
-	return $grassdata[size]
+  v0=AGVector4.new(-w,0,0)
+  v1=AGVector4.new(w,0,0)
+  v2=AGVector4.new(w,0,h*2)
+  v3=AGVector4.new(-w,0,h*2)
+  
+  if i==1
+    vadd=AGVector4.new(0,0,0,0)
+  else
+    vadd=AGVector4.new(agRand(1.0)*2,agRand(1.0)*2,0,0)
+  end
+  
+  mv0.v=v0+vadd
+  mv1.v=v1+vadd
+  mv2.v=v2+vadd
+  mv3.v=v3+vadd
+  
+  mv0.n=AGVector3.new(0,-1,0)
+  mv1.n=AGVector3.new(0,-1,0)
+  mv2.n=AGVector3.new(0,-1,0)
+  mv3.n=AGVector3.new(0,-1,0)
+  
+  opt.add(mv0)
+  opt.add(mv1)
+  opt.add(mv2)
+  
+  opt.add(mv0)
+  opt.add(mv2)
+  opt.add(mv3)
+  
+  turn=AGMatrix4.new(Math::PI/3,AGVector3.new(0,0,1))
+  
+  mv0.v=turn*v0+vadd
+  mv1.v=turn*v1+vadd
+  mv2.v=turn*v2+vadd
+  mv3.v=turn*v3+vadd
+  
+   opt.add(mv0)
+   opt.add(mv1)
+   opt.add(mv2)
+#   
+   opt.add(mv0)
+   opt.add(mv2)
+   opt.add(mv3)
+  
+  turn=AGMatrix4.new(-1*Math::PI/3,AGVector3.new(0,0,1))
+  
+  mv0.v=turn*v0+vadd
+  mv1.v=turn*v1+vadd
+  mv2.v=turn*v2+vadd
+  mv3.v=turn*v3+vadd
+  
+   opt.add(mv0)
+   opt.add(mv1)
+   opt.add(mv2)
+#   
+   opt.add(mv0)
+   opt.add(mv2)
+   opt.add(mv3)
+  
+  if bush
+    mv0.t=AGVector2.new(0,1-0.5)
+    mv1.t=AGVector2.new(1,1-0.5)
+    mv2.t=AGVector2.new(1,1-1)
+    mv3.t=AGVector2.new(0,1-1)
+    mv0.n=AGVector3.new(0,0,1)
+    mv1.n=AGVector3.new(0,0,1)
+    mv2.n=AGVector3.new(0,0,1)
+    mv3.n=AGVector3.new(0,0,1)
+    mv0.v=AGVector4.new(-w,-w,h/3)
+    mv1.v=AGVector4.new( w,-w,h/3)
+    mv2.v=AGVector4.new( w, w,h/3)
+    mv3.v=AGVector4.new(-w, w,h/3)
+    opt.add(mv0)
+    opt.add(mv1)
+    opt.add(mv2)
+    
+    opt.add(mv0)
+    opt.add(mv2)
+    opt.add(mv3)
+    mv0.v=AGVector4.new(-w*0.7,-w*0.7,h*0.7)
+    mv1.v=AGVector4.new( w*0.7,-w*0.7,h*0.7)
+    mv2.v=AGVector4.new( w*0.7, w*0.7,h*0.7)
+    mv3.v=AGVector4.new(-w*0.7, w*0.7,h*0.7)
+    opt.add(mv0)
+    opt.add(mv1)
+    opt.add(mv2)
+    
+    opt.add(mv0)
+    opt.add(mv2)
+    opt.add(mv3)
+    
+    mv0.v=AGVector4.new(-w/2,-w/2,h/2*3)
+    mv1.v=AGVector4.new( w/2,-w/2,h/2*3)
+    mv2.v=AGVector4.new( w/2, w/2,h/2*3)
+    mv3.v=AGVector4.new(-w/2, w/2,h/2*3)
+     opt.add(mv0)
+     opt.add(mv1)
+     opt.add(mv2)
+     
+     opt.add(mv0)
+     opt.add(mv2)
+     opt.add(mv3)
+  end
+  
+  
+  end
+  
+  #$grassdata[size]=MeshData.new(opt.getArray,"data/textures/models/high_grass2.png",true) #false)
+  $grassdata[size]=MeshData.new(opt.getArray,texture,true) #false) # last is shadow
+  $grassdata[size].setTransparent(true)
+  
+  if nil
+    $grassdata[size]=MeshData.new(opt.getArray,"data/textures/terrain/reed.png",true) #false)
+    $grassdata[size].setLighting(false)
+    #$grassdata[size].setOverdraw(true)
+    $grassdata[size].setTransparent(true)
+  end
+  #$grassdata[size]=MeshData.new(opt.getArray,"data/textures/models/flower1.png",false)
+  
+  return $grassdata[size]
 end
 
 def makeGrassMesh(scene,size=0.4)
-	return nil if scene.nil?
-	return Mesh.new(scene,getGrassMeshData(size,4,"data/textures/models/high_grass2.png"),AGVector4.new(0,0,0,0),0)
+  return nil if scene.nil?
+  return Mesh.new(scene,getGrassMeshData(size,4,"data/textures/models/high_grass2.png"),AGVector4.new(0,0,0,0),0)
 end
 
 def makeBushMesh(scene,size=0.4)
-	return nil if scene.nil?
-	assert{scene.is_a?(Scene)}
-	assert{size.is_a?(Numeric)}
-	return Mesh.new(scene,getGrassMeshData(size,1,"data/textures/models/bush5.png",true),AGVector4.new(0,0,0,0),0)
+  return nil if scene.nil?
+  assert{scene.is_a?(Scene)}
+  assert{size.is_a?(Numeric)}
+  return Mesh.new(scene,getGrassMeshData(size,1,"data/textures/models/bush5.png",true),AGVector4.new(0,0,0,0),0)
 end

Modified: antargis/trunk/ruby/mpmap.rb
===================================================================
--- antargis/trunk/ruby/mpmap.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/mpmap.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,45 +7,45 @@
 require 'map.rb'
 
 class AntMpMap<AntRubyMap
-	def initialize(c,app,pScene,w,h,playerName="Rowen")
-		super(app,pScene,w,h,playerName)
-		@connection=c
-	end
+  def initialize(c,app,pScene,w,h,playerName="Rowen")
+    super(app,pScene,w,h,playerName)
+    @connection=c
+  end
 
-	def processMessage(message)
-		case message
-			when RestMessage
-				getByUID(message.hero).newHLRestJob(message.time)
-			when MoveMessage
-				getByUID(message.hero).newHLMoveJob(0,message.pos,message.dist)
-			when FightMessage
-				if message.defend
-					getByUID(message.hero).newHLFightJob(getByUID(message.target))
-				else
-					getByUID(message.hero).newHLFightJob(getByUID(message.target))
-				end
-			when NewPlayerMessage
-				h=AntHero.new
-				puts "C:#{message.pos.class}"
-				h.setPos(message.pos)
-				h.setName(message.name)
-				insertEntity(h)
-		end
+  def processMessage(message)
+    case message
+      when RestMessage
+        getByUID(message.hero).newHLRestJob(message.time)
+      when MoveMessage
+        getByUID(message.hero).newHLMoveJob(0,message.pos,message.dist)
+      when FightMessage
+        if message.defend
+          getByUID(message.hero).newHLFightJob(getByUID(message.target))
+        else
+          getByUID(message.hero).newHLFightJob(getByUID(message.target))
+        end
+      when NewPlayerMessage
+        h=AntHero.new
+        puts "C:#{message.pos.class}"
+        h.setPos(message.pos)
+        h.setName(message.name)
+        insertEntity(h)
+    end
 
-	end
+  end
 
-	def eventNewJobAssignedToBoss(boss)
-		if @connection
-			if boss.getPlayer==getPlayer
-				puts "===================================================="
-				puts boss.getJob
-				puts "===================================================="
-				m=boss.getJob.makeMessage(boss.uid)
-				@connection.sendMessage(m)
-				puts m
-				puts "message sent?????"
-			end
-		end
-	end
+  def eventNewJobAssignedToBoss(boss)
+    if @connection
+      if boss.getPlayer==getPlayer
+        puts "===================================================="
+        puts boss.getJob
+        puts "===================================================="
+        m=boss.getJob.makeMessage(boss.uid)
+        @connection.sendMessage(m)
+        puts m
+        puts "message sent?????"
+      end
+    end
+  end
 
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/obj_import.rb
===================================================================
--- antargis/trunk/ruby/obj_import.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/obj_import.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -10,9 +10,9 @@
 $swap=false
 
 if File.exists?("antargislib.rb")
-	require "antargislib.rb"
+  require "antargislib.rb"
 else
-	require "ruby/antargislib.rb"
+  require "ruby/antargislib.rb"
 end
 
 $vs=[]
@@ -21,62 +21,62 @@
 $fs=[]
 
 if ARGV.length<2
-	puts "ARGS: ./obj_import.rb aaa.obj bbb.ant2"
-	exit
+  puts "ARGS: ./obj_import.rb aaa.obj bbb.ant2"
+  exit
 end
 infile=ARGV[0]
 outfile=ARGV[1]
 
 if File.exists?(outfile) and not (ARGV.length>2 and ARGV[2]=="-f")
-	throw "File already exists"
+  throw "File already exists"
 end
 
 File.open(infile).each_line{|line|
-	#puts "line:"+line
-	if line=~/#.*/ then
-		# ignore - it's a comment
-	elsif line=~/^v .*/ then
-		x,y,z=line.gsub("v ","").split(" ").collect{|a|a.to_f}
-		if $swap
-			z,y=y,z
-		end
-		$vs.push([x,y,z])
-	elsif line=~/^vt .*/ then
-		x,y=line.gsub("vt ","").split(" ").collect{|a|a.to_f}
-		$ts.push([x,y])
-	elsif line=~/^vn .*/ then
-		a,x,y,z=line.gsub("vt ","").split(" ").collect{|a|a.to_f}
-		printf "%f,%f,%f\n",x,y,z
-		$ns.push([x,y,z])
-	elsif line=~/^f .*/ then
-		vs=line.gsub("f ","").split(" ")
-		faces=[]
-		vs.each{|v|
-			v,t,n=v.split("/").collect{|a|a.to_i-1}
-			faces.push([v,t,n])
-		}
-		$fs.push(faces)
-	else	
-		puts "ignored:"+line
-	end
+  #puts "line:"+line
+  if line=~/#.*/ then
+    # ignore - it's a comment
+  elsif line=~/^v .*/ then
+    x,y,z=line.gsub("v ","").split(" ").collect{|a|a.to_f}
+    if $swap
+      z,y=y,z
+    end
+    $vs.push([x,y,z])
+  elsif line=~/^vt .*/ then
+    x,y=line.gsub("vt ","").split(" ").collect{|a|a.to_f}
+    $ts.push([x,y])
+  elsif line=~/^vn .*/ then
+    a,x,y,z=line.gsub("vt ","").split(" ").collect{|a|a.to_f}
+    printf "%f,%f,%f\n",x,y,z
+    $ns.push([x,y,z])
+  elsif line=~/^f .*/ then
+    vs=line.gsub("f ","").split(" ")
+    faces=[]
+    vs.each{|v|
+      v,t,n=v.split("/").collect{|a|a.to_i-1}
+      faces.push([v,t,n])
+    }
+    $fs.push(faces)
+  else  
+    puts "ignored:"+line
+  end
 }
 
 file=File.new(outfile,"wb")
 file.print([1].pack("v"))
 file.print([$fs.length].pack("v"))
 $fs.each{|face|
-	file.print([face.length].pack("v"))
-	face.each{|mv|
-		file.print($vs[mv[0]].pack("eee"))
-		file.print($ns[mv[2]].pack("eee"))
-		file.print([1,1,1].pack("eee"))
-		if $ts[mv[1]]
-			file.print($ts[mv[1]].pack("ee"))
-		else
-			file.print([0,0].pack("ee"))
-		end
-	}
+  file.print([face.length].pack("v"))
+  face.each{|mv|
+    file.print($vs[mv[0]].pack("eee"))
+    file.print($ns[mv[2]].pack("eee"))
+    file.print([1,1,1].pack("eee"))
+    if $ts[mv[1]]
+      file.print($ts[mv[1]].pack("ee"))
+    else
+      file.print([0,0].pack("ee"))
+    end
+  }
 }
 
 
-file.close
\ No newline at end of file
+file.close

Modified: antargis/trunk/ruby/runtests.rb
===================================================================
--- antargis/trunk/ruby/runtests.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/runtests.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -4,14 +4,14 @@
 #
 
 def runScript(s)
-	r=`ruby #{s} 2>/dev/null`	
-	status=$?
-	#puts r
-	#puts status
-	if status!=0
-		#raise "sth wrong"
-	end
-	status==0
+  r=`ruby #{s} 2>/dev/null`  
+  status=$?
+  #puts r
+  #puts status
+  if status!=0
+    #raise "sth wrong"
+  end
+  status==0
 end
 
 tests=Dir["ruby/tests/*.rb"]
@@ -19,17 +19,17 @@
 failed=[]
 
 tests.each{|t|
-	s=" "*(40-t.length)
-	print "Running: "+t+s
-	if not runScript(t)
-		failed.push(t)
-		puts "FAILED"
-	else
-		puts "OK"
-	end
+  s=" "*(40-t.length)
+  print "Running: "+t+s
+  if not runScript(t)
+    failed.push(t)
+    puts "FAILED"
+  else
+    puts "OK"
+  end
 
 }
 
 puts
 puts "Successfully completed: #{tests.length-failed.length}"
-puts "Failed tests          : #{failed.length}"
\ No newline at end of file
+puts "Failed tests          : #{failed.length}"

Modified: antargis/trunk/ruby/spec/level_testing.rb
===================================================================
--- antargis/trunk/ruby/spec/level_testing.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/level_testing.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -3,54 +3,54 @@
 require 'ruby/ant_application.rb'
 
 module LevelTesting
-	class TestEntity
-		class ClickNode
-			attr_accessor :node
-		end
+  class TestEntity
+    class ClickNode
+      attr_accessor :node
+    end
 
-		def initialize(entity,app)
-			@entity=entity
-			@app=app
-		end
-		def click(button=1)
-			n=ClickNode.new
-			n.node=@entity.getMesh[0]
-			@app.eventEntitiesClicked([n],button)
-		end
-		def method_missing(*s)
-			@entity.send(*s)
-		end
-	end
-	
-	def entities(type)
-		map.getByType(type).collect{|e|TestEntity.new(e, at app)}
-	end
-	
-	include GuiTest
-	def getTestApp(testLevelName)
-		case testLevelName
-			when :tutorial0
-				file="data/levels/tutorial/tutorial0.antlvl"
-			when :tutorial3
-				file="data/levels/tutorial/tutorial3.antlvl"
-	    end
-	    clientConnection=nil
-	    @app=makeTestAppClass(AntGameApp).new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
-	end
-	
-	def runUntilLowLevelJobToFinish(entity)
-		observe(entity,:eventJobFinished) do |observer|
-			while observer.isNotCalled
-				advance
-			end
-		end
-	end
-	
+    def initialize(entity,app)
+      @entity=entity
+      @app=app
+    end
+    def click(button=1)
+      n=ClickNode.new
+      n.node=@entity.getMesh[0]
+      @app.eventEntitiesClicked([n],button)
+    end
+    def method_missing(*s)
+      @entity.send(*s)
+    end
+  end
+  
+  def entities(type)
+    map.getByType(type).collect{|e|TestEntity.new(e, at app)}
+  end
+  
+  include GuiTest
+  def getTestApp(testLevelName)
+    case testLevelName
+      when :tutorial0
+        file="data/levels/tutorial/tutorial0.antlvl"
+      when :tutorial3
+        file="data/levels/tutorial/tutorial3.antlvl"
+      end
+      clientConnection=nil
+      @app=makeTestAppClass(AntGameApp).new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
+  end
+  
+  def runUntilLowLevelJobToFinish(entity)
+    observe(entity,:eventJobFinished) do |observer|
+      while observer.isNotCalled
+        advance
+      end
+    end
+  end
+  
   def clickAwayStory
-	  telltaleWidget=widget("TellTale")
-		raise if telltaleWidget.nil?
+    telltaleWidget=widget("TellTale")
+    raise if telltaleWidget.nil?
     return if telltaleWidget.nil?
-	
+  
     telltaleWidget.should_not be_nil
     telltaleWidget.should be_visible
     okButton=telltaleWidget.child("ok")
@@ -65,44 +65,44 @@
       trials.should <10
     end
   end
-	
-	
-	def advance(time=nil)
-		step=0.3
-		time||=0
-		begin
-			@app.getMap.move(step)
-			@app.step
-			time-=step
-		end while time>step
-	end	
+  
+  
+  def advance(time=nil)
+    step=0.3
+    time||=0
+    begin
+      @app.getMap.move(step)
+      @app.step
+      time-=step
+    end while time>step
+  end  
 
   def hero(name)
-  	h=map.getByName(name)
-		h.should_not be_nil
-		h.should be_a_kind_of(AntHero)
-		h
+    h=map.getByName(name)
+    h.should_not be_nil
+    h.should be_a_kind_of(AntHero)
+    h
   end
-	def building(name)
-		b=map.getByName(name)
-		b.should_not be_nil
-		b.should be_a_kind_of(AntHouse)
-		b
-	end
-	def map
-		@app.getMap
-	end
-	
-	def clickMap(pos2d,button=1)
-		@app.eventMapClicked(pos2d,button)
-	end
-	
-	def waitForStory
-	  while not storyIsDisplayed
-			advance
-		 end
-	end
+  def building(name)
+    b=map.getByName(name)
+    b.should_not be_nil
+    b.should be_a_kind_of(AntHouse)
+    b
+  end
+  def map
+    @app.getMap
+  end
+  
+  def clickMap(pos2d,button=1)
+    @app.eventMapClicked(pos2d,button)
+  end
+  
+  def waitForStory
+    while not storyIsDisplayed
+      advance
+     end
+  end
   def storyIsDisplayed
     widget("TellTale").valid and widget("TellTale").visible?
   end  
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/spec/spec_basic.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_basic.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_basic.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -2,13 +2,13 @@
 require 'ruby/gui/ag_tools.rb'
 
 describe "Array.shuffle" do
-	it "should really shuffle an array (in a 100 trials)" do
-		tries=100
-		a=[1,2,3,4,5]
-		while tries>0
-			break if a!=a.shuffle
-			tries-=1
-		end
-		tries.should >0
-	end
-end
\ No newline at end of file
+  it "should really shuffle an array (in a 100 trials)" do
+    tries=100
+    a=[1,2,3,4,5]
+    while tries>0
+      break if a!=a.shuffle
+      tries-=1
+    end
+    tries.should >0
+  end
+end

Modified: antargis/trunk/ruby/spec/spec_call.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_call.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_call.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -17,26 +17,26 @@
       end
     end
     a=A.new
-		a.y.should == "hi"
+    a.y.should == "hi"
     lambda{a.y.should be_nil}.should cross(a,:y)
-		a.y.should == "hi"
+    a.y.should == "hi"
   end
-	it "should work with should_not" do
-		lambda{}.should_not cross(:globalTestFunction)
-	end
+  it "should work with should_not" do
+    lambda{}.should_not cross(:globalTestFunction)
+  end
 
-	it "should work with new method" do
-		class A
-			attr_reader :a
-			def initialize
-				@a=10
-			end
-		end
-		
-		lambda{A.new}.should cross(A,:initialize)
-		lambda{}.should_not cross(A,:initialize)
-		lambda{a=A.new}.should cross(A,:initialize)
-	end
+  it "should work with new method" do
+    class A
+      attr_reader :a
+      def initialize
+        @a=10
+      end
+    end
+    
+    lambda{A.new}.should cross(A,:initialize)
+    lambda{}.should_not cross(A,:initialize)
+    lambda{a=A.new}.should cross(A,:initialize)
+  end
 
 end
 
@@ -72,7 +72,7 @@
   
   it "should work for class-methods" do
     lambda{Test.test2}.should cross(Test,:test2)
-		Test.test2.should equal(:test_2)
+    Test.test2.should equal(:test_2)
   end
   
   it "should work for object-methods" do
@@ -86,12 +86,12 @@
     lambda{Test.new}.should cross(Test,:initialize)
   end
 
-	it "failure measure" do
-		Cross.new("A","B").failure_message.should =~/expected .* to call A.B.*/
-	end
-	it "negative failure measure" do
-		Cross.new("A","B").negative_failure_message.should =~/expected .* not to call A.B.*/
-	end
+  it "failure measure" do
+    Cross.new("A","B").failure_message.should =~/expected .* to call A.B.*/
+  end
+  it "negative failure measure" do
+    Cross.new("A","B").negative_failure_message.should =~/expected .* not to call A.B.*/
+  end
   
   it "should work with local classes" do
     class A

Modified: antargis/trunk/ruby/spec/spec_campaign.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_campaign.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_campaign.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -2,68 +2,68 @@
 require 'ruby/campaign.rb'
 
 describe Campaign do
-	before(:all) do
-		@campaigns=getCampaigns
-		@tutorial=@campaigns[0]
- 		@birth=@campaigns[1]
-	end
-	it "getCampaigns should return at least 2" do
-		@campaigns.length.should >=2
- 	end
-	it "first campaign is tutorial" do
-		@tutorial.name.should == "Tutorial"
-	end
-	
-	it "tutorial has lower order than birth-campaign" do
-		tut=@campaigns.find{|c|c.name=="Tutorial"}
-		tut.should_not be_nil
-		birth=@campaigns.find{|c|c.name=="A hero is born."}
-		birth.should_not be_nil
-		tut.order.should < birth.order
-	end
+  before(:all) do
+    @campaigns=getCampaigns
+    @tutorial=@campaigns[0]
+     @birth=@campaigns[1]
+  end
+  it "getCampaigns should return at least 2" do
+    @campaigns.length.should >=2
+   end
+  it "first campaign is tutorial" do
+    @tutorial.name.should == "Tutorial"
+  end
+  
+  it "tutorial has lower order than birth-campaign" do
+    tut=@campaigns.find{|c|c.name=="Tutorial"}
+    tut.should_not be_nil
+    birth=@campaigns.find{|c|c.name=="A hero is born."}
+    birth.should_not be_nil
+    tut.order.should < birth.order
+  end
 
-	it "tutorial starts with level" do
-		@tutorial.getCurrentPart.should be_a_kind_of(CampaignLevel)
-	end
+  it "tutorial starts with level" do
+    @tutorial.getCurrentPart.should be_a_kind_of(CampaignLevel)
+  end
 
- 	it "birth campaign is second campaign" do
- 		#pp @birth.name
- 		@birth.name.should == "A hero is born."
- 	end
+   it "birth campaign is second campaign" do
+     #pp @birth.name
+     @birth.name.should == "A hero is born."
+   end
 
-	it "birth campaign starts with cutscene" do
-		@birth.getCurrentPart.should be_a_kind_of(CutScene)
-	end
- 	it "should run a story fine" do
-		OldDisplay=CutSceneDisplay.clone
-		class CutSceneDisplay
-			@@ok=false
-			@@calls={}
-			
-			# remove all methods
-			self.instance_methods.each{|m|undef_method(m) unless m=~/__.*__/}
-			def initialize
-				@@ok=true
-			end
-			def CutSceneDisplay.initok
-				@@ok 
-			end
-			def CutSceneDisplay.callCount(name)
-				@@calls[name]
-			end
-			def method_missing(name,*s)
-				@@calls[name]||=0
-				@@calls[name]+=1
-			end
-		end
- 		cutscene=@birth.getCurrentPart
- 		lambda {cutscene.play}.should cross(CutSceneDisplay,:initialize)
-		CutSceneDisplay.initok.should be_false # because it wasn't hit due to "should cross"
-		CutSceneDisplay.callCount(:setImage).should >0
-		CutSceneDisplay.callCount(:setImage).should equal(CutSceneDisplay.callCount(:setText))
-		CutSceneDisplay.callCount(:setImage).should equal(CutSceneDisplay.callCount(:run))
- 		CutSceneDisplay=OldDisplay
- 	end
+  it "birth campaign starts with cutscene" do
+    @birth.getCurrentPart.should be_a_kind_of(CutScene)
+  end
+   it "should run a story fine" do
+    OldDisplay=CutSceneDisplay.clone
+    class CutSceneDisplay
+      @@ok=false
+      @@calls={}
+      
+      # remove all methods
+      self.instance_methods.each{|m|undef_method(m) unless m=~/__.*__/}
+      def initialize
+        @@ok=true
+      end
+      def CutSceneDisplay.initok
+        @@ok 
+      end
+      def CutSceneDisplay.callCount(name)
+        @@calls[name]
+      end
+      def method_missing(name,*s)
+        @@calls[name]||=0
+        @@calls[name]+=1
+      end
+    end
+     cutscene=@birth.getCurrentPart
+     lambda {cutscene.play}.should cross(CutSceneDisplay,:initialize)
+    CutSceneDisplay.initok.should be_false # because it wasn't hit due to "should cross"
+    CutSceneDisplay.callCount(:setImage).should >0
+    CutSceneDisplay.callCount(:setImage).should equal(CutSceneDisplay.callCount(:setText))
+    CutSceneDisplay.callCount(:setImage).should equal(CutSceneDisplay.callCount(:run))
+     CutSceneDisplay=OldDisplay
+   end
 
 
 end

Added: antargis/trunk/ruby/spec/spec_drawing.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_drawing.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_drawing.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -0,0 +1,6 @@
+require 'ruby/gui/testing.rb'
+
+describe "Drawing Widgets" do
+  it "should work on positioned widgets" do
+  end
+end
\ No newline at end of file

Modified: antargis/trunk/ruby/spec/spec_formation.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_formation.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_formation.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,68 +1,68 @@
 require 'ruby/spec/level_testing.rb'
 
 class MockResource
-	def get(*s)
-		0
-	end
+  def get(*s)
+    0
+  end
 end
 
 class MockMan
     def initialize(pos)
         @pos=pos
     end
-	def getPos2D
-		@pos
-	end
-	def resource
-		MockResource.new
-	end
+  def getPos2D
+    @pos
+  end
+  def resource
+    MockResource.new
+  end
 end
 
 class MockHero<MockMan
-	def initialize(pos)
-		super
-		@men=[]
-	end
-	def add(man)
-		@men << man
-	end
-	def getMen
-		@men+[self]
-	end
+  def initialize(pos)
+    super
+    @men=[]
+  end
+  def add(man)
+    @men << man
+  end
+  def getMen
+    @men+[self]
+  end
 end
 
 
 describe 'SitFormation' do
-	it "should center on heroes position with hero only" do
-		hero=MockHero.new(AGVector2.new(0,0))
-		AntFormationRest.new(hero).getPosition(hero,hero.getPos2D).should == hero.getPos2D
-	end
-	
-	(2..25).step(3){|count|
-		it "should center on heroes with #{count} men in range of 1" do
-			middle=AGVector2.new(0,0)
-			some=AGVector2.new(100,100)
-			hero=MockHero.new(middle)
-			null=AGVector2.new(0,0)
-			(1...count).each{|i|
-				hero.add(MockMan.new(some))
-			}
-			formation=AntFormationRest.new(hero)
-			poss=hero.getMen.collect{|man|
-				pos=formation.getPosition(man,hero.getPos2D)
-				puts pos
-				pos
-			}
-			sum=poss.inject(null){|a,b|a+b}
-			(sum/poss.length-middle).length.should < 1
-		end
-	}
+  it "should center on heroes position with hero only" do
+    hero=MockHero.new(AGVector2.new(0,0))
+    AntFormationRest.new(hero).getPosition(hero,hero.getPos2D).should == hero.getPos2D
+  end
+  
+  (2..25).step(3){|count|
+    it "should center on heroes with #{count} men in range of 1" do
+      middle=AGVector2.new(0,0)
+      some=AGVector2.new(100,100)
+      hero=MockHero.new(middle)
+      null=AGVector2.new(0,0)
+      (1...count).each{|i|
+        hero.add(MockMan.new(some))
+      }
+      formation=AntFormationRest.new(hero)
+      poss=hero.getMen.collect{|man|
+        pos=formation.getPosition(man,hero.getPos2D)
+        puts pos
+        pos
+      }
+      sum=poss.inject(null){|a,b|a+b}
+      (sum/poss.length-middle).length.should < 1
+    end
+  }
 end
 
 describe 'WalkFormation' do
-	it "should work correctly with only the hero"
-	it "should work correctly with a single trooper"
-	it "should work correctly with 5 troopers"
+  it "should work correctly with only the hero"
+  it "should work correctly with a single trooper"
+  it "should work correctly with 5 troopers"
     it "should work correctly with 15 troopers"
     it "should work correctly with 35 troopers"
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/spec/spec_gc.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_gc.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_gc.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -6,30 +6,30 @@
 
 
 def doapp
-	address=nil
-	Module.new.module_eval{
-		app=AGApplication.new #AGMessageObject.new #(nil,AGRect2.new(0,0,100,100)) #AGApplication.new
-		address=getAddressOfRubyObject(app)
-		app=nil
-	}
+  address=nil
+  Module.new.module_eval{
+    app=AGApplication.new #AGMessageObject.new #(nil,AGRect2.new(0,0,100,100)) #AGApplication.new
+    address=getAddressOfRubyObject(app)
+    app=nil
+  }
     address
-	#nil
+  #nil
 end
 
 describe "Garbage Collection" do
-	it "should handle AGApplication (alone) correctly" do
-		#setDebugLevel(0)
-		address=0
-		begin
-			address=doapp
-		end
-		GC.enable
-	    # allocate much mem (200 MB)
-		text="a"*1000*1000*300
-		GC.start
-		rubyObjectExists(address).should be_false
-		rubyObjectExists(getAddressOfRubyObject(getMain)).should be_true
-	end
+  it "should handle AGApplication (alone) correctly" do
+    #setDebugLevel(0)
+    address=0
+    begin
+      address=doapp
+    end
+    GC.enable
+      # allocate much mem (200 MB)
+    text="a"*1000*1000*300
+    GC.start
+    rubyObjectExists(address).should be_false
+    rubyObjectExists(getAddressOfRubyObject(getMain)).should be_true
+  end
 end
 
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/spec/spec_geometry.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_geometry.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_geometry.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -2,28 +2,28 @@
 require 'pp'
 
 describe AGCircle2,"a radius 2 circle around (10,10)" do
-	before(:each) do
-		@circleMiddle=AGVector2.new(10,10)
-		@radius=2
-		@circle=AGCircle2.new(@circleMiddle, at radius)
-	end
+  before(:each) do
+    @circleMiddle=AGVector2.new(10,10)
+    @radius=2
+    @circle=AGCircle2.new(@circleMiddle, at radius)
+  end
 
-	it "should hit an intersection line (9,0)-(9,20)" do
-		line=AGLine2.new(AGVector2.new(9,0),AGVector2.new(9,20))
-		list=@circle.collide(line)
-		list.length.should == 2
-		list.each{|p|(p- at circleMiddle).length.should == @radius}
+  it "should hit an intersection line (9,0)-(9,20)" do
+    line=AGLine2.new(AGVector2.new(9,0),AGVector2.new(9,20))
+    list=@circle.collide(line)
+    list.length.should == 2
+    list.each{|p|(p- at circleMiddle).length.should == @radius}
 
-		# should lie on line
-		list.each{|p|p.x.should ==9}
+    # should lie on line
+    list.each{|p|p.x.should ==9}
 
-	end
-	it "should not hit an line at (9,0)-(119,0)" do
-		l2=AGLine2.new(AGVector2.new(9,0),AGVector2.new(119,0))
-		list=@circle.collide(l2)
-		list.length.should ==0
+  end
+  it "should not hit an line at (9,0)-(119,0)" do
+    l2=AGLine2.new(AGVector2.new(9,0),AGVector2.new(119,0))
+    list=@circle.collide(l2)
+    list.length.should ==0
 
-	end
+  end
   
 end
 
@@ -78,4 +78,4 @@
     v=AGVector2.new(10,10)
     @r.clip(v).should == v
   end
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/spec/spec_hljob_saving.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_hljob_saving.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_hljob_saving.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -46,12 +46,12 @@
     checkRowenRest
     #advance
     lambda {
-	    @app.load
-	    dialog=widget("LoadDialog")
-	    files=dialog.getChild("Files")
-	    filename=files.getValues.keys.select{|f|f=~/#{file}/}[0]
-	    files.selectItem(filename)
-	    click(dialog.getChild("ok").getScreenRect.getMiddle)
+      @app.load
+      dialog=widget("LoadDialog")
+      files=dialog.getChild("Files")
+      filename=files.getValues.keys.select{|f|f=~/#{file}/}[0]
+      files.selectItem(filename)
+      click(dialog.getChild("ok").getScreenRect.getMiddle)
     }.should_not cross(AntEntity,:newMoveJob) #AntNewHLJob,:check)
     checkRowenRest
   end
@@ -61,4 +61,4 @@
     pp file
     loadFile(file)
   end
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/spec/spec_map.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_map.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_map.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,11 +1,11 @@
 require "ruby/spec/level_testing.rb"
 
 describe AntRubyMap,"A BoA-Ruby-map" do
-	it "should run without UI at all" do
-		map=AntRubyMap.new(nil,nil,64,64)
-		map.move(1)
-	end
+  it "should run without UI at all" do
+    map=AntRubyMap.new(nil,nil,64,64)
+    map.move(1)
+  end
   it "should not include ant_mock.rb when calling without GUI"
 
-	it "should be possible to create two maps concurrently (low prio)"
+  it "should be possible to create two maps concurrently (low prio)"
 end

Modified: antargis/trunk/ruby/spec/spec_math.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_math.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_math.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,5 +1,25 @@
 require 'ruby/spec_helper.rb'
 
+class AGMatrix3
+  def toString
+    (0..2).map{|y|"("+(0..2).map{|x|get(x,y).to_s}.join(";")+")"}.join(",")
+  end
+end
+
+def singleMatrix
+  m=AGMatrix3.new
+  m.set(0,0,1)
+  m.set(1,0,0)
+  m.set(2,0,0)
+  m.set(0,1,0)
+  m.set(1,1,1)
+  m.set(2,1,0)
+  m.set(0,2,0)
+  m.set(1,2,0)
+  m.set(2,2,1)
+  m 
+end
+
 describe "Determinant" do
   def makeQuadMatrix(*s)
     len=s.length
@@ -41,6 +61,38 @@
   end
 end
 
+describe "Gauss should work correctly" do
+  def makeMatrix(str)
+    y=0
+    m=AGMatrix3.new
+    str.gsub("(","").gsub(")","").split(",").each{|a|
+      x=0
+      a.split(";").each{|v|
+        puts "#{x},#{y}:#{v}"
+        m.set(x,y,v.to_f)
+        x+=1
+      }
+      y+=1
+      
+    }
+    m
+  end
+  def self.check(s)
+    it "should work on #{s}" do
+      m=makeMatrix(s)
+      pp s
+      pp m.toString
+      i=m.inverted
+      pp i.toString
+      (m*i).should==singleMatrix
+    end
+  end
+  
+  check("((1;0;-9),(0;1;0),(0;0;1),)")
+#  check("(1;0;-2),(0;1;0),(0;0;1)")
+end
+
+
 describe "AGMatrix3D(one with 0s on the main axis)" do
   it "should be invertable" do
     m=AGMatrix3.new
@@ -55,17 +107,4 @@
     m.set(2,2,0)
     (m.inverted*m).should == singleMatrix 
   end
-  def singleMatrix
-    m=AGMatrix3.new
-    m.set(0,0,1)
-    m.set(1,0,0)
-    m.set(2,0,0)
-    m.set(0,1,0)
-    m.set(1,1,1)
-    m.set(2,1,0)
-    m.set(0,2,0)
-    m.set(1,2,0)
-    m.set(2,2,1)
-    m 
-  end
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/spec/spec_menu.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_menu.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_menu.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,66 +7,66 @@
 require 'ruby/mainmenu.rb'
 
 describe 'Main-Menu' do
-	include GuiTest
-	before(:each) do
-		@app=makeTestAppClass(AntMenuApp).new
-		@app.step
-	end
-	it "should display credits" do
- 		widget("ticker").should be_nil
-		credits=widget("credits")
-		credits.should be_a_kind_of(AGButton)
-		credits.click
-		widget("ticker").should be_a_kind_of(AntTicker)
-		widget("exit").click
-		widget("credits").should be_a_kind_of(AGButton)
- 		widget("ticker").should be_nil
-	end
-	it "should end when clicking on quit" do
-		quit=widget("quit")
-		quit.should be_an_instance_of(AGButton)
-		@app.step
-		lambda {quit.click}.should change(@app,:quitCounter).by(1)
-	end
-	it "should be possible to select tutorial and this will start this one" do
-		tutorialButton=widget("tutorial")
-		tutorialButton.should be_an_instance_of(AGButton)
-		lambda {tutorialButton.click}.should cross(:startCampaign)
-	end
-	it "should be possible to select the tutorial in the campaign section and start it" do
-		playCampaign(0)
-	end
-	it "should be possible to select the birth-campaign and start it" do
-		playCampaign(1)
-	end
-	it "should be possible to flip fullscreen" do
-		optionsButton=widget("options")
-		optionsButton.should be_an_instance_of(AGButton)
-		optionsButton.click
-		optionsMenu=widget("OptionsMenu")
-		optionsMenu.should be_a_kind_of(AGWidget)
-		optionsMenu.should be_visible
-		fullscreenButton=optionsMenu.child("fullscreen")
-		fullscreenButton.should be_an_instance_of(AGButton)
-		lambda {fullscreenButton.click}.should change(getVideo,:fullscreen).from(false).to(true)
-		lambda {fullscreenButton.click}.should change(getVideo,:fullscreen).from(true).to(false)
-	end
-	private
-	def playCampaign(number)
-		campaignButton=widget("campaign")
-		campaignButton.should_not be_nil
-		campaignButton.click
-		menu=widget("CampaignMenu")
-		menu.should be_a_kind_of(AGLayout)
-		campaignRadio=menu.child("campaign#{number}")
-		campaignRadio.should be_a_kind_of(AGRadio)
-		campaignRadio.should_not be_checked
-		campaignRadio.click
-		campaignRadio.should be_checked
-		startButton=menu.child("start")
-		startButton.should be_a_kind_of(AGButton)
-		lambda {startButton.click}.should cross(:startCampaign)
-	end
+  include GuiTest
+  before(:each) do
+    @app=makeTestAppClass(AntMenuApp).new
+    @app.step
+  end
+  it "should display credits" do
+     widget("ticker").should be_nil
+    credits=widget("credits")
+    credits.should be_a_kind_of(AGButton)
+    credits.click
+    widget("ticker").should be_a_kind_of(AntTicker)
+    widget("exit").click
+    widget("credits").should be_a_kind_of(AGButton)
+     widget("ticker").should be_nil
+  end
+  it "should end when clicking on quit" do
+    quit=widget("quit")
+    quit.should be_an_instance_of(AGButton)
+    @app.step
+    lambda {quit.click}.should change(@app,:quitCounter).by(1)
+  end
+  it "should be possible to select tutorial and this will start this one" do
+    tutorialButton=widget("tutorial")
+    tutorialButton.should be_an_instance_of(AGButton)
+    lambda {tutorialButton.click}.should cross(:startCampaign)
+  end
+  it "should be possible to select the tutorial in the campaign section and start it" do
+    playCampaign(0)
+  end
+  it "should be possible to select the birth-campaign and start it" do
+    playCampaign(1)
+  end
+  it "should be possible to flip fullscreen" do
+    optionsButton=widget("options")
+    optionsButton.should be_an_instance_of(AGButton)
+    optionsButton.click
+    optionsMenu=widget("OptionsMenu")
+    optionsMenu.should be_a_kind_of(AGWidget)
+    optionsMenu.should be_visible
+    fullscreenButton=optionsMenu.child("fullscreen")
+    fullscreenButton.should be_an_instance_of(AGButton)
+    lambda {fullscreenButton.click}.should change(getVideo,:fullscreen).from(false).to(true)
+    lambda {fullscreenButton.click}.should change(getVideo,:fullscreen).from(true).to(false)
+  end
+  private
+  def playCampaign(number)
+    campaignButton=widget("campaign")
+    campaignButton.should_not be_nil
+    campaignButton.click
+    menu=widget("CampaignMenu")
+    menu.should be_a_kind_of(AGLayout)
+    campaignRadio=menu.child("campaign#{number}")
+    campaignRadio.should be_a_kind_of(AGRadio)
+    campaignRadio.should_not be_checked
+    campaignRadio.click
+    campaignRadio.should be_checked
+    startButton=menu.child("start")
+    startButton.should be_a_kind_of(AGButton)
+    lambda {startButton.click}.should cross(:startCampaign)
+  end
 end
 
-#end
\ No newline at end of file
+#end

Modified: antargis/trunk/ruby/spec/spec_minimap.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_minimap.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_minimap.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,3 +1,3 @@
 describe "MiniMap" do
-	it "should move the main map when clicked into"
-end
\ No newline at end of file
+  it "should move the main map when clicked into"
+end

Modified: antargis/trunk/ruby/spec/spec_run_tutorial.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_run_tutorial.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_run_tutorial.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,29 +7,29 @@
 # TODO: redesign spec for different runs
 
 describe 'Tutorial campaign' do
-	describe '- First level' do
-	  include LevelTesting
+  describe '- First level' do
+    include LevelTesting
     describe "- disjoint tests" do
-			before do
-				@app=getTestApp(:tutorial0)
-		    @app.step
-				
-			end
-			it "should start off with a story telling dialog" do
-				telltaleWidget=widget("TellTale")
-				telltaleWidget.should_not be_nil
-				telltaleWidget.should be_visible
-				textWidget=telltaleWidget.child("text")
-				textWidget.should_not be_nil
-				text=textWidget.getText.to_s
-				okButton=telltaleWidget.child("ok")
-				okButton.should_not be_nil
-				okButton.click
-				text.should_not ==(textWidget.getText.to_s)
-				@app.step
-				clickAwayStory
-				
-			end
+      before do
+        @app=getTestApp(:tutorial0)
+        @app.step
+        
+      end
+      it "should start off with a story telling dialog" do
+        telltaleWidget=widget("TellTale")
+        telltaleWidget.should_not be_nil
+        telltaleWidget.should be_visible
+        textWidget=telltaleWidget.child("text")
+        textWidget.should_not be_nil
+        text=textWidget.getText.to_s
+        okButton=telltaleWidget.child("ok")
+        okButton.should_not be_nil
+        okButton.click
+        text.should_not ==(textWidget.getText.to_s)
+        @app.step
+        clickAwayStory
+        
+      end
 
       it "should be no problem to recruit only a few men at the beginning when aggression is low" do
         storyIsDisplayed.should be_true
@@ -48,37 +48,37 @@
         rowen.getMen.length.should < menCount
         keep.getMen.length.should > 0
       end      
-      	    
-	    it "should be no problem to set aggression to maximum at the beginning" do
-	      storyIsDisplayed.should be_true
-	      clickAwayStory
-	      rowen=hero("Rowen")
-	      keep=building("Keep")
-	      rowen.getMen.length.should == 1
-	      menCount=(rowen.getMen+keep.getMen).length
-	      rowen.getAggression.should == 1
-	      rowen.setAggression(3.0)
-	      rowen.newHLRecruitJob(keep)
-	      while rowen.hasHLJob
-	        advance
-	      end
-	      rowen.getAggression.should == 3
-	      rowen.hasHLJob.should be_false
-	      rowen.getMen.length.should == menCount
-	      keep.getMen.length.should == 0
-	    end
+            
+      it "should be no problem to set aggression to maximum at the beginning" do
+        storyIsDisplayed.should be_true
+        clickAwayStory
+        rowen=hero("Rowen")
+        keep=building("Keep")
+        rowen.getMen.length.should == 1
+        menCount=(rowen.getMen+keep.getMen).length
+        rowen.getAggression.should == 1
+        rowen.setAggression(3.0)
+        rowen.newHLRecruitJob(keep)
+        while rowen.hasHLJob
+          advance
+        end
+        rowen.getAggression.should == 3
+        rowen.hasHLJob.should be_false
+        rowen.getMen.length.should == menCount
+        keep.getMen.length.should == 0
+      end
     end    
     
-		describe '- State at the beginning' do
-		  before(:all) do
-	      @app=getTestApp(:tutorial0)
-			  @map=@app.getMap
-			  @map.should be_a_kind_of(AntRubyMap)
-			  #clickAwayStory
-			  @enemy=nil
-			  @hero=nil
+    describe '- State at the beginning' do
+      before(:all) do
+        @app=getTestApp(:tutorial0)
+        @map=@app.getMap
+        @map.should be_a_kind_of(AntRubyMap)
+        #clickAwayStory
+        @enemy=nil
+        @hero=nil
         advance
-		  end
+      end
       it "should display a story-telling" do
         storyIsDisplayed.should be_true
         clickAwayStory
@@ -90,36 +90,36 @@
         hero("Rowen").getAggression.should == 1
       end
 
-			            	
-		  it "should include Rowen and an enemy" do
-		    heroes=@map.getOwnHeroes
-				enemies=@map.getHeroes- at map.getOwnHeroes
-				heroes.length.should == 1
-				enemies.length.should == 1
-				@hero=heroes[0]
-				@enemy=enemies[0]
-		  end
-		  it "should have a single enemy with a few troopers" do
-		  	getEnemy.getMen.length.should >2
-		  end
+                    
+      it "should include Rowen and an enemy" do
+        heroes=@map.getOwnHeroes
+        enemies=@map.getHeroes- at map.getOwnHeroes
+        heroes.length.should == 1
+        enemies.length.should == 1
+        @hero=heroes[0]
+        @enemy=enemies[0]
+      end
+      it "should have a single enemy with a few troopers" do
+        getEnemy.getMen.length.should >2
+      end
 
-		  it "should have Rowen with no followers yet" do
-		  	getHero.getMen.length ==1
-		  end
+      it "should have Rowen with no followers yet" do
+        getHero.getMen.length ==1
+      end
 
-		  it "should have a tower with a few men" do
-		  	towers=@map.getBuildings
-				towers.length.should == 1
-				@tower=towers[0]
-				@tower.should be_a_kind_of(AntTower)
-				@tower.getMen.length>2
-		  end
-		  it "should include more men in tower than enemy has" do
-		  	tower=@map.getBuildings[0]
-				tower.getMen.length.should > getEnemy.getMen.length
-		  end
-		  
-		end
+      it "should have a tower with a few men" do
+        towers=@map.getBuildings
+        towers.length.should == 1
+        @tower=towers[0]
+        @tower.should be_a_kind_of(AntTower)
+        @tower.getMen.length>2
+      end
+      it "should include more men in tower than enemy has" do
+        tower=@map.getBuildings[0]
+        tower.getMen.length.should > getEnemy.getMen.length
+      end
+      
+    end
     
     describe "- normal run" do
       before(:all) do
@@ -129,89 +129,89 @@
         clickAwayStory
       end
     
-			it "should be possible to recruit some men (not all)" do
-				# do a recruit job
-				@map=@app.getMap
-				hero=getHero
-	      hero.getAggression.should == 1
-				building=getBuilding
-				hero.newHLRecruitJob(building)
-				while hero.hasHLJob
-					advance
-				end
-				hero.getJob.should_not be_a_kind_of(AntHeroRecruitJob)
-				widget("TellTale").should be_visible
-				building.getMen.length.should > 0
-				hero.getMen.length.should >= 2
-			end
-	    it "should display a story part" do
-	      storyIsDisplayed.should be_true
-	      clickAwayStory
-	    end
-	
-	    it "should be possible to recruit the remaining men" do
-	      rowen=hero("Rowen")
-	      keep=building("Keep")
-	      rowen.setAggression(3)
-	      rowen.newHLRecruitJob(keep)
-	      menCount=rowen.getMen.length+keep.getMen.length
-	      while rowen.hasHLJob ; advance; end
-	      rowen.getMen.length.should == menCount
-	      keep.getMen.length.should == 0
-	      rowen.getMen.length.should > getEnemy.getMen.length
-	    end
-	    
-			it "should be possible to defeat enemy with low aggression" do
-			  
-				hero=getHero
-				enemy=getEnemy
-	      hero.setAggression(1)
-				hero.newHLFightJob(enemy)
-				hero.getJob.should be_a_kind_of(AntHeroFightJob)
-				enemy.hasHLJob.should be_false
-	      trials=300
-				while hero.hasHLJob
-					puts hero.getJob
-					advance
-	        break if storyIsDisplayed
-	        trials.should > 0
-	        trials-=1
-				end
-	      storyIsDisplayed.should be_true
-				clickAwayStory
-				advance
-		    @app.result.won.should == "won"
-	      map.getOwnHeroes.length.should == 2
-			end
-			
-			
-			it "should be possible to dismiss some people" do
-				hero=getHero
-				hero.setAggression(1)
-				oldMenCount=hero.getMen.length
-				oldMenCount.should > 1
-				hero.newHLDismissJob
-				while hero.hasHLJob
-					advance
-				end
-				menCount=hero.getMen.length
-				menCount.should < oldMenCount
-			end
-    end			
-		
-	
-		def getEnemies
-			enemies=map.getHeroes-map.getOwnHeroes
-			enemies
-		end
-		def getEnemy
-		  getEnemies[0]
-		end
-		def getHero
-		  @app.getMap.getOwnHeroes[0]
-		end
-		def getBuilding
-			@app.getMap.getBuildings[0]
-		end
-	end
-end
\ No newline at end of file
+      it "should be possible to recruit some men (not all)" do
+        # do a recruit job
+        @map=@app.getMap
+        hero=getHero
+        hero.getAggression.should == 1
+        building=getBuilding
+        hero.newHLRecruitJob(building)
+        while hero.hasHLJob
+          advance
+        end
+        hero.getJob.should_not be_a_kind_of(AntHeroRecruitJob)
+        widget("TellTale").should be_visible
+        building.getMen.length.should > 0
+        hero.getMen.length.should >= 2
+      end
+      it "should display a story part" do
+        storyIsDisplayed.should be_true
+        clickAwayStory
+      end
+  
+      it "should be possible to recruit the remaining men" do
+        rowen=hero("Rowen")
+        keep=building("Keep")
+        rowen.setAggression(3)
+        rowen.newHLRecruitJob(keep)
+        menCount=rowen.getMen.length+keep.getMen.length
+        while rowen.hasHLJob ; advance; end
+        rowen.getMen.length.should == menCount
+        keep.getMen.length.should == 0
+        rowen.getMen.length.should > getEnemy.getMen.length
+      end
+      
+      it "should be possible to defeat enemy with low aggression" do
+        
+        hero=getHero
+        enemy=getEnemy
+        hero.setAggression(1)
+        hero.newHLFightJob(enemy)
+        hero.getJob.should be_a_kind_of(AntHeroFightJob)
+        enemy.hasHLJob.should be_false
+        trials=300
+        while hero.hasHLJob
+          puts hero.getJob
+          advance
+          break if storyIsDisplayed
+          trials.should > 0
+          trials-=1
+        end
+        storyIsDisplayed.should be_true
+        clickAwayStory
+        advance
+        @app.result.won.should == "won"
+        map.getOwnHeroes.length.should == 2
+      end
+      
+      
+      it "should be possible to dismiss some people" do
+        hero=getHero
+        hero.setAggression(1)
+        oldMenCount=hero.getMen.length
+        oldMenCount.should > 1
+        hero.newHLDismissJob
+        while hero.hasHLJob
+          advance
+        end
+        menCount=hero.getMen.length
+        menCount.should < oldMenCount
+      end
+    end      
+    
+  
+    def getEnemies
+      enemies=map.getHeroes-map.getOwnHeroes
+      enemies
+    end
+    def getEnemy
+      getEnemies[0]
+    end
+    def getHero
+      @app.getMap.getOwnHeroes[0]
+    end
+    def getBuilding
+      @app.getMap.getBuildings[0]
+    end
+  end
+end

Modified: antargis/trunk/ruby/spec/spec_screenshot.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_screenshot.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_screenshot.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -18,9 +18,9 @@
     checkSurface(surface, @red).should be_true
   end
   it "should be possible to grab back-buffer screenshot with readpixels" do
-	  fill(@blue)
-	  flip
-	  fill(@red)
+    fill(@blue)
+    flip
+    fill(@red)
     surface=@s.screenshotSurface(false)
     checkSurface(surface, @red).should be_true
   end
@@ -68,4 +68,4 @@
     equal
   end
 end
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/spec/spec_scrollingwidget.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_scrollingwidget.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_scrollingwidget.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -36,16 +36,16 @@
   end
   
   def makeScreenshot
-  	@makeScreenshot=true
+    @makeScreenshot=true
   end
   
   protected
   def grabScreenshot(e)
-  	if @makeScreenshot
-  	  @screenshot=getScreen.screenshotSurface(false)
-	  @makeScreenshot=nil
-  	end
-  	true
+    if @makeScreenshot
+      @screenshot=getScreen.screenshotSurface(false)
+    @makeScreenshot=nil
+    end
+    true
   end
   
   private

Deleted: antargis/trunk/ruby/spec/spec_translation.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_translation.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_translation.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,15 +0,0 @@
-require 'ruby/spec/level_testing.rb'
-
-describe "Checking translation" do
-  
-  include LevelTesting
-  
-  before(:all) do
-    getTestApp(:tutorial0)
-    advance
-  end
-  
-  it "should diplay normal text and special chars like backslashes" do
-    1.should == 0
-  end
-end
\ No newline at end of file

Modified: antargis/trunk/ruby/state_machine/ant_hl_job_states.rb
===================================================================
--- antargis/trunk/ruby/state_machine/ant_hl_job_states.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/state_machine/ant_hl_job_states.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,61 +1,61 @@
 require 'ruby/state_machine/state_machine.rb'
 
 class HLJob_New_BaseState<StateMachineNode
-	def hero
-		dict[:hero]
-	end
-	def allMen
-		dict[:hero].getMen
-	end
-	def getTime
-		getMap.getTime
-	end
+  def hero
+    dict[:hero]
+  end
+  def allMen
+    dict[:hero].getMen
+  end
+  def getTime
+    getMap.getTime
+  end
 end
 
 class HLJob_DirState<HLJob_New_BaseState
-	def formatDir
-		(targetPos-hero.getPos2D).normalized
-	end
-	def targetPos
-		dict[:targetPos]
-	end
+  def formatDir
+    (targetPos-hero.getPos2D).normalized
+  end
+  def targetPos
+    dict[:targetPos]
+  end
 end
 
 class HLJob_FormatWalk_State<HLJob_DirState
-	# needed: getTime
+  # needed: getTime
 
-	# wait 5 seconds at max for formatting
-	FORMAT_MAX_TIME=5
+  # wait 5 seconds at max for formatting
+  FORMAT_MAX_TIME=5
 
-	def eventEnter
-		hero.formation=AntFormationBlock.new(hero,formatDir)
-		heroPos=hero.getPos2D
-		allMen.each{|man|
-			pos=hero.getFormation(man,heroPos)
-			man.walkTo(pos)
-			man.hlJobMode[:formatting]=true
-		}
-		@formatStart=getTime
-	end
+  def eventEnter
+    hero.formation=AntFormationBlock.new(hero,formatDir)
+    heroPos=hero.getPos2D
+    allMen.each{|man|
+      pos=hero.getFormation(man,heroPos)
+      man.walkTo(pos)
+      man.hlJobMode[:formatting]=true
+    }
+    @formatStart=getTime
+  end
 
-	def assign(man)
-		#raise 1
-		man.setDirection(180-(targetPos-hero.getPos2D).normalized.getAngle.angle*180.0/Math::PI)
-		man.standStill
-		man.hlJobMode.delete(:formatting)
-	end
+  def assign(man)
+    #raise 1
+    man.setDirection(180-(targetPos-hero.getPos2D).normalized.getAngle.angle*180.0/Math::PI)
+    man.standStill
+    man.hlJobMode.delete(:formatting)
+  end
 
-	def ready
-		if getTime- at formatStart>FORMAT_MAX_TIME
-			puts "MUST BE READY"
-			return true
-		end
-		allMen.each{|man|
-			puts "formatting:#{man}:#{man.hlJobMode[:formatting]}"
-			if man.hlJobMode[:formatting]
-				return false
-			end
-		}
-		return true
-	end
-end
\ No newline at end of file
+  def ready
+    if getTime- at formatStart>FORMAT_MAX_TIME
+      puts "MUST BE READY"
+      return true
+    end
+    allMen.each{|man|
+      puts "formatting:#{man}:#{man.hlJobMode[:formatting]}"
+      if man.hlJobMode[:formatting]
+        return false
+      end
+    }
+    return true
+  end
+end

Modified: antargis/trunk/ruby/state_machine/spec/job_states.rb
===================================================================
--- antargis/trunk/ruby/state_machine/spec/job_states.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/state_machine/spec/job_states.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -6,79 +6,79 @@
 require 'ruby/state_machine/ant_hl_job_states.rb'
 
 # class MockEnt
-# 	def setPos(p)
-# 		@p=p
-# 	end
+#   def setPos(p)
+#     @p=p
+#   end
 # end
 # 
 # class AntHero<MockEnt
-# 	def initialize
-# 		@men=[]
-# 	end
-# 	def addMan(m)
-# 		@men << m
-# 	end
+#   def initialize
+#     @men=[]
+#   end
+#   def addMan(m)
+#     @men << m
+#   end
 # end
 # class AntMan<MockEnt
-# 	def setBoss(b)
-# 		@boss=b
-# 		@boss.addMan(self)
-# 	end
+#   def setBoss(b)
+#     @boss=b
+#     @boss.addMan(self)
+#   end
 # end
 
 class JobTestingSuite
-	attr_reader :hero, :entities, :men
-	def initialize
-		app=AGApplication.new
-		scene=Scene.new(800,600)
-		@map=AntRubyMap.new(app,scene,800,600)
-		@hero=AntHero.new
-		@hero.setPos(AGVector2.new(2,2))
-		@men=[]
-		vecs=[[2,1],[1,1]]
-		vecs.each{|v|
-			man=AntMan.new
-			man.setPos(AGVector2.new(v[0],v[1]))
-			man.setBoss(@hero)
-			@men << man
-		}
-		@entities=@men+[@hero]
-	end
+  attr_reader :hero, :entities, :men
+  def initialize
+    app=AGApplication.new
+    scene=Scene.new(800,600)
+    @map=AntRubyMap.new(app,scene,800,600)
+    @hero=AntHero.new
+    @hero.setPos(AGVector2.new(2,2))
+    @men=[]
+    vecs=[[2,1],[1,1]]
+    vecs.each{|v|
+      man=AntMan.new
+      man.setPos(AGVector2.new(v[0],v[1]))
+      man.setBoss(@hero)
+      @men << man
+    }
+    @entities=@men+[@hero]
+  end
 end
 
 describe HLJob_FormatWalk_State, "Formatting state" do
-	# initialize a state-machine-def
-	before(:all) do
-		@def=StateMachineDefinition.new
-		@def.startNode=@def.addNode(HLJob_FormatWalk_State,:format)
-		@suite=JobTestingSuite.new		
-	end
-	before(:each) do
-		@m=@def.createMachine
-		@m.debug=true
-		@m.dict[:hero]=@suite.hero
-		@m.dict[:targetPos]=AGVector2.new(4,4)
-	end
+  # initialize a state-machine-def
+  before(:all) do
+    @def=StateMachineDefinition.new
+    @def.startNode=@def.addNode(HLJob_FormatWalk_State,:format)
+    @suite=JobTestingSuite.new    
+  end
+  before(:each) do
+    @m=@def.createMachine
+    @m.debug=true
+    @m.dict[:hero]=@suite.hero
+    @m.dict[:targetPos]=AGVector2.new(4,4)
+  end
 
-	it "should assign a job to each man" do
-		@suite.entities.each{|e|e.hasJob.should == false }
-		@m.tick(0.001)
-		@suite.entities.each{|e|e.hasJob.should == true }
-	end
+  it "should assign a job to each man" do
+    @suite.entities.each{|e|e.hasJob.should == false }
+    @m.tick(0.001)
+    @suite.entities.each{|e|e.hasJob.should == true }
+  end
 
-	it "should format men to the given formation" do
-		while not @m.finished do
-			@m.tick(1)
-			@suite.entities.each{|e|e.move(0.2)}
-		end
-		@suite.entities.each{|e|
-			e.getPos2D.should == @suite.hero.getFormation(e, at suite.hero.getPos2D)
-		}
-	end
-	
-	it "should finish in a decent time."
+  it "should format men to the given formation" do
+    while not @m.finished do
+      @m.tick(1)
+      @suite.entities.each{|e|e.move(0.2)}
+    end
+    @suite.entities.each{|e|
+      e.getPos2D.should == @suite.hero.getFormation(e, at suite.hero.getPos2D)
+    }
+  end
+  
+  it "should finish in a decent time."
 
-	it "should assign even if old jobs are assigned."
+  it "should assign even if old jobs are assigned."
 end
 
 

Modified: antargis/trunk/ruby/state_machine/spec/state_machine.rb
===================================================================
--- antargis/trunk/ruby/state_machine/spec/state_machine.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/state_machine/spec/state_machine.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -2,235 +2,235 @@
 require 'ruby/state_machine/state_machine.rb'
 
 describe StateMachineNode do
-	before(:each) do
+  before(:each) do
     @node = StateMachineNode.new(:id)
   end
 
-	it "should have id :id" do
-		@node.id.should == :id
-	end
+  it "should have id :id" do
+    @node.id.should == :id
+  end
 
-	it "should have a function dict, which is the state-machines dictionary" do
-		@node.methods.member?("dict").should == true
-	end
+  it "should have a function dict, which is the state-machines dictionary" do
+    @node.methods.member?("dict").should == true
+  end
 
-	it "accessing the dictionary when the node is not attached to a machine will raise an exception" do
-		lambda {@node.dict}.should raise_error(AntargisException)
-	end
+  it "accessing the dictionary when the node is not attached to a machine will raise an exception" do
+    lambda {@node.dict}.should raise_error(AntargisException)
+  end
 end
 
 describe StateMachineEdge do
   before(:each) do
-		@e = StateMachineEdge.new(:a,:b,:name)
+    @e = StateMachineEdge.new(:a,:b,:name)
   end
 
-	it "should have from node :a" do
-		@e.from.should == :a
-	end
-	it "should have to node :b" do
-		@e.to.should == :b
-	end
-	it "should have name :name" do
-		@e.name.should == :name
-	end
+  it "should have from node :a" do
+    @e.from.should == :a
+  end
+  it "should have to node :b" do
+    @e.to.should == :b
+  end
+  it "should have name :name" do
+    @e.name.should == :name
+  end
 end
 
 describe StateMachineDefinition, "with no node" do
-	before(:each) do
-		@d=StateMachineDefinition.new
-	end
-	it "creating a machine should raise an error" do
-		lambda {@d.createMachine}.should raise_error(AntargisException) #("startnode not set")
-	end
+  before(:each) do
+    @d=StateMachineDefinition.new
+  end
+  it "creating a machine should raise an error" do
+    lambda {@d.createMachine}.should raise_error(AntargisException) #("startnode not set")
+  end
 end
 
 describe StateMachineDefinition, "with a single node" do
   before(:each) do
-		@d = StateMachineDefinition.new
-		@d.addNode(StateMachineNode,:startNode)
-		@d.startNode=:startNode
+    @d = StateMachineDefinition.new
+    @d.addNode(StateMachineNode,:startNode)
+    @d.startNode=:startNode
   end
-	it "should have node count 1" do
-		@d.nodeCount.should == 1
-	end
+  it "should have node count 1" do
+    @d.nodeCount.should == 1
+  end
 
-	it "should be finished when run" do
-		m=@d.createMachine
-		m.tick(1)
-		m.finished.should == true
-	end
+  it "should be finished when run" do
+    m=@d.createMachine
+    m.tick(1)
+    m.finished.should == true
+  end
 
 end
 
 # a mockstate that can be set to finished externally
 class MockState<StateMachineNode
-	attr_accessor :dummyVar
+  attr_accessor :dummyVar
 
-	def initialize(pid)
-		super(pid)	
-		@finished=true
+  def initialize(pid)
+    super(pid)  
+    @finished=true
 
-	end
-	def finished=(f)
-		@finished=f
-	end
-	def ready
-		@finished
-	end
+  end
+  def finished=(f)
+    @finished=f
+  end
+  def ready
+    @finished
+  end
 
-	def eventEnter
-		logEvent("eventEnter")
-	end
-	def eventLeave
-		logEvent("eventLeave")
-	end
-	def eventFrame(t)
-		logEvent("eventFrame")
-		t
-	end
+  def eventEnter
+    logEvent("eventEnter")
+  end
+  def eventLeave
+    logEvent("eventLeave")
+  end
+  def eventFrame(t)
+    logEvent("eventFrame")
+    t
+  end
 
 private
-	def logEvent(name)
-		dict["events"]||=[]
-		dict["events"] << id.to_s+" "+name
-	end
-	
+  def logEvent(name)
+    dict["events"]||=[]
+    dict["events"] << id.to_s+" "+name
+  end
+  
 end
 
 describe StateMachine, " with 2 mock-states " do
-	before(:all) do 
-		@d=StateMachineDefinition.new
-		@n1=@d.startNode=@d.addNode(MockState,:start)
-		@n2=@d.addNode(MockState,:end)
-		@d.addEdge(@n1, at n2)
-	end
-	it "should not touch another machine with same definition in their states" do
-		m1=@d.createMachine
-		m2=@d.createMachine
+  before(:all) do 
+    @d=StateMachineDefinition.new
+    @n1=@d.startNode=@d.addNode(MockState,:start)
+    @n2=@d.addNode(MockState,:end)
+    @d.addEdge(@n1, at n2)
+  end
+  it "should not touch another machine with same definition in their states" do
+    m1=@d.createMachine
+    m2=@d.createMachine
 
-		m1.state.dummyVar=20
-		m2.state.dummyVar.should == nil
-	end
+    m1.state.dummyVar=20
+    m2.state.dummyVar.should == nil
+  end
 
-	before(:each) do
-		@m=@d.createMachine
-	end
-	
-	it "should call eventEnter on startNode before calling eventFrame" do
-		@m.tick(1)
-		events=@m.dict["events"]
-		events.length.should == 5
-		events[0].should == "start eventEnter"
-		events[1].should == "start eventFrame"
-		events[2].should == "start eventLeave"
-		events[3].should == "end eventEnter"
-		events[4].should == "end eventFrame"
-	end
+  before(:each) do
+    @m=@d.createMachine
+  end
+  
+  it "should call eventEnter on startNode before calling eventFrame" do
+    @m.tick(1)
+    events=@m.dict["events"]
+    events.length.should == 5
+    events[0].should == "start eventEnter"
+    events[1].should == "start eventFrame"
+    events[2].should == "start eventLeave"
+    events[3].should == "end eventEnter"
+    events[4].should == "end eventFrame"
+  end
 
-	it "should not be finished without being started/tick called" do
-		@m.finished.should == false
-	end
-	it "should be finished when tick was called" do
-		@m.tick(1)
-		@m.finished.should == true
-	end
-	it "- rest-time should be equal to initial time when calling tick" do
-		time=1
-		restTime=@m.tick(time)
-		time.should restTime
-	end
-	it "should only process first node and stay there, when tick-time is 0" do
-		@m.tick(0)
-		@m.state.id.should == @n1
-	end
-	it "should end in @n2 and be finished, when tick-time is 1" do
-		@m.tick(1)
-		@m.state.id.should == @n2
-		@m.finished.should == true
-	end
-	it "should return a node when calling state" do
-		@m.state.should is_a?(StateMachineNode)
-	end
+  it "should not be finished without being started/tick called" do
+    @m.finished.should == false
+  end
+  it "should be finished when tick was called" do
+    @m.tick(1)
+    @m.finished.should == true
+  end
+  it "- rest-time should be equal to initial time when calling tick" do
+    time=1
+    restTime=@m.tick(time)
+    time.should restTime
+  end
+  it "should only process first node and stay there, when tick-time is 0" do
+    @m.tick(0)
+    @m.state.id.should == @n1
+  end
+  it "should end in @n2 and be finished, when tick-time is 1" do
+    @m.tick(1)
+    @m.state.id.should == @n2
+    @m.finished.should == true
+  end
+  it "should return a node when calling state" do
+    @m.state.should is_a?(StateMachineNode)
+  end
 
-	it "should have a dictionary" do
-		@m.dict.should is_a?(Hash)
-	end
+  it "should have a dictionary" do
+    @m.dict.should is_a?(Hash)
+  end
 
-	it "should be able to pass on information from one state to another" do	
-		@m.dict["test"]=10
-		@m.tick(1)
-		@m.state.id.should == @n2
-		@m.dict["test"].should == 10
-	end
+  it "should be able to pass on information from one state to another" do  
+    @m.dict["test"]=10
+    @m.tick(1)
+    @m.state.id.should == @n2
+    @m.dict["test"].should == 10
+  end
 
-	it "should be able to pass on information from one state to another - saved and restored within state" do	
-		@m.state.dict["test"]=10
-		@m.tick(1)
-		@m.state.id.should == @n2
-		@m.state.dict["test"].should == 10
-	end
+  it "should be able to pass on information from one state to another - saved and restored within state" do  
+    @m.state.dict["test"]=10
+    @m.tick(1)
+    @m.state.id.should == @n2
+    @m.state.dict["test"].should == 10
+  end
 
-	it "- states have link up to machine" do
-		@m.state.machine.should == @m
-	end	
+  it "- states have link up to machine" do
+    @m.state.machine.should == @m
+  end  
 
-	it "should return the state, when giving the correct name" do
-		s1=@m.getState(:start)
-		s1.should is_a?(StateMachineNode)
-		s1.id.should == @n1
-		s2=@m.getState(:end)
-		s2.should is_a?(StateMachineNode)
-		s2.id.should == @n2
-	end
+  it "should return the state, when giving the correct name" do
+    s1=@m.getState(:start)
+    s1.should is_a?(StateMachineNode)
+    s1.id.should == @n1
+    s2=@m.getState(:end)
+    s2.should is_a?(StateMachineNode)
+    s2.id.should == @n2
+  end
 end
 
 class DelayState<StateMachineNode
-	def eventEnter
-		@time=1
-	end
-	def eventFrame(t)
-		d=[1,t].min
-		@time-=d
-		t-=d
-		t
-	end
-	def ready
-		@time<=0
-	end
+  def eventEnter
+    @time=1
+  end
+  def eventFrame(t)
+    d=[1,t].min
+    @time-=d
+    t-=d
+    t
+  end
+  def ready
+    @time<=0
+  end
 end
 
 describe StateMachine, " with 2 mock-states and a decision-node" do
-	before(:all) do
-		@d=StateMachineDefinition.new
-		@n1=@d.addNode(DelayState,:start)
-		@n2=@d.addNode(DecisionNode, :decision) do |node|(node.dict[:continue] ? :continue : :return) end
-		@n3=@d.addNode(DelayState,:end)
-		@d.addEdge(@n1, at n2)
-		@d.addEdge(@n2, at n3,:continue)
-		@d.addEdge(@n2, at n1,:return)
-		@d.startNode=@n1
-	end
-	before(:each) do
-		@m=@d.createMachine
-	end
-	it "should return again and again when continue is false" do
-		@m.state.id.should == @n1
-		@m.tick(0.5)
-		@m.state.id.should == @n1
-		@m.tick(0.5)
-		@m.state.id.should == @n2
-		@m.tick(0.5)
-		@m.state.id.should == @n1
-	end
-	it "should finish when continue is true" do
-		@m.dict[:continue]=true
-		@m.state.id.should == @n1
-		@m.tick(0.5)
-		@m.state.id.should == @n1
-		@m.tick(0.5)
-		@m.state.id.should == @n2
-		@m.tick(0.5)
-		@m.state.id.should == @n3
-	end
+  before(:all) do
+    @d=StateMachineDefinition.new
+    @n1=@d.addNode(DelayState,:start)
+    @n2=@d.addNode(DecisionNode, :decision) do |node|(node.dict[:continue] ? :continue : :return) end
+    @n3=@d.addNode(DelayState,:end)
+    @d.addEdge(@n1, at n2)
+    @d.addEdge(@n2, at n3,:continue)
+    @d.addEdge(@n2, at n1,:return)
+    @d.startNode=@n1
+  end
+  before(:each) do
+    @m=@d.createMachine
+  end
+  it "should return again and again when continue is false" do
+    @m.state.id.should == @n1
+    @m.tick(0.5)
+    @m.state.id.should == @n1
+    @m.tick(0.5)
+    @m.state.id.should == @n2
+    @m.tick(0.5)
+    @m.state.id.should == @n1
+  end
+  it "should finish when continue is true" do
+    @m.dict[:continue]=true
+    @m.state.id.should == @n1
+    @m.tick(0.5)
+    @m.state.id.should == @n1
+    @m.tick(0.5)
+    @m.state.id.should == @n2
+    @m.tick(0.5)
+    @m.state.id.should == @n3
+  end
 end
 

Modified: antargis/trunk/ruby/state_machine/state_machine.rb
===================================================================
--- antargis/trunk/ruby/state_machine/state_machine.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/state_machine/state_machine.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,209 +1,209 @@
 require 'ruby/ant_tools.rb'
 
 class StateMachineBase
-	attr_accessor :dict
+  attr_accessor :dict
 end
 
 class StateMachineNode
-	attr_reader :id
-	attr_accessor :machine
+  attr_reader :id
+  attr_accessor :machine
 
-	def initialize(pid)
-		assert{pid.is_a?(Symbol)}
+  def initialize(pid)
+    assert{pid.is_a?(Symbol)}
 
-		@id=pid
-	end
+    @id=pid
+  end
 
-	def eventEnter
-	end
-	def eventLeave
-	end
-	def eventFrame(t)
-		#raise "should not be used!"
-		t-0.5
-	end
+  def eventEnter
+  end
+  def eventLeave
+  end
+  def eventFrame(t)
+    #raise "should not be used!"
+    t-0.5
+  end
 
-	def assign(entity)
-	end
+  def assign(entity)
+  end
 
-	def ready
-		true
-	end
+  def ready
+    true
+  end
 
-	def output
-		nil
-	end
+  def output
+    nil
+  end
 
-	def dict
-		assert{@machine.is_a?(StateMachine)}
-		@machine.dict
-	end
+  def dict
+    assert{@machine.is_a?(StateMachine)}
+    @machine.dict
+  end
 end
 
 class StateMachineEdge
-	attr_reader :from, :to, :name
-	def initialize(from,to,name)
-		assert{from.is_a?(Symbol)}
-		assert{to.is_a?(Symbol)}
-		assert{name.is_a?(Symbol)}
-		@from=from
-		@to=to
-		@name=name
-	end
+  attr_reader :from, :to, :name
+  def initialize(from,to,name)
+    assert{from.is_a?(Symbol)}
+    assert{to.is_a?(Symbol)}
+    assert{name.is_a?(Symbol)}
+    @from=from
+    @to=to
+    @name=name
+  end
 end
 
 class StateMachineDefinition
-	attr_reader :startNode
-	def initialize
-		@nodes={}
-		@edges={}
-		@blocks={}
-		@startNode=nil
-	end
+  attr_reader :startNode
+  def initialize
+    @nodes={}
+    @edges={}
+    @blocks={}
+    @startNode=nil
+  end
 
-	def startNode=(name)
-		assert("startNode is already a member node") {not @nodes[name].nil?}
-		@startNode=name
-	end
+  def startNode=(name)
+    assert("startNode is already a member node") {not @nodes[name].nil?}
+    @startNode=name
+  end
 
-	def addNode(nodeClass,name,&block)
-		assert {nodeClass.ancestors.member?(StateMachineNode)}
-		assert {@nodes[name].nil?}
-		@nodes[name]=nodeClass
-		@blocks[name]=block
-		name
-	end
-	def addEdge(node1,node2,name=nil)
-		assert {hasNode(node1)}
-		assert {hasNode(node2)}
-		assert {name.is_a?(Symbol) || name.nil?}
-		name||=:default
-		edge=StateMachineEdge.new(node1,node2,name)
-		@edges[edge.from]||=[]
-		@edges[edge.from] << edge
-	end
+  def addNode(nodeClass,name,&block)
+    assert {nodeClass.ancestors.member?(StateMachineNode)}
+    assert {@nodes[name].nil?}
+    @nodes[name]=nodeClass
+    @blocks[name]=block
+    name
+  end
+  def addEdge(node1,node2,name=nil)
+    assert {hasNode(node1)}
+    assert {hasNode(node2)}
+    assert {name.is_a?(Symbol) || name.nil?}
+    name||=:default
+    edge=StateMachineEdge.new(node1,node2,name)
+    @edges[edge.from]||=[]
+    @edges[edge.from] << edge
+  end
 
-	def nodeCount
-		@nodes.length
-	end
+  def nodeCount
+    @nodes.length
+  end
 
-	def ready?
-		(not @startNode.nil?)
-	end
+  def ready?
+    (not @startNode.nil?)
+  end
 
-	def getNextNode(nodeName,output)
-		output||=:default
-		return nil if @edges[nodeName].nil?
-		#puts "ok"
-		@edges[nodeName].each{|edge|
-			#puts "#{edge.name} #{output}"
-			if edge.name==output
-				return edge.to
-			end
-		}
-		nil
-	end
-	def hasNode(nodeName)
-		(not @nodes[nodeName].nil?)
-	end
-	
+  def getNextNode(nodeName,output)
+    output||=:default
+    return nil if @edges[nodeName].nil?
+    #puts "ok"
+    @edges[nodeName].each{|edge|
+      #puts "#{edge.name} #{output}"
+      if edge.name==output
+        return edge.to
+      end
+    }
+    nil
+  end
+  def hasNode(nodeName)
+    (not @nodes[nodeName].nil?)
+  end
+  
 
-	def getNodeClass(nodeName)
-		assert("getNodeClass checks if has node '#{nodeName}'") {hasNode(nodeName)}
-		@nodes[nodeName]
-	end
+  def getNodeClass(nodeName)
+    assert("getNodeClass checks if has node '#{nodeName}'") {hasNode(nodeName)}
+    @nodes[nodeName]
+  end
 
-	def createMachine
-		StateMachine.new(self)
-	end
+  def createMachine
+    StateMachine.new(self)
+  end
 
-	def getBlock(nodeName)
-		@blocks[nodeName]
-	end
+  def getBlock(nodeName)
+    @blocks[nodeName]
+  end
 end
 
 
 class StateMachine
-	MAX_LOOPS=20
-	attr_reader :finished
-	attr_accessor :dict
-	attr_accessor :debug
+  MAX_LOOPS=20
+  attr_reader :finished
+  attr_accessor :dict
+  attr_accessor :debug
 
-	def initialize(definition)
-		assert{definition.is_a?(StateMachineDefinition)}
-		assert("startnode not set!") {definition.ready?}
-		@definition=definition
-		@nodes={}
-		@dict={}
-		@currentNode=getNode(@definition.startNode)
-		@finished=false
-		@started=false
-	end
+  def initialize(definition)
+    assert{definition.is_a?(StateMachineDefinition)}
+    assert("startnode not set!") {definition.ready?}
+    @definition=definition
+    @nodes={}
+    @dict={}
+    @currentNode=getNode(@definition.startNode)
+    @finished=false
+    @started=false
+  end
 
-	def tick(timeFrame)
-		restTime=timeFrame
-		loops=0
-		while restTime>0 and loops<MAX_LOOPS
-			if not @started
-				@started=true
-				puts "#{@currentNode.id}.eventEnter" if @debug
-				@currentNode.eventEnter
-			end
-			restTime=@currentNode.eventFrame(restTime)
-			assert{restTime.is_a?(Numeric)}
-			if @currentNode.ready
-				output=@currentNode.output
-				nextNodeName=@definition.getNextNode(@currentNode.id,output)
-				#sputs "FROM #{@currentNode.id} TO #{nextNodeName}"
-				if nextNodeName.nil?
-					setFinished
-					return eventFinished
-				end
-				nextNode=getNode(nextNodeName)
-				@currentNode.eventLeave
-				@currentNode=nextNode
-				nextNode.eventEnter
-			end
-			loops+=1
-		end
-		raise "Too many loops in StateMachine.tick(.) restFrame:#{restTime}" if loops>=MAX_LOOPS
-	end
+  def tick(timeFrame)
+    restTime=timeFrame
+    loops=0
+    while restTime>0 and loops<MAX_LOOPS
+      if not @started
+        @started=true
+        puts "#{@currentNode.id}.eventEnter" if @debug
+        @currentNode.eventEnter
+      end
+      restTime=@currentNode.eventFrame(restTime)
+      assert{restTime.is_a?(Numeric)}
+      if @currentNode.ready
+        output=@currentNode.output
+        nextNodeName=@definition.getNextNode(@currentNode.id,output)
+        #sputs "FROM #{@currentNode.id} TO #{nextNodeName}"
+        if nextNodeName.nil?
+          setFinished
+          return eventFinished
+        end
+        nextNode=getNode(nextNodeName)
+        @currentNode.eventLeave
+        @currentNode=nextNode
+        nextNode.eventEnter
+      end
+      loops+=1
+    end
+    raise "Too many loops in StateMachine.tick(.) restFrame:#{restTime}" if loops>=MAX_LOOPS
+  end
 
-	def eventFinished
-	end
+  def eventFinished
+  end
 
-	def state
-		@currentNode
-	end
+  def state
+    @currentNode
+  end
 
-	def getState(state)
-		getNode(state)
-	end
+  def getState(state)
+    getNode(state)
+  end
 
-	private
-	def setFinished
-		@finished=true
-	end
+  private
+  def setFinished
+    @finished=true
+  end
 
-	def getNode(nodeName)
-		block=@definition.getBlock(nodeName)
-		if block
-			@nodes[nodeName]||=@definition.getNodeClass(nodeName).new(nodeName,block)
-		else
-			@nodes[nodeName]||=@definition.getNodeClass(nodeName).new(nodeName)
-		end
-		@nodes[nodeName].machine=self
-		@nodes[nodeName]
-	end
+  def getNode(nodeName)
+    block=@definition.getBlock(nodeName)
+    if block
+      @nodes[nodeName]||=@definition.getNodeClass(nodeName).new(nodeName,block)
+    else
+      @nodes[nodeName]||=@definition.getNodeClass(nodeName).new(nodeName)
+    end
+    @nodes[nodeName].machine=self
+    @nodes[nodeName]
+  end
 end
 
 class DecisionNode < StateMachineNode
-	def initialize(id,block)
-		super(id)
-		@block=block
-	end
-	def output
-		@block.call(self)
-	end	
+  def initialize(id,block)
+    super(id)
+    @block=block
+  end
+  def output
+    @block.call(self)
+  end  
 end
 

Modified: antargis/trunk/ruby/state_machine/tests/state_machine_test.rb
===================================================================
--- antargis/trunk/ruby/state_machine/tests/state_machine_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/state_machine/tests/state_machine_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -2,57 +2,57 @@
 require 'test/unit'
 
 class MockState<StateMachineNode
-	attr_accessor :dummyVar
-	def initialize(pid)
-		super(pid)	
-		@finished=true
-	end
-	def finished=(f)
-		@finished=f
-	end
-	def isFinished?
-		@finished
-	end
-	
+  attr_accessor :dummyVar
+  def initialize(pid)
+    super(pid)  
+    @finished=true
+  end
+  def finished=(f)
+    @finished=f
+  end
+  def isFinished?
+    @finished
+  end
+  
 end
 
 
 class SinglNodeTest < Test::Unit::TestCase
-	def setup
-		d=StateMachineDefinition.new
-		
-		n=StateMachineNode.new(:start)
+  def setup
+    d=StateMachineDefinition.new
+    
+    n=StateMachineNode.new(:start)
 
-		d.addNode(n)
+    d.addNode(n)
 
-		d.startNode=(n)
+    d.startNode=(n)
 
-		@m=StateMachine.new(d)
-	end
+    @m=StateMachine.new(d)
+  end
 
-	def test_notFinishedWhenNotStarted
-		assert((not @m.finished),"@m should not be finished when not yet started!")
-	end
+  def test_notFinishedWhenNotStarted
+    assert((not @m.finished),"@m should not be finished when not yet started!")
+  end
 
-	def test_simplerun
-		@m.tick(10)
-		assert(@m.finished,"@m should be finished!")
-	end
+  def test_simplerun
+    @m.tick(10)
+    assert(@m.finished,"@m should be finished!")
+  end
 end
 
 class TwoMachinesSeparate < Test::Unit::TestCase
-	def setup
-		d=StateMachineDefinition.new
-		n=MockState.new(:p0)
-		d << (n)
-		d.startNode=n
-		@m1=StateMachine.new(d)
-		@m2=StateMachine.new(d)
-	end
+  def setup
+    d=StateMachineDefinition.new
+    n=MockState.new(:p0)
+    d << (n)
+    d.startNode=n
+    @m1=StateMachine.new(d)
+    @m2=StateMachine.new(d)
+  end
 
-	def test_notSync
-		@m1.state.dummyVar=10
-		assert(@m2.state.dummyVar.nil?,"@m2.state.dummyVar shouldn't be influenced by @m1.state.dummyVar")
-	end
+  def test_notSync
+    @m1.state.dummyVar=10
+    assert(@m2.state.dummyVar.nil?,"@m2.state.dummyVar shouldn't be influenced by @m1.state.dummyVar")
+  end
 end
 

Modified: antargis/trunk/ruby/storyflow.rb
===================================================================
--- antargis/trunk/ruby/storyflow.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/storyflow.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -27,51 +27,51 @@
 #   * themselves are spoken by a person
 #
 # a simple example on how to create a story-flow:
-#			start=StoryFlow.new("recruit")
-#			start.push("Tutorial","Ok, you have recruited some men.")
-#			start.push("Tutorial","If you want to recruit all men select the button with the three swords. ....")
-#			start.push("Tutorial","When you're done with this go north and defeat your enemies. You .......")
-#			tellStory(start)
+#      start=StoryFlow.new("recruit")
+#      start.push("Tutorial","Ok, you have recruited some men.")
+#      start.push("Tutorial","If you want to recruit all men select the button with the three swords. ....")
+#      start.push("Tutorial","When you're done with this go north and defeat your enemies. You .......")
+#      tellStory(start)
 #
 class StoryFlow
-	attr_reader :name, :s
+  attr_reader :name, :s
 
-	# create a story-flow with identification "name"
-	def initialize(name)
-		@s=[]
-		@pos=0
-		@name=name
-	end
+  # create a story-flow with identification "name"
+  def initialize(name)
+    @s=[]
+    @pos=0
+    @name=name
+  end
 
-	# push a text with title "name" into the story-flow
-	def push(name,text)
-		@s.push([name,text])
-	end
+  # push a text with title "name" into the story-flow
+  def push(name,text)
+    @s.push([name,text])
+  end
 
-	# return current text
-	def getCurrent
-		return nil if @s.length<=@pos
-		c=@s[@pos]
-		return c
-	end
-		
+  # return current text
+  def getCurrent
+    return nil if @s.length<=@pos
+    c=@s[@pos]
+    return c
+  end
+    
 
-	# you won't need this unless you're implementing within the actual application-object
-	def get
-		return nil if @s.length<=@pos
-		c=@s[@pos]
-		@pos+=1
-		return c
-	end
-	# you won't need this unless you're implementing within the actual application-object
-	def append(flow)
-		@s+=flow.s
-		@name=flow.name
-	end
-	# you won't need this unless you're implementing within the actual application-object
-	def back
-		if @pos>0
-			@pos-=1
-		end
-	end	
-end
\ No newline at end of file
+  # you won't need this unless you're implementing within the actual application-object
+  def get
+    return nil if @s.length<=@pos
+    c=@s[@pos]
+    @pos+=1
+    return c
+  end
+  # you won't need this unless you're implementing within the actual application-object
+  def append(flow)
+    @s+=flow.s
+    @name=flow.name
+  end
+  # you won't need this unless you're implementing within the actual application-object
+  def back
+    if @pos>0
+      @pos-=1
+    end
+  end  
+end

Modified: antargis/trunk/ruby/terrain_2d.rb
===================================================================
--- antargis/trunk/ruby/terrain_2d.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/terrain_2d.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -2,42 +2,42 @@
 end
 
 class Terrain2D<TerrainBase
-	def initialize(scene,map)
-		super
-		@scene=scene
-		@map=map
-		createTiles
-	end
+  def initialize(scene,map)
+    super
+    @scene=scene
+    @map=map
+    createTiles
+  end
 
-	def createTiles
-		@textures={
-			:grass=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/full_grass.png")),
-			:grass2=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/full_grass2.png")),
-			:water=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/full_water.png"))
-		}
-		@meshdata={}
-		@textures.each{|k,v|
-			@meshdata[k]=Mesh2DData.new(v)
-		}
+  def createTiles
+    @textures={
+      :grass=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/full_grass.png")),
+      :grass2=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/full_grass2.png")),
+      :water=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/full_water.png"))
+    }
+    @meshdata={}
+    @textures.each{|k,v|
+      @meshdata[k]=Mesh2DData.new(v)
+    }
 
-		(0..(@map.getW/4-2)).each{|x|
-			(0..(@map.getH/2-1)).each{|y|
-				ix=x
-				iy=y
-				ix*=4
-				iy*=2
-				v=AGVector4.new(ix,iy,0,1)
-				t=:grass
-				if @map.getHeight(ix+2,iy+1)<0
-					t=:water
-				end
-# 				if x+y>5
-# 					t=:grass2
-# 				end
-				mesh=Terrain2DTile.new(@scene, at meshdata[t],v,0)
-				@scene.addNode(mesh)
-				mesh.setOrder(TERRAIN_Z)
-			}
-		}
-	end
+    (0..(@map.getW/4-2)).each{|x|
+      (0..(@map.getH/2-1)).each{|y|
+        ix=x
+        iy=y
+        ix*=4
+        iy*=2
+        v=AGVector4.new(ix,iy,0,1)
+        t=:grass
+        if @map.getHeight(ix+2,iy+1)<0
+          t=:water
+        end
+#         if x+y>5
+#           t=:grass2
+#         end
+        mesh=Terrain2DTile.new(@scene, at meshdata[t],v,0)
+        @scene.addNode(mesh)
+        mesh.setOrder(TERRAIN_Z)
+      }
+    }
+  end
 end

Modified: antargis/trunk/ruby/test_ant3.rb
===================================================================
--- antargis/trunk/ruby/test_ant3.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/test_ant3.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -5,29 +5,29 @@
 require 'ruby/antargislib.rb'
 
 class App<GLApp
-	def initialize(w,h)
-		super
-		
-		data=AnimMeshData.new("data/models/sheep.anim")
-		data.setTransform(AGMatrix4.new(Math::PI,AGVector3.new(0,0,1))*AGMatrix4.new(Math::PI/2,AGVector3.new(1,0,0)))
-		
-		puts "YAY"
-		@n=AnimMesh.new(getScene,data)
-		
-		@n.setAnimation("go")
-		getScene.addNode(@n)
-		@rot=0.0
-	end
-	
-	def eventFrame(s)
-		super(s)
-		@rot+=1
-		@n.setRotation(AGVector3.new(0,0,1), at rot)
-		if @rot>180
-			@n.setAnimation("eat")
-		end
-	end
+  def initialize(w,h)
+    super
+    
+    data=AnimMeshData.new("data/models/sheep.anim")
+    data.setTransform(AGMatrix4.new(Math::PI,AGVector3.new(0,0,1))*AGMatrix4.new(Math::PI/2,AGVector3.new(1,0,0)))
+    
+    puts "YAY"
+    @n=AnimMesh.new(getScene,data)
+    
+    @n.setAnimation("go")
+    getScene.addNode(@n)
+    @rot=0.0
+  end
+  
+  def eventFrame(s)
+    super(s)
+    @rot+=1
+    @n.setRotation(AGVector3.new(0,0,1), at rot)
+    if @rot>180
+      @n.setAnimation("eat")
+    end
+  end
 end
 
 a=App.new(800,600)
-a.run
\ No newline at end of file
+a.run

Modified: antargis/trunk/ruby/tests/3d_engine/wireframe.rb
===================================================================
--- antargis/trunk/ruby/tests/3d_engine/wireframe.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/3d_engine/wireframe.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -14,26 +14,26 @@
 
 
 class MWidget<AGGLWidget
-	def initialize(p,r)
-		super
-		@scene=Scene.new(r.width.to_i,r.height.to_i)
+  def initialize(p,r)
+    super
+    @scene=Scene.new(r.width.to_i,r.height.to_i)
 
-		wireframe=Boa3dWireframe.new(@scene)
+    wireframe=Boa3dWireframe.new(@scene)
 
-		a=AGVector3.new(0,0,0)
-		b=AGVector3.new(10,0,0)
-		white=AGVector4.new(1,1,1,1)
+    a=AGVector3.new(0,0,0)
+    b=AGVector3.new(10,0,0)
+    white=AGVector4.new(1,1,1,1)
 
-		wireframe.addLine(a,b,white)
+    wireframe.addLine(a,b,white)
 
-		@scene.addNode(wireframe)
+    @scene.addNode(wireframe)
 
-	end
-	def drawGL
-		@scene.draw
-	end
+  end
+  def drawGL
+    @scene.draw
+  end
 
-	
+  
 end
 
 widget=MWidget.new(nil,AGRect2.new(0,0,640,480))

Modified: antargis/trunk/ruby/tests/algebra_test.rb
===================================================================
--- antargis/trunk/ruby/tests/algebra_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/algebra_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,62 +7,62 @@
 setDebugLevel(0)
 
 def inverseTest
-	m=AGMatrixN.new(4,4)
-	
-	a=
-	[[1,-1,0,0],
-	[0,1,-1,0],
-	[0,0,1,-1],
-	[1,0,0,1]]
-	
-	(0..3).each{|x|
-		(0..3).each{|y|
-			m.set(x,y,a[y][x])
-		}
-	}
-	puts "M:"
-	m.output
-	
-	x=m.inverse
-	
-	y=m*x
-	puts "Y:"
-	y.output
+  m=AGMatrixN.new(4,4)
+  
+  a=
+  [[1,-1,0,0],
+  [0,1,-1,0],
+  [0,0,1,-1],
+  [1,0,0,1]]
+  
+  (0..3).each{|x|
+    (0..3).each{|y|
+      m.set(x,y,a[y][x])
+    }
+  }
+  puts "M:"
+  m.output
+  
+  x=m.inverse
+  
+  y=m*x
+  puts "Y:"
+  y.output
 end
 
 def multTest
-	a=AGMatrixN.new(2,2)
-	b=AGMatrixN.new(2,2)
-	a.makeUnitMatrix
-	b.makeUnitMatrix
-	a.set(0,1,10)
-	b.set(0,1,10)
-	puts "a:"	
-	a.output
-	puts "b:"	
-	b.output
-	c=a*b
-	puts "c:"	
-	c.output
+  a=AGMatrixN.new(2,2)
+  b=AGMatrixN.new(2,2)
+  a.makeUnitMatrix
+  b.makeUnitMatrix
+  a.set(0,1,10)
+  b.set(0,1,10)
+  puts "a:"  
+  a.output
+  puts "b:"  
+  b.output
+  c=a*b
+  puts "c:"  
+  c.output
 end
 
 def invTest2
-	a=AGMatrixN.new(3,3)
-	a.set(0,0,1)
-	a.set(0,1,1)
-	a.set(1,0,1)
-	a.set(2,2,2)
-	puts "a:"
-	a.output
-	i=a.inverse
-	puts "i:"
-	i.output
+  a=AGMatrixN.new(3,3)
+  a.set(0,0,1)
+  a.set(0,1,1)
+  a.set(1,0,1)
+  a.set(2,2,2)
+  puts "a:"
+  a.output
+  i=a.inverse
+  puts "i:"
+  i.output
 
-	t=a*i
-	puts "t:"
-	t.output
+  t=a*i
+  puts "t:"
+  t.output
 end
 
 #multTest
 #invTest2
-inverseTest
\ No newline at end of file
+inverseTest

Modified: antargis/trunk/ruby/tests/basis_test.rb
===================================================================
--- antargis/trunk/ruby/tests/basis_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/basis_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -5,50 +5,50 @@
 setDebugLevel(0)
 
 def makeBasis
-	m=AGMatrixN.new(2,8)
-	
-	a=[
-	[1,1,1,1],
-	[1,1,-1,-1],
-	[1,-1,0,0],
-	[0,0,1,-1],
-	]
+  m=AGMatrixN.new(2,8)
+  
+  a=[
+  [1,1,1,1],
+  [1,1,-1,-1],
+  [1,-1,0,0],
+  [0,0,1,-1],
+  ]
 
-	a=[
-	[1,1,1,1,1,1,1,1],
-	[1,1,1,1,-1,-1,-1,-1],
-	[1,1,-1,-1,0,0,0,0],
-	[0,0,0,0,1,1,-1,-1],
-	[-1,1,0,0,0,0,0,0],
-	[0,0,-1,1,0,0,0,0],
-	[0,0,0,0,-1,1,0,0],
-	]
+  a=[
+  [1,1,1,1,1,1,1,1],
+  [1,1,1,1,-1,-1,-1,-1],
+  [1,1,-1,-1,0,0,0,0],
+  [0,0,0,0,1,1,-1,-1],
+  [-1,1,0,0,0,0,0,0],
+  [0,0,-1,1,0,0,0,0],
+  [0,0,0,0,-1,1,0,0],
+  ]
 
-	
-	(0..7).each{|x|
-		(0..1).each{|y|
-			m.set(y,x,a[y][x])
-		}
-	}
-	m
+  
+  (0..7).each{|x|
+    (0..1).each{|y|
+      m.set(y,x,a[y][x])
+    }
+  }
+  m
 end
 
 def makeSample(w)
-	v=AGMatrixN.new(1,w)
-	(0..(w-1)).each{|c|
-		v.set(0,c,rand)
-	}
-	v
+  v=AGMatrixN.new(1,w)
+  (0..(w-1)).each{|c|
+    v.set(0,c,rand)
+  }
+  v
 end
 
 def encode(basePair,v)
-	inv=basePair[1]
-	inv*v
+  inv=basePair[1]
+  inv*v
 end
 
 def decode(basePair,encodedV)
-	m=basePair[0]
-	m*encodedV
+  m=basePair[0]
+  m*encodedV
 end
 
 basis=makeBasis
@@ -84,15 +84,15 @@
 err2=0
 count=10000
 (0..count).each{|i|
-	sample=makeSample(8)
-	sample2=makeSample(8)
-	err2+=(sample-sample2).scalar
-	enc=encode(basePair,sample)
-	dec=decode(basePair,enc)
-	c=(dec-sample).scalar
-	#puts c
-	err+=c
-	
+  sample=makeSample(8)
+  sample2=makeSample(8)
+  err2+=(sample-sample2).scalar
+  enc=encode(basePair,sample)
+  dec=decode(basePair,enc)
+  c=(dec-sample).scalar
+  #puts c
+  err+=c
+  
 }
 
 puts err/count

Modified: antargis/trunk/ruby/tests/clip_test.rb
===================================================================
--- antargis/trunk/ruby/tests/clip_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/clip_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -5,33 +5,33 @@
 r=AGRect2.new(0,0,20,20)
 
 class MyWidget<AGWidget
-	def initialize(p,r)
-		super
-		@a=AGClipping.new
-		@a.exclude(AGRect2.new(0,0,500,500))
-		@a.include(AGRect2.new(100,100,200,200))
-		@a.exclude(AGRect2.new(150,150,50,50))
-	end
-	def draw(p)
-		rs=@a.clip(AGRect2.new(0,0,400,400))
-		rs.each{|r|
-			p.fillRect(r,AGColor.new(
-				(rand*0xFF).to_i,
-				(rand*0xFF).to_i,
-				(rand*0xFF).to_i))
-		}
-	end
+  def initialize(p,r)
+    super
+    @a=AGClipping.new
+    @a.exclude(AGRect2.new(0,0,500,500))
+    @a.include(AGRect2.new(100,100,200,200))
+    @a.exclude(AGRect2.new(150,150,50,50))
+  end
+  def draw(p)
+    rs=@a.clip(AGRect2.new(0,0,400,400))
+    rs.each{|r|
+      p.fillRect(r,AGColor.new(
+        (rand*0xFF).to_i,
+        (rand*0xFF).to_i,
+        (rand*0xFF).to_i))
+    }
+  end
 end
 
 class MyApp<AGApplication
-	def initialize
-		super
-		setMainWidget(MyWidget.new(nil,AGRect2.new(0,0,640,480)))
-	end
-	def eventFrame(t)	
-		delay(100)
-		true
-	end
+  def initialize
+    super
+    setMainWidget(MyWidget.new(nil,AGRect2.new(0,0,640,480)))
+  end
+  def eventFrame(t)  
+    delay(100)
+    true
+  end
 end
 app=MyApp.new
-app.run
\ No newline at end of file
+app.run

Modified: antargis/trunk/ruby/tests/clip_widget_test.rb
===================================================================
--- antargis/trunk/ruby/tests/clip_widget_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/clip_widget_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,65 +7,65 @@
 setDebugLevel(0)
 
 class MyWidget<AGWidget
-	def initialize(p,r)
-		super
-	end
-	def draw(p)
-		c=AGColor.new(0xFF,0,0)#(rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
-		p.fillRect(getRect.origin,c)
-	end
+  def initialize(p,r)
+    super
+  end
+  def draw(p)
+    c=AGColor.new(0xFF,0,0)#(rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
+    p.fillRect(getRect.origin,c)
+  end
 end
 
 class MyWidget2<AGWidget
-	def initialize(p,r)
-		super
-		@x=@y=0
-		eventFrame(0)
-		queryRedraw
-	end
-	def draw(p)
-		c=AGColor.new((rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
-		#c=AGColor.new(0,0,0)
-		p.fillRect(getRect.origin,c) #AGColor.new(0,0,0))
-		c=AGColor.new(0,0xFF,0) #(rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
-		#p.fillRect(@r,c)
-	end
-	def eventFrame(t)
-		if @inited
-		else
-			pushChangeRect(getRect.origin) #queryRedraw
-			@inited=true
-		end
-		@x+=1
-		@y+=3
-		@x%=width
-		@y%=height
-		@r=AGRect2.new(@x, at y,10,10)
-		pushChangeRect(@r.grow(3))
-		#queryRedraw
-		true
-	end
+  def initialize(p,r)
+    super
+    @x=@y=0
+    eventFrame(0)
+    queryRedraw
+  end
+  def draw(p)
+    c=AGColor.new((rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
+    #c=AGColor.new(0,0,0)
+    p.fillRect(getRect.origin,c) #AGColor.new(0,0,0))
+    c=AGColor.new(0,0xFF,0) #(rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
+    #p.fillRect(@r,c)
+  end
+  def eventFrame(t)
+    if @inited
+    else
+      pushChangeRect(getRect.origin) #queryRedraw
+      @inited=true
+    end
+    @x+=1
+    @y+=3
+    @x%=width
+    @y%=height
+    @r=AGRect2.new(@x, at y,10,10)
+    pushChangeRect(@r.grow(3))
+    #queryRedraw
+    true
+  end
 end
 
 class MyApp<AGApplication
-	def initialize
-		super
-		@ws=[]
-		@m=MyWidget2.new(nil,AGRect2.new(50,50,200,200))
-		setMainWidget(@m)
-		@ws << MyWidget.new(@m,AGRect2.new(5,5,110,70))
-		@ws << AGButton.new(@m,AGRect2.new(10,10,100,50),AGStringUtf8.new("halo"))
-		puts "adddd..."
-		#@ws.each{|w|@m.addChild(w)}
-		
+  def initialize
+    super
+    @ws=[]
+    @m=MyWidget2.new(nil,AGRect2.new(50,50,200,200))
+    setMainWidget(@m)
+    @ws << MyWidget.new(@m,AGRect2.new(5,5,110,70))
+    @ws << AGButton.new(@m,AGRect2.new(10,10,100,50),AGStringUtf8.new("halo"))
+    puts "adddd..."
+    #@ws.each{|w|@m.addChild(w)}
+    
 
-	end
-	def eventFrame(t)
-		delay(10)
-		@m.eventFrame(t)
-		true
-	end
+  end
+  def eventFrame(t)
+    delay(10)
+    @m.eventFrame(t)
+    true
+  end
 end
 
 a=MyApp.new
-a.run
\ No newline at end of file
+a.run

Modified: antargis/trunk/ruby/tests/dirty_rects.rb
===================================================================
--- antargis/trunk/ruby/tests/dirty_rects.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/dirty_rects.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -6,39 +6,39 @@
 
 
 class MyWidget<AGWidget
-	def initialize(p,r)
-		super
-		@x=0
-		@y=0
-	end
-	def prepareDraw
-	end
-	def draw(p)
-		#p.fillRect(AGRect2.new(0,0,300,300),AGColor.new(0,0,0))
-		p.fillRect(AGRect2.new(@x, at y,10,10),AGColor.new(0xFF,0,0))
-	end
-	def eventFrame(t)
-		@x+=2
-		@y+=1
-		@x%=207
-		@y%=293
-		#queryRedraw
-		pushChangeRect(AGRect2.new(@x-2, at y-2,12,12))
-	end
+  def initialize(p,r)
+    super
+    @x=0
+    @y=0
+  end
+  def prepareDraw
+  end
+  def draw(p)
+    #p.fillRect(AGRect2.new(0,0,300,300),AGColor.new(0,0,0))
+    p.fillRect(AGRect2.new(@x, at y,10,10),AGColor.new(0xFF,0,0))
+  end
+  def eventFrame(t)
+    @x+=2
+    @y+=1
+    @x%=207
+    @y%=293
+    #queryRedraw
+    pushChangeRect(AGRect2.new(@x-2, at y-2,12,12))
+  end
 end
 
 class MyApp<AGApplication
-	def initialize
-		super
-		@imw=MyWidget.new(nil,AGRect2.new(0,0,800,600))
-		setMainWidget(@imw)
-	end
-	def eventFrame(t)
-		@imw.eventFrame(t)
-		delay(5)
-		true
-	end
+  def initialize
+    super
+    @imw=MyWidget.new(nil,AGRect2.new(0,0,800,600))
+    setMainWidget(@imw)
+  end
+  def eventFrame(t)
+    @imw.eventFrame(t)
+    delay(5)
+    true
+  end
 end
 
 app=MyApp.new
-app.run
\ No newline at end of file
+app.run

Modified: antargis/trunk/ruby/tests/graph_test.rb
===================================================================
--- antargis/trunk/ruby/tests/graph_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/graph_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -3,10 +3,10 @@
 require 'ruby/antargislib.rb'
 
 #@mweighter=MapPathWeighter.new(self)
-#		@sgraph=makeGraph(self, at mweighter,4)
-#		@dgraph=DecimatedGraph.new(@sgraph)
-#		@dgraph.decimate(0.2, at mweighter)
-#		@heuristic=computeHeuristic(@dgraph)
+#    @sgraph=makeGraph(self, at mweighter,4)
+#    @dgraph=DecimatedGraph.new(@sgraph)
+#    @dgraph.decimate(0.2, at mweighter)
+#    @heuristic=computeHeuristic(@dgraph)
 
 
 

Modified: antargis/trunk/ruby/tests/gui_tests.rb
===================================================================
--- antargis/trunk/ruby/tests/gui_tests.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/gui_tests.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -3,13 +3,13 @@
 require 'ruby/antargislib.rb'
 
 class AGApplication
-	alias getNewEventOld getNewEvent
-	def getNewEvent
-		@eventDebugging||=File.open("events.txt","r")
-		if @eventDebugging.eof
-			return nil
-		end
-		s=@eventDebugging.readline
-		return toSDLEvent(s)
-	end 
-end
\ No newline at end of file
+  alias getNewEventOld getNewEvent
+  def getNewEvent
+    @eventDebugging||=File.open("events.txt","r")
+    if @eventDebugging.eof
+      return nil
+    end
+    s=@eventDebugging.readline
+    return toSDLEvent(s)
+  end 
+end

Modified: antargis/trunk/ruby/tests/impostor.rb
===================================================================
--- antargis/trunk/ruby/tests/impostor.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/impostor.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -5,33 +5,33 @@
 
 
 class MyApp<GLApp
-	def initialize(w,h)
-		super
-		#node=Mesh.new(getScene,getMeshData("data/models/sack.ant2",0.3,"data/textures/models/sack.png"),AGVector4.new(0,0,0),0)
-		node=Mesh.new(getScene,getMeshData("data/models/workshop.ant2",0.18,"data/textures/models/workshop.png"),AGVector4.new(0,0,0),-50)
+  def initialize(w,h)
+    super
+    #node=Mesh.new(getScene,getMeshData("data/models/sack.ant2",0.3,"data/textures/models/sack.png"),AGVector4.new(0,0,0),0)
+    node=Mesh.new(getScene,getMeshData("data/models/workshop.ant2",0.18,"data/textures/models/workshop.png"),AGVector4.new(0,0,0),-50)
 
-		getScene.addNode(node)
+    getScene.addNode(node)
 
-		imp=AntImpostorData.new(node)
+    imp=AntImpostorData.new(node)
 
-		tex=imp.getTexture
-			
-		image=AGImage.new(nil,AGRect2.new(0,0,tex.width,tex.height),tex,false)
-		setMainWidget(image)
-		
-		getScene.removeNode(node)
-	end
+    tex=imp.getTexture
+      
+    image=AGImage.new(nil,AGRect2.new(0,0,tex.width,tex.height),tex,false)
+    setMainWidget(image)
+    
+    getScene.removeNode(node)
+  end
 
-	def eventFrame(t)
-		#imp=
-		delay(100)
-	puts t
-		return true
-	end
+  def eventFrame(t)
+    #imp=
+    delay(100)
+  puts t
+    return true
+  end
 
-#  	def draw(p)
-#  		p.blit(imp.getTexture)
-#  	end
+#    def draw(p)
+#      p.blit(imp.getTexture)
+#    end
 end
 
 #app=MyApp.new(128,128) #800,600)

Modified: antargis/trunk/ruby/tests/path/fields_test.rb
===================================================================
--- antargis/trunk/ruby/tests/path/fields_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/path/fields_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -19,9 +19,9 @@
 heightMap=HeightMap.new(nil,w,h)
 
 (0..w).each{|x|
-	(0..h).each{|y|
-		heightMap.set(x,y,rand)
-	}
+  (0..h).each{|y|
+    heightMap.set(x,y,rand)
+  }
 }
 
 
@@ -46,27 +46,27 @@
 image=AGSurface.new(w*fsize,h*fsize)
 
 def getColor(i)
-	j=i%8
-	j+=1
-	#puts "J:#{j}"
-	AGColor.new((j % 2)*255, ((j /2)%2)*255, (j / 4).to_i*255) #*(255.0-(i*2)/255.0)
+  j=i%8
+  j+=1
+  #puts "J:#{j}"
+  AGColor.new((j % 2)*255, ((j /2)%2)*255, (j / 4).to_i*255) #*(255.0-(i*2)/255.0)
 end
 
 
 (0..(w-1)).each{|x|
-	(0..(h-1)).each{|y|
-		fieldnum=pathData.getField(AGVector2.new(x,y))
-		if fieldnum<20000
-			puts "field:#{fieldnum}"
-			color=getColor(fieldnum)
-			puts "COLOR:#{color}"
-			(0..(fsize-1)).each{|dx|
-				(0..(fsize-1)).each{|dy|
-					image.putPixel(x*fsize+dx,y*fsize+dy,color)
-				}
-			}
-		end
-	}
+  (0..(h-1)).each{|y|
+    fieldnum=pathData.getField(AGVector2.new(x,y))
+    if fieldnum<20000
+      puts "field:#{fieldnum}"
+      color=getColor(fieldnum)
+      puts "COLOR:#{color}"
+      (0..(fsize-1)).each{|dx|
+        (0..(fsize-1)).each{|dy|
+          image.putPixel(x*fsize+dx,y*fsize+dy,color)
+        }
+      }
+    end
+  }
 }
 
 

Modified: antargis/trunk/ruby/tests/path/fields_test2.rb
===================================================================
--- antargis/trunk/ruby/tests/path/fields_test2.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/path/fields_test2.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -19,9 +19,9 @@
 heightMap=HeightMap.new(nil,w,h)
 
 (0..w).each{|x|
-	(0..h).each{|y|
-		heightMap.set(x,y,rand)
-	}
+  (0..h).each{|y|
+    heightMap.set(x,y,rand)
+  }
 }
 
 
@@ -59,41 +59,41 @@
 image=AGSurface.new(w*fsize,h*fsize)
 
 def getColor(i)
-	j=i%8
-	j+=1
-	AGColor.new((j % 2)*255, ((j /2)%2)*255, (j / 4).to_i*255) #*(255.0-(i*2)/255.0)
+  j=i%8
+  j+=1
+  AGColor.new((j % 2)*255, ((j /2)%2)*255, (j / 4).to_i*255) #*(255.0-(i*2)/255.0)
 end
 
 
 def displayFieldAssign(fieldCollection,image,w,h,fsize)
-	puts "DISPLAYING DATA"
-	(0..(w-1)).each{|x|
-		(0..(h-1)).each{|y|
-			fieldnum=fieldCollection.getFieldId(AGVector2.new(x,y))
-			if fieldnum<20000
-				color=getColor(fieldnum)
-				(0..(fsize-1)).each{|dx|
-					(0..(fsize-1)).each{|dy|
-						image.putPixel(x*fsize+dx,y*fsize+dy,color)
-					}
-				}
-			end
-		}
-	}
+  puts "DISPLAYING DATA"
+  (0..(w-1)).each{|x|
+    (0..(h-1)).each{|y|
+      fieldnum=fieldCollection.getFieldId(AGVector2.new(x,y))
+      if fieldnum<20000
+        color=getColor(fieldnum)
+        (0..(fsize-1)).each{|dx|
+          (0..(fsize-1)).each{|dy|
+            image.putPixel(x*fsize+dx,y*fsize+dy,color)
+          }
+        }
+      end
+    }
+  }
 end
 
 def displayDistanceData(field,image)
-	m=field.getMiddle
-	field.getVectors.each{|v|
-		
-		image.putPixel(v.x.to_i,v.y.to_i,AGColor.new(0xFF,0xFF,0xFF)*(1-(v-m).length*0.3))
-	}
+  m=field.getMiddle
+  field.getVectors.each{|v|
+    
+    image.putPixel(v.x.to_i,v.y.to_i,AGColor.new(0xFF,0xFF,0xFF)*(1-(v-m).length*0.3))
+  }
 end
 
 def displayNeighbors(field,image)
-	field.getNeighbors.each{|v|
-		image.putPixel(v.x.to_i,v.y.to_i,AGColor.new(0xFF,0,0))
-	}
+  field.getNeighbors.each{|v|
+    image.putPixel(v.x.to_i,v.y.to_i,AGColor.new(0xFF,0,0))
+  }
 end
 puts "COMPUTE  DISTACNES:"
 fieldCollection.computeDistances(distComputer)
@@ -101,10 +101,10 @@
 
 #displayFieldAssign(fieldCollection,image,w,h,fsize)
 (0..(fieldCollection.getFieldCount-1)).each{|num|
-	field=fieldCollection.getField(num)
-	#field.init
-	displayDistanceData(field,image)
-	#displayNeighbors(field,image)
+  field=fieldCollection.getField(num)
+  #field.init
+  displayDistanceData(field,image)
+  #displayNeighbors(field,image)
 }
 
 

Modified: antargis/trunk/ruby/tests/path/heuristic_test.rb
===================================================================
--- antargis/trunk/ruby/tests/path/heuristic_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/path/heuristic_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -13,13 +13,13 @@
 c=AGVector2.new(2,2)
 
 values=[
-	[a,b,3],
-	[b,c,4],
-	[c,a,5]
+  [a,b,3],
+  [b,c,4],
+  [c,a,5]
 ]
 
 values.each{|a|
-	f.store(a[0],a[1],a[2])
+  f.store(a[0],a[1],a[2])
 }
 
 stream=BinaryStringOut.new
@@ -32,7 +32,7 @@
 f2=StoredHeuristicFunction.new(stream)
 
 values.each{|a|
-	raise "error within #{a}" unless f2.get(a[0],a[1])==a[2] 
+  raise "error within #{a}" unless f2.get(a[0],a[1])==a[2] 
 }
 
-puts "ok"
\ No newline at end of file
+puts "ok"

Modified: antargis/trunk/ruby/tests/rect_test.rb
===================================================================
--- antargis/trunk/ruby/tests/rect_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/rect_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,24 +7,24 @@
 r=AGRect2.new(0,0,20,20)
 
 def checkPair(a,b)
-	l=a.difference(b)
-	l.each{|r|
-		puts "ERROR: #{r} not in #{a}!" unless a.contains(r)
-		puts "ERROR: #{r} is in #{b}!" if b.contains(r)
-	}
-	puts "size:#{l.length}"
-	#puts l
+  l=a.difference(b)
+  l.each{|r|
+    puts "ERROR: #{r} not in #{a}!" unless a.contains(r)
+    puts "ERROR: #{r} is in #{b}!" if b.contains(r)
+  }
+  puts "size:#{l.length}"
+  #puts l
 end
 
 [5,10].each{|w|
-	[5,10].each{|h|
-		[-20,-10,-5,0,5,10,20,30].each{|x|
-			[-20,-10,-5,0,5,10,20,30].each{|y|
-				a=AGRect2.new(x,y,w,h)
-				checkPair(r,a)
-			}
-		}
-	}
+  [5,10].each{|h|
+    [-20,-10,-5,0,5,10,20,30].each{|x|
+      [-20,-10,-5,0,5,10,20,30].each{|y|
+        a=AGRect2.new(x,y,w,h)
+        checkPair(r,a)
+      }
+    }
+  }
 }
 
-puts "seems ok"
\ No newline at end of file
+puts "seems ok"

Modified: antargis/trunk/ruby/tests/scene_2d.rb
===================================================================
--- antargis/trunk/ruby/tests/scene_2d.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/scene_2d.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -5,108 +5,108 @@
 getMain.initVideo(800,600,32,false,false)
 
 def makeExampleMesh(scene,type)
-	t=AGTexture.new(AGSurface.load("data/textures/2d/#{type}.png"))
-	data=Mesh2DData.new(t)
-	mesh=Mesh2D.new(scene,data,AGVector4.new(0,0,0,1),0)
-	mesh.setOrder(TREE_Z)
-	mesh
+  t=AGTexture.new(AGSurface.load("data/textures/2d/#{type}.png"))
+  data=Mesh2DData.new(t)
+  mesh=Mesh2D.new(scene,data,AGVector4.new(0,0,0,1),0)
+  mesh.setOrder(TREE_Z)
+  mesh
 end
 
 class MyTerrain #<TerrainBase
-	def initialize(scene,map)
-		#super
-		@scene=scene
+  def initialize(scene,map)
+    #super
+    @scene=scene
 
-		createTiles
-	end
+    createTiles
+  end
 
-	def createTiles
-		@textures={
-			:grass=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/basic_grass.png")),
-			:grass2=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/basic_grass2.png"))
-		}
-		@meshdata={}
-		@textures.each{|k,v|
-			@meshdata[k]=Mesh2DData.new(v)
-		}
+  def createTiles
+    @textures={
+      :grass=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/basic_grass.png")),
+      :grass2=>AGTexture.new(AGSurface.load("data/textures/2d/terrain/basic_grass2.png"))
+    }
+    @meshdata={}
+    @textures.each{|k,v|
+      @meshdata[k]=Mesh2DData.new(v)
+    }
 
-		(0..10).each{|x|
-			(0..100).each{|y|
-				ix=x*2+(y % 2)
-				iy=y
-				ix*=64
-				iy*=32
-				v=AGVector4.new(ix,iy,0,1)
-				t=:grass
-				if x+y>5
-					t=:grass2
-				end
-				mesh=Mesh2D.new(@scene, at meshdata[t],v,0)
-				@scene.addNode(mesh)
-				mesh.setOrder(TERRAIN_Z)
-			}
-		}
-	end
+    (0..10).each{|x|
+      (0..100).each{|y|
+        ix=x*2+(y % 2)
+        iy=y
+        ix*=64
+        iy*=32
+        v=AGVector4.new(ix,iy,0,1)
+        t=:grass
+        if x+y>5
+          t=:grass2
+        end
+        mesh=Mesh2D.new(@scene, at meshdata[t],v,0)
+        @scene.addNode(mesh)
+        mesh.setOrder(TERRAIN_Z)
+      }
+    }
+  end
 end
 
 
 class My2dWidget<AGWidget
-	def initialize(p,r)
-		super
-		@scene=Scene2D.new(r.width.to_i,r.height.to_i)
-		mesh=makeExampleMesh(@scene,:farm)
-		mesh.setPos(AGVector3.new(130,50,0))
-		@scene.addNode(mesh)
-		mesh=makeExampleMesh(@scene,:tree)
-		mesh.setPos(AGVector3.new(300,50,0))
-		@scene.addNode(mesh)
+  def initialize(p,r)
+    super
+    @scene=Scene2D.new(r.width.to_i,r.height.to_i)
+    mesh=makeExampleMesh(@scene,:farm)
+    mesh.setPos(AGVector3.new(130,50,0))
+    @scene.addNode(mesh)
+    mesh=makeExampleMesh(@scene,:tree)
+    mesh.setPos(AGVector3.new(300,50,0))
+    @scene.addNode(mesh)
 
-		@terrain=MyTerrain.new(@scene,nil)
-	end
-	def draw(p)
-		@scene.setPainter(p)
-		@scene.draw
-		@scene.discardPainter
-	end
+    @terrain=MyTerrain.new(@scene,nil)
+  end
+  def draw(p)
+    @scene.setPainter(p)
+    @scene.draw
+    @scene.discardPainter
+  end
 
-	def eventMouseButtonDown(e)
-		#raise 1
-		@mousePos=e.getMousePosition
-		super
-	end
-	def eventMouseButtonUp(e)
-		@mousePos=nil
-		super
-	end
-	def eventMouseMotion(e)
-		if @mousePos
-			diff=e.getMousePosition- at mousePos
-			@mousePos=e.getMousePosition
-			p=@scene.getCamera.dim2+AGVector2.new(-diff[0],diff[1])
-			@scene.setCamera(AGVector4.new(p[0],p[1],0,1))
-			queryRedraw
-		end
-		super
-	end
+  def eventMouseButtonDown(e)
+    #raise 1
+    @mousePos=e.getMousePosition
+    super
+  end
+  def eventMouseButtonUp(e)
+    @mousePos=nil
+    super
+  end
+  def eventMouseMotion(e)
+    if @mousePos
+      diff=e.getMousePosition- at mousePos
+      @mousePos=e.getMousePosition
+      p=@scene.getCamera.dim2+AGVector2.new(-diff[0],diff[1])
+      @scene.setCamera(AGVector4.new(p[0],p[1],0,1))
+      queryRedraw
+    end
+    super
+  end
 
-# 	def prepareDraw
-# 		queryRedraw
-# 	end
+#   def prepareDraw
+#     queryRedraw
+#   end
 
 end
 
 class My2dTest<AGApplication
-	def initialize
-		super
-		setMainWidget(My2dWidget.new(nil,AGRect2.new(0,0,getMain.width,getMain.height)))
-	end
-	def eventFrame(t)
-		
-		delay(20)
-		super
-	end
+  def initialize
+    super
+    setMainWidget(My2dWidget.new(nil,AGRect2.new(0,0,getMain.width,getMain.height)))
+  end
+  def eventFrame(t)
+    
+    delay(20)
+    super
+  end
 end
 
 app=My2dTest.new
 
-app.run
\ No newline at end of file
+app.run

Modified: antargis/trunk/ruby/tests/scissor_test.rb
===================================================================
--- antargis/trunk/ruby/tests/scissor_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/scissor_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -4,24 +4,24 @@
 require 'ruby/antargislib.rb'
 
 class MyWidget<AGWidget
-	def draw(p)
-		super
-		p.fillRect(AGRect2.new(-10,-10,30,30),AGColor.new(0,0xFF,0xFF))
-		p.fillRect(AGRect2.new(1,1,2,2),AGColor.new(0xFF,0xFF,0xFF))
-	end
+  def draw(p)
+    super
+    p.fillRect(AGRect2.new(-10,-10,30,30),AGColor.new(0,0xFF,0xFF))
+    p.fillRect(AGRect2.new(1,1,2,2),AGColor.new(0xFF,0xFF,0xFF))
+  end
 end
 
 class MyApp<AGApplication
-	def initialize
-		super
-		setMainWidget(MyWidget.new(nil,AGRect2.new(0,0,4,4)))
-	end
-	def eventFrame(t)
-		#puts "eventFram"
-		#delay(20)
-		tryQuit
-		return true
-	end
+  def initialize
+    super
+    setMainWidget(MyWidget.new(nil,AGRect2.new(0,0,4,4)))
+  end
+  def eventFrame(t)
+    #puts "eventFram"
+    #delay(20)
+    tryQuit
+    return true
+  end
 
 end
 

Modified: antargis/trunk/ruby/tests/sdl_texture.rb
===================================================================
--- antargis/trunk/ruby/tests/sdl_texture.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/sdl_texture.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,8 +7,8 @@
 
 
 class MyWidget<AGWidget
-	def initialize(p,r)
-		super
+  def initialize(p,r)
+    super
 
 a=AGSurface.new(64,64)
 p=AGPainter.new(a)
@@ -16,7 +16,7 @@
 p.fillRect(AGRect2.new(10,10,10,10),AGColor.new(0xFF,0,0))
 p=nil
 a.save("test0.png")
-	@t1=AGTexture.new(a)
+  @t1=AGTexture.new(a)
 
 
 t=AGTexture.new(64,64)
@@ -28,23 +28,23 @@
 s.save("test1.png")
 
 
-	@t2=AGTexture.new(s)
+  @t2=AGTexture.new(s)
 
-		@t3=AGTexture.new(64,64)
-		@t3.beginPaint
-		@t3.blit(@t2,AGRect2.new(0,0,64,64),AGRect2.new(0,0,64,64))
-		@t3.endPaint
+    @t3=AGTexture.new(64,64)
+    @t3.beginPaint
+    @t3.blit(@t2,AGRect2.new(0,0,64,64),AGRect2.new(0,0,64,64))
+    @t3.endPaint
 s=AGSurface.new(@t3.sdlTexture)
 s.save("test2.png")
 
-	end
-	def draw(p)
-		#p.
-		p.fillRect(AGRect2.new(0,0,256,256),AGColor.new(0,0xFF,0))
-		p.blit(@t1,AGRect2.new(0,0,64,64))
-		p.blit(@t2,AGRect2.new(64,0,64,64))
-		p.blit(@t3,AGRect2.new(128,0,64,64))
-	end
+  end
+  def draw(p)
+    #p.
+    p.fillRect(AGRect2.new(0,0,256,256),AGColor.new(0,0xFF,0))
+    p.blit(@t1,AGRect2.new(0,0,64,64))
+    p.blit(@t2,AGRect2.new(64,0,64,64))
+    p.blit(@t3,AGRect2.new(128,0,64,64))
+  end
 end
 
 
@@ -54,4 +54,4 @@
 imw=MyWidget.new(nil,AGRect2.new(0,0,800,600))
 
 app.setMainWidget(imw)
-app.run
\ No newline at end of file
+app.run

Modified: antargis/trunk/ruby/tests/swig_derivation_test.rb
===================================================================
--- antargis/trunk/ruby/tests/swig_derivation_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/swig_derivation_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -12,29 +12,29 @@
 puts "C:"
 puts l,l.object_id,l.class
 l.each{|i|
-	puts i,i.object_id,i.class
+  puts i,i.object_id,i.class
 }
 
 l=s.getCurrentNodes
 
 l.each{|i|
-	puts i,i.object_id
+  puts i,i.object_id
 }
 
 l.each{|i|
-	puts i,i.object_id
+  puts i,i.object_id
 }
 
 l.each{|i|
-	puts i,i.object_id
+  puts i,i.object_id
 }
 
 l.each{|i|
-	puts i,i.object_id
+  puts i,i.object_id
 }
 
 l=s.getCurrentNodes
 
 l.each{|i|
-	puts i,i.object_id
+  puts i,i.object_id
 }

Modified: antargis/trunk/ruby/tests/test_path.rb
===================================================================
--- antargis/trunk/ruby/tests/test_path.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/test_path.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -35,7 +35,7 @@
 heuristic=computeHeuristic(dg)
 
 # class MyHeu<HeuristicFunction
-# 	def distance(
+#   def distance(
 # end
 # 
 # heuristic
@@ -53,25 +53,25 @@
 
 $i=0
 class MDebug<PathDebugging
-	def debugPath(p,h)
-		$i+=1
-		#ms=AGSurface.new(800,600)
-		t=getScreen
-		$dg.paintNode(t.getRect,t,$startVec,AGColor.new(0xFF,0,0xFF))
-		$dg.paintNode(t.getRect,t,$endVec,AGColor.new(0,0,0xFF))
-		$dg.paint(t.getRect,t,$heuristic)
-		p.paint(t.getRect,t,$dg.width)
-		
-		#t=AGTexture.new(ms)
-		#getScreen.blit(t,ms.getRect,ms.getRect)
-		p=AGPainter.new(getScreen)
-		p.renderText(h.to_s,AGVector2.new(80,0),AGFont.new)
-		p=nil
+  def debugPath(p,h)
+    $i+=1
+    #ms=AGSurface.new(800,600)
+    t=getScreen
+    $dg.paintNode(t.getRect,t,$startVec,AGColor.new(0xFF,0,0xFF))
+    $dg.paintNode(t.getRect,t,$endVec,AGColor.new(0,0,0xFF))
+    $dg.paint(t.getRect,t,$heuristic)
+    p.paint(t.getRect,t,$dg.width)
+    
+    #t=AGTexture.new(ms)
+    #getScreen.blit(t,ms.getRect,ms.getRect)
+    p=AGPainter.new(getScreen)
+    p.renderText(h.to_s,AGVector2.new(80,0),AGFont.new)
+    p=nil
 
 
-		getScreen.flip
-		$app.delay(500)
-	end
+    getScreen.flip
+    $app.delay(500)
+  end
 end
 
 d=MDebug.new

Modified: antargis/trunk/ruby/tools/anim_import.rb
===================================================================
--- antargis/trunk/ruby/tools/anim_import.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tools/anim_import.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -13,8 +13,8 @@
 require 'antargisgui.rb'
 
 if ARGV == nil or ARGV.length<2
-	puts "call: anim_import.rb mesh.txt mesh.ant3"
-	exit
+  puts "call: anim_import.rb mesh.txt mesh.ant3"
+  exit
 end
 infilename=ARGV[0]
 outfilename=ARGV[1]
@@ -22,109 +22,109 @@
 $infile=File.open(infilename)
 
 def getline
-	if $infile.eof
-		throw "getline reached eof"
-	end
-	line=$infile.readline
-	if line=~/\/\/.*/ or line=="\n"
-		return getline
-	else
-		return line.gsub("\n","")
-	end
-		
+  if $infile.eof
+    throw "getline reached eof"
+  end
+  line=$infile.readline
+  if line=~/\/\/.*/ or line=="\n"
+    return getline
+  else
+    return line.gsub("\n","")
+  end
+    
 end
 
 def assert(cond)
-	if not cond
-		throw "assertion failed"
-	end
+  if not cond
+    throw "assertion failed"
+  end
 end
 
 class Vertex
-	def initialize(pos,tex,b)
-		@pos=pos
-		@tex=tex
-		@bone=b
-	end
-	def x
-		@pos.x
-	end
-	def y
-		@pos.y
-	end
-	def z
-		@pos.z
-	end
-	def tx
-		@tex.x
-	end
-	def ty
-		1- at tex.y
-	end
-	def bone
-		@bone
-	end
+  def initialize(pos,tex,b)
+    @pos=pos
+    @tex=tex
+    @bone=b
+  end
+  def x
+    @pos.x
+  end
+  def y
+    @pos.y
+  end
+  def z
+    @pos.z
+  end
+  def tx
+    @tex.x
+  end
+  def ty
+    1- at tex.y
+  end
+  def bone
+    @bone
+  end
 end
 
 class Triangle
-	def initialize(v0,v1,v2,n0,n1,n2,g)
-		@group=g
-		@v0=v0
-		@v1=v1
-		@v2=v2
-		@n0=n0
-		@n1=n1
-		@n2=n2
-	end
-	def fvertices
-		[f0,f1,f2]
-	end
-	def f0
-		[$vertices[@v0],$normals[@n0]]
-	end
-	def f1
-		[$vertices[@v1],$normals[@n1]]
-	end
-	def f2
-		[$vertices[@v2],$normals[@n2]]
-	end
+  def initialize(v0,v1,v2,n0,n1,n2,g)
+    @group=g
+    @v0=v0
+    @v1=v1
+    @v2=v2
+    @n0=n0
+    @n1=n1
+    @n2=n2
+  end
+  def fvertices
+    [f0,f1,f2]
+  end
+  def f0
+    [$vertices[@v0],$normals[@n0]]
+  end
+  def f1
+    [$vertices[@v1],$normals[@n1]]
+  end
+  def f2
+    [$vertices[@v2],$normals[@n2]]
+  end
 end
 
 class Frame
-	def initialize(t,p,r)
-		@time=t
-		@pos=p
-		@rot=r
-	end
-	attr_reader :time, :rot, :pos
+  def initialize(t,p,r)
+    @time=t
+    @pos=p
+    @rot=r
+  end
+  attr_reader :time, :rot, :pos
 end
 
 class Bone
-	def initialize(p,r,par)
-		@pos=p
-		@rot=r
-		@frames=[]
-		if par
-			@parent=par
-		else
-			@parent=-1
-		end
-	end
-	def addFrame(f)
-		@frames.push(f)
-	end
-	def getFrame(t)
-		@frames.each{|f|
-			if f.time==t
-				return f
-			end
-		}
-		e= "Frame "+t.to_s+" not Found!"
-		puts e
-		#throw e
-		return Frame.new(t,AGVector3.new(0,0,0),AGVector3.new(0,0,0))
-	end
-	attr_reader :pos, :rot, :frames, :parent
+  def initialize(p,r,par)
+    @pos=p
+    @rot=r
+    @frames=[]
+    if par
+      @parent=par
+    else
+      @parent=-1
+    end
+  end
+  def addFrame(f)
+    @frames.push(f)
+  end
+  def getFrame(t)
+    @frames.each{|f|
+      if f.time==t
+        return f
+      end
+    }
+    e= "Frame "+t.to_s+" not Found!"
+    puts e
+    #throw e
+    return Frame.new(t,AGVector3.new(0,0,0),AGVector3.new(0,0,0))
+  end
+  attr_reader :pos, :rot, :frames, :parent
 end
 
 # read frames
@@ -151,37 +151,37 @@
 $nstart=0
 for mesh in 0..($meshes-1)
 
-	line=getline
-	$meshname,flags,$material=line.split(" ")
-	$meshname.gsub!("\"","")
-	
-	# read vertices
-	line=getline
-	$numvertices=line.to_i
-	for i in 0..($numvertices-1)
-		line=getline
-		flags,x,y,z,u,v,bone=line.split(" ").collect{|x|x.to_f}
-		bone=bone.to_i
-		$vertices.push(Vertex.new(AGVector3.new(x,y,z),AGVector2.new(u,v),bone))
-	end
-	
-	#read normals
-	$numnormals=getline.to_i
-	for i in 0..($numnormals-1)
-		line=getline
-		x,y,z=line.split(" ").collect{|x|x.to_f}
-		$normals.push(AGVector3.new(x,y,z))
-	end
-	
-	#read triangles
-	$numtris=getline.to_i
-	for i in 0..($numtris-1)
-		line=getline
-		flag,i0,i1,i2,n0,n1,n2,g=line.split(" ").collect{|x|x.to_i}
-		$tris.push(Triangle.new(i0+$vstart, i1+$vstart, i2+$vstart, n0+$nstart, n1+$nstart, n2+$nstart ,g))
-	end
-	$vstart=$vertices.length
-	$nstart=$normals.length
+  line=getline
+  $meshname,flags,$material=line.split(" ")
+  $meshname.gsub!("\"","")
+  
+  # read vertices
+  line=getline
+  $numvertices=line.to_i
+  for i in 0..($numvertices-1)
+    line=getline
+    flags,x,y,z,u,v,bone=line.split(" ").collect{|x|x.to_f}
+    bone=bone.to_i
+    $vertices.push(Vertex.new(AGVector3.new(x,y,z),AGVector2.new(u,v),bone))
+  end
+  
+  #read normals
+  $numnormals=getline.to_i
+  for i in 0..($numnormals-1)
+    line=getline
+    x,y,z=line.split(" ").collect{|x|x.to_f}
+    $normals.push(AGVector3.new(x,y,z))
+  end
+  
+  #read triangles
+  $numtris=getline.to_i
+  for i in 0..($numtris-1)
+    line=getline
+    flag,i0,i1,i2,n0,n1,n2,g=line.split(" ").collect{|x|x.to_i}
+    $tris.push(Triangle.new(i0+$vstart, i1+$vstart, i2+$vstart, n0+$nstart, n1+$nstart, n2+$nstart ,g))
+  end
+  $vstart=$vertices.length
+  $nstart=$normals.length
 end
 # read materials =1  !!!
 line=getline
@@ -189,35 +189,35 @@
 line.gsub!("Materials: ","")
 $mats=line.to_i
 for mat in 1..$mats
-	#assert(line=="Materials: 1")
-	line=getline
-	assert(line=~/".*"/)
-	
-	# ambient
-	line=getline
-	r,g,b,a=line.split(" ").collect{|x|x.to_f}
-	$ambient=AGVector4.new(r,g,b,a)
-	
-	# diffuse
-	line=getline
-	r,g,b,a=line.split(" ").collect{|x|x.to_f}
-	$diffuse=AGVector4.new(r,g,b,a)
-	
-	# specular
-	line=getline
-	r,g,b,a=line.split(" ").collect{|x|x.to_f}
-	$specular=AGVector4.new(r,g,b,a)
-	
-	# emissive
-	line=getline
-	r,g,b,a=line.split(" ").collect{|x|x.to_f}
-	$emissive=AGVector4.new(r,g,b,a)
-	
-	$shininess=getline
-	$transparency=getline
-	
-	$colortex=getline.gsub("\"","")
-	$alphatex=getline.gsub("\"","")
+  #assert(line=="Materials: 1")
+  line=getline
+  assert(line=~/".*"/)
+  
+  # ambient
+  line=getline
+  r,g,b,a=line.split(" ").collect{|x|x.to_f}
+  $ambient=AGVector4.new(r,g,b,a)
+  
+  # diffuse
+  line=getline
+  r,g,b,a=line.split(" ").collect{|x|x.to_f}
+  $diffuse=AGVector4.new(r,g,b,a)
+  
+  # specular
+  line=getline
+  r,g,b,a=line.split(" ").collect{|x|x.to_f}
+  $specular=AGVector4.new(r,g,b,a)
+  
+  # emissive
+  line=getline
+  r,g,b,a=line.split(" ").collect{|x|x.to_f}
+  $emissive=AGVector4.new(r,g,b,a)
+  
+  $shininess=getline
+  $transparency=getline
+  
+  $colortex=getline.gsub("\"","")
+  $alphatex=getline.gsub("\"","")
 end
 line=getline
 puts line
@@ -228,44 +228,44 @@
 $bones=[]
 $bonenames={}
 for i in 0..($numbones-1)
-	name=getline.gsub("\"","")
-	parent=getline.gsub("\"","")
-	$bonenames[name]=i
-	flags,x,y,z,rx,ry,rz=getline.split(" ").collect{|a|a.to_f}
-	bone=Bone.new(AGVector3.new(x,y,z),AGVector3.new(rx,ry,rz),$bonenames[parent])
-	
-	poskeys=getline.to_i
-	pkeys={}
-	rkeys={}
-	for j in 1..poskeys
-		t,x,y,z = getline.split(" ").collect{|a|a.to_f}
-		pkeys[t]=AGVector3.new(x,y,z)
-	end
-	rotkeys=getline.to_i
-	for j in 1..rotkeys
-		t,x,y,z = getline.split(" ").collect{|a|a.to_f}
-		rkeys[t]=AGVector3.new(x,y,z)
-	end
-	
-	(rkeys.keys+pkeys.keys).sort.uniq.each{|t|
-		p=pkeys[t]
-		r=rkeys[t]
-		if not p
-			p=AGVector3.new(0,0,0)
-		end
-		if not r
-			r=AGVector3.new(0,0,0)
-		end
-		bone.addFrame(Frame.new(t,p,r))
-	}
-	$bones.push(bone)
+  name=getline.gsub("\"","")
+  parent=getline.gsub("\"","")
+  $bonenames[name]=i
+  flags,x,y,z,rx,ry,rz=getline.split(" ").collect{|a|a.to_f}
+  bone=Bone.new(AGVector3.new(x,y,z),AGVector3.new(rx,ry,rz),$bonenames[parent])
+  
+  poskeys=getline.to_i
+  pkeys={}
+  rkeys={}
+  for j in 1..poskeys
+    t,x,y,z = getline.split(" ").collect{|a|a.to_f}
+    pkeys[t]=AGVector3.new(x,y,z)
+  end
+  rotkeys=getline.to_i
+  for j in 1..rotkeys
+    t,x,y,z = getline.split(" ").collect{|a|a.to_f}
+    rkeys[t]=AGVector3.new(x,y,z)
+  end
+  
+  (rkeys.keys+pkeys.keys).sort.uniq.each{|t|
+    p=pkeys[t]
+    r=rkeys[t]
+    if not p
+      p=AGVector3.new(0,0,0)
+    end
+    if not r
+      r=AGVector3.new(0,0,0)
+    end
+    bone.addFrame(Frame.new(t,p,r))
+  }
+  $bones.push(bone)
 end
 
 begin
-	f=File.open(ARGV[1],"r")
-	puts "File '"+ARGV[1]+"' already exists!"
-	puts "Please give an other name!"
-	exit
+  f=File.open(ARGV[1],"r")
+  puts "File '"+ARGV[1]+"' already exists!"
+  puts "Please give an other name!"
+  exit
 rescue
 end
 
@@ -274,7 +274,7 @@
 fvertices=[]
 
 $tris.each{|t|
-	fvertices+=t.fvertices
+  fvertices+=t.fvertices
 }
 fvertices.uniq!
 puts "distinct verts:"+$vertices.length.to_s
@@ -284,34 +284,34 @@
 file.print [fvertices.length].pack("i")
 
 fvertices.each{|f|
-	a=[f[0].x,f[0].y,f[0].z,f[0].tx,f[0].ty,f[0].bone,f[1].x,f[1].y,f[1].z]
-	s=a.pack("fffffifff")
-	file.print s
+  a=[f[0].x,f[0].y,f[0].z,f[0].tx,f[0].ty,f[0].bone,f[1].x,f[1].y,f[1].z]
+  s=a.pack("fffffifff")
+  file.print s
 }
 
 file.print [$tris.length].pack("i")
 
 $tris.each{|t|
-	a=[]
-	t.fvertices.each{|v|
-		i=fvertices.index(v)
-		a.push(i)
-	}
-	file.print a.pack("iii")
+  a=[]
+  t.fvertices.each{|v|
+    i=fvertices.index(v)
+    a.push(i)
+  }
+  file.print a.pack("iii")
 }
 
 file.print [$bones.length].pack("i")
 $bones.each{|b|
-	a=[b.pos.x,b.pos.y,b.pos.z, b.rot.x,b.rot.y,b.rot.z,b.parent]
-	file.print a.pack("ffffffi")
+  a=[b.pos.x,b.pos.y,b.pos.z, b.rot.x,b.rot.y,b.rot.z,b.parent]
+  file.print a.pack("ffffffi")
 }
 
 keys=[]
 $bones.each{|b|
-	b.frames.each{|f|
-		keys.push(f.time)
-	}
-	keys.uniq!
+  b.frames.each{|f|
+    keys.push(f.time)
+  }
+  keys.uniq!
 }
 puts keys.collect{|x|x.to_s}.join(" - ")
 
@@ -319,11 +319,11 @@
 file.print [keys.length].pack("i")
 
 keys.each{|k|
-	file.print [k].pack("f")
-	$bones.each{|b|
-		f=b.getFrame(k)
-		file.print [f.pos.x,f.pos.y,f.pos.z,f.rot.x,f.rot.y,f.rot.z].pack("ffffff")
-	}
+  file.print [k].pack("f")
+  $bones.each{|b|
+    f=b.getFrame(k)
+    file.print [f.pos.x,f.pos.y,f.pos.z,f.rot.x,f.rot.y,f.rot.z].pack("ffffff")
+  }
 }
 
 file.close

Modified: antargis/trunk/ruby/tools/anim_import4.rb
===================================================================
--- antargis/trunk/ruby/tools/anim_import4.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tools/anim_import4.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -8,8 +8,8 @@
 require 'antargisgui.rb'
 
 if ARGV == nil or ARGV.length<2
-	puts "call: anim_import.rb mesh.txt mesh.ant4"
-	exit
+  puts "call: anim_import.rb mesh.txt mesh.ant4"
+  exit
 end
 infilename=ARGV[0]
 outfilename=ARGV[1]
@@ -17,101 +17,101 @@
 $infile=File.open(infilename)
 
 def getline
-	if $infile.eof
-		throw "getline reached eof"
-	end
-	line=$infile.readline
-	if line=~/\/\/.*/ or line=="\n"
-		return getline
-	else
-		return line.gsub("\n","")
-	end
-		
+  if $infile.eof
+    throw "getline reached eof"
+  end
+  line=$infile.readline
+  if line=~/\/\/.*/ or line=="\n"
+    return getline
+  else
+    return line.gsub("\n","")
+  end
+    
 end
 
 def assert(cond)
-	if not cond
-		throw "assertion failed"
-	end
+  if not cond
+    throw "assertion failed"
+  end
 end
 
 class Vertex
-	def initialize(pos,tex,b)
-		@pos=pos
-		@tex=tex
-		@bone=b
-	end
-	def x
-		@pos.x
-	end
-	def y
-		@pos.y
-	end
-	def z
-		@pos.z
-	end
-	def tx
-		@tex.x
-	end
-	def ty
-		1- at tex.y
-	end
-	def bone
-		@bone
-	end
+  def initialize(pos,tex,b)
+    @pos=pos
+    @tex=tex
+    @bone=b
+  end
+  def x
+    @pos.x
+  end
+  def y
+    @pos.y
+  end
+  def z
+    @pos.z
+  end
+  def tx
+    @tex.x
+  end
+  def ty
+    1- at tex.y
+  end
+  def bone
+    @bone
+  end
 end
 
 class Triangle
-	def initialize(v0,v1,v2,n0,n1,n2,g)
-		@group=g
-		@v0=v0
-		@v1=v1
-		@v2=v2
-		@n0=n0
-		@n1=n1
-		@n2=n2
-	end
-	def fvertices
-		[f0,f1,f2]
-	end
-	def f0
-		[$vertices[@v0],$normals[@n0]]
-	end
-	def f1
-		[$vertices[@v1],$normals[@n1]]
-	end
-	def f2
-		[$vertices[@v2],$normals[@n2]]
-	end
+  def initialize(v0,v1,v2,n0,n1,n2,g)
+    @group=g
+    @v0=v0
+    @v1=v1
+    @v2=v2
+    @n0=n0
+    @n1=n1
+    @n2=n2
+  end
+  def fvertices
+    [f0,f1,f2]
+  end
+  def f0
+    [$vertices[@v0],$normals[@n0]]
+  end
+  def f1
+    [$vertices[@v1],$normals[@n1]]
+  end
+  def f2
+    [$vertices[@v2],$normals[@n2]]
+  end
 end
 
 class Frame
-	def initialize(t,pv)
-		@time=t
-		@v=pv
-	end
-	attr_reader :time, :v
+  def initialize(t,pv)
+    @time=t
+    @v=pv
+  end
+  attr_reader :time, :v
 end
 
 class Bone
-	def initialize(p,r,par)
-		@pos=p
-		@rot=r
-		@rframes=[]
-		@tframes=[]
-		if par
-			@parent=par
-		else
-			@parent=-1
-		end
-	end
-	def addRFrame(f)
-		@rframes.push(f)
-	end
-	def addTFrame(f)
-		@tframes.push(f)
-	end
-	attr_reader :pos, :rot, :rframes, :parent, :tframes
+  def initialize(p,r,par)
+    @pos=p
+    @rot=r
+    @rframes=[]
+    @tframes=[]
+    if par
+      @parent=par
+    else
+      @parent=-1
+    end
+  end
+  def addRFrame(f)
+    @rframes.push(f)
+  end
+  def addTFrame(f)
+    @tframes.push(f)
+  end
+  attr_reader :pos, :rot, :rframes, :parent, :tframes
 end
 
 # read frames
@@ -138,37 +138,37 @@
 $nstart=0
 for mesh in 0..($meshes-1)
 
-	line=getline
-	$meshname,flags,$material=line.split(" ")
-	$meshname.gsub!("\"","")
-	
-	# read vertices
-	line=getline
-	$numvertices=line.to_i
-	for i in 0..($numvertices-1)
-		line=getline
-		flags,x,y,z,u,v,bone=line.split(" ").collect{|x|x.to_f}
-		bone=bone.to_i
-		$vertices.push(Vertex.new(AGVector3.new(x,y,z),AGVector2.new(u,v),bone))
-	end
-	
-	#read normals
-	$numnormals=getline.to_i
-	for i in 0..($numnormals-1)
-		line=getline
-		x,y,z=line.split(" ").collect{|x|x.to_f}
-		$normals.push(AGVector3.new(x,y,z))
-	end
-	
-	#read triangles
-	$numtris=getline.to_i
-	for i in 0..($numtris-1)
-		line=getline
-		flag,i0,i1,i2,n0,n1,n2,g=line.split(" ").collect{|x|x.to_i}
-		$tris.push(Triangle.new(i0+$vstart, i1+$vstart, i2+$vstart, n0+$nstart, n1+$nstart, n2+$nstart ,g))
-	end
-	$vstart=$vertices.length
-	$nstart=$normals.length
+  line=getline
+  $meshname,flags,$material=line.split(" ")
+  $meshname.gsub!("\"","")
+  
+  # read vertices
+  line=getline
+  $numvertices=line.to_i
+  for i in 0..($numvertices-1)
+    line=getline
+    flags,x,y,z,u,v,bone=line.split(" ").collect{|x|x.to_f}
+    bone=bone.to_i
+    $vertices.push(Vertex.new(AGVector3.new(x,y,z),AGVector2.new(u,v),bone))
+  end
+  
+  #read normals
+  $numnormals=getline.to_i
+  for i in 0..($numnormals-1)
+    line=getline
+    x,y,z=line.split(" ").collect{|x|x.to_f}
+    $normals.push(AGVector3.new(x,y,z))
+  end
+  
+  #read triangles
+  $numtris=getline.to_i
+  for i in 0..($numtris-1)
+    line=getline
+    flag,i0,i1,i2,n0,n1,n2,g=line.split(" ").collect{|x|x.to_i}
+    $tris.push(Triangle.new(i0+$vstart, i1+$vstart, i2+$vstart, n0+$nstart, n1+$nstart, n2+$nstart ,g))
+  end
+  $vstart=$vertices.length
+  $nstart=$normals.length
 end
 # read materials =1  !!!
 line=getline
@@ -176,35 +176,35 @@
 line.gsub!("Materials: ","")
 $mats=line.to_i
 for mat in 1..$mats
-	#assert(line=="Materials: 1")
-	line=getline
-	assert(line=~/".*"/)
-	
-	# ambient
-	line=getline
-	r,g,b,a=line.split(" ").collect{|x|x.to_f}
-	$ambient=AGVector4.new(r,g,b,a)
-	
-	# diffuse
-	line=getline
-	r,g,b,a=line.split(" ").collect{|x|x.to_f}
-	$diffuse=AGVector4.new(r,g,b,a)
-	
-	# specular
-	line=getline
-	r,g,b,a=line.split(" ").collect{|x|x.to_f}
-	$specular=AGVector4.new(r,g,b,a)
-	
-	# emissive
-	line=getline
-	r,g,b,a=line.split(" ").collect{|x|x.to_f}
-	$emissive=AGVector4.new(r,g,b,a)
-	
-	$shininess=getline
-	$transparency=getline
-	
-	$colortex=getline.gsub("\"","")
-	$alphatex=getline.gsub("\"","")
+  #assert(line=="Materials: 1")
+  line=getline
+  assert(line=~/".*"/)
+  
+  # ambient
+  line=getline
+  r,g,b,a=line.split(" ").collect{|x|x.to_f}
+  $ambient=AGVector4.new(r,g,b,a)
+  
+  # diffuse
+  line=getline
+  r,g,b,a=line.split(" ").collect{|x|x.to_f}
+  $diffuse=AGVector4.new(r,g,b,a)
+  
+  # specular
+  line=getline
+  r,g,b,a=line.split(" ").collect{|x|x.to_f}
+  $specular=AGVector4.new(r,g,b,a)
+  
+  # emissive
+  line=getline
+  r,g,b,a=line.split(" ").collect{|x|x.to_f}
+  $emissive=AGVector4.new(r,g,b,a)
+  
+  $shininess=getline
+  $transparency=getline
+  
+  $colortex=getline.gsub("\"","")
+  $alphatex=getline.gsub("\"","")
 end
 line=getline
 puts line
@@ -215,33 +215,33 @@
 $bones=[]
 $bonenames={}
 for i in 0..($numbones-1)
-	name=getline.gsub("\"","")
-	parent=getline.gsub("\"","")
-	$bonenames[name]=i
-	flags,x,y,z,rx,ry,rz=getline.split(" ").collect{|a|a.to_f}
-	bone=Bone.new(AGVector3.new(x,y,z),AGVector3.new(rx,ry,rz),$bonenames[parent])
-	
-	poskeys=getline.to_i
-	pkeys={}
-	rkeys={}
-	for j in 1..poskeys
-		t,x,y,z = getline.split(" ").collect{|a|a.to_f}
-		bone.addTFrame(Frame.new(t,AGVector3.new(x,y,z)))
-	end
-	rotkeys=getline.to_i
-	for j in 1..rotkeys
-		t,x,y,z = getline.split(" ").collect{|a|a.to_f}
-		bone.addRFrame(Frame.new(t,AGVector3.new(x,y,z)))
-	end
-	
-	$bones.push(bone)
+  name=getline.gsub("\"","")
+  parent=getline.gsub("\"","")
+  $bonenames[name]=i
+  flags,x,y,z,rx,ry,rz=getline.split(" ").collect{|a|a.to_f}
+  bone=Bone.new(AGVector3.new(x,y,z),AGVector3.new(rx,ry,rz),$bonenames[parent])
+  
+  poskeys=getline.to_i
+  pkeys={}
+  rkeys={}
+  for j in 1..poskeys
+    t,x,y,z = getline.split(" ").collect{|a|a.to_f}
+    bone.addTFrame(Frame.new(t,AGVector3.new(x,y,z)))
+  end
+  rotkeys=getline.to_i
+  for j in 1..rotkeys
+    t,x,y,z = getline.split(" ").collect{|a|a.to_f}
+    bone.addRFrame(Frame.new(t,AGVector3.new(x,y,z)))
+  end
+  
+  $bones.push(bone)
 end
 
 begin
-	f=File.open(ARGV[1],"r")
-	puts "File '"+ARGV[1]+"' already exists!"
-	puts "Please give an other name!"
-	exit
+  f=File.open(ARGV[1],"r")
+  puts "File '"+ARGV[1]+"' already exists!"
+  puts "Please give an other name!"
+  exit
 rescue
 end
 
@@ -250,7 +250,7 @@
 fvertices=[]
 
 $tris.each{|t|
-	fvertices+=t.fvertices
+  fvertices+=t.fvertices
 }
 fvertices.uniq!
 puts "distinct verts:"+$vertices.length.to_s
@@ -260,40 +260,40 @@
 file.print [fvertices.length].pack("i")
 
 fvertices.each{|f|
-	a=[f[0].x,f[0].y,f[0].z,f[0].tx,f[0].ty,f[0].bone,f[1].x,f[1].y,f[1].z]
-	s=a.pack("fffffifff")
-	file.print s
+  a=[f[0].x,f[0].y,f[0].z,f[0].tx,f[0].ty,f[0].bone,f[1].x,f[1].y,f[1].z]
+  s=a.pack("fffffifff")
+  file.print s
 }
 
 file.print [$tris.length].pack("i")
 
 $tris.each{|t|
-	a=[]
-	t.fvertices.each{|v|
-		i=fvertices.index(v)
-		a.push(i)
-	}
-	file.print a.pack("iii")
+  a=[]
+  t.fvertices.each{|v|
+    i=fvertices.index(v)
+    a.push(i)
+  }
+  file.print a.pack("iii")
 }
 
 file.print [$frames,$bones.length].pack("ii")
 $bones.each{|b|
-	a=[b.pos.x,b.pos.y,b.pos.z, b.rot.x,b.rot.y,b.rot.z,b.parent]
-	file.print a.pack("ffffffi")
-	
-	# rot frames
-	fs=b.rframes
-	file.print [fs.length].pack("i")
-	fs.each{|f|
-		file.print [f.time,f.v.x, f.v.y, f.v.z].pack("ffff")
-	}
-	
-	# translation frames
-	fs=b.tframes
-	file.print [fs.length].pack("i")
-	fs.each{|f|
-		file.print [f.time,f.v.x, f.v.y, f.v.z].pack("ffff")
-	}
+  a=[b.pos.x,b.pos.y,b.pos.z, b.rot.x,b.rot.y,b.rot.z,b.parent]
+  file.print a.pack("ffffffi")
+  
+  # rot frames
+  fs=b.rframes
+  file.print [fs.length].pack("i")
+  fs.each{|f|
+    file.print [f.time,f.v.x, f.v.y, f.v.z].pack("ffff")
+  }
+  
+  # translation frames
+  fs=b.tframes
+  file.print [fs.length].pack("i")
+  fs.each{|f|
+    file.print [f.time,f.v.x, f.v.y, f.v.z].pack("ffff")
+  }
 }
 
 file.close

Modified: antargis/trunk/ruby/tools/ant2obj.rb
===================================================================
--- antargis/trunk/ruby/tools/ant2obj.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tools/ant2obj.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -8,27 +8,27 @@
 infile=ARGV[0]
 
 class Reader
-	def initialize(c)
-		@c=c
-		@pos=0
-		@vlen=[1].pack("v").length
-		@elen=[1].pack("e").length
-	end
-	def readV
-		v=@c[@pos..(@pos+ at vlen)].unpack("v")
-		@pos+=@vlen
-		return v[0]
-	end
-	def readE
-		v=@c[@pos..(@pos+ at elen)].unpack("e")
-		@pos+=@elen
-		return v[0]
-	end
+  def initialize(c)
+    @c=c
+    @pos=0
+    @vlen=[1].pack("v").length
+    @elen=[1].pack("e").length
+  end
+  def readV
+    v=@c[@pos..(@pos+ at vlen)].unpack("v")
+    @pos+=@vlen
+    return v[0]
+  end
+  def readE
+    v=@c[@pos..(@pos+ at elen)].unpack("e")
+    @pos+=@elen
+    return v[0]
+  end
 end
 
 def mreadv(c)
-	l=[1].pack("v").length
-	c=c[l..c.length]
+  l=[1].pack("v").length
+  c=c[l..c.length]
 end
 
 puts infile
@@ -41,13 +41,13 @@
 puts faces
 puts faces.class
 (1..faces).each{|x|
-	fsize=r.readV
-	puts fsize
-	(1..fsize).each{|v|
-		vertex=[r.readE,r.readE,r.readE]
-		normal=[r.readE,r.readE,r.readE]
-		color=[r.readE,r.readE,r.readE]
-		tex=[r.readE,r.readE]
-		puts vertex.join("/")
-	}
+  fsize=r.readV
+  puts fsize
+  (1..fsize).each{|v|
+    vertex=[r.readE,r.readE,r.readE]
+    normal=[r.readE,r.readE,r.readE]
+    color=[r.readE,r.readE,r.readE]
+    tex=[r.readE,r.readE]
+    puts vertex.join("/")
+  }
 }

Modified: antargis/trunk/ruby/two_d_app.rb
===================================================================
--- antargis/trunk/ruby/two_d_app.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/two_d_app.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,166 +1,166 @@
 require 'terrain_2d.rb'
 
 class Scene2D
-	def getPickTriangles
-		0
-	end
-	def getTriangles
-		0
-	end
-	def getDrawnMeshes
-		0
-	end
+  def getPickTriangles
+    0
+  end
+  def getTriangles
+    0
+  end
+  def getDrawnMeshes
+    0
+  end
 end
 
 class AntBaseMapViewWidget<AGWidget
-	def initialize(p,r,scene)
-		super(p,r)
-		@scene=scene
-	end
+  def initialize(p,r,scene)
+    super(p,r)
+    @scene=scene
+  end
 
-	def draw(p)
-		@frame||=0
-		@frame+=1
+  def draw(p)
+    @frame||=0
+    @frame+=1
 
-		#if (@frame%2)==0
-			#p=AGPainter.new
-			@scene.setPainter(p)
-			@scene.draw
-			@scene.discardPainter
-			#p=nil
-			#GC.start
-		#end
-		super
-	end
-	def prepareDraw
-		queryRedraw
-		return
-		currentNodes=@scene.getCurrentNodes
-		puts "currentNodes:#{currentNodes}(#{currentNodes.class})!"
-		currentNodes.each{|n|
-			r=n.getLastDrawingRect
-			r2=n.getDrawingRect
-			if r!=r2
-				pushChangeRect(r)
-				pushChangeRect(r2)
-			end
-		}
+    #if (@frame%2)==0
+      #p=AGPainter.new
+      @scene.setPainter(p)
+      @scene.draw
+      @scene.discardPainter
+      #p=nil
+      #GC.start
+    #end
+    super
+  end
+  def prepareDraw
+    queryRedraw
+    return
+    currentNodes=@scene.getCurrentNodes
+    puts "currentNodes:#{currentNodes}(#{currentNodes.class})!"
+    currentNodes.each{|n|
+      r=n.getLastDrawingRect
+      r2=n.getDrawingRect
+      if r!=r2
+        pushChangeRect(r)
+        pushChangeRect(r2)
+      end
+    }
 
-	end
+  end
 end
 
 class AntBaseMapView<AGApplication
-	def initialize(w,h)
-		super()
-		@scene=Scene2D.new(w,h)
-		@submain=nil
-		@mainWidget=nil
-		setMainWidget(@realMainWidget=AntBaseMapViewWidget.new(nil,AGRect2.new(0,0,w,h), at scene))
-	end
+  def initialize(w,h)
+    super()
+    @scene=Scene2D.new(w,h)
+    @submain=nil
+    @mainWidget=nil
+    setMainWidget(@realMainWidget=AntBaseMapViewWidget.new(nil,AGRect2.new(0,0,w,h), at scene))
+  end
 
- 	def setMainWidget(w)
- 		if w.is_a?(AntBaseMapViewWidget)
- 			super(w)
- 		else
- 			@realMainWidget.removeChild(@mainWidget) if @mainWidget
- 			@mainWidget=w
- 			@realMainWidget.addChild(w)
- 		end
- 	end
+   def setMainWidget(w)
+     if w.is_a?(AntBaseMapViewWidget)
+       super(w)
+     else
+       @realMainWidget.removeChild(@mainWidget) if @mainWidget
+       @mainWidget=w
+       @realMainWidget.addChild(w)
+     end
+   end
  
- 	def getMainWidget
- 		@mainWidget
- 	end
-# 	def draw()
-# 		super()
-# 	end
+   def getMainWidget
+     @mainWidget
+   end
+#   def draw()
+#     super()
+#   end
 
 
-	def getScene
-		@scene
-	end
-	def setCamera(p)
-		@scene.setCamera(AGVector4.new(p.x,p.y,0))
-	end
-	def eventFrame(t)
-	end
+  def getScene
+    @scene
+  end
+  def setCamera(p)
+    @scene.setCamera(AGVector4.new(p.x,p.y,0))
+  end
+  def eventFrame(t)
+  end
 
-# 	def eventKeyDown(e)
-# 		super
-# 	end
+#   def eventKeyDown(e)
+#     super
+#   end
 
-	def eventMouseButtonDown(e)
-		#raise 1
-		case e.getButton
-			when 1
-				@mousePos=e.getMousePosition
-		end
-		@mayclick=true
-		super
-	end
-	def eventMouseButtonUp(e)
-		case e.getButton
-			when 1
-				@mousePos=nil
-		end
-		if @mayclick
-			nodes=tryClick(e.getMousePosition)
-			nodes.each{|n|
+  def eventMouseButtonDown(e)
+    #raise 1
+    case e.getButton
+      when 1
+        @mousePos=e.getMousePosition
+    end
+    @mayclick=true
+    super
+  end
+  def eventMouseButtonUp(e)
+    case e.getButton
+      when 1
+        @mousePos=nil
+    end
+    if @mayclick
+      nodes=tryClick(e.getMousePosition)
+      nodes.each{|n|
         puts "NODE: #{n}(#{n.class})"
         puts "NODE:"+(getMap.getEntity(n.node).to_s)
-			}
-			eventClick(nodes,e.getButton)
-		end
-		super
-	end
-	def eventMouseMotion(e)
-		@mayclick=false
-		if @mousePos
-			diff=e.getMousePosition- at mousePos
-			diff=diff*0.03
-			@mousePos=e.getMousePosition
-			p=@scene.getCamera.dim2+AGVector2.new(-diff[0],diff[1])
-			@scene.setCamera(AGVector4.new(p[0],p[1],0,1))
-			#queryRedraw
-		end
-		super
-	end
-	private
-	def tryClick(pos)
-		nodes=@scene.pick(pos.x,pos.y,1,1)	
-	end
+      }
+      eventClick(nodes,e.getButton)
+    end
+    super
+  end
+  def eventMouseMotion(e)
+    @mayclick=false
+    if @mousePos
+      diff=e.getMousePosition- at mousePos
+      diff=diff*0.03
+      @mousePos=e.getMousePosition
+      p=@scene.getCamera.dim2+AGVector2.new(-diff[0],diff[1])
+      @scene.setCamera(AGVector4.new(p[0],p[1],0,1))
+      #queryRedraw
+    end
+    super
+  end
+  private
+  def tryClick(pos)
+    nodes=@scene.pick(pos.x,pos.y,1,1)  
+  end
 end
 
 require 'map.rb'
 
 class AntRubyMap
-	def initTerrainMesh
-		setTerrain(Terrain2D.new(getScene,self))
-	end
+  def initTerrainMesh
+    setTerrain(Terrain2D.new(getScene,self))
+  end
 end
 
 
 require 'ant_models.rb'
 
 module AntModels
-	def AntModels.createModel(entityType,subType=nil,angle=nil)
-		type=entityType.to_s
-		if subType.to_s!=""
-			type+="_"+subType.to_s
-		end
-		t=AGTexture.new(AGSurface.load("data/textures/2d/#{type}.png"))
-		data=Mesh2DData.new(t)
-		mesh=Mesh2D.new(getMap.getScene,data,AGVector4.new(0,0,0,1),0)
-		mesh.setOrder(TREE_Z)
-		mesh
-	end
+  def AntModels.createModel(entityType,subType=nil,angle=nil)
+    type=entityType.to_s
+    if subType.to_s!=""
+      type+="_"+subType.to_s
+    end
+    t=AGTexture.new(AGSurface.load("data/textures/2d/#{type}.png"))
+    data=Mesh2DData.new(t)
+    mesh=Mesh2D.new(getMap.getScene,data,AGVector4.new(0,0,0,1),0)
+    mesh.setOrder(TREE_Z)
+    mesh
+  end
 end
 
 
 # some hacks
 class Mesh2D
-	def setRingColor(c)
-	end
-	def setAnimation(a)
-	end
-end
\ No newline at end of file
+  def setRingColor(c)
+  end
+  def setAnimation(a)
+  end
+end

Modified: antargis/trunk/ruby/widgets/ant_buttonpanel.rb
===================================================================
--- antargis/trunk/ruby/widgets/ant_buttonpanel.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/widgets/ant_buttonpanel.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -14,118 +14,118 @@
 # * sigJobChanged
 # You can attach your listeners to these to receive events when the aggression or a job is changed.
 class AntButtonPanel<AGWidget
-	attr_reader :job
-	
+  attr_reader :job
+  
 
-	def initialize(p,r)
-		super(p,r)
-		setName("ButtonPanel")
-		clearHandlers
-		@jobButtons=["doRest","doDismiss","doDropFood","doDropWeapon","doBuild"]
-		@aggButtons={"doAgg0"=>1,"doAgg1"=>2,"doAgg2"=>3}
-		@inited=false
-		@agg=1
+  def initialize(p,r)
+    super(p,r)
+    setName("ButtonPanel")
+    clearHandlers
+    @jobButtons=["doRest","doDismiss","doDropFood","doDropWeapon","doBuild"]
+    @aggButtons={"doAgg0"=>1,"doAgg1"=>2,"doAgg2"=>3}
+    @inited=false
+    @agg=1
 
-		addSignal("sigAggressionChanged")
-		addSignal("sigJobChanged")
+    addSignal("sigAggressionChanged")
+    addSignal("sigJobChanged")
 
-		@hero=nil
-	end
+    @hero=nil
+  end
 
-	# set the current hero *h* of class AntHero
-	def setHero(h)
-		assert{h.is_a?(AntHero) || h.nil?}
-		@hero=h
-		if @hero
-			setName(@hero.getName)
-		else
-			setName(_("no hero"))
-		end
-	end
+  # set the current hero *h* of class AntHero
+  def setHero(h)
+    assert{h.is_a?(AntHero) || h.nil?}
+    @hero=h
+    if @hero
+      setName(@hero.getName)
+    else
+      setName(_("no hero"))
+    end
+  end
 
 
-	# event-handlers can't be initialized in the constructor initialize, because
-	# possible children are not yet created.
-	# *initHandlers* initializes event-handlers for the job- and aggression-selection buttons.
-	# FIXME: this function should only be called once ! may be check this
-	def initHandlers
-		getChild("doAgg0").setChecked(true)
-		@job="doRest"
-		@jobButtons.each {|b|
-			c=getChild(b)
-			addHandler(c,:sigClick,:eventJobSelected)
-		}
-		@aggButtons.each {|b,a|
-			c=getChild(b)
-			addHandler(c,:sigClick,:eventAggSelected)
-		}
-	end
+  # event-handlers can't be initialized in the constructor initialize, because
+  # possible children are not yet created.
+  # *initHandlers* initializes event-handlers for the job- and aggression-selection buttons.
+  # FIXME: this function should only be called once ! may be check this
+  def initHandlers
+    getChild("doAgg0").setChecked(true)
+    @job="doRest"
+    @jobButtons.each {|b|
+      c=getChild(b)
+      addHandler(c,:sigClick,:eventJobSelected)
+    }
+    @aggButtons.each {|b,a|
+      c=getChild(b)
+      addHandler(c,:sigClick,:eventAggSelected)
+    }
+  end
 
-	# checks if the view has to be updated
-	def prepareDraw
-		updateJobView
-		super
-	end
+  # checks if the view has to be updated
+  def prepareDraw
+    updateJobView
+    super
+  end
 
-	
-	def eventJobSelected(e)
-		@job=e.getCaller.getName
-		sigJobChanged(e)
-		return true
-	end
+  
+  def eventJobSelected(e)
+    @job=e.getCaller.getName
+    sigJobChanged(e)
+    return true
+  end
 
-	# another aggression was selected, so put it forward to this signal *sigAggressionChanged*
-	def eventAggSelected(e)
-		@agg=@aggButtons[e.getCaller.getName]
-		sigAggressionChanged(e)
-		return true
-	end
-	
-	# force setting an aggresion 
-	# FIXME: which aggressions are ok ??? Check this in here!
-	def setAggression(l)
-		l=l.to_i
-		@aggButtons.each{|n,b|
-			getChild(n).setChecked((b==l))
-		}
-		@agg=l
-	end
+  # another aggression was selected, so put it forward to this signal *sigAggressionChanged*
+  def eventAggSelected(e)
+    @agg=@aggButtons[e.getCaller.getName]
+    sigAggressionChanged(e)
+    return true
+  end
+  
+  # force setting an aggresion 
+  # FIXME: which aggressions are ok ??? Check this in here!
+  def setAggression(l)
+    l=l.to_i
+    @aggButtons.each{|n,b|
+      getChild(n).setChecked((b==l))
+    }
+    @agg=l
+  end
 
-	# get the current aggression
-	def getAggression
-		@agg
-	end
-	def setPointing
-		@job="doPoint"
-		getChild("doFight").setChecked(true)
-	end
+  # get the current aggression
+  def getAggression
+    @agg
+  end
+  def setPointing
+    @job="doPoint"
+    getChild("doFight").setChecked(true)
+  end
 private
-	def updateJobView
-		return if @hero.nil?
-		if @hero.getJob
-			i=@hero.getJob.image
-		else
-			i="data/gui/bed.png"
-		end
-		if @job!=i
-			@job=i
-			getChild("jobView").setTexture(getTextureCache.get(i))
-		end
-	end
+  def updateJobView
+    return if @hero.nil?
+    if @hero.getJob
+      i=@hero.getJob.image
+    else
+      i="data/gui/bed.png"
+    end
+    if @job!=i
+      @job=i
+      getChild("jobView").setTexture(getTextureCache.get(i))
+    end
+  end
 
-	# set another name for the hero-name-display
-	def setName(n)
-		if getChild("heroName")
-			getChild("heroName").setText(_(n))
-		end
-	end
+  # set another name for the hero-name-display
+  def setName(n)
+    if getChild("heroName")
+      getChild("heroName").setText(_(n))
+    end
+  end
 
 end
 
 # factory for buttonpanel-widget
 class AntButtonPanelCreator<AGLayoutCreator
-	def create(p,r,n)
-		setResult AntButtonPanel.new(p,r)
-	end
+  def create(p,r,n)
+    setResult AntButtonPanel.new(p,r)
+  end
 end
 getLayoutFactory.addCreator("antButtonPanel",AntButtonPanelCreator.new)

Modified: antargis/trunk/ruby/widgets/ant_name_display.rb
===================================================================
--- antargis/trunk/ruby/widgets/ant_name_display.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/widgets/ant_name_display.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -5,52 +5,52 @@
 # Enemy heroes' names are displayed in red - your own heroes are display in yellow.
 # the position on the screen must be given from outside (from the application e.g.)
 class AntNameDisplay<AGWidget
-	@@fontChangeCount=0
+  @@fontChangeCount=0
 
-	# p - the parent widget
-	# r - the surrounding rectangle
-	# hero - the inspected hero
-	# map - the containing map-object
-	def initialize(p,r,hero,map)
-		super(p,r)
-		@map=map
-		@hero=hero
-		@font=getTheme.getFont("heroName.font")
-		@oldfont=@font
-		@name=@hero.getName
-		addChild(@mb=AGButton.new(self,AGRect.new(0,0,width,height),_("")))
-		
-		# disable button - so it can't be clicked anymore (no hovering either)
-		@mb.setEnabled(false)
-		addChild(@textWidget=AGText.new(self,AGRect.new(0,0,width,height),AGStringUtf8.new(@hero.getName), at font))
-		
-		# assign font-types
-		@fonts={true=>getTheme.getFont("heroName.font"),false=>getTheme.getFont("enemyHero.font")}
-		
-		# enable caching of widget texture - this improves drawing performance (slightly)
-		setCaching(true)
-	end
+  # p - the parent widget
+  # r - the surrounding rectangle
+  # hero - the inspected hero
+  # map - the containing map-object
+  def initialize(p,r,hero,map)
+    super(p,r)
+    @map=map
+    @hero=hero
+    @font=getTheme.getFont("heroName.font")
+    @oldfont=@font
+    @name=@hero.getName
+    addChild(@mb=AGButton.new(self,AGRect.new(0,0,width,height),_("")))
+    
+    # disable button - so it can't be clicked anymore (no hovering either)
+    @mb.setEnabled(false)
+    addChild(@textWidget=AGText.new(self,AGRect.new(0,0,width,height),AGStringUtf8.new(@hero.getName), at font))
+    
+    # assign font-types
+    @fonts={true=>getTheme.getFont("heroName.font"),false=>getTheme.getFont("enemyHero.font")}
+    
+    # enable caching of widget texture - this improves drawing performance (slightly)
+    setCaching(true)
+  end
 
-	# enforce integer position	
-	# 
-	def setRect(r)
-		super(AGRect.new(r.x.to_i,r.y.to_i,r.w.to_i,r.h.to_i))
-	end
-	
-	def getText
-		@name
-	end
+  # enforce integer position  
+  # 
+  def setRect(r)
+    super(AGRect.new(r.x.to_i,r.y.to_i,r.w.to_i,r.h.to_i))
+  end
+  
+  def getText
+    @name
+  end
 
-	def prepareDraw
-		# check if @hero's player changed
-		@font=@fonts[@hero.getPlayer==@map.getPlayer]
-		if @font!=@oldfont
-			# this is the case - so assign new font to textWidget
-			@oldfont=@font
-			@textWidget.setFont(@font)
-			# query redraw of (possibly) cached widget texture
-			queryRedraw
-		end
-		super
-	end
+  def prepareDraw
+    # check if @hero's player changed
+    @font=@fonts[@hero.getPlayer==@map.getPlayer]
+    if @font!=@oldfont
+      # this is the case - so assign new font to textWidget
+      @oldfont=@font
+      @textWidget.setFont(@font)
+      # query redraw of (possibly) cached widget texture
+      queryRedraw
+    end
+    super
+  end
 end



From davidkamphausen at mail.berlios.de  Fri Jun  6 20:33:47 2008
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Fri, 6 Jun 2008 20:33:47 +0200
Subject: [Antargis-svn] r1264 - in antargis/trunk: ext/basic main ruby
	ruby/spec
Message-ID: <200806061833.m56IXlBQ032250@sheep.berlios.de>

Author: davidkamphausen
Date: 2008-06-06 20:33:45 +0200 (Fri, 06 Jun 2008)
New Revision: 1264

Modified:
   antargis/trunk/ext/basic/ag_rtools.cc
   antargis/trunk/ext/basic/ag_rtools.h
   antargis/trunk/ext/basic/ag_string.cc
   antargis/trunk/ext/basic/ag_string.h
   antargis/trunk/main/starter.cc
   antargis/trunk/ruby/antargislib.rb
   antargis/trunk/ruby/spec/spec_scrollingwidget.rb
Log:
Incomplete - task 6: Cleanup 
http://localhost:3000/issues/show/6
Complete - task 45: Check clipping when hovering 
http://localhost:3000/issues/show/45

Modified: antargis/trunk/ext/basic/ag_rtools.cc
===================================================================
--- antargis/trunk/ext/basic/ag_rtools.cc	2008-06-05 19:24:45 UTC (rev 1263)
+++ antargis/trunk/ext/basic/ag_rtools.cc	2008-06-06 18:33:45 UTC (rev 1264)
@@ -39,6 +39,9 @@
 }
 
 
+
+
+
 bool rubyMatchRegex(const std::string &p,const std::string &pregex)
   {
     VALUE rp=rb_str_new(p.c_str(),p.length());

Modified: antargis/trunk/ext/basic/ag_rtools.h
===================================================================
--- antargis/trunk/ext/basic/ag_rtools.h	2008-06-05 19:24:45 UTC (rev 1263)
+++ antargis/trunk/ext/basic/ag_rtools.h	2008-06-06 18:33:45 UTC (rev 1264)
@@ -6,6 +6,7 @@
 
 AGEXPORT std::string rubyHash(const std::string &p);
 AGEXPORT bool rubyMatchRegex(const std::string &p,const std::string &pregex);
+std::string rubySub(const std::string &p,const std::string &search,const std::string &repl);
 
 
 

Modified: antargis/trunk/ext/basic/ag_string.cc
===================================================================
--- antargis/trunk/ext/basic/ag_string.cc	2008-06-05 19:24:45 UTC (rev 1263)
+++ antargis/trunk/ext/basic/ag_string.cc	2008-06-06 18:33:45 UTC (rev 1264)
@@ -223,3 +223,8 @@
 {
   return rubyMatchRegex(*this,regex);
 }
+
+AGString AGString::last(size_t n) const
+{
+  
+}

Modified: antargis/trunk/ext/basic/ag_string.h
===================================================================
--- antargis/trunk/ext/basic/ag_string.h	2008-06-05 19:24:45 UTC (rev 1263)
+++ antargis/trunk/ext/basic/ag_string.h	2008-06-06 18:33:45 UTC (rev 1264)
@@ -39,6 +39,8 @@
   std::vector<AGString> split(const AGString &p) const;
 
   AGString replace(const AGString &what, const AGString &by) const;
+  
+  AGString last(size_t n) const;
 
   AGString operator+(const AGString &s) const;
   AGString operator+(const char *s) const;

Modified: antargis/trunk/main/starter.cc
===================================================================
--- antargis/trunk/main/starter.cc	2008-06-05 19:24:45 UTC (rev 1263)
+++ antargis/trunk/main/starter.cc	2008-06-06 18:33:45 UTC (rev 1264)
@@ -3,20 +3,70 @@
 #include <ruby.h>
 #include <iostream>
 
-//extern "C" void Init_antargis();
+#include <ag_rtools.h>
+#include <ag_string.h>
 
-int main(int argc,char*argv[])
+std::string toLower(const std::string &s)
   {
+    std::string a;
+    for(size_t i=0;i<s.length();i++)
+      {
+        if(s[i]>='A' && s[i]<='Z')
+          a+=s[i]-'A'+'a';
+        else
+          a+=s[i];
+      }
+    return a;
+  }
+
+bool isWindows(const std::string &str)
+  {
+    int s=std::max((int)str.length()-5,0);
+    int l=std::max((int)str.length()-s,0);
+    std::string e=str.substr(s,l);
+
+    return(toLower(e)==".exe");
+  }
+
+std::string truncReverseUntil(const std::string &object,const std::string &search)
+  {
+    size_t r=object.rfind(search);
+    if(r==object.npos)
+      return "";
+
+    return object.substr(0,r);
+  }
+
+int main(int _argc,char*_argv[])
+  {
     ruby_init();
-    //rb_load_file("antargis");
-    std::cout<<"Init_antargis out of starter..."<<std::endl;
-    //Init_antargis();
-    std::cout<<"Init_antargis out of starter-ready"<<std::endl;
-    std::cout<<"Init_antargis out of starter-ready"<<std::endl;
+
+
+    int argc=_argc;
+    char**argv=_argv;
+
+    if(argc==1)
+      {
+        argv=new char*[2];
+        argv[0]=_argv[0];
+
+        std::string s=argv[0],sep;
+
+        if(isWindows(s))
+          sep="\\";
+        else
+          sep="/";
+        s=truncReverseUntil(s,sep);
+
+        argv[1]=new char[s.length()+100];
+        strcpy(argv[1],(s+sep+"antargis").c_str());
+        argc=2;
+      }
+
+
     ruby_options(argc,argv);
-    std::cout<<"AAA"<<std::endl;
-    //ruby_script("sdl_starter");
-    std::cout<<"BBB"<<std::endl;
+    rb_gv_set("antargisStarterLoaded",Qtrue);
+
     ruby_run();
     std::cout<<"CCC"<<std::endl;
     return 0;

Modified: antargis/trunk/ruby/antargislib.rb
===================================================================
--- antargis/trunk/ruby/antargislib.rb	2008-06-05 19:24:45 UTC (rev 1263)
+++ antargis/trunk/ruby/antargislib.rb	2008-06-06 18:33:45 UTC (rev 1264)
@@ -80,6 +80,17 @@
 end
 
 begin
+  if $antargisStarterLoaded!=true
+    puts "Please run wih ./starter antargis" 
+    exit
+  end
+rescue
+  puts "Please run wih ./starter antargis"
+  exit
+end
+
+
+begin
   include Antargis
   puts "Antargis-module included"
 rescue

Modified: antargis/trunk/ruby/spec/spec_scrollingwidget.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_scrollingwidget.rb	2008-06-05 19:24:45 UTC (rev 1263)
+++ antargis/trunk/ruby/spec/spec_scrollingwidget.rb	2008-06-06 18:33:45 UTC (rev 1264)
@@ -108,3 +108,30 @@
     end
   end
 end
+
+describe "Clipping of AGWidget" do
+  include GuiTest
+  before(:each) do
+    @app=makeTestAppClass(AGApplication).new
+    @m=AGWidget.new(nil,AGRect2.new(10,10,20,20))
+    @app.setMainWidget(@m)
+    @c=AGWidget.new(@m,AGRect2.new(-10,-10,20,20))
+    @m.addChild(@c)
+  end    
+  def self.checkHovering(pos,boolM,boolC)
+    s0=(boolM ? "" : "not ")
+    s1=(boolC ? "" : "not ")
+    it "should #{s0}hover m at #{pos}" do
+      mouseMotion(pos)
+      @m.hovered.should == boolM
+    end
+    it "should #{s0}hover c at #{pos}" do
+      mouseMotion(pos)
+      @c.hovered.should == boolC
+    end
+  end
+  checkHovering(AGVector2.new(5,5),false,false)
+  checkHovering(AGVector2.new(10,10),true,true)
+  checkHovering(AGVector2.new(15,15),true,true)
+  checkHovering(AGVector2.new(30,30),true,false)
+end



From davidkamphausen at mail.berlios.de  Mon Jun  9 20:46:20 2008
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Mon, 9 Jun 2008 20:46:20 +0200
Subject: [Antargis-svn] r1265 - in antargis/trunk: .
	data/gui/layout/editor/campaign ext/basic ext/gui ext/video
	main ruby/editor/campaign
Message-ID: <200806091846.m59IkKXt015351@sheep.berlios.de>

Author: davidkamphausen
Date: 2008-06-09 20:46:17 +0200 (Mon, 09 Jun 2008)
New Revision: 1265

Added:
   antargis/trunk/antargisStarter.rb
Removed:
   antargis/trunk/antargis
Modified:
   antargis/trunk/Rakefile
   antargis/trunk/TODO
   antargis/trunk/data/gui/layout/editor/campaign/main.xml
   antargis/trunk/ext/basic/ag_geometry.cc
   antargis/trunk/ext/basic/ag_geometry.h
   antargis/trunk/ext/basic/ag_xml.cc
   antargis/trunk/ext/basic/ag_xml.h
   antargis/trunk/ext/gui/ag_frame.cc
   antargis/trunk/ext/gui/ag_frame.h
   antargis/trunk/ext/gui/ag_image.cc
   antargis/trunk/ext/gui/ag_image.h
   antargis/trunk/ext/gui/ag_layoutcreators.cc
   antargis/trunk/ext/gui/ag_table.cc
   antargis/trunk/ext/gui/ag_table.h
   antargis/trunk/ext/gui/ag_widget.cc
   antargis/trunk/ext/video/ag_gltexture.cc
   antargis/trunk/main/starter.cc
   antargis/trunk/ruby/editor/campaign/drag_grid.rb
Log:
Complete - task 46: Add check and call in antargislib.rb to prevent loading .so without running starter 
http://localhost:3000/issues/show/46
Complete - task 45: Check clipping when hovering 
http://localhost:3000/issues/show/45
Incomplete - task 11: Campaign editor 
http://localhost:3000/issues/show/11

Modified: antargis/trunk/Rakefile
===================================================================
--- antargis/trunk/Rakefile	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/Rakefile	2008-06-09 18:46:17 UTC (rev 1265)
@@ -17,7 +17,7 @@
 lib=Rookey::ruby_ext("antargis",Dir["ext/*/*.cc"]+Dir["ext/*/*.c"]+Dir["ext/*/*.h"]+Dir["ext/*/templates.i"],inits)
 
 ts=Rookey::compile(Dir["main/starter.cc"])
-main=Rookey::link_exe("starter",ts)
+main=Rookey::link_exe("antargis",ts)
 
 
 task :default=>[lib,main] do
@@ -29,7 +29,7 @@
 def system(cmd)
   #puts Dir.pwd
   if cmd=~/ruby .*/
-    cmd=cmd.gsub(/^ruby/,"./starter")
+    cmd=cmd.gsub(/^ruby/,"./antargis")
   end
   #puts cmd
   oldSystem(cmd)
@@ -55,7 +55,7 @@
 
 
 namespace :spec do
-  spec_cmd = (RUBY_PLATFORM =~ /java/) ? "jruby -S spec" : "./starter /usr/bin/spec"
+  spec_cmd = (RUBY_PLATFORM =~ /java/) ? "jruby -S spec" : "./antargis /usr/bin/spec"
   task :showall do
     puts Dir["ruby/**/spec_*.rb"].select{|f|not f=~/spec_helper.rb/}.join("\n")
   end

Modified: antargis/trunk/TODO
===================================================================
--- antargis/trunk/TODO	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/TODO	2008-06-09 18:46:17 UTC (rev 1265)
@@ -3,28 +3,9 @@
 * why is the story-telling dialog taking so much time ??
 * why is the story-telling dialog eating up clicks ?
 * improve settings-dialog!
-* check level-editor
-** make wish-list
 
-* move single entities with path-finder, too?
 
-* docs
-* configure
-* "contrib"
- * autopackage
- * debian
- * antargis.iss
 
-
-* check if reachable before fetching !!! (in house) - or even better use heuristic for estimating distance in getNear(...)
-* fix jobs some more
-* what's wrong with pathfinding-test ???
-
-
-==========
-
-
-
 Short Information:
 Problems are marked by priority. L is for low, M for medium and H high.
 In special cases it can be Very High (=VH).
@@ -39,7 +20,6 @@
 [Arts - Graphics - 3D]
 ------------------------------------------------------
 [H] modify bakery a little (http://antargis.berlios.de/phpBB2/viewtopic.php?p=359#359)
-[H] do bow animation
 
 [H] oil tower
 [M] team color
@@ -192,7 +172,6 @@
 
 [Editor]
 ------------------------------------------------------
-[H] loading doesn't remove old entities
 [H] remove load script when in editor
 [H] add painting by dragging
 [H] plain other terrain type
@@ -207,9 +186,3 @@
 [L] installer for linux. maybe some autopackage or .debs?
 
 
-DOCUMENTATION
-======================================================
-[H] Architecture
-[H] comments in ruby-scripts
-[H] comments in game-engine
-[H] comments in 3d-engine

Deleted: antargis/trunk/antargis
===================================================================
--- antargis/trunk/antargis	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/antargis	2008-06-09 18:46:17 UTC (rev 1265)
@@ -1,46 +0,0 @@
-#!/usr/bin/env ruby
-
-# run intro - mainmenu will be called automatically
-
-Dir.chdir(File.split(__FILE__)[0])
-
-require 'ruby/intro.rb'
-require 'ruby/mainmenu.rb'
-
-
-
-# code for starting a level directly from command-line like this:
-# ./ruby/run_game.rb levels/birth1
-# or
-# ./ruby/run_game.rb savegames/savegame0
-$useMenu||=false
-if true
-  savegame=""
-  ARGV.each{|arg|
-    if arg=~/levels.*/ or arg=~/savegames.*/
-      savegame=arg+".antlvl"
-    end
-  }
-  if savegame!=""
-    startGame(savegame) 
-    exit
-  end
-end
-
-if getConfig.get("intro")!="false"
-  app=IntroApp.new
-  app.run
-end
-
-
-
-getConfig.set("ok","ok")
-
-
-
-# run menu
-app=AntMenuApp.new
-app.run
-
-
-MyLocalizer.finalize
\ No newline at end of file

Copied: antargis/trunk/antargisStarter.rb (from rev 1260, antargis/trunk/antargis)

Modified: antargis/trunk/data/gui/layout/editor/campaign/main.xml
===================================================================
--- antargis/trunk/data/gui/layout/editor/campaign/main.xml	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/data/gui/layout/editor/campaign/main.xml	2008-06-09 18:46:17 UTC (rev 1265)
@@ -51,7 +51,7 @@
           <edit name="textEdit"/>
         </cell>
         <cell col="1" row="0">
-          <button name="weiter"/>
+          <button name="weiter" caption-image="data/gui/options.png"/>
         </cell>
       </table>
     </cell>
@@ -59,8 +59,36 @@
   </table>
   </cell>
   </table>
-  <!--
   <appearEffect name="showEdit" table="bigTable" row="1" size="40" duration="0.2"/>
--->  
+  <hideEffect name="hideEdit" table="bigTable" row="1" size="40" duration="0.2"/>
 </dragEnvironment>
+   <image filename="" tile="true" color="#00000099"/>
+
+  <frame width="150" height="70">
+    <frame border="button.border.normal">
+      <image filename="" tile="true" color="#000000FF"/>
+      <table rows="2" cols="1">
+        <rowsize row="0" relative="3"/>
+        <cell col="0" row="0">
+          <frame width="20">
+            <image filename="data/gui/map1.png" scale="true"/>
+          </frame>
+        </cell>
+        <cell col="0" row="1">
+          <table rows="1" cols="3">
+            <colsize col="1" relative="8"/>
+            <cell col="1" row="0">
+              <edit text="caption"/>
+            </cell>
+            <cell col="0" row="0">
+              <button caption="Back"/>
+            </cell>
+            <cell col="2" row="0">
+              <button caption="Next"/>
+            </cell>
+          </table>
+        </cell>
+      </table>
+    
+  </frame>
 </layout>
\ No newline at end of file

Modified: antargis/trunk/ext/basic/ag_geometry.cc
===================================================================
--- antargis/trunk/ext/basic/ag_geometry.cc	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/ext/basic/ag_geometry.cc	2008-06-09 18:46:17 UTC (rev 1265)
@@ -995,31 +995,12 @@
 bool AGTriangle2::contains(const AGVector2 &pp) const
 {
   std::vector<AGVector2> l=getNormals(); // BEWARE: dont' change the order in getNormals!!!
-  cdebug(pp);
-  cdebug(l[0]);
-  cdebug(l[1]);
-  cdebug(l[2]);
 
-  cdebug(p[0]);
-  cdebug(p[1]);
-  cdebug(p[2]);
 
-  cdebug((pp-p[2])*l[0]);
-  cdebug((pp-p[0])*l[1]);
-  cdebug((pp-p[1])*l[2]);
-
-
   if(AGsign((pp-p[0])*l[0])==AGsign((p[2]-p[0])*l[0]))
     if(AGsign((pp-p[0])*l[1])==AGsign((p[1]-p[0])*l[1]))
       if(AGsign((pp-p[1])*l[2])==AGsign((p[0]-p[1])*l[2]))
         return true;
-
-  /*
-  if(AGsign((pp-p[2])*l[0])==AGsign((p[2]-p[2])*l[0]))
-    if(AGsign((pp-p[0])*l[1])==AGsign((p[0]-p[0])*l[1]))
-      if(AGsign((pp-p[1])*l[2])==AGsign((p[1]-p[1])*l[2]))
-        return true;
-   */
   return false;
 }
 
@@ -1433,6 +1414,13 @@
   return AGRect2(v0+d,v1-d);
 }
 
+AGRect2 AGRect2::shrink(float w,float h) const
+{
+  AGVector2 d(w,h);
+  return AGRect2(v0+d,v1-d);
+}
+
+
 AGRect2 AGRect2::shrinkToTopLeft(float w,float h) const
 {
   return AGRect2(x(),y(),this->w()-w,this->h()-h);

Modified: antargis/trunk/ext/basic/ag_geometry.h
===================================================================
--- antargis/trunk/ext/basic/ag_geometry.h	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/ext/basic/ag_geometry.h	2008-06-09 18:46:17 UTC (rev 1265)
@@ -467,6 +467,7 @@
     AGVector2 getMiddle() const;
 
     AGRect2 shrink(float f) const;
+    AGRect2 shrink(float w,float h) const;
     AGRect2 shrinkToTopLeft(float w,float h) const;
     AGRect2 grow(float f) const;
 

Modified: antargis/trunk/ext/basic/ag_xml.cc
===================================================================
--- antargis/trunk/ext/basic/ag_xml.cc	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/ext/basic/ag_xml.cc	2008-06-09 18:46:17 UTC (rev 1265)
@@ -451,11 +451,13 @@
   return os.str();
 }
 
-void Parser::Data::eat(size_t i)
+void Parser::Data::eat(size_t i) throw (XMLParseError)
   {
     STACKTRACE;
     if(pos+i>s.length())
-      throw int();
+      {
+        throw XMLParseError("in Parse::Data::eat - no data left");
+      }
     for(size_t j=0;j<i;j++)
       if(s[pos+j]=='\n')
         line++;
@@ -484,13 +486,19 @@
     linestack.pop_back();
   }
 
-void Parser::Data::eatBlanks()
+void Parser::Data::eatBlanks() throw (XMLParseError)
   {
     AGString f=getFirst(1);
 
     while(f==" " || f=="\t" || f=="\n")
       {
-        eat(1);
+        try{
+          eat(1);
+        }
+        catch(XMLParseError)
+          {
+            throw XMLParseError("Tried to eat blanks, but data was left.");
+          }
         f=getFirst(1);
       }
 

Modified: antargis/trunk/ext/basic/ag_xml.h
===================================================================
--- antargis/trunk/ext/basic/ag_xml.h	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/ext/basic/ag_xml.h	2008-06-09 18:46:17 UTC (rev 1265)
@@ -32,6 +32,12 @@
 
 #include "ag_debug.h"
 
+struct XMLParseError
+  {
+    XMLParseError(const std::string &p):problem(p){}
+    std::string problem;
+  };
+
 class AGEXPORT Node
   {
   public:
@@ -136,12 +142,12 @@
 
     bool first(const AGString &p) const;
     AGString getFirst(size_t i) const;
-    void eat(size_t i);
+    void eat(size_t i) throw (XMLParseError);
     void push();
     void pop();
     void discard();
     AGString getTil(const AGString &p) const;
-    void eatBlanks();
+    void eatBlanks() throw (XMLParseError);
   };
 
   struct NodeStartInfo

Modified: antargis/trunk/ext/gui/ag_frame.cc
===================================================================
--- antargis/trunk/ext/gui/ag_frame.cc	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/ext/gui/ag_frame.cc	2008-06-09 18:46:17 UTC (rev 1265)
@@ -2,15 +2,15 @@
 #include "ag_screen.h"
 #include "ag_debug.h"
 
-AGFrame::AGFrame(AGWidget *pParent,const AGRect2 &pRect,size_t pWidth):AGWidget(pParent,pRect),
-mWidth(pWidth),mBorder(0),mTexture((int)width(),(int)height())
+AGFrame::AGFrame(AGWidget *pParent,const AGRect2 &pRect,size_t pWidth,size_t pWidthH):AGWidget(pParent,pRect),
+mWidth(pWidth),mBorder(0),mWidthH(pWidthH==0?pWidth:pWidthH),mTexture((int)width(),(int)height())
 {
   mTextureInited=false;
   mUseTexture=true;
   mBg=0;
 }
 AGFrame::AGFrame(AGWidget *pParent,const AGRect2 &pRect,const AGBorder &pBorder):AGWidget(pParent,pRect),
-mWidth(pBorder.getWidth()),mBorder(new AGBorder(pBorder)),mTexture((int)width(),(int)height())
+mWidth(pBorder.getWidth()),mWidthH(pBorder.getWidth()),mBorder(new AGBorder(pBorder)),mTexture((int)width(),(int)height())
 {
   mTextureInited=false;
   mUseTexture=true;
@@ -25,7 +25,7 @@
 
 AGRect2 AGFrame::getClientRect() const
 {
-  return getRect().origin().shrink(mWidth);
+  return getRect().origin().shrink(mWidth,mWidthH);
 }
 
 void AGFrame::prepareDraw()

Modified: antargis/trunk/ext/gui/ag_frame.h
===================================================================
--- antargis/trunk/ext/gui/ag_frame.h	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/ext/gui/ag_frame.h	2008-06-09 18:46:17 UTC (rev 1265)
@@ -10,7 +10,7 @@
 class AGEXPORT AGFrame:public AGWidget
 {
  public:
-  AGFrame(AGWidget *pParent,const AGRect2 &pRect,size_t width); // transparent frame
+  AGFrame(AGWidget *pParent,const AGRect2 &pRect,size_t width,size_t widthH=0); // transparent frame
   AGFrame(AGWidget *pParent,const AGRect2 &pRect,const AGBorder &pBorder);
   ~AGFrame();
 
@@ -20,9 +20,10 @@
 
   void draw(AGPainter &p);
   void prepareDraw();
-
+  
  private:
   size_t mWidth;
+  size_t mWidthH;
   AGBorder *mBorder;
   AGBackground *mBg;
   AGTexture mTexture;

Modified: antargis/trunk/ext/gui/ag_image.cc
===================================================================
--- antargis/trunk/ext/gui/ag_image.cc	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/ext/gui/ag_image.cc	2008-06-09 18:46:17 UTC (rev 1265)
@@ -23,32 +23,32 @@
 
 AGImage::AGImage(AGWidget *pParent,const AGRect2 &r,AGSurface pSurface,bool pTile):
   AGWidget(pParent,r),
-  mTexture(pSurface),mTile(pTile)
-  {
-    mCenter=true;
-    //  CTRACE;
-    /*  if(pRect!=pSurface.getRect() && pRect.w()!=0 && pRect.h()!=0)
+  mTexture(pSurface),mTile(pTile),mScale(false)
+      {
+        mCenter=true;
+        //  CTRACE;
+        /*  if(pRect!=pSurface.getRect() && pRect.w()!=0 && pRect.h()!=0)
     {
       //      mSrcRect=pRect;
 
       setHeight(pRect.h());
       setWidth(pRect.w());
       }*/
-  }
+      }
 AGImage::AGImage(AGWidget *pParent,const AGRect2 &r,AGTexture pTexture,bool pTile):
   AGWidget(pParent,r),
   mTexture(pTexture),mTile(pTile)
-  {
-    mCenter=true;
-    //  CTRACE;
-    /*  if(pRect!=pTexture.getRect() && pRect.w()!=0 && pRect.h()!=0)
+      {
+        mCenter=true;
+        //  CTRACE;
+        /*  if(pRect!=pTexture.getRect() && pRect.w()!=0 && pRect.h()!=0)
     {
       mSrcRect=pRect;
 
       setHeight(pRect.h());
       setWidth(pRect.w());
       }*/
-  }
+      }
 
 
 
@@ -70,11 +70,21 @@
       {
 
         AGRect2 mr=getRect().origin();
+        AGRect2 fr=mTexture.getRect();
 
-        if(mCenter)
+        /*     if(mScale) // disables centering
+          {
+            fr=
+          }
+        else 
+         */         
+        if(mCenter && !mScale)
           mr+=AGVector2((width()-mTexture.width())/2,(height()-mTexture.height())/2);
 
-        p.blit(mTexture,mr);
+        if(mScale)
+          p.blit(mTexture,mr,fr);
+        else
+          p.blit(mTexture,mr);
       }
     else
       p.blit(mTexture,getRect().origin());
@@ -101,3 +111,8 @@
   {
     mCenter=c;
   }
+
+void AGImage::setScale(bool c)
+  {
+    mScale=c;
+  }

Modified: antargis/trunk/ext/gui/ag_image.h
===================================================================
--- antargis/trunk/ext/gui/ag_image.h	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/ext/gui/ag_image.h	2008-06-09 18:46:17 UTC (rev 1265)
@@ -41,10 +41,12 @@
   void useTextures();
 
   void setCenter(bool c);
+  void setScale(bool s);
 
  private:
   AGTexture mTexture;
   bool mTile;
+  bool mScale;
   bool mCenter;
 };
 

Modified: antargis/trunk/ext/gui/ag_layoutcreators.cc
===================================================================
--- antargis/trunk/ext/gui/ag_layoutcreators.cc	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/ext/gui/ag_layoutcreators.cc	2008-06-09 18:46:17 UTC (rev 1265)
@@ -325,6 +325,14 @@
       AGSurface s(0,0);
       if(filename.length())
         s=AGSurface::load(filename);
+      else if(pNode.get("color").length()>0)
+        {
+          AGSurface f(1,1);
+          f.putPixel(0,0,AGColor(pNode.get("color")));
+          s=f;
+        }
+      
+      
 
       AGRect2 r=pRect;
       if(pNode.get("x").length())
@@ -335,12 +343,15 @@
 #warning "add subsurfaces"
 
 
-      AGWidget *w;
+      AGImage *w;
+      
 
       if(pNode.get("tile")=="true")
         w=new AGImage(pParent,r,s,true);
       else
         w=new AGImage(pParent,r,s,false);
+      
+      w->setScale(pNode.get("scale")=="true");
 
       setResult(w);
     }
@@ -359,12 +370,16 @@
       CTRACE;
       AGString border=pNode.get("border");
       size_t width=pNode.get("width").toInt();
+      
+      size_t height=0;
+      if(pNode.get("height").length()>0)
+        height=pNode.get("height").toInt();
 
       AGFrame *w;
       if(border.length())
         w=new AGFrame(pParent,pRect,AGBorder(border));
       else
-        w=new AGFrame(pParent,pRect,width);
+        w=new AGFrame(pParent,pRect,width,height);
 
       setResult(w);
       if(pNode.get("background").length())

Modified: antargis/trunk/ext/gui/ag_table.cc
===================================================================
--- antargis/trunk/ext/gui/ag_table.cc	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/ext/gui/ag_table.cc	2008-06-09 18:46:17 UTC (rev 1265)
@@ -23,7 +23,7 @@
 
 AGTable::AGTable(AGWidget *pWidget,const AGRect2 &pRect):
   AGWidget(pWidget,pRect),
-  w(0),h(0),xw(0),yw(0),mInserted(false)
+  w(0),h(0),xw(0),yw(0),mInserted(false),mRoundPositions(true)
   {
   }
 

Modified: antargis/trunk/ext/gui/ag_table.h
===================================================================
--- antargis/trunk/ext/gui/ag_table.h	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/ext/gui/ag_table.h	2008-06-09 18:46:17 UTC (rev 1265)
@@ -70,6 +70,7 @@
   std::vector<AGWidget*> children;
 
   bool mInserted;
+  bool mRoundPositions;
 };
 
 #endif

Modified: antargis/trunk/ext/gui/ag_widget.cc
===================================================================
--- antargis/trunk/ext/gui/ag_widget.cc	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/ext/gui/ag_widget.cc	2008-06-09 18:46:17 UTC (rev 1265)
@@ -1283,10 +1283,7 @@
   AGRect2 m=p;
 
   if(mUseClientRect)
-    {
-      cdebug(mClientProj.getMatrix());
       m=mClientProj.inverse().project(m);
-    }
   return m-getRect().getV0();
 }
 AGVector2 AGWidget::outerToInner(const AGVector2 &p) const

Modified: antargis/trunk/ext/video/ag_gltexture.cc
===================================================================
--- antargis/trunk/ext/video/ag_gltexture.cc	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/ext/video/ag_gltexture.cc	2008-06-09 18:46:17 UTC (rev 1265)
@@ -33,7 +33,6 @@
   {
     while(value!=0)
       {
-        cdebug(value);
         if(value&1)
           {
             if((value^1))

Modified: antargis/trunk/main/starter.cc
===================================================================
--- antargis/trunk/main/starter.cc	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/main/starter.cc	2008-06-09 18:46:17 UTC (rev 1265)
@@ -59,7 +59,7 @@
         s=truncReverseUntil(s,sep);
 
         argv[1]=new char[s.length()+100];
-        strcpy(argv[1],(s+sep+"antargis").c_str());
+        strcpy(argv[1],(s+sep+"antargisStarter.rb").c_str());
         argc=2;
       }
 

Modified: antargis/trunk/ruby/editor/campaign/drag_grid.rb
===================================================================
--- antargis/trunk/ruby/editor/campaign/drag_grid.rb	2008-06-06 18:33:45 UTC (rev 1264)
+++ antargis/trunk/ruby/editor/campaign/drag_grid.rb	2008-06-09 18:46:17 UTC (rev 1265)
@@ -118,7 +118,7 @@
     @registered=false
     @running=false
     @duration=node["duration"].to_f
-    run
+    #run
   end
   def draw(p)
     if @registered==false
@@ -165,6 +165,20 @@
   end
 end
 
+class HideEffect<Effect
+  def initialize(p,r,node)
+    super
+    @name=node["name"]
+    @target=node["table"]
+    @row=node["row"].to_i
+    @size=50
+    
+  end
+  def step(amount)
+    table=getApp.getMainWidget.getChild(@target)
+    table.modifyRow(@row,(1-amount)*@size)
+  end
+end
 
 class AGHoverWidget<AGWidget
   attr_accessor :hoverBorder
@@ -228,7 +242,9 @@
 end
 
 module DragObject
-  
+  def canFocus
+    false
+  end
 end
 
 class DragBox<AGHoverWidget
@@ -267,7 +283,6 @@
   end
   def eventDragBy(e,v)
     super
-    p "DRAGGIGN #{v}"
     if @dragging
       setRect(getRect+v)
       return true
@@ -369,6 +384,9 @@
 
 class DragLine<AGWidget
   include Arrows
+  
+  attr_accessor :selected, :text
+  
   def initialize(p,r,startObject)
     super(p,r)
     @startObject=startObject
@@ -377,6 +395,7 @@
     @@font||=AGFont.new("FreeSans.ttf",14)
     @@font.setColor(AGColor.new(0,0,0))
     @hovered=false
+    @text=AGStringUtf8.new("none")
   end
     
   def getPos(obj)
@@ -390,9 +409,7 @@
     else
       endP=@pos
     end
-    #endP=@pos unless @endObject
-    #endP=getPos(@endObject) if @endObject
-    
+   
     if @endObject and @startObject
       if @moving==false and (@endObject.visible==false or @startObject.visible==false)
         hide
@@ -402,11 +419,10 @@
     white=AGColor.new(0xFF,0xFF,0x88) if @hovered
     black=AGColor.new(0,0,0)
     p.setLineWidth(1)
-    p "---",startP,endP,"_--"
     p.drawArrow(startP,endP,5,white,black)
     middle=(endP+startP)*0.5
     
-    p.renderText(AGStringUtf8.new("MUH"),middle,@@font)
+    p.renderText(AGStringUtf8.new(@text),middle,@@font)
   end
   
   def eventDragBy(e,v)
@@ -438,6 +454,7 @@
   end
   def eventMouseButtonDown(e)
     r=super
+    
     if @endObject.nil?
       @moving=true
       @pos=e.getMousePosition+(getRect.getV0-getScreenRect.getV0)
@@ -445,8 +462,10 @@
       if @hovered
         @endObject=nil
         @moving=true
+        r=true
       end
     end    
+    getDragGrid.select(self) if getDragGrid
     r
   end
   def eventMouseButtonUp(e)
@@ -562,6 +581,10 @@
       @selected.selected=true
       checkEdit    
       @edit.setText(@selected.text)
+      @edit.gainFocus
+      getApp.getEffect("showEdit").run
+    else
+      getApp.getEffect("hideEdit").run
     end
   end
 
@@ -573,6 +596,10 @@
     p.fillRect(getRect, at bgColor)
     @lines.each{|l|p.drawLine(l.getV0,l.getV1, at borderColor)}
   end
+  
+  def eventMouseButtonDown(e)
+    return super
+  end
       
 private
   def cellCountX
@@ -636,8 +663,6 @@
       o.setName("DRAG")
       o.setButtonDown(true,e.getMousePosition)
       o.startDragging
-      #letChildProcess(o,e)
-      #o.eventMouseButtonDown(e)
       return true
     end
     
@@ -659,7 +684,7 @@
 end
 
 
-[DragGrid,DragSource,DragTrash,DragEnvironment,ToolBar,ToolButton,AppearEffect].each{|c|standardLayoutCreator(c)}
+[DragGrid,DragSource,DragTrash,DragEnvironment,ToolBar,ToolButton,AppearEffect,HideEffect].each{|c|standardLayoutCreator(c)}
 
 class RubySignal
   def initialize(name)
@@ -703,8 +728,6 @@
       @grid=layout.getChild("dragGrid")
       addHandler(env,:sigClick,:eventDeselect)
     end
-    
-    
   end
   def eventDeselect
     @grid.select(nil) if @grid
@@ -713,6 +736,8 @@
     sigFrame(t)
     super
   end
-  
+  def getEffect(name)
+    @layout.getChild(name)
+  end
 end
 



From davidkamphausen at mail.berlios.de  Mon Jun  9 20:55:34 2008
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Mon, 9 Jun 2008 20:55:34 +0200
Subject: [Antargis-svn] r1266 - antargis/trunk/rookey
Message-ID: <200806091855.m59ItYwJ016178@sheep.berlios.de>

Author: davidkamphausen
Date: 2008-06-09 20:55:34 +0200 (Mon, 09 Jun 2008)
New Revision: 1266

Modified:
   antargis/trunk/rookey/config_generator.rb
Log:
Complete - task 45: Check clipping when hovering 
http://localhost:3000/issues/show/45
Incomplete - task 11: Campaign editor 
http://localhost:3000/issues/show/11

Modified: antargis/trunk/rookey/config_generator.rb
===================================================================
--- antargis/trunk/rookey/config_generator.rb	2008-06-09 18:46:17 UTC (rev 1265)
+++ antargis/trunk/rookey/config_generator.rb	2008-06-09 18:55:34 UTC (rev 1266)
@@ -109,6 +109,7 @@
     end
     def getEnvPath
       p=ENV["PATH"]
+      pp p
       if File.join("a","b")=~/\\/
         p.split(";")
       else



From davidkamphausen at mail.berlios.de  Mon Jun  9 20:59:40 2008
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Mon, 9 Jun 2008 20:59:40 +0200
Subject: [Antargis-svn] r1267 - antargis/trunk
Message-ID: <200806091859.m59IxeP7016587@sheep.berlios.de>

Author: davidkamphausen
Date: 2008-06-09 20:59:40 +0200 (Mon, 09 Jun 2008)
New Revision: 1267

Modified:
   antargis/trunk/Rakefile
Log:
Complete - task 45: Check clipping when hovering 
http://localhost:3000/issues/show/45
Incomplete - task 11: Campaign editor 
http://localhost:3000/issues/show/11

Modified: antargis/trunk/Rakefile
===================================================================
--- antargis/trunk/Rakefile	2008-06-09 18:55:34 UTC (rev 1266)
+++ antargis/trunk/Rakefile	2008-06-09 18:59:40 UTC (rev 1267)
@@ -50,7 +50,7 @@
 end
 
 desc "Task for cruisecontrol.rb"
-  task :cruise => :spec do
+  task :cruise => [:clean,:spec] do
 end
 
 



From davidkamphausen at mail.berlios.de  Tue Jun 10 21:22:34 2008
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Tue, 10 Jun 2008 21:22:34 +0200
Subject: [Antargis-svn] r1268 - in antargis/trunk: . data
	data/gui/layout/editor/campaign ext/basic ext/gui ext/video
	rookey ruby/editor/campaign
Message-ID: <200806101922.m5AJMY8R025076@sheep.berlios.de>

Author: davidkamphausen
Date: 2008-06-10 21:22:29 +0200 (Tue, 10 Jun 2008)
New Revision: 1268

Modified:
   antargis/trunk/Rakefile
   antargis/trunk/data/gui/layout/editor/campaign/main.xml
   antargis/trunk/data/theme.xml
   antargis/trunk/ext/basic/ag_fs.h
   antargis/trunk/ext/basic/ag_geometry.cc
   antargis/trunk/ext/basic/ag_geometry.h
   antargis/trunk/ext/gui/ag_background.cc
   antargis/trunk/ext/gui/ag_border.cc
   antargis/trunk/ext/gui/ag_frame.cc
   antargis/trunk/ext/gui/ag_frame.h
   antargis/trunk/ext/video/ag_glpainter.cc
   antargis/trunk/ext/video/ag_glpainter.h
   antargis/trunk/ext/video/ag_glscreen.cc
   antargis/trunk/ext/video/ag_glscreen.h
   antargis/trunk/ext/video/ag_projection.cc
   antargis/trunk/ext/video/ag_projection.h
   antargis/trunk/ext/video/ag_surface.cc
   antargis/trunk/ext/video/ag_surface.h
   antargis/trunk/rookey/config_generator.rb
   antargis/trunk/ruby/editor/campaign/drag_grid.rb
Log:
Incomplete - task 11: Campaign editor 
http://localhost:3000/issues/show/11

Modified: antargis/trunk/Rakefile
===================================================================
--- antargis/trunk/Rakefile	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/Rakefile	2008-06-10 19:22:29 UTC (rev 1268)
@@ -67,7 +67,7 @@
 
     spec_filename = "spec_#{file_name}.rb"
     specs = Dir["ruby/**/#{spec_filename}"]
-    pp specs
+    #pp specs
     
     if path = specs.detect { |f| spec_filename == File.basename(f) }
       run_file_name = path

Modified: antargis/trunk/data/gui/layout/editor/campaign/main.xml
===================================================================
--- antargis/trunk/data/gui/layout/editor/campaign/main.xml	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/data/gui/layout/editor/campaign/main.xml	2008-06-10 19:22:29 UTC (rev 1268)
@@ -1,94 +1,104 @@
 <?xml version="1.0"?>
 <layout name="CampaignEditorLayout">
-<dragEnvironment name="dragEnvironment">
-<table cols="1" rows="2">
-  <rowsize row="0" fixed="50"/>
+
+  <dragEnvironment name="dragEnvironment">
+    <table cols="1" rows="2">
+      <rowsize row="0" fixed="50"/>
   
-  <cell col="0" row="0">
-    <toolBar name="toolbar">
-         <toolButton text="Save" name="save" caption="muh" caption-image="gui/save.png"/>
-         <toolButton text="Load" name="load" caption="muh" caption-image="gui/load.png"/>
-    </toolBar>
-  </cell>
+      <cell col="0" row="0">
+        <toolBar name="toolbar">
+          <toolButton text="Save" name="save" caption="muh" caption-image="gui/save.png"/>
+          <toolButton text="Load" name="load" caption="muh" caption-image="gui/load.png"/>
+        </toolBar>
+      </cell>
   
-  <cell col="0" row="1">
-  <table cols="2" rows="2" name="bigTable">
-    <colsize col="0" fixed="100"/>
-    <rowsize row="1" fixed="50"/>
+      <cell col="0" row="1">
+        <table cols="2" rows="2" name="bigTable">
+          <colsize col="0" fixed="100"/>
+          <rowsize row="1" fixed="50"/>
     
-    <cell col="0" row="0">
-      <table cols="1" rows="4">
-        <rowsize row="0" fixed="100"/>
-        <rowsize row="1" fixed="100"/>
-        <rowsize row="2" fixed="100"/>
-        <cell col="0" row="0">
-          <dragSource name="levelSource" class="DragBox" text="Level"/>
-        </cell>
+          <cell col="0" row="0">
+            <table cols="1" rows="4">
+              <rowsize row="0" fixed="100"/>
+              <rowsize row="1" fixed="100"/>
+              <rowsize row="2" fixed="100"/>
+              <cell col="0" row="0">
+                <dragSource name="levelSource" class="DragBox" text="Level"/>
+              </cell>
         
-        <cell col="0" row="1">
-          <dragSource name ="storySource" class="DragBoxStory" text="Story"/>
-        </cell>
-        <cell col="0" row="2">
-          <dragTrash/>
-        </cell>
+              <cell col="0" row="1">
+                <dragSource name ="storySource" class="DragBoxStory" text="Story"/>
+              </cell>
+              <cell col="0" row="2">
+                <dragTrash/>
+              </cell>
         
-      </table>
-    </cell>
+            </table>
+          </cell>
     
     
-    <cell col="1" row="0">
-      <scrollingWidget clientRect="(0,0,1600,1024)">
-        <dragGrid name="dragGrid" cellWidth="100" hoverColor='#9999FF' edit="textEdit"/>
-      </scrollingWidget>
-    </cell>
+          <cell col="1" row="0">
+            <scrollingWidget clientRect="(0,0,1600,1024)">
+              <dragGrid name="dragGrid" cellWidth="100" hoverColor='#9999FF' edit="textEdit"/>
+            </scrollingWidget>
+          </cell>
     
     
     
-    <cell col="1" row="1" name="a">
-      <table cols="2" rows="1" name="b">
-        <colsize col="1" fixed="50"/>
-        <cell col="0" row="0">
-          <edit name="textEdit"/>
-        </cell>
-        <cell col="1" row="0">
-          <button name="weiter" caption-image="data/gui/options.png"/>
-        </cell>
-      </table>
-    </cell>
+          <cell col="1" row="1" name="a">
+            <table cols="2" rows="1" name="b">
+              <colsize col="1" fixed="50"/>
+              <cell col="0" row="0">
+                <edit name="textEdit"/>
+              </cell>
+              <cell col="1" row="0">
+                <button name="weiter" caption-image="data/gui/options.png"/>
+              </cell>
+            </table>
+          </cell>
     
-  </table>
-  </cell>
-  </table>
-  <appearEffect name="showEdit" table="bigTable" row="1" size="40" duration="0.2"/>
-  <hideEffect name="hideEdit" table="bigTable" row="1" size="40" duration="0.2"/>
-</dragEnvironment>
-   <image filename="" tile="true" color="#00000099"/>
+        </table>
+      </cell>
+    </table>
+    <appearEffect name="showEdit" table="bigTable" row="1" size="40" duration="0.2"/>
+    <hideEffect name="hideEdit" table="bigTable" row="1" size="40" duration="0.2"/>
+  </dragEnvironment>
 
+
   <frame width="150" height="70">
-    <frame border="button.border.normal">
-      <image filename="" tile="true" color="#000000FF"/>
-      <table rows="2" cols="1">
-        <rowsize row="0" relative="3"/>
+    <window>
+      <table rows="3" cols="1">
+        <rowsize row="0" relative="0.7"/>
+        <rowsize row="1" relative="3"/>
         <cell col="0" row="0">
+          <imageList/>
+        </cell>
+        <cell col="0" row="1">
           <frame width="20">
             <image filename="data/gui/map1.png" scale="true"/>
           </frame>
         </cell>
-        <cell col="0" row="1">
+        <cell col="0" row="2">
           <table rows="1" cols="3">
             <colsize col="1" relative="8"/>
             <cell col="1" row="0">
-              <edit text="caption"/>
+              <frame width="5">
+                <edit text="caption" multi="true"/>
+              </frame>
             </cell>
             <cell col="0" row="0">
-              <button caption="Back"/>
+              <frame width="10" height="40">
+                <button caption-image="data/gui/arrow_left.png"/>
+              </frame>
             </cell>
             <cell col="2" row="0">
-              <button caption="Next"/>
+              <frame width="10" height="40">
+                <button caption-image="data/gui/arrow_right.png"/>
+              </frame>
             </cell>
           </table>
         </cell>
       </table>
-    
+    </window>
   </frame>
 </layout>
\ No newline at end of file

Modified: antargis/trunk/data/theme.xml
===================================================================
--- antargis/trunk/data/theme.xml	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/data/theme.xml	2008-06-10 19:22:29 UTC (rev 1268)
@@ -183,13 +183,15 @@
 	
 	<edit>
 		<background>
-					<color name='gradientColor1' color='#54555b'/>
+      <color name="color" color='#11111144'/>
+<!-- 					<color name='gradientColor1' color='#54555b'/>
 					<color name='gradientColor2' color='#3c3d41'/>
 					<color name='gradientColor3' color='#3c3d41'/>
-					<color name='gradientColor4' color='#12141c'/>
-<!--			<image name="image" file="bg_tile2.png"/>-->
+					<color name='gradientColor4' color='#12141c'/> -->
+			<!--  <image name="image" file="data/gui/bg_tile2.png"/>-->
 		</background>
-		<font name="font" file="FreeSans.ttf" size="14" color="#000000"/>
+    <!-- <font name="font" file="FreeSans.ttf" size="14" color="#000000"/> -->
+    <font name="font" file="FreeSans.ttf" size="14" color="#E7E7FF"/>
 	</edit>
 <!--
 	<screen>

Modified: antargis/trunk/ext/basic/ag_fs.h
===================================================================
--- antargis/trunk/ext/basic/ag_fs.h	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/basic/ag_fs.h	2008-06-10 19:22:29 UTC (rev 1268)
@@ -28,6 +28,12 @@
 
 #include <ag_base.h>
 
+struct FileNotFound
+  {
+    FileNotFound(const std::string &f):filename(f){}
+    std::string filename;
+  };
+
 AGEXPORT void initFS(const char *argv0);
 AGEXPORT AGString loadFile(const AGString &pFilename);
 AGEXPORT bool saveFile(const AGString &pFilename,const AGString &pContent);

Modified: antargis/trunk/ext/basic/ag_geometry.cc
===================================================================
--- antargis/trunk/ext/basic/ag_geometry.cc	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/basic/ag_geometry.cc	2008-06-10 19:22:29 UTC (rev 1268)
@@ -1443,8 +1443,27 @@
   return v0!=r.v0 || v1!=r.v1;
 }
 
+std::vector<AGRect2> AGRect2::tile(size_t x,size_t y) const
+{
+  std::vector<AGRect2> l;
+  
+  if(x==0 || y==0)
+  return l;
+  
+  float w=width()/x;
+  float h=height()/y;
+  
+  for(size_t i=0;i<x;i++)
+    for(size_t j=0;j<y;j++)
+      {
+        l.push_back(AGRect2(x0()+w*i,y0()+h*j,w,h));
+      }
+  
+  return l;
+}
 
 
+
 SDL_Rect AGRect2::sdl() const
 {
   SDL_Rect r;

Modified: antargis/trunk/ext/basic/ag_geometry.h
===================================================================
--- antargis/trunk/ext/basic/ag_geometry.h	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/basic/ag_geometry.h	2008-06-10 19:22:29 UTC (rev 1268)
@@ -504,6 +504,7 @@
 
     //result=this-r
     std::vector<AGRect2> difference(const AGRect2 &r) const;
+    std::vector<AGRect2> tile(size_t x,size_t y) const;
 
     SDL_Rect sdl() const;
 

Modified: antargis/trunk/ext/gui/ag_background.cc
===================================================================
--- antargis/trunk/ext/gui/ag_background.cc	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/gui/ag_background.cc	2008-06-10 19:22:29 UTC (rev 1268)
@@ -29,15 +29,15 @@
     @param pColor an rgba-color. so you can use transparent backgrounds,too.
  */
 AGBackground::AGBackground(const AGColor &pColor):mTexture(0)
-{
-  //  CTRACE;
-  mColor=true;
-  mColors[0]=pColor;
-  mColors[1]=pColor;
-  mColors[2]=pColor;
-  mColors[3]=pColor;
-  mBorder=0;
-}
+  {
+    //  CTRACE;
+    mColor=true;
+    mColors[0]=pColor;
+    mColors[1]=pColor;
+    mColors[2]=pColor;
+    mColors[3]=pColor;
+    mBorder=0;
+  }
 
 
 /**
@@ -58,29 +58,37 @@
  */
 
 AGBackground::AGBackground(const AGString &pThemeName):mTexture(0)
-{
-  //  CTRACE;
+  {
+    //  CTRACE;
 
-  AGTheme *theme=getTheme();
-  mColor=false;
-  if(theme->hasSurface(pThemeName+".image"))
-    {
-      //      CTRACE;
-      cdebug(pThemeName+".image");
-      mTexture=&getTextureCache()->get(getTheme()->getSurfaceName(pThemeName+".image"));
-      //mTexture=new AGTexture(theme->getSurface(pThemeName+".image"));
-    }
-  else if(theme->hasColor(pThemeName+"."+"gradientColor1"))
-    {
-      mColor=true;
-      mColors[0]=theme->getColor(pThemeName+"."+"gradientColor1");
-      mColors[1]=theme->getColor(pThemeName+"."+"gradientColor2");
-      mColors[2]=theme->getColor(pThemeName+"."+"gradientColor3");
-      mColors[3]=theme->getColor(pThemeName+"."+"gradientColor4");
-    }
+    AGTheme *theme=getTheme();
+    mColor=false;
+    if(theme->hasSurface(pThemeName+".image"))
+      {
+        //      CTRACE;
+        cdebug(pThemeName+".image");
+        mTexture=&getTextureCache()->get(getTheme()->getSurfaceName(pThemeName+".image"));
+        //mTexture=new AGTexture(theme->getSurface(pThemeName+".image"));
+      }
+    else if(theme->hasColor(pThemeName+"."+"gradientColor1"))
+      {
+        mColor=true;
+        mColors[0]=theme->getColor(pThemeName+"."+"gradientColor1");
+        mColors[1]=theme->getColor(pThemeName+"."+"gradientColor2");
+        mColors[2]=theme->getColor(pThemeName+"."+"gradientColor3");
+        mColors[3]=theme->getColor(pThemeName+"."+"gradientColor4");
+      }
+    else if(theme->hasColor(pThemeName+"."+"color"))
+      {
+        mColor=true;
+        mColors[0]=theme->getColor(pThemeName+"."+"color");
+        mColors[1]=theme->getColor(pThemeName+"."+"color");
+        mColors[2]=theme->getColor(pThemeName+"."+"color");
+        mColors[3]=theme->getColor(pThemeName+"."+"color");
+      }
 
-  mBorder=theme->getInt(pThemeName+"."+"border");
-}
+    mBorder=theme->getInt(pThemeName+"."+"border");
+  }
 
 /// draws the background on painter in the given rectangle
 void AGBackground::draw(const AGRect2 &r,AGPainter &p)

Modified: antargis/trunk/ext/gui/ag_border.cc
===================================================================
--- antargis/trunk/ext/gui/ag_border.cc	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/gui/ag_border.cc	2008-06-10 19:22:29 UTC (rev 1268)
@@ -81,25 +81,7 @@
 
     float x2=d.x1();
     float y2=d.y1();
-    /*
-  // corners
-  p.blit(*mTexture,AGRect2(0,0,w,w),AGRect2(0,0,w,w));
 
-  p.blit(*mTexture,AGRect2(0,y2-w,w,w),AGRect2(0,w2,w,w));
-
-  p.blit(*mTexture,AGRect2(x2-w,0,w,w),AGRect2(w2,0,w,w));
-
-  p.blit(*mTexture,AGRect2(x2-w,y2-w,w,w),AGRect2(w2,w2,w,w));
-
-  // borders
-
-  // hor
-  p.tile(*mTexture,AGRect2(w,0,d.w()-w2,w),AGRect2(w,0,w,w));
-  p.tile(*mTexture,AGRect2(w,y2-w,d.w()-w2,w),AGRect2(w,w2,w,w));
-  // ver
-  p.tile(*mTexture,AGRect2(0,w,w,d.h()-w2),AGRect2(0,w,w,w));
-  p.tile(*mTexture,AGRect2(x2-w,w,w,d.h()-w2),AGRect2(w2,w,w,w));
-     */
     // skip interior
 
 

Modified: antargis/trunk/ext/gui/ag_frame.cc
===================================================================
--- antargis/trunk/ext/gui/ag_frame.cc	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/gui/ag_frame.cc	2008-06-10 19:22:29 UTC (rev 1268)
@@ -3,7 +3,7 @@
 #include "ag_debug.h"
 
 AGFrame::AGFrame(AGWidget *pParent,const AGRect2 &pRect,size_t pWidth,size_t pWidthH):AGWidget(pParent,pRect),
-mWidth(pWidth),mBorder(0),mWidthH(pWidthH==0?pWidth:pWidthH),mTexture((int)width(),(int)height())
+mWidth(pWidth),mBorder(0),mWidthH(pWidthH<0?pWidth:pWidthH),mTexture((int)width(),(int)height())
 {
   mTextureInited=false;
   mUseTexture=true;

Modified: antargis/trunk/ext/gui/ag_frame.h
===================================================================
--- antargis/trunk/ext/gui/ag_frame.h	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/gui/ag_frame.h	2008-06-10 19:22:29 UTC (rev 1268)
@@ -10,7 +10,7 @@
 class AGEXPORT AGFrame:public AGWidget
 {
  public:
-  AGFrame(AGWidget *pParent,const AGRect2 &pRect,size_t width,size_t widthH=0); // transparent frame
+  AGFrame(AGWidget *pParent,const AGRect2 &pRect,size_t width,size_t widthH=-1); // transparent frame
   AGFrame(AGWidget *pParent,const AGRect2 &pRect,const AGBorder &pBorder);
   ~AGFrame();
 
@@ -22,8 +22,8 @@
   void prepareDraw();
   
  private:
-  size_t mWidth;
-  size_t mWidthH;
+  int mWidth;
+  int mWidthH;
   AGBorder *mBorder;
   AGBackground *mBg;
   AGTexture mTexture;

Modified: antargis/trunk/ext/video/ag_glpainter.cc
===================================================================
--- antargis/trunk/ext/video/ag_glpainter.cc	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/video/ag_glpainter.cc	2008-06-10 19:22:29 UTC (rev 1268)
@@ -26,36 +26,37 @@
 #include "ag_rendercontext.h"
 #include "ag_debug.h"
 #include "ag_vdebug.h"
+#include "ag_projection.h"
 
 namespace AGGLPainter
-{
-  void glColor(const AGColor &c)
-    {
-      glColor4f(c.r/255.0,c.g/255.0,c.b/255.0,c.a/255.0);
-    }
-  
-  void fillPoly(const std::vector<AGVector2> &pVecs,const AGColor &pColor)
-    {
-      STACKTRACE;
+  {
+    void glColor(const AGColor &c)
+      {
+        glColor4f(c.r/255.0,c.g/255.0,c.b/255.0,c.a/255.0);
+      }
 
-      AGRenderContext context;
-      context.setColor(pColor);
-      context.setCulling(false);
-      context.setAlpha(0,GL_NONE);
-      context.setDepthTest(false);
-      context.begin();
+    void fillPoly(const std::vector<AGVector2> &pVecs,const AGColor &pColor)
+      {
+        STACKTRACE;
 
-      // turned
-      glBegin(GL_POLYGON);
-      for(std::vector<AGVector2>::const_iterator i=pVecs.begin();i!=pVecs.end();i++)
-        {
-          glVertex2fv(*i);
-        }
-      glEnd();
-      
-    } 
-  
-  void drawPoly(const std::vector<AGVector2> &pVecs,const AGColor &pColor,float pWidth)
+        AGRenderContext context;
+        context.setColor(pColor);
+        context.setCulling(false);
+        context.setAlpha(0,GL_NONE);
+        context.setDepthTest(false);
+        context.begin();
+
+        // turned
+        glBegin(GL_POLYGON);
+        for(std::vector<AGVector2>::const_iterator i=pVecs.begin();i!=pVecs.end();i++)
+          {
+            glVertex2fv(*i);
+          }
+        glEnd();
+
+      } 
+
+    void drawPoly(const std::vector<AGVector2> &pVecs,const AGColor &pColor,float pWidth)
       {
         STACKTRACE;
 
@@ -74,279 +75,279 @@
             glVertex2fv(*i);
           }
         glEnd();
-        
+
       }
 
-  void blit(const AGTexture &pSource,const AGRect2 &pRect,const AGRect2 &pSrc,const AGColor &pColor)
-    {
-      STACKTRACE;
+    void blit(const AGTexture &pSource,const AGRect2 &pRect,const AGRect2 &pSrc,const AGColor &pColor)
+      {
+        STACKTRACE;
 
-      float tw=pSource.getTextureWidth();
-      float th=pSource.getTextureHeight();
+        float tw=pSource.getTextureWidth();
+        float th=pSource.getTextureHeight();
 
-      AGRect2 s(pSrc.x()/tw,pSrc.y()/th,pSrc.w()/tw,pSrc.h()/th);
+        AGRect2 s(pSrc.x()/tw,pSrc.y()/th,pSrc.w()/tw,pSrc.h()/th);
 
 
-      AGRenderContext context;
-      context.setCulling(false);
-      context.setTexture(const_cast<AGTexture&>(pSource).glTexture());
-      context.setDepthTest(false);
-      if(pColor.a>0)
-        context.setColor(pColor);
-      context.begin();
+        AGRenderContext context;
+        context.setCulling(false);
+        context.setTexture(const_cast<AGTexture&>(pSource).glTexture());
+        context.setDepthTest(false);
+        if(pColor.a>0)
+          context.setColor(pColor);
+        context.begin();
 
-      glBegin(GL_QUADS);
-      glTexCoord2fv(s.getV0());
-      glVertex2fv(pRect.getV0());
+        glBegin(GL_QUADS);
+        glTexCoord2fv(s.getV0());
+        glVertex2fv(pRect.getV0());
 
-      glTexCoord2fv(s.getV10());
-      glVertex2fv(pRect.getV10());
+        glTexCoord2fv(s.getV10());
+        glVertex2fv(pRect.getV10());
 
-      glTexCoord2fv(s.getV1());
-      glVertex2fv(pRect.getV1());
+        glTexCoord2fv(s.getV1());
+        glVertex2fv(pRect.getV1());
 
-      glTexCoord2fv(s.getV01());
-      glVertex2fv(pRect.getV01());
-      glEnd();
+        glTexCoord2fv(s.getV01());
+        glVertex2fv(pRect.getV01());
+        glEnd();
 
-    }
+      }
 
 
-  void blit(const AGTexture &pSource,const std::vector<std::pair<AGRect2,AGRect2> > &pSrcDestRects,const AGColor &pColor)
-    {
-      STACKTRACE;
+    void blit(const AGTexture &pSource,const std::vector<std::pair<AGRect2,AGRect2> > &pSrcDestRects,const AGColor &pColor)
+      {
+        STACKTRACE;
 
-      float tw=pSource.getTextureWidth();
-      float th=pSource.getTextureHeight();
+        float tw=pSource.getTextureWidth();
+        float th=pSource.getTextureHeight();
 
-      float itw=1.0/tw;
-      float ith=1.0/th;
+        float itw=1.0/tw;
+        float ith=1.0/th;
 
-      AGRenderContext context;
-      context.setCulling(false);
-      context.setTexture(const_cast<AGTexture&>(pSource).glTexture());
-      context.setDepthTest(false);
-      if(pColor.a>0)
-        context.setColor(pColor);
-      context.begin();
+        AGRenderContext context;
+        context.setCulling(false);
+        context.setTexture(const_cast<AGTexture&>(pSource).glTexture());
+        context.setDepthTest(false);
+        if(pColor.a>0)
+          context.setColor(pColor);
+        context.begin();
 
-      glBegin(GL_QUADS);
-      for(std::vector<std::pair<AGRect2,AGRect2> >::const_iterator i=pSrcDestRects.begin();i!=pSrcDestRects.end();i++)
-        {
-          AGRect2 s(i->first.x()*itw,i->first.y()*ith,i->first.w()*itw,i->first.h()*ith);
-          AGRect2 d(i->second);
+        glBegin(GL_QUADS);
+        for(std::vector<std::pair<AGRect2,AGRect2> >::const_iterator i=pSrcDestRects.begin();i!=pSrcDestRects.end();i++)
+          {
+            AGRect2 s(i->first.x()*itw,i->first.y()*ith,i->first.w()*itw,i->first.h()*ith);
+            AGRect2 d(i->second);
 
-          glTexCoord2fv(s.getV0());
-          glVertex2fv(d.getV0());
+            glTexCoord2fv(s.getV0());
+            glVertex2fv(d.getV0());
 
-          glTexCoord2fv(s.getV10());
-          glVertex2fv(d.getV10());
+            glTexCoord2fv(s.getV10());
+            glVertex2fv(d.getV10());
 
-          glTexCoord2fv(s.getV1());
-          glVertex2fv(d.getV1());
+            glTexCoord2fv(s.getV1());
+            glVertex2fv(d.getV1());
 
-          glTexCoord2fv(s.getV01());
-          glVertex2fv(d.getV01());
-        }
-      glEnd();
-    }
+            glTexCoord2fv(s.getV01());
+            glVertex2fv(d.getV01());
+          }
+        glEnd();
+      }
 
 
-  void tile(const AGTexture &pSource,const AGRect2 &pTarget,const AGColor &pColor)
-    {
-      STACKTRACE;
-      AGRenderContext context;
-      context.setCulling(false);
-      context.setTexture(const_cast<AGTexture&>(pSource).glTexture());
-      context.setDepthTest(false);
-      if(pColor.a>0)
-        context.setColor(pColor);
-      context.begin();
+    void tile(const AGTexture &pSource,const AGRect2 &pTarget,const AGColor &pColor)
+      {
+        STACKTRACE;
+        AGRenderContext context;
+        context.setCulling(false);
+        context.setTexture(const_cast<AGTexture&>(pSource).glTexture());
+        context.setDepthTest(false);
+        if(pColor.a>0)
+          context.setColor(pColor);
+        context.begin();
 
-      AGRect2 s(0,0,float(pTarget.width())/pSource.width(),float(pTarget.height())/pSource.height());
+        AGRect2 s(0,0,float(pTarget.width())/pSource.width(),float(pTarget.height())/pSource.height());
 
-      glBegin(GL_QUADS);
-      glTexCoord2fv(s.getV0());
-      glVertex2fv(pTarget.getV0());
+        glBegin(GL_QUADS);
+        glTexCoord2fv(s.getV0());
+        glVertex2fv(pTarget.getV0());
 
-      glTexCoord2fv(s.getV10());
-      glVertex2fv(pTarget.getV10());
+        glTexCoord2fv(s.getV10());
+        glVertex2fv(pTarget.getV10());
 
-      glTexCoord2fv(s.getV1());
-      glVertex2fv(pTarget.getV1());
+        glTexCoord2fv(s.getV1());
+        glVertex2fv(pTarget.getV1());
 
-      glTexCoord2fv(s.getV01());
-      glVertex2fv(pTarget.getV01());
+        glTexCoord2fv(s.getV01());
+        glVertex2fv(pTarget.getV01());
 
 
-      glEnd();
-    }
+        glEnd();
+      }
 
 
-  void fillRect(const AGRect2 &pRect,const AGColor &c)
-    {
-      STACKTRACE;
+    void fillRect(const AGRect2 &pRect,const AGColor &c)
+      {
+        STACKTRACE;
 
-      AGRenderContext context;
-      context.setColor(c);
-      context.setCulling(false);
-      context.setAlpha(0,GL_NONE);
-      context.setDepthTest(false);
-      context.begin();
+        AGRenderContext context;
+        context.setColor(c);
+        context.setCulling(false);
+        context.setAlpha(0,GL_NONE);
+        context.setDepthTest(false);
+        context.begin();
 
-      // turned
-      glBegin(GL_QUADS);
+        // turned
+        glBegin(GL_QUADS);
 
-      glVertex2fv(pRect.getV0());
-      glVertex2fv(pRect.getV10());
-      glVertex2fv(pRect.getV1());
-      glVertex2fv(pRect.getV01());
-      glEnd();
-    }
+        glVertex2fv(pRect.getV0());
+        glVertex2fv(pRect.getV10());
+        glVertex2fv(pRect.getV1());
+        glVertex2fv(pRect.getV01());
+        glEnd();
+      }
 
-  void fillRects(const std::vector<std::pair<AGRect2,AGVector4> > &pRects)
-    {
-      STACKTRACE;
+    void fillRects(const std::vector<std::pair<AGRect2,AGVector4> > &pRects)
+      {
+        STACKTRACE;
 
-      AGRenderContext context;
-      context.setColor(AGColor(0,0,0));
-      context.setCulling(false);
-      context.setAlpha(0,GL_NONE);
-      context.setDepthTest(false);
-      context.begin();
+        AGRenderContext context;
+        context.setColor(AGColor(0,0,0));
+        context.setCulling(false);
+        context.setAlpha(0,GL_NONE);
+        context.setDepthTest(false);
+        context.begin();
 
-      //    float x0,y0,x1,y1;
-      // turned
-      glBegin(GL_QUADS);
-      for(std::vector<std::pair<AGRect2,AGVector4> >::const_iterator i=pRects.begin();i!=pRects.end();++i)
-        {
-          glColor4fv(i->second);
-          glVertex2fv(i->first.getV0());
-          glColor4fv(i->second);
-          glVertex2fv(i->first.getV10());
-          glColor4fv(i->second);
-          glVertex2fv(i->first.getV1());
-          glColor4fv(i->second);
-          glVertex2fv(i->first.getV01());
-        }
-      glEnd();
-    }
+        //    float x0,y0,x1,y1;
+        // turned
+        glBegin(GL_QUADS);
+        for(std::vector<std::pair<AGRect2,AGVector4> >::const_iterator i=pRects.begin();i!=pRects.end();++i)
+          {
+            glColor4fv(i->second);
+            glVertex2fv(i->first.getV0());
+            glColor4fv(i->second);
+            glVertex2fv(i->first.getV10());
+            glColor4fv(i->second);
+            glVertex2fv(i->first.getV1());
+            glColor4fv(i->second);
+            glVertex2fv(i->first.getV01());
+          }
+        glEnd();
+      }
 
 
-  void drawGradientAlpha(const AGRect2& pRect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr)
-    {
-      STACKTRACE;
+    void drawGradientAlpha(const AGRect2& pRect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr)
+      {
+        STACKTRACE;
 
-      AGRenderContext context;
-      context.setColor(AGVector4(1,1,1,1));
-      context.setCulling(false);
-      context.setDepthTest(false);
+        AGRenderContext context;
+        context.setColor(AGVector4(1,1,1,1));
+        context.setCulling(false);
+        context.setDepthTest(false);
 
 
-      context.begin();
+        context.begin();
 
-      glBegin(GL_QUADS);
-      glColor(ul);
-      glVertex2fv(pRect.getV0());
+        glBegin(GL_QUADS);
+        glColor(ul);
+        glVertex2fv(pRect.getV0());
 
-      glColor(ur);
-      glVertex2fv(pRect.getV10());
+        glColor(ur);
+        glVertex2fv(pRect.getV10());
 
-      glColor(dr);
-      glVertex2fv(pRect.getV1());
+        glColor(dr);
+        glVertex2fv(pRect.getV1());
 
-      glColor(dl);
-      glVertex2fv(pRect.getV01());
-      glEnd();
-    }
+        glColor(dl);
+        glVertex2fv(pRect.getV01());
+        glEnd();
+      }
 
-  void drawBorder(const AGRect2& rect,int W, const AGColor& c1, const AGColor& c2)
-    {
-      STACKTRACE;
+    void drawBorder(const AGRect2& rect,int W, const AGColor& c1, const AGColor& c2)
+      {
+        STACKTRACE;
 
-      AGRect2 inner=rect.shrink(3);
+        AGRect2 inner=rect.shrink(3);
 
-      AGRenderContext context;
-      context.setColor(c1);
-      context.setCulling(false);
-      context.setDepthTest(false);
-      context.begin();
+        AGRenderContext context;
+        context.setColor(c1);
+        context.setCulling(false);
+        context.setDepthTest(false);
+        context.begin();
 
-      glBegin(GL_QUADS);
-      glVertex2fv(rect.getV0());
-      glVertex2fv(rect.getV10());
-      glVertex2fv(inner.getV10());
-      glVertex2fv(inner.getV0());
+        glBegin(GL_QUADS);
+        glVertex2fv(rect.getV0());
+        glVertex2fv(rect.getV10());
+        glVertex2fv(inner.getV10());
+        glVertex2fv(inner.getV0());
 
-      glVertex2fv(rect.getV0());
-      glVertex2fv(inner.getV0());
-      glVertex2fv(inner.getV01());
-      glVertex2fv(rect.getV01());
+        glVertex2fv(rect.getV0());
+        glVertex2fv(inner.getV0());
+        glVertex2fv(inner.getV01());
+        glVertex2fv(rect.getV01());
 
-      glEnd();
+        glEnd();
 
-      // right and //bottom
-      context.setColor(c2);
-      context.begin();
-      //  glColor(c2);
-      glBegin(GL_QUADS);
+        // right and //bottom
+        context.setColor(c2);
+        context.begin();
+        //  glColor(c2);
+        glBegin(GL_QUADS);
 
-      glVertex2fv(rect.getV10());
-      glVertex2fv(rect.getV1());
-      glVertex2fv(inner.getV1());
-      glVertex2fv(inner.getV10());
+        glVertex2fv(rect.getV10());
+        glVertex2fv(rect.getV1());
+        glVertex2fv(inner.getV1());
+        glVertex2fv(inner.getV10());
 
-      glVertex2fv(rect.getV01());
-      glVertex2fv(inner.getV01());
-      glVertex2fv(inner.getV1());
-      glVertex2fv(rect.getV1());
-      glEnd();
-    }
+        glVertex2fv(rect.getV01());
+        glVertex2fv(inner.getV01());
+        glVertex2fv(inner.getV1());
+        glVertex2fv(rect.getV1());
+        glEnd();
+      }
 
-  void putPixel(int x,int y,const AGColor &pc)
-    {
-      STACKTRACE;
+    void putPixel(int x,int y,const AGColor &pc)
+      {
+        STACKTRACE;
 
-      AGRenderContext rc;
-      rc.begin();
-      float f=0xFF;
-      rc.setColor(AGVector4(pc.r/f,pc.g/f,pc.b/f,pc.a/f));
-      rc.begin();
+        AGRenderContext rc;
+        rc.begin();
+        float f=0xFF;
+        rc.setColor(AGVector4(pc.r/f,pc.g/f,pc.b/f,pc.a/f));
+        rc.begin();
 
-      glBegin(GL_POINTS);
+        glBegin(GL_POINTS);
 
-      // #warning "really +1 ????????????"
-      glVertex2f(x,y+1);
+        // #warning "really +1 ????????????"
+        glVertex2f(x,y+1);
 
-      glEnd();
+        glEnd();
 
-    }
+      }
 
-  void drawLine(const AGVector2 &p0,const AGVector2 &p1,const AGColor &c,float pWidth)
-    {
-      STACKTRACE;
-      assertGL;
-      AGRenderContext context;
-      context.setColor(c);
-      context.setDepthTest(false);
-      context.begin();
+    void drawLine(const AGVector2 &p0,const AGVector2 &p1,const AGColor &c,float pWidth)
+      {
+        STACKTRACE;
+        assertGL;
+        AGRenderContext context;
+        context.setColor(c);
+        context.setDepthTest(false);
+        context.begin();
 
-      glLineWidth(pWidth);
-      glEnable(GL_LINE_SMOOTH);
-      glBegin(GL_LINES);
-      glVertex2fv(p0);
-      glVertex2fv(p1);
+        glLineWidth(pWidth);
+        glEnable(GL_LINE_SMOOTH);
+        glBegin(GL_LINES);
+        glVertex2fv(p0);
+        glVertex2fv(p1);
 
-      glEnd();
-      assertGL;
+        glEnd();
+        assertGL;
 
-    }
+      }
 
-  void blitTri(const AGTexture &pSource,const AGTriangle2 &pSrc,const AGTriangle2 &pDest)
-    {
-      throw int();
-      STACKTRACE;
-      /*    AGRenderContext c;
+    void blitTri(const AGTexture &pSource,const AGTriangle2 &pSrc,const AGTriangle2 &pDest)
+      {
+        throw int();
+        STACKTRACE;
+        /*    AGRenderContext c;
     c.setTexture(const_cast<AGTexture&>(pSource).glTexture());
     c.setDepthTest(false);
     c.begin();
@@ -363,7 +364,30 @@
     glVertex2f(pDest[0].getX(), h-1-pDest[0].getY());
 
     glEnd();*/
-    }
+      }
 
 
-}
+    void blit3dTri(const AGTexture &pSource,const AGTriangle2 &pSrc,const AGTriangle3 &pDest)
+      {
+        STACKTRACE;
+
+        AGRenderContext context;
+        context.setCulling(false);
+        context.setTexture(const_cast<AGTexture&>(pSource).glTexture());
+        context.setDepthTest(false);
+        context.begin();
+        
+        AGProjection2D p(pSource.getRect(),AGRect2(0,0,1,1));
+
+        glBegin(GL_TRIANGLES);
+        for(size_t i=0;i<3;i++)
+          {
+            glTexCoord2fv(p.project(pSrc.get(i)));
+            glVertex3fv(pDest[i]);
+          }
+
+        glEnd();       
+      }
+
+
+  }

Modified: antargis/trunk/ext/video/ag_glpainter.h
===================================================================
--- antargis/trunk/ext/video/ag_glpainter.h	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/video/ag_glpainter.h	2008-06-10 19:22:29 UTC (rev 1268)
@@ -50,6 +50,7 @@
   void drawLine(const AGVector2 &p0,const AGVector2 &p1,const AGColor &c,float pWidth);
 
   void blitTri(const AGTexture &pSource,const AGTriangle2 &pSrc,const AGTriangle2 &pDest);
+  void blit3dTri(const AGTexture &pSource,const AGTriangle2 &pSrc,const AGTriangle3 &pDest);
 
   void putPixel(int x,int y,const AGColor &pc);
 }

Modified: antargis/trunk/ext/video/ag_glscreen.cc
===================================================================
--- antargis/trunk/ext/video/ag_glscreen.cc	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/video/ag_glscreen.cc	2008-06-10 19:22:29 UTC (rev 1268)
@@ -118,41 +118,41 @@
 AGGLScreen::AGGLScreen(int W,int H,int VW,int VH):
   w(VW),h(VH),
   rw(W),rh(H)
-          {
-            if(w<rw)
-              w=rw;
-            if(h<rh)
-              h=rh;
+  {
+    if(w<rw)
+      w=rw;
+    if(h<rh)
+      h=rh;
 
-            mLineWidth=2;
+    mLineWidth=2;
 
-            cdebug("w:"<<w<<" h:"<<h);
+    cdebug("w:"<<w<<" h:"<<h);
 
-            // init GL
-            glEnable(GL_TEXTURE_2D);
-            glShadeModel(GL_SMOOTH);
-            glClearColor(0.0f,0.0f,0.0f,0.0f); // clear bgcolor
-            glClearDepth(1.0f);      // clear depth buffer
-            glEnable(GL_DEPTH_TEST); // enable depth test
-            glDepthFunc(GL_LEQUAL); // set type depth test
-            glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // GL_NICEST // best perspective correction
-            glEnable(GL_BLEND);
+    // init GL
+    glEnable(GL_TEXTURE_2D);
+    glShadeModel(GL_SMOOTH);
+    glClearColor(0.0f,0.0f,0.0f,0.0f); // clear bgcolor
+    glClearDepth(1.0f);      // clear depth buffer
+    glEnable(GL_DEPTH_TEST); // enable depth test
+    glDepthFunc(GL_LEQUAL); // set type depth test
+    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // GL_NICEST // best perspective correction
+    glEnable(GL_BLEND);
 
-            glViewport( 0, 0, rw, rh );
-            glMatrixMode( GL_PROJECTION );
-            glLoadIdentity( );
+    glViewport( 0, 0, rw, rh );
+    glMatrixMode( GL_PROJECTION );
+    glLoadIdentity( );
 
-            GLfloat ratio;
+    GLfloat ratio;
 
-            ratio = ( float )w / ( float )h;
+    ratio = ( float )w / ( float )h;
 
-            //  gluPerspective( 45.0f, ratio, 1.0f, 100.0f );
+    //  gluPerspective( 45.0f, ratio, 1.0f, 100.0f );
 
-            gluOrtho2D(0,w,0,h);
+    gluOrtho2D(0,w,0,h);
 
-            glMatrixMode( GL_MODELVIEW );
-            glLoadIdentity( );
-          }
+    glMatrixMode( GL_MODELVIEW );
+    glLoadIdentity( );
+  }
 
 
 
@@ -298,7 +298,8 @@
 
     ratio = ( float )w / ( float )h;
 
-    gluOrtho2D(0,w,0,h);
+    //gluOrtho2D(0,w,0,h);
+    glOrtho(0,w,0,h,-1,1);
 
     glMatrixMode( GL_MODELVIEW );
     glLoadIdentity( );
@@ -311,6 +312,7 @@
     glDepthMask(false);
   }
 
+
 void AGGLScreen::flip()
   {
     myFlip();
@@ -413,6 +415,12 @@
     drawGradientAlpha(rect,ul,ur,dl,dr);
   }
 
+void AGGLScreen::blit3dTri(const AGTexture &pSource,const AGTriangle2 &pSrc,const AGTriangle3 &pDest)
+  {
+    AGGLPainter::blit3dTri(pSource,pSrc,pDest);
+  }
+
+
 void AGGLScreen::drawLine(const AGVector2 &p0,const AGVector2 &p1,const AGColor &c)
   {
     AGGLPainter::drawLine(p0,p1,c,mLineWidth);

Modified: antargis/trunk/ext/video/ag_glscreen.h
===================================================================
--- antargis/trunk/ext/video/ag_glscreen.h	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/video/ag_glscreen.h	2008-06-10 19:22:29 UTC (rev 1268)
@@ -18,6 +18,8 @@
  * License along with this program.
  */
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #ifndef __GUI_GLSURFACE_H
 #define __GUI_GLSURFACE_H
 
@@ -71,6 +73,8 @@
   virtual void drawPoly(const std::vector<AGVector2> &pPoly,const AGColor &pColor);
   virtual void drawLine(const AGVector2 &p0,const AGVector2 &p1,const AGColor &c);
 
+  void blit3dTri(const AGTexture &pSource,const AGTriangle2 &pSrc,const AGTriangle3 &pDest);
+
   virtual AGRect2 getRect() const;
 
   virtual void drawGradient(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr);

Modified: antargis/trunk/ext/video/ag_projection.cc
===================================================================
--- antargis/trunk/ext/video/ag_projection.cc	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/video/ag_projection.cc	2008-06-10 19:22:29 UTC (rev 1268)
@@ -50,6 +50,24 @@
   return (m*p).dim2();
 }
 
+/// leaves 3rd dimension untouched
+AGVector3 AGProjection2D::project(const AGVector3 &p) const
+{
+  assert(mInited);
+  return AGVector3((m*p.dim2()).dim2(),p[2]);
+}
+
+AGTriangle2 AGProjection2D::project(const AGTriangle2 &t) const
+{
+  return AGTriangle2(project(t.get(0)),project(t.get(1)),project(t.get(2)));
+}
+// leaves 3rd dimension untouched
+AGTriangle3 AGProjection2D::project(const AGTriangle3 &t) const
+{
+  return AGTriangle3(project(t[0]),project(t[1]),project(t[2]));
+}
+
+
 void AGProjection2D::pushProjection(const AGProjection2D &p)
   {
     assert(mInited);

Modified: antargis/trunk/ext/video/ag_projection.h
===================================================================
--- antargis/trunk/ext/video/ag_projection.h	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/video/ag_projection.h	2008-06-10 19:22:29 UTC (rev 1268)
@@ -17,6 +17,9 @@
 
   AGRect2 project(const AGRect2 &r) const;
   AGVector2 project(const AGVector2 &p) const;
+  AGVector3 project(const AGVector3 &p) const;
+  AGTriangle2 project(const AGTriangle2 &t) const;
+  AGTriangle3 project(const AGTriangle3 &t) const;
   
   AGProjection2D inverse() const throw (GeometryException);
 

Modified: antargis/trunk/ext/video/ag_surface.cc
===================================================================
--- antargis/trunk/ext/video/ag_surface.cc	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/video/ag_surface.cc	2008-06-10 19:22:29 UTC (rev 1268)
@@ -132,26 +132,26 @@
 ///////////////////////////////////////////////////////////////////////
 
 AGSurface::AGSurface(AGInternalSurface *i):s(i)
-    {
-      getSurfaceManager()->registerMe(this);
-    }
+      {
+        getSurfaceManager()->registerMe(this);
+      }
 
 
 AGSurface::AGSurface():
   s(0)
-      {
-        getSurfaceManager()->registerMe(this);
-      }
+        {
+          getSurfaceManager()->registerMe(this);
+        }
 AGSurface::AGSurface(int w,int h):
   s(AGCreate32BitSurface(w,h))
-      {
-        getSurfaceManager()->registerMe(this);
-      }
+        {
+          getSurfaceManager()->registerMe(this);
+        }
 AGSurface::AGSurface(const AGSurface &p):
   s(p.s)
-      {
-        getSurfaceManager()->registerMe(this);
-      }
+        {
+          getSurfaceManager()->registerMe(this);
+        }
 
 bool AGSurface::valid() const
 {
@@ -350,13 +350,16 @@
   return s;
 }
 
-AGSurface AGSurface::load(const std::string &pFilename)
+AGSurface AGSurface::load(const std::string &pFilename) throw (FileNotFound)
   {
     AGSurface n;
     n.s=new AGInternalSurface;
     std::string file=loadFile(pFilename);
     if(file.length()==0)
-      cdebug("File "<<pFilename<<" is empty!");
+      {
+        cdebug("File "<<pFilename<<" is empty!");
+        throw FileNotFound(pFilename);
+      }
 
     SDL_RWops* rw=SDL_RWFromMem(const_cast<char*>(file.c_str()),file.length());
 
@@ -373,7 +376,7 @@
     return n;
   }
 
-AGSurface AGSurface::loadDRM(const std::string &pName)
+AGSurface AGSurface::loadDRM(const std::string &pName) throw(FileNotFound)
   {
     assert(mDecryptor);
 
@@ -383,6 +386,8 @@
 
     n.s=new AGInternalSurface;
     std::string file=loadFile(pName);
+    if(file.length()==0)
+      throw FileNotFound(pName);
 
     file=mDecryptor->decrypt(file,pName);
     gDRM=true;

Modified: antargis/trunk/ext/video/ag_surface.h
===================================================================
--- antargis/trunk/ext/video/ag_surface.h	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ext/video/ag_surface.h	2008-06-10 19:22:29 UTC (rev 1268)
@@ -116,8 +116,8 @@
 
   void save(const std::string &pName) const;
 
-  static AGSurface load(const std::string &pName);
-  static AGSurface loadDRM(const std::string &pName);
+  static AGSurface load(const std::string &pName) throw(FileNotFound);
+  static AGSurface loadDRM(const std::string &pName) throw(FileNotFound);
 
   AGInternalSurface *surface() const;
 

Modified: antargis/trunk/rookey/config_generator.rb
===================================================================
--- antargis/trunk/rookey/config_generator.rb	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/rookey/config_generator.rb	2008-06-10 19:22:29 UTC (rev 1268)
@@ -109,7 +109,6 @@
     end
     def getEnvPath
       p=ENV["PATH"]
-      pp p
       if File.join("a","b")=~/\\/
         p.split(";")
       else

Modified: antargis/trunk/ruby/editor/campaign/drag_grid.rb
===================================================================
--- antargis/trunk/ruby/editor/campaign/drag_grid.rb	2008-06-09 18:59:40 UTC (rev 1267)
+++ antargis/trunk/ruby/editor/campaign/drag_grid.rb	2008-06-10 19:22:29 UTC (rev 1268)
@@ -686,6 +686,8 @@
 
 [DragGrid,DragSource,DragTrash,DragEnvironment,ToolBar,ToolButton,AppearEffect,HideEffect].each{|c|standardLayoutCreator(c)}
 
+require File.join(File.split(__FILE__)[0],'image_list.rb')
+
 class RubySignal
   def initialize(name)
     @name=name



From davidkamphausen at mail.berlios.de  Fri Jun 27 17:10:25 2008
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Fri, 27 Jun 2008 17:10:25 +0200
Subject: [Antargis-svn] r1269 - in antargis/trunk: . data data/gui/campaign
	data/gui/layout/editor/campaign ext/basic ext/gui ext/video
	games games/copter games/copter/images ruby/editor/campaign ruby/gui
Message-ID: <200806271510.m5RFAPS1014878@sheep.berlios.de>

Author: davidkamphausen
Date: 2008-06-27 17:10:20 +0200 (Fri, 27 Jun 2008)
New Revision: 1269

Added:
   antargis/trunk/data/gui/campaign/map1.png
   antargis/trunk/data/gui/layout/editor/campaign/story_editor.xml
   antargis/trunk/games/
   antargis/trunk/games/copter/
   antargis/trunk/games/copter/images/
   antargis/trunk/games/copter/images/copter0.png
   antargis/trunk/ruby/editor/campaign/image_list.rb
   antargis/trunk/ruby/editor/campaign/image_list_2d.rb
   antargis/trunk/ruby/editor/campaign/story_editor.rb
Modified:
   antargis/trunk/data/gui/layout/editor/campaign/main.xml
   antargis/trunk/data/theme.xml
   antargis/trunk/ext/basic/ag_geometry.cc
   antargis/trunk/ext/basic/ag_geometry.h
   antargis/trunk/ext/gui/ag_background.cc
   antargis/trunk/ext/gui/ag_background.h
   antargis/trunk/ext/gui/ag_frame.cc
   antargis/trunk/ext/gui/ag_frame.h
   antargis/trunk/ext/gui/ag_layout.cc
   antargis/trunk/ext/gui/ag_layoutcreators.cc
   antargis/trunk/ext/gui/ag_theme.cc
   antargis/trunk/ext/gui/ag_theme.h
   antargis/trunk/ext/gui/ag_widget.cc
   antargis/trunk/ext/gui/ag_widget.h
   antargis/trunk/ext/gui/ag_window.cc
   antargis/trunk/ext/video/ag_glpainter.cc
   antargis/trunk/ext/video/ag_gltexture.cc
   antargis/trunk/ext/video/ag_gltexture.h
   antargis/trunk/ext/video/ag_texturecache.cc
   antargis/trunk/ext/video/ag_texturecache.h
   antargis/trunk/ext/video/ag_video.cc
   antargis/trunk/ruby/editor/campaign/drag_grid.rb
   antargis/trunk/ruby/gui/ag_tools.rb
Log:
Incomplete - task 11: Campaign editor 
http://localhost:3000/issues/show/11

Added: antargis/trunk/data/gui/campaign/map1.png
===================================================================
(Binary files differ)


Property changes on: antargis/trunk/data/gui/campaign/map1.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: antargis/trunk/data/gui/layout/editor/campaign/main.xml
===================================================================
--- antargis/trunk/data/gui/layout/editor/campaign/main.xml	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/data/gui/layout/editor/campaign/main.xml	2008-06-27 15:10:20 UTC (rev 1269)
@@ -63,42 +63,6 @@
     <appearEffect name="showEdit" table="bigTable" row="1" size="40" duration="0.2"/>
     <hideEffect name="hideEdit" table="bigTable" row="1" size="40" duration="0.2"/>
   </dragEnvironment>
+  <storyEditor name="storyEditor"/>
 
-
-  <frame width="150" height="70">
-    <window>
-      <table rows="3" cols="1">
-        <rowsize row="0" relative="0.7"/>
-        <rowsize row="1" relative="3"/>
-        <cell col="0" row="0">
-          <imageList/>
-        </cell>
-        <cell col="0" row="1">
-          <frame width="20">
-            <image filename="data/gui/map1.png" scale="true"/>
-          </frame>
-        </cell>
-        <cell col="0" row="2">
-          <table rows="1" cols="3">
-            <colsize col="1" relative="8"/>
-            <cell col="1" row="0">
-              <frame width="5">
-                <edit text="caption" multi="true"/>
-              </frame>
-            </cell>
-            <cell col="0" row="0">
-              <frame width="10" height="40">
-                <button caption-image="data/gui/arrow_left.png"/>
-              </frame>
-            </cell>
-            <cell col="2" row="0">
-              <frame width="10" height="40">
-                <button caption-image="data/gui/arrow_right.png"/>
-              </frame>
-            </cell>
-          </table>
-        </cell>
-      </table>
-    </window>
-  </frame>
 </layout>
\ No newline at end of file

Added: antargis/trunk/data/gui/layout/editor/campaign/story_editor.xml
===================================================================
--- antargis/trunk/data/gui/layout/editor/campaign/story_editor.xml	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/data/gui/layout/editor/campaign/story_editor.xml	2008-06-27 15:10:20 UTC (rev 1269)
@@ -0,0 +1,43 @@
+<?xml version="1.0"?>
+<layout name="StoryEditor">
+  <frame width="150" height="70">
+    <window theme="black">
+      <table rows="3" cols="1">
+        <rowsize row="0" relative="0.7"/>
+        <rowsize row="1" relative="3"/>
+        <cell col="0" row="0">
+          <imageList2D name="imageList"/>
+        </cell>
+        <cell col="0" row="1">
+          <frame width="20">
+            <image name="image" filename="data/gui/map1.png" scale="true"/>
+          </frame>
+        </cell>
+        <cell col="0" row="2">
+          <table rows="2" cols="3">
+            <colsize col="1" relative="8"/>
+            <rowsize row="1" relative="0.2"/>
+            <cell col="1" row="0">
+              <frame width="5">
+                <edit name="edit" text="caption" multi="true"/>
+              </frame>
+            </cell>
+            <cell col="0" row="0">
+              <frame width="10" height="40">
+                <button name="prev" caption-image="data/gui/arrow_left.png"/>
+              </frame>
+            </cell>
+            <cell col="2" row="0">
+              <frame width="10" height="40">
+                <button name="next" caption-image="data/gui/arrow_right.png"/>
+              </frame>
+            </cell>
+            <cell col="1" row="1">
+              <text name="info"/>
+            </cell>
+          </table>
+        </cell>
+      </table>
+    </window>
+  </frame>
+ </layout>
\ No newline at end of file

Modified: antargis/trunk/data/theme.xml
===================================================================
--- antargis/trunk/data/theme.xml	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/data/theme.xml	2008-06-27 15:10:20 UTC (rev 1269)
@@ -222,6 +222,30 @@
 			<image name="image" file="data/gui/paper2.png"/>
 		</background>
 	</window>
+  <black>
+    <window>
+      <border>
+        <image name="image" file="data/gui/buttontest3.png"/>
+      </border>
+      <title>
+        <font name="font" file="FreeSans.ttf" size="16" color='#FFFFFF'/>
+        <background>
+          <value name="border" value="0"/>
+          <color name='gradientColor1' color='#54555b'/>
+          <color name='gradientColor2' color='#3c3d41'/>
+          <color name='gradientColor3' color='#3c3d41'/>
+          <color name='gradientColor4' color='#12141c'/>
+        </background>
+      </title>
+      <buttons>
+        <image name="close" file="data/gui/close_button.png"/>
+      </buttons>
+      <background>
+        <value name="border" value="0"/>
+        <color name="color" color='#000000'/>
+      </background>
+    </window>
+  </black>
 	
 	
 	<yellowButton>

Modified: antargis/trunk/ext/basic/ag_geometry.cc
===================================================================
--- antargis/trunk/ext/basic/ag_geometry.cc	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/basic/ag_geometry.cc	2008-06-27 15:10:20 UTC (rev 1269)
@@ -841,6 +841,13 @@
     p[2]=v2;
   }
 
+void AGTriangle2::flip()
+  {
+    AGVector2 tmp=p[2];
+    p[2]=p[1];
+    p[1]=tmp;
+  }
+
 AGRect2 AGTriangle2::getBBox() const
 {
   float minx=std::min(p[0].getX(),std::min(p[1].getX(),p[2].getX()));
@@ -1199,6 +1206,12 @@
   return AGVector4(ip,1);
 }
 
+void AGTriangle3::flip()
+  {
+    AGVector3 tmp=p[2];
+    p[2]=p[1];
+    p[1]=tmp;
+  }
 
 AGString AGTriangle3::toString() const
 {

Modified: antargis/trunk/ext/basic/ag_geometry.h
===================================================================
--- antargis/trunk/ext/basic/ag_geometry.h	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/basic/ag_geometry.h	2008-06-27 15:10:20 UTC (rev 1269)
@@ -390,6 +390,8 @@
     AGLine2 nearestLine(const AGVector2 &v) const;
 
     std::vector<AGLine2> getLines() const;
+    
+    void flip();
 #ifdef SWIG
     %rename(to_s) toString() const;
 #endif
@@ -424,10 +426,15 @@
     // (x,y,z,0) for no collision 
     // (x,y,z,1) for collision in point (x,y,z)
     AGVector4 collide(const AGLine3 &pLine) const;
+#ifdef SWIG
+    %rename(to_s) toString() const;
+#endif
 
     AGString toString() const;
 
     AGVector3 operator[](int index) const;
+    
+    void flip();
   };
 
 class AGEXPORT AGRect2

Modified: antargis/trunk/ext/gui/ag_background.cc
===================================================================
--- antargis/trunk/ext/gui/ag_background.cc	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/gui/ag_background.cc	2008-06-27 15:10:20 UTC (rev 1269)
@@ -59,37 +59,44 @@
 
 AGBackground::AGBackground(const AGString &pThemeName):mTexture(0)
   {
-    //  CTRACE;
+    AGTheme *theme=getTheme();
+loadFromTheme(theme->getTheme(""),pThemeName);
+  }
 
-    AGTheme *theme=getTheme();
+AGBackground::AGBackground(const AGLocalTheme &pTheme,const AGString &pThemeName)
+  {
+    loadFromTheme(pTheme,pThemeName);
+  }
+void AGBackground::loadFromTheme(const AGLocalTheme &pTheme,const AGString &pThemeName)
+  {
     mColor=false;
-    if(theme->hasSurface(pThemeName+".image"))
+    
+    if(pTheme.hasSurface(pThemeName+".image"))
       {
-        //      CTRACE;
         cdebug(pThemeName+".image");
-        mTexture=&getTextureCache()->get(getTheme()->getSurfaceName(pThemeName+".image"));
-        //mTexture=new AGTexture(theme->getSurface(pThemeName+".image"));
+        mTexture=&getTextureCache()->get(pTheme.getSurfaceName(pThemeName+".image"));
       }
-    else if(theme->hasColor(pThemeName+"."+"gradientColor1"))
+    else if(pTheme.hasColor(pThemeName+"."+"gradientColor1"))
       {
         mColor=true;
-        mColors[0]=theme->getColor(pThemeName+"."+"gradientColor1");
-        mColors[1]=theme->getColor(pThemeName+"."+"gradientColor2");
-        mColors[2]=theme->getColor(pThemeName+"."+"gradientColor3");
-        mColors[3]=theme->getColor(pThemeName+"."+"gradientColor4");
+        mColors[0]=pTheme.getColor(pThemeName+"."+"gradientColor1");
+        mColors[1]=pTheme.getColor(pThemeName+"."+"gradientColor2");
+        mColors[2]=pTheme.getColor(pThemeName+"."+"gradientColor3");
+        mColors[3]=pTheme.getColor(pThemeName+"."+"gradientColor4");
       }
-    else if(theme->hasColor(pThemeName+"."+"color"))
+    else if(pTheme.hasColor(pThemeName+"."+"color"))
       {
         mColor=true;
-        mColors[0]=theme->getColor(pThemeName+"."+"color");
-        mColors[1]=theme->getColor(pThemeName+"."+"color");
-        mColors[2]=theme->getColor(pThemeName+"."+"color");
-        mColors[3]=theme->getColor(pThemeName+"."+"color");
+        mColors[0]=pTheme.getColor(pThemeName+"."+"color");
+        mColors[1]=pTheme.getColor(pThemeName+"."+"color");
+        mColors[2]=pTheme.getColor(pThemeName+"."+"color");
+        mColors[3]=pTheme.getColor(pThemeName+"."+"color");
       }
 
-    mBorder=theme->getInt(pThemeName+"."+"border");
+    mBorder=pTheme.getInt(pThemeName+"."+"border");    
   }
 
+
 /// draws the background on painter in the given rectangle
 void AGBackground::draw(const AGRect2 &r,AGPainter &p)
   {

Modified: antargis/trunk/ext/gui/ag_background.h
===================================================================
--- antargis/trunk/ext/gui/ag_background.h	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/gui/ag_background.h	2008-06-27 15:10:20 UTC (rev 1269)
@@ -27,6 +27,7 @@
 #include "ag_geometry.h"
 #include "ag_texture.h"
 #include "ag_color.h"
+#include "ag_theme.h"
 
 class AGPainter;
 
@@ -35,20 +36,24 @@
     It is themable.
  */
 class AGEXPORT AGBackground
-{
- public:
-  AGBackground(const AGString &pThemeName="");
-  AGBackground(const AGColor &pColor);
+  {
+  public:
+    AGBackground(const AGString &pThemeName="");
+    AGBackground(const AGLocalTheme &pTheme,const AGString &pThemeName="");
+    AGBackground(const AGColor &pColor);
 
-  void draw(const AGRect2 &r,AGPainter &p);
+    void draw(const AGRect2 &r,AGPainter &p);
 
-  void useTextures();
- private:
-  const AGTexture *mTexture;
-  AGColor mColors[4];
+    void useTextures();
+  private:
+    
+    void loadFromTheme(const AGLocalTheme &pTheme,const AGString &pThemeName="");
+    
+    const AGTexture *mTexture;
+    AGColor mColors[4];
 
-  bool mColor;
-  int mBorder;
-};
+    bool mColor;
+    int mBorder;
+  };
 
 #endif

Modified: antargis/trunk/ext/gui/ag_frame.cc
===================================================================
--- antargis/trunk/ext/gui/ag_frame.cc	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/gui/ag_frame.cc	2008-06-27 15:10:20 UTC (rev 1269)
@@ -2,7 +2,7 @@
 #include "ag_screen.h"
 #include "ag_debug.h"
 
-AGFrame::AGFrame(AGWidget *pParent,const AGRect2 &pRect,size_t pWidth,size_t pWidthH):AGWidget(pParent,pRect),
+AGFrame::AGFrame(AGWidget *pParent,const AGRect2 &pRect,int pWidth,int pWidthH):AGWidget(pParent,pRect),
 mWidth(pWidth),mBorder(0),mWidthH(pWidthH<0?pWidth:pWidthH),mTexture((int)width(),(int)height())
 {
   mTextureInited=false;

Modified: antargis/trunk/ext/gui/ag_frame.h
===================================================================
--- antargis/trunk/ext/gui/ag_frame.h	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/gui/ag_frame.h	2008-06-27 15:10:20 UTC (rev 1269)
@@ -10,7 +10,7 @@
 class AGEXPORT AGFrame:public AGWidget
 {
  public:
-  AGFrame(AGWidget *pParent,const AGRect2 &pRect,size_t width,size_t widthH=-1); // transparent frame
+  AGFrame(AGWidget *pParent,const AGRect2 &pRect,int width,int widthH=-1); // transparent frame
   AGFrame(AGWidget *pParent,const AGRect2 &pRect,const AGBorder &pBorder);
   ~AGFrame();
 

Modified: antargis/trunk/ext/gui/ag_layout.cc
===================================================================
--- antargis/trunk/ext/gui/ag_layout.cc	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/gui/ag_layout.cc	2008-06-27 15:10:20 UTC (rev 1269)
@@ -86,6 +86,7 @@
       }
     getLayoutFactory()->popLayout();
     mTempWidgets.clear();
+    initEvents();
   }
 
 bool AGLayout::eventKeyDown(AGEvent *m)

Modified: antargis/trunk/ext/gui/ag_layoutcreators.cc
===================================================================
--- antargis/trunk/ext/gui/ag_layoutcreators.cc	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/gui/ag_layoutcreators.cc	2008-06-27 15:10:20 UTC (rev 1269)
@@ -371,7 +371,7 @@
       AGString border=pNode.get("border");
       size_t width=pNode.get("width").toInt();
       
-      size_t height=0;
+      int height=-1;
       if(pNode.get("height").length()>0)
         height=pNode.get("height").toInt();
 

Modified: antargis/trunk/ext/gui/ag_theme.cc
===================================================================
--- antargis/trunk/ext/gui/ag_theme.cc	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/gui/ag_theme.cc	2008-06-27 15:10:20 UTC (rev 1269)
@@ -43,42 +43,57 @@
   }
 void AGTheme::setColor(const AGString &pName,AGColor pColor)
   {
-    //  cdebug(pName);
     mColors[pName]=pColor;
-    //  cout<<"setting:"<<pName<<":"<<pColor.toString()<<endl;
   }
 
 
-AGFont AGTheme::getFont(const AGString &pName)
-  {
-    //  cdebug(pName<<":"<<mFonts[pName].toString());
-    if(mFonts.find(pName)==mFonts.end())
-      return mFonts[trunk(pName)];
-    return mFonts[pName];
-  }
-AGColor AGTheme::getColor(const AGString &pName)
-  {
-    //  cdebug(pName);
-    if(mColors.find(pName)==mColors.end())
-      return mColors[trunk(pName)];
-    return mColors[pName];
-  }
+AGFont AGTheme::getFont(const AGString &pName) const
+{
+  std::map<AGString,AGFont>::const_iterator i=mFonts.find(pName);
 
-AGString AGTheme::trunk(AGString s)
+  if(i==mFonts.end())
+    {
+      i=mFonts.find(trunc(pName));
+      if(i==mFonts.end())
+        return AGFont();
+    }
+  return i->second;
+}
+AGColor AGTheme::getColor(const AGString &pName) const
+{
+  std::map<AGString,AGColor>::const_iterator i=mColors.find(pName);
+
+  if(i==mColors.end())
+    {
+      AGString n=trunc(pName);
+      i=mColors.find(n);
+      if(i==mColors.end())
+        return AGColor();
+    }
+  return i->second;
+}
+
+AGString AGTheme::trunc(AGString s) const
   {
-    //  cdebug(s);
     size_t i=s.find(".");
     if(i!=s.npos)
       s=s.substr(0,i);
     return s;
   }
 
-int AGTheme::getInt(const AGString &pName)
-  {
-    if(mInts.find(pName)==mInts.end())
-      return mInts[trunk(pName)];
-    return mInts[pName];
-  }
+int AGTheme::getInt(const AGString &pName) const
+{
+  std::map<AGString,int>::const_iterator i=mInts.find(pName);
+
+  if(i==mInts.end())
+    {
+      AGString n=trunc(pName);
+      i=mInts.find(n);
+      if(i==mInts.end())
+        return 0;
+    }
+  return i->second;
+}
 void AGTheme::setInt(const AGString &pName,int i)
   {
     mInts[pName]=i;
@@ -110,21 +125,36 @@
 
 bool AGTheme::hasSurface(const AGString &pName) const
 {
-  //  cdebug(pName);
   return(mSurfaces.find(pName)!=mSurfaces.end());
 }
+bool AGTheme::hasSurfaceName(const AGString &pName) const
+{
+  return(mSurfaceNames.find(pName)!=mSurfaceNames.end());
+}
+bool AGTheme::hasInt(const AGString &pName) const
+{
+  return(mInts.find(pName)!=mInts.end());
+}
 bool AGTheme::hasColor(const AGString &pName) const
 {
-  //  cdebug(pName);
   return(mColors.find(pName)!=mColors.end());
 }
+bool AGTheme::hasFont(const AGString &pName) const
+{
+  return(mFonts.find(pName)!=mFonts.end());
+}
 
 
-AGSurface AGTheme::getSurface(const AGString &pName)
+AGSurface AGTheme::getSurface(const AGString &pName) const
   {
-    if(mSurfaces.find(pName)==mSurfaces.end())
-      return mSurfaces[trunk(pName)];
-    return mSurfaces[pName];
+    std::map<AGString,AGSurface>::const_iterator i=mSurfaces.find(pName);
+    if(i==mSurfaces.end())
+      {
+        i=mSurfaces.find(trunc(pName));
+        if(i==mSurfaces.end())
+          return AGSurface();
+      }
+    return i->second;
   }
 void AGTheme::setSurface(const AGString &pName,const AGSurface &pSurface)
   {
@@ -133,18 +163,101 @@
     assert(mSurfaces[pName].valid());
   }
 
-std::string AGTheme::getSurfaceName(const AGString &pName)
+std::string AGTheme::getSurfaceName(const AGString &pName) const
   {
-    if(mSurfaceNames.find(pName)==mSurfaceNames.end())
-      return mSurfaceNames[trunk(pName)];
-    return mSurfaceNames[pName];
+    std::map<AGString,std::string>::const_iterator i=mSurfaceNames.find(pName);
+    if(i==mSurfaceNames.end())
+      {
+        i=mSurfaceNames.find(trunc(pName));
+        if(i==mSurfaceNames.end())
+          return "";
+      }
+    return i->second;
   }
 void AGTheme::setSurfaceName(const AGString &pName,const std::string &pSurface)
   {
     mSurfaceNames[pName]=pSurface;
   }
 
+AGLocalTheme AGTheme::getTheme(const AGString &pTheme) const
+{
+  return AGLocalTheme(pTheme);
+}
 
+
+
+AGLocalTheme::AGLocalTheme(const AGString &pTheme):mTheme(pTheme)
+      {
+      }
+
+AGFont AGLocalTheme::getFont(const AGString &pName) const
+  {
+    AGString t=mTheme+"."+pName;
+    if(getTheme()->hasFont(t))
+      return getTheme()->getFont(t);
+    return getTheme()->getFont(pName);
+  }
+AGColor AGLocalTheme::getColor(const AGString &pName) const
+  {
+    AGString t=mTheme+"."+pName;
+    if(getTheme()->hasColor(t))
+      return getTheme()->getColor(t);
+    return getTheme()->getColor(pName);
+  }
+
+int AGLocalTheme::getInt(const AGString &pName) const
+  {
+    AGString t=mTheme+"."+pName;
+    if(getTheme()->hasInt(t))
+      return getTheme()->getInt(t);
+    return getTheme()->getInt(pName);
+  }
+
+AGSurface AGLocalTheme::getSurface(const AGString &pName) const
+{
+  AGString t=mTheme+"."+pName;
+  if(getTheme()->hasSurface(t))
+    return getTheme()->getSurface(t);
+  return getTheme()->getSurface(pName);
+}
+
+std::string AGLocalTheme::getSurfaceName(const AGString &pName) const
+{
+  AGString t=mTheme+"."+pName;
+  if(getTheme()->hasSurfaceName(t))
+    return getTheme()->getSurfaceName(t);
+  return getTheme()->getSurfaceName(pName);
+}
+
+bool AGLocalTheme::hasFont(const AGString &pName) const
+{
+  return getTheme()->hasFont(mTheme+"."+pName);
+}
+bool AGLocalTheme::hasColor(const AGString &pName) const
+{
+  return getTheme()->hasColor(mTheme+"."+pName);  
+}
+bool AGLocalTheme::hasInt(const AGString &pName) const
+{
+  return getTheme()->hasInt(mTheme+"."+pName);
+}
+bool AGLocalTheme::hasSurface(const AGString &pName) const
+{
+  return getTheme()->hasSurface(mTheme+"."+pName);
+}
+bool AGLocalTheme::hasSurfaceName(const AGString &pName) const
+{
+  return getTheme()->hasSurfaceName(mTheme+"."+pName);
+}
+
+
+
+
+
+
+
+
+
 void loadTheme(const Node&node,AGTheme &t,AGString name)
   {
     Node::const_iterator i=node.begin();

Modified: antargis/trunk/ext/gui/ag_theme.h
===================================================================
--- antargis/trunk/ext/gui/ag_theme.h	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/gui/ag_theme.h	2008-06-27 15:10:20 UTC (rev 1269)
@@ -29,33 +29,59 @@
 
 #include <map>
 
+class AGEXPORT AGLocalTheme
+  {
+  public:
+    AGLocalTheme(const AGString &pTheme);
+    
+    AGFont getFont(const AGString &pName) const;
+    AGColor getColor(const AGString &pName) const;
+    int getInt(const AGString &pName) const;
+    AGSurface getSurface(const AGString &pName) const;
+    std::string getSurfaceName(const AGString &pName) const;
+    
+    bool hasFont(const AGString &pName) const;
+    bool hasColor(const AGString &pName) const;
+    bool hasInt(const AGString &pName) const;
+    bool hasSurface(const AGString &pName) const;
+    bool hasSurfaceName(const AGString &pName) const;
+    
+  private:
+    AGString mTheme;
+  };
+
 class AGEXPORT AGTheme
 {
  public:
   AGTheme();
   virtual ~AGTheme();
 
-  AGFont getFont(const AGString &pName);
-  AGColor getColor(const AGString &pName);
-
+  AGFont getFont(const AGString &pName) const;
+  bool hasFont(const AGString &pName) const;
   void setFont(const AGString &pName,AGFont pFont);
+  
   void setColor(const AGString &pName,AGColor pColor);
+  AGColor getColor(const AGString &pName) const;
+  bool hasColor(const AGString &pName) const;
 
-  int getInt(const AGString &pName);
+  int getInt(const AGString &pName) const;
+  bool hasInt(const AGString &pName) const;
   void setInt(const AGString &pName,int i);
 
-  AGSurface getSurface(const AGString &pName);
+  AGSurface getSurface(const AGString &pName) const;
+  bool hasSurface(const AGString &pName) const;
   void setSurface(const AGString &pName,const AGSurface &pSurface);
 
-  std::string getSurfaceName(const AGString &pName);
+  std::string getSurfaceName(const AGString &pName) const;
+  bool hasSurfaceName(const AGString &pName) const;
   void setSurfaceName(const AGString &pName,const std::string &pSurface);
 
-  bool hasSurface(const AGString &pName) const;
-  bool hasColor(const AGString &pName) const;
+  
+  AGLocalTheme getTheme(const AGString &pTheme) const;
 
  private:
 
-  AGString trunk(AGString s);
+  AGString trunc(AGString s) const;
 
   std::map<AGString,AGFont> mFonts;
   std::map<AGString,AGColor> mColors;

Modified: antargis/trunk/ext/gui/ag_widget.cc
===================================================================
--- antargis/trunk/ext/gui/ag_widget.cc	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/gui/ag_widget.cc	2008-06-27 15:10:20 UTC (rev 1269)
@@ -66,6 +66,7 @@
   mHasFocus(false),mFocus(0)
 
     {
+      mEventsInited=false;
       CTRACE;
       if(mParent)
         mParent->addChildRef(this);
@@ -1295,3 +1296,16 @@
   return m-getRect().getV0();
 }
 
+
+void AGWidget::initEvents()
+  {
+    if(!mEventsInited)
+      eventInitEvents();
+    for(Children::iterator i=mChildren.begin();i!=mChildren.end();i++)
+      (*i)->initEvents();
+  }
+
+void AGWidget::eventInitEvents()
+  {
+    
+  }

Modified: antargis/trunk/ext/gui/ag_widget.h
===================================================================
--- antargis/trunk/ext/gui/ag_widget.h	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/gui/ag_widget.h	2008-06-27 15:10:20 UTC (rev 1269)
@@ -253,6 +253,10 @@
   virtual bool eventMouseMotionClipped(AGEvent *pEvent,const AGVector2 &pPosition);
 
   void addChildRef(AGWidget *pWidget);
+  
+  void initEvents(); 
+  
+  virtual void eventInitEvents();
  
   
 protected:
@@ -310,6 +314,8 @@
 
   std::set<AGWidget*> mRefChildren;
   
+  bool mEventsInited;
+  
 protected:
   std::list<AGWidget*> mChildren;
 

Modified: antargis/trunk/ext/gui/ag_window.cc
===================================================================
--- antargis/trunk/ext/gui/ag_window.cc	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/gui/ag_window.cc	2008-06-27 15:10:20 UTC (rev 1269)
@@ -35,18 +35,15 @@
 
   {
     CTRACE;
+    
+    AGLocalTheme theme=getTheme()->getTheme(pTheme);
 
-    AGString tstr="window.border.image";
-    if(pTheme!="")
-      tstr=pTheme+"."+tstr;
+    AGString borderImage="window.border.image";
 
-
-    cdebug("image:"<<tstr);
-    AGSurface s=getTheme()->getSurface(tstr);
+    AGSurface s=theme.getSurface(borderImage);
     float bw=s.getRect().w()/3;
     int titBarHeight=20;
 
-    //  cdebug("window_border:"<<s.width()<<"/"<<s.height());
     AGTable *t=0;
 
 
@@ -58,7 +55,7 @@
         {
           AGRect2 r(x*bw,y*bw,bw,bw);
 
-          textures.push_back(&getTextureCache()->get(getTheme()->getSurfaceName(tstr),r));
+          textures.push_back(&getTextureCache()->get(theme.getSurfaceName(borderImage),r));
         }
 
 
@@ -82,7 +79,7 @@
 
         AGImage *i1,*i2;
 
-        AGTable::addChild(0,1,i1=new AGImage(this,AGRect2(0,0,bw,titBarHeight),*textures[3],true));//,AGRect2(0,bw,bw,bw)));
+        AGTable::addChild(0,1,i1=new AGImage(this,AGRect2(0,0,bw,titBarHeight),*textures[3],true));
         // title
         t=dynamic_cast<AGTable*>(getTitleBar((int)(width()-2*bw),titBarHeight));
 
@@ -101,7 +98,7 @@
         AGTable::addChild(1,3,new AGImage(this,AGRect2(0,0,bw,bw),*textures[7],true));
         AGTable::addChild(2,3,new AGImage(this,AGRect2(0,0,bw,bw),*textures[8],true));
 
-        AGTable::addChild(1,2,mClient=new AGCaption(this,AGRect2(0,0,0,0),"",getTheme()->getFont("window.title.font"),AGBackground("window.background")));
+        AGTable::addChild(1,2,mClient=new AGCaption(this,AGRect2(0,0,0,0),"",theme.getFont("window.title.font"),AGBackground(theme,"window.background")));
 
       }
     else
@@ -125,7 +122,7 @@
         AGTable::addChild(1,2,new AGImage(this,AGRect2(0,0,bw,bw),*textures[7],true));
         AGTable::addChild(2,2,new AGImage(this,AGRect2(0,0,bw,bw),*textures[8],true));
 
-        AGTable::addChild(1,1,mClient=new AGCaption(this,AGRect2(0,0,0,0),"",getTheme()->getFont("window.title.font"),AGBackground("window.background")));
+        AGTable::addChild(1,1,mClient=new AGCaption(this,AGRect2(0,0,0,0),"",theme.getFont("window.title.font"),AGBackground(theme,"window.background")));
       }
 
     arrange();

Modified: antargis/trunk/ext/video/ag_glpainter.cc
===================================================================
--- antargis/trunk/ext/video/ag_glpainter.cc	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/video/ag_glpainter.cc	2008-06-27 15:10:20 UTC (rev 1269)
@@ -374,15 +374,17 @@
         AGRenderContext context;
         context.setCulling(false);
         context.setTexture(const_cast<AGTexture&>(pSource).glTexture());
-        context.setDepthTest(false);
+        context.setDepthTest(true);
+        context.setColor(AGColor(0xFF,0xFF,0xFF,0xFF));
         context.begin();
         
-        AGProjection2D p(pSource.getRect(),AGRect2(0,0,1,1));
+        AGProjection2D p(const_cast<AGTexture&>(pSource).glTexture()->getRect(),AGRect2(0,0,1,1));
 
         glBegin(GL_TRIANGLES);
         for(size_t i=0;i<3;i++)
           {
             glTexCoord2fv(p.project(pSrc.get(i)));
+            //glVertex2f(pDest[i][0],pDest[i][1]);
             glVertex3fv(pDest[i]);
           }
 

Modified: antargis/trunk/ext/video/ag_gltexture.cc
===================================================================
--- antargis/trunk/ext/video/ag_gltexture.cc	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/video/ag_gltexture.cc	2008-06-27 15:10:20 UTC (rev 1269)
@@ -255,6 +255,12 @@
   return d;
 }
 
+AGRect2 AGGLTexture::getRect() const
+{
+  return AGRect2(0,0,w,h);
+}
+
+
 AGSurface AGGLTexture::getSurface() const
 {
   AGSurface s(w,h*d);

Modified: antargis/trunk/ext/video/ag_gltexture.h
===================================================================
--- antargis/trunk/ext/video/ag_gltexture.h	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/video/ag_gltexture.h	2008-06-27 15:10:20 UTC (rev 1269)
@@ -55,6 +55,8 @@
   {
     return mTarget;
   }
+  
+  AGRect2 getRect() const;
 
 private:
 

Modified: antargis/trunk/ext/video/ag_texturecache.cc
===================================================================
--- antargis/trunk/ext/video/ag_texturecache.cc	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/video/ag_texturecache.cc	2008-06-27 15:10:20 UTC (rev 1269)
@@ -37,7 +37,7 @@
     getInstanceKiller()->reg(createKiller(this));
   }
 
-const AGTexture &AGTextureCache::get(const AGString &pTexture,const AGRect2 &pSub)
+const AGTexture &AGTextureCache::get(const AGString &pTexture,const AGRect2 &pSub) throw (FileNotFound)
   {
     std::string s=pTexture+":"+pSub.toString();
 
@@ -53,7 +53,7 @@
   }
 
 
-const AGTexture &AGTextureCache::get(const AGString &pTexture,int downScaleExp)
+const AGTexture &AGTextureCache::get(const AGString &pTexture,int downScaleExp) throw (FileNotFound)
   {
     std::map<AGString,AGTexture*>::iterator i=mTextures.find(pTexture);
     if(i==mTextures.end())
@@ -116,7 +116,7 @@
   }
 
 
-const AGTexture &AGTextureCache::get3D(const AGString &pTexture,int downScaleExp,int downScaleZ)
+const AGTexture &AGTextureCache::get3D(const AGString &pTexture,int downScaleExp,int downScaleZ) throw (FileNotFound)
   {
     std::map<AGString,AGTexture*>::iterator i=mTextures.find(pTexture);
     if(i==mTextures.end())

Modified: antargis/trunk/ext/video/ag_texturecache.h
===================================================================
--- antargis/trunk/ext/video/ag_texturecache.h	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/video/ag_texturecache.h	2008-06-27 15:10:20 UTC (rev 1269)
@@ -36,10 +36,10 @@
   {
     AGTextureCache();
   public:
-    const AGTexture &get(const AGString &pTextureFilename ,int downScaleExp=1);
-    const AGTexture &get3D(const AGString &pTextureFilename,int downScaleExp=1,int downScaleZ=1);
+    const AGTexture &get(const AGString &pTextureFilename ,int downScaleExp=1) throw (FileNotFound);
+    const AGTexture &get3D(const AGString &pTextureFilename,int downScaleExp=1,int downScaleZ=1) throw (FileNotFound);
 
-    const AGTexture &get(const AGString &pTextureFilename,const AGRect2 &pSub);
+    const AGTexture &get(const AGString &pTextureFilename,const AGRect2 &pSub) throw (FileNotFound);
   private:
     std::map<AGString,AGTexture*> mTextures;
     

Modified: antargis/trunk/ext/video/ag_video.cc
===================================================================
--- antargis/trunk/ext/video/ag_video.cc	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ext/video/ag_video.cc	2008-06-27 15:10:20 UTC (rev 1269)
@@ -89,12 +89,9 @@
       videoFlags|=SDL_DOUBLEBUF;
 
 
-    cdebug("SDL_Init...");
     // set video mode
     //  SDL_Init(SDL_INIT_VIDEO);
-    cdebug("SDL_SetVideoMode...");
     SDL_Surface *ms=SDL_SetVideoMode(w,h,videoInfo->vfmt->BitsPerPixel,videoFlags);
-    cdebug("ms:"<<ms);
     if(!ms)
       {
         std::cerr<<"Initing video mode failed!"<<std::endl;
@@ -121,8 +118,6 @@
     lastVWidth=vw;
     lastVHeight=vh;
 
-    cdebug("gl:"<<gl);
-
     if(gl)
       {
         AGGLScreen *ms=new AGGLScreen(w,h,vw,vh);
@@ -133,8 +128,6 @@
     else
       setScreen(mScreen=new AGSDLScreen(ms));
 
-    cdebug("mscreen:"<<mScreen);
-
     SDL_WM_SetCaption("Antargis","Antargis");
 
 

Added: antargis/trunk/games/copter/images/copter0.png
===================================================================
(Binary files differ)


Property changes on: antargis/trunk/games/copter/images/copter0.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: antargis/trunk/ruby/editor/campaign/drag_grid.rb
===================================================================
--- antargis/trunk/ruby/editor/campaign/drag_grid.rb	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ruby/editor/campaign/drag_grid.rb	2008-06-27 15:10:20 UTC (rev 1269)
@@ -686,7 +686,7 @@
 
 [DragGrid,DragSource,DragTrash,DragEnvironment,ToolBar,ToolButton,AppearEffect,HideEffect].each{|c|standardLayoutCreator(c)}
 
-require File.join(File.split(__FILE__)[0],'image_list.rb')
+require File.join(File.split(__FILE__)[0],'story_editor.rb')
 
 class RubySignal
   def initialize(name)

Added: antargis/trunk/ruby/editor/campaign/image_list.rb
===================================================================
--- antargis/trunk/ruby/editor/campaign/image_list.rb	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ruby/editor/campaign/image_list.rb	2008-06-27 15:10:20 UTC (rev 1269)
@@ -0,0 +1,96 @@
+class ImageList<AGWidget
+  def initialize(p,r,options)
+    super(p,r)
+    dir="data/gui/campaign"
+    files=getDirectory(dir).select{|f|f=~/\.png$/}.uniq
+    pp files
+    #exit
+    @images=files.map{|file|[file,AGTexture.new(AGSurface::load(File.join(dir,file)))]}
+    assert{@images.length>0}
+    @selected=2
+    @border=AGBorder.new("button.border.normal")
+    @pos=0
+  end
+  
+  def eventMouseButtonDown(e)
+    pp e.getButton
+    super
+  end
+  
+  def eventMouseMotion(e)
+    @pos=1-e.getMousePosition.x/width
+    pp @pos
+    super
+  end
+  
+  def draw(p)
+    rs=getRects
+    
+    
+    0.upto(rs.length-1){|i|
+      t=@images[3][1]
+      r=rs[i]+getScreenRect.getV0
+      f=t.getRect
+      pos=i.to_f/(rs.length)*0.5+ at pos-1
+      #pp pos
+      trisFrom=makeTriangles(f,AGTriangle2)
+      #trisTo=makeTriangles(r,AGTriangle3)
+      trisTo=makeTriangle(getScreenRect,pos,f)
+      (0..1).each{|j|
+        p.getTarget.blit3dTri(t,trisFrom[j],trisTo[j])
+      }
+      
+    }    
+  end
+  
+  def makeTriangle(drawRect,pos,fromRect)
+    pos01=(pos+1)*0.5
+    
+    height=drawRect.height*0.7
+    width=fromRect.width/fromRect.height*height
+    
+    centerx=drawRect.x+drawRect.width*pos01
+    lx=centerx-width*0.5
+    rx=centerx+width*0.5
+    f=0.5
+    y0=y1=height*f
+    f=0.3
+    dl=dr=0
+    
+    dr=pos if pos<0
+    dl=-pos if pos>0
+    
+    d1=[0,[y1,-height*(pos)*f].min].max
+    d0=[0,[y0,height*(pos)*f].min].max
+    pp d0,d1
+    
+    y1-=d1
+    y0-=d0
+    
+    y=drawRect.getMiddle.y
+    
+    vs=[AGVector3.new(lx,y+y0,dl),
+      AGVector3.new(lx,y-y0,dl),
+      AGVector3.new(rx,y-y1,dr),
+      AGVector3.new(rx,y+y1,dr),
+       ]
+    [AGTriangle3.new(vs[0],vs[1],vs[2]),AGTriangle3.new(vs[0],vs[2],vs[3])]
+  end
+  
+  def makeTriangles(r,type)
+    a=[r.getV0,r.getV10,r.getV1,r.getV01]
+    a=a.map{|v|AGVector3.new(v,0.0)} if type==AGTriangle3
+    [type.new(a[0],a[1],a[2]),type.new(a[0],a[2],a[3])]
+  end
+  
+  def getRects 
+    @rects||=genRects(@images.length)
+  end
+  
+  def genRects(count)
+    getRect.origin.tile(count,1).map{|r|r.shrink(5)}
+  end
+  
+end
+
+[ImageList].each{|c|standardLayoutCreator(c)}

Added: antargis/trunk/ruby/editor/campaign/image_list_2d.rb
===================================================================
--- antargis/trunk/ruby/editor/campaign/image_list_2d.rb	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ruby/editor/campaign/image_list_2d.rb	2008-06-27 15:10:20 UTC (rev 1269)
@@ -0,0 +1,78 @@
+class ImageList2D<AGWidget
+  
+  def initialize(p,r,options)
+    super(p,r)
+    
+    createSignal :sigSelected
+    dir="data/gui/campaign"
+    files=getDirectory(dir).select{|f|f=~/\.png$/}.uniq
+    pp files
+    #exit
+    @images=files.map{|file|[file,AGTexture.new(AGSurface::load(File.join(dir,file)))]}*3
+    assert{@images.length>0}
+    @selected=2
+    @border=AGBorder.new("button.border.normal")
+    @pos=0
+    
+    @imageHeight=height*0.7
+    @imageWidth=@imageHeight*1.3
+    @imageY=(height- at imageHeight)/2
+    @margin=20
+    @selected=2
+    @color=AGColor.new(0,0,0)
+  end
+  
+  def getImageByFilename(filename)
+    @images.select{|pair|pair[0]==filename}[0][1]
+  end
+  
+  def getFirstImage
+    @images[0][0]
+  end
+  
+  def eventMouseButtonDown(e)
+    super
+    true
+  end
+  
+  def eventMouseClick(e)
+    pos=e.getRelMousePosition
+    if getRect.origin.contains(pos)
+      i=0
+      getRects.each{|r|
+        if r.contains(pos)
+          @selected=i
+          sigSelected(*@images[i])
+          return true
+        end
+        i+=1
+      }
+      return true
+    end
+    super
+  end
+  
+  def draw(p)
+    i=0
+    getRects.each{|r|
+      imagePair=@images[i]
+      file,image=imagePair
+      from=image.getRect
+      p.setLineWidth(1)
+      if i==@selected
+        p.fillRect(r.grow(5), at color)
+        p.drawRect(r.grow(2),AGColor.new(0xFF,0xFF,0xFF))
+      end
+      p.blit(image,r,from)
+      
+      i+=1
+    }
+  end
+  
+  def getRects
+    (1.. at images.length).map{|x|@pos+(x-1)*(@imageWidth+ at margin)}.map{|x|AGRect2.new(x, at imageY, at imageWidth, at imageHeight)}
+  end
+  
+end
+
+[ImageList2D].each{|c|standardLayoutCreator(c)}

Added: antargis/trunk/ruby/editor/campaign/story_editor.rb
===================================================================
--- antargis/trunk/ruby/editor/campaign/story_editor.rb	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ruby/editor/campaign/story_editor.rb	2008-06-27 15:10:20 UTC (rev 1269)
@@ -0,0 +1,74 @@
+require File.join(File.split(__FILE__)[0],'image_list.rb')
+require File.join(File.split(__FILE__)[0],'image_list_2d.rb')
+
+StoryScreen=Struct.new(:imageFilename,:text)
+
+class StoryEditor<AGWidget
+  def initialize(p,r,options)
+    super(p,r)
+    @story=[]
+    layout=AGLayout.new(self)
+    layout.loadXML(loadFile("data/gui/layout/editor/campaign/story_editor.xml"))
+    addChild(layout)
+    
+    @image=getChild("image")
+    @imageList=getChild("imageList")
+    @imageList.sigSelected.connect(self,:eventImageSelected)
+    @next=getChild("next")
+    @prev=getChild("prev")
+    @edit=getChild("edit")
+    
+    @prev.setEnabled(false)
+    @story=[makeNewScreen]
+    
+    addHandler(@next,:sigClick,:eventNext)
+    addHandler(@prev,:sigClick,:eventPrev)
+    addHandler(@edit,:sigModified,:eventText)
+    @cursor=0
+  end
+  
+  def eventText(e)
+    @story[@cursor].text=@edit.getText
+    true
+  end
+  
+  def eventNext(e)
+    puts "NEXT"
+    @cursor+=1
+    @prev.setEnabled(true)
+    @story << makeNewScreen while @cursor>=@story.length
+    updateView
+    true
+  end
+  def eventPrev(e)
+    puts "PREV"
+    @cursor-=1
+    @prev.setEnabled(false) if @cursor==0 
+    updateView
+    true
+  end
+  
+  def eventImageSelected(file,texture)
+    @image.setTexture(texture)
+    @story[@cursor].imageFilename=file
+  end  
+  private
+  def makeNewScreen
+    StoryScreen.new(firstImage,AGStringUtf8.new(""))
+  end
+  def firstImage
+    @imageList.getFirstImage
+  end
+  
+  def updateView
+    screen=@story[@cursor]
+    @image.setTexture(getImage(screen.imageFilename))
+    @edit.setText(screen.text)
+    getChild("info").setText(AGStringUtf8.new("Page #{@cursor+1} of #{@story.length}"))
+  end
+  def getImage(filename)
+    @imageList.getImageByFilename(filename)
+  end
+end
+
+[StoryEditor].each{|c|standardLayoutCreator(c)}

Modified: antargis/trunk/ruby/gui/ag_tools.rb
===================================================================
--- antargis/trunk/ruby/gui/ag_tools.rb	2008-06-10 19:22:29 UTC (rev 1268)
+++ antargis/trunk/ruby/gui/ag_tools.rb	2008-06-27 15:10:20 UTC (rev 1269)
@@ -85,7 +85,7 @@
     end
     return super(e)
   end
-
+  
   private
   def makeHandlerName(object,event)
     #if object.respond_to?(:getName)



