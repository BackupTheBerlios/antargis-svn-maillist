From davidkamphausen at mail.berlios.de  Mon Mar  5 06:19:33 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Mon, 5 Mar 2007 06:19:33 +0100
Subject: [Antargis-svn] r1055 - in antargis/trunk: gui/src ruby src
Message-ID: <200703050519.l255JXfg019237@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-05 06:19:31 +0100 (Mon, 05 Mar 2007)
New Revision: 1055

Modified:
   antargis/trunk/gui/src/ag_frame.cc
   antargis/trunk/gui/src/ag_glpainter.cc
   antargis/trunk/gui/src/ag_glscreen.cc
   antargis/trunk/gui/src/ag_glscreen.h
   antargis/trunk/gui/src/ag_gradient.cc
   antargis/trunk/gui/src/ag_main.cc
   antargis/trunk/gui/src/ag_painter.cc
   antargis/trunk/gui/src/ag_string.h
   antargis/trunk/gui/src/ag_string_utf8.h
   antargis/trunk/gui/src/ag_texture.cc
   antargis/trunk/ruby/ant_fire.rb
   antargis/trunk/ruby/ant_house.rb
   antargis/trunk/ruby/map_generator2.rb
   antargis/trunk/src/glsl.cc
   antargis/trunk/src/glsl.h
   antargis/trunk/src/nantmarker.hh
   antargis/trunk/src/scene.cc
   antargis/trunk/src/scenenode.cc
   antargis/trunk/src/scenenode.h
   antargis/trunk/src/terrain.cc
   antargis/trunk/src/water.cc
Log:
* many bug-fixes
* improved map-generator
* fire will smoke after being turned out


Modified: antargis/trunk/gui/src/ag_frame.cc
===================================================================
--- antargis/trunk/gui/src/ag_frame.cc	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/gui/src/ag_frame.cc	2007-03-05 05:19:31 UTC (rev 1055)
@@ -3,14 +3,14 @@
 #include "ag_debug.h"
 
 AGFrame::AGFrame(AGWidget *pParent,const AGRect2 &pRect,size_t pWidth):AGWidget(pParent,pRect),
-								      mWidth(pWidth),mBorder(0),mTexture(width(),height())
+								       mWidth(pWidth),mBorder(0),mTexture((int)width(),(int)height())
 {
   mTextureInited=false;
   mUseTexture=true;
   mBg=0;
 }
 AGFrame::AGFrame(AGWidget *pParent,const AGRect2 &pRect,const AGBorder &pBorder):AGWidget(pParent,pRect),
-										 mWidth(pBorder.getWidth()),mBorder(new AGBorder(pBorder)),mTexture(width(),height())
+										 mWidth(pBorder.getWidth()),mBorder(new AGBorder(pBorder)),mTexture((int)width(),(int)height())
 {
   mTextureInited=false;
   mUseTexture=true;

Modified: antargis/trunk/gui/src/ag_glpainter.cc
===================================================================
--- antargis/trunk/gui/src/ag_glpainter.cc	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/gui/src/ag_glpainter.cc	2007-03-05 05:19:31 UTC (rev 1055)
@@ -271,7 +271,7 @@
     
     glBegin(GL_POINTS);
     
-    #warning "really +1 ????????????"
+    // #warning "really +1 ????????????"
     glVertex2f(x,y+1);
     
     glEnd();

Modified: antargis/trunk/gui/src/ag_glscreen.cc
===================================================================
--- antargis/trunk/gui/src/ag_glscreen.cc	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/gui/src/ag_glscreen.cc	2007-03-05 05:19:31 UTC (rev 1055)
@@ -47,6 +47,8 @@
 
 std::set<SDL_Surface *> glTestSurfaces;
 
+std::set<AGGLObject*> AGGLScreen::msObjects;
+
 #define SIMPLE
 
 
@@ -85,6 +87,35 @@
   SDL_GL_SwapBuffers();
 }
 
+////////////////////////////////////////////////////////////////////////
+// AGGLObject
+////////////////////////////////////////////////////////////////////////
+
+
+AGGLObject::AGGLObject()
+{
+  AGGLScreen::addGLObject(this);
+}
+
+AGGLObject::~AGGLObject()
+{
+  AGGLScreen::removeGLObject(this);
+}
+
+void AGGLObject::onScreenDown()
+{
+
+}
+
+void AGGLObject::onScreenUp()
+{
+}
+
+////////////////////////////////////////////////////////////////////////
+// AGGLScreen
+////////////////////////////////////////////////////////////////////////
+
+
 AGGLScreen::AGGLScreen(int W,int H,int VW,int VH):
   w(VW),h(VH),
   rw(W),rh(H)
@@ -135,7 +166,7 @@
 {
   AGSurface s(getWidth(),getHeight());
 
-  SDL_Surface *surface=s.surface()->surface;
+  //  SDL_Surface *surface=s.surface()->surface;
 
   unsigned char *buffer=new unsigned char[getWidth()*getHeight()*4];
   glReadBuffer(GL_FRONT);
@@ -160,8 +191,8 @@
     // copy
     TRACE;
     int h=getHeight()-1;
-    for(int x=0;x<getWidth();x++)
-      for(int y=0;y<getHeight();y++)
+    for(int x=0;x<(int)getWidth();x++)
+      for(int y=0;y<(int)getHeight();y++)
 	{
 	  unsigned char*p=buffer+((x+(h-y)*getWidth())*4);
 	  AGColor c(p[0],p[1],p[2],p[3]);
@@ -316,16 +347,29 @@
 }
 void AGGLScreen::clip(const AGRect2 &r)
 {
-  return;
+  //return;
 #warning "insert clipping facility for opengl"
 
   AGRect2 x=AGRect2(0,0,w,h);
   AGRect2 m=x.intersect(r);
 
+  GLint x0,y0,cw,ch;
+
+  x0=(GLint)m.x0();
+  y0=(GLint)(h-m.y1()); // -1
+  cw=(GLint)m.width();
+  ch=(GLint)m.height(); // +2
+
+  //  cdebug(x0<<";"<<y0<<";"<<cw<<";"<<ch);
+
+  glScissor(x0,y0,cw,ch);
+  /*
+
   glScissor((GLint)(m.x0()),
 	    (GLint)(h-1-m.y1()),
 	    (GLint)(m.width()),
 	    (GLint)(m.height()));
+  */
   assertGL;
   glEnable(GL_SCISSOR_TEST);
   assertGL;
@@ -342,7 +386,7 @@
   //  CTRACE;
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
-  glTranslatef(0,getHeight()+1,0);
+  glTranslatef(0,getHeight(),0);
   glScalef(1,-1,1);
 }
 
@@ -357,8 +401,29 @@
   mLineWidth=w;
 }
 
+void AGGLScreen::addGLObject(AGGLObject *pObject)
+{
+  msObjects.insert(pObject);
+}
 
+void AGGLScreen::removeGLObject(AGGLObject *pObject)
+{
+  msObjects.erase(pObject);
+}
 
+void AGGLScreen::screenDown()
+{
+  for(std::set<AGGLObject*>::iterator i=msObjects.begin();i!=msObjects.end();i++)
+    (*i)->onScreenDown();
+
+}
+void AGGLScreen::screenUp()
+{
+  for(std::set<AGGLObject*>::iterator i=msObjects.begin();i!=msObjects.end();i++)
+    (*i)->onScreenUp();
+}
+
+
 bool opengl()
 {
   return dynamic_cast<AGGLScreen*>(&getScreen());

Modified: antargis/trunk/gui/src/ag_glscreen.h
===================================================================
--- antargis/trunk/gui/src/ag_glscreen.h	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/gui/src/ag_glscreen.h	2007-03-05 05:19:31 UTC (rev 1055)
@@ -35,6 +35,16 @@
 
 typedef GLuint TextureID;
 
+class AGGLObject
+{
+ public:
+  AGGLObject();
+  virtual ~AGGLObject();
+
+  virtual void onScreenDown();
+  virtual void onScreenUp();
+};
+
 class AGGLScreen:public AGScreen
 {
  public:
@@ -83,6 +93,12 @@
 
   void setLineWidth(float w);
 
+  void screenDown();
+  void screenUp();
+
+  static void addGLObject(AGGLObject *pObject);
+  static void removeGLObject(AGGLObject *pObject);
+
  private:
   AGRect2 getRect(SDL_Surface *s);
   void checkUnusedTextures();
@@ -93,6 +109,8 @@
   float mLineWidth;
 
   friend class AGTexture;
+
+  static std::set<AGGLObject*> msObjects;
 };
 
 bool opengl();

Modified: antargis/trunk/gui/src/ag_gradient.cc
===================================================================
--- antargis/trunk/gui/src/ag_gradient.cc	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/gui/src/ag_gradient.cc	2007-03-05 05:19:31 UTC (rev 1055)
@@ -438,10 +438,10 @@
 
   for(int i=0;i<width;i++)
     {
-      sge_HLine(surface,r.x(),r.x()+r.w()-1,r.y(),uc1);
-      sge_HLine(surface,r.x(),r.x()+r.w()-1,r.y()+r.h()-1,uc2);
-      sge_VLine(surface,r.x(),r.y(),r.y()+r.h()-1,uc1);
-      sge_VLine(surface,r.x()+r.w()-1,r.y(),r.y()+r.h()-1,uc2);
+      sge_HLine(surface,(Sint16)r.x()          , (Sint16)(r.x()+r.w()-1), (Sint16)r.y(),          uc1);
+      sge_HLine(surface,(Sint16)r.x()          , (Sint16)(r.x()+r.w()-1), (Sint16)(r.y()+r.h()-1),uc2);
+      sge_VLine(surface,(Sint16)r.x()          , (Sint16)r.y(),           (Sint16)(r.y()+r.h()-1),uc1);
+      sge_VLine(surface,(Sint16)(r.x()+r.w()-1), (Sint16)r.y(),           (Sint16)(r.y()+r.h()-1),uc2);
       r=r.shrink(1);
     }
 }

Modified: antargis/trunk/gui/src/ag_main.cc
===================================================================
--- antargis/trunk/gui/src/ag_main.cc	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/gui/src/ag_main.cc	2007-03-05 05:19:31 UTC (rev 1055)
@@ -214,7 +214,12 @@
 
 
   if(mScreen)
-    delete mScreen;
+    {
+      AGGLScreen *ms=dynamic_cast<AGGLScreen*>(mScreen);
+      if(ms)
+	ms->screenDown();
+      delete mScreen;
+    }
 
   if(vw<w)
     vw=w;
@@ -227,7 +232,12 @@
   cdebug("gl:"<<gl);
 
   if(gl)
-    setScreen(mScreen=new AGGLScreen(w,h,vw,vh));
+    {
+      AGGLScreen *ms=new AGGLScreen(w,h,vw,vh);
+      ms->screenUp();
+
+      setScreen(mScreen=ms);
+    }
   else
     setScreen(mScreen=new AGSDLScreen(ms));
 

Modified: antargis/trunk/gui/src/ag_painter.cc
===================================================================
--- antargis/trunk/gui/src/ag_painter.cc	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/gui/src/ag_painter.cc	2007-03-05 05:19:31 UTC (rev 1055)
@@ -477,6 +477,7 @@
   STACKTRACE;
   AGRect2 d,pSrc;
   d=mCurrent.project(pDest);
+  // FIXME: remove clipRect !!
   AGRect2 p=mCurrent.clipRect(d);
   if(p.w()>0 && p.h()>0)
     {
@@ -493,7 +494,8 @@
   for(std::vector<std::pair<AGRect2,AGVector4> >::const_iterator i=pRects.begin();i!=pRects.end();++i)
     {
       AGRect2 d=mCurrent.project(i->first);
-      d=mCurrent.clipRect(d);
+      if(!opengl())
+	d=mCurrent.clipRect(d);
       if(d.w()>0 && d.h()>0)
 	rs.push_back(std::make_pair(d,i->second));
     }
@@ -564,6 +566,7 @@
 {
   mCurrent=ps.back();
   ps.pop_back();
+  mTarget->clip(mCurrent.clip);
 }
 void AGPainter::translate(const AGVector2 &v)
 {

Modified: antargis/trunk/gui/src/ag_string.h
===================================================================
--- antargis/trunk/gui/src/ag_string.h	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/gui/src/ag_string.h	2007-03-05 05:19:31 UTC (rev 1055)
@@ -26,9 +26,12 @@
   AGString(const char*c);
   AGString(const char*c,size_t size);
   
+#ifndef SWIG
   AGString &operator=(const AGString &s);
 
   AGString &operator+=(const AGString &p);
+#endif
+
   // size in UTF-8 characters
   //  size_t length() const;
 

Modified: antargis/trunk/gui/src/ag_string_utf8.h
===================================================================
--- antargis/trunk/gui/src/ag_string_utf8.h	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/gui/src/ag_string_utf8.h	2007-03-05 05:19:31 UTC (rev 1055)
@@ -16,13 +16,16 @@
   AGCharUtf8(const AGCharUtf8 &p);
   AGCharUtf8(AGStringUtf8 *ps,size_t ppos);
 
+  bool operator==(const AGCharUtf8 &c) const;
+  bool operator==(const char pChar) const;
+
+#ifndef SWIG
   AGCharUtf8 &operator=(const AGCharUtf8 &c);
   AGCharUtf8 &operator=(const AGStringUtf8 &c);
 
-  bool operator==(const AGCharUtf8 &c) const;
-  bool operator==(const char pChar) const;
   bool operator!=(const AGCharUtf8 &c) const;
   bool operator!=(const char pChar) const;
+#endif
   
 
   std::string getString() const;
@@ -72,8 +75,10 @@
   AGStringUtf8 &operator=(const AGStringUtf8 &s);
   AGStringUtf8 &operator=(const AGCharUtf8 &s);
 
+#ifndef SWIG
   AGStringUtf8 &operator+=(const AGStringUtf8 &p);
   AGStringUtf8 &operator+=(const AGCharUtf8 &p);
+#endif
   // size in UTF-8 characters
   size_t length() const;
 

Modified: antargis/trunk/gui/src/ag_texture.cc
===================================================================
--- antargis/trunk/gui/src/ag_texture.cc	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/gui/src/ag_texture.cc	2007-03-05 05:19:31 UTC (rev 1055)
@@ -246,6 +246,8 @@
   assert(!m3d);
   if(opengl())
     {
+      glDisable(GL_SCISSOR_TEST); // to make sure
+
       if(canFBO())
 	{
 	  //	  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
@@ -290,6 +292,7 @@
 	    blit(*this,getRect().origin(),getRect().origin());
 	  mCleared=false;
 	}
+      glDisable(GL_SCISSOR_TEST); // to make sure
     }
   else
     {

Modified: antargis/trunk/ruby/ant_fire.rb
===================================================================
--- antargis/trunk/ruby/ant_fire.rb	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/ruby/ant_fire.rb	2007-03-05 05:19:31 UTC (rev 1055)
@@ -6,7 +6,8 @@
 		mp=AGVector3.new(0,0,0)
 		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/fire.ant2",0.3,"data/textures/models/fire.png"),AGVector4.new(0,0,0),0)
 		setMesh(mesh)
-		addMesh(Smoke.new(getMap.getScene,4),mp)
+		@smokeMesh=Smoke.new(getMap.getScene,4)
+		addMesh(@smokeMesh,mp)
 		smoke=Smoke.new(getMap.getScene,40)
 		smoke.setFire(true)
 		smoke.setMaxTime(0.8)
@@ -16,6 +17,9 @@
 	end
 	def disable
 		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/fire.ant2",0.3,"data/textures/models/fire2.png"),AGVector4.new(0,0,0),0))
+		getMap.getScene.addNode(@smokeMesh) # FIXME: dirty hack - solve this another way!!!
+		addMesh(@smokeMesh,AGVector3.new(0,0,0))
+		@smokeMesh.setEnabled(false)
 		@enabled=false
 	end
 	def loadXML(n)

Modified: antargis/trunk/ruby/ant_house.rb
===================================================================
--- antargis/trunk/ruby/ant_house.rb	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/ruby/ant_house.rb	2007-03-05 05:19:31 UTC (rev 1055)
@@ -40,7 +40,7 @@
 class AntVillage
 	attr_reader :houses
 	def initialize(name,map)
-		@houses=map.getAllHousesOfVillage(name)		
+		@houses=map.getHousesOfVillage(name)		
 	end
 	def getTrooperCount
 		@houses.collect{|h|h.getMen.length}.inject{|a,b|a+b}

Modified: antargis/trunk/ruby/map_generator2.rb
===================================================================
--- antargis/trunk/ruby/map_generator2.rb	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/ruby/map_generator2.rb	2007-03-05 05:19:31 UTC (rev 1055)
@@ -542,7 +542,7 @@
 	myMap.erode([:rock])
 else
 	myMap.computeHeights(:veryrough)
-	myMap.blurHeights(20)
+	myMap.blurHeights(10)
 	myMap.computeHeights(:rough)
 	myMap.blurHeights(5)
 	myMap.computeDistances(:rock)

Modified: antargis/trunk/src/glsl.cc
===================================================================
--- antargis/trunk/src/glsl.cc	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/src/glsl.cc	2007-03-05 05:19:31 UTC (rev 1055)
@@ -102,27 +102,56 @@
 
 AntShaderProgram::AntShaderProgram(const std::string &pVertexFile,const std::string &pFragFile):
   //  vertex(getVertexProgram(pVertexFile)),frag(getFragProgram(pFragFile))
-  vertex(pVertexFile),frag(pFragFile)
+  mVertexFile(pVertexFile),mFragFile(pFragFile),
+  vertex(0),frag(0)
 {
   //  CTRACE;
-  if(glslOk())
+  on=false;
+  matrixBuf=new float[16*100];
+  name=pVertexFile+":"+pFragFile;
+
+  init();
+}
+
+AntShaderProgram::~AntShaderProgram()
+{
+  takeDown();
+
+  delete [] matrixBuf;
+}
+
+void AntShaderProgram::onScreenUp()
+{
+  CTRACE;
+  init();
+}
+void AntShaderProgram::onScreenDown()
+{
+  CTRACE;
+  takeDown();
+}
+
+
+void AntShaderProgram::init()
+{
+ if(glslOk())
     {
+      vertex=new AntVertexProgram(mVertexFile);
+      frag=new AntFragProgram(mFragFile);
+
       p = glCreateProgramObjectARB();
-      glAttachObjectARB(p,vertex.vertexShader);
-      if(frag.valid())
-	glAttachObjectARB(p,frag.fragShader);
+      glAttachObjectARB(p,vertex->vertexShader);
+      if(frag->valid())
+	glAttachObjectARB(p,frag->fragShader);
       
       glLinkProgramARB(p);
       printInfoLog(p);
 
       assert(p);
     }
-  on=false;
-  matrixBuf=new float[16*100];
-  name=pVertexFile+":"+pFragFile;
 }
 
-AntShaderProgram::~AntShaderProgram()
+void AntShaderProgram::takeDown()
 {
   disable();
   CTRACE;
@@ -130,11 +159,13 @@
   if(glslOk() && !hasQuit())
     glDeleteObjectARB(p);
   cdebug("name:"<<name);
-  delete [] matrixBuf;
   cdebug("name:"<<name);
+  delete vertex;
+  delete frag;
 }
 
 
+
 void AntShaderProgram::enable()
 {
   if(glslOk())

Modified: antargis/trunk/src/glsl.h
===================================================================
--- antargis/trunk/src/glsl.h	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/src/glsl.h	2007-03-05 05:19:31 UTC (rev 1055)
@@ -4,6 +4,7 @@
 #include "ant_renderer.h"
 #include "ag_tools.h"
 #include "ag_geometry.h"
+#include "ag_glscreen.h"
 
 #include <map>
 
@@ -44,15 +45,17 @@
   
 };
 
-class AntShaderProgram
+class AntShaderProgram:public AGGLObject
 {
-  AntVertexProgram vertex;
-  AntFragProgram frag;
+  std::string mVertexFile,mFragFile;
+  AntVertexProgram *vertex;
+  AntFragProgram *frag;
   std::map<std::string,GLint> locations;
   std::map<std::string,GLint> attrs;
   float *matrixBuf;
   bool on;
   std::string name;
+
  protected:  
   GLhandleARB p;
 
@@ -76,6 +79,16 @@
   void sendUniform(const std::string &pName,const std::vector<AGMatrix4> &m);
 
   void sendAttribute(const std::string &pName,const std::vector<float> &vf);
+
+  void onScreenUp();
+  void onScreenDown();
+
+
+ private:
+  void check();
+  void init();
+  void takeDown();
+
 };
 
 class AntShadowShader:public AntShaderProgram

Modified: antargis/trunk/src/nantmarker.hh
===================================================================
--- antargis/trunk/src/nantmarker.hh	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/src/nantmarker.hh	2007-03-05 05:19:31 UTC (rev 1055)
@@ -328,7 +328,7 @@
 	result->mRubyObject=true;
 }
 %markfunc PathWeighter "general_markfunc"
-%exception AntMap::AntMap {
+%exception MiniMap::MiniMap {
 	$action
 	result->mRUBY=self;
 #ifdef GCDEBUG
@@ -337,8 +337,8 @@
 #endif
 	result->mRubyObject=true;
 }
-%markfunc AntMap "general_markfunc"
-%exception AGMenu::AGMenu {
+%markfunc MiniMap "general_markfunc"
+%exception AntMap::AntMap {
 	$action
 	result->mRUBY=self;
 #ifdef GCDEBUG
@@ -347,8 +347,8 @@
 #endif
 	result->mRubyObject=true;
 }
-%markfunc AGMenu "general_markfunc"
-%exception MiniMap::MiniMap {
+%markfunc AntMap "general_markfunc"
+%exception AGMenu::AGMenu {
 	$action
 	result->mRUBY=self;
 #ifdef GCDEBUG
@@ -357,7 +357,7 @@
 #endif
 	result->mRubyObject=true;
 }
-%markfunc MiniMap "general_markfunc"
+%markfunc AGMenu "general_markfunc"
 %exception AGColorButton::AGColorButton {
 	$action
 	result->mRUBY=self;
@@ -936,10 +936,10 @@
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadioGroup,0);
 else if(dynamic_cast<AGWindow*>(result))
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
+else if(dynamic_cast<MiniMap*>(result))
+  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
 else if(dynamic_cast<AGMenu*>(result))
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
-else if(dynamic_cast<MiniMap*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
 else if(dynamic_cast<AGColorButton*>(result))
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
 else if(dynamic_cast<AGImage*>(result))
@@ -996,10 +996,10 @@
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRadioGroup,0);
 else if(dynamic_cast<AGWindow*>($1))
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGWindow,0);
+else if(dynamic_cast<MiniMap*>($1))
+  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MiniMap,0);
 else if(dynamic_cast<AGMenu*>($1))
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenu,0);
-else if(dynamic_cast<MiniMap*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MiniMap,0);
 else if(dynamic_cast<AGColorButton*>($1))
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGColorButton,0);
 else if(dynamic_cast<AGImage*>($1))
@@ -1432,10 +1432,10 @@
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
 else if(dynamic_cast<AntMap*>(result))
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntMap,0);
+else if(dynamic_cast<MiniMap*>(result))
+  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
 else if(dynamic_cast<AGMenu*>(result))
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
-else if(dynamic_cast<MiniMap*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
 else if(dynamic_cast<AGColorButton*>(result))
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
 else if(dynamic_cast<AGImage*>(result))
@@ -1502,10 +1502,10 @@
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGWindow,0);
 else if(dynamic_cast<AntMap*>($1))
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntMap,0);
+else if(dynamic_cast<MiniMap*>($1))
+  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MiniMap,0);
 else if(dynamic_cast<AGMenu*>($1))
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenu,0);
-else if(dynamic_cast<MiniMap*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MiniMap,0);
 else if(dynamic_cast<AGColorButton*>($1))
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGColorButton,0);
 else if(dynamic_cast<AGImage*>($1))
@@ -2368,10 +2368,10 @@
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGWindow,0);
 else if(dynamic_cast<AntMap*>(result))
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntMap,0);
+else if(dynamic_cast<MiniMap*>(result))
+  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
 else if(dynamic_cast<AGMenu*>(result))
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
-else if(dynamic_cast<MiniMap*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
 else if(dynamic_cast<AGColorButton*>(result))
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
 else if(dynamic_cast<AGImage*>(result))
@@ -2440,10 +2440,10 @@
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGWindow,0);
 else if(dynamic_cast<AntMap*>($1))
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntMap,0);
+else if(dynamic_cast<MiniMap*>($1))
+  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MiniMap,0);
 else if(dynamic_cast<AGMenu*>($1))
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenu,0);
-else if(dynamic_cast<MiniMap*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MiniMap,0);
 else if(dynamic_cast<AGColorButton*>($1))
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGColorButton,0);
 else if(dynamic_cast<AGImage*>($1))
@@ -2694,6 +2694,11 @@
  Data_Get_Struct($input,AGFontEngine,b);
  $result=*b;
 }
+%typemap(directorout) AGGLObject {
+ AGGLObject *b;
+ Data_Get_Struct($input,AGGLObject,b);
+ $result=*b;
+}
 %typemap(directorout) AGGLScreen {
  AGGLScreen *b;
  Data_Get_Struct($input,AGGLScreen,b);

Modified: antargis/trunk/src/scene.cc
===================================================================
--- antargis/trunk/src/scene.cc	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/src/scene.cc	2007-03-05 05:19:31 UTC (rev 1055)
@@ -151,6 +151,8 @@
 {
   if(mNodeSet.find(node)==mNodeSet.end())
     {
+      node->setScene(this);
+
       mNodes.push_back(node);
       mNodeSet.insert(node);
       assert(node->getScene()==this);

Modified: antargis/trunk/src/scenenode.cc
===================================================================
--- antargis/trunk/src/scenenode.cc	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/src/scenenode.cc	2007-03-05 05:19:31 UTC (rev 1055)
@@ -28,6 +28,13 @@
     mScene->removeNode(this);
 }
 
+void SceneNode::setScene(Scene *pScene)
+{
+  assert(mScene==0 || mScene==pScene);
+  mScene=pScene;
+}
+
+
 /// release attaching to scene
 void SceneNode::resetScene()
 {

Modified: antargis/trunk/src/scenenode.h
===================================================================
--- antargis/trunk/src/scenenode.h	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/src/scenenode.h	2007-03-05 05:19:31 UTC (rev 1055)
@@ -80,6 +80,8 @@
   int getOrder() const;
   
  private:
+  void setScene(Scene *pScene);
+
   int mOrder;
 
   Scene *mScene;
@@ -87,6 +89,8 @@
 
   AGVector4 mPos;
   AGBox3 mBBox;
+
+  friend class Scene;
 };
 
 typedef SceneNode *SceneNodePtr;

Modified: antargis/trunk/src/terrain.cc
===================================================================
--- antargis/trunk/src/terrain.cc	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/src/terrain.cc	2007-03-05 05:19:31 UTC (rev 1055)
@@ -128,6 +128,8 @@
 
 void TerrainPiece::draw()
 {
+  assertGL;
+
   STACKTRACE;
   AGRenderContext c;
   c.setLighting(true);
@@ -137,6 +139,7 @@
   c.begin();
 
   m3dArray.draw();
+  assertGL;
 }
 
 

Modified: antargis/trunk/src/water.cc
===================================================================
--- antargis/trunk/src/water.cc	2007-02-25 18:29:35 UTC (rev 1054)
+++ antargis/trunk/src/water.cc	2007-03-05 05:19:31 UTC (rev 1055)
@@ -100,6 +100,7 @@
 void WaterPiece::draw()
 {
   STACKTRACE;
+  assertGL;
 
   AGRenderContext c;
   c.setAlpha(0,GL_NONE);
@@ -118,6 +119,7 @@
   mArray.draw();
   if(useWaterAnimation())
     getWaterShader()->disable();
+  assertGL;
 }
 
 void WaterPiece::drawPick()
@@ -129,7 +131,9 @@
 
 void WaterPiece::advance(float t)
 {
+  assertGL;
   getWaterShader()->update(t);
+  assertGL;
 }
 
 size_t WaterPiece::getTriangles() const



From davidkamphausen at mail.berlios.de  Thu Mar  8 21:11:11 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Thu, 8 Mar 2007 21:11:11 +0100
Subject: [Antargis-svn] r1056 - in antargis/trunk: . gui/src ruby
Message-ID: <200703082011.l28KBB0f006303@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-08 21:11:04 +0100 (Thu, 08 Mar 2007)
New Revision: 1056

Modified:
   antargis/trunk/TODO
   antargis/trunk/gui/src/ag_application.cc
   antargis/trunk/gui/src/ag_application.h
   antargis/trunk/gui/src/ag_messageobject.cc
   antargis/trunk/gui/src/ag_texture.cc
   antargis/trunk/ruby/ant_arrow.rb
   antargis/trunk/ruby/ant_bakery.rb
   antargis/trunk/ruby/ant_boat.rb
   antargis/trunk/ruby/ant_boss.rb
   antargis/trunk/ruby/ant_buildingsite.rb
   antargis/trunk/ruby/ant_config.rb
   antargis/trunk/ruby/ant_debug.rb
   antargis/trunk/ruby/ant_decal.rb
   antargis/trunk/ruby/ant_deco.rb
   antargis/trunk/ruby/ant_druid.rb
   antargis/trunk/ruby/ant_dwelling.rb
   antargis/trunk/ruby/ant_energy.rb
   antargis/trunk/ruby/ant_farm.rb
   antargis/trunk/ruby/ant_field.rb
   antargis/trunk/ruby/ant_fir.rb
   antargis/trunk/ruby/ant_fire.rb
   antargis/trunk/ruby/ant_fish.rb
   antargis/trunk/ruby/ant_fishing_hut.rb
   antargis/trunk/ruby/ant_formations.rb
   antargis/trunk/ruby/ant_grass.rb
   antargis/trunk/ruby/ant_hero.rb
   antargis/trunk/ruby/ant_hljobs.rb
   antargis/trunk/ruby/ant_house.rb
   antargis/trunk/ruby/ant_inventory.rb
   antargis/trunk/ruby/ant_local.rb
   antargis/trunk/ruby/ant_man.rb
   antargis/trunk/ruby/ant_manbase.rb
   antargis/trunk/ruby/ant_messagebox.rb
   antargis/trunk/ruby/ant_mill.rb
   antargis/trunk/ruby/ant_mine.rb
   antargis/trunk/ruby/ant_pcplayer.rb
   antargis/trunk/ruby/ant_player.rb
   antargis/trunk/ruby/ant_ring.rb
   antargis/trunk/ruby/ant_sack.rb
   antargis/trunk/ruby/ant_sheep.rb
   antargis/trunk/ruby/ant_sound.rb
   antargis/trunk/ruby/ant_stone.rb
   antargis/trunk/ruby/ant_tools.rb
   antargis/trunk/ruby/ant_tower.rb
   antargis/trunk/ruby/ant_townhall.rb
   antargis/trunk/ruby/ant_tree.rb
   antargis/trunk/ruby/ant_trigger.rb
   antargis/trunk/ruby/ant_well.rb
   antargis/trunk/ruby/ant_wolf.rb
   antargis/trunk/ruby/ant_workshop.rb
   antargis/trunk/ruby/antargis.rb
   antargis/trunk/ruby/antargislib.rb
   antargis/trunk/ruby/campaign.rb
   antargis/trunk/ruby/dialogs.rb
   antargis/trunk/ruby/editview.rb
   antargis/trunk/ruby/ents.rb
   antargis/trunk/ruby/intro.rb
   antargis/trunk/ruby/mainmenu.rb
   antargis/trunk/ruby/map.rb
   antargis/trunk/ruby/mpmap.rb
Log:
* include demo recording
* many fixes


Modified: antargis/trunk/TODO
===================================================================
--- antargis/trunk/TODO	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/TODO	2007-03-08 20:11:04 UTC (rev 1056)
@@ -56,11 +56,7 @@
 
 [Segfaults]
 ------------------------------------------------------
-[M] a segfault appears when profiling with ruby (./run --profile)
-		couldn't find the problem yet. it's probably one of these problems:
-		1) some GC-problem
-		2) some ruby-error (?) within version 1.8.4
-		workaround done: simply disable gc nearly all the time
+None known.
 
 [AI]
 ------------------------------------------------------
@@ -72,7 +68,7 @@
 ------------------------------------------------------
 [H] fix texture-painting on GeForce - backgrounds are always black, but they should be transparent (like FPS-display)
 [M] add texture-space-saving
-[L] add Framebuffer objects for paint to texture.
+[L] add Framebuffer objects for paint to texture. -- still buggy ????
 [L] fix AGMenu*. This is broken, but not used ATM.
 [L] rewrite AGEdit - without AGEditLines
 		In AGEdit2 is a beginning of a rewrite. But it's a kind of crappy approach. AGEdit2 should
@@ -86,8 +82,10 @@
 
 [Graphics - 3d-engine]
 ------------------------------------------------------
-[H] game crashes when toggling fullscreen (in game)
-[H] check for GLEE_texture_3D extension or gl>1.3 or what support
+[H] use AGGLWidget instead of GLApp - include generic AGApp
+
+
+[H] game crashes when toggling fullscreen (in game) -- FIXED ???? CHECK ON WINDOWS
 [H] try using GL_DYNAMIC_DRAW_ARB for dynamic vertexarrays and combine multiple meshes some how?
 [M] add support for non-3d-texture-graphic cards
 [M] increase picking speed => use kd-tree or bsp
@@ -111,9 +109,6 @@
 
 [H] wolves should attack people
 
-[?] Rowen dies too fast of starvation when fighting
-[?] Rowen surrenders and does not die when fighting stoner's keep in testai
-
 [H] continue buildingsite function => check if already claimed
 [H] fetching in house (testai) - tries to go through water - maybe move fetching code to some common module
 
@@ -143,8 +138,6 @@
 		So the AntApp must be finished and the surrounding campaign-code, too. After this the
 		loaded campaign must be started.
 [L] add aggression-leveling of non-hero bosses
-[L] story-telling:
-	- browsing facility (scene=>number(person)=>text)
 [L] add wolf, fish, bird
 [L] single games - add village generator to map generator
 [L] single games - add some menu for options
@@ -152,6 +145,8 @@
 
 [VL] very bad situation => raise heroes with a new player (rebellion)
 [VL] add females
+[VL] story-telling:
+	- browsing facility (scene=>number(person)=>text)
 
 [Artificial Intelligence]
 ------------------------------------------------------
@@ -181,7 +176,6 @@
 [Packaging / Building]
 ------------------------------------------------------
 [L] installer for linux. maybe some autopackage or .debs?
-[VH] remove she-bangs here as in 0.1.9 tag
 
 
 DOCUMENTATION

Modified: antargis/trunk/gui/src/ag_application.cc
===================================================================
--- antargis/trunk/gui/src/ag_application.cc	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/gui/src/ag_application.cc	2007-03-08 20:11:04 UTC (rev 1056)
@@ -53,6 +53,7 @@
       setCursor(getTextureCache()->get("blue_cursor.png"));
       setNormalCursor();
     }
+  mDemoTime=-1;
 }
 
 AGApplication::~AGApplication()
@@ -152,10 +153,20 @@
 	    doEvent(&event);
 	    }*/
 
-	t=(now-last)/1000.0;
+	if(mDemoTime>0)
+	  {
+	    t=mDemoTime;
+	    mDemoTime=-1;
+	  }
+	else
+	  {
+	    t=(now-last)/1000.0;
+	  }
 	if(mainWidget)
 	  mainWidget->sigTick(t);
 	
+	eventPrepareFrame(t);
+
 	eventFrame(t);
       }
       {
@@ -179,6 +190,12 @@
   return true;
 }
 
+void AGApplication::setDemoTime(float t)
+{
+  mDemoTime=t;
+}
+
+
 SDL_Event AGApplication::getNewEvent()
 {
   SDL_Event mEvent;
@@ -386,6 +403,12 @@
 {
 }
 
+bool AGApplication::eventPrepareFrame(float pTime)
+{
+  return false;
+}
+
+
 bool AGApplication::eventFrame(float pTime)
 {
   return false;
@@ -471,3 +494,8 @@
   delete mCursor;
   mCursor=0;
 }
+
+bool AGApplication::hardwareCursor() const
+{
+  return mCursor==0;
+}

Modified: antargis/trunk/gui/src/ag_application.h
===================================================================
--- antargis/trunk/gui/src/ag_application.h	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/gui/src/ag_application.h	2007-03-08 20:11:04 UTC (rev 1056)
@@ -83,6 +83,9 @@
 
   /// called in each frame when idling
   virtual bool eventIdle();           
+
+  virtual bool eventPrepareFrame(float pTime);
+
   /// called between event-handling and drawing
   virtual bool eventFrame(float pTime);
   /// called after drawing - so before event handling
@@ -116,10 +119,13 @@
 
   void setCursor(const AGTexture &pTexture);
   void setNormalCursor();
+  bool hardwareCursor() const;
 
   virtual SDL_Event getNewEvent();
 
   void setKeyRepeat(bool enable);
+
+  void setDemoTime(float t);
   
  private:
   void clearOldMousePosition();
@@ -142,6 +148,8 @@
 
   SDL_Event mEvent;
 
+  float mDemoTime;
+
  public:
   void mark();
 };

Modified: antargis/trunk/gui/src/ag_messageobject.cc
===================================================================
--- antargis/trunk/gui/src/ag_messageobject.cc	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/gui/src/ag_messageobject.cc	2007-03-08 20:11:04 UTC (rev 1056)
@@ -628,6 +628,11 @@
     {
       event.type=SDL_QUIT;
     }
+  else
+    {
+      event.type=SDL_NOEVENT;
+      return &event;
+    }
   if(event.type)
     return &event;
 

Modified: antargis/trunk/gui/src/ag_texture.cc
===================================================================
--- antargis/trunk/gui/src/ag_texture.cc	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/gui/src/ag_texture.cc	2007-03-08 20:11:04 UTC (rev 1056)
@@ -382,8 +382,8 @@
 
 void AGTexture::blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc)
 {
-  if(gUsedTexMemory>20000000)
-    throw int();
+  //  if(gUsedTexMemory>20000000)
+  //    throw int();
 
 
   if(opengl())

Modified: antargis/trunk/ruby/ant_arrow.rb
===================================================================
--- antargis/trunk/ruby/ant_arrow.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_arrow.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #

Modified: antargis/trunk/ruby/ant_bakery.rb
===================================================================
--- antargis/trunk/ruby/ant_bakery.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_bakery.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,6 +1,3 @@
-#!/usr/bin/env ruby
-
-
 #FIXME
 
 class AntBakery<AntHouse

Modified: antargis/trunk/ruby/ant_boat.rb
===================================================================
--- antargis/trunk/ruby/ant_boat.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_boat.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 def getBoatMeshData
 	getMeshData("data/models/boat_simple.ant2",0.12,"data/textures/models/boat_simple.png")
 end

Modified: antargis/trunk/ruby/ant_boss.rb
===================================================================
--- antargis/trunk/ruby/ant_boss.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_boss.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 require 'ents.rb'
 require 'ant_hljobs.rb'
 require 'ant_formations.rb'
@@ -55,7 +52,17 @@
 					@job=AntHeroMoveJob.new(self,0,AGVector2.new(0,0),0)
 				when "AntHeroRestJob"
 					@job=AntHeroRestJob.new(self,10)
+				when "AntHeroRecruitJob"
+					target=n.getChildren.select{|c|c.get("name")=="@target"}[0]
+					if target
+						target=getMap.getByUID(target.get("value"))
+					
+						@job=AntHeroRecruitJob.new(self,target)
+					else
+						raise "target missing in saved AntHeroRecruitJob"
+					end
 				else
+					# FIXME!!!
 					raise "unknown job: #{t}"
 			end
 			@job.loadXML(n)

Modified: antargis/trunk/ruby/ant_buildingsite.rb
===================================================================
--- antargis/trunk/ruby/ant_buildingsite.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_buildingsite.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,6 +1,4 @@
-#!/usr/bin/env ruby
 
-
 class AntBuildingSite<AntRubyEntity
 	attr_accessor :building
 	def initialize

Modified: antargis/trunk/ruby/ant_config.rb
===================================================================
--- antargis/trunk/ruby/ant_config.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_config.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,6 +18,4 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 YEAR=60 # one second
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_debug.rb
===================================================================
--- antargis/trunk/ruby/ant_debug.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_debug.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 $debug||=false
 if $debug
 	module Kernel

Modified: antargis/trunk/ruby/ant_decal.rb
===================================================================
--- antargis/trunk/ruby/ant_decal.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_decal.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 class AntDecal<AntRubyEntity
 	def initialize()
 		super(AGVector2.new(0,0))

Modified: antargis/trunk/ruby/ant_deco.rb
===================================================================
--- antargis/trunk/ruby/ant_deco.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_deco.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 class AntDeco<AntRubyEntity
 	def initialize(decoType=nil)
 		super(AGVector2.new(0,0))

Modified: antargis/trunk/ruby/ant_druid.rb
===================================================================
--- antargis/trunk/ruby/ant_druid.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_druid.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,6 +1,3 @@
-#!/usr/bin/env ruby
-
-
 class AntNPC<AntRubyEntity
 	attr_accessor :npcType
 	def initialize()

Modified: antargis/trunk/ruby/ant_dwelling.rb
===================================================================
--- antargis/trunk/ruby/ant_dwelling.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_dwelling.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 BIRTHING_TIME=80
 MAX_RESIDENTS=10
 

Modified: antargis/trunk/ruby/ant_energy.rb
===================================================================
--- antargis/trunk/ruby/ant_energy.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_energy.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 # Inventory view
 class AntEnergy<AGWidget
 	attr_accessor :hborder

Modified: antargis/trunk/ruby/ant_farm.rb
===================================================================
--- antargis/trunk/ruby/ant_farm.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_farm.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 # A farm produces food, uses men and tools
 #
 # so

Modified: antargis/trunk/ruby/ant_field.rb
===================================================================
--- antargis/trunk/ruby/ant_field.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_field.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 class AntField<AntRubyEntity
 	attr_accessor :farm
 	def initialize

Modified: antargis/trunk/ruby/ant_fir.rb
===================================================================
--- antargis/trunk/ruby/ant_fir.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_fir.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 #require 'fir_mesh.rb'
 
 # really nothing special here - just a "grouper"

Modified: antargis/trunk/ruby/ant_fire.rb
===================================================================
--- antargis/trunk/ruby/ant_fire.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_fire.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 class AntFire<AntRubyEntity
 	def initialize(p=AGVector2.new(0,0))
 		super

Modified: antargis/trunk/ruby/ant_fish.rb
===================================================================
--- antargis/trunk/ruby/ant_fish.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_fish.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 def getFishMeshData
 	getMeshData("data/models/fish.ant2",0.02,"data/textures/models/fish.png")
 end

Modified: antargis/trunk/ruby/ant_fishing_hut.rb
===================================================================
--- antargis/trunk/ruby/ant_fishing_hut.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_fishing_hut.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,6 +1,4 @@
-#!/usr/bin/env ruby
 
-
 class AntFishingHut<AntHouse
 	def initialize
 		super

Modified: antargis/trunk/ruby/ant_formations.rb
===================================================================
--- antargis/trunk/ruby/ant_formations.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_formations.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #

Modified: antargis/trunk/ruby/ant_grass.rb
===================================================================
--- antargis/trunk/ruby/ant_grass.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_grass.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 
 def getGrassMeshData(size,many=4,texture=nil,bush=false)
 	size=(size*10).to_i/10.0

Modified: antargis/trunk/ruby/ant_hero.rb
===================================================================
--- antargis/trunk/ruby/ant_hero.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_hero.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 require 'ents.rb'
 require 'ant_hljobs.rb'
 require 'ant_boss.rb'
@@ -132,20 +129,20 @@
 		assignJob2All
 	end
 	def newHLRecruitJob(target)
-		@job=AntHeroRecruitJob.new(self,target,getAggression)
+		@job=AntHeroRecruitJob.new(self,target)
 		assignJob2All
 	end
 	def newHLConstructJob(target)
-		@job=AntHeroConstructJob.new(self,target,getAggression)
+		@job=AntHeroConstructJob.new(self,target)
 		assignJob2All
 	end
 	def newHLTakeFoodJob(target)
 		puts "take food job #{self} #{target}"
-		@job=AntHeroTakeJob.new(self,target,getAggression,"food")
+		@job=AntHeroTakeJob.new(self,target,"food")
 		assignJob2All
 	end
 	def newHLTakeWeaponJob(target)
-		@job=AntHeroTakeJob.new(self,target,getAggression,"weapon")
+		@job=AntHeroTakeJob.new(self,target,"weapon")
 		assignJob2All
 	end
 	def newHLFightJob(target)

Modified: antargis/trunk/ruby/ant_hljobs.rb
===================================================================
--- antargis/trunk/ruby/ant_hljobs.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_hljobs.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -60,6 +60,12 @@
 						c.set("type","AGVector2s")
 						value=value.collect{|v|v.to_s}.join(":")
 					end
+				when Hash
+					c.set("type","HashEntities")
+					value=value.collect{|k,v|
+						k.uid.to_s+"="+v.uid.to_s
+					}.join("&")
+					
 				when Fixnum,Float,TrueClass,FalseClass
 					c.set("type",value.class.to_s)
 				when AGVector2
@@ -68,8 +74,9 @@
 					# do nothing
 					c.set("type","String")
 				else
+					puts "UNKNOWN TYPE:#{value} #{value.class} #{name}"
+					
 					value=AntMarshal.dump(value)
-					puts "UNKNOWN TYPE:#{value} #{value.class} #{name}"
 					raise 1
 			end
 			puts "#{value} #{name}"
@@ -89,6 +96,16 @@
 				case c.get("type")
 					when "AntEntity"
 						value=getMap.getByUID(value.to_i)
+					when "HashEntities"
+						vs={}
+						value=value.split("&").each{|s|
+							k,v=s.split("=").collect{|u|getMap.getByUID(u.to_i)}
+							#puts "K:#{k} V:#{v}"
+							vs[k]=v
+						}
+						#puts vs,vs.class
+						#raise 1
+						value=vs
 					when "AntEntities"
 						value=value.split(",").collect{|v|getMap.getByUID(v)}
 					when "AGVector2"
@@ -625,11 +642,10 @@
 	include AntHeroSitting
 
 	attr_reader :finished
-	def initialize(hero,target,agg)
+	def initialize(hero,target)
 		@target=target
-		@aggression=agg
 		@targetMen=target.menCount
-		@want=@targetMen*agg/3
+		@want=@targetMen*hero.getAggression/3
 		@finished=false
 		@restingMen=0
 		@wantedMen=@want.to_i
@@ -714,11 +730,10 @@
 
 class AntHeroTakeJob<AntHeroMoveJob
 	attr_reader :finished
-	def initialize(hero,target,agg,what="food")
+	def initialize(hero,target,what="food")
 		super(hero,0,target.getPos2D,4)
 		@what=what
 		@target=target
-		@aggression=agg
 		@want=@men
 		@oldpos=nil
 		@takeStarted=false
@@ -805,7 +820,7 @@
 
 class AntHeroConstructJob<AntHeroMoveJob
 	attr_reader :finished
-	def initialize(hero,target,agg)
+	def initialize(hero,target)
 		super(hero,0,target.getPos2D,4)
 		@target=target
 		@usedmen=0

Modified: antargis/trunk/ruby/ant_house.rb
===================================================================
--- antargis/trunk/ruby/ant_house.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_house.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 require 'ant_boss.rb'
 require 'ant_tools.rb'
 

Modified: antargis/trunk/ruby/ant_inventory.rb
===================================================================
--- antargis/trunk/ruby/ant_inventory.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_inventory.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 # Inventory view
 class AntInventory<AGWidget
 	@@inventory=nil

Modified: antargis/trunk/ruby/ant_local.rb
===================================================================
--- antargis/trunk/ruby/ant_local.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_local.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 #
 #
 #

Modified: antargis/trunk/ruby/ant_man.rb
===================================================================
--- antargis/trunk/ruby/ant_man.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_man.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 require 'ant_manbase.rb'
 require 'ant_config.rb'
 

Modified: antargis/trunk/ruby/ant_manbase.rb
===================================================================
--- antargis/trunk/ruby/ant_manbase.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_manbase.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,9 +18,7 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
 
-
 # AntAngle is an entity for displaying angels flying up
 # when an AntMan dies. This is currently not supported, because
 # there is no AntAngel mesh.

Modified: antargis/trunk/ruby/ant_messagebox.rb
===================================================================
--- antargis/trunk/ruby/ant_messagebox.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_messagebox.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 class MessageBox<AntDialog
 	include AGHandler
 

Modified: antargis/trunk/ruby/ant_mill.rb
===================================================================
--- antargis/trunk/ruby/ant_mill.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_mill.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,6 +1,3 @@
-#!/usr/bin/env ruby
-
-
 class AntMill<AntHouse
 	def initialize
 		super

Modified: antargis/trunk/ruby/ant_mine.rb
===================================================================
--- antargis/trunk/ruby/ant_mine.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_mine.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,9 +18,7 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
 
-
 class AntMine<AntRubyEntity
 	def initialize(typeID=nil)
 		super(AGVector2.new(0,0))

Modified: antargis/trunk/ruby/ant_pcplayer.rb
===================================================================
--- antargis/trunk/ruby/ant_pcplayer.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_pcplayer.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 
 class PCRule
 end

Modified: antargis/trunk/ruby/ant_player.rb
===================================================================
--- antargis/trunk/ruby/ant_player.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_player.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 class AntPlayer
 	attr_accessor :name
 	def initialize(name)

Modified: antargis/trunk/ruby/ant_ring.rb
===================================================================
--- antargis/trunk/ruby/ant_ring.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_ring.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 module RingData
 	@@ringdata=nil
 	def RingData.getRingData(w=1)

Modified: antargis/trunk/ruby/ant_sack.rb
===================================================================
--- antargis/trunk/ruby/ant_sack.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_sack.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 class AntSack<AntAnimal
 	def initialize(p=AGVector2.new(0,0))
 		super

Modified: antargis/trunk/ruby/ant_sheep.rb
===================================================================
--- antargis/trunk/ruby/ant_sheep.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_sheep.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 # some very simple base-class for animals. contains really nothing.
 class AntAnimal<AntRubyEntity
 	def AntAnimal.xmlName

Modified: antargis/trunk/ruby/ant_sound.rb
===================================================================
--- antargis/trunk/ruby/ant_sound.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_sound.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 module AntSound
 	@@soundLastCall={}
 	@@soundInited=false

Modified: antargis/trunk/ruby/ant_stone.rb
===================================================================
--- antargis/trunk/ruby/ant_stone.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_stone.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 class AntStone<AntRubyEntity
 	def initialize()
 		super(AGVector2.new(0,0))

Modified: antargis/trunk/ruby/ant_tools.rb
===================================================================
--- antargis/trunk/ruby/ant_tools.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_tools.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 require "ant_sound.rb"
 
 def getMeshData(file,zoom,texture="",shadow=true)

Modified: antargis/trunk/ruby/ant_tower.rb
===================================================================
--- antargis/trunk/ruby/ant_tower.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_tower.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 class AntTower<AntHouse
 	def initialize
 		super

Modified: antargis/trunk/ruby/ant_townhall.rb
===================================================================
--- antargis/trunk/ruby/ant_townhall.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_townhall.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 # A farm produces food, uses men and tools
 #
 # so

Modified: antargis/trunk/ruby/ant_tree.rb
===================================================================
--- antargis/trunk/ruby/ant_tree.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_tree.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 #require 'fir_mesh.rb'
 #require 'ant_appletree.rb'
 require 'ant_grass.rb'

Modified: antargis/trunk/ruby/ant_trigger.rb
===================================================================
--- antargis/trunk/ruby/ant_trigger.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_trigger.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 class Trigger
 	attr_reader :name, :player
 	def initialize(node)

Modified: antargis/trunk/ruby/ant_well.rb
===================================================================
--- antargis/trunk/ruby/ant_well.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_well.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 
 
 class AntWell<AntRubyEntity

Modified: antargis/trunk/ruby/ant_wolf.rb
===================================================================
--- antargis/trunk/ruby/ant_wolf.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_wolf.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 # Note:
 # This implementation is still very buggy. Apart from this there are some things missing:
 # * animation

Modified: antargis/trunk/ruby/ant_workshop.rb
===================================================================
--- antargis/trunk/ruby/ant_workshop.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ant_workshop.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,6 +1,3 @@
-#!/usr/bin/env ruby
-
-
 # This is a workshop. Residents will produce tools and fetch needed resources
 # which are wood and stone. Apart from this they'll try to gather food so they won't starve
 class AntWorkshop<AntHouse

Modified: antargis/trunk/ruby/antargis.rb
===================================================================
--- antargis/trunk/ruby/antargis.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/antargis.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -167,24 +167,7 @@
 	# EVENT HANDLERS
 	####################################
 
-	# debugging-function - log all user-input
-	def getNewEvent
-		if false
-			@eventDebugging||=File.open("events.txt","r")
-			s=@eventDebugging.readline
-			return toSDLEvent(s)
-		end
-		e=super
-		s=toString(e)
-		@eventDebugging||=File.open("events.txt","w")
-		begin
-			@eventDebugging.puts s
-			#puts toSDLEvent(s)
-		rescue
-		end
-	
-		return e
-	end
+	include AntMyEventHandler
 
 
 	# this handler is for the buttonpanel on the top

Modified: antargis/trunk/ruby/antargislib.rb
===================================================================
--- antargis/trunk/ruby/antargislib.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/antargislib.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 #
 # antargislib.rb does the following:
 # - load libantargis.so (the c++-lib for anything that's not ruby)
@@ -24,7 +22,54 @@
 	end
 end
 
+if $demoMode.nil?
+	$demoMode=false
+	$enableLogging=true
+end
 
+module AntMyEventHandler
+	def getNewEvent
+		if $demoMode
+			if hardwareCursor
+				setCursor(getTextureCache.get("blue_cursor.png"))
+			end
+			@@eventDebugging||=File.open("events.txt","r")
+			@@nextLine||=@@eventDebugging.readline
+			#puts "NEXTLINE:#{@@nextLine}"
+			if @@nextLine=~/T:.*/
+				time=@@nextLine.scan(/..(.*)/)[0][0].to_f
+				#puts "TIME:#{time}"
+				@@nextLine=nil
+				setDemoTime(time)
+				return toSDLEvent("")
+			else
+				s=@@nextLine
+				@@nextLine=nil
+				return toSDLEvent(s)
+			end
+		else
+			e=super
+			s=toString(e)
+			if $enableLogging
+				@@eventDebugging||=File.open("events.txt","w")
+				@@eventDebugging.puts s
+			end
+			return e
+		end
+	end
+
+
+	def eventPrepareFrame(t)
+		if $enableLogging and not $demoMode
+			@@eventDebugging||=File.open("events.txt","w")
+			@@eventDebugging.puts "T:#{t}"
+		end
+		return false
+	end
+
+end
+
+
 if File.exists?("libantargis.so")
 	require 'libantargis'
 elsif File.exists?("../src/.libs/libantargis.so")
@@ -71,6 +116,8 @@
 						@@fullscreen=true
 					when "window"
 						@@fullscreen=false
+					when "demo"
+						$demoMode=true
 					when "gui-test"
 						require 'ruby/tests/gui_tests.rb'
 						@@cursorEnabled=true
@@ -171,4 +218,8 @@
 		puts range,range.class
 		super
 	end
+end
+
+class AntApplication<AGApplication
+	include AntMyEventHandler
 end
\ No newline at end of file

Modified: antargis/trunk/ruby/campaign.rb
===================================================================
--- antargis/trunk/ruby/campaign.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/campaign.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 
 # Campaigning
 #################################
@@ -79,7 +78,7 @@
 	end
 end
 
-class CutSceneDisplay<AGApplication
+class CutSceneDisplay<AntApplication
 	def initialize(image,text)
 		super()
 		@layout=AGLayout.new(nil)

Modified: antargis/trunk/ruby/dialogs.rb
===================================================================
--- antargis/trunk/ruby/dialogs.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/dialogs.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,4 +1,3 @@
-#!/usr/bin/env ruby
 #
 # Copyright (c) 2005 by David Kamphausen. All rights reserved.
 #
@@ -19,9 +18,7 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
 
-
 # draws a simple rect all of the defined region (typically the whole screen)
 # this used for darkening the screen when the game is paused.
 #
@@ -276,11 +273,11 @@
 		if $campaign==nil
 			raise "saving while not in campaign!"
 		end
-		getChild("window").getChild("title").setText("Save campaign")
+		getChild("window").getChild("title").setText(_("Save campaign"))
 	end
 	def eventOk(e)
-		filename=toAGEdit(getChild("Filename")).getText
-		puts "FILENAME:"+filename
+		filename=toAGEdit(getChild("Filename")).getText.to_s
+		puts "FILENAME:"+filename.to_s
 		if not filename =~ /.*\.antcmp/ then
 			filename=filename+".antcmp"
 		end
@@ -583,7 +580,7 @@
 # loadscreen.setvalue(somevalue)
 # loadscreen.tick
 # and so on
-class LoadApp<AGApplication
+class LoadApp<AntApplication
 	def initialize
 		super
 		@s=LoadScreen.new(nil)

Modified: antargis/trunk/ruby/editview.rb
===================================================================
--- antargis/trunk/ruby/editview.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/editview.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -18,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 require 'ents.rb'
 require 'editor/ent_list.rb'
 

Modified: antargis/trunk/ruby/ents.rb
===================================================================
--- antargis/trunk/ruby/ents.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/ents.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -18,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 require 'ant_local.rb'
 
 # this variables are used for playing sounds, which should be done with AntRubyEntity::playSound

Modified: antargis/trunk/ruby/intro.rb
===================================================================
--- antargis/trunk/ruby/intro.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/intro.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -17,7 +17,7 @@
 	end
 end
 
-class IntroApp<AGApplication
+class IntroApp<AntApplication
 	include AGHandler
 	def initialize
 		super

Modified: antargis/trunk/ruby/mainmenu.rb
===================================================================
--- antargis/trunk/ruby/mainmenu.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/mainmenu.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -18,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 require 'ruby/antargislib.rb'
 $useMenu=true
 
@@ -31,7 +29,7 @@
 # It uses the setMainWidget-function of AGApplication
 # This way the current menu can easily be exchanged.
 
-class AntMenuApp <AGApplication
+class AntMenuApp <AntApplication
 	include AGHandler
 	def initialize
 		super()

Modified: antargis/trunk/ruby/map.rb
===================================================================
--- antargis/trunk/ruby/map.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/map.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -18,8 +18,6 @@
 # License along with this program.
 #
 
-#!/usr/bin/ruby
-
 require 'ant_player.rb'
 require 'ant_trigger.rb'
 require 'ant_level.rb'

Modified: antargis/trunk/ruby/mpmap.rb
===================================================================
--- antargis/trunk/ruby/mpmap.rb	2007-03-05 05:19:31 UTC (rev 1055)
+++ antargis/trunk/ruby/mpmap.rb	2007-03-08 20:11:04 UTC (rev 1056)
@@ -1,5 +1,3 @@
-#!/usr/bin/env ruby
-
 #
 # AntMpMap adds some helper functions to AntRubyMap. These include 
 # additional support for Mulitplayer-games (not yet completed !!)



From davidkamphausen at mail.berlios.de  Thu Mar  8 21:12:13 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Thu, 8 Mar 2007 21:12:13 +0100
Subject: [Antargis-svn] r1057 - antargis/trunk/ruby/tests
Message-ID: <200703082012.l28KCD2R006359@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-08 21:12:12 +0100 (Thu, 08 Mar 2007)
New Revision: 1057

Added:
   antargis/trunk/ruby/tests/scissor_test.rb
Log:
* added missing file


Added: antargis/trunk/ruby/tests/scissor_test.rb
===================================================================
--- antargis/trunk/ruby/tests/scissor_test.rb	2007-03-08 20:11:04 UTC (rev 1056)
+++ antargis/trunk/ruby/tests/scissor_test.rb	2007-03-08 20:12:12 UTC (rev 1057)
@@ -0,0 +1,32 @@
+#!/usr/bin/env ruby
+
+
+require 'ruby/antargislib.rb'
+
+class MyWidget<AGWidget
+	def draw(p)
+		super
+		p.fillRect(AGRect2.new(-10,-10,30,30),AGColor.new(0,0xFF,0xFF))
+		p.fillRect(AGRect2.new(1,1,2,2),AGColor.new(0xFF,0xFF,0xFF))
+	end
+end
+
+class MyApp<AGApplication
+	def initialize
+		super
+		setMainWidget(MyWidget.new(nil,AGRect2.new(0,0,4,4)))
+	end
+	def eventFrame(t)
+		#puts "eventFram"
+		delay(20)
+		return true
+	end
+
+end
+
+
+app=MyApp.new
+app.run
+
+
+



From davidkamphausen at mail.berlios.de  Sun Mar 11 21:40:30 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 11 Mar 2007 21:40:30 +0100
Subject: [Antargis-svn] r1058 - in antargis/trunk: . gui/src gui/src/mtwist
	ruby/tests src
Message-ID: <200703112040.l2BKeUBZ015101@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-11 21:40:28 +0100 (Sun, 11 Mar 2007)
New Revision: 1058

Added:
   antargis/trunk/gui/src/ag_rand.cc
   antargis/trunk/gui/src/ag_rand.h
   antargis/trunk/gui/src/mtwist/
   antargis/trunk/gui/src/mtwist/README
   antargis/trunk/gui/src/mtwist/mtwist.3
   antargis/trunk/gui/src/mtwist/mtwist.c
   antargis/trunk/gui/src/mtwist/mtwist.h
   antargis/trunk/gui/src/mtwist/randistrs.3
   antargis/trunk/gui/src/mtwist/randistrs.c
   antargis/trunk/gui/src/mtwist/randistrs.h
   antargis/trunk/ruby/tests/rand_test.rb
Modified:
   antargis/trunk/AUTHORS
   antargis/trunk/Rakefile
   antargis/trunk/src/antargisgui.h
   antargis/trunk/src/nantmarker.hh
Log:
* added mt-randomizer


Modified: antargis/trunk/AUTHORS
===================================================================
--- antargis/trunk/AUTHORS	2007-03-08 20:12:12 UTC (rev 1057)
+++ antargis/trunk/AUTHORS	2007-03-11 20:40:28 UTC (rev 1058)
@@ -37,4 +37,6 @@
 For more authors of images please have a look at their website.
 
 The gui/src/sge* files were taken from libSGE. Have a look at these files or at http://www.etek.chalmers.se/~e8cal1/sge/ for AUTHOR's information.
-LibSGE is published under LGPL, which corresponds to AntargisGUILib.
\ No newline at end of file
+LibSGE is published under LGPL, which corresponds to AntargisGUILib.
+
+The files under gui/src/mtwist are licensed under LGPL and are copyrighted to Geoff Kuenning. Download the sources from http://lasr.cs.ucla.edu/geoff/mtwist.html#downloading.
\ No newline at end of file

Modified: antargis/trunk/Rakefile
===================================================================
--- antargis/trunk/Rakefile	2007-03-08 20:12:12 UTC (rev 1057)
+++ antargis/trunk/Rakefile	2007-03-11 20:40:28 UTC (rev 1058)
@@ -38,7 +38,7 @@
 "ag_rubyobj.h","ag_messageobject.h","ag_serial.h","ag_aes.h","ag_singleton.h",
  "ag_geometry.h","ag_font.h","ag_color.h","ag_local.h","ag_config.h","ag_string.h","ag_string_utf8.h",
  "ag_widget.h","ag_colorbutton.h","ag_glwidget.h","ag_xml.h","ag_layout.h","ag_dialog.h","ag_mutex.h",
- "ag_application.h","ag_background.h","ag_border.h","ag_button.h","ag_text.h","ag_caption.h","ag_checkbox.h","ag_combo.h","ag_edit.h","ag_fontengine.h","ag_fs.h","ag_painttarget.h","ag_surface.h","ag_texture.h","ag_surfacemanager.h","ag_image.h","ag_layoutfactory.h","ag_listbox.h","ag_list.h","ag_main.h","ag_menu.h","ag_menuitem.h","ag_mixer.h","ag_mutex.h","ag_painter.h","ag_png.h","ag_radio.h","ag_screen.h","ag_glscreen.h","ag_table.h","ag_texturecache.h","ag_theme.h","ag_tools.h","ag_window.h","ag_xml.h","ag_screenwidget.h","ag_scroller.h","ag_plugin.h","ag_destructor.h"]
+ "ag_application.h","ag_background.h","ag_border.h","ag_button.h","ag_text.h","ag_caption.h","ag_checkbox.h","ag_combo.h","ag_edit.h","ag_fontengine.h","ag_fs.h","ag_painttarget.h","ag_surface.h","ag_texture.h","ag_surfacemanager.h","ag_image.h","ag_layoutfactory.h","ag_listbox.h","ag_list.h","ag_main.h","ag_menu.h","ag_menuitem.h","ag_mixer.h","ag_mutex.h","ag_painter.h","ag_png.h","ag_radio.h","ag_screen.h","ag_glscreen.h","ag_table.h","ag_texturecache.h","ag_theme.h","ag_tools.h","ag_window.h","ag_xml.h","ag_screenwidget.h","ag_scroller.h","ag_plugin.h","ag_destructor.h","ag_rand.h"]
 
 interfaceHeadersSRC.collect!{|s|"src/"+s}
 interfaceHeadersGUI.collect!{|s|"gui/src/"+s}
@@ -73,7 +73,7 @@
 	rubyincludedir=Config::CONFIG['archdir']
 end
 
-$CFLAGS+=" -Isrc -I"+$GUISRC+" -DUSE_RUBY -I"+rubyincludedir+" -Wall"
+$CFLAGS+=" -Isrc -I"+$GUISRC+" -I#{$GUISRC}/mtwist -DUSE_RUBY -I"+rubyincludedir+" -Wall"
 
 if $debug
 	$CFLAGS+=" -g -O0"
@@ -93,7 +93,7 @@
 
 interfaceHeaders = interfaceHeadersGUI + interfaceHeadersSRC
 
-SRCS=(Dir[$GUISRC+"/*.cc"]+Dir[$GUISRC+"/*.c"]+Dir["src/*.cc"]+["src/swig.cc","gui/src/guiswig.cc"]).uniq
+SRCS=(Dir[$GUISRC+"/*.cc"]+Dir[$GUISRC+"/*.c"]+Dir["src/*.cc"]+["src/swig.cc","gui/src/guiswig.cc","gui/src/mtwist/mtwist.c"]).uniq
 if $internalSGE
 	SRCS+=Dir[$GUISRC+"/sge/*.cc"]
 end

Added: antargis/trunk/gui/src/ag_rand.cc
===================================================================
--- antargis/trunk/gui/src/ag_rand.cc	2007-03-08 20:12:12 UTC (rev 1057)
+++ antargis/trunk/gui/src/ag_rand.cc	2007-03-11 20:40:28 UTC (rev 1058)
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_rand.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_rand.h"
+#include "ag_debug.h"
+#include "mtwist.h"
+
+#include <sstream>
+
+static mt_state mState;
+
+
+AGRandomizer::AGRandomizer(const std::string &pSeed)
+{
+  std::istringstream is;
+  is.str(pSeed);
+
+  is>>mState.stateptr;
+  is>>mState.initialized;
+
+  for(unsigned long i=0;i<MT_STATE_SIZE;i++)
+    is>>mState.statevec[i];
+  
+  //  mts_seed(&mState);
+
+}
+float AGRandomizer::operator()(float f)
+{
+  float d=(float)mts_drand(&mState);
+  cdebug("d:"<<d<<" f:"<<f);
+  d*=f;
+  cdebug("d2:"<<d);
+  
+  return d;
+}
+int AGRandomizer::operator()(int i)
+{
+  int r=mts_lrand(&mState);
+  cdebug("r:"<<r<<" i:"<<i);
+  r%=i;
+  cdebug("r2:"<<r);
+  return r;
+}
+
+std::string AGRandomizer::stateToString() const
+{
+  std::ostringstream os;
+  os<<mState.stateptr<<" "<<mState.initialized<<" ";
+
+  for(unsigned long i=0;i<MT_STATE_SIZE;i++)
+    os<<mState.statevec[i]<<" ";
+
+  return os.str();
+
+}
+
+
+

Added: antargis/trunk/gui/src/ag_rand.h
===================================================================
--- antargis/trunk/gui/src/ag_rand.h	2007-03-08 20:12:12 UTC (rev 1057)
+++ antargis/trunk/gui/src/ag_rand.h	2007-03-11 20:40:28 UTC (rev 1058)
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_rand.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef __AG_RAND
+#define __AG_RAND
+
+#include <string>
+
+class AGRandomizer
+{
+ public:
+  AGRandomizer(const std::string &pSeed);
+#ifdef SWIG
+  %rename(randFloat) operator()(float f);
+  %rename(randInt) operator()(int i);
+#endif
+  float operator()(float f);
+  int operator()(int i);
+
+  std::string stateToString() const;
+
+};
+
+
+#endif

Added: antargis/trunk/gui/src/mtwist/README
===================================================================
--- antargis/trunk/gui/src/mtwist/README	2007-03-08 20:12:12 UTC (rev 1057)
+++ antargis/trunk/gui/src/mtwist/README	2007-03-11 20:40:28 UTC (rev 1058)
@@ -0,0 +1,16 @@
+This is an implementation of the Mersenne Twist pseudorandom number
+generator, including both C and C++ interfaces and a set of functions
+for generating random variates from common distributions.
+
+To compile, you may need to define MT_NOINLINE or MT_LONG_LONG.
+
+The full documentation for the package is in the manual pages,
+mtwist.3 and randistrs.3.
+
+For more information, see the Web page for the package, at:
+
+	http://www.cs.hmc.edu/~geoff/mtwist.html
+
+or
+
+	http://www.lasr.cs.ucla.edu/geoff/mtwist.html

Added: antargis/trunk/gui/src/mtwist/mtwist.3
===================================================================
--- antargis/trunk/gui/src/mtwist/mtwist.3	2007-03-08 20:12:12 UTC (rev 1057)
+++ antargis/trunk/gui/src/mtwist/mtwist.3	2007-03-11 20:40:28 UTC (rev 1058)
@@ -0,0 +1,389 @@
+.\"
+.\" $Id: mtwist.3,v 1.5 2002/10/30 07:39:53 geoff Exp $
+.\"
+.\" $Log: mtwist.3,v $
+.\" Revision 1.5  2002/10/30 07:39:53  geoff
+.\" Document the new seeding routines.
+.\"
+.\" Revision 1.4  2001/06/20 08:15:51  geoff
+.\" Correct the documentation of the generator's period.
+.\"
+.\" Revision 1.3  2001/06/19 00:43:01  geoff
+.\" Document the lack of a newline in the << operator
+.\"
+.\" Revision 1.2  2001/06/18 10:09:24  geoff
+.\" Fix the manual section.
+.\"
+.\" Revision 1.1  2001/06/16 21:20:31  geoff
+.\" Initial revision
+.\"
+.\" 
+.TH mtwist 3 "June 14, 2001" "" "Linux Programmer's Manual"
+.SH NAME
+mts_seed32new, mts_seed32, mts_seedfull, mts_seed, mts_goodseed, mts_bestseed,
+mts_savestate, mts_loadstate, mt_seed32new, mt_seed32, mt_seedfull, mt_seed,
+mt_goodseed, mt_bestseed, mt_getstate, mt_savestate, mt_loadstate,
+mts_lrand, mts_llrand, mts_drand, mts_ldrand, mt_lrand, mt_llrand,
+mt_drand, mt_ldrand,
+mt_prng \- generate uniformly distributed pseudo-random numbers
+.SH SYNOPSIS
+.nf
+.IR "#defines" " (see below)"
+.br
+.B
+#include "mtwist.h"
+.sp
+C interface:
+.sp
+.BI "void mts_seed32(mt_state* " state ", unsigned long " seed ");"
+.sp
+.BI "void mts_seed32new(mt_state* " state ", unsigned long " seed ");"
+.sp
+.BI "void mts_seedfull(mt_state* " state ","
+.BI "                  unsigned long " seeds "[MT_STATE_SIZE]);"
+.sp
+.BI "void mts_seed(mt_state* " state ");"
+.sp
+.BI "void mts_goodseed(mt_state* " state ");"
+.sp
+.BI "void mts_bestseed(mt_state* " state ");"
+.sp
+.BI "int mts_savestate(FILE* " statefile ", mt_state* " state ");"
+.sp
+.BI "int mts_loadstate(FILE* " statefile ", mt_state* " state ");"
+.sp
+.BI "void mt_seed32(unsigned long " seed ");"
+.sp
+.BI "void mt_seed32new(unsigned long " seed ");"
+.sp
+.BI "void mt_seedfull(unsigned long " seeds "[MT_STATE_SIZE]);"
+.sp
+.B void mt_seed(void);
+.sp
+.B void mt_goodseed(void);
+.sp
+.B void mt_bestseed(void);
+.sp
+.B mt_state* mt_getstate(void);
+.sp
+.BI "int mt_savestate(FILE* " statefile ");"
+.sp
+.BI "int mt_loadstate(FILE* " statefile ");"
+.sp
+.BI "unsigned long mts_lrand(mt_state* " state ");"
+.sp
+.BI "unsigned long long mts_llrand(mt_state* " state ");"
+.sp
+.BI "double mts_drand(mt_state* " state ");"
+.sp
+.BI "double mts_ldrand(mt_state* " state ");"
+.sp
+.B unsigned long mt_lrand(void);
+.sp
+.B unsigned long long mt_llrand(void);
+.sp
+.B double mt_drand(void);
+.sp
+.B double mt_ldrand(void);
+.sp
+.B "C++ interface:"
+.sp
+.BI "mt_prng " rng ;
+.sp
+.BI "mt_prng " rng "(bool " pickseed " = false);"
+.sp
+.BI "mt_prng " rng "(unsigned long " seed );
+.sp
+.BI "mt_prng " rng "(unsigned long " seeds [MT_STATE_SIZE]);
+.sp
+.BI "void " rng ".seed32(unsigned long " seed ");"
+.sp
+.BI "void " rng ".seedfull(unsigned long seeds[MT_STATE_SIZE]);"
+.sp
+.BI "void " rng ".seed();"
+.sp
+.BI "void " rng ".goodseed();"
+.sp
+.BI "void " rng ".bestseed();"
+.sp
+.BI "unsigned long " rng ".lrand();"
+.sp
+.BI "unsigned long long " rng ".llrand();"
+.sp
+.BI "double " rng ".drand();"
+.sp
+.BI "double " rng ".ldrand();"
+.sp
+.BI "double " rng "();"
+.sp
+.IB "stream" " << " rng ";"
+.sp
+.IB "stream" " >> " rng ";"
+.SH DESCRIPTION
+These functions generate pseudo-random numbers using Matsumoto and
+Nishimura's Mersenne Twist algorithm (see:
+.nf
+.sp
+        http://www.math.keio.ac.jp/~matumoto/emt.html
+.sp
+.fi
+for full information).
+The period of this pseudo random-number generator (PRNG) is 2^19337-1
+which is vastly longer than the life of the universe
+even if the random numbers are being generated at an impossible rate.
+The generator also has excellent statistical properties.
+.PP
+The
+.B mtwist
+package assumes a 32-bit machine with a C or C++ compiler that
+supports inline functions and the
+.B long long
+data type.
+If these features are not present, it will be necessary to
+.B #define
+either or both of
+.B MT_NO_INLINE
+or
+.BR MT_NO_LONGLONG ,
+as appropriate.
+On a machine with 64-bit hardware, the value
+.B MT_MACHINE_BITS
+must be defined equal to 64.
+At present, the
+.B mtwist
+package assumes that
+.B long
+is a 32-bit type, even on 64-bit machines.
+If this assumption is false, the declarations in the package will have
+to be modified.
+.PP
+All of the PRNG functions work from a
+.IR "state vector" ,
+which is of type
+.B mt_state
+in C and type
+.B mt_prng
+in C++.
+The state vector stores everything that the PRNG needs to generate new
+numbers in the proper sequence.
+By using multiple state vectors, programs can draw random numbers from
+independent sequences, which is important in applications such as
+simulation (where each independent random variable should be drawn
+from its own sequence to avoid unintentional correlations).
+.PP
+For convenience, the C interface also provides a built-in default
+state vector that can be used in simple applications.
+The
+.BI mt_ xxx
+functions use the default state vector to control their behavior,
+while the
+.BI mts_xxx
+functions accept a user-provided state vector.
+.PP
+In C, a user-provided state vector has the following structure:
+.PP
+.nf
+#define MT_STATE_SIZE 624
+
+typedef struct {
+.in +8
+unsigned long statevec[MT_STATE_SIZE];
+.in +16
+/* Vector holding current state */
+.in -16
+int stateptr;   /* Next state entry to be used */
+int initialized;
+.in +16
+/* NZ if state has been initialized */
+.in -24
+} mt_state;
+.fi
+.PP
+An uninitialized PRNG is indicated by zeros in
+.I both
+.B stateptr
+and
+.BR initialized .
+It is the programmer's responsibility to ensure that these fields are
+zero before calling any of the
+.BI mts_xxx
+functions.
+.PP
+It is occasionally useful to directly access the default state vector, so
+.B mt_getstate
+will return a pointer to the default state.
+.PP
+In both C and C++, the functionality is divided into two categories:
+seeding and pseudorandom-number generation.
+If one of the generation functions is called on an unseeded generator,
+a default seed (specified by Matsumoto and Nishimura) will be used.
+Usually, the programmer will wish to override the default seed and
+choose a more appropriate one.
+The simplest way to seed a PRNG is by calling one of the
+.B *seed32new
+functions.
+This will invoke Matsumoto and Nishimura's revised Knuth-style seed
+generator.
+.PP
+The
+.B *seed32
+functions
+will invoke Matsumoto and Nishimura's original Knuth-style seed
+generator, which is now deprecated.
+In C++, the same effect can be achieved by passing a 32-bit
+.RB ( "unsigned long" )
+seed to the constructor.
+The original 32-bit seeder did not work correctly if the seed was zero,
+so in that
+case the default seed of 4357 will be substituted.
+The original seeder is still supported so that older software will
+continue to work in the same fashion without changes.
+.PP
+The
+.B *seed32new
+and
+.B *seed32
+functions are simple to use, but they have the drawback that only 4
+billion distinct pseudorandom sequences can be generated using them.
+To allow access to sequences beginning anywhere in the entire space of
+possibilities, the
+.B *seedfull
+functions can be passed an initial state vector of 624 32-bit numbers,
+or a C++ PRNG can be constructed with a 624-element array as an
+argument.
+The initialization vector must contain at least one nonzero value;
+if this rule is violated, the program will be aborted (unfortunately
+without a diagnostic message due to C/C++ portability issues).
+.PP
+The
+.BR *seed32new ,
+.BR *seed32 ,
+and
+.B *seedfull
+functions allow fixed, reproducible seeds, which is useful for
+simulation and experimentation.
+For game-like applications, non-reproducible seeds are usually more
+appropriate.
+The
+.BR mts_seed ,
+.BR mt_seed ,
+and
+.B seed
+functions use the system time to generate an argument to the
+.B *seed32new
+functions to satisfy this need.
+The microseconds portion of the time is included in the seed to
+enhance the probability that two programs will generate different
+random sequences.
+.PP
+Since the various "plain"
+.B seed
+functions are also somewhat limited in the variety they can produce,
+two other functions are available on systems that have support for the
+.B /dev/random
+device.
+The
+.B *goodseed
+functions attempt to use
+.B /dev/urandom
+to get truly random values for use with
+.BR *seedfull .
+If
+.B /dev/urandom
+isn't available, these functions fall back to calling the equivalent "plain"
+.B seed
+function.
+C++ programmers can also invoke
+.B goodseed
+at construction time by passing an argument of
+.B true
+to the constructor.
+.PP
+For the most random seed possible, the
+.B *bestseed
+functions attempt to use
+.B /dev/random
+to acquire values for
+.BR *seedfull ,
+falling back to
+.B *seed
+if
+.B /dev/random
+is unavailable.
+The disadvantage of these functions is that it usually takes a
+significant amount of (wall-clock) time before
+.B /dev/random
+can produce enough entropy to provide a seed.
+Therefore, it is nearly always better to stick with the
+.B *goodseed
+functions.
+.PP
+Finally, it is often useful to be able to save and restore the PRNG
+state for later use.
+In C, the functions
+.B *savestate
+.B *loadstate
+will save the current state into an open
+.B stdio
+.B FILE
+as a single long line (in ASCII)
+and later restore it such that the restored PRNG will pick up where
+the saved one left off.
+In C++, the same effect can be achieved by writing to or reading from
+a C++
+.B stream
+using the usual
+.B "<<"
+and
+.B ">>"
+operators.
+As with all well-behaved C++ types, the
+.B "<<"
+operator does not add a newline after the saved state.
+.PP
+Once a generator has been seeded,
+uniformly distributed pseudorandom numbers can be produced in several
+formats.
+(The functions in the
+.IR randistrs (3)
+library can be used to produce other statistical distributions.)
+The
+.B *lrand
+and
+.B *llrand
+generate 32-bit and 64-bit random integers uniformly distributed
+between 0 and the maximum unsigned value.
+(The
+.B *llrand
+functions are only available on machines that support the
+.B "long long"
+data type.
+The
+.B *drand
+functions generate a double-precision number in the range [0,1)
+(i.e., 0 is a possible value but 1 is not).
+The number generated by
+.B *drand
+has 32 bits of precision.
+For convenience, the C++ interface also defines a function operator
+that returns the same result as
+.BR drand ,
+so that a PRNG can be called as if it were a function.
+For applications that demand increased precision, the
+.B *ldrand
+functions generate a double-precision number in [0,1) with up to 64
+bits of precision (usually 52 bits).
+.SH BUGS
+The package won't work on a machine where
+.B long
+is a 64-bit integer.
+If
+.B inline
+or
+.B long long
+is not available, special symbols must be defined before using the
+package.
+It would be better if knowledge of the architecture and compiler were
+built into the package.
+.SH "SEE ALSO"
+.BR randistrs "(3), " drand48 "(3), " rand "(3), " random (3)

Added: antargis/trunk/gui/src/mtwist/mtwist.c
===================================================================
--- antargis/trunk/gui/src/mtwist/mtwist.c	2007-03-08 20:12:12 UTC (rev 1057)
+++ antargis/trunk/gui/src/mtwist/mtwist.c	2007-03-11 20:40:28 UTC (rev 1058)
@@ -0,0 +1,952 @@
+#ifndef lint
+static char Rcs_Id[] =
+    "$Id: mtwist.c,v 1.19 2003/09/11 05:55:19 geoff Exp $";
+#endif
+
+/*
+ * C library functions for generating pseudorandom numbers using the
+ * Mersenne Twist algorithm.  See M. Matsumoto and T. Nishimura,
+ * "Mersenne Twister: A 623-Dimensionally Equidistributed Uniform
+ * Pseudo-Random Number Generator", ACM Transactions on Modeling and
+ * Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30.
+ *
+ * The Web page on the Mersenne Twist algorithm is at:
+ *
+ * http://www.math.keio.ac.jp/~matumoto/emt.html
+ *
+ * These functions were written by Geoffrey H. Kuenning, Claremont, CA.
+ *
+ * IMPORTANT NOTE: the Makefile must define two machine-specific
+ * variables to get optimum features and performance:
+ *
+ *	MT_NO_INLINE	should be defined if the compiler doesn't support
+ *			the "inline" keyword.
+ *	MT_NO_LONGLONG	should be defined if the compiler doesn't support a
+ *			"long long" type for 64-bit integers
+ *	MT_MACHINE_BITS	must be either 32 or 64, reflecting the natural
+ *			size of the processor registers.  If undefined, it
+ *			will default to 32.
+ *
+ * The first two variables above are defined in an inverted sense
+ * because I expect that most compilers will support inline and
+ * long-long.  By inverting the sense, this common case will require
+ * no special compiler flags.
+ *
+ * IMPORTANT NOTE: this software assumes that the inherent width of a
+ * "long" is 32 bits.  If you are running on a machine that uses
+ * 64-bit longs, some of the declarations and code will have to be
+ * modified.
+ *
+ * This software is based on LGPL-ed code by Takuji Nishimura.  It has
+ * also been heavily influenced by code written by Shawn Cokus, and
+ * somewhat influenced by code written by Richard J. Wagner.  It is
+ * therefore also distributed under the LGPL:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public License
+ * as published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.  You should have
+ * received a copy of the GNU Library General Public License along
+ * with this library; if not, write to the Free Foundation, Inc., 59
+ * Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * $Log: mtwist.c,v $
+ * Revision 1.19  2003/09/11 05:55:19  geoff
+ * Get rid of some minor compiler warnings.
+ *
+ * Revision 1.18  2003/09/11 05:50:53  geoff
+ * Don't #define inline to nothing, since that breaks standard include
+ * files.  Instead, use MT_INLINE as a synonym.
+ *
+ * Revision 1.17  2002/10/31 22:07:10  geoff
+ * Make WIN32 detection work with GCC as well as MS C
+ *
+ * Revision 1.16  2002/10/31 22:04:59  geoff
+ * Fix a typo in the WIN32 option
+ *
+ * Revision 1.15  2002/10/31 06:01:43  geoff
+ * Incorporate Joseph Brill's Windows-portability changes
+ *
+ * Revision 1.14  2002/10/30 07:39:53  geoff
+ * Reintroduce the old seeding functions (so that old code will still
+ * produce the same results), and give the new versions new names.
+ *
+ * Revision 1.13  2002/10/30 01:08:26  geoff
+ * Switch to M&T's new initialization method
+ *
+ * Revision 1.12  2001/06/18 05:40:12  geoff
+ * Prefix the compile options with MT_.
+ *
+ * Revision 1.11  2001/06/14 10:26:59  geoff
+ * Invert the sense of the #define flags so that the default is the
+ * normal case (if gcc is normal!).  Also default MT_MACHINE_BITS to 32.
+ *
+ * Revision 1.10  2001/06/14 10:10:38  geoff
+ * Move the RNG functions into the header file so they can be inlined.
+ * Add saving/loading of state.  Add a function that marks the PRNG as
+ * initialized while also calculating critical constants.  Run the
+ * refresh routine whenever seed32 is called.  Add functions to seed
+ * based on /dev/random or the time.
+ *
+ * Revision 1.9  2001/06/11 10:00:04  geoff
+ * Major changes to improve flexibility and performance, and to prepare
+ * for inlining.  This code is about as fast as it can get without
+ * inlining the various PRNG functions.  Add seed/goodseed/bestseed for
+ * seeding from random start values.  Add the refresh routine a la Cokus,
+ * but optimize it by unrolling loops.  Change getstate to return a
+ * complete state pointer, since knowing the position in the state vector
+ * is critical to restoring state.  Add more macros to improve
+ * readability.  Rename certain macros in preparation for inlining.  Get
+ * rid of leftover optimizer-bug stuff.  Stop using mtwist_guts.h;
+ * instead use direct code (via macros) and the refresh function.
+ *
+ * Revision 1.8  2001/04/23 08:36:03  geoff
+ * Move the #defined code into a header file to ease stepping with a debugger.
+ *
+ * Revision 1.7  2001/04/23 08:00:13  geoff
+ * Add code to work around optimizer bug
+ *
+ * Revision 1.6  2001/04/14 01:33:32  geoff
+ * Clarify the license
+ *
+ * Revision 1.5  2001/04/09 08:45:00  geoff
+ * Rename default_state to mt_default_state, and make it global so that
+ * the random-distribution code can use it.
+ *
+ * Revision 1.4  2001/04/07 23:24:11  geoff
+ * My guess in the commentary for the last delta was right: it's faster
+ * on a x86 to convert the two halves of the PRN to double, multiplying
+ * them by the appropriate value to scale them, and then add them as
+ * doubles.  I suspect the reason is that there is no instruction to
+ * convert a 64-bit value directly to a double, so the work of building
+ * the long long (which isn't easy anyway, without assembly access) is
+ * worse than wasted.  So add support for MT_MACHINE_BITS, and only go
+ * the via-long-long route on a true 64-bit machine.
+ *
+ * Revision 1.3  2001/04/07 23:09:38  geoff
+ * Get rid of MT_INLINE.  Convert all of the code to use preprocessor
+ * macros for the guts of the PRNG code.  Take advantage of the
+ * conversion to get rid of unnecessary calls initialization tests.  Also
+ * clean up the generation of long-double pseudorandom numbers on
+ * machines that have the long long type (by converting first to a long
+ * long, then to a double, saving one floating-point operation).  The
+ * latter change might be a mistake on 32-bit machines.  The code is now
+ * much faster as a result of macro-izing.
+ *
+ * Revision 1.2  2001/04/07 22:21:41  geoff
+ * Make the long-double code a hair faster by always having a 64-bit
+ * conversion constant.  Add commentary to the PRNG loop.
+ *
+ * Revision 1.1  2001/04/07 09:43:41  geoff
+ * Initial revision
+ *
+ */
+
+#ifdef _WIN32
+#undef WIN32
+#define WIN32
+#endif /* _WIN32 */
+
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef WIN32
+#include <sys/timeb.h>
+#else /* WIN32 */
+#include <sys/time.h>
+#endif /* WIN32 */
+
+/*
+ * Before we include the Mersenne Twist header file, we must do a bit
+ * of magic setup.  The code for actual random-number generation
+ * resides in that file rather than here.  We need to arrange for the
+ * code to be compiled into this .o file, either because inlines
+ * aren't supported or because somebody might want to take a pointer
+ * to a function.  We do so with a couple of careful #defines.
+ */
+#undef MT_NO_INLINE			/* Ask for code to be compiled */
+#define MT_INLINE			/* Disable the inline keyword */
+#define MT_EXTERN			/* Generate real code for functions */
+
+#include "mtwist.h"
+
+/*
+ * Table of contents:
+ */
+void			mts_mark_initialized(mt_state* state);
+					/* Mark a PRNG state as initialized */
+void			mts_seed32(mt_state* state, unsigned long seed);
+					/* Set random seed for any generator */
+void			mts_seed32new(mt_state* state, unsigned long seed);
+					/* Set random seed for any generator */
+void			mts_seedfull(mt_state* state,
+			  unsigned long seeds[MT_STATE_SIZE]);
+					/* Set complicated seed for any gen. */
+void			mts_seed(mt_state* state);
+					/* Choose seed from random input */
+void			mts_goodseed(mt_state* state);
+					/* Choose seed from more random */
+					/* ..input than mts_seed */
+static void		mts_devseed(mt_state* state, char* seed_dev);
+					/* Choose seed from a device */
+void			mts_bestseed(mt_state* state);
+					/* Choose seed from extremely random */
+					/* ..input (can be *very* slow) */
+void			mts_refresh(mt_state* state);
+					/* Generate 624 more random values */
+int			mts_savestate(FILE* statefile, mt_state* state);
+					/* Save state to a file (ASCII) */
+int			mts_loadstate(FILE* statefile, mt_state* state);
+					/* Load state from a file (ASCII) */
+
+void			mt_seed32(unsigned long seed);
+					/* Set random seed for default gen. */
+void			mt_seed32new(unsigned long seed);
+					/* Set random seed for default gen. */
+void			mt_seedfull(unsigned long seeds[MT_STATE_SIZE]);
+					/* Set complicated seed for default */
+void			mt_seed(void);	/* Choose seed from random input */
+void			mt_goodseed(void);
+					/* Choose seed from more random */
+					/* ..input than mts_seed */
+void			mt_bestseed(void);
+					/* Choose seed from extremely random */
+					/* ..input (can be *very* slow) */
+extern mt_state*	mt_getstate(void);
+					/* Get current state of default */
+					/* ..generator */
+int			mt_savestate(FILE* statefile);
+					/* Save state to a file (ASCII) */
+int			mt_loadstate(FILE* statefile);
+					/* Load state from a file (ASCII) */
+
+
+/*
+ * The following values are fundamental parameters of the algorithm.
+ * With the exception of the two masks, all of them were found
+ * experimentally using methods described in Matsumoto and Nishimura's
+ * paper.  They are exceedingly magic; don't change them.
+ */
+
+/* MT_STATE_SIZE is defined in the header file. */
+#define RECURRENCE_OFFSET 397		/* Offset into state space for the */
+					/* ..recurrence relation.  The */
+					/* ..recurrence mashes together two */
+					/* ..values that are separated by */
+					/* ..this offset in the state */
+					/* ..space. */
+#define MATRIX_A	0x9908b0df	/* Constant vector A for the */
+					/* ..recurrence relation.  The */
+					/* ..mashed-together value is */
+					/* ..multiplied by this vector to */
+					/* ..get a new value that will be */
+					/* ..stored into the state space. */
+
+/*
+ * Width of a long.  Don't change this even if your longs are 64 bits.
+ */
+#define BIT_WIDTH	32		/* Work with 32-bit words */
+
+/*
+ * Masks for extracting the bits to be mashed together.  The widths of these
+ * masks are also fundamental parameters of the algorithm, determined
+ * experimentally -- but of course the masks themselves are simply bit
+ * selectors.
+ */
+#define UPPER_MASK	0x80000000	/* Most significant w-r bits */
+#define LOWER_MASK	0x7fffffff	/* Least significant r bits */
+
+/*
+ * Macro to simplify code in the generation loop.  This function
+ * combines the top bit of x with the bottom 31 bits of y.
+ */
+#define COMBINE_BITS(x, y) \
+			(((x) & UPPER_MASK) | ((y) & LOWER_MASK))
+
+/*
+ * Another generation-simplification macro.  This one does the magic
+ * scrambling function.
+ */
+#define MATRIX_MULTIPLY(original, new) \
+			((original) ^ ((new) >> 1) \
+			  ^ matrix_decider[(new) & 0x1])
+
+/*
+ * Parameters of Knuth's PRNG (Line 25, Table 1, p. 102 of "The Art of
+ * Computer Programming, Vol. 2, 2nd ed, 1981).
+ */
+#define KNUTH_MULTIPLIER_OLD \
+			69069
+
+/*
+ * Parameters of Knuth's PRNG (p. 106 of "The Art of Computer
+ * Programming, Vol. 2, 3rd ed).
+ */
+#define KNUTH_MULTIPLIER_NEW \
+			1812433253ul
+#define KNUTH_SHIFT	30		// Even on a 64-bit machine!
+
+/*
+ * Default 32-bit random seed if mts_seed32 wasn't called
+ */
+#define DEFAULT_SEED32_OLD \
+			4357
+#define DEFAULT_SEED32_NEW \
+			5489ul
+
+/*
+ * Where to get random numbers
+ */
+#define DEVRANDOM	"/dev/random"
+#define DEVURANDOM	"/dev/urandom"
+
+/*
+ * Many applications need only a single PRNG, so it's a nuisance to have to
+ * specify a state.  For those applications, we will provide a default
+ * state, and functions to use it.
+ */
+mt_state		mt_default_state;
+
+/*
+ * To generate double-precision random numbers, we need to divide the result
+ * of mts_lrand or mts_llrand by 2^32 or 2^64, respectively.  The quickest
+ * way to do that on most machines is to multiply by the inverses of those
+ * numbers.  However, I don't trust the compiler to correctly convert the
+ * corresponding decimal constant.  So we will compute the correct number at
+ * run time as part of initialization, which will produce a nice exact
+ * result.
+ */
+double			mt_32_to_double;
+					/* Multiplier to convert long to dbl */
+double			mt_64_to_double;
+					/* Mult'r to cvt long long to dbl */
+
+/*
+ * In the recurrence relation, the new value is XORed with MATRIX_A only if
+ * the lower bit is nonzero.  Since most modern machines don't like to
+ * branch, it's vastly faster to handle this decision by indexing into an
+ * array.  The chosen bit is used as an index into the following vector,
+ * which produces either zero or MATRIX_A and thus the desired effect.
+ */
+static unsigned long	matrix_decider[2] =
+			  {0x0, MATRIX_A};
+
+/*
+ * Mark a PRNG's state as having been initialized.  This is the only
+ * way to set that field nonzero; that way we can be sure that the
+ * constants are set properly before the PRNG is used.
+ *
+ * As a side effect, set up some constants that the PRNG assumes are
+ * valid.  These are calculated at initialization time rather than
+ * being written as decimal constants because I frankly don't trust
+ * the compiler's ASCII conversion routines.
+ */
+void mts_mark_initialized(
+    mt_state*		state)		/* State vector to mark initialized */
+    {
+    int			i;		/* Power of 2 being calculated */
+
+    /*
+     * Figure out the proper multiplier for long-to-double conversion.  We
+     * don't worry too much about efficiency, since the assumption is that
+     * initialization is vastly rarer than generation of random numbers.
+     */
+    mt_32_to_double = 1.0;
+    for (i = 0;  i < BIT_WIDTH;  i++)
+	mt_32_to_double /= 2.0;
+    mt_64_to_double = mt_32_to_double;
+    for (i = 0;  i < BIT_WIDTH;  i++)
+	mt_64_to_double /= 2.0;
+
+    state->initialized = 1;
+    }
+
+/*
+ * Initialize a Mersenne Twist PRNG from a 32-bit seed.
+ *
+ * According to Matsumoto and Nishimura's paper, the seed array needs to be
+ * filled with nonzero values.  (My own interpretation is that there needs
+ * to be at least one nonzero value).  They suggest using Knuth's PRNG from
+ * Line 25, Table 1, p.102, "The Art of Computer Programming," Vol. 2 (2nd
+ * ed.), 1981.  I find that rather odd, since that particular PRNG is
+ * sensitive to having an initial seed of zero (there are many other PRNGs
+ * out there that have an additive component, so that a seed of zero does
+ * not generate a repeating-zero sequence).  However, one thing I learned
+ * from reading Knuth is that you shouldn't second-guess mathematicians
+ * about PRNGs.  Also, by following M & N's approach, we will be compatible
+ * with other implementations.  So I'm going to stick with their version,
+ * with the single addition that a zero seed will be changed to their
+ * default seed.
+ */
+void mts_seed32(
+    mt_state*		state,		/* State vector to initialize */
+    unsigned long	seed)		/* 32-bit seed to start from */
+    {
+    int			i;		/* Loop index */
+
+    if (seed == 0)
+	seed = DEFAULT_SEED32_OLD;
+
+    /*
+     * Fill the state vector using Knuth's PRNG.  Be sure to mask down
+     * to 32 bits in case we're running on a machine with 64-bit
+     * longs.
+     */
+    state->statevec[MT_STATE_SIZE - 1] = seed & 0xffffffff;
+    for (i = MT_STATE_SIZE - 2;  i >= 0;  i--)
+        state->statevec[i] =
+          (KNUTH_MULTIPLIER_OLD * state->statevec[i + 1]) & 0xffffffff;
+
+    state->stateptr = MT_STATE_SIZE;
+    mts_mark_initialized(state);
+
+    /*
+     * Matsumoto and Nishimura's implementation refreshes the PRNG
+     * immediately after running the Knuth algorithm.  This is
+     * probably a good thing, since Knuth's PRNG doesn't generate very
+     * good numbers.
+     */
+    mts_refresh(state);
+    }
+
+/*
+ * Initialize a Mersenne Twist PRNG from a 32-bit seed, using
+ * Matsumoto and Nishimura's newer reference implementation (Jan. 9,
+ * 2002).
+ */
+void mts_seed32new(
+    mt_state*		state,		/* State vector to initialize */
+    unsigned long	seed)		/* 32-bit seed to start from */
+    {
+    int			i;		/* Loop index */
+    unsigned long	nextval;	/* Next value being calculated */
+
+    /*
+     * Fill the state vector using Knuth's PRNG.  Be sure to mask down
+     * to 32 bits in case we're running on a machine with 64-bit
+     * longs.
+     */
+    state->statevec[MT_STATE_SIZE - 1] = seed & 0xffffffffUL;
+    for (i = MT_STATE_SIZE - 2;  i >= 0;  i--)
+	{
+	nextval = state->statevec[i + 1] >> KNUTH_SHIFT;
+	nextval ^= state->statevec[i + 1];
+	nextval *= KNUTH_MULTIPLIER_NEW;
+	nextval += (MT_STATE_SIZE - 1) - i;
+	state->statevec[i] = nextval & 0xffffffffUL;
+	}
+
+    state->stateptr = MT_STATE_SIZE;
+    mts_mark_initialized(state);
+
+    /*
+     * Matsumoto and Nishimura's implementation refreshes the PRNG
+     * immediately after running the Knuth algorithm.  This is
+     * probably a good thing, since Knuth's PRNG doesn't generate very
+     * good numbers.
+     */
+    mts_refresh(state);
+    }
+
+/*
+ * Initialize a Mersenne Twist RNG from a 624-long seed.
+ *
+ * The 32-bit seeding routine given by Matsumoto and Nishimura has the
+ * drawback that there are only 2^32 different PRNG sequences that can be
+ * generated by calling that function.  This function solves that problem by
+ * allowing a full 624*32-bit state to be given.  (Note that 31 bits of the
+ * given state are ignored; see the paper for details.)
+ *
+ * Since an all-zero state would cause the PRNG to cycle, we detect
+ * that case and abort the program (silently, since there is no
+ * portable way to produce a message in both C and C++ environments).
+ * An alternative would be to artificially force the state to some
+ * known nonzero value.  However, I feel that if the user is providing
+ * a full state, it's a bug to provide all zeros and we we shouldn't
+ * conceal the bug by generating apparently correct output.
+ */
+void mts_seedfull(
+    mt_state*		state,		/* State vector to initialize */
+    unsigned long	seeds[MT_STATE_SIZE])
+					/* Seed array to start from */
+    {
+    int			had_nz = 0;	/* NZ if at least one NZ seen */
+    int			i;		/* Loop index */
+
+    for (i = 0;  i < MT_STATE_SIZE;  i++)
+        {
+        if (seeds[i] != 0)
+	    had_nz = 1;
+        state->statevec[MT_STATE_SIZE - i - 1] = seeds[i];
+	}
+
+    if (!had_nz)
+	{
+	/*
+	 * It would be nice to abort with a message.  Unfortunately, fprintf
+	 * isn't compatible with all implementations of C++.  In the
+	 * interest of C++ compatibility, therefore, we will simply abort
+	 * silently.  It will unfortunately be up to a programmer to run
+	 * under a debugger (or examine the core dump) to discover the cause
+	 * of the abort.
+	 */
+	abort();
+	}
+
+    state->stateptr = MT_STATE_SIZE;
+    mts_mark_initialized(state);
+    }
+
+/*
+ * Choose a seed based on some moderately random input.  Prefers
+ * /dev/urandom as a source of random numbers, but uses the lower bits
+ * of the current time if /dev/urandom is not available.  In any case,
+ * only provides 32 bits of entropy.
+ */
+void mts_seed(
+    mt_state*		state)		/* State vector to seed */
+    {
+    mts_devseed(state, DEVURANDOM);
+    }
+
+/*
+ * Choose a seed based on some fairly random input.  Prefers
+ * /dev/random as a source of random numbers, but uses the lower bits
+ * of the current time if /dev/random is not available.  In any case,
+ * only provides 32 bits of entropy.
+ */
+void mts_goodseed(
+    mt_state*		state)		/* State vector to seed */
+    {
+    mts_devseed(state, DEVRANDOM);
+    }
+
+/*
+ * Choose a seed based on a random-number device given by the caller.
+ * If that device can't be opened, use the lower 32 bits from the
+ * current time.
+ */
+static void mts_devseed(
+    mt_state*		state,		/* State vector to seed */
+    char*		seed_dev)	/* Device to seed from */
+    {
+    int			bytesread;	/* Byte count read from device */
+    int			nextbyte;	/* Index of next byte to read */
+    FILE*		ranfile;	/* Access to device */
+    union
+	{
+	char		ranbuffer[sizeof (unsigned long)];
+					/* Space for reading random int */
+	unsigned long	randomvalue;	/* Random value for initialization */
+	}
+			randomunion;	/* Union for reading random int */
+#ifdef WIN32
+    struct _timeb	tb;		/* Time of day (Windows mode) */
+#else /* WIN32 */
+    struct timeval	tv;		/* Time of day */
+    struct timezone	tz;		/* Dummy for gettimeofday */
+#endif /* WIN32 */
+
+    ranfile = fopen(seed_dev, "rb");
+    if (ranfile != NULL)
+	{
+	for (nextbyte = 0;
+	  nextbyte < (int)sizeof randomunion.ranbuffer;
+	  nextbyte += bytesread)
+	    {
+	    bytesread = fread(&randomunion.ranbuffer[nextbyte], 1,
+	      sizeof randomunion.ranbuffer - nextbyte, ranfile);
+	    if (bytesread == 0)
+		break;
+	    }
+	fclose(ranfile);
+	if (nextbyte == sizeof randomunion.ranbuffer)
+	    {
+	    mts_seed32new(state, randomunion.randomvalue);
+	    return;
+	    }
+	}
+
+    /*
+     * The device isn't available.  Use the time.  We will
+     * assume that the time of day is accurate to microsecond
+     * resolution, which is true on most modern machines.
+     */
+#ifdef WIN32
+    (void) _ftime (&tb);
+#else /* WIN32 */
+    (void) gettimeofday (&tv, &tz);
+#endif /* WIN32 */
+
+    /*
+     * We just let the excess part of the seconds field overflow
+     */
+#ifdef WIN32
+    randomunion.randomvalue = tb.time * 1000 + tb.millitm;
+#else /* WIN32 */
+    randomunion.randomvalue = tv.tv_sec * 1000000 + tv.tv_usec;
+#endif /* WIN32 */
+    mts_seed32new(state, randomunion.randomvalue);
+    }
+
+/*
+ * Choose a seed based on the best random input available.  Prefers
+ * /dev/random as a source of random numbers, and reads the entire
+ * 624-long state from that device.  Because of this approach, the
+ * function can take a long time (in real time) to complete, since
+ * /dev/random may have to wait quite a while before it can provide
+ * that much randomness.  If /dev/random is unavailable, falls back to
+ * calling mts_goodseed.
+ */
+void mts_bestseed(
+    mt_state*		state)		/* State vector to seed */
+    {
+    int			bytesread;	/* Byte count read from device */
+    int			nextbyte;	/* Index of next byte to read */
+    FILE*		ranfile;	/* Access to device */
+
+    ranfile = fopen("/dev/random", "rb");
+    if (ranfile == NULL)
+	{
+	mts_goodseed(state);
+	return;
+	}
+
+    for (nextbyte = 0;
+      nextbyte < (int)sizeof state->statevec;
+      nextbyte += bytesread)
+	{
+	bytesread = fread((char *)&state->statevec + nextbyte, 1,
+	  sizeof state->statevec - nextbyte, ranfile);
+	if (bytesread == 0)
+	    {
+	    /*
+	     * Something went wrong.  Fall back to time-based seeding.
+	     */
+	    fclose(ranfile);
+	    mts_goodseed(state);
+	    return;
+	    }
+	}
+    }
+
+/*
+ * Generate 624 more random values.  This function is called when the
+ * state vector has been exhausted.  It generates another batch of
+ * pseudo-random values.  The performance of this function is critical
+ * to the performance of the Mersenne Twist PRNG, so it has been
+ * highly optimized.
+ */
+void mts_refresh(
+    register mt_state*	state)		/* State for the PRNG */
+    {
+    register int	i;		/* Index into the state */
+    register unsigned long*
+			state_ptr;	/* Next place to get from state */
+    register unsigned long
+			value1;		/* Scratch val picked up from state */
+    register unsigned long
+			value2;		/* Scratch val picked up from state */
+
+    /*
+     * Start by making sure a random seed has been set.  If not, set
+     * one.
+     */
+    if (!state->initialized)
+	{
+	mts_seed32(state, DEFAULT_SEED32_OLD);
+	return;				/* Seed32 calls us recursively */
+	}
+
+    /*
+     * Now generate the new pseudorandom values by applying the
+     * recurrence relation.  We use two loops and a final
+     * 2-statement sequence so that we can handle the wraparound
+     * explicitly, rather than having to use the relatively slow
+     * modulus operator.
+     *
+     * In essence, the recurrence relation concatenates bits
+     * chosen from the current random value (last time around)
+     * with the immediately preceding one.  Then it
+     * matrix-multiplies the concatenated bits with a value
+     * RECURRENCE_OFFSET away and a constant matrix.  The matrix
+     * multiplication reduces to a shift and two XORs.
+     *
+     * Some comments on the optimizations are in order:
+     *
+     * Strictly speaking, none of the optimizations should be
+     * necessary.  All could conceivably be done by a really good
+     * compiler.  However, the compilers available to me aren't quite
+     * smart enough, so hand optimization needs to be done.
+     *
+     * Shawn Cokus was the first to achieve a major speedup.  In the
+     * original code, the first value given to COMBINE_BITS (in my
+     * characterization) was re-fetched from the state array, rather
+     * than being carried in a scratch variable.  Cokus noticed that
+     * the first argument to COMBINE_BITS could be saved in a register
+     * in the previous loop iteration, getting rid of the need for an
+     * expensive memory reference.
+     *
+     * Cokus also switched to using pointers to access the state
+     * array and broke the original loop into two so that he could
+     * avoid using the expensive modulus operator.  Cokus used three
+     * pointers; Richard J. Wagner noticed that the offsets between
+     * the three were constant, so that they could be collapsed into a
+     * single pointer and constant-offset accesses.  This is clearly
+     * faster on x86 architectures, and is the same cost on RISC
+     * machines.  A secondary benefit is that Cokus' version was
+     * register-starved on the x86, while Wagner's version was not.
+     *
+     * I made several smaller improvements to these observations.
+     * First, I reversed the contents of the state vector.  In the
+     * current version of the code, this change doesn't directly
+     * affect the performance of the refresh loop, but it has the nice
+     * side benefit that an all-zero state structure represents an
+     * uninitialized generator.  It also slightly speeds up the
+     * random-number routines, since they can compare the state
+     * pointer against zero instead of against a constant (this makes
+     * the biggest difference on RISC machines).
+     *
+     * Second, I returned to Matsumoto and Nishimura's original
+     * technique of using a lookup table to decide whether to xor the
+     * constant vector A (MATRIX_A in this code) with the newly
+     * computed value.  Cokus and Wagner had used the ?: operator,
+     * which requires a test and branch.  Modern machines don't like
+     * branches, so the table lookup is faster.
+     *
+     * Third, in the Cokus and Wagner versions the loop ends with a
+     * statement similar to "value1 = value2", which is necessary to
+     * carry the fetched value into the next loop iteration.  I
+     * recognized that if the loop were unrolled so that it generates
+     * two values per iteration, a bit of variable renaming would get
+     * rid of that assignment.  A nice side effect is that the
+     * overhead of loop control becomes only half as large.
+     *
+     * It is possible to improve the code's performance somewhat
+     * further.  In particular, since the second loop's loop count
+     * factors into 2*2*3*3*11, it could be unrolled yet further.
+     * That's easy to do, too: just change the "/ 2" into a division
+     * by whatever factor you choose, and then use cut-and-paste to
+     * duplicate the code in the body.  To remove a few more cycles,
+     * fix the code to decrement state_ptr by the unrolling factor, and
+     * adjust the various offsets appropriately.  However, the payoff
+     * will be small.  At the moment, the x86 version of the loop is
+     * 25 instructions, of which 3 are involved in loop control
+     * (including the decrementing of state_ptr).  Further unrolling by
+     * a factor of 2 would thus produce only about a 6% speedup.
+     *
+     * The logical extension of the unrolling
+     * approach would be to remove the loops and create 624
+     * appropriate copies of the body.  However, I think that doing
+     * the latter is a bit excessive!
+     *
+     * I suspect that a superior optimization would be to simplify the
+     * mathematical operations involved in the recurrence relation.
+     * However, I have no idea whether such a simplification is
+     * feasible.
+     */
+    state_ptr = &state->statevec[MT_STATE_SIZE - 1];
+    value1 = *state_ptr;
+    for (i = (MT_STATE_SIZE - RECURRENCE_OFFSET) / 2;  --i >= 0;  )
+	{
+	state_ptr -= 2;
+	value2 = state_ptr[1];
+	value1 = COMBINE_BITS(value1, value2);
+	state_ptr[2] =
+	  MATRIX_MULTIPLY(state_ptr[-RECURRENCE_OFFSET + 2], value1);
+	value1 = state_ptr[0];
+	value2 = COMBINE_BITS(value2, value1);
+	state_ptr[1] =
+	  MATRIX_MULTIPLY(state_ptr[-RECURRENCE_OFFSET + 1], value2);
+	}
+    value2 = *--state_ptr;
+    value1 = COMBINE_BITS(value1, value2);
+    state_ptr[1] =
+      MATRIX_MULTIPLY(state_ptr[-RECURRENCE_OFFSET + 1], value1);
+
+    for (i = (RECURRENCE_OFFSET - 1) / 2;  --i >= 0;  )
+	{
+	state_ptr -= 2;
+	value1 = state_ptr[1];
+	value2 = COMBINE_BITS(value2, value1);
+	state_ptr[2] =
+	  MATRIX_MULTIPLY(state_ptr[MT_STATE_SIZE - RECURRENCE_OFFSET + 2],
+	    value2);
+	value2 = state_ptr[0];
+	value1 = COMBINE_BITS(value1, value2);
+	state_ptr[1] =
+	  MATRIX_MULTIPLY(state_ptr[MT_STATE_SIZE - RECURRENCE_OFFSET + 1],
+	    value1);
+	}
+
+    /*
+     * The final entry in the table requires the "previous" value
+     * to be gotten from the other end of the state vector, so it
+     * must be handled specially.
+     */
+    value1 = COMBINE_BITS(value2, state->statevec[MT_STATE_SIZE - 1]);
+    *state_ptr =
+      MATRIX_MULTIPLY(state_ptr[MT_STATE_SIZE - RECURRENCE_OFFSET], value1);
+
+    /*
+     * Now that refresh is complete, reset the state pointer to allow more
+     * pseudorandom values to be fetched from the state array.
+     */
+    state->stateptr = MT_STATE_SIZE;
+    }
+
+/*
+ * Save state to a file.  The save format is compatible with Richard
+ * J. Wagner's format, although the details are different.  Returns NZ
+ * if the save succeeded.  Produces one very long line containing 625
+ * numbers.
+ */
+int mts_savestate(
+    FILE*		statefile,	/* File to save to */
+    mt_state*		state)		/* State to be saved */
+    {
+    int			i;		/* Next word to save */
+
+    if (!state->initialized)
+	mts_seed32(state, DEFAULT_SEED32_OLD);
+
+    for (i = MT_STATE_SIZE;  --i >= 0;  )
+	{
+	if (fprintf(statefile, "%lu ", state->statevec[i]) < 0)
+	    return 0;
+	}
+
+    if (fprintf(statefile, "%d\n", state->stateptr) < 0)
+	return 0;
+
+    return 1;
+    }
+
+/*
+ * Load state from a file.  Returns NZ if the load succeeded.
+ */
+int mts_loadstate(
+    FILE*		statefile,	/* File to load from */
+    mt_state*		state)		/* State to be loaded */
+    {
+    int			i;		/* Next word to load */
+
+    /*
+     * Set the state to "uninitialized" in case the load fails.
+     */
+    state->initialized = state->stateptr = 0;
+
+    for (i = MT_STATE_SIZE;  --i >= 0;  )
+	{
+	if (fscanf(statefile, "%lu", &state->statevec[i]) != 1)
+	    return 0;
+	}
+
+    if (fscanf(statefile, "%d", &state->stateptr) != 1)
+	return 0;
+
+    /*
+     * The only validity checking we can do is to insist that the
+     * state pointer be valid.
+     */
+    if (state->stateptr < 0  ||  state->stateptr > MT_STATE_SIZE)
+	{
+	state->stateptr = 0;
+	return 0;
+	}
+
+    mts_mark_initialized(state);
+
+    return 1;
+    }
+
+/*
+ * Initialize the default Mersenne Twist PRNG from a 32-bit seed.
+ *
+ * See mts_seed32 for full commentary.
+ */
+void mt_seed32(
+    unsigned long	seed)		/* 32-bit seed to start from */
+    {
+    mts_seed32(&mt_default_state, seed);
+    }
+
+/*
+ * Initialize the default Mersenne Twist PRNG from a 32-bit seed.
+ *
+ * See mts_seed32new for full commentary.
+ */
+void mt_seed32new(
+    unsigned long	seed)		/* 32-bit seed to start from */
+    {
+    mts_seed32new(&mt_default_state, seed);
+    }
+
+/*
+ * Initialize a Mersenne Twist RNG from a 624-long seed.
+ *
+ * See mts_seedfull for full commentary.
+ */
+void mt_seedfull(
+    unsigned long	seeds[MT_STATE_SIZE])
+    {
+    mts_seedfull(&mt_default_state, seeds);
+    }
+
+/*
+ * Initialize the PRNG from random input.  See mts_seed.
+ */
+void mt_seed()
+    {
+    mts_seed(&mt_default_state);
+    }
+
+/*
+ * Initialize the PRNG from random input.  See mts_goodseed.
+ */
+void mt_goodseed()
+    {
+    mts_goodseed(&mt_default_state);
+    }
+
+/*
+ * Initialize the PRNG from random input.  See mts_bestseed.
+ */
+void mt_bestseed()
+    {
+    mts_bestseed(&mt_default_state);
+    }
+
+/*
+ * Return a pointer to the current state of the PRNG.  The purpose of
+ * this function is to allow the state to be saved for later
+ * restoration.  The state should not be modified; instead, it should
+ * be reused later as a parameter to one of the mts_xxx functions.
+ */
+extern mt_state* mt_getstate()
+    {
+    return &mt_default_state;
+    }
+
+/*
+ * Save state to a file.  The save format is compatible with Richard
+ * J. Wagner's format, although the details are different.
+ */
+int mt_savestate(
+    FILE*		statefile)	/* File to save to */
+    {
+    return mts_savestate(statefile, &mt_default_state);
+    }
+
+/*
+ * Load state from a file.
+ */
+int mt_loadstate(
+    FILE*		statefile)	/* File to load from */
+    {
+    return mts_loadstate(statefile, &mt_default_state);
+    }

Added: antargis/trunk/gui/src/mtwist/mtwist.h
===================================================================
--- antargis/trunk/gui/src/mtwist/mtwist.h	2007-03-08 20:12:12 UTC (rev 1057)
+++ antargis/trunk/gui/src/mtwist/mtwist.h	2007-03-11 20:40:28 UTC (rev 1058)
@@ -0,0 +1,830 @@
+#ifndef MTWIST_H
+#define MTWIST_H
+
+/*
+ * $Id: mtwist.h,v 1.15 2003/09/11 23:56:20 geoff Exp geoff $
+ *
+ * Header file for C/C++ use of the Mersenne-Twist pseudo-RNG.  See
+ * http://www.math.keio.ac.jp/~matumoto/emt.html for full information.
+ *
+ * Author of this header file: Geoffrey H. Kuenning, March 18, 2001.
+ *
+ * IMPORTANT NOTE: the Makefile must define two machine-specific
+ * variables to get optimum features and performance:
+ *
+ *	MT_NO_INLINE	should be defined if the compiler doesn't support
+ *			the "inline" keyword.
+ *	MT_NO_LONGLONG	should be defined if the compiler doesn't support a
+ *			"long long" type for 64-bit integers
+ *	MT_MACHINE_BITS	must be either 32 or 64, reflecting the natural
+ *			size of the processor registers.  If undefined, it
+ *			will default to a value calculated from limits.h.
+ *
+ * The first two variables above are defined in an inverted sense
+ * because I expect that most compilers will support inline and
+ * long-long.  By inverting the sense, this common case will require
+ * no special compiler flags.
+ *
+ * IMPORTANT NOTE: this software assumes that the inherent width of a
+ * "long" is 32 bits.  If you are running on a machine that uses
+ * 64-bit longs, some of the declarations and code will have to be
+ * modified.
+ *
+ * The executable part of this software is based on LGPL-ed code by
+ * Takuji Nishimura.  The header file is therefore also distributed
+ * under the LGPL:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public License
+ * as published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.  You should have
+ * received a copy of the GNU Library General Public License along
+ * with this library; if not, write to the Free Foundation, Inc., 59
+ * Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * $Log: mtwist.h,v $
+ * Revision 1.15  2003/09/11 23:56:20  geoff
+ * Allow stdio references in C++ files; it turns out that ANSI has
+ * blessed it.  Declare the various functions as external even if they're
+ * inlined or being compiled directly (in mtwist.c).  Get rid of a #ifdef
+ * that can't ever be true.
+ *
+ * Revision 1.14  2003/09/11 05:50:53  geoff
+ * Don't allow stdio references from C++, since they're not guaranteed to
+ * work on all compilers.  Disable inlining using the MT_INLINE keyword
+ * rather than #defining inline, since doing the latter can affect other
+ * files and functions than our own.
+ *
+ * Revision 1.13  2003/07/01 23:29:29  geoff
+ * Refer to streams from the standard library using the correct namespace.
+ *
+ * Revision 1.12  2002/10/30 07:39:54  geoff
+ * Declare the new seeding functions.
+ *
+ * Revision 1.11  2001/06/19 00:41:16  geoff
+ * For consistency with other C++ types, don't put out a newline after
+ * the saved data.
+ *
+ * Revision 1.10  2001/06/18 10:09:24  geoff
+ * Fix some places where I forgot to set one of the result values.  Make
+ * the C++ state vector protected so the random-distributions package can
+ * pass it to the C functions.
+ *
+ * Revision 1.9  2001/06/18 05:40:12  geoff
+ * Prefix the compile options with MT_.
+ *
+ * Revision 1.8  2001/06/14 10:26:59  geoff
+ * Invert the sense of the #define flags so that the default is the
+ * normal case (if gcc is normal!).  Also default MT_MACHINE_BITS to 32.
+ *
+ * Revision 1.7  2001/06/14 10:10:38  geoff
+ * Move the critical-path PRNG code into the header file so that it can
+ * be inlined.  Add saving/loading of state.  Add functions to seed based
+ * on /dev/random or the time.  Add the function-call operator in the C++
+ * code.
+ *
+ * Revision 1.6  2001/06/11 10:00:04  geoff
+ * Add declarations of the refresh and /dev/random seeding functions.
+ * Change getstate to return a complete state pointer, since knowing the
+ * position in the state vector is critical to restoring the state.
+ *
+ * Revision 1.5  2001/04/23 08:36:03  geoff
+ * Remember to zero the state pointer when constructing, since otherwise
+ * proper initialization won't happen.
+ *
+ * Revision 1.4  2001/04/14 01:33:32  geoff
+ * Clarify the license
+ *
+ * Revision 1.3  2001/04/14 01:04:54  geoff
+ * Add a C++ class, mt_prng, that makes usage more convenient for C++
+ * programmers.
+ *
+ * Revision 1.2  2001/04/09 08:45:00  geoff
+ * Fix the name in the #ifndef wrapper, and clean up some outdated comments.
+ *
+ * Revision 1.1  2001/04/07 09:43:41  geoff
+ * Initial revision
+ *
+ */
+
+#include <stdio.h>
+#ifdef __cplusplus
+#include <iostream>
+#endif /* __cplusplus */
+
+#ifndef MT_MACHINE_BITS
+#include <limits.h>
+#if INT_MAX == 2147483647
+#define MT_MACHINE_BITS	32
+#else /* INT_MAX */
+#define MT_MACHINE_BITS	64
+#endif /* INT_MAX */
+#endif /* MT_MACHINE_BITS */
+
+/*
+ * The following value is a fundamental parameter of the algorithm.
+ * It was found experimentally using methods described in Matsumoto
+ * and Nishimura's paper.  It is exceedingly magic; don't change it.
+ */
+#define MT_STATE_SIZE	624		/* Size of the MT state vector */
+
+/*
+ * Internal state for an MT RNG.  The user can keep multiple mt_state
+ * structures around as a way of generating multiple streams of random
+ * numbers.
+ *
+ * In Matsumoto and Nishimura's original paper, the state vector was
+ * processed in a forward direction.  I have reversed the state vector
+ * in this implementation.  The reason for the reversal is that it
+ * allows the critical path to use a test against zero instead of a
+ * test against 624 to detect the need to refresh the state.  on most
+ * machines, testing against zero is slightly faster.  It also means
+ * that a state that has been set to all zeros will be correctly
+ * detected as needing initialization; this means that setting a state
+ * vector to zero (either with memset or by statically allocating it)
+ * will cause the RNG to operate properly.
+ */
+typedef struct
+    {
+    unsigned long	statevec[MT_STATE_SIZE];
+					/* Vector holding current state */
+    int			stateptr;	/* Next state entry to be used */
+    int			initialized;	/* NZ if state was initialized */
+    }
+			mt_state;
+
+#ifdef __cplusplus
+extern "C"
+    {
+#endif
+
+/*
+ * Functions for manipulating any generator (given a state pointer).
+ */
+extern void		mts_mark_initialized(mt_state* state);
+					/* Mark a PRNG state as initialized */
+extern void		mts_seed32(mt_state* state, unsigned long seed);
+					/* Set random seed for any generator */
+extern void		mts_seed32new(mt_state* state, unsigned long seed);
+					/* Set random seed for any generator */
+extern void		mts_seedfull(mt_state* state,
+			  unsigned long seeds[MT_STATE_SIZE]);
+					/* Set complicated seed for any gen. */
+extern void		mts_seed(mt_state* state);
+					/* Choose seed from random input. */
+					/* ..Prefers /dev/urandom; uses time */
+					/* ..if /dev/urandom unavailable. */
+					/* ..Only gives 32 bits of entropy. */
+extern void		mts_goodseed(mt_state* state);
+					/* Choose seed from more random */
+					/* ..input than mts_seed.  Prefers */
+					/* ../dev/random; uses time if that */
+					/* ..is unavailable.  Only gives 32 */
+					/* ..bits of entropy. */
+extern void		mts_bestseed(mt_state* state);
+					/* Choose seed from extremely random */
+					/* ..input (can be *very* slow). */
+					/* ..Prefers /dev/random and reads */
+					/* ..the entire state from there. */
+					/* ..If /dev/random is unavailable, */
+					/* ..falls back to mt_goodseed().  */
+					/* ..Not usually worth the cost.  */
+extern void		mts_refresh(mt_state* state);
+					/* Generate 624 more random values */
+extern int		mts_savestate(FILE* statefile, mt_state* state);
+					/* Save state to a file (ASCII). */
+					/* ..Returns NZ if succeeded. */
+extern int		mts_loadstate(FILE* statefile, mt_state* state);
+					/* Load state from a file (ASCII). */
+					/* ..Returns NZ if succeeded. */
+
+/*
+ * Functions for manipulating the default generator.
+ */
+extern void		mt_seed32(unsigned long seed);
+					/* Set random seed for default gen. */
+extern void		mt_seed32new(unsigned long seed);
+					/* Set random seed for default gen. */
+extern void		mt_seedfull(unsigned long seeds[MT_STATE_SIZE]);
+					/* Set complicated seed for default */
+extern void		mt_seed(void);	/* Choose seed from random input. */
+					/* ..Prefers /dev/urandom; uses time */
+					/* ..if /dev/urandom unavailable. */
+					/* ..Only gives 32 bits of entropy. */
+extern void		mt_goodseed(void);
+					/* Choose seed from more random */
+					/* ..input than mts_seed.  Prefers */
+					/* ../dev/random; uses time if that */
+					/* ..is unavailable.  Only gives 32 */
+					/* ..bits of entropy. */
+extern void		mt_bestseed(void);
+					/* Choose seed from extremely random */
+					/* ..input (can be *very* slow). */
+					/* ..Prefers /dev/random and reads */
+					/* ..the entire state from there. */
+					/* ..If /dev/random is unavailable, */
+					/* ..falls back to mt_goodseed().  */
+					/* ..Not usually worth the cost.  */
+extern mt_state*	mt_getstate(void);
+					/* Get current state of default */
+					/* ..generator */
+extern int		mt_savestate(FILE* statefile);
+					/* Save state to a file (ASCII) */
+					/* ..Returns NZ if succeeded. */
+extern int		mt_loadstate(FILE* statefile);
+					/* Load state from a file (ASCII) */
+					/* ..Returns NZ if succeeded. */
+
+#ifdef __cplusplus
+    }
+#endif
+
+/*
+ * Functions for generating random numbers.  The actual code of the
+ * functions is given in this file so that it can be declared inline.
+ * For compilers that don't have the inline feature, mtwist.c will
+ * incorporate this file with some clever #defining so that the code
+ * actually gets compiled.  In that case, however, "extern"
+ * definitions will be needed here, so we give them.
+ */
+#ifdef __cplusplus
+#undef MT_NO_INLINE			/* C++ definitely has inlining */
+#endif /* __cplusplus */
+
+extern unsigned long	mts_lrand(mt_state* state);
+					/* Generate 32-bit value, any gen. */
+#ifndef MT_NO_LONGLONG
+extern unsigned long long
+			mts_llrand(mt_state* state);
+					/* Generate 64-bit value, any gen. */
+#endif /* MT_NO_LONGLONG */
+extern double		mts_drand(mt_state* state);
+					/* Generate floating value, any gen. */
+					/* Fast, with only 32-bit precision */
+extern double		mts_ldrand(mt_state* state);
+					/* Generate floating value, any gen. */
+					/* Slower, with 64-bit precision */
+
+extern unsigned long	mt_lrand(void);	/* Generate 32-bit random value */
+#ifndef MT_NO_LONGLONG
+extern unsigned long long
+			mt_llrand(void);
+					/* Generate 64-bit random value */
+#endif /* MT_NO_LONGLONG */
+extern double		mt_drand(void);
+					/* Generate floating value */
+					/* Fast, with only 32-bit precision */
+extern double		mt_ldrand(void);
+					/* Generate floating value */
+					/* Slower, with 64-bit precision */
+
+#ifndef MT_NO_INLINE
+/*
+ * Tempering parameters.  These are perhaps the most magic of all the magic
+ * values in the algorithm.  The values are again experimentally determined.
+ * The values generated by the recurrence relation (constants above) are not
+ * equidistributed in 623-space.  For some reason, the tempering process
+ * produces that effect.  Don't ask me why.  Read the paper if you can
+ * understand the math.  Or just trust these magic numbers.
+ */
+#define MT_TEMPERING_MASK_B 0x9d2c5680
+#define MT_TEMPERING_MASK_C 0xefc60000
+#define MT_TEMPERING_SHIFT_U(y) \
+			(y >> 11)
+#define MT_TEMPERING_SHIFT_S(y) \
+			(y << 7)
+#define MT_TEMPERING_SHIFT_T(y) \
+			(y << 15)
+#define MT_TEMPERING_SHIFT_L(y) \
+			(y >> 18)
+
+/*
+ * Macros to do the tempering.  MT_PRE_TEMPER does all but the last step;
+ * it's useful for situations where the final step can be incorporated
+ * into a return statement.  MT_FINAL_TEMPER does that final step (not as
+ * an assignment).  MT_TEMPER does the entire process.  Note that
+ * MT_PRE_TEMPER and MT_TEMPER both modify their arguments.
+ */
+#define MT_PRE_TEMPER(value)						\
+    do									\
+	{								\
+	value ^= MT_TEMPERING_SHIFT_U(value);				\
+	value ^= MT_TEMPERING_SHIFT_S(value) & MT_TEMPERING_MASK_B;	\
+	value ^= MT_TEMPERING_SHIFT_T(value) & MT_TEMPERING_MASK_C;	\
+	}								\
+	while (0)
+#define MT_FINAL_TEMPER(value) \
+			((value) ^ MT_TEMPERING_SHIFT_L(value))
+#define MT_TEMPER(value)						\
+    do									\
+	{								\
+	value ^= MT_TEMPERING_SHIFT_U(value);				\
+	value ^= MT_TEMPERING_SHIFT_S(value) & MT_TEMPERING_MASK_B;	\
+	value ^= MT_TEMPERING_SHIFT_T(value) & MT_TEMPERING_MASK_C;	\
+	value ^= MT_TEMPERING_SHIFT_L(value);				\
+	}								\
+	while (0)
+
+extern mt_state		mt_default_state;
+					/* State of the default generator */
+extern double		mt_32_to_double;
+					/* Multiplier to convert long to dbl */
+extern double		mt_64_to_double;
+					/* Mult'r to cvt long long to dbl */
+
+/*
+ * In gcc, inline functions must be declared extern or they'll produce
+ * assembly code (and thus linking errors).  We have to work around
+ * that difficulty with the MT_EXTERN define.
+ */
+#ifndef MT_EXTERN
+#ifdef __cplusplus
+#define MT_EXTERN			/* C++ doesn't need static */
+#else /* __cplusplus */
+#define MT_EXTERN	extern		/* C (at least gcc) needs extern */
+#endif /* __cplusplus */
+#endif /* MT_EXTERN */
+
+/*
+ * Make it possible for mtwist.c to disable the inline keyword.  We
+ * use our own keyword so that we don't interfere with inlining in
+ * C/C++ header files, above.
+ */
+#ifndef MT_INLINE
+#define MT_INLINE	inline		/* Compiler has inlining */
+#endif /* MT_INLINE */
+
+/*
+ * Generate a random number in the range 0 to 2^32-1, inclusive, working
+ * from a given state vector.
+ *
+ * The generator is optimized for speed.  The primary optimization is that
+ * the pseudorandom numbers are generated in batches of MT_STATE_SIZE.  This
+ * saves the cost of a modulus operation in the critical path.
+ */
+MT_EXTERN MT_INLINE unsigned long mts_lrand(
+    register mt_state*	state)		/* State for the PRNG */
+    {
+    register unsigned long
+			random_value;	/* Pseudorandom value generated */
+
+    if (state->stateptr <= 0)
+	mts_refresh(state);
+
+    random_value = state->statevec[--state->stateptr];
+    MT_PRE_TEMPER(random_value);
+    return MT_FINAL_TEMPER(random_value);
+    }
+
+#ifndef MT_NO_LONGLONG
+/*
+ * Generate a random number in the range 0 to 2^64-1, inclusive, working
+ * from a given state vector.
+ *
+ * According to Matsumoto and Nishimura, such a number can be generated by
+ * simply concatenating two 32-bit pseudorandom numbers.  Who am I to argue?
+ *
+ * Note that there is a slight inefficiency here: if the 624-entry state is
+ * recycled on the second call to mts_lrand, there will be an unnecessary
+ * check to see if the state has been initialized.  The cost of that check
+ * seems small (since it happens only once every 624 random numbers, and
+ * never if only 64-bit numbers are being generated), so I didn't bother to
+ * optimize it out.  Doing so would be messy, since it would require two
+ * nearly-identical internal implementations of mts_lrand.
+ */
+MT_EXTERN MT_INLINE unsigned long long mts_llrand(
+    register mt_state*	state)		/* State for the PRNG */
+    {
+    register unsigned long
+			random_value_1;	/* 1st pseudorandom value generated */
+    register unsigned long
+			random_value_2;	/* 2nd pseudorandom value generated */
+
+    /*
+     * For maximum speed, we'll handle the two overflow cases
+     * together.  That will save us one test in the common case, at
+     * the expense of an extra one in the overflow case.
+     */
+    if (--state->stateptr <= 0)
+	{
+	if (state->stateptr < 0)
+	    {
+	    mts_refresh(state);
+	    random_value_1 = state->statevec[--state->stateptr];
+	    }
+	else
+	    {
+	    random_value_1 = state->statevec[state->stateptr];
+	    mts_refresh(state);
+	    }
+	}
+    else
+	random_value_1 = state->statevec[--state->stateptr];
+
+    MT_TEMPER(random_value_1);
+
+    random_value_2 = state->statevec[--state->stateptr];
+    MT_PRE_TEMPER(random_value_2);
+
+    return ((unsigned long long) random_value_1 << 32)
+      | (unsigned long long) MT_FINAL_TEMPER(random_value_2);
+    }
+#endif /* MT_NO_LONGLONG */
+
+/*
+ * Generate a double-precision random number between 0 (inclusive) and 1.0
+ * (exclusive).  This function is optimized for speed, but it only generates
+ * 32 bits of precision.  Use mts_ldrand to get 64 bits of precision.
+ */
+MT_EXTERN MT_INLINE double mts_drand(
+    register mt_state*	state)		/* State for the PRNG */
+    {
+    register unsigned long
+			random_value;	/* Pseudorandom value generated */
+
+    if (state->stateptr <= 0)
+	mts_refresh(state);
+
+    random_value = state->statevec[--state->stateptr];
+    MT_TEMPER(random_value);
+
+    return random_value * mt_32_to_double;
+    }
+
+/*
+ * Generate a double-precision random number between 0 (inclusive) and 1.0
+ * (exclusive).  This function generates 64 bits of precision.  Use
+ * mts_drand for more speed but less precision.
+ */
+MT_EXTERN MT_INLINE double mts_ldrand(
+    register mt_state*	state)		/* State for the PRNG */
+    {
+#if MT_MACHINE_BITS == 64
+    unsigned long long	final_value;	/* Final (integer) value */
+#endif /* MT_MACHINE_BITS */
+    register unsigned long
+			random_value_1;	/* 1st pseudorandom value generated */
+    register unsigned long
+			random_value_2;	/* 2nd pseudorandom value generated */
+
+    /*
+     * For maximum speed, we'll handle the two overflow cases
+     * together.  That will save us one test in the common case, at
+     * the expense of an extra one in the overflow case.
+     */
+    if (--state->stateptr <= 0)
+	{
+	if (state->stateptr < 0)
+	    {
+	    mts_refresh(state);
+	    random_value_1 = state->statevec[--state->stateptr];
+	    }
+	else
+	    {
+	    random_value_1 = state->statevec[state->stateptr];
+	    mts_refresh(state);
+	    }
+	}
+    else
+	random_value_1 = state->statevec[--state->stateptr];
+
+    MT_TEMPER(random_value_1);
+
+    random_value_2 = state->statevec[--state->stateptr];
+    MT_TEMPER(random_value_2);
+
+#if MT_MACHINE_BITS == 64
+    final_value = ((unsigned long long) random_value_1 << 32)
+      | (unsigned long long) random_value_2;
+    return final_value * mt_64_to_double;
+#else /* MT_MACHINE_BITS */
+    return random_value_1 * mt_32_to_double + random_value_2 * mt_64_to_double;
+#endif /* MT_MACHINE_BITS */
+    }
+
+/*
+ * Generate a random number in the range 0 to 2^32-1, inclusive, working
+ * from the default state vector.
+ *
+ * See mts_lrand for full commentary.
+ */
+MT_EXTERN MT_INLINE unsigned long mt_lrand()
+    {
+    register unsigned long
+			random_value;	/* Pseudorandom value generated */
+
+    if (mt_default_state.stateptr <= 0)
+	mts_refresh(&mt_default_state);
+
+    random_value = mt_default_state.statevec[--mt_default_state.stateptr];
+    MT_PRE_TEMPER(random_value);
+
+    return MT_FINAL_TEMPER(random_value);
+    }
+
+#ifndef MT_NO_LONGLONG
+/*
+ * Generate a random number in the range 0 to 2^64-1, inclusive, working
+ * from the default state vector.
+ *
+ * See mts_llrand for full commentary.
+ */
+MT_EXTERN MT_INLINE unsigned long long mt_llrand()
+    {
+    register unsigned long
+			random_value_1;	/* 1st pseudorandom value generated */
+    register unsigned long
+			random_value_2;	/* 2nd pseudorandom value generated */
+
+    /*
+     * For maximum speed, we'll handle the two overflow cases
+     * together.  That will save us one test in the common case, at
+     * the expense of an extra one in the overflow case.
+     */
+    if (--mt_default_state.stateptr <= 0)
+	{
+	if (mt_default_state.stateptr < 0)
+	    {
+	    mts_refresh(&mt_default_state);
+	    random_value_1 =
+	      mt_default_state.statevec[--mt_default_state.stateptr];
+	    }
+	else
+	    {
+	    random_value_1 =
+	      mt_default_state.statevec[mt_default_state.stateptr];
+	    mts_refresh(&mt_default_state);
+	    }
+	}
+    else
+	random_value_1 =
+	  mt_default_state.statevec[--mt_default_state.stateptr];
+
+    MT_TEMPER(random_value_1);
+
+    random_value_2 = mt_default_state.statevec[--mt_default_state.stateptr];
+    MT_PRE_TEMPER(random_value_2);
+
+    return ((unsigned long long) random_value_1 << 32)
+      | (unsigned long long) MT_FINAL_TEMPER(random_value_2);
+    }
+#endif /* MT_NO_LONGLONG */
+
+/*
+ * Generate a double-precision random number between 0 (inclusive) and 1.0
+ * (exclusive).  This function is optimized for speed, but it only generates
+ * 32 bits of precision.  Use mt_ldrand to get 64 bits of precision.
+ */
+MT_EXTERN MT_INLINE double mt_drand()
+    {
+    register unsigned long
+			random_value;	/* Pseudorandom value generated */
+
+    if (mt_default_state.stateptr <= 0)
+	mts_refresh(&mt_default_state);
+
+    random_value = mt_default_state.statevec[--mt_default_state.stateptr];
+    MT_TEMPER(random_value);
+
+    return random_value * mt_32_to_double;
+    }
+
+/*
+ * Generate a double-precision random number between 0 (inclusive) and 1.0
+ * (exclusive).  This function generates 64 bits of precision.  Use
+ * mts_drand for more speed but less precision.
+ */
+MT_EXTERN MT_INLINE double mt_ldrand(void)
+    {
+#if MT_MACHINE_BITS == 64
+    unsigned long long	final_value;	/* Final (integer) value */
+#endif /* MT_MACHINE_BITS */
+    register unsigned long
+			random_value_1;	/* 1st pseudorandom value generated */
+    register unsigned long
+			random_value_2;	/* 2nd pseudorandom value generated */
+
+    /*
+     * For maximum speed, we'll handle the two overflow cases
+     * together.  That will save us one test in the common case, at
+     * the expense of an extra one in the overflow case.
+     */
+    if (--mt_default_state.stateptr <= 0)
+	{
+	if (mt_default_state.stateptr < 0)
+	    {
+	    mts_refresh(&mt_default_state);
+	    random_value_1 =
+	      mt_default_state.statevec[--mt_default_state.stateptr];
+	    }
+	else
+	    {
+	    random_value_1 =
+	      mt_default_state.statevec[mt_default_state.stateptr];
+	    mts_refresh(&mt_default_state);
+	    }
+	}
+    else
+	random_value_1 =
+	  mt_default_state.statevec[--mt_default_state.stateptr];
+
+    MT_TEMPER(random_value_1);
+
+    random_value_2 = mt_default_state.statevec[--mt_default_state.stateptr];
+    MT_TEMPER(random_value_2);
+
+#if MT_MACHINE_BITS == 64
+    final_value = ((unsigned long long) random_value_1 << 32)
+      | (unsigned long long) random_value_2;
+    return final_value * mt_64_to_double;
+#else /* MT_MACHINE_BITS */
+    return random_value_1 * mt_32_to_double + random_value_2 * mt_64_to_double;
+#endif /* MT_MACHINE_BITS */
+    }
+
+#endif /* MT_NO_INLINE */
+
+#ifdef __cplusplus
+/*
+ * C++ interface to the Mersenne Twist PRNG.  This class simply
+ * provides a more C++-ish way to access the PRNG.  Only state-based
+ * functions are provided.  All functions are inlined, both for speed
+ * and so that the same implementation code can be used in C and C++.
+ */
+class mt_prng
+    {
+    public:
+	/*
+	 * Constructors and destructors.  The default constructor
+	 * leaves initialization (seeding) for later unless pickSeed
+	 * is true, in which case the seed is chosen based on either
+	 * /dev/urandom (if available) or the system time.  The other
+	 * constructors accept either a 32-bit seed, or a full
+	 * 624-long seed.
+	 */
+			mt_prng(	// Default constructor
+			    bool pickSeed = false)
+					// True to get seed from /dev/urandom
+					// ..or time
+			    {
+			    state.stateptr = 0;
+			    state.initialized = 0;
+			    if (pickSeed)
+				mts_seed(&state);
+			    }
+			mt_prng(unsigned long seed)
+					// Construct with 32-bit seeding
+			    {
+			    state.stateptr = 0;
+			    state.initialized = 0;
+			    mts_seed32(&state, seed);
+			    }
+			mt_prng(unsigned long seeds[MT_STATE_SIZE])
+					// Construct with full seeding
+			    {
+			    state.stateptr = 0;
+			    state.initialized = 0;
+			    mts_seedfull(&state, seeds);
+			    }
+			~mt_prng() { }
+
+	/*
+	 * Copy and assignment are best left defaulted.
+	 */
+
+	/*
+	 * PRNG seeding functions.
+	 */
+	void		seed32(unsigned long seed)
+					// Set 32-bit random seed
+			    {
+			    mts_seed32(&state, seed);
+			    }
+	void		seed32new(unsigned long seed)
+					// Set 32-bit random seed
+			    {
+			    mts_seed32new(&state, seed);
+			    }
+	void		seedfull(unsigned long seeds[MT_STATE_SIZE])
+					// Set complicated random seed
+			    {
+			    mts_seedfull(&state, seeds);
+			    }
+	void		seed()		// Choose seed from random input
+			    {
+			    mts_seed(&state);
+			    }
+	void		goodseed()	// Choose better seed from random input
+			    {
+			    mts_goodseed(&state);
+			    }
+	void		bestseed()	// Choose best seed from random input
+			    {
+			    mts_bestseed(&state);
+			    }
+	friend std::ostream&
+			operator<<(std::ostream& stream, const mt_prng& rng);
+	friend std::istream&
+			operator>>(std::istream& stream, mt_prng& rng);
+
+	/*
+	 * PRNG generation functions
+	 */
+	unsigned long	lrand()		// Generate 32-bit pseudo-random value
+			    {
+			    return mts_lrand(&state);
+			    }
+#ifndef MT_NO_LONGLONG
+	unsigned long long
+			llrand()	// Generate 64-bit pseudo-random value
+			    {
+			    return mts_llrand(&state);
+			    }
+#endif /* MT_NO_LONGLONG */
+	double		drand()		// Generate fast 32-bit floating value
+			    {
+			    return mts_drand(&state);
+			    }
+	double		ldrand()	// Generate slow 64-bit floating value
+			    {
+			    return mts_ldrand(&state);
+			    }
+
+	/*
+	 * Following Richard J. Wagner's example, we overload the
+	 * function-call operator to return a 32-bit floating value.
+	 * That allows the common use of the PRNG to be simplified as
+	 * in the following example:
+	 *
+	 *	mt_prng ranno(true);
+	 *	// ...
+	 *	coinFlip = ranno() >= 0.5 ? heads : tails;
+	 */
+	double		operator()()
+			    {
+			    return mts_drand(&state);
+			    }
+    protected:
+	/*
+	 * Protected data
+	 */
+	mt_state	state;		// Current state of the PRNG
+    };
+
+/*
+ * Save state to a stream.  See mts_savestate.
+ */
+MT_INLINE std::ostream& operator<<(
+    std::ostream&	stream,		// Stream to save to
+    const mt_prng&	rng)		// PRNG to save
+    {
+    for (int i = MT_STATE_SIZE;  --i >= 0;  )
+	{
+	if (!(stream << rng.state.statevec[i] << ' '))
+	    return stream;
+	}
+
+    return stream << rng.state.stateptr;
+    }
+
+/*
+ * Restore state from a stream.  See mts_loadstate.
+ */
+MT_INLINE std::istream& operator>>(
+    std::istream&	stream,		// Stream to laod from
+    mt_prng&		rng)		// PRNG to load
+    {
+    rng.state.initialized = rng.state.stateptr = 0;
+    for (int i = MT_STATE_SIZE;  --i >= 0;  )
+	{
+	if (!(stream >> rng.state.statevec[i]))
+	    return stream;
+	}
+
+    if (!(stream >> rng.state.stateptr))
+	{
+	rng.state.stateptr = 0;
+	return stream;
+	}
+
+    /*
+     * If the state is invalid, all we can do is to make it uninitialized.
+     */
+    if (rng.state.stateptr < 0  ||  rng.state.stateptr > MT_STATE_SIZE)
+	{
+	rng.state.stateptr = 0;
+	return stream;
+	}
+
+    mts_mark_initialized(&rng.state);
+
+    return stream;
+    }
+#endif
+
+#endif /* MTWIST_H */

Added: antargis/trunk/gui/src/mtwist/randistrs.3
===================================================================
--- antargis/trunk/gui/src/mtwist/randistrs.3	2007-03-08 20:12:12 UTC (rev 1057)
+++ antargis/trunk/gui/src/mtwist/randistrs.3	2007-03-11 20:40:28 UTC (rev 1058)
@@ -0,0 +1,321 @@
+.\"
+.\" $Id: randistrs.3,v 1.2 2001/06/19 00:41:17 geoff Exp $
+.\"
+.\" $Log: randistrs.3,v $
+.\" Revision 1.2  2001/06/19 00:41:17  geoff
+.\" Add documentation of the new "l" versions of all the functions.
+.\"
+.\" Revision 1.1  2001/06/18 10:04:20  geoff
+.\" Initial revision
+.\"
+.\" 
+.TH randistrs 3 "June 18, 2001" "" "Linux Programmer's Manual"
+.SH NAME
+rds_iuniform, rds_liuniform, rds_uniform, rds_luniform,
+rds_exponential, rds_lexponential, rds_erlang, rds_lerlang,
+rds_weibull, rds_lweibull, rds_normal, rds_lnormal, rds_lognormal,
+rds_llognormal, rds_triangular, rds_ltriangular, rds_empirical,
+rds_lempirical, rd_iuniform, rd_liuniform, rd_uniform, rd_luniform,
+rd_exponential, rd_lexponential, rd_erlang, rd_lerlang, rd_weibull,
+rd_lweibull, rd_normal, rd_lnormal, rd_lognormal, rd_llognormal,
+rd_triangular, rd_ltriangular, rd_empirical rd_lempirical \- generate
+pseudo-random numbers in various distributions
+.SH SYNOPSIS
+.nf
+.IR "#defines" " (see below)"
+.br
+.B
+#include "randistrs.h"
+.sp
+C interface:
+.R
+.sp
+.BI "long rds_iuniform(mt_state* " state ", long " lower ", long " upper ");"
+.sp
+.BI "long long rds_liuniform(mt_state* " state ","
+.BI "                  long long " lower ", long long " upper ");"
+.sp
+.BI "double rds_uniform(mt_state* " state ", double " lower ", double " upper ");"
+.sp
+.BI "double rds_luniform(mt_state* " state ", double " lower ", double " upper ");"
+.sp
+.BI "double rds_exponential(mt_state* " state ", double " mean ");"
+.sp
+.BI "double rds_lexponential(mt_state* " state ", double " mean ");"
+.sp
+.BI "double rds_erlang(mt_state* " state ", int " p ", double " mean ");"
+.sp
+.BI "double rds_lerlang(mt_state* " state ", int " p ", double " mean ");"
+.sp
+.BI "double rds_weibull(mt_state* " state ", double " shape ", double " scale ");"
+.sp
+.BI "double rds_lweibull(mt_state* " state ", double " shape ", double " scale ");"
+.sp
+.BI "double rds_normal(mt_state* " state ", double " mean ", double " sigma ");"
+.sp
+.BI "double rds_lnormal(mt_state* " state ", double " mean ", double " sigma ");"
+.sp
+.BI "double rds_lognormal(mt_state* " state ", double " shape ", double " scale ");"
+.sp
+.BI "double rds_llognormal(mt_state* " state ", double " shape ", double " scale ");"
+.sp
+.BI "double rds_triangular(mt_state* " state ", double " lower ","
+.BI "                      double " upper ", double " mode ");"
+.sp
+.BI "double rds_ltriangular(mt_state* " state ", double " lower ","
+.BI "                      double " upper ", double " mode ");"
+.sp
+.BI "double rds_empirical(mt_state* " state ", int " n_probs ","
+.BI "                     double* " values ", double* " probs ");"
+.sp
+.BI "double rds_lempirical(mt_state* " state ", int " n_probs ","
+.BI "                     double* " values ", double* " probs ");"
+.sp
+.BI "long rd_iuniform(long " lower ", long " upper ");"
+.sp
+.BI "long long rd_liuniform(long long " lower ", long long " upper ");"
+.sp
+.BI "double rd_uniform(double " lower ", double " upper ");"
+.sp
+.BI "double rd_luniform(double " lower ", double " upper ");"
+.sp
+.BI "double rd_exponential(double " mean ");"
+.sp
+.BI "double rd_lexponential(double " mean ");"
+.sp
+.BI "double rd_erlang(int " p ", double " mean ");"
+.sp
+.BI "double rd_lerlang(int " p ", double " mean ");"
+.sp
+.BI "double rd_weibull(double " shape ", double " scale ");"
+.sp
+.BI "double rd_lweibull(double " shape ", double " scale ");"
+.sp
+.BI "double rd_normal(double " mean ", double " sigma ");"
+.sp
+.BI "double rd_lnormal(double " mean ", double " sigma ");"
+.sp
+.BI "double rd_lognormal(double " shape ", double " scale ");"
+.sp
+.BI "double rd_llognormal(double " shape ", double " scale ");"
+.sp
+.BI "double rd_triangular(double " lower ", double " upper ", double " mode ");"
+.sp
+.BI "double rd_ltriangular(double " lower ", double " upper ", double " mode ");"
+.sp
+.BI "double rd_empirical(int " n_probs ", double* " values ", double* " probs ");"
+.sp
+.BI "double rd_lempirical(int " n_probs ", double* " values ", double* " probs ");"
+.sp
+.B "C++ interface:"
+.sp
+.BI "mt_distribution " rng ;
+.sp
+.BI "long " rng ".iuniform(long " lower ", long " upper ");"
+.sp
+.BI "long long " rng ".liuniform(long long " lower ", long long " upper ");"
+.sp
+.BI "double " rng ".uniform(double " lower ", double " upper ");"
+.sp
+.BI "double " rng ".luniform(double " lower ", double " upper ");"
+.sp
+.BI "double " rng ".exponential(double " mean ");"
+.sp
+.BI "double " rng ".lexponential(double " mean ");"
+.sp
+.BI "double " rng ".erlang(int " p ", double " mean ");"
+.sp
+.BI "double " rng ".lerlang(int " p ", double " mean ");"
+.sp
+.BI "double " rng ".weibull(double " shape ", double " scale ");"
+.sp
+.BI "double " rng ".lweibull(double " shape ", double " scale ");"
+.sp
+.BI "double " rng ".normal(double " mean ", double " sigma ");"
+.sp
+.BI "double " rng ".lnormal(double " mean ", double " sigma ");"
+.sp
+.BI "double " rng ".lognormal(double " shape ", double " scale ");"
+.sp
+.BI "double " rng ".llognormal(double " shape ", double " scale ");"
+.sp
+.BI "double " rng ".triangular(double " lower ", double " upper ", double " mode ");"
+.sp
+.BI "double " rng ".ltriangular(double " lower ", double " upper ", double " mode ");"
+.sp
+.BI "double " rng ".empirical(int " n_probs ", double* " values ", double* " probs ");"
+.SH DESCRIPTION
+.BI "double " rng ".lempirical(int " n_probs ", double* " values ", double* " probs ");"
+.SH DESCRIPTION
+These functions generate pseudo-random numbers in various
+distributions using the Mersenne Twist algorithm described in
+.BR mtwist (3).
+.PP
+Depending on the compiler and architecture, it may be necessary to
+.B #define
+either or both of
+.B MT_NO_INLINE
+or
+.B MT_NO_LONGLONG
+before including the
+.B randistrs.h
+header file;
+see
+.BR mtwist (3)
+for more information.
+.PP
+The C interface provides four flavors of each function:
+.BI rds_ xxx\fR,\fP
+.BI rds_l xxx\fR,\fP
+.BI rd_ xxx\fR,\fP
+and
+.BI rd_l xxx\fR.\fP
+The "\fBrds\fP" versions
+accept an explicit Mersenne Twist state vector, as
+described in
+.BR mtwist (3).
+The "\fBrd\fP" versions use the default global state vector;
+in general these functions should be avoided except for unimportant
+applications.
+The versions with no "\fBl\fP" after the underscore use the 32-bit
+version of the PRNG, while the "\fBl\fP" versions generate more bits
+(usually 53) to increase the accuracy of the generated distribution at
+the expense of speed.
+.PP
+In the C++ interface, the
+.B mt_distribution
+class is derived from
+.B mt_prng
+(see
+.BR mtwist (3)),
+and provides all the functionality of that class as well as the
+extended functions for generating specific distributions.
+.PP
+With the exception of the
+.B *iuniform
+functions, all functions return a double-precision result.
+The range of the result depends on the distribution and the
+parameters.
+However, in all cases the precision of the result of non-"\fBl\fP"
+functions is limited to 32
+bits, or about 1 part in 4 billion.
+.PP
+The
+.B *iuniform
+functions generate integers selected from a uniform distribution in
+the range
+.RI ( lower ,
+.IR upper ].
+If the total range given to the non-"\fBl\fP" functions is less than
+429497, a fast but slightly
+inaccurate method is used; the bias in this case will never exceed
+.01%.
+If the range exceeds that value, a slightly slower but precise method
+is used.
+.PP
+The
+.B *liuniform
+functions also generate uniformly distributed integers, but they will
+support a range greater than 4294967295.
+The
+.B *liuniform
+functions should never be used unless a large range is required.
+.PP
+The
+.B *uniform
+functions generate double-precision numbers selected from a uniform
+distribution in the range
+.RI ( lower ,
+.IR upper ].
+This function should
+.I not
+be used to generate uniformly distributed random integers.
+Use the
+.I *iuniform
+family instead.
+.PP
+The
+.B *exponential
+functions generate an exponential distribution with the given mean.
+The
+.B *erlang
+functions generate a
+.IR p -Erlang
+distribution with the given mean.
+The
+.B *weibull
+functions generate a Weibull function with the given shape and scale
+parameters.
+.PP
+The
+.B *normal
+functions generate a normal (Gaussian) distribution with the given
+mean and a standard deviation equal to
+.IR sigma .
+The
+.B *lognormal
+functions generate a lognormal distribution with the given shape and
+scale parameters.
+.PP
+The
+.B *triangular
+functions generate a triangular distribution in the range 
+.RI ( lower ,
+.IR upper ]
+and with the given mode.
+.PP
+Finally, the
+.B *empirical
+functions generate empirically determined distributions.
+The caller must supply an array of
+.I n_probs
+probabilities in
+.I probs
+and an array of
+.IR n_probs +1
+.IR values .
+The result will be
+.IR values [0]
+with probability
+.IR probs [0],
+.IR values [1]
+with probability
+.IR probs [1],
+and so forth.
+The extra value,
+.IR values [ n_probs ],
+will appear with a probability equal to 1 minus the sum of the
+preceding probabilities.
+There is little point in using the "\fBl\fP" versions of the
+.B *empirical
+functions unless you have strong evidence to the contrary.
+.SH NOTES
+.PP
+It would be helpful if the package supported even more distributions.
+.PP
+The
+.B *iuniform
+functions keep internal state in an attempt to speed up their
+performance when the range is large.
+This internal state makes them non-reentrant.
+.PP
+When the range is small,
+.B *iuniform
+functions exhibit a very slight bias in favor of some values.
+This bias isn't significant for any application less demanding than
+gambling.
+To eliminate the bias, compile
+.B randistrs.c
+with
+.B RD_MAX_BIAS
+set to zero.
+.PP
+The state-saving optimization in the
+.B *iuniform
+functions doesn't help when they are called with varying ranges, even
+if a different state vector is used for each range.
+.SH "SEE ALSO"
+.BR mtwist (3)
+.PP
+Any good statistics or simulation textbook for descriptions of the
+distributions.

Added: antargis/trunk/gui/src/mtwist/randistrs.c
===================================================================
--- antargis/trunk/gui/src/mtwist/randistrs.c	2007-03-08 20:12:12 UTC (rev 1057)
+++ antargis/trunk/gui/src/mtwist/randistrs.c	2007-03-11 20:40:28 UTC (rev 1058)
@@ -0,0 +1,911 @@
+#ifndef lint
+static char Rcs_Id[] =
+    "$Id: randistrs.c,v 1.7 2005/05/17 21:40:10 geoff Exp $";
+#endif
+
+/*
+ * C library functions for generating various random distributions
+ * using the Mersenne Twist PRNG.  See the header file for full
+ * documentation.
+ *
+ * These functions were written by Geoffrey H. Kuenning, Claremont, CA.
+ *
+ * Unless otherwise specified, these algorithms are taken from Averill
+ * M. Law and W. David Kelton, "Simulation Modeling and Analysis",
+ * McGraw-Hill, 1991.
+ *
+ * Copyright 2001, 2002, Geoffrey H. Kuenning, Claremont, CA.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All modifications to the source code must be clearly marked as
+ *    such.  Binary redistributions based on modified source code
+ *    must be clearly marked as modified versions in the documentation
+ *    and/or other materials provided with the distribution.
+ * 4. The name of Geoff Kuenning may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY GEOFF KUENNING AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL GEOFF KUENNING OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $Log: randistrs.c,v $
+ * Revision 1.7  2005/05/17 21:40:10  geoff
+ * Fix a bug that caused rds_iuniform to generate off-by-one values if the
+ * lower bound was negative.
+ *
+ * Revision 1.6  2002/10/30 00:50:44  geoff
+ * Add a (BSD-style) license.  Fix all places where logs are taken so
+ * that there is no risk of unintentionally taking the log of zero.  This
+ * is a very low-probability occurrence, but it's better to have robust
+ * code.
+ *
+ * Revision 1.5  2001/06/20 09:07:57  geoff
+ * Fix a place where long long wasn't conditionalized.
+ *
+ * Revision 1.4  2001/06/19 00:41:17  geoff
+ * Add the "l" versions of all functions.  Add the MT_NO_CACHING option.
+ *
+ * Revision 1.3  2001/06/18 10:09:24  geoff
+ * Add the iuniform functions to generate unbiased uniformly distributed
+ * integers.
+ *
+ * Revision 1.2  2001/04/10 09:11:38  geoff
+ * Make sure the Erlang distribution has a p of 1 or more.  Fix a serious
+ * bug in the Erlang calculation (the value returned was completely
+ * wrong).
+ *
+ * Revision 1.1  2001/04/09 08:39:54  geoff
+ * Initial revision
+ *
+ */
+
+#include "mtwist.h"
+#include "randistrs.h"
+#include <math.h>
+
+/*
+ * Table of contents:
+ */
+long			rds_iuniform(mt_state * state, long lower, long upper);
+					/* (Integer) uniform distribution */
+#ifndef MT_NO_LONGLONG
+long long		rds_liuniform(mt_state * state, long long lower,
+			  long long upper);
+					/* (Integer) uniform distribution */
+#endif /* MT_NO_LONGLONG */
+double			rds_uniform(mt_state * state,
+			  double lower, double upper);
+					/* (Floating) uniform distribution */
+double			rds_luniform(mt_state * state,
+			  double lower, double upper);
+					/* (Floating) uniform distribution */
+double			rds_exponential(mt_state * state, double mean);
+					/* Exponential distribution */
+double			rds_lexponential(mt_state * state, double mean);
+					/* Exponential distribution */
+double			rds_erlang(mt_state * state, int p, double mean);
+					/* p-Erlang distribution */
+double			rds_lerlang(mt_state * state, int p, double mean);
+					/* p-Erlang distribution */
+double			rds_weibull(mt_state * state,
+			  double shape, double scale);
+					/* Weibull distribution */
+double			rds_lweibull(mt_state * state,
+			  double shape, double scale);
+					/* Weibull distribution */
+double			rds_normal(mt_state * state,
+			  double mean, double sigma);
+					/* Normal distribution */
+double			rds_lnormal(mt_state * state,
+			  double mean, double sigma);
+					/* Normal distribution */
+double			rds_lognormal(mt_state * state,
+			  double shape, double scale);
+					/* Lognormal distribution */
+double			rds_llognormal(mt_state * state,
+			  double shape, double scale);
+					/* Lognormal distribution */
+double			rds_triangular(mt_state * state,
+			  double lower, double upper, double mode);
+					/* Triangular distribution */
+double			rds_ltriangular(mt_state * state,
+			  double lower, double upper, double mode);
+					/* Triangular distribution */
+double			rds_empirical(mt_state * state,
+			  int n_probs, double * values, double * probs);
+					/* Empirical distribution */
+double			rds_lempirical(mt_state * state,
+			  int n_probs, double * values, double * probs);
+					/* Empirical distribution */
+long			rd_iuniform(long lower, long upper);
+					/* (Integer) uniform distribution */
+#ifndef MT_NO_LONGLONG
+long long		rd_liuniform(long long lower, long long upper);
+					/* (Integer) uniform distribution */
+#endif /* MT_NO_LONGLONG */
+double			rd_uniform(double lower, double upper);
+					/* (Floating) uniform distribution */
+double			rd_luniform(double lower, double upper);
+					/* (Floating) uniform distribution */
+double			rd_exponential(double mean);
+					/* Exponential distribution */
+double			rd_lexponential(double mean);
+					/* Exponential distribution */
+double			rd_erlang(int p, double mean);
+					/* p-Erlang distribution */
+double			rd_lerlang(int p, double mean);
+					/* p-Erlang distribution */
+double			rd_weibull(double shape, double scale);
+					/* Weibull distribution */
+double			rd_lweibull(double shape, double scale);
+					/* Weibull distribution */
+double			rd_normal(double mean, double sigma);
+					/* Normal distribution */
+double			rd_lnormal(double mean, double sigma);
+					/* Normal distribution */
+double			rd_lognormal(double shape, double scale);
+					/* Lognormal distribution */
+double			rd_llognormal(double shape, double scale);
+					/* Lognormal distribution */
+double			rd_triangular(double lower, double upper, double mode);
+					/* Triangular distribution */
+double			rd_ltriangular(double lower, double upper, double mode);
+					/* Triangular distribution */
+double			rd_empirical(int n_probs,
+			  double * values, double * probs);
+					/* Empirical distribution */
+double			rd_lempirical(int n_probs,
+			  double * values, double * probs);
+					/* Empirical distribution */
+
+/*
+ * The Mersenne Twist PRNG makes it default state available as an
+ * external variable.  This feature is undocumented, but is useful to
+ * use because it allows us to avoid implementing every function
+ * twice.  (In fact, the feature was added to enable this file to be
+ * written.  It would be better to write in C++, where I could control
+ * the access to the state.)
+ */
+extern mt_state		mt_default_state;
+
+/*
+ * Threshold below which it is OK for uniform integer distributions to make
+ * use of the double-precision code as a crutch.  For ranges below
+ * this value, a double-precision random value is generated and then
+ * mapped to the given range.  For a lower bound of zero, this is
+ * equivalent to mapping a 32-bit integer into the range by using the
+ * following formula:
+ *
+ *	final = upper * mt_lrand() / (1 << 32);
+ *
+ * That formula can't be computed using integer arithmetic, since the
+ * multiplication must precede the division and would cause overflow.
+ * Double-precision calculations solve that problem.  However the
+ * formula will also produce biased results unless the range ("upper")
+ * is exactly a power of 2.  To see this, suppose mt_lrand produced
+ * values from 0 to 7 (i.e., 8 values), and we asked for numbers in
+ * the range (0, 7].  The 8 values uniformly generated by mt_lrand
+ * would be mapped into the 7 output values.  Clearly, one output
+ * value (in this case, 4) would occur twice as often as the others
+ *
+ * The amount of bias introduced by this approximation depends on the
+ * relative sizes of the requested range and the range of values
+ * produced by mt_lrand.  If the ranges are almost equal, some values
+ * will occur almost twice as often as they should.  At the other
+ * extreme, consider a requested range of 3 values (0 to 2,
+ * inclusive).  If the PRNG cycles through all 2^32 possible values,
+ * two of the output values will be generated 1431655765 times and the
+ * third will appear 1431655766 times.  Clearly, the bias here is
+ * within the expected limits of randomness.
+ *
+ * The exact amount of bias depends on the relative size of the range
+ * compared to the width of the PRNG output.  In general, for an
+ * output range of r, no value will appear more than r/(2^32) extra
+ * times using the simple integer algorithm.
+ *
+ * The threshold given below will produce a bias of under 0.01%.  For
+ * values above this threshold, a slower but 100% accurate algorithm
+ * will be used.
+ */
+#ifndef RD_MAX_BIAS
+#define RD_MAX_BIAS		0.0001
+#endif /* RD_MAX_BIAS */
+#ifndef RD_UNIFORM_THRESHOLD
+#define RD_UNIFORM_THRESHOLD	((int)((double)(1u << 31) * 2.0 * RD_MAX_BIAS))
+#endif /* RD_UNIFORM_THRESHOLD */
+
+/*
+ * Generate a uniform integer distribution on the open interval
+ * (lower, upper].  See comments above about RD_UNIFORM_THRESHOLD.  If
+ * we are above the threshold, this function is relatively expensive
+ * because we may have to repeatedly draw random numbers to get a
+ * one that works.
+ */
+long rds_iuniform(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    long		lower,		/* Lower limit of distribution */
+    long		upper)		/* Upper limit of distribution */
+    {
+    unsigned long	range = upper - lower;
+					/* Range of requested distribution */
+
+    if (range <= RD_UNIFORM_THRESHOLD)
+	return lower + (long)(mts_ldrand(state) * range);
+    else
+	{
+	/*
+	 * Using the simple formula would produce too much bias.
+	 * Instead, draw numbers until we get one within the range.
+	 * To save time, we first calculate a mask so that we only
+	 * look at the number of bits we actually need.  Since finding
+	 * the mask is expensive, we do a bit of caching here (note
+	 * that the caching makes the code non-reentrant; set
+	 * MT_NO_CACHING to achieve reentrancy).
+	 *
+	 * Incidentally, the astute reader will note that we use the
+	 * low-order bits of the PRNG output.  If the PRNG were linear
+	 * congruential, using the low-order bits wouuld be a major
+	 * no-no.  However, the Mersenne Twist PRNG doesn't have that
+	 * drawback.
+	 */
+#ifdef MT_NO_CACHING
+	unsigned long	rangemask = 0;	/* Mask for range */
+#else /* MT_NO_CACHING */
+	static unsigned long
+			lastrange = 0;	/* Range used last time */
+	static unsigned long
+			rangemask = 0;	/* Mask for range */
+#endif /* MT_NO_CACHING */
+	register unsigned long
+			ranval;		/* Random value from mts_lrand */
+
+#ifndef MT_NO_CACHING
+	if (range != lastrange)
+#endif /* MT_NO_CACHING */
+	    {
+	    /*
+	     * Range is different from last time, recalculate mask.
+	     *
+	     * A few iterations could be trimmed off of the loop if we
+	     * started rangemask at the next power of 2 above
+	     * RD_UNIFORM_THRESHOLD.  However, I don't currently know
+	     * a formula for generating that value (though there is
+	     * probably one in HAKMEM).
+	     */
+#ifndef MT_NO_CACHING
+	    lastrange = range;
+#endif /* MT_NO_CACHING */
+	    for (rangemask = 1;
+	      rangemask < range  &&  rangemask != 0;
+	      rangemask <<= 1)
+		;
+
+	    /*
+	     * If rangemask became zero, the range is over 2^31.  In
+	     * that case, subtracting 1 from rangemask will produce a
+	     * full-word mask, which is what we need.
+	     */
+	    rangemask -= 1;
+	    }
+
+	/*
+	 * Draw random numbers until we get one in the requested range.
+	 */
+	do
+	    {
+	    ranval = mts_lrand(state) & rangemask;
+	    }
+	    while (ranval >= range);
+	return lower + ranval;
+	}
+    }
+
+#ifndef MT_NO_LONGLONG
+/*
+ * Generate a uniform integer distribution on the open interval
+ * (lower, upper].
+ */
+long long rds_liuniform(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    long long		lower,		/* Lower limit of distribution */
+    long long		upper)		/* Upper limit of distribution */
+    {
+    unsigned long long	range = upper - lower;
+					/* Range of requested distribution */
+
+    /*
+     * Draw numbers until we get one within the range.  To save time,
+     * we first calculate a mask so that we only look at the number of
+     * bits we actually need.  Since finding the mask is expensive, we
+     * do a bit of caching here.  See rds_iuniform for more information.
+     */
+#ifdef MT_NO_CACHING
+    unsigned long	rangemask = 0;	/* Mask for range */
+#else /* MT_NO_CACHING */
+    static unsigned long
+		    lastrange = 0;	/* Range used last time */
+    static unsigned long
+		    rangemask = 0;	/* Mask for range */
+#endif /* MT_NO_CACHING */
+    register unsigned long
+		    ranval;		/* Random value from mts_lrand */
+
+#ifndef MT_NO_CACHING
+    if (range != lastrange)
+#endif /* MT_NO_CACHING */
+	{
+	/*
+	 * Range is different from last time, recalculate mask.
+	 */
+#ifndef MT_NO_CACHING
+	lastrange = range;
+#endif /* MT_NO_CACHING */
+	for (rangemask = 1;
+	  rangemask < range  &&  rangemask != 0;
+	  rangemask <<= 1)
+	    ;
+
+	/*
+	 * If rangemask became zero, the range is over 2^31.  In
+	 * that case, subtracting 1 from rangemask will produce a
+	 * full-word mask, which is what we need.
+	 */
+	rangemask -= 1;
+	}
+
+    /*
+     * Draw random numbers until we get one in the requested range.
+     */
+    do
+	{
+	ranval = mts_llrand(state) & rangemask;
+	}
+	while (ranval >= range);
+    return lower + ranval;
+    }
+#endif /* MT_NO_LONGLONG */
+
+/*
+ * Generate a uniform distribution on the open interval (lower, upper].
+ */
+double rds_uniform(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		lower,		/* Lower limit of distribution */
+    double		upper)		/* Upper limit of distribution */
+    {
+    return lower + mts_drand(state) * (upper - lower);
+    }
+
+/*
+ * Generate a uniform distribution on the open interval (lower, upper].
+ */
+double rds_luniform(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		lower,		/* Lower limit of distribution */
+    double		upper)		/* Upper limit of distribution */
+    {
+    return lower + mts_ldrand(state) * (upper - lower);
+    }
+
+/*
+ * Generate an exponential distribution with the given mean.
+ */
+double rds_exponential(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		mean)		/* Mean of generated distribution */
+    {
+    double		random_value;	/* Random sample on (0,1] */
+
+    do
+	random_value = mts_drand(state);
+    while (random_value == 0.0);
+    return -mean * log(random_value);
+    }
+
+/*
+ * Generate an exponential distribution with the given mean.
+ */
+double rds_lexponential(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		mean)		/* Mean of generated distribution */
+    {
+    double		random_value;	/* Random sample on (0,1] */
+
+    do
+	random_value = mts_ldrand(state);
+    while (random_value == 0.0);
+    return -mean * log(random_value);
+    }
+
+/*
+ * Generate a p-Erlang distribution with the given mean.
+ */
+double rds_erlang(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    int			p,		/* Order of distribution to generate */
+    double		mean)		/* Mean of generated distribution */
+    {
+    int			order;		/* Order generated so far */
+    double		random_value;	/* Value generated so far */
+
+    do
+	{
+	if (p <= 1)
+	    p = 1;
+	random_value = mts_drand(state);
+	for (order = 1;  order < p;  order++)
+	    random_value *= mts_drand(state);
+	}
+    while (random_value == 0.0);
+    return -mean * log(random_value) / p;
+    }
+
+/*
+ * Generate a p-Erlang distribution with the given mean.
+ */
+double rds_lerlang(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    int			p,		/* Order of distribution to generate */
+    double		mean)		/* Mean of generated distribution */
+    {
+    int			order;		/* Order generated so far */
+    double		random_value;	/* Value generated so far */
+
+    do
+	{
+	if (p <= 1)
+	    p = 1;
+	random_value = mts_ldrand(state);
+	for (order = 1;  order < p;  order++)
+	    random_value *= mts_ldrand(state);
+	}
+    while (random_value == 0.0);
+    return -mean * log(random_value) / p;
+    }
+
+/*
+ * Generate a Weibull distribution with the given shape and scale parameters.
+ */
+double rds_weibull(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    double		random_value;	/* Random sample on (0,1] */
+
+    do
+	random_value = mts_drand(state);
+    while (random_value == 0.0);
+    return scale * exp(log(-log(random_value)) / shape);
+    }
+					/* Weibull distribution */
+/*
+ * Generate a Weibull distribution with the given shape and scale parameters.
+ */
+double rds_lweibull(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    double		random_value;	/* Random sample on (0,1] */
+
+    do
+	random_value = mts_ldrand(state);
+    while (random_value == 0.0);
+    return scale * exp(log(-log(random_value)) / shape);
+    }
+					/* Weibull distribution */
+/*
+ * Generate a normal distribution with the given mean and standard
+ * deviation.  See Law and Kelton, p. 491.
+ */
+double rds_normal(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		mean,		/* Mean of generated distribution */
+    double		sigma)		/* Standard deviation to generate */
+    {
+    double		mag;		/* Magnitude of (x,y) point */
+    double		offset;		/* Unscaled offset from mean */
+    double		xranval;	/* First random value on (-1,1] */
+    double		yranval;	/* Second random value on (-1,1] */
+
+    /*
+     * Generating a normal distribution is a bit tricky.  We may need
+     * to make several attempts before we get a valid result.  When we
+     * are done, we will have two normally distributed values, one of
+     * which we discard.
+     */
+    do
+	{
+	xranval = 2.0 * mts_drand(state) - 1.0;
+	yranval = 2.0 * mts_drand(state) - 1.0;
+	mag = xranval * xranval + yranval * yranval;
+	}
+    while (mag > 1.0  ||  mag == 0.0);
+
+    offset = sqrt((-2.0 * log(mag)) / mag);
+    return mean + sigma * xranval * offset;
+
+    /*
+     * The second random variate is given by:
+     *
+     *     mean + sigma * yranval * offset;
+     *
+     * If this were a C++ function, it could probably save that value
+     * somewhere and return it in the next subsequent call.  But
+     * that's too hard to make bulletproof (and reentrant) in C.
+     */
+    }
+
+/*
+ * Generate a normal distribution with the given mean and standard
+ * deviation.  See Law and Kelton, p. 491.
+ */
+double rds_lnormal(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		mean,		/* Mean of generated distribution */
+    double		sigma)		/* Standard deviation to generate */
+    {
+    double		mag;		/* Magnitude of (x,y) point */
+    double		offset;		/* Unscaled offset from mean */
+    double		xranval;	/* First random value on (-1,1] */
+    double		yranval;	/* Second random value on (-1,1] */
+
+    /*
+     * Generating a normal distribution is a bit tricky.  We may need
+     * to make several attempts before we get a valid result.  When we
+     * are done, we will have two normally distributed values, one of
+     * which we discard.
+     */
+    do
+	{
+	xranval = 2.0 * mts_ldrand(state) - 1.0;
+	yranval = 2.0 * mts_ldrand(state) - 1.0;
+	mag = xranval * xranval + yranval * yranval;
+	}
+    while (mag > 1.0  ||  mag == 0.0);
+
+    offset = sqrt((-2.0 * log(mag)) / mag);
+    return mean + sigma * xranval * offset;
+
+    /*
+     * The second random variate is given by:
+     *
+     *     mean + sigma * yranval * offset;
+     *
+     * If this were a C++ function, it could probably save that value
+     * somewhere and return it in the next subsequent call.  But
+     * that's too hard to make bulletproof (and reentrant) in C.
+     */
+    }
+
+/*
+ * Generate a lognormal distribution with the given shape and scale
+ * parameters.
+ */
+double rds_lognormal(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    return exp(rds_normal(state, scale, shape));
+    }
+
+/*
+ * Generate a lognormal distribution with the given shape and scale
+ * parameters.
+ */
+double rds_llognormal(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    return exp(rds_lnormal(state, scale, shape));
+    }
+
+/*
+ * Generate a triangular distibution between given limits, with a
+ * given mode.
+ */
+double rds_triangular(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		lower,		/* Lower limit of distribution */
+    double		upper,		/* Upper limit of distribution */
+    double		mode)		/* Highest point of distribution */
+    {
+    double		ran_value;	/* Value generated by PRNG */
+    double		scaled_mode;	/* Scaled version of mode */
+
+    scaled_mode = (mode - lower) / (upper - lower);
+    ran_value = mts_drand(state);
+    if (ran_value <= scaled_mode)
+	ran_value = sqrt(scaled_mode * ran_value);
+    else
+	ran_value = 1.0 - sqrt((1.0 - scaled_mode) * (1.0 - ran_value));
+    return lower + (upper - lower) * ran_value;
+    }
+
+/*
+ * Generate a triangular distibution between given limits, with a
+ * given mode.
+ */
+double rds_ltriangular(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    double		lower,		/* Lower limit of distribution */
+    double		upper,		/* Upper limit of distribution */
+    double		mode)		/* Highest point of distribution */
+    {
+    double		ran_value;	/* Value generated by PRNG */
+    double		scaled_mode;	/* Scaled version of mode */
+
+    scaled_mode = (mode - lower) / (upper - lower);
+    ran_value = mts_ldrand(state);
+    if (ran_value <= scaled_mode)
+	ran_value = sqrt(scaled_mode * ran_value);
+    else
+	ran_value = 1.0 - sqrt((1.0 - scaled_mode) * (1.0 - ran_value));
+    return lower + (upper - lower) * ran_value;
+    }
+
+/*
+ * Generate an empirical distribution given a set of values and their
+ * probabilities.
+ */
+double rds_empirical(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    int			n_probs,	/* Number of probabilities given */
+    double *		values,		/* Vals returned with various probs */
+    double *		probs)		/* Probs of various values */
+    {
+    int			i;		/* Index into both arrays */
+    double		ran_value;	/* Value generated by PRNG */
+
+    ran_value = mts_drand(state);
+    /*
+     * NEEDSWORK: This should be a binary search if n_probs is
+     * moderately large (e.g., more than about 5-7).
+     */
+    for (i = 0;  i < n_probs;  i++)
+	{
+	if (ran_value <= probs[i])
+	    return values[i];
+	}
+    return values[n_probs];
+    }
+
+/*
+ * Generate an empirical distribution given a set of values and their
+ * probabilities.
+ */
+double rds_lempirical(
+    mt_state *		state,		/* State of the MT PRNG to use */
+    int			n_probs,	/* Number of probabilities given */
+    double *		values,		/* Vals returned with various probs */
+    double *		probs)		/* Probs of various values */
+    {
+    int			i;		/* Index into both arrays */
+    double		ran_value;	/* Value generated by PRNG */
+
+    ran_value = mts_ldrand(state);
+    /*
+     * NEEDSWORK: This should be a binary search if n_probs is
+     * moderately large (e.g., more than about 5-7).
+     */
+    for (i = 0;  i < n_probs;  i++)
+	{
+	if (ran_value <= probs[i])
+	    return values[i];
+	}
+    return values[n_probs];
+    }
+
+/*
+ * Generate a uniform integer distribution on the open interval
+ * (lower, upper].  See comments on rds_iuniform.
+ */
+long rd_iuniform(
+    long		lower,		/* Lower limit of distribution */
+    long		upper)		/* Upper limit of distribution */
+    {
+    return rds_iuniform(&mt_default_state, lower, upper);
+    }
+
+#ifndef MT_NO_LONGLONG
+/*
+ * Generate a uniform integer distribution on the open interval
+ * (lower, upper].  See comments on rds_iuniform.
+ */
+long long rd_liuniform(
+    long long		lower,		/* Lower limit of distribution */
+    long long		upper)		/* Upper limit of distribution */
+    {
+    return rds_liuniform(&mt_default_state, lower, upper);
+    }
+#endif /* MT_NO_LONGLONG */
+
+/*
+ * Generate a uniform distribution on the open interval (lower, upper].
+ */
+double rd_uniform(
+    double		lower,		/* Lower limit of distribution */
+    double		upper)		/* Upper limit of distribution */
+    {
+    return rds_uniform (&mt_default_state, lower, upper);
+    }
+
+/*
+ * Generate a uniform distribution on the open interval (lower, upper].
+ */
+double rd_luniform(
+    double		lower,		/* Lower limit of distribution */
+    double		upper)		/* Upper limit of distribution */
+    {
+    return rds_luniform (&mt_default_state, lower, upper);
+    }
+
+/*
+ * Generate an exponential distribution with the given mean.
+ */
+double rd_exponential(
+    double		mean)		/* Mean of generated distribution */
+    {
+    return rds_exponential (&mt_default_state, mean);
+    }
+
+/*
+ * Generate an exponential distribution with the given mean.
+ */
+double rd_lexponential(
+    double		mean)		/* Mean of generated distribution */
+    {
+    return rds_lexponential (&mt_default_state, mean);
+    }
+
+/*
+ * Generate a p-Erlang distribution with the given mean.
+ */
+double rd_erlang(
+    int			p,		/* Order of distribution to generate */
+    double		mean)		/* Mean of generated distribution */
+    {
+    return rds_erlang (&mt_default_state, p, mean);
+    }
+
+/*
+ * Generate a p-Erlang distribution with the given mean.
+ */
+double rd_lerlang(
+    int			p,		/* Order of distribution to generate */
+    double		mean)		/* Mean of generated distribution */
+    {
+    return rds_lerlang (&mt_default_state, p, mean);
+    }
+
+/*
+ * Generate a Weibull distribution with the given shape and scale parameters.
+ */
+double rd_weibull(
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    return rds_weibull (&mt_default_state, shape, scale);
+    }
+
+/*
+ * Generate a Weibull distribution with the given shape and scale parameters.
+ */
+double rd_lweibull(
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    return rds_lweibull (&mt_default_state, shape, scale);
+    }
+
+/*
+ * Generate a normal distribution with the given mean and standard
+ * deviation.  See Law and Kelton, p. 491.
+ */
+double rd_normal(
+    double		mean,		/* Mean of generated distribution */
+    double		sigma)		/* Standard deviation to generate */
+    {
+    return rds_normal (&mt_default_state, mean, sigma);
+    }
+
+/*
+ * Generate a normal distribution with the given mean and standard
+ * deviation.  See Law and Kelton, p. 491.
+ */
+double rd_lnormal(
+    double		mean,		/* Mean of generated distribution */
+    double		sigma)		/* Standard deviation to generate */
+    {
+    return rds_lnormal (&mt_default_state, mean, sigma);
+    }
+
+/*
+ * Generate a lognormal distribution with the given shape and scale
+ * parameters.
+ */
+double rd_lognormal(
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    return rds_lognormal (&mt_default_state, shape, scale);
+    }
+
+/*
+ * Generate a lognormal distribution with the given shape and scale
+ * parameters.
+ */
+double rd_llognormal(
+    double		shape,		/* Shape of the distribution */
+    double		scale)		/* Scale of the distribution */
+    {
+    return rds_llognormal (&mt_default_state, shape, scale);
+    }
+
+/*
+ * Generate a triangular distibution between given limits, with a
+ * given mode.
+ */
+double rd_triangular(
+    double		lower,		/* Lower limit of distribution */
+    double		upper,		/* Upper limit of distribution */
+    double		mode)
+    {
+    return rds_triangular (&mt_default_state, lower, upper, mode);
+    }
+
+/*
+ * Generate a triangular distibution between given limits, with a
+ * given mode.
+ */
+double rd_ltriangular(
+    double		lower,		/* Lower limit of distribution */
+    double		upper,		/* Upper limit of distribution */
+    double		mode)
+    {
+    return rds_ltriangular (&mt_default_state, lower, upper, mode);
+    }
+
+/*
+ * Generate an empirical distribution given a set of values and their
+ * probabilities.
+ */
+double rd_empirical(
+    int			n_probs,	/* Number of probabilities given */
+    double *		values,		/* Vals returned with various probs */
+    double *		probs)		/* Probs of various values */
+    {
+    return rds_empirical (&mt_default_state, n_probs, values, probs);
+    }
+
+/*
+ * Generate an empirical distribution given a set of values and their
+ * probabilities.
+ */
+double rd_lempirical(
+    int			n_probs,	/* Number of probabilities given */
+    double *		values,		/* Vals returned with various probs */
+    double *		probs)		/* Probs of various values */
+    {
+    return rds_lempirical (&mt_default_state, n_probs, values, probs);
+    }

Added: antargis/trunk/gui/src/mtwist/randistrs.h
===================================================================
--- antargis/trunk/gui/src/mtwist/randistrs.h	2007-03-08 20:12:12 UTC (rev 1057)
+++ antargis/trunk/gui/src/mtwist/randistrs.h	2007-03-11 20:40:28 UTC (rev 1058)
@@ -0,0 +1,381 @@
+#ifndef RANDISTRS_H
+#define RANDISTRS_H
+
+/*
+ * $Id: randistrs.h,v 1.4 2001/06/20 09:07:58 geoff Exp $
+ *
+ * Header file for C/C++ use of a generalized package that generates
+ * random numbers in various distributions, using the Mersenne-Twist
+ * pseudo-RNG.  See mtwist.h and mtwist.c for documentation on the PRNG.
+ *
+ * Author of this header file: Geoffrey H. Kuenning, April 7, 2001.
+ *
+ * All of the functions provided by this package have three variants.
+ * The rd_xxx versions use the default state vector provided by the MT
+ * package.  The rds_xxx versions use a state vector provided by the
+ * caller.  In general, the rds_xxx versions are preferred for serious
+ * applications, since they allow random numbers used for different
+ * purposes to be drawn from independent, uncorrelated streams.
+ * Finally, the C++ interface provides a class "mt_distribution",
+ * derived from mt_prng, with no-prefix ("xxx") versions of each
+ * function.
+ *
+ * The summary below will describe only the rds_xxx functions.  The
+ * rd_xxx functions have identical specifications, except that the
+ * "state" argument is omitted.  In all cases, the "state" argument
+ * has type mt_state, and must have been initialized either by calling
+ * one of the Mersenne Twist seeding functions, or by being set to all
+ * zeros.
+ *
+ * The "l" version of each function calls the 64-bit version of the
+ * PRNG instead of the 32-bit version.  In general, you shouldn't use
+ * those functions unless your application is *very* sensitive to tiny
+ * variations in the probability distribution.  This is especially
+ * true of the uniform and empirical distributions.
+ *
+ * Random-distribution functions:
+ *
+ * rds_iuniform(mt_state* state, long lower, long upper)
+ *		(Integer) uniform on the open interval (lower, upper].
+ * rds_liuniform(mt_state* state, long long lower, long long upper)
+ *		(Integer) uniform on the open interval (lower, upper].
+ *		Don't use unless you need numbers bigger than a long!
+ * rds_uniform(mt_state* state, double lower, double upper)
+ *		(Floating) uniform on the open interval (lower, upper].
+ * rds_luniform(mt_state* state, double lower, double upper)
+ *		(Floating) uniform on the open interval (lower, upper].
+ *		Higher precision but slower than rds_uniform.
+ * rds_exponential(mt_state* state, double mean)
+ *		Exponential with the given mean.
+ * rds_lexponential(mt_state* state, double mean)
+ *		Exponential with the given mean.
+ *		Higher precision but slower than rds_exponential.
+ * rds_erlang(mt_state* state, int p, double mean)
+ *		p-Erlang with the given mean.
+ * rds_lerlang(mt_state* state, int p, double mean)
+ *		p-Erlang with the given mean.
+ *		Higher precision but slower than rds_erlang.
+ * rds_weibull(mt_state* state, double shape, double scale)
+ *		Weibull with the given shape and scale parameters.
+ * rds_lweibull(mt_state* state, double shape, double scale)
+ *		Weibull with the given shape and scale parameters.
+ *		Higher precision but slower than rds_weibull.
+ * rds_normal(mt_state* state, double mean, double sigma)
+ *		Normal with the  given mean and standard deviation.
+ * rds_lnormal(mt_state* state, double mean, double sigma)
+ *		Normal with the  given mean and standard deviation.
+ *		Higher precision but slower than rds_normal.
+ * rds_lognormal(mt_state* state, double shape, double scale)
+ *		Lognormal with the given shape and scale parameters.
+ * rds_llognormal(mt_state* state, double shape, double scale)
+ *		Lognormal with the given shape and scale parameters.
+ *		Higher precision but slower than rds_lognormal.
+ * rds_triangular(mt_state* state, double lower, double upper, double mode)
+ *		Triangular on the closed interval (lower, upper) with
+ *		the given mode.
+ * rds_ltriangular(mt_state* state, double lower, double upper, double mode)
+ *		Triangular on the closed interval (lower, upper) with
+ *		the given mode.
+ *		Higher precision but slower than rds_triangular.
+ * rds_empirical(mt_state* state, int n_probs, double* values, double* probs)
+ *		values[0] with probability probs[0], values[1] with
+ *		probability probs[1] - probs[0], etc.; values[n_probs]
+ *		with probability 1-probs[n_probs-1].  Note that there
+ *		is one more value than there are probabilities.  It is
+ *		the caller's responsibility to make sure that the
+ *		probabilities are monotonically increasing and that
+ *		their sum is less than or equal to 1; if this
+ *		condition is violated, some of the values will never
+ *		be generated.
+ * rds_lempirical(mt_state* state, int n_probs, double* values, double* probs)
+ *		Empirical distribution.  Higher precision but slower than
+ *		rds_empirical.
+ * rd_iuniform(long lower, long upper)
+ * rd_liuniform(long long lower, long long upper)
+ *		As above, using the default MT-PRNG.
+ * rd_uniform(double lower, double upper)
+ * rd_luniform(double lower, double upper)
+ *		As above, using the default MT-PRNG.
+ * rd_exponential(double mean)
+ * rd_lexponential(double mean)
+ *		As above, using the default MT-PRNG.
+ * rd_erlang(int p, double mean)
+ * rd_lerlang(int p, double mean)
+ *		As above, using the default MT-PRNG.
+ * rd_weibull(double shape, double scale)
+ * rd_lweibull(double shape, double scale)
+ *		As above, using the default MT-PRNG.
+ * rd_normal(double mean, double sigma)
+ * rd_lnormal(double mean, double sigma)
+ *		As above, using the default MT-PRNG.
+ * rd_lognormal(double shape, double scale)
+ * rd_llognormal(double shape, double scale)
+ *		As above, using the default MT-PRNG.
+ * rd_triangular(double lower, double upper, double mode)
+ * rd_ltriangular(double lower, double upper, double mode)
+ *		As above, using the default MT-PRNG.
+ * rd_empirical(int n_probs, double* values, double* probs)
+ * rd_lempirical(int n_probs, double* values, double* probs)
+ *		As above, using the default MT-PRNG.
+ *
+ * $Log: randistrs.h,v $
+ * Revision 1.4  2001/06/20 09:07:58  geoff
+ * Fix a place where long long wasn't conditionalized.
+ *
+ * Revision 1.3  2001/06/19 00:41:17  geoff
+ * Add the "l" versions of all functions.
+ *
+ * Revision 1.2  2001/06/18 10:09:24  geoff
+ * Add the iuniform functions.  Improve the header comments.  Add a C++
+ * interface.  Clean up some stylistic inconsistencies.
+ *
+ * Revision 1.1  2001/04/09 08:39:54  geoff
+ * Initial revision
+ *
+ */
+
+#include "mtwist.h"
+
+#ifdef __cplusplus
+extern "C"
+    {
+#endif
+
+/*
+ * Functions that use a provided state.
+ */
+extern long		rds_iuniform(mt_state* state, long lower, long upper);
+					/* (Integer) uniform distribution */
+#ifndef MT_NO_LONGLONG
+extern long long	rds_liuniform(mt_state* state, long long lower,
+			  long long upper);
+					/* (Integer) uniform distribution */
+#endif /* MT_NO_LONGLONG */
+extern double		rds_uniform(mt_state* state,
+			  double lower, double upper);
+					/* (Floating) uniform distribution */
+extern double		rds_luniform(mt_state* state,
+			  double lower, double upper);
+					/* (Floating) uniform distribution */
+extern double		rds_exponential(mt_state* state, double mean);
+					/* Exponential distribution */
+extern double		rds_lexponential(mt_state* state, double mean);
+					/* Exponential distribution */
+extern double		rds_erlang(mt_state* state, int p, double mean);
+					/* p-Erlang distribution */
+extern double		rds_lerlang(mt_state* state, int p, double mean);
+					/* p-Erlang distribution */
+extern double		rds_weibull(mt_state* state,
+			  double shape, double scale);
+					/* Weibull distribution */
+extern double		rds_lweibull(mt_state* state,
+			  double shape, double scale);
+					/* Weibull distribution */
+extern double		rds_normal(mt_state* state,
+			  double mean, double sigma);
+					/* Normal distribution */
+extern double		rds_lnormal(mt_state* state,
+			  double mean, double sigma);
+					/* Normal distribution */
+extern double		rds_lognormal(mt_state* state,
+			  double shape, double scale);
+					/* Lognormal distribution */
+extern double		rds_llognormal(mt_state* state,
+			  double shape, double scale);
+					/* Lognormal distribution */
+extern double		rds_triangular(mt_state* state,
+			  double lower, double upper, double mode);
+					/* Triangular distribution */
+extern double		rds_ltriangular(mt_state* state,
+			  double lower, double upper, double mode);
+					/* Triangular distribution */
+extern double		rds_empirical(mt_state* state,
+			  int n_probs, double* values, double* probs);
+					/* Empirical distribution */
+extern double		rds_lempirical(mt_state* state,
+			  int n_probs, double* values, double* probs);
+					/* Empirical distribution */
+
+/*
+ * Functions that use the default state of the PRNG.
+ */
+extern long		rd_iuniform(long lower, long upper);
+					/* (Integer) uniform distribution */
+#ifndef MT_NO_LONGLONG
+extern long long	rd_liuniform(long long lower, long long upper);
+					/* (Integer) uniform distribution */
+#endif /* MT_NO_LONGLONG */
+extern double		rd_uniform(double lower, double upper);
+					/* (Floating) uniform distribution */
+extern double		rd_luniform(double lower, double upper);
+					/* (Floating) uniform distribution */
+extern double		rd_exponential(double mean);
+					/* Exponential distribution */
+extern double		rd_lexponential(double mean);
+					/* Exponential distribution */
+extern double		rd_erlang(int p, double mean);
+					/* p-Erlang distribution */
+extern double		rd_lerlang(int p, double mean);
+					/* p-Erlang distribution */
+extern double		rd_weibull(double shape, double scale);
+					/* Weibull distribution */
+extern double		rd_lweibull(double shape, double scale);
+					/* Weibull distribution */
+extern double		rd_normal(double mean, double sigma);
+					/* Normal distribution */
+extern double		rd_lnormal(double mean, double sigma);
+					/* Normal distribution */
+extern double		rd_lognormal(double shape, double scale);
+					/* Lognormal distribution */
+extern double		rd_llognormal(double shape, double scale);
+					/* Lognormal distribution */
+extern double		rd_triangular(double lower, double upper, double mode);
+					/* Triangular distribution */
+extern double		rd_ltriangular(double lower, double upper,
+			  double mode);	/* Triangular distribution */
+extern double		rd_empirical(int n_probs,
+			  double* values, double* probs);
+					/* Empirical distribution */
+extern double		rd_lempirical(int n_probs,
+			  double* values, double* probs);
+					/* Empirical distribution */
+
+#ifdef __cplusplus
+    }
+#endif
+
+#ifdef __cplusplus
+/*
+ * C++ interface to the random-distribution generators.  This class is
+ * little more than a wrapper for the C functions, but it fits a bit
+ * more nicely with the mt_prng class.
+ */
+class mt_distribution : public mt_prng
+    {
+    public:
+	/*
+	 * Constructors and destructors.  All constructors and
+	 * destructors are the same as for mt_prng.
+	 */
+			mt_distribution(
+					// Default constructor
+			    bool pickSeed = false)
+					// True to get seed from /dev/urandom
+					// ..or time
+			    : mt_prng(pickSeed)
+			    {
+			    }
+			mt_distribution(unsigned long seed)
+					// Construct with 32-bit seeding
+			    : mt_prng(seed)
+			    {
+			    }
+			mt_distribution(unsigned long seeds[MT_STATE_SIZE])
+					// Construct with full seeding
+			    : mt_prng(seeds)
+			    {
+			    }
+			~mt_distribution() { }
+
+	/*
+	 * Functions for generating distributions.  These simply
+	 * invoke the C functions above.
+	 */
+	long		iuniform(long lower, long upper)
+					/* Uniform distribution */
+			    {
+			    return rds_iuniform(&state, lower, upper);
+			    }
+#ifndef MT_NO_LONGLONG
+	long long	liuniform(long long lower, long long upper)
+					/* Uniform distribution */
+			    {
+			    return rds_liuniform(&state, lower, upper);
+			    }
+#endif /* MT_NO_LONGLONG */
+	double		uniform(double lower, double upper)
+					/* Uniform distribution */
+			    {
+			    return rds_uniform(&state, lower, upper);
+			    }
+	double		luniform(double lower, double upper)
+					/* Uniform distribution */
+			    {
+			    return rds_luniform(&state, lower, upper);
+			    }
+	double		exponential(double mean)
+					/* Exponential distribution */
+			    {
+			    return rds_exponential(&state, mean);
+			    }
+	double		lexponential(double mean)
+					/* Exponential distribution */
+			    {
+			    return rds_lexponential(&state, mean);
+			    }
+	double		erlang(int p, double mean)
+					/* p-Erlang distribution */
+			    {
+			    return rds_erlang(&state, p, mean);
+			    }
+	double		lerlang(int p, double mean)
+					/* p-Erlang distribution */
+			    {
+			    return rds_lerlang(&state, p, mean);
+			    }
+	double		weibull(double shape, double scale)
+					/* Weibull distribution */
+			    {
+			    return rds_weibull(&state, shape, scale);
+			    }
+	double		lweibull(double shape, double scale)
+					/* Weibull distribution */
+			    {
+			    return rds_lweibull(&state, shape, scale);
+			    }
+	double		normal(double mean, double sigma)
+					/* Normal distribution */
+			    {
+			    return rds_normal(&state, mean, sigma);
+			    }
+	double		lnormal(double mean, double sigma)
+					/* Normal distribution */
+			    {
+			    return rds_lnormal(&state, mean, sigma);
+			    }
+	double		lognormal(double shape, double scale)
+					/* Lognormal distribution */
+			    {
+			    return rds_lognormal(&state, shape, scale);
+			    }
+	double		llognormal(double shape, double scale)
+					/* Lognormal distribution */
+			    {
+			    return rds_llognormal(&state, shape, scale);
+			    }
+	double		triangular(double lower, double upper, double mode)
+					/* Triangular distribution */
+			    {
+			    return rds_triangular(&state, lower, upper, mode);
+			    }
+	double		ltriangular(double lower, double upper, double mode)
+					/* Triangular distribution */
+			    {
+			    return rds_ltriangular(&state, lower, upper, mode);
+			    }
+	double		empirical(int n_probs, double* values, double* probs)
+					/* Empirical distribution */
+			    {
+			    return
+			      rds_empirical(&state, n_probs, values, probs);
+			    }
+	double		lempirical(int n_probs, double* values, double* probs)
+					/* Empirical distribution */
+			    {
+			    return
+			      rds_lempirical(&state, n_probs, values, probs);
+			    }
+    };
+#endif
+
+#endif /* RANDISTRS_H */

Added: antargis/trunk/ruby/tests/rand_test.rb
===================================================================
--- antargis/trunk/ruby/tests/rand_test.rb	2007-03-08 20:12:12 UTC (rev 1057)
+++ antargis/trunk/ruby/tests/rand_test.rb	2007-03-11 20:40:28 UTC (rev 1058)
@@ -0,0 +1,12 @@
+#!/usr/bin/env ruby
+
+require 'libantargis'
+include Libantargis
+
+a=AGRandomizer.new("")
+
+puts a.randInt(20)
+puts a.randInt(20)
+puts a.randInt(20)
+puts a.randInt(20)
+

Modified: antargis/trunk/src/antargisgui.h
===================================================================
--- antargis/trunk/src/antargisgui.h	2007-03-08 20:12:12 UTC (rev 1057)
+++ antargis/trunk/src/antargisgui.h	2007-03-11 20:40:28 UTC (rev 1058)
@@ -58,6 +58,7 @@
 #include "../gui/src/ag_scroller.h"
 #include "../gui/src/ag_plugin.h"
 #include "../gui/src/ag_destructor.h"
+#include "../gui/src/ag_rand.h"
 #include "../src/ant_frustum.h"
 #include "../src/ant_projection.h"
 #include "../src/ant_camera.h"
@@ -143,6 +144,7 @@
 %include "../gui/src/ag_scroller.h"
 %include "../gui/src/ag_plugin.h"
 %include "../gui/src/ag_destructor.h"
+%include "../gui/src/ag_rand.h"
 %include "../src/ant_frustum.h"
 %include "../src/ant_projection.h"
 %include "../src/ant_camera.h"

Modified: antargis/trunk/src/nantmarker.hh
===================================================================
--- antargis/trunk/src/nantmarker.hh	2007-03-08 20:12:12 UTC (rev 1057)
+++ antargis/trunk/src/nantmarker.hh	2007-03-11 20:40:28 UTC (rev 1058)
@@ -2834,6 +2834,11 @@
  Data_Get_Struct($input,AGRadioGroup,b);
  $result=*b;
 }
+%typemap(directorout) AGRandomizer {
+ AGRandomizer *b;
+ Data_Get_Struct($input,AGRandomizer,b);
+ $result=*b;
+}
 %typemap(directorout) AGRect2 {
  AGRect2 *b;
  Data_Get_Struct($input,AGRect2,b);



From davidkamphausen at mail.berlios.de  Wed Mar 14 20:02:07 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Wed, 14 Mar 2007 20:02:07 +0100
Subject: [Antargis-svn] r1059 - in antargis/trunk: gui/src ruby ruby/tests
	src
Message-ID: <200703141902.l2EJ273K020961@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-14 20:02:05 +0100 (Wed, 14 Mar 2007)
New Revision: 1059

Modified:
   antargis/trunk/gui/src/ag_application.cc
   antargis/trunk/gui/src/ag_main.cc
   antargis/trunk/gui/src/ag_main.h
   antargis/trunk/gui/src/ag_messageobject.cc
   antargis/trunk/gui/src/ag_rand.cc
   antargis/trunk/gui/src/ag_rand.h
   antargis/trunk/ruby/ant_arrow.rb
   antargis/trunk/ruby/ant_boss.rb
   antargis/trunk/ruby/ant_decal.rb
   antargis/trunk/ruby/ant_deco.rb
   antargis/trunk/ruby/ant_field.rb
   antargis/trunk/ruby/ant_fish.rb
   antargis/trunk/ruby/ant_grass.rb
   antargis/trunk/ruby/ant_hero.rb
   antargis/trunk/ruby/ant_house.rb
   antargis/trunk/ruby/ant_man.rb
   antargis/trunk/ruby/ant_mine.rb
   antargis/trunk/ruby/ant_sheep.rb
   antargis/trunk/ruby/ant_stone.rb
   antargis/trunk/ruby/ant_tools.rb
   antargis/trunk/ruby/ant_tree.rb
   antargis/trunk/ruby/ant_wolf.rb
   antargis/trunk/ruby/antargislib.rb
   antargis/trunk/ruby/ents.rb
   antargis/trunk/ruby/intro.rb
   antargis/trunk/ruby/mainmenu.rb
   antargis/trunk/ruby/map.rb
   antargis/trunk/ruby/tests/rand_test.rb
   antargis/trunk/src/height_map.cc
   antargis/trunk/src/map.cc
   antargis/trunk/src/nantmarker.hh
   antargis/trunk/src/path.cc
   antargis/trunk/src/path.h
Log:
* demo-mode - with correct replay


Modified: antargis/trunk/gui/src/ag_application.cc
===================================================================
--- antargis/trunk/gui/src/ag_application.cc	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/gui/src/ag_application.cc	2007-03-14 19:02:05 UTC (rev 1059)
@@ -101,6 +101,8 @@
   
   flushEventQueue();
   last=now=SDL_GetTicks();
+
+  size_t loopCount=0;
   
   while(mRunning)
     {
@@ -121,18 +123,24 @@
 	  ;
 	*/
 	clearOldMousePosition();
+	cdebug("loop pre-event:"<<loopCount);
 	event=getNewEvent();
 	if(eventOk(event))
 	  {
 	    do
 	      {
+		cdebug("eventok  "<<toString(&event));
 		doEvent(event);
 		if(mIdleCalls)
-		  event=getNewEvent();
+		  {
+		    cdebug("getNewEvent...  (idlecalls:"<<mIdleCalls<<")");
+		    event=getNewEvent();
+		  }
 		else
 		  resetEvent(event);
 	      }while(eventOk(event));
 	  } 
+	cdebug("loop post-event:"<<loopCount);
 	/*
 	if(mIdleCalls) 
 	  {
@@ -153,10 +161,11 @@
 	    doEvent(&event);
 	    }*/
 
-	if(mDemoTime>0)
+	if(mDemoTime>=0)
 	  {
 	    t=mDemoTime;
 	    mDemoTime=-1;
+	    cdebug("demo time:"<<t);
 	  }
 	else
 	  {
@@ -165,6 +174,7 @@
 	if(mainWidget)
 	  mainWidget->sigTick(t);
 	
+	cdebug("frame events:"<<t);
 	eventPrepareFrame(t);
 
 	eventFrame(t);
@@ -184,6 +194,9 @@
       
       eventFrameEnd(t);
       last=now;
+
+      loopCount++;
+      cdebug("Running:"<<mRunning);
     }
   gApplication=0;
 
@@ -192,6 +205,7 @@
 
 void AGApplication::setDemoTime(float t)
 {
+  cdebug("demoTime:"<<t);
   mDemoTime=t;
 }
 
@@ -199,6 +213,7 @@
 SDL_Event AGApplication::getNewEvent()
 {
   SDL_Event mEvent;
+  resetEvent(mEvent);
   // pull motion events (may flood the eventqueue)
   while(SDL_PeepEvents(&mEvent, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) > 0)
     ;
@@ -266,6 +281,7 @@
  
 bool AGApplication::eventQuit(AGEvent *m)
 {
+  CTRACE;
   mRunning=false;
   return false;
 }
@@ -377,6 +393,7 @@
 
 void AGApplication::tryQuit()
 {
+  CTRACE;
   mRunning=false;
 }
 
@@ -426,6 +443,7 @@
 /// delays execution for ms milliseconds. This can be used to decrease framerate and cpu-load.
 void AGApplication::delay(int ms)
 {
+  cdebug("delay:"<<ms);
   SDL_Delay(ms);
 }
 

Modified: antargis/trunk/gui/src/ag_main.cc
===================================================================
--- antargis/trunk/gui/src/ag_main.cc	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/gui/src/ag_main.cc	2007-03-14 19:02:05 UTC (rev 1059)
@@ -79,11 +79,13 @@
    creates an AGMain object.
 */
 AGMain::AGMain():
-  mCollector(0)
+  mCollector(0),mRand(0)
 {
   assert(mAGMain==0);
   mAGMain=this;
 
+  mRand=new AGRandomizer("");
+
   newInstanceKiller();
 
   // Initialize SDL
@@ -117,7 +119,9 @@
   SDL_Quit();
   quited=true;
 
+  saveDelete(mRand);
 
+
   setRubyRaising(true);
 }
 
@@ -355,9 +359,20 @@
 void AGMain::mark()
 {
   markObject(getCollector());
+  markObject(mRand);
 }
 
+void AGMain::setRand(AGRandomizer *pRand)
+{
+  mRand=pRand;
+}
 
+AGRandomizer *AGMain::getRand()
+{
+  return mRand;
+}
+
+
 std::string gAppName="Antargis";
 void setAppName(const std::string &pName)
 {

Modified: antargis/trunk/gui/src/ag_main.h
===================================================================
--- antargis/trunk/gui/src/ag_main.h	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/gui/src/ag_main.h	2007-03-14 19:02:05 UTC (rev 1059)
@@ -24,6 +24,7 @@
 #include <string>
 #include <ag_rubyobj.h>
 #include <ag_collector.h>
+#include <ag_rand.h>
 
 
 /**
@@ -66,6 +67,9 @@
   bool fullscreen() const;
   long getTicks() const;
 
+  void setRand(AGRandomizer *pRand);
+  AGRandomizer *getRand();
+
   AGCollector *getCollector();
  protected:
   virtual void mark();
@@ -75,6 +79,8 @@
   AGCollector *mCollector;
 
   const SDL_VideoInfo *videoInfo;
+
+  AGRandomizer *mRand;
 };
 
 bool hasMain();

Modified: antargis/trunk/gui/src/ag_messageobject.cc
===================================================================
--- antargis/trunk/gui/src/ag_messageobject.cc	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/gui/src/ag_messageobject.cc	2007-03-14 19:02:05 UTC (rev 1059)
@@ -521,12 +521,25 @@
 	case SDL_QUIT:
 	  os<<"SDL_QUIT:";
 	  break;
+	case SDL_SYSWMEVENT:
+	  os<<"SDL_DUMMY;";
+	  break;
+	case SDL_VIDEOEXPOSE:
+	  os<<"SDL_VIDEOEXPOSE";
+	  break;
+	case SDL_NOEVENT:
+	  os<<"SDL_NOEVENT";
+	  break;
+	default:
+	  cdebug("UNKNOWN SDL_EVENT:"<<pEvent->type);
+	  os<<"SDL_NOEVENT";
+	  break;
 	}
       if(os.str().length())
 	return os.str();
       
     }
-  return "nil";
+  return "SDL_NOEVENT";
 }
 
 
@@ -624,6 +637,20 @@
       event.jbutton.button=getUntil(b,":").toUint8();
       event.jbutton.state=getUntil(b,":").toUint8();
     }
+  else if(t=="SDL_SYSWMEVENT")
+    {
+      event.type=SDL_SYSWMEVENT;
+      // FIXME
+    }
+  else if(t=="SDL_VIDEOEXPOSE")
+    {
+      event.type=SDL_VIDEOEXPOSE;
+      
+    }
+  else if(t=="SDL_DUMMY")
+    {
+      event.type=SDL_USEREVENT;
+    }
   else if(t=="SDL_QUIT")
     {
       event.type=SDL_QUIT;
@@ -640,7 +667,8 @@
 }
 bool eventOk(const SDL_Event &pEvent)
 {
-  return pEvent.type!=SDL_NOEVENT;
+  cdebug("eventOk: check "<<(int)pEvent.type<<"!="<<SDL_NOEVENT<<" ???");
+  return (int)pEvent.type!=SDL_NOEVENT;
 }
 
 void resetEvent(SDL_Event &pEvent)

Modified: antargis/trunk/gui/src/ag_rand.cc
===================================================================
--- antargis/trunk/gui/src/ag_rand.cc	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/gui/src/ag_rand.cc	2007-03-14 19:02:05 UTC (rev 1059)
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ * Copyright (c) 2007 by David Kamphausen. All rights reserved.
  *
  * ag_rand.cc
  * by David Kamphausen (david.kamphausen at web.de)
@@ -18,8 +18,10 @@
  * License along with this program.
  */
 
+#include "ag_debug.h"
+#include "ag_main.h"
+#include "ag_profiler.h"
 #include "ag_rand.h"
-#include "ag_debug.h"
 #include "mtwist.h"
 
 #include <sstream>
@@ -71,5 +73,34 @@
 
 }
 
+int agRand(int i)
+{
+  AGRandomizer *r=getMain()->getRand();
+  if(!r)
+    throw std::runtime_error("Randomizer not set!");
+  return (*r)(i);
+}
+float agRand(float f)
+{
+  AGRandomizer *r=getMain()->getRand();
+  if(!r)
+    throw std::runtime_error("Randomizer not set!");
+  return (*r)(f);
+}
 
-
+void randSpeed()
+{
+  long m=10000000;
+  int t;
+  int max=100;
+  {
+    STACKTRACE;
+    for(long i=0;i<m;i++)
+      t=rand()%max;
+  }
+  {
+    STACKTRACE;
+    for(long i=0;i<m;i++)
+      t=agRand(max);
+  }
+}

Modified: antargis/trunk/gui/src/ag_rand.h
===================================================================
--- antargis/trunk/gui/src/ag_rand.h	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/gui/src/ag_rand.h	2007-03-14 19:02:05 UTC (rev 1059)
@@ -22,10 +22,19 @@
 #define __AG_RAND
 
 #include <string>
+#include "ag_rubyobj.h"
 
-class AGRandomizer
+// Randomizer using Mersenne Twister - it's even faster
+// than the common libc-implementation of rand()
+// Second reason to use it is the possibility to save
+// the prng (pseudo-random-number generator)'s state
+// to a string and restore it. This way we can deterministically
+// rerun a "randomized" game
+class AGRandomizer:public AGRubyObject
 {
  public:
+  // restore a randomizer from a state-string (pretty long)
+  // for an initial seed - call with pSeed==""
   AGRandomizer(const std::string &pSeed);
 #ifdef SWIG
   %rename(randFloat) operator()(float f);
@@ -34,9 +43,18 @@
   float operator()(float f);
   int operator()(int i);
 
+  // give state-string, to be saved
   std::string stateToString() const;
 
 };
 
+/// calls getMain()->getRand()->rand()
+int agRand(int i);
+/// calls getMain()->getRand()->rand()
+float agRand(float f);
 
+/// runs a small speed test
+void randSpeed();
+
+
 #endif

Modified: antargis/trunk/ruby/ant_arrow.rb
===================================================================
--- antargis/trunk/ruby/ant_arrow.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_arrow.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -25,8 +25,8 @@
 class AntArrow<AntRubyEntity
 	def initialize
 		super(AGVector2.new(0,0))
-		@typeID=(rand()*2).to_i
-		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/arrow.ant2",0.1,"data/textures/models/arrow.png"),AGVector4.new(0,0,0,0),rand*360))
+		@typeID=(getRand*2).to_i
+		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/arrow.ant2",0.1,"data/textures/models/arrow.png"),AGVector4.new(0,0,0,0),getRand*360))
 		setSpeed(10)
 	end
 	def eventNoJob

Modified: antargis/trunk/ruby/ant_boss.rb
===================================================================
--- antargis/trunk/ruby/ant_boss.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_boss.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -41,6 +41,7 @@
 		super(node)
 		if node.get("men")!="" then
 			dputs "LOAD:CREATING MEN:"+node.get("men")
+			dputs caller.join("\n")
 			if node.get("men")!=""
 				@createMen=node.get("men").to_i
 			end
@@ -90,7 +91,8 @@
 	end
 	
 	def eventNoJob
-		puts "eventNoJob "+self.class.to_s+" "+ at job.to_s
+		dputs "eventNoJob "+self.class.to_s+" "+ at job.to_s
+		dputs caller.join("\n")
 		checkHLJobEnd(self)
  		checkCreateMen
 	end

Modified: antargis/trunk/ruby/ant_decal.rb
===================================================================
--- antargis/trunk/ruby/ant_decal.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_decal.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -21,7 +21,7 @@
 class AntDecal<AntRubyEntity
 	def initialize()
 		super(AGVector2.new(0,0))
-		@typeID=(rand()*2).to_i
+		@typeID=(getRand()*2).to_i
 		setProvide("decal",true)
 		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/floor.ant2",0.8,"data/textures/gravel4.png",false),AGVector4.new(0,0,0,0),0))
 	end

Modified: antargis/trunk/ruby/ant_deco.rb
===================================================================
--- antargis/trunk/ruby/ant_deco.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_deco.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -24,7 +24,7 @@
 		@decoType=decoType
 		if @decoType==nil
 			a=["flower1a","flower2a","twig","gravel","small_bush","hole","grass4","grass4a","grass4b","gravel_big","gravel_big2","rock1"]
-			r=(rand()*a.size).to_i
+			r=(getRand()*a.size).to_i
 			@decoType=a[r]
 		else
 			b={"coach"=>["coach2"],
@@ -39,7 +39,7 @@
 					"block"=>["block2"],
 					"grassGreen"=>["grass3"]}
 			a=b[@decoType]
-			r=(rand()*a.size).to_i
+			r=(getRand()*a.size).to_i
 			@decoType=a[r]
 		end
 		setProvide("deco",true)
@@ -62,9 +62,9 @@
 class AntTwig<AntRubyEntity
 	def initialize()
 		super(AGVector2.new(0,0))
-		@typeID=(rand()*2).to_i
+		@typeID=(getRand()*2).to_i
 		#setType("twig")
-		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/twig.ant2",0.7),AGVector4.new(0,0,0,0),rand*360))
+		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/twig.ant2",0.7),AGVector4.new(0,0,0,0),getRand*360))
 	end
 end
 

Modified: antargis/trunk/ruby/ant_field.rb
===================================================================
--- antargis/trunk/ruby/ant_field.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_field.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -3,7 +3,7 @@
 	def initialize
 		super(AGVector2.new(0,0))
 		setProvide("field",true)
-		@size=0 # (rand*3).to_i
+		@size=0
 		#init fieldMeshes-var
 		AntField.getFieldMeshData(0)
 		@max=@@fieldMeshes.length-1

Modified: antargis/trunk/ruby/ant_fish.rb
===================================================================
--- antargis/trunk/ruby/ant_fish.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_fish.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -72,7 +72,7 @@
 			getMap.insertEntity(fish)
 			getMap.endChange
 			newRestJob(2)
-			@lastBirth=-rand()*10
+			@lastBirth=-getRand()*10
 		else
 			setPos(AGVector3.new(getPos2D,-0.3))
 			newMoveJob(0,getTargetPos,0)
@@ -94,7 +94,7 @@
 		tries=10
 		# assure that sheep doesn't walk into water
 		while tries>0 do
-			d=AGVector2.new(rand-0.5,rand-0.5).normalized*2
+			d=AGVector2.new(getRand-0.5,getRand-0.5).normalized*2
 			t=p+d
 			t=getMap.truncPos(t)
 			tries-=1

Modified: antargis/trunk/ruby/ant_grass.rb
===================================================================
--- antargis/trunk/ruby/ant_grass.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_grass.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -52,7 +52,7 @@
 	if i==1
 		vadd=AGVector4.new(0,0,0,0)
 	else
-		vadd=AGVector4.new(rand*2,rand*2,0,0)
+		vadd=AGVector4.new(agRand(1.0)*2,agRand(1.0)*2,0,0)
 	end
 	
 	mv0.v=v0+vadd
@@ -182,9 +182,9 @@
 		super(AGVector2.new(0,0))
 		setProvide("grass",true)
 		if high
-			@size=rand*0.25+0.5
+			@size=getRand*0.25+0.5
 		else
-			@size=rand*0.25+0.25
+			@size=getRand*0.25+0.25
 		end
 		setupMesh
 	end
@@ -210,7 +210,7 @@
 	def initialize()
 		super(AGVector2.new(0,0))
 		setProvide("bush",true)
-		@size=rand*0.25+0.25
+		@size=getRand*0.25+0.25
 		setupMesh
 	end
 	def resourceChanged

Modified: antargis/trunk/ruby/ant_hero.rb
===================================================================
--- antargis/trunk/ruby/ant_hero.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_hero.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -232,10 +232,12 @@
 	def assignJob2All
 		super
 		puts "ASSIGN JOB 2 All #{self}"
+		puts "---"
 		if @job.class!=AntHeroRestJob
 			setFire(false)
 		end
 		doEvent(:newJobAssigned)
+		puts "ASSIGN JOB ready."
 	end
 
 	def setMeshState(name)

Modified: antargis/trunk/ruby/ant_house.rb
===================================================================
--- antargis/trunk/ruby/ant_house.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_house.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -307,7 +307,7 @@
 		super(node)
 		setPos(getPos2D) # set to ground
 		if getName==""
-			setName(rand.to_s)
+			setName(getRand.to_s)
 		end
 		@village=node.get("village")
 	end	

Modified: antargis/trunk/ruby/ant_man.rb
===================================================================
--- antargis/trunk/ruby/ant_man.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_man.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -85,7 +85,7 @@
 						exit
 					end
 					@bossName=houseName
-					newRestJob(rand()*2)
+					newRestJob(getRand*2)
 					#house=getMap.getRuby(house)
 					house.signUp(self)
 					@signed=true

Modified: antargis/trunk/ruby/ant_mine.rb
===================================================================
--- antargis/trunk/ruby/ant_mine.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_mine.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -24,7 +24,7 @@
 		super(AGVector2.new(0,0))
 		setProvide("coal",true)
 		setProvide("ore",true)
-		@angle=rand*360
+		@angle=getRand*360
 		
 		setMinimapColor(AGColor.new(0,0,0))
 	

Modified: antargis/trunk/ruby/ant_sheep.rb
===================================================================
--- antargis/trunk/ruby/ant_sheep.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_sheep.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -63,8 +63,8 @@
 			getMap.insertEntity(sheep)
 			#getMap.endChange
 			newRestJob(2)
-			@lastBirth=-rand()*10
-		elsif rand<0.5 then
+			@lastBirth=-getRand*10
+		elsif getRand<0.5 then
 			newMoveJob(0,getTargetPos,0)
 			setMeshState("go")
 		else
@@ -90,7 +90,7 @@
 		tries=10
 		# assure that sheep doesn't walk into water
 		while tries>0 do
-			d=AGVector2.new(rand-0.5,rand-0.5).normalized*2
+			d=AGVector2.new(getRand-0.5,getRand-0.5).normalized*2
 			t=p+d
 			t=getMap.truncPos(t)
 			tries-=1

Modified: antargis/trunk/ruby/ant_stone.rb
===================================================================
--- antargis/trunk/ruby/ant_stone.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_stone.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -21,10 +21,10 @@
 class AntStone<AntRubyEntity
 	def initialize()
 		super(AGVector2.new(0,0))
-		@typeID=(rand()*2).to_i
+		@typeID=(getRand*2).to_i
 		setProvide("stone",true)
 		#setMesh(Mesh.new(getMeshData("data/models/floor.ant2",1,"data/textures/splats/gravel_big2.png",false),AGVector4.new(0,0,0,0),0))
-		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/big_stone.ant2",0.7,"data/textures/models/big_stone.png"),AGVector4.new(0,0,0,0),rand*360))
+		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/big_stone.ant2",0.7,"data/textures/models/big_stone.png"),AGVector4.new(0,0,0,0),getRand*360))
 		
 #		setMesh(NewDecal.new(AGVector2.new(3,3),5.3,getMap,"data/textures/gravel.png"))
 #		setMesh(NewDecal.new(AGVector2.new(3,3),5.3,getMap,"data/textures/terrain/rough_dirt2.png"))

Modified: antargis/trunk/ruby/ant_tools.rb
===================================================================
--- antargis/trunk/ruby/ant_tools.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_tools.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -9,17 +9,6 @@
 		puts "LOAD MESH:"+id	
 		$meshes[id]=MeshData.new(file,zoom,texture,shadow)
 
-# 		# instancing test
-# 		puts "FILE:#{file}"
-# 		if file =~ /tree/
-# 			ts=[]
-# 			(0..2).each{|x|
-# 				(0..2).each{|y|
-# 					ts.push(AGMatrix4.new(AGVector4.new(x*2+rand*1.7,y*2+rand*1.7,0,0)))
-# 				}
-# 			}
-# 			$meshes[id].makeInstances(ts)
-# 		end
 	end
 	return $meshes[id]
 end

Modified: antargis/trunk/ruby/ant_tree.rb
===================================================================
--- antargis/trunk/ruby/ant_tree.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_tree.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -65,10 +65,10 @@
 	def initialize(typeID=nil)
 		super(AGVector2.new(0,0))
 		@typeID=typeID
-		@typeID||=(rand*getTreeTypes.length).to_i
+		@typeID||=(getRand*getTreeTypes.length).to_i
 		setProvide("wood",true)
 		setProvide("fruit",true)
-		@angle=rand*360
+		@angle=getRand*360
 		
 		@maxApples=100
 		setMinimapColor(AGColor.new(0,0x77,0))
@@ -117,8 +117,8 @@
 		@crownRadius=1.3
 		@applePos=[]
 		for i in 1.. at maxApples
-			va=(rand-0.5)*Math::PI
-			ha=(rand+1)*Math::PI  # only on front side
+			va=(getRand-0.5)*Math::PI
+			ha=(getRand+1)*Math::PI  # only on front side
 			z=@crownRadius*Math::sin(va)
 			rest=Math::sqrt(@crownRadius**2-z**2)
 			y=Math::sin(ha)*rest

Modified: antargis/trunk/ruby/ant_wolf.rb
===================================================================
--- antargis/trunk/ruby/ant_wolf.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ant_wolf.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -82,7 +82,7 @@
 			getMap.insertEntity(wolf)
 			#getMap.endChange
 			newRestJob(2)
-			@lastBirth=-rand()*10
+			@lastBirth=-getRand*10
 		else
 			checkPackMerge
 			if @leader
@@ -216,7 +216,7 @@
 		radius=4
 		# assure that sheep doesn't walk into water
 		while getMap.getHeight(t.x,t.y)<0.1 or ok do
-			d=AGVector2.new(rand-0.5,rand-0.5).normalized*radius
+			d=AGVector2.new(getRand-0.5,getRand-0.5).normalized*radius
 			t=p+d
 			t=getMap.truncPos(t)
 			ok=false

Modified: antargis/trunk/ruby/antargislib.rb
===================================================================
--- antargis/trunk/ruby/antargislib.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/antargislib.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -10,7 +10,7 @@
 	@@antargislibinited||=false
 
 	if not @@antargislibinited
-		puts "TRY"
+		puts "MYTRY"
 		# try suspending arts
 		if File.exists?("/usr/bin/artsshell")
 			File.popen("/usr/bin/artsshell suspend 2>&1").close
@@ -35,12 +35,13 @@
 			end
 			@@eventDebugging||=File.open("events.txt","r")
 			@@nextLine||=@@eventDebugging.readline
-			#puts "NEXTLINE:#{@@nextLine}"
+			puts "NEXTLINE:#{@@nextLine}"
 			if @@nextLine=~/T:.*/
 				time=@@nextLine.scan(/..(.*)/)[0][0].to_f
-				#puts "TIME:#{time}"
+				puts "TIME:#{time}"
 				@@nextLine=nil
 				setDemoTime(time)
+				
 				return toSDLEvent("")
 			else
 				s=@@nextLine
@@ -49,11 +50,19 @@
 			end
 		else
 			e=super
-			s=toString(e)
-			if $enableLogging
-				@@eventDebugging||=File.open("events.txt","w")
-				@@eventDebugging.puts s
+			if not e.nil?
+				if eventOk(e)
+					s=toString(e)
+					if $enableLogging
+						@@eventDebugging||=File.open("events.txt","w")
+						@@eventDebugging.puts s
+						puts "NEWEVENT: #{self}  #{s}"
+					end
+				end
 			end
+# 			if e.nil?
+# 				return toSDLEvent("")
+# 			end
 			return e
 		end
 	end
@@ -62,7 +71,8 @@
 	def eventPrepareFrame(t)
 		if $enableLogging and not $demoMode
 			@@eventDebugging||=File.open("events.txt","w")
-			@@eventDebugging.puts "T:#{t}"
+			@@eventDebugging.puts "T: #{t}"
+			puts "TIME #{t}"
 		end
 		return false
 	end
@@ -138,6 +148,8 @@
 	--no-sound     disables sound for now and future uses
 	
 	--gui-test     tells BoA to use events.txt to produce GUI-events
+
+	--demo         enable demo mode - reading events from events.txt
 	"
 	
 						exit
@@ -197,7 +209,16 @@
 			puts "GC ok"
 		end
 	end
+
+	def MyAntargislib.demoMode
+		$demoMove
+	end
 end
+
+def demoMode
+	MyAntargislib.demoMode
+end
+
 #include Libantargis
 def startGC
 	MyAntargislib.startGC
@@ -222,4 +243,16 @@
 
 class AntApplication<AGApplication
 	include AntMyEventHandler
-end
\ No newline at end of file
+
+	def delay(ms)
+		puts "DELAY  #{ms}"
+		return 
+		if not demoMode
+			super
+		end
+	end
+end
+
+# def rand
+# 	raise "This Function shouldn't be called at all!!!!!"
+# end
\ No newline at end of file

Modified: antargis/trunk/ruby/ents.rb
===================================================================
--- antargis/trunk/ruby/ents.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/ents.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -113,7 +113,12 @@
 	end
 	def getRand
 		# FIXME - implement me (network code)
-		rand
+		#rand
+# 		@mrand||=AGRandomizer.new("")
+# 		return @mrand.randFloat(1)
+		puts "#{self} getRand"
+		puts caller.join("\n")
+		agRand(1.0)
 	end
 
 	def setStrength(v)

Modified: antargis/trunk/ruby/intro.rb
===================================================================
--- antargis/trunk/ruby/intro.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/intro.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -78,6 +78,7 @@
 	end
 	
 	def checkPhase
+		puts "#{@time}>#{@phases[@phase]}"
 		if @time>@phases[@phase]
 			@time-=@phases[@phase]
 			@phase+=1

Modified: antargis/trunk/ruby/mainmenu.rb
===================================================================
--- antargis/trunk/ruby/mainmenu.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/mainmenu.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -397,6 +397,7 @@
 	end
 
 	def eventFrame(t)
+		puts "evenFrame #{t}"
 		@frameTime||=0
 		@frames||=0
 		@frameTime+=t

Modified: antargis/trunk/ruby/map.rb
===================================================================
--- antargis/trunk/ruby/map.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/map.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -252,7 +252,7 @@
 		end
 		if e
 			e.preloadXML(node)
-			@loadedEntities[node]=e
+			@loadedEntities<<[node,e]
 		end
 # 	end
 # 
@@ -302,16 +302,18 @@
 	
 	def loadXML(n)
 		@loadedEntsNum=1
-		@loadedEntities={}
+		@loadedEntities=[]
 		super(n)
 # 		puts @loadedEntities.length
 # 		puts @loadedEntsNum
 # 		raise 1
-		@loadedEntities.each{|node,entity|
+		@loadedEntities.each{|pair|
+			node,entity=pair
 			insertEntity(entity)
 		}
 
-		@loadedEntities.each{|node,entity|
+		@loadedEntities.each{|pair|
+			node,entity=pair
 #			loadEntityFromXML(entity,node)
 			entity.loadXML(node)
 			entity.eventMapChanged

Modified: antargis/trunk/ruby/tests/rand_test.rb
===================================================================
--- antargis/trunk/ruby/tests/rand_test.rb	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/ruby/tests/rand_test.rb	2007-03-14 19:02:05 UTC (rev 1059)
@@ -10,3 +10,6 @@
 puts a.randInt(20)
 puts a.randInt(20)
 
+main=AGMain.new
+main.setRand(AGRandomizer.new(""))
+randSpeed

Modified: antargis/trunk/src/height_map.cc
===================================================================
--- antargis/trunk/src/height_map.cc	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/src/height_map.cc	2007-03-14 19:02:05 UTC (rev 1059)
@@ -369,14 +369,13 @@
 std::vector<float> genSomeHeights(int mW,int mH,float mMaxHeight)
 {
   std::vector<float> h(mW*mH);
-  int randMax=10000;
 
   for(int i=0;i<mW*mH;i++)
     h[i]=0;
   return h;
   
   for(int i=0;i<mW*mH;i++)
-    h[i]=(rand()%randMax)*mMaxHeight/randMax;
+    h[i]=agRand(mMaxHeight);
   
   int x,y;
   // blur

Modified: antargis/trunk/src/map.cc
===================================================================
--- antargis/trunk/src/map.cc	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/src/map.cc	2007-03-14 19:02:05 UTC (rev 1059)
@@ -19,6 +19,7 @@
  */
 
 #include "scene.h"
+#include "ag_rand.h"
 #include "map.h"
 #include "entity.h"
 #include <vector>
@@ -303,7 +304,7 @@
     {
       std::multimap<float,AntEntity*>::iterator j=ents.begin();
       float nearest=j->first;
-      int r=rand()%std::min((Uint32)ents.size(),5U);
+      int r=agRand(std::min((int)ents.size(),5));
       while(r>0 && (j->first<=nearest*1.3 || j->first<2000*2000))
         {
           j++;

Modified: antargis/trunk/src/nantmarker.hh
===================================================================
--- antargis/trunk/src/nantmarker.hh	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/src/nantmarker.hh	2007-03-14 19:02:05 UTC (rev 1059)
@@ -408,6 +408,16 @@
 	result->mRubyObject=true;
 }
 %markfunc AGLayoutCreator "general_markfunc"
+%exception AGRandomizer::AGRandomizer {
+	$action
+	result->mRUBY=self;
+#ifdef GCDEBUG
+     result->mObjName=typeid(*result).name();
+     printf("%lx   %s\n",self,typeid(*result).name());
+#endif
+	result->mRubyObject=true;
+}
+%markfunc AGRandomizer "general_markfunc"
 %exception AGGLScreen::AGGLScreen {
 	$action
 	result->mRUBY=self;
@@ -508,7 +518,7 @@
 	result->mRubyObject=true;
 }
 %markfunc AGSound "general_markfunc"
-%exception AGPaintTarget::AGPaintTarget {
+%exception Mesh::Mesh {
 	$action
 	result->mRUBY=self;
 #ifdef GCDEBUG
@@ -517,8 +527,8 @@
 #endif
 	result->mRubyObject=true;
 }
-%markfunc AGPaintTarget "general_markfunc"
-%exception AGButton::AGButton {
+%markfunc Mesh "general_markfunc"
+%exception AGPaintTarget::AGPaintTarget {
 	$action
 	result->mRUBY=self;
 #ifdef GCDEBUG
@@ -527,8 +537,8 @@
 #endif
 	result->mRubyObject=true;
 }
-%markfunc AGButton "general_markfunc"
-%exception AGListener::AGListener {
+%markfunc AGPaintTarget "general_markfunc"
+%exception AGButton::AGButton {
 	$action
 	result->mRUBY=self;
 #ifdef GCDEBUG
@@ -537,8 +547,8 @@
 #endif
 	result->mRubyObject=true;
 }
-%markfunc AGListener "general_markfunc"
-%exception Mesh::Mesh {
+%markfunc AGButton "general_markfunc"
+%exception AGListener::AGListener {
 	$action
 	result->mRUBY=self;
 #ifdef GCDEBUG
@@ -547,7 +557,7 @@
 #endif
 	result->mRubyObject=true;
 }
-%markfunc Mesh "general_markfunc"
+%markfunc AGListener "general_markfunc"
 %exception TerrainPiece::TerrainPiece {
 	$action
 	result->mRUBY=self;
@@ -568,7 +578,7 @@
 	result->mRubyObject=true;
 }
 %markfunc NewDecal "general_markfunc"
-%typemap(out) AGRadio*{
+%typemap(out) MapPathWeighter*{
  if($1)
  {
   if($1->mRubyObject)
@@ -577,12 +587,12 @@
    {
      if(false);
    else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MapPathWeighter,0);
    }
  }
  else vresult=Qnil;
 }
-%typemap(directorin) AGRadio*{
+%typemap(directorin) MapPathWeighter*{
  if($1)
  {
   if($1->mRubyObject)
@@ -591,12 +601,12 @@
    {
      if(false);
    else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRadio,0);
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MapPathWeighter,0);
    }
  }
  else $input=Qnil;
 }
-%typemap(out) GLApp*{
+%typemap(out) AGRadio*{
  if($1)
  {
   if($1->mRubyObject)
@@ -605,12 +615,12 @@
    {
      if(false);
    else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GLApp,0);
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRadio,0);
    }
  }
  else vresult=Qnil;
 }
-%typemap(directorin) GLApp*{
+%typemap(directorin) AGRadio*{
  if($1)
  {
   if($1->mRubyObject)
@@ -619,12 +629,12 @@
    {
      if(false);
    else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_GLApp,0);
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRadio,0);
    }
  }
  else $input=Qnil;
 }
-%typemap(out) MapPathWeighter*{
+%typemap(out) GLApp*{
  if($1)
  {
   if($1->mRubyObject)
@@ -633,12 +643,12 @@
    {
      if(false);
    else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MapPathWeighter,0);
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GLApp,0);
    }
  }
  else vresult=Qnil;
 }
-%typemap(directorin) MapPathWeighter*{
+%typemap(directorin) GLApp*{
  if($1)
  {
   if($1->mRubyObject)
@@ -647,7 +657,7 @@
    {
      if(false);
    else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MapPathWeighter,0);
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_GLApp,0);
    }
  }
  else $input=Qnil;
@@ -1964,6 +1974,34 @@
  }
  else $input=Qnil;
 }
+%typemap(out) AGRandomizer*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $result=$1->mRUBY;
+  else
+   {
+     if(false);
+   else
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGRandomizer,0);
+   }
+ }
+ else vresult=Qnil;
+}
+%typemap(directorin) AGRandomizer*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $input=$1->mRUBY;
+  else
+   {
+     if(false);
+   else
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGRandomizer,0);
+   }
+ }
+ else $input=Qnil;
+}
 %typemap(out) AGGLScreen*{
  if($1)
  {

Modified: antargis/trunk/src/path.cc
===================================================================
--- antargis/trunk/src/path.cc	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/src/path.cc	2007-03-14 19:02:05 UTC (rev 1059)
@@ -19,10 +19,16 @@
 
 }
 
-std::map<SimpleGraph::Node*,float> SimpleGraph::Node::getNextNodes()
+bool SimpleGraph::NodePtrCompare::operator()(const Node *a,const Node *b)
 {
-  std::map<SimpleGraph::Node*,float> m;
+  return a->p<b->p;
+}
 
+
+SimpleGraph::Node::NodeMap SimpleGraph::Node::getNextNodes()
+{
+  SimpleGraph::Node::NodeMap m;
+
   for(Edges::iterator i=edges.begin();i!=edges.end();i++)
     {
       if((*i)->a==this)
@@ -59,6 +65,12 @@
 {
 }
 
+bool SimpleGraph::EdgePtrCompare::operator()(const Edge *a,const Edge *b)
+{
+  return(a->a->p < b->a->p || (a->a->p==b->a->p && a->b->p<b->b->p));
+}
+
+
 bool SimpleGraph::Edge::operator<(const Edge &e) const
 {
   return a<e.a || (a==e.a && b<e.b);
@@ -620,10 +632,10 @@
 	  SimpleGraph::Node *n=*modified.begin();
 	  modified.erase(modified.begin());
 	  
-	  std::map<SimpleGraph::Node*,float> ns=n->getNextNodes();
+	  SimpleGraph::Node::NodeMap ns=n->getNextNodes();
 	  float old=weights[n];
 
-	  for(std::map<SimpleGraph::Node*,float>::iterator j=ns.begin();j!=ns.end();j++)
+	  for(SimpleGraph::Node::NodeMap::iterator j=ns.begin();j!=ns.end();j++)
 	    {
 	      float now=weights[j->first];
 	      //	      cdebug("now:"<<now<<"  old:"<<old<<" plus:"<<j->second);
@@ -843,12 +855,12 @@
       cdebug("tries:"<<tries);
       
 
-      std::map<SimpleGraph::Node*,float> nextNodes=last->getNextNodes();
+      SimpleGraph::Node::NodeMap nextNodes=last->getNextNodes();
 
       std::set<SimpleGraph::Node*> alreadyGone;
       std::copy(path.begin(),path.end(),std::inserter(alreadyGone,alreadyGone.begin()));
 
-      for(std::map<SimpleGraph::Node*,float>::iterator i=nextNodes.begin();i!=nextNodes.end();i++)
+      for(SimpleGraph::Node::NodeMap::iterator i=nextNodes.begin();i!=nextNodes.end();i++)
 	{
 	  if(alreadyGone.find(i->first)==alreadyGone.end())
 	    {

Modified: antargis/trunk/src/path.h
===================================================================
--- antargis/trunk/src/path.h	2007-03-11 20:40:28 UTC (rev 1058)
+++ antargis/trunk/src/path.h	2007-03-14 19:02:05 UTC (rev 1059)
@@ -54,7 +54,6 @@
 };
 
 
-
 class SimpleGraph:public AGRubyObject
 {
  public:
@@ -64,6 +63,18 @@
   typedef std::list<Edge*> Edges;
   typedef std::list<Node*> Nodes;
 
+  class NodePtrCompare
+  {
+  public:
+    bool operator()(const Node *a,const Node *b);
+  };
+    
+  class EdgePtrCompare
+  {
+  public:
+    bool operator()(const Edge *a,const Edge *b);
+  };
+
   // only used for processing and not for storing !
   struct HalfEdge
   {
@@ -86,17 +97,18 @@
     HalfEdge *getHalfEdgeFrom(Node *n);
 
     HalfEdge *getHalfEdgeTo(Node *n);
+
   };
 
   struct Node
   {
     AGVector2 p;
     Edges edges;
+    typedef std::map<Node*,float,NodePtrCompare> NodeMap;
     
     ~Node();
 
-    std::map<Node*,float> getNextNodes();
-
+    NodeMap getNextNodes();
   };
 
   struct EdgeSort
@@ -154,7 +166,7 @@
   // FIXME: quadtree out of nodes !!!
 
   typedef std::map<AGVector2,Node*,AGVector2Sort> NodeMap;
-  typedef std::set<Node*> NodeSet;
+  typedef std::set<Node*,NodePtrCompare> NodeSet;
   typedef std::set<Edge*,EdgeSort> EdgeSet;
   NodeMap mNodeMap;
   NodeSet mNodes;



From davidkamphausen at mail.berlios.de  Thu Mar 15 21:03:58 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Thu, 15 Mar 2007 21:03:58 +0100
Subject: [Antargis-svn] r1060 - in antargis/trunk: gui/src ruby
Message-ID: <200703152003.l2FK3wx3007253@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-15 21:03:57 +0100 (Thu, 15 Mar 2007)
New Revision: 1060

Modified:
   antargis/trunk/gui/src/ag_application.cc
   antargis/trunk/gui/src/ag_debug.cc
   antargis/trunk/gui/src/ag_debug.h
   antargis/trunk/gui/src/ag_fs.cc
   antargis/trunk/gui/src/ag_gltexture.cc
   antargis/trunk/gui/src/ag_main.h
   antargis/trunk/gui/src/ag_messageobject.cc
   antargis/trunk/gui/src/ag_rand.cc
   antargis/trunk/gui/src/ag_rand.h
   antargis/trunk/ruby/antargislib.rb
   antargis/trunk/ruby/ents.rb
   antargis/trunk/ruby/intro.rb
   antargis/trunk/ruby/mainmenu.rb
Log:
* some modifications with loggin /randomization


Modified: antargis/trunk/gui/src/ag_application.cc
===================================================================
--- antargis/trunk/gui/src/ag_application.cc	2007-03-14 19:02:05 UTC (rev 1059)
+++ antargis/trunk/gui/src/ag_application.cc	2007-03-15 20:03:57 UTC (rev 1060)
@@ -123,24 +123,24 @@
 	  ;
 	*/
 	clearOldMousePosition();
-	cdebug("loop pre-event:"<<loopCount);
+	dbout(2,"loop pre-event:"<<loopCount);
 	event=getNewEvent();
 	if(eventOk(event))
 	  {
 	    do
 	      {
-		cdebug("eventok  "<<toString(&event));
+		dbout(2,"eventok  "<<toString(&event));
 		doEvent(event);
 		if(mIdleCalls)
 		  {
-		    cdebug("getNewEvent...  (idlecalls:"<<mIdleCalls<<")");
+		    dbout(2,"getNewEvent...  (idlecalls:"<<mIdleCalls<<")");
 		    event=getNewEvent();
 		  }
 		else
 		  resetEvent(event);
 	      }while(eventOk(event));
 	  } 
-	cdebug("loop post-event:"<<loopCount);
+	dbout(2,"loop post-event:"<<loopCount);
 	/*
 	if(mIdleCalls) 
 	  {
@@ -165,7 +165,7 @@
 	  {
 	    t=mDemoTime;
 	    mDemoTime=-1;
-	    cdebug("demo time:"<<t);
+	    dbout(2,"demo time:"<<t);
 	  }
 	else
 	  {
@@ -174,7 +174,7 @@
 	if(mainWidget)
 	  mainWidget->sigTick(t);
 	
-	cdebug("frame events:"<<t);
+	dbout(2,"frame events:"<<t);
 	eventPrepareFrame(t);
 
 	eventFrame(t);
@@ -196,7 +196,7 @@
       last=now;
 
       loopCount++;
-      cdebug("Running:"<<mRunning);
+      dbout(2,"Running:"<<mRunning);
     }
   gApplication=0;
 
@@ -205,7 +205,7 @@
 
 void AGApplication::setDemoTime(float t)
 {
-  cdebug("demoTime:"<<t);
+  dbout(2,"demoTime:"<<t);
   mDemoTime=t;
 }
 
@@ -443,7 +443,7 @@
 /// delays execution for ms milliseconds. This can be used to decrease framerate and cpu-load.
 void AGApplication::delay(int ms)
 {
-  cdebug("delay:"<<ms);
+  dbout(2,"delay:"<<ms);
   SDL_Delay(ms);
 }
 

Modified: antargis/trunk/gui/src/ag_debug.cc
===================================================================
--- antargis/trunk/gui/src/ag_debug.cc	2007-03-14 19:02:05 UTC (rev 1059)
+++ antargis/trunk/gui/src/ag_debug.cc	2007-03-15 20:03:57 UTC (rev 1060)
@@ -66,32 +66,43 @@
 }
 
 size_t gDebugIndex=0;
+size_t gDebugLevel=0;
 
 size_t getDebugIndex()
 {
   return gDebugIndex;
 }
 
+size_t getDebugLevel()
+{
+  return gDebugLevel;
+}
+void setDebugLevel(size_t t)
+{
+  gDebugLevel=t;
+}
 
+
+
 D::D(std::string c):
   m(c)
 {
   indent();
   gDebugIndex++;
 
-  debugout("start of:"<<c<<"("<<gDebugIndex<<")"<<std::endl);
+  dbout(2,"start of:"<<c<<"("<<gDebugIndex<<")"<<std::endl);
   d++;
 }
 AGEXPORT D::~D()
 {
   d--;
   indent();
-  debugout("end   of:"<<m<<std::endl);
+  dbout(2,"end   of:"<<m<<std::endl);
 }
 void D::indent()
 {
   for(int i=0;i<d;i++)
-    debugout("  ");
+    debugout_checked(2,"  ");
 }
 
 

Modified: antargis/trunk/gui/src/ag_debug.h
===================================================================
--- antargis/trunk/gui/src/ag_debug.h	2007-03-14 19:02:05 UTC (rev 1059)
+++ antargis/trunk/gui/src/ag_debug.h	2007-03-15 20:03:57 UTC (rev 1060)
@@ -68,9 +68,13 @@
 #define cdebug(x) debugout("("<<__FILE__<<":"<<__LINE__<<":"<<__PRETTY_FUNCTION__<<"):"<<x<<endl)
 #define ccdebug(x) debugout("("<<__FILE__<<":"<<__LINE__<<":"<<__PRETTY_FUNCTION__<<":"<<((void*)this)<<"):"<<x<<endl)
 
-
 size_t getDebugIndex();
+size_t getDebugLevel();
+void setDebugLevel(size_t t);
 
+#define debugout_checked(level,x) { if(level>getDebugLevel()) { getDebug()<<x; }}
+#define dbout(level,x) {if(level>getDebugLevel()) { cdebug(x); }}
+
 /** A helper class for tracing the program's flow
     Use it by instantiating it with a proper name, or simply use TRACE; (or CTRACE for classes) in your functions */
 class AGEXPORT D

Modified: antargis/trunk/gui/src/ag_fs.cc
===================================================================
--- antargis/trunk/gui/src/ag_fs.cc	2007-03-14 19:02:05 UTC (rev 1059)
+++ antargis/trunk/gui/src/ag_fs.cc	2007-03-15 20:03:57 UTC (rev 1060)
@@ -50,7 +50,7 @@
   char **p=PHYSFS_getSearchPath();
   for(;*p;p++)
     {
-      cdebug(*p);
+      dbout(0,*p);
 
     }
 #endif
@@ -66,9 +66,9 @@
   PHYSFS_setSaneConfig("Antargis","Antargis","ZIP",false,false);
   FSinited=true;
   const char *wp=PHYSFS_getWriteDir();
-  cdebug("writedir:"<<wp);
+  dbout(0,"writedir:"<<wp);
 
-  cdebug("searchpath:");
+  dbout(0,"searchpath:");
 
   PHYSFS_addToSearchPath("./data/",1);
   PHYSFS_addToSearchPath("/usr/share/antargisgui/",1);
@@ -81,11 +81,11 @@
   char **p=PHYSFS_getSearchPath();
   for(;*p;p++)
     {
-      cdebug(*p);
+      dbout(0,*p);
 
     }
 
-  cdebug("--");
+  dbout(0,"--");
 
 #endif
   addPath("data");
@@ -115,8 +115,8 @@
 		}
 	  else
 	  {
-		  cdebug("could not create dir:"<<s);
-		  cdebug("rc:"<<rc);
+		  dbout(0,"could not create dir:"<<s);
+		  dbout(0,"rc:"<<rc);
 		  throw std::runtime_error("could not create dir");
 		}
     }
@@ -133,7 +133,7 @@
 	case EACCES: 
 	  return; // probably exists - we don't have access
 	default:
-	  cdebug("could not create dir:"<<s);
+	  dbout(0,"could not create dir:"<<s);
 	  throw std::runtime_error("could not create dir");
 	}
     }
@@ -238,9 +238,9 @@
   //    throw std::runtime_error("Not yet inited fs-paths!");
 
   for(std::list<std::string>::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
-    cdebug("path:"<<*i);
+    dbout(0,"path:"<<*i);
 
-  cdebug("LOAD FAILED:"<<pName);
+  dbout(0,"LOAD FAILED:"<<pName);
 
   return r;
 }
@@ -414,7 +414,7 @@
 
   if(!f)
     {
-      cdebug("Error saving file:"<<pName);
+      dbout(0,"Error saving file:"<<pName);
     }
   assert(f);
 
@@ -506,13 +506,13 @@
   struct dirent *ent;
   DIR *dir;
   std::string dirname=pDir;//+"/*";
-  cdebug("DIR:"<<dirname);
+  dbout(0,"DIR:"<<dirname);
   dir=opendir(dirname.c_str());
   if(dir)
     {
       while((ent=readdir(dir)))
 	{
-	  cdebug("found:"<<ent->d_name);
+	  dbout(0,"found:"<<ent->d_name);
 	  v.push_back(ent->d_name);
 	}
     }

Modified: antargis/trunk/gui/src/ag_gltexture.cc
===================================================================
--- antargis/trunk/gui/src/ag_gltexture.cc	2007-03-14 19:02:05 UTC (rev 1059)
+++ antargis/trunk/gui/src/ag_gltexture.cc	2007-03-15 20:03:57 UTC (rev 1060)
@@ -45,7 +45,7 @@
   assertGL;
   gUsedTexMemory+=w*h*4;
 
-  cdebug("used memory:"<<gUsedTexMemory);
+  dbout(4,"used memory:"<<gUsedTexMemory);
 
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
   assertGL;
@@ -68,7 +68,7 @@
   assertGL;
 
   gUsedTexMemory+=w*h*d*4;
-  cdebug("used memory:"<<gUsedTexMemory);
+  dbout(4,"used memory:"<<gUsedTexMemory);
 
   glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
   assertGL;

Modified: antargis/trunk/gui/src/ag_main.h
===================================================================
--- antargis/trunk/gui/src/ag_main.h	2007-03-14 19:02:05 UTC (rev 1059)
+++ antargis/trunk/gui/src/ag_main.h	2007-03-15 20:03:57 UTC (rev 1060)
@@ -94,5 +94,9 @@
 bool videoInited();
 std::string AGEXPORT myHash(const std::string &p);
 
+// from ag_debug
+size_t getDebugLevel();
+void setDebugLevel(size_t t);
 
+
 #endif

Modified: antargis/trunk/gui/src/ag_messageobject.cc
===================================================================
--- antargis/trunk/gui/src/ag_messageobject.cc	2007-03-14 19:02:05 UTC (rev 1059)
+++ antargis/trunk/gui/src/ag_messageobject.cc	2007-03-15 20:03:57 UTC (rev 1060)
@@ -325,7 +325,7 @@
 bool AGMessageObject::processEvent(AGEvent* agEvent) 
 {
 
-  //  cdebug("typeid:"<<typeid(this).name());
+  //  dbout(1,"typeid:"<<typeid(this).name());
   //  TRACE;
   //  SDL_Event e;
   bool rc=false;
@@ -531,7 +531,7 @@
 	  os<<"SDL_NOEVENT";
 	  break;
 	default:
-	  cdebug("UNKNOWN SDL_EVENT:"<<pEvent->type);
+	  dbout(1,"UNKNOWN SDL_EVENT:"<<pEvent->type);
 	  os<<"SDL_NOEVENT";
 	  break;
 	}
@@ -667,7 +667,7 @@
 }
 bool eventOk(const SDL_Event &pEvent)
 {
-  cdebug("eventOk: check "<<(int)pEvent.type<<"!="<<SDL_NOEVENT<<" ???");
+  dbout(1,"eventOk: check "<<(int)pEvent.type<<"!="<<SDL_NOEVENT<<" ???");
   return (int)pEvent.type!=SDL_NOEVENT;
 }
 

Modified: antargis/trunk/gui/src/ag_rand.cc
===================================================================
--- antargis/trunk/gui/src/ag_rand.cc	2007-03-14 19:02:05 UTC (rev 1059)
+++ antargis/trunk/gui/src/ag_rand.cc	2007-03-15 20:03:57 UTC (rev 1060)
@@ -22,29 +22,49 @@
 #include "ag_main.h"
 #include "ag_profiler.h"
 #include "ag_rand.h"
-#include "mtwist.h"
 
 #include <sstream>
 
-static mt_state mState;
+//static mt_state mState;
 
 
 AGRandomizer::AGRandomizer(const std::string &pSeed)
 {
+  CTRACE;
+
   std::istringstream is;
   is.str(pSeed);
 
+  mState.stateptr=0;
+  mState.initialized=0;
+
+
   is>>mState.stateptr;
   is>>mState.initialized;
 
   for(unsigned long i=0;i<MT_STATE_SIZE;i++)
-    is>>mState.statevec[i];
+    {
+      mState.statevec[i]=0;
+      is>>mState.statevec[i];
+    }
+
+  cdebug("state"<<mState.stateptr);
+  cdebug("seed:"<<pSeed);
+
+  assert(mState.stateptr<MT_STATE_SIZE && mState.stateptr>=0);
   
   //  mts_seed(&mState);
 
 }
+
+AGRandomizer::~AGRandomizer()
+{
+  CTRACE;
+}
+
 float AGRandomizer::operator()(float f)
 {
+  CTRACE;
   float d=(float)mts_drand(&mState);
   cdebug("d:"<<d<<" f:"<<f);
   d*=f;
@@ -54,6 +74,7 @@
 }
 int AGRandomizer::operator()(int i)
 {
+  CTRACE;
   int r=mts_lrand(&mState);
   cdebug("r:"<<r<<" i:"<<i);
   r%=i;

Modified: antargis/trunk/gui/src/ag_rand.h
===================================================================
--- antargis/trunk/gui/src/ag_rand.h	2007-03-14 19:02:05 UTC (rev 1059)
+++ antargis/trunk/gui/src/ag_rand.h	2007-03-15 20:03:57 UTC (rev 1060)
@@ -23,6 +23,7 @@
 
 #include <string>
 #include "ag_rubyobj.h"
+#include "mtwist.h"
 
 // Randomizer using Mersenne Twister - it's even faster
 // than the common libc-implementation of rand()
@@ -36,6 +37,7 @@
   // restore a randomizer from a state-string (pretty long)
   // for an initial seed - call with pSeed==""
   AGRandomizer(const std::string &pSeed);
+  ~AGRandomizer();
 #ifdef SWIG
   %rename(randFloat) operator()(float f);
   %rename(randInt) operator()(int i);
@@ -46,6 +48,7 @@
   // give state-string, to be saved
   std::string stateToString() const;
 
+  mt_state mState;
 };
 
 /// calls getMain()->getRand()->rand()

Modified: antargis/trunk/ruby/antargislib.rb
===================================================================
--- antargis/trunk/ruby/antargislib.rb	2007-03-14 19:02:05 UTC (rev 1059)
+++ antargis/trunk/ruby/antargislib.rb	2007-03-15 20:03:57 UTC (rev 1060)
@@ -56,7 +56,7 @@
 					if $enableLogging
 						@@eventDebugging||=File.open("events.txt","w")
 						@@eventDebugging.puts s
-						puts "NEWEVENT: #{self}  #{s}"
+						#puts "NEWEVENT: #{self}  #{s}"
 					end
 				end
 			end
@@ -72,7 +72,7 @@
 		if $enableLogging and not $demoMode
 			@@eventDebugging||=File.open("events.txt","w")
 			@@eventDebugging.puts "T: #{t}"
-			puts "TIME #{t}"
+			#puts "TIME #{t}"
 		end
 		return false
 	end
@@ -100,6 +100,8 @@
 		@@antargislibinited=true
 		@@fullscreen=false
 		@@antProfiling=false
+
+		setDebugLevel(1000)
 	
 		# check options
 		ARGV.each{|arg|
@@ -126,6 +128,9 @@
 						@@fullscreen=true
 					when "window"
 						@@fullscreen=false
+					when /debug-level/
+						level=a.split("=")[1].to_i
+						setDebugLevel(level)
 					when "demo"
 						$demoMode=true
 					when "gui-test"
@@ -150,6 +155,8 @@
 	--gui-test     tells BoA to use events.txt to produce GUI-events
 
 	--demo         enable demo mode - reading events from events.txt
+
+	--debug-level=x
 	"
 	
 						exit
@@ -244,13 +251,14 @@
 class AntApplication<AGApplication
 	include AntMyEventHandler
 
-	def delay(ms)
-		puts "DELAY  #{ms}"
-		return 
-		if not demoMode
-			super
-		end
-	end
+# # Here you can bypass some functions - if you might want to -
+# 	def delay(ms)
+# 		puts "DELAY  #{ms}"
+# 		return 
+# 		if not demoMode
+# 			super
+# 		end
+# 	end
 end
 
 # def rand

Modified: antargis/trunk/ruby/ents.rb
===================================================================
--- antargis/trunk/ruby/ents.rb	2007-03-14 19:02:05 UTC (rev 1059)
+++ antargis/trunk/ruby/ents.rb	2007-03-15 20:03:57 UTC (rev 1060)
@@ -112,12 +112,18 @@
 		@fightTarget
 	end
 	def getRand
-		# FIXME - implement me (network code)
-		#rand
-# 		@mrand||=AGRandomizer.new("")
-# 		return @mrand.randFloat(1)
-		puts "#{self} getRand"
-		puts caller.join("\n")
+		if false
+			# FIXME - implement me (network code)
+			#rand
+			puts "mrand:#{@mrand}"
+			@mrand||=AGRandomizer.new("")
+			val=@mrand.randFloat(1)
+	
+			puts "#{self} getRand #{val}  #{@mrand}"
+			puts caller.join("\n")
+	
+			return val
+		end
 		agRand(1.0)
 	end
 

Modified: antargis/trunk/ruby/intro.rb
===================================================================
--- antargis/trunk/ruby/intro.rb	2007-03-14 19:02:05 UTC (rev 1059)
+++ antargis/trunk/ruby/intro.rb	2007-03-15 20:03:57 UTC (rev 1060)
@@ -78,7 +78,7 @@
 	end
 	
 	def checkPhase
-		puts "#{@time}>#{@phases[@phase]}"
+		#puts "#{@time}>#{@phases[@phase]}"
 		if @time>@phases[@phase]
 			@time-=@phases[@phase]
 			@phase+=1

Modified: antargis/trunk/ruby/mainmenu.rb
===================================================================
--- antargis/trunk/ruby/mainmenu.rb	2007-03-14 19:02:05 UTC (rev 1059)
+++ antargis/trunk/ruby/mainmenu.rb	2007-03-15 20:03:57 UTC (rev 1060)
@@ -397,7 +397,6 @@
 	end
 
 	def eventFrame(t)
-		puts "evenFrame #{t}"
 		@frameTime||=0
 		@frames||=0
 		@frameTime+=t



From davidkamphausen at mail.berlios.de  Fri Mar 16 20:21:33 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Fri, 16 Mar 2007 20:21:33 +0100
Subject: [Antargis-svn] r1061 - in antargis/trunk: . gui/src ruby ruby/tests
Message-ID: <200703161921.l2GJLXNf005122@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-16 20:21:32 +0100 (Fri, 16 Mar 2007)
New Revision: 1061

Modified:
   antargis/trunk/ChangeLog
   antargis/trunk/Rakefile
   antargis/trunk/TODO
   antargis/trunk/gui/src/ag_rand.cc
   antargis/trunk/ruby/ant_boss.rb
   antargis/trunk/ruby/ant_hljobs.rb
   antargis/trunk/ruby/antargis.rb
   antargis/trunk/ruby/map.rb
   antargis/trunk/ruby/tests/scissor_test.rb
Log:
* small fixes


Modified: antargis/trunk/ChangeLog
===================================================================
--- antargis/trunk/ChangeLog	2007-03-15 20:03:57 UTC (rev 1060)
+++ antargis/trunk/ChangeLog	2007-03-16 19:21:32 UTC (rev 1061)
@@ -1,3 +1,12 @@
+0.2
+	- major refactoring and documentation effort
+	- many bugs fixed
+	- preparations for AI and network code
+	- basic AI functionality
+	- speed and compabitility improvements
+	- event-tracking and demo-mode
+
+
 for 0.1.3:
 * moving with left-mouse-button
 * FBOs

Modified: antargis/trunk/Rakefile
===================================================================
--- antargis/trunk/Rakefile	2007-03-15 20:03:57 UTC (rev 1060)
+++ antargis/trunk/Rakefile	2007-03-16 19:21:32 UTC (rev 1061)
@@ -218,7 +218,7 @@
 
 task :test => "libantargis.so" do |t|
 	if (not $xcompile)
-		`ruby ruby/runtests.rb`
+		msh "ruby ruby/runtests.rb"
 	end
 	#require 'libantargis.so'
 end

Modified: antargis/trunk/TODO
===================================================================
--- antargis/trunk/TODO	2007-03-15 20:03:57 UTC (rev 1060)
+++ antargis/trunk/TODO	2007-03-16 19:21:32 UTC (rev 1061)
@@ -1,3 +1,17 @@
+* Translation tut3
+* Fighting tut2 - problems men belong to more than one buildign ???
+* fix jobs some more
+* what's wrong with pathfinding-test ???
+
+
+
+
+
+
+==========
+
+
+
 Short Information:
 Problems are marked by priority. L is for low, M for medium and H high.
 In special cases it can be Very High (=VH).

Modified: antargis/trunk/gui/src/ag_rand.cc
===================================================================
--- antargis/trunk/gui/src/ag_rand.cc	2007-03-15 20:03:57 UTC (rev 1060)
+++ antargis/trunk/gui/src/ag_rand.cc	2007-03-16 19:21:32 UTC (rev 1061)
@@ -111,7 +111,7 @@
 
 void randSpeed()
 {
-  long m=10000000;
+  long m=100000;
   int t;
   int max=100;
   {

Modified: antargis/trunk/ruby/ant_boss.rb
===================================================================
--- antargis/trunk/ruby/ant_boss.rb	2007-03-15 20:03:57 UTC (rev 1060)
+++ antargis/trunk/ruby/ant_boss.rb	2007-03-16 19:21:32 UTC (rev 1061)
@@ -91,8 +91,8 @@
 	end
 	
 	def eventNoJob
-		dputs "eventNoJob "+self.class.to_s+" "+ at job.to_s
-		dputs caller.join("\n")
+# 		dputs "eventNoJob "+self.class.to_s+" "+ at job.to_s
+# 		dputs caller.join("\n")
 		checkHLJobEnd(self)
  		checkCreateMen
 	end

Modified: antargis/trunk/ruby/ant_hljobs.rb
===================================================================
--- antargis/trunk/ruby/ant_hljobs.rb	2007-03-15 20:03:57 UTC (rev 1060)
+++ antargis/trunk/ruby/ant_hljobs.rb	2007-03-16 19:21:32 UTC (rev 1061)
@@ -826,7 +826,7 @@
 		@usedmen=0
 		@restype={}
 		@constructStarted=false
-		@productionRules=$productionRules # FIXME maybe exchange for different constructing types
+		@@productionRules=$productionRules # FIXME maybe exchange for different constructing types
 	end
 	def image
 		"data/gui/construct.png"
@@ -974,7 +974,7 @@
 	end
 	def readyConstructed
 		# produce any
-		@productionRules.shuffle.each{|rule|
+		@@productionRules.shuffle.each{|rule|
 			ok=true
 			
 			rule.from.each{|w,n|

Modified: antargis/trunk/ruby/antargis.rb
===================================================================
--- antargis/trunk/ruby/antargis.rb	2007-03-15 20:03:57 UTC (rev 1060)
+++ antargis/trunk/ruby/antargis.rb	2007-03-16 19:21:32 UTC (rev 1061)
@@ -159,9 +159,9 @@
 		#setCursor(getTextureCache.get("blue_cursor.png"))
 	end
 
-	def getSpeed
-		@speed
-	end
+# 	def getSpeed
+# 		@speed
+# 	end
 
 	####################################
 	# EVENT HANDLERS
@@ -253,6 +253,11 @@
 				if @hero
 					@hero.newHLRestJob(10)
 				end
+			when SDLK_PLUS
+				@speed=[@speed+1,5].min
+			when SDLK_MINUS
+				@speed=[@speed-1,1].max
+			
 			when SDLK_p
 				eventPause(nil)
 		end
@@ -290,7 +295,7 @@
 
 
 		# move entities in game-engine
-		getMap().move(time)
+		getMap().move(time*@speed)
 		# advance animations
 		getScene.advance(time)
 		checkHeroEnergy

Modified: antargis/trunk/ruby/map.rb
===================================================================
--- antargis/trunk/ruby/map.rb	2007-03-15 20:03:57 UTC (rev 1060)
+++ antargis/trunk/ruby/map.rb	2007-03-16 19:21:32 UTC (rev 1061)
@@ -452,7 +452,7 @@
 		if @pause
 			return
 		end
-		time*=@app.getSpeed # increase speed
+		#time*=@app.getSpeed # increase speed  # moved to app
 		@curTime+=time
 		@@systemTime+=time
 		super(time)

Modified: antargis/trunk/ruby/tests/scissor_test.rb
===================================================================
--- antargis/trunk/ruby/tests/scissor_test.rb	2007-03-15 20:03:57 UTC (rev 1060)
+++ antargis/trunk/ruby/tests/scissor_test.rb	2007-03-16 19:21:32 UTC (rev 1061)
@@ -18,7 +18,8 @@
 	end
 	def eventFrame(t)
 		#puts "eventFram"
-		delay(20)
+		#delay(20)
+		tryQuit
 		return true
 	end
 



From davidkamphausen at mail.berlios.de  Wed Mar 21 20:31:01 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Wed, 21 Mar 2007 20:31:01 +0100
Subject: [Antargis-svn] r1062 - in antargis/trunk: gui/src ruby
Message-ID: <200703211931.l2LJV1bj030526@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-21 20:31:00 +0100 (Wed, 21 Mar 2007)
New Revision: 1062

Added:
   antargis/trunk/ruby/ant_new_hljobs.rb
Modified:
   antargis/trunk/gui/src/ag_debug.cc
   antargis/trunk/gui/src/ag_debug.h
   antargis/trunk/gui/src/ag_geometry.cc
   antargis/trunk/gui/src/ag_geometry.h
   antargis/trunk/ruby/ant_boss.rb
   antargis/trunk/ruby/ant_hljobs.rb
   antargis/trunk/ruby/ant_man.rb
   antargis/trunk/ruby/ant_manbase.rb
   antargis/trunk/ruby/ant_tools.rb
Log:
* some fixes - improvements with new hl-jobs


Modified: antargis/trunk/gui/src/ag_debug.cc
===================================================================
--- antargis/trunk/gui/src/ag_debug.cc	2007-03-16 19:21:32 UTC (rev 1061)
+++ antargis/trunk/gui/src/ag_debug.cc	2007-03-21 19:31:00 UTC (rev 1062)
@@ -51,7 +51,18 @@
   gRubyRaising=flag;
 }
 
+size_t gDebugLevel=0;
 
+size_t getDebugLevel()
+{
+  return gDebugLevel;
+}
+void setDebugLevel(size_t t)
+{
+  gDebugLevel=t;
+}
+
+
 #ifndef MNDEBUG
 int D::d=0;
 
@@ -66,24 +77,14 @@
 }
 
 size_t gDebugIndex=0;
-size_t gDebugLevel=0;
 
 size_t getDebugIndex()
 {
   return gDebugIndex;
 }
 
-size_t getDebugLevel()
-{
-  return gDebugLevel;
-}
-void setDebugLevel(size_t t)
-{
-  gDebugLevel=t;
-}
 
 
-
 D::D(std::string c):
   m(c)
 {

Modified: antargis/trunk/gui/src/ag_debug.h
===================================================================
--- antargis/trunk/gui/src/ag_debug.h	2007-03-16 19:21:32 UTC (rev 1061)
+++ antargis/trunk/gui/src/ag_debug.h	2007-03-21 19:31:00 UTC (rev 1062)
@@ -39,6 +39,7 @@
 void setQuiet();
 
 #ifdef MNDEBUG
+#define dbout(x,l)
 #define cdebug(x)
 #define ccdebug(x)
 #define debug(x)

Modified: antargis/trunk/gui/src/ag_geometry.cc
===================================================================
--- antargis/trunk/gui/src/ag_geometry.cc	2007-03-16 19:21:32 UTC (rev 1061)
+++ antargis/trunk/gui/src/ag_geometry.cc	2007-03-21 19:31:00 UTC (rev 1062)
@@ -250,7 +250,12 @@
   return v[0]*v[0]+v[1]*v[1];
 }
 
+AGVector2 AGVector2::dim2() const
+{
+  return *this;
+}
 
+
 bool AGVector2::nonZero() const
 {
   return length2()!=0.0f;

Modified: antargis/trunk/gui/src/ag_geometry.h
===================================================================
--- antargis/trunk/gui/src/ag_geometry.h	2007-03-16 19:21:32 UTC (rev 1061)
+++ antargis/trunk/gui/src/ag_geometry.h	2007-03-21 19:31:00 UTC (rev 1062)
@@ -73,6 +73,8 @@
   void setX(float pX);
   void setY(float pY);
 
+  AGVector2 dim2() const;
+
   
 #ifdef SWIG
   %rename(x) getX() const;

Modified: antargis/trunk/ruby/ant_boss.rb
===================================================================
--- antargis/trunk/ruby/ant_boss.rb	2007-03-16 19:21:32 UTC (rev 1061)
+++ antargis/trunk/ruby/ant_boss.rb	2007-03-21 19:31:00 UTC (rev 1062)
@@ -26,9 +26,12 @@
 class AntBoss<AntRubyEntity
 	attr_accessor :formation
 
+	attr_accessor :hlJobMode
+
 	def initialize
 		super(AGVector2.new(0,0))
 		@men=[]
+		@hlJobMode={}
 		@job=nil
 		@createMen=0
 		@selected=@hovered=false
@@ -220,6 +223,13 @@
 		if getMap
 			getMap.eventNewJobAssignedToBoss(self)
 		end
+
+		begin
+		# discard reassigning in this case
+		return if ObjectSpace.const_get(:AntNewHLJob)
+		rescue
+		end
+
 		@men.each{|man|
 			man.delJob
 			assignJob(man)

Modified: antargis/trunk/ruby/ant_hljobs.rb
===================================================================
--- antargis/trunk/ruby/ant_hljobs.rb	2007-03-16 19:21:32 UTC (rev 1061)
+++ antargis/trunk/ruby/ant_hljobs.rb	2007-03-21 19:31:00 UTC (rev 1062)
@@ -1110,4 +1110,11 @@
 end
 
 
-require 'ant_buildjob.rb'
\ No newline at end of file
+require 'ant_buildjob.rb'
+
+
+def newHLJobs
+	return false
+end
+
+#require 'ant_new_hljobs.rb'
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_man.rb
===================================================================
--- antargis/trunk/ruby/ant_man.rb	2007-03-16 19:21:32 UTC (rev 1061)
+++ antargis/trunk/ruby/ant_man.rb	2007-03-21 19:31:00 UTC (rev 1062)
@@ -33,9 +33,14 @@
 
 	attr_reader :meshState, :dead
 	attr_accessor :target
+
+	attr_accessor :hlJobMode
 	
 	def initialize()
 		super(AGVector2.new(0,0))
+
+		@hlJobMode={}
+
 		setProvide("man",true)
 		@signed=false
 		@dead=false
@@ -177,7 +182,7 @@
 		super
 		setGoAnim
 	end
-	
+
 	def newMoveJob(p,target,n)
 		if isOnWater and isOnOpenWater(target) and (not haveBoat)
 			newRestJob(2)

Modified: antargis/trunk/ruby/ant_manbase.rb
===================================================================
--- antargis/trunk/ruby/ant_manbase.rb	2007-03-16 19:21:32 UTC (rev 1061)
+++ antargis/trunk/ruby/ant_manbase.rb	2007-03-21 19:31:00 UTC (rev 1062)
@@ -62,6 +62,26 @@
 		setMeshState("sitdown")
 	end
 
+	def walkTo(p)
+		newMoveJob(0,p,0)
+	end
+	
+	def standStill
+		newRestJob(2)
+		setMeshState("stand")
+	end
+
+	def standStillShort
+		newRestJob(0.2)
+		setMeshState("stand")
+	end
+
+	def sitStill
+		newRestJob(2)
+		setMeshState("sit")
+	end
+
+
 	# overrides newFightJob from AntEntity
 	# fighting distance is assigned 1 or 10 
 	# depending on the man having a bow
@@ -74,6 +94,14 @@
 	end
 
 	def eventDefeated
+		# FIXME: check, if this ok !!!! /HLJobs
+		if newHLJobs
+			hlJobMode[:defeated]=true
+			eventNoJob
+			return
+		end
+
+
 		if is_a?(AntBoss)
 			eventManDefeated(self)
 		elsif @boss then

Added: antargis/trunk/ruby/ant_new_hljobs.rb
===================================================================
--- antargis/trunk/ruby/ant_new_hljobs.rb	2007-03-16 19:21:32 UTC (rev 1061)
+++ antargis/trunk/ruby/ant_new_hljobs.rb	2007-03-21 19:31:00 UTC (rev 1062)
@@ -0,0 +1,236 @@
+#
+# This is a new implementation of the high-level jobs.
+# They're now state-based. Each job consists of several
+# states. Each of these states has (or can have) an "enter",
+# "assign","ready" and a "leave"-function.
+# "enter" is called each time the current job switches into
+# this state. "leave" is called when the state is left
+# "ready" will be called to check, if the task of this state is 
+# finished and the job can be transfered into a new state.
+# "assign" is called whenever a man has no low-level-job anymore
+# and wants to get a new task. You should always assign low-level-jobs
+# to waiting men, because otherwise this function gets called for
+# each waiting man in each frame, which can have impact on the performance.
+#
+# 
+
+def newHLJobs
+	return false
+end
+
+# 
+# FIXME: * add path-finding to moving
+#        * do FIXME s ;-)
+
+module HLJob
+	def hero
+		@hero
+	end
+	def allMen
+		@hero.getMen
+	end
+end
+
+require 'ant_hljob_states.rb'
+require 'ant_hljob_base.rb'
+
+
+class AntNewHLRestJob<AntNewHLJob
+	include HLJob_FormatSit
+	include HLJob_SitDown
+	include HLJob_JustSitOnce
+	include HLJob_SpreadThings
+
+	SPREAD_CHECK_TIME=10 # all 10 seconds spread things
+
+	def initialize(hero,time)
+		@state=:FormatSit
+		@workflow=[[:FormatSit,:SitDown],[:SitDown,:CheckSpread],[:SpreadThings,:FormatSit],[:JustSitOnce,:CheckSpread]] #JustSit],[:JustSit]
+		super(hero)
+	end
+	def image
+		"data/gui/bed.png"
+	end
+	# fixme: discard this
+	def makeMessage(boss)
+		RestMessage.new(boss, at time)
+	end
+
+	def sitDown_leave
+		if @spreadOnce.nil?
+			@spreadTime=getTime-SPREAD_CHECK_TIME
+			@spreadOnce=true
+		else
+			@spreadTime=getTime
+		end
+	end
+	
+
+	def checkSpread_enter
+		curTime=getTime
+		puts "#{curTime- at spreadTime}>#{SPREAD_CHECK_TIME}"
+		if curTime- at spreadTime>SPREAD_CHECK_TIME
+			switchToState(:SpreadThings)
+		else
+			switchToState(:JustSitOnce)
+		end
+	end
+end
+
+class AntNewHLMoveJob<AntNewHLJob
+	include HLJob_FormatWalk
+	include HLJob_MoveToNextWayPoint
+	include HLJob_FormatSit
+	include HLJob_SitDown
+	# FIXME: time is irrelevant here!
+	#def initialize(hero,time)
+
+	attr_reader :targetPos
+
+	def initialize(hero,prio,pos,dist,doFormat=true)
+		@targetPos=pos.dim2
+		if doFormat
+			@state=:FormatWalk
+		else
+			@state=:MoveToNextWayPoint
+		end
+		@workflow=[
+			[:FormatWalk,:MoveToNextWayPoint],
+# 			[:MoveToNextWayPoint,:FormatSit],
+# 			[:FormatSit,:SitDown]
+		]
+		super(hero)
+	end
+	# FIXME: move this to a config-file !
+	def image
+		"data/gui/move.png"
+	end
+	# FIXME: discard this
+	def makeMessage(boss)
+		MoveMessage.new(boss,targetPos, at dist)
+	end
+
+end
+
+
+class AntNewHLTakeJob<AntNewHLJob
+	include HLJob_FormatWalk
+	include HLJob_FetchStart
+	include HLJob_GetResource
+	include HLJob_MoveToNextWayPoint
+
+	attr_reader :resources, :targetPos, :near, :target
+
+	def initialize(phero,target,what="food")
+		@resources={"food"=>["food"],"weapon"=>["sword","bow","boat","shield"]}[what]
+
+		@state=:FormatWalk
+		@workflow=[
+			[:FormatWalk,:MoveToNextWayPoint],
+			[:MoveToNextWayPoint,:MyStore],
+			[:MyStore,:FetchStart],
+			[:FetchStart,:GetResource],
+			[:GetResource,:MoveToNextWayPoint]
+		]
+		@targetPos=target.getPos2D
+		@target=target
+		@near=4
+		super(phero)
+	end
+
+	def image
+		if @what=="food"
+			"data/gui/take_apple.png"
+		else
+			"data/gui/take_weapon.png"
+		end
+	end
+
+
+	def myStore_enter
+		trace
+		if @taken
+			@finished=true
+			return 
+		end
+		@targetPos=hero.getPos2D
+		puts "#{@targetPos} #{hero.getPos2D}"
+		@near=0
+		@taken=true
+	end
+end
+
+class AntNewHLKillAnimal<AntNewHLTakeJob
+	def fetchStart_leave
+		# kill animal
+		playSound
+		killAnimal
+	end
+
+	
+	def myStore_enter
+		if @taken
+			@finished=true
+			return 
+		end
+		# no need to return to separate position
+		@taken=true
+	end
+
+	private
+	def playSound
+		# FIXME: play eat sound
+	end
+	def killAnimal
+		@target.eventDie
+		hero.resource.takeAll(target.resource)
+	end
+end
+
+class AntNewHLFight<AntNewHLJob
+	include HLJob_FormatWalk
+	include HLJob_MoveToNextWayPoint
+	include HLJob_Fight
+
+	attr_reader :targetPos,:near,:target
+
+	def initialize(hero,target,defend=false)
+		@target=target
+		if defend
+			@state=:Fight
+			#trace
+		else
+			@state=:FormatWalk
+			@targetPos=target.getPos2D
+			@near=10
+			@workflow=[
+				[:FormatWalk,:MoveToNextWayPoint],
+				[:MoveToNextWayPoint,:Fight]
+			]
+		end
+		super(hero)
+	end
+
+	def image
+		"data/gui/sword.png"
+	end
+
+
+end
+
+# rename and replace old hl-jobs
+
+AntHeroRestJobOld=AntHeroRestJob
+AntHeroRestJob=AntNewHLRestJob
+
+AntHeroMoveJobOld=AntHeroMoveJob
+AntHeroMoveJob=AntNewHLMoveJob
+
+AntHeroTakeJobOld=AntHeroTakeJob
+AntHeroTakeJob=AntNewHLTakeJob
+
+AntHeroFightAnimalJobOld=AntHeroFightAnimalJob
+AntHeroFightAnimalJob=AntNewHLKillAnimal
+
+AntHeroFightJobOld=AntHeroFightJob
+AntHeroFightJob=AntNewHLFight
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_tools.rb
===================================================================
--- antargis/trunk/ruby/ant_tools.rb	2007-03-16 19:21:32 UTC (rev 1061)
+++ antargis/trunk/ruby/ant_tools.rb	2007-03-21 19:31:00 UTC (rev 1062)
@@ -67,3 +67,15 @@
 	ObjectSpace.each_object(Class){|a|c.push(a) if a.ancestors.member?(p)}
 	return c
 end
+
+def trace
+	puts "TRACE #{caller[0]}"
+end
+
+def assert(&block)
+	if not block.call
+		raise "Assertion #{block} failed in #{caller[0]} #{block.binding}"
+	end
+end
+
+



From davidkamphausen at mail.berlios.de  Sun Mar 25 18:13:33 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 25 Mar 2007 18:13:33 +0200
Subject: [Antargis-svn] r1063 - in antargis/trunk: ruby src
Message-ID: <200703251613.l2PGDXui023394@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-25 18:13:32 +0200 (Sun, 25 Mar 2007)
New Revision: 1063

Added:
   antargis/trunk/ruby/ant_hljob_base.rb
   antargis/trunk/ruby/ant_hljob_states.rb
   antargis/trunk/ruby/ant_to_xml.rb
Modified:
   antargis/trunk/ruby/ant_boss.rb
   antargis/trunk/ruby/ant_hljobs.rb
   antargis/trunk/ruby/ant_inventory.rb
   antargis/trunk/ruby/ant_local.rb
   antargis/trunk/ruby/ant_man.rb
   antargis/trunk/ruby/ant_new_hljobs.rb
   antargis/trunk/src/path.cc
Log:
* some fixes
* some changes for new hl-jobs


Modified: antargis/trunk/ruby/ant_boss.rb
===================================================================
--- antargis/trunk/ruby/ant_boss.rb	2007-03-21 19:31:00 UTC (rev 1062)
+++ antargis/trunk/ruby/ant_boss.rb	2007-03-25 16:13:32 UTC (rev 1063)
@@ -198,11 +198,12 @@
 	end
 
 	def underAttack
-		@job.is_a?(AntHeroFightJob)
+		(@job.is_a?(AntHeroFightJob) and (not @job.finished))
 	end
 
 
 	def setOwner(owner)
+		trace
 		@owner=owner
 		dputs "RESETING PLAYER:"
 		if @player
@@ -213,7 +214,10 @@
 			@player.add(self)
 		end
 		getMap.eventOwnerChanged(self)
+		trace
 		AntInventory.update(self)
+		trace
+		#resourceChanged
 	end
 	def getOwner
 		@owner
@@ -326,6 +330,10 @@
 	end
 
 	def eventHaveDefeated(e)
+		if newHLJobs
+			eventNoJob
+			return
+		end
 		puts "#{getName} has defeated #{e.getName}"
 		if @job.is_a?(AntHeroFightJob)
 			@job.haveDefeated(e)

Added: antargis/trunk/ruby/ant_hljob_base.rb
===================================================================
--- antargis/trunk/ruby/ant_hljob_base.rb	2007-03-21 19:31:00 UTC (rev 1062)
+++ antargis/trunk/ruby/ant_hljob_base.rb	2007-03-25 16:13:32 UTC (rev 1063)
@@ -0,0 +1,96 @@
+class AntNewHLJob
+	attr_reader :finished
+	# some magic here
+	def initialize(hero)
+		@hero=hero
+
+		@finished=false
+
+		firstCall
+	end
+	def getTime
+		@hero.getMap.getTime
+	end
+	def allMen
+		if @hero.is_a?(AntHero)
+			@hero.getMen
+		else
+			@hero.getMen-[@hero]
+		end
+	end
+	def hero
+		@hero
+	end
+
+	def check(man)
+		return if @state.nil?
+		call2(@state,"assign",man)
+		while call(@state,"ready")
+			call(@state,"leave")
+			goToNextState
+			break if @state.nil? or @finished
+		end
+		puts "FINISHED: #{@finished}"
+	end
+
+	# override this one
+	def goToNextState
+		@workflow.each{|p|
+			if p[0]==@state
+				@state=p[1]
+				call(@state,"enter")
+				return
+			end
+		}
+		@finished=true
+	end
+
+	def switchToState(state)
+		call(@state,"leave")
+		@state=state
+		call(@state,"enter")
+	end
+
+	def firstCall
+		call(@state,"enter")
+	end
+
+	def call(state,event)
+		m=methodName(state,event)
+		print "CALL #{state} #{event} #{m}  #{getTime} -- "
+		if self.class.method_defined?(m)
+			v=send(m)
+			puts v
+			return v
+		else
+			puts "UNKNOWN"
+			true
+		end
+	end
+	def xmlName
+		self.class.to_s
+	end
+
+	def call2(state,event,man)
+		m=methodName(state,event)
+		print "CALL2 #{state} #{event} #{m} #{man} #{getTime} -- "
+		if self.class.method_defined?(m)
+			v=send(m,man)
+			puts v
+			return v
+		else
+			puts "UNKNOWN"
+			true
+		end
+	end
+
+	def methodName(state,event)
+		m=state.to_s+"_"+event
+		m=m[0..0].downcase+m[1..-1]
+	end
+
+	def trace
+		puts "TRACE #{caller[0]} #{getTime}"
+	end
+		
+end

Added: antargis/trunk/ruby/ant_hljob_states.rb
===================================================================
--- antargis/trunk/ruby/ant_hljob_states.rb	2007-03-21 19:31:00 UTC (rev 1062)
+++ antargis/trunk/ruby/ant_hljob_states.rb	2007-03-25 16:13:32 UTC (rev 1063)
@@ -0,0 +1,562 @@
+# Does the walk-formation
+# 
+#
+module HLJob_FormatWalk
+	# needed: getTime
+
+	# wait 5 seconds at max for formatting
+	FORMAT_MAX_TIME=5
+
+	def formatWalk_enter
+		trace
+		hero.formation=AntFormationBlock.new(@hero,formatDir)
+		heroPos=@hero.getPos2D
+		allMen.each{|man|
+			pos=@hero.getFormation(man,heroPos)
+			man.walkTo(pos)
+			man.hlJobMode[:formatting]=true
+		}
+		@formatStart=getTime
+	end
+
+	def formatWalk_assign(man)
+		man.setDirection(180-(targetPos-hero.getPos2D).normalized.getAngle.angle*180.0/Math::PI)
+		man.standStill
+		man.hlJobMode.delete(:formatting)
+	end
+
+	def formatWalk_ready
+		if getTime- at formatStart>FORMAT_MAX_TIME
+			return true
+		end
+		allMen.each{|man|
+			if man.hlJobMode[:formatting]
+				return false
+			end
+		}
+		return true
+	end
+
+private
+	def formatDir
+		(targetPos-hero.getPos2D).normalized
+	end
+
+end
+
+module HLJob_FormatSit
+	# needed: getTime
+
+	# wait 5 seconds at max for formatting
+	FORMAT_MAX_TIME=15
+
+	def formatSit_enter
+		trace
+		hero.formation=AntFormationRest.new(@hero)
+		heroPos=@hero.getPos2D
+		allMen.each{|man|
+			pos=@hero.getFormation(man,heroPos)
+			man.walkTo(pos)
+			man.hlJobMode[:formatting]=true
+			#puts "formatSit_enter: #{man} to #{pos}  (heroPos:#{heroPos})"
+		}
+		@formatStart=getTime
+	end
+
+	def formatSit_assign(man)
+		man.setDirection(180-(hero.getPos2D-man.getPos2D).normalized.getAngle.angle*180.0/Math::PI)
+		man.standStill
+		man.hlJobMode.delete(:formatting)
+	end
+
+	def formatSit_ready
+		if getTime- at formatStart>FORMAT_MAX_TIME
+			# FIXME:rest deserts
+			return true
+		end
+		allMen.each{|man|
+			#puts "formatSit_ready: #{man}:#{man.hlJobMode[:formatting]}"
+			if man.hlJobMode[:formatting]
+				return false
+			end
+		}
+		return true
+	end
+end
+
+module HLJob_MoveToNextWayPoint
+	# needed: hero,allMen,targetPos, near
+	def near
+		0
+	end
+
+	def moveToNextWayPoint_enter
+		hero.formation=AntFormationBlock.new(@hero,formatDir)
+		allMen.each{|man|
+			pos=@hero.getFormation(man,targetPos)
+			man.newMoveJob(0,pos,near)
+			man.hlJobMode[:walking]=true
+		}
+	end
+
+	def moveToNextWayPoint_assign(man)
+		man.standStill
+		man.hlJobMode.delete(:walking)
+
+		# FIXME: maybe let him desert if this is called too often ?
+	end
+
+	def moveToNextWayPoint_ready
+		allMen.each{|man|
+			if man.hlJobMode[:walking]
+				return false
+			end
+		}
+		return true
+	end
+
+end
+
+module HLJob_SitDown
+	def sitDown_enter
+		allMen.each{|man|
+			man.setDirection(180-(hero.getPos2D-man.getPos2D).normalized.getAngle.angle*180.0/Math::PI)
+			man.sitDown
+			man.hlJobMode[:sitting]=true
+		}
+	end
+
+	def sitDown_assign(man)
+		man.sitStill
+		man.hlJobMode.delete(:sitting)
+	end
+
+	def sitDown_ready
+		allMen.each{|man|
+			if man.hlJobMode[:sitting]
+				return false
+			end
+		}
+		return true
+	end
+end
+
+module HLJob_JustSit
+	def justSit_enter
+		allMen.each{|man|
+			man.sitStill
+		}
+	end
+	def justSit_assign(man)
+		man.sitStill # and rest
+	end
+
+	def justSit_ready
+		return false
+	end
+end
+
+module HLJob_JustSitOnce
+	def justSitOnce_enter
+		allMen.each{|man|
+			man.sitStill
+			man.hlJobMode[:justSitting]=true
+		}
+	end
+	def justSitOnce_assign(man)
+		man.hlJobMode.delete(:justSitting)
+	end
+	def justSitOnce_ready
+		allMen.each{|man|
+			if man.hlJobMode[:justSitting]
+				return false
+			else
+				return true
+			end
+		}
+	end
+end
+	
+
+module HLJob_FetchStart
+	# needed a target-entity
+	def fetchStart_enter
+		trace
+		fetchPoint=target.getPos2D
+		puts "fetchPoint:#{fetchPoint}  heroPos:#{hero.getPos2D}"
+		allMen.each{|man|
+			man.walkTo(fetchPoint)
+			man.hlJobMode[:fetching]=true
+			puts "set to fetching: #{man}"
+		}
+		
+	end
+
+	def fetchStart_assign(man)
+		trace
+		man.standStill
+		man.hlJobMode.delete(:fetching)
+	end
+
+	def fetchStart_ready
+		trace
+		allMen.each{|man|
+			puts "fetchStart_ready check: #{man} : #{man.hlJobMode[:fetching]}"
+			if man.hlJobMode[:fetching]
+				return false
+			end
+			puts "false"
+		}
+		puts "return true ??"
+		return true
+	end
+end
+
+module HLJob_GetResource
+	# needed: resources return array of resource-strings
+	def getResource_enter
+		allMen.each{|man|
+			resources.each{|r|
+				a=target.resource.get(r)
+				if a>1
+					man.resource.add(r,1)
+					target.resource.sub(r,1)
+				end
+			}
+		}
+	end
+	def getResource_ready
+		return true
+	end
+end
+
+module HLJob_KillAnimal
+	def killAnimal_enter
+		target.eventDie
+		hero.resource.takeAll(target.resource)
+	end
+end
+
+# spread things among team-members
+module HLJob_SpreadThings
+	RESOURCES_TO_SPREAD=["sword","shield","bow","boat"]
+
+	def spreadThings_enter
+		allMen.each{|man|
+			man.walkTo(hero.getPos2D)
+			man.hlJobMode[:gatherToSpread]=true
+		}
+		@alreadySpread=false
+	end
+
+	def spreadThings_assign(man)
+		man.standStillShort
+		if man.hlJobMode[:gatherToSpread]
+			man.hlJobMode.delete(:gatherToSpread)
+			man.hlJobMode[:waitForSpread]=true
+		elsif man.hlJobMode[:waitForSpread]
+			man.hlJobMode.delete(:waitForSpread)
+		else
+			# nothing for now
+		end
+	end
+
+	def spreadThings_ready
+		return true if @alreadySpread		
+		allMen.each{|man|
+			return false if man.hlJobMode[:gatherToSpread] or man.hlJobMode[:waitForSpread]
+		}
+		# we can spread now
+		doSpreading
+		@alreadySpread=true
+		return true
+	end
+	private
+	
+	def doSpreading
+		# FIXME: maybe this can be done more easily ???
+		trace
+	
+		all={}
+		RESOURCES_TO_SPREAD.each{|r|	
+			all=0
+			allMen.each{|m|
+				c=m.resource.get(r)
+				all+=c
+			}
+			if all>=allMen.length
+				# give everyone 1 of these and put the rest on the hero
+				allMen.each{|m|
+					m.resource.set(r,1)
+				}
+				hero.resource.add(r,all-allMen.length)
+			else
+				men=allMen.sort {|b,a|a.resource.get(r)<=>b.resource.get(r)} # sort descending
+				# put hero at first
+				men.delete(hero)
+				men=[hero]+men
+				men.each{|m|m.resource.set(r,0)} # reset
+				for i in 1..all # now give to those who had a weapon and to hero (at first)
+					men[i-1].resource.set(r,1)
+				end
+			end
+		}
+		# spread food equally
+		food=0
+		allMen.each{|m|food+=m.resource.get("food")}
+		min=(food/allMen.length).to_i
+		allMen.each{|m|m.resource.set("food",min)}
+		# spread rest on first
+		food-=min*allMen.length
+		for i in 1..food
+			allMen[i-1].resource.add("food",1)
+		end
+	end
+	
+end
+
+class HLJob_FightData
+
+	attr_reader :inited
+	# only attacker creates fightData
+	def initialize(fightJob)
+		@parties={:attacker=>[fightJob],:defender=>[]}
+		@oldparties=@parties.dup
+	end
+	def add(fightJob)
+		@parties[getFightType(fightJob)].push(fightJob)
+		@oldparties[getFightType(fightJob)].push(fightJob)
+		reshuffle
+	end
+
+	def remove(fightJob)
+		@parties[fightJob.fightType].delete(fightJob)
+		@oldparties[fightJob.fightType].delete(fightJob)
+		reshuffle
+	end
+
+	def removeLost(fightJob)
+		@parties[fightJob.fightType].delete(fightJob)
+		reshuffle
+	end
+
+	def getFightType(fightJob)
+		target=fightJob.target
+		[:attacker,:defender].each{|t| 
+			return otherType(t) if @parties[t].collect{|a|a.hero}.member?(target)
+		}
+		raise "Target #{fightJob} (target:#{target}) not found in getFightType!"
+	end
+
+	def getNewOpponent(man,fightJob)
+		assert{man.is_a?(AntHero) or man.is_a?(AntMan)}
+		assert{man.getHero==fightJob.hero}
+	
+		# for a start: get next opponent
+		# (maybe take next free opponent ??)
+		# (maybe: find weakest friend and help him ???)
+
+		myType=fightJob.fightType
+		oType=otherType(myType)
+
+		opponent=@parties[oType].collect{|job|job.undefeatedMen}.flatten.uniq.shuffle[0]
+		if opponent.nil?
+			# we won ???
+			#eventWon(myType)
+			return nil
+		else
+			return opponent
+		end
+	end
+
+# 	def eventWon(whichType)
+# 		trace
+# 		
+# 
+# 		# FIXME: should be parted !!!
+# 		owners=@oldparties[whichType].collect{|j|j.hero}
+# 		i=0
+# 		puts "whichType:#{whichType}"
+# 		assert{owners.length>0}
+# 		@oldparties[otherType(whichType)].each{|p|
+# 			newOwner=owners[i]
+# 			p.hero.setOwner(newOwner)
+# 			i+=1
+# 			i%=owners.length
+# 		}
+# 	end
+# 	def eventLost(type)
+# 		eventWon(otherType(type))
+# 	end
+	private
+
+	def otherType(my)
+		{:attacker=>:defender,:defender=>:attacker}[my]
+	end
+
+	def reshuffle
+		# reinit and assign
+
+		menGroup={}
+		@parties.each{|type,jobs|
+			puts "parties: #{type}:#{jobs}"
+			menGroup[type]=jobs.collect{|job|job.undefeatedMen}.flatten.uniq
+			return if @inited and menGroup[type].length==0 # a fightjob is leaving
+		}
+	
+		# check that each group has more than 0 members
+		assert{menGroup.select{|k,v|v.length==0}.length==0}
+
+		defenders=menGroup[:defender].dup
+
+		defenders.each{|d|d.hlJobMode.delete(:fightTarget)}
+		
+		assert{defenders.length>0}
+
+		# each attacker gets an opponent - if all defenders are used - restart them agaim
+		menGroup[:attacker].each{|attacker|
+			defender=defenders.min{|a,b|(a.getPos2D-attacker.getPos2D).length<=>(b.getPos2D-attacker.getPos2D).length}
+
+			assert{not defender.nil?}
+
+			attacker.hlJobMode[:fightTarget]=defender
+			if not defender.hlJobMode.member?(:fightTarget)
+				defender.hlJobMode[:fightTarget]=attacker
+			end
+
+			defenders.delete(defender)
+
+			defenders=menGroup[:defender].dup if defenders.length==0
+		}
+		menGroup[:defender].each{|defender|
+			if not defender.hlJobMode.member?(:fightTarget)
+				# assign remaining defenders to attackers
+				attacker=menGroup[:attacker].min{|a,b|(a.getPos2D-defender.getPos2D).length<=>(b.getPos2D-defender.getPos2D).length}
+				defender.hlJobMode[:fightTarget]=attacker
+			end
+		}
+		@inited=true
+	end
+
+
+end
+
+module HLJob_Fight
+	# needed: hero,target, undefeatedMen
+
+	attr_reader :fightType, :fightData, :won
+
+	def fight_enter
+
+		targetHadFightData=target.hlJobMode[:fightData].nil?
+		
+		puts "fightData: #{target.hlJobMode[:fightData]}"
+		checkForFightData
+		if targetHadFightData
+			puts "NOT YET INITED #{self} hero:#{hero} target:#{target}"
+			target.newHLDefendJob(hero)
+		end
+		#@fightData.init
+		assignAllJobs
+	end
+
+	def fight_assign(man)
+		if man.is_a?(AntHouse)
+			man.newRestJob(20)
+			return
+		end
+
+		if man.hlJobMode[:defeated]
+			# FIXME:send away
+			# FIXME: maybe flee ?
+			if hero.is_a?(AntHouse)
+				if man.hlJobMode[:homing]
+					man.standStill
+				else
+					man.hlJobMode[:homing]
+					man.walkTo(hero.getPos2D)
+				end
+			else
+				# FIXME
+			end
+			man.hlJobMode[:defeated]=true
+			man.hlJobMode.delete(:fighting)
+		else
+			opponent=@fightData.getNewOpponent(man,self)
+			if opponent.nil?
+				# won
+				@won=true
+			else
+				man.hlJobMode[:fightTarget]=opponent
+				man.newFightJob(0,man.hlJobMode[:fightTarget])
+			end
+		end
+	end
+
+	def fight_leave
+		if lost
+			@fightData.removeLost(self)
+		else
+			@fightData.remove(self)
+		end
+		@fightData=nil
+		@fightType=nil
+		hero.hlJobMode.delete(:fightType)
+		hero.hlJobMode.delete(:fightData)
+
+		allMen.each{|man|
+			man.hlJobMode.delete(:defeated)
+			man.hlJobMode.delete(:fighting)
+			man.hlJobMode.delete(:homing)
+		}
+	end
+
+	def fight_ready
+		if won 
+			eventWon(target)
+			return true
+		elsif lost
+			eventLost(target)
+			return true
+		end
+		return false
+	end
+
+	def lost
+		(not @won) and undefeatedMen.length==0
+	end
+
+	def undefeatedMen
+		allMen.select{|man|man.hlJobMode[:defeated].nil?}
+	end
+
+	private
+	# return true if fightData already exists
+	def checkForFightData
+		if target.hlJobMode[:fightData]
+			@fightData=target.hlJobMode[:fightData]
+			@fightData.add(self)
+			@fightType=@fightData.getFightType(self)
+			return true
+		else
+			@fightData=HLJob_FightData.new(self)
+			@fightType=:attacker
+		end
+		puts "assigned fightData!"
+		hero.hlJobMode[:fightData]=@fightData # store so that it's avaiable above
+	end
+	def assignAllJobs
+		# FIXME:assign a fight-job to every member (undefeatedMen)
+
+		undefeatedMen.each{|man|
+			assert{not man.hlJobMode[:fightTarget].nil?}
+			man.newFightJob(0,man.hlJobMode[:fightTarget])
+			# FIXME: check if morale is high enough
+			man.hlJobMode.delete(:defeated)
+			man.hlJobMode[:fighting]=true
+		}
+	end
+
+
+end
+

Modified: antargis/trunk/ruby/ant_hljobs.rb
===================================================================
--- antargis/trunk/ruby/ant_hljobs.rb	2007-03-21 19:31:00 UTC (rev 1062)
+++ antargis/trunk/ruby/ant_hljobs.rb	2007-03-25 16:13:32 UTC (rev 1063)
@@ -1117,4 +1117,4 @@
 	return false
 end
 
-#require 'ant_new_hljobs.rb'
\ No newline at end of file
+require 'ant_new_hljobs.rb'
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_inventory.rb
===================================================================
--- antargis/trunk/ruby/ant_inventory.rb	2007-03-21 19:31:00 UTC (rev 1062)
+++ antargis/trunk/ruby/ant_inventory.rb	2007-03-25 16:13:32 UTC (rev 1063)
@@ -59,28 +59,34 @@
 	end
 
 	def update(e)
+		trace
 		if @inspect==e
+			trace
 			updateInspection
 		end
 	end
 private
 	def checkFriend
+		trace
 		if @inspect.nil?
 			return
 		end
 		friend=(@inspect.getPlayer==getMap.getPlayer)
 		enemy=(not friend)
+		puts "friend #{friend}"
 		getChild("friend_true").setVisible(friend)
 		getChild("friend_false").setVisible(enemy)
 		getChild("enemy_true").setVisible(enemy)
 		getChild("enemy_false").setVisible(friend)
 	end
 	def checkButtons
+		trace	
 		my=(@inspect.getPlayer==getMap.getPlayer and @inspect!=$app.hero)
 		
+		#myok=my # reenable other options when under attack
 		myok=(my and (not @inspect.underAttack))
 
-			
+		puts "my #{my} myok #{myok}"
 		getChild("doRecruit").setVisible(((not my) or (not @inspect.underAttack)))
 		getChild("doRecruit").setEnabled(myok)
 		getChild("doTakeFood").setEnabled(myok)
@@ -123,7 +129,9 @@
 		end
 	end
 	def updateInspection
+		trace
 		if @inspect then
+			trace
 			checkButtons
 			checkFriend
 			res=@inspect.resource.getAll
@@ -157,7 +165,9 @@
 		@@inventory.inspectEntity(entity) if @@inventory
 	end
 	def AntInventory.update(entity)
+		trace
 		@@inventory.update(entity) if @@inventory
+		trace
 	end
 	def AntInventory.resetPointer
 		@@inventory=nil

Modified: antargis/trunk/ruby/ant_local.rb
===================================================================
--- antargis/trunk/ruby/ant_local.rb	2007-03-21 19:31:00 UTC (rev 1062)
+++ antargis/trunk/ruby/ant_local.rb	2007-03-25 16:13:32 UTC (rev 1063)
@@ -34,9 +34,11 @@
 		# windows - try estimating thruogh "Program Files"-dir name
 		known={"Programme"=>"de",
 		 "Archivos de programa"=>"es"}
-		n=$ENV["CommonProgramFiles"].split("\\")[1]
-		if known[n]
-			return known[n]
+		if $ENV.has_key?("CommonProgramFiles")
+			n=$ENV["CommonProgramFiles"].split("\\")[1]
+			if known[n]
+				return known[n]
+			end
 		end
 		return "en"
 	end

Modified: antargis/trunk/ruby/ant_man.rb
===================================================================
--- antargis/trunk/ruby/ant_man.rb	2007-03-21 19:31:00 UTC (rev 1062)
+++ antargis/trunk/ruby/ant_man.rb	2007-03-25 16:13:32 UTC (rev 1063)
@@ -115,8 +115,12 @@
 	end	
 
 	def eventHaveDefeated(e)
-		puts "#{getName} has defeated #{e.getName}"
-		@boss.eventHaveDefeated(e)
+		if newHLJobs
+			eventNoJob
+		else
+			puts "#{getName} has defeated #{e.getName}"
+			@boss.eventHaveDefeated(e)
+		end
 	end
 
 	def getPlayer

Modified: antargis/trunk/ruby/ant_new_hljobs.rb
===================================================================
--- antargis/trunk/ruby/ant_new_hljobs.rb	2007-03-21 19:31:00 UTC (rev 1062)
+++ antargis/trunk/ruby/ant_new_hljobs.rb	2007-03-25 16:13:32 UTC (rev 1063)
@@ -15,7 +15,7 @@
 # 
 
 def newHLJobs
-	return false
+	return true
 end
 
 # 
@@ -198,6 +198,7 @@
 		@target=target
 		if defend
 			@state=:Fight
+			@workflow=[]
 			#trace
 		else
 			@state=:FormatWalk
@@ -215,7 +216,13 @@
 		"data/gui/sword.png"
 	end
 
+	def eventWon(opponent)
+	end
+	def eventLost(opponent)
+		hero.setOwner(opponent) #.getPlayer)
+	end
 
+
 end
 
 # rename and replace old hl-jobs

Added: antargis/trunk/ruby/ant_to_xml.rb
===================================================================
--- antargis/trunk/ruby/ant_to_xml.rb	2007-03-21 19:31:00 UTC (rev 1062)
+++ antargis/trunk/ruby/ant_to_xml.rb	2007-03-25 16:13:32 UTC (rev 1063)
@@ -0,0 +1,172 @@
+require 'libantargis.so'
+include Libantargis
+
+# def addToXmlMarshal
+# 	puts caller
+# 	exit
+# 	XmlMarshal.addClass(caller)
+# end
+# 
+# class Integer
+# 	addToXmlMarshal
+# 
+# 	def to_xml(parentNode,myName)
+# 		n=parentNode.addChild("Integer")
+# 		n.set("name",myName)
+# 		n.set("value",to_s)
+# 		n
+# 	end
+# 	def from_xml(node)
+# 		self=node.get("value").to_i
+# 	end
+# end
+# 
+# class Float
+# 	def to_xml(parentNode,myName)
+# 		n=parentNode.addChild("Integer")
+# 		n.set("name",myName)
+# 		n.set("value",to_s)
+# 		n
+# 	end
+# 	def from_xml(node)
+# 		self=node.get("value").to_f
+# 	end
+# end
+# 
+# 
+# class String
+# 	def to_xml(parentNode,myName)
+# 		n=parentNode.addChild("String")
+# 		n.set("name",myName)
+# 		n.set("value",self)
+# 		n
+# 	end
+# 
+# 	def from_xml(node)
+# 		self=node.get("value")
+# 	end
+# end
+
+# class Array
+# 	def to_xml(parentNode,myName)
+# 		n=parentNode.addChild("String")
+# 		n.set("name",myName)
+# 		n.set("value",self)
+# 		n
+# 	end
+# 
+# 	def from_xml(node)
+# 		self=node.get("value")
+# 	end
+# end
+
+
+
+class XmlMarshal
+	@@classes=[]
+	
+	def XmlMarshal.dump(v,node)
+		node.set("type",v.class.to_s)
+		if v.class.method_defined?(:to_xml)
+			v.to_xml(node,"")
+		else
+			case v
+				when Numeric,String
+					node.set("value",v.to_s)
+				when Array
+					v.each{|i|
+						n=node.addChild("element")
+						XmlMarshal.dump(i,n)
+					}
+				when Hash
+					v.each{|a,b|
+						p=node.addChild("pair")
+						k=p.addChild("key")
+						m=p.addChild("value")
+						XmlMarshal.dump(a,k)
+						XmlMarshal.dump(b,m)
+					}
+			end
+		end
+	end
+	def XmlMarshal.load(node)
+		v=nil
+		type=node.get("type")
+		cl=ObjectSpace.const_get(type)
+		if cl.method_defined?(:from_xml)
+			v=cl.from_xml(node)
+		else
+			case type
+				when "Fixnum","Bignum"
+					v=node.get("value").to_i
+				when "Float"
+					v=node.get("value").to_f
+				when "String"
+					v=node.get("value").to_s
+				when "Hash"
+					puts ":"+type
+					v={}
+					node.getChildren("pair").each{|p|
+						ks=p.getChildren("key")
+						vs=p.getChildren("value")
+						if ks.length==1 and vs.length==1
+							k=XmlMarshal.load(ks[0])
+							m=XmlMarshal.load(vs[0])
+							v[k]=m
+						end
+						
+					}
+				when "Array"
+					v=[]
+					node.getChildren("element").each{|e|
+						m=XmlMarshal.load(e)
+						v.push(m)
+					}
+			end
+		end
+		v
+	end
+end
+
+
+def printDbgMy(v)
+	case v
+		when String
+			'"'+v+'"'
+		when Numeric
+			v.to_s
+		when Array
+			"["+v.collect{|i|printDbgMy(i)}.join(",")+"]"
+		when Hash
+			"{"+v.collect{|k,v|printDbgMy(k)+"=>"+printDbgMy(v)}.join(",")+"}"
+	end
+end
+
+def printDbg(v)
+	puts printDbgMy(v)
+end
+
+def test
+	doc=Document.new
+
+	root=doc.root
+	
+	root.setName("root_a")
+	a={"a"=>[1,2,3],"huhu"=>["hallo",2.222]}
+
+	XmlMarshal.dump(a,root)
+
+
+	b=XmlMarshal.load(root)
+
+
+	puts root.toString
+
+
+	#puts b
+	printDbg(a)
+	printDbg(b)
+
+end
+
+#test
\ No newline at end of file

Modified: antargis/trunk/src/path.cc
===================================================================
--- antargis/trunk/src/path.cc	2007-03-21 19:31:00 UTC (rev 1062)
+++ antargis/trunk/src/path.cc	2007-03-25 16:13:32 UTC (rev 1063)
@@ -459,7 +459,7 @@
 {
   size_t m=(size_t)(mNodes.size()*(1.0-amount));
 
-  m=std::max(m,2U);
+  m=std::max((unsigned int)m,2U);
 
   while(mNodes.size()>m)
     {



From davidkamphausen at mail.berlios.de  Sun Mar 25 18:18:21 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 25 Mar 2007 18:18:21 +0200
Subject: [Antargis-svn] r1064 - website/contact
Message-ID: <200703251618.l2PGILx9023842@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-25 18:18:21 +0200 (Sun, 25 Mar 2007)
New Revision: 1064

Modified:
   website/contact/view.thtml
Log:
* contact changed


Modified: website/contact/view.thtml
===================================================================
--- website/contact/view.thtml	2007-03-25 16:13:32 UTC (rev 1063)
+++ website/contact/view.thtml	2007-03-25 16:18:21 UTC (rev 1064)
@@ -1,8 +1,15 @@
 <h1>Contact</h1>
 	
-	
-<h3>Please contact us per mailing-list:</h3>
+<h3>The first address is out forum:</h3>
 <p>
+<a href='http://antargis.berlios.de/phpBB2/'>http://antargis.berlios.de/phpBB2/</a>
+</p>
+<p>
+If this is down or something unlikely happened to it, then...	
+
+
+<h3>please contact us per mailing-list:</h3>
+<p>
 	<a href='mailto:antargis-dev at lists.berlios.de'>antargis-dev at lists.berlios.de</a>
 </p>
 <p>



From davidkamphausen at mail.berlios.de  Sun Mar 25 18:19:43 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 25 Mar 2007 18:19:43 +0200
Subject: [Antargis-svn] r1065 - website/contact
Message-ID: <200703251619.l2PGJhjX024047@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-25 18:19:43 +0200 (Sun, 25 Mar 2007)
New Revision: 1065

Modified:
   website/contact/view.thtml
Log:
* contact


Modified: website/contact/view.thtml
===================================================================
--- website/contact/view.thtml	2007-03-25 16:18:21 UTC (rev 1064)
+++ website/contact/view.thtml	2007-03-25 16:19:43 UTC (rev 1065)
@@ -1,6 +1,6 @@
 <h1>Contact</h1>
 	
-<h3>The first address is out forum:</h3>
+<h3>The first address for contacting us is our forum:</h3>
 <p>
 <a href='http://antargis.berlios.de/phpBB2/'>http://antargis.berlios.de/phpBB2/</a>
 </p>



From davidkamphausen at mail.berlios.de  Sun Mar 25 18:25:32 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 25 Mar 2007 18:25:32 +0200
Subject: [Antargis-svn] r1066 - in website: config start
Message-ID: <200703251625.l2PGPWa3024395@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-25 18:25:31 +0200 (Sun, 25 Mar 2007)
New Revision: 1066

Modified:
   website/config/style.css
   website/start/view.thtml
Log:
* layout changes


Modified: website/config/style.css
===================================================================
--- website/config/style.css	2007-03-25 16:19:43 UTC (rev 1065)
+++ website/config/style.css	2007-03-25 16:25:31 UTC (rev 1066)
@@ -290,6 +290,13 @@
 	margin-top:40px;
 }
 
+.helpwanted
+{
+	border-style:ridge;
+	border-width:2px;
+	border-color:#773300; /*bd6c04;*/
+}
+
 hr
 {
 	border-top:1px solid gray;

Modified: website/start/view.thtml
===================================================================
--- website/start/view.thtml	2007-03-25 16:19:43 UTC (rev 1065)
+++ website/start/view.thtml	2007-03-25 16:25:31 UTC (rev 1066)
@@ -32,7 +32,7 @@
 	<a href='index.php?page=news'>More news </a>
 </div>
 
-<div class='infos'>
+<div class='infos helpwanted'>
 	<h3>Help wanted</h3>
 	<p>
 		If you are an artist or a developer and have some free time, then <a href='http://antargis.berlios.de/phpBB2/viewtopic.php?t=3'>join us</a> in creating a great game!



From davidkamphausen at mail.berlios.de  Sun Mar 25 18:27:57 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 25 Mar 2007 18:27:57 +0200
Subject: [Antargis-svn] r1067 - website/config
Message-ID: <200703251627.l2PGRv5C024578@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-25 18:27:57 +0200 (Sun, 25 Mar 2007)
New Revision: 1067

Modified:
   website/config/style.css
Log:
* changes


Modified: website/config/style.css
===================================================================
--- website/config/style.css	2007-03-25 16:25:31 UTC (rev 1066)
+++ website/config/style.css	2007-03-25 16:27:57 UTC (rev 1067)
@@ -294,7 +294,9 @@
 {
 	border-style:ridge;
 	border-width:2px;
-	border-color:#773300; /*bd6c04;*/
+	border-color:#773300;
+	width:20em;
+	background-color:#fad68e;
 }
 
 hr



From davidkamphausen at mail.berlios.de  Sun Mar 25 18:28:54 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 25 Mar 2007 18:28:54 +0200
Subject: [Antargis-svn] r1068 - website/config
Message-ID: <200703251628.l2PGSsTL024683@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-25 18:28:54 +0200 (Sun, 25 Mar 2007)
New Revision: 1068

Modified:
   website/config/style.css
Log:
M    config/style.css


Modified: website/config/style.css
===================================================================
--- website/config/style.css	2007-03-25 16:27:57 UTC (rev 1067)
+++ website/config/style.css	2007-03-25 16:28:54 UTC (rev 1068)
@@ -295,8 +295,8 @@
 	border-style:ridge;
 	border-width:2px;
 	border-color:#773300;
-	width:20em;
-	background-color:#fad68e;
+	width:16em;
+	background-color:#faefd7;
 }
 
 hr



From davidkamphausen at mail.berlios.de  Mon Mar 26 21:28:16 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Mon, 26 Mar 2007 21:28:16 +0200
Subject: [Antargis-svn] r1069 - in antargis/trunk: gui/src ruby
Message-ID: <200703261928.l2QJSGsO031669@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-03-26 21:28:15 +0200 (Mon, 26 Mar 2007)
New Revision: 1069

Modified:
   antargis/trunk/gui/src/ag_application.cc
   antargis/trunk/gui/src/ag_debug.cc
   antargis/trunk/gui/src/ag_widget.cc
   antargis/trunk/gui/src/ag_widget.h
   antargis/trunk/ruby/ant_hljobs.rb
   antargis/trunk/ruby/ant_inventory.rb
   antargis/trunk/ruby/ant_new_hljobs.rb
Log:
* some bug-fixes with lazy-drawing


Modified: antargis/trunk/gui/src/ag_application.cc
===================================================================
--- antargis/trunk/gui/src/ag_application.cc	2007-03-25 16:28:54 UTC (rev 1068)
+++ antargis/trunk/gui/src/ag_application.cc	2007-03-26 19:28:15 UTC (rev 1069)
@@ -305,11 +305,11 @@
 
   if(mainWidget)
     {
-      mainWidget->prepareDraw();
+      mainWidget->prepareDrawAll();
       mainWidget->useTexturesRecursive();
     }
   if(mOverlay)
-    mOverlay->prepareDraw();
+    mOverlay->prepareDrawAll();
 }  
 
 

Modified: antargis/trunk/gui/src/ag_debug.cc
===================================================================
--- antargis/trunk/gui/src/ag_debug.cc	2007-03-25 16:28:54 UTC (rev 1068)
+++ antargis/trunk/gui/src/ag_debug.cc	2007-03-26 19:28:15 UTC (rev 1069)
@@ -91,14 +91,14 @@
   indent();
   gDebugIndex++;
 
-  dbout(2,"start of:"<<c<<"("<<gDebugIndex<<")"<<std::endl);
+  debugout_checked(2,"start of:"<<c<<"("<<gDebugIndex<<")"<<std::endl);
   d++;
 }
 AGEXPORT D::~D()
 {
   d--;
   indent();
-  dbout(2,"end   of:"<<m<<std::endl);
+  debugout_checked(2,"end   of:"<<m<<std::endl);
 }
 void D::indent()
 {

Modified: antargis/trunk/gui/src/ag_widget.cc
===================================================================
--- antargis/trunk/gui/src/ag_widget.cc	2007-03-25 16:28:54 UTC (rev 1068)
+++ antargis/trunk/gui/src/ag_widget.cc	2007-03-26 19:28:15 UTC (rev 1069)
@@ -111,7 +111,7 @@
 	{
 	  if(getAllWidgets()->find(getParent())==getAllWidgets()->end())
 	    {
-	      cdebug("WARNING:Error in ~AGWidget!!!");
+	      dbout(5000,"WARNING:Error in ~AGWidget!!!");
 	    }
 	  else
 	    getParent()->eventChildrenDeleted(this);
@@ -169,7 +169,7 @@
 	{
 	  if(!(*i)->mRubyObject) // don't delete ruby-objects - they get deleted by garbage collection
 	    {
-	      cdebug("type:"<<typeid(**i).name());
+	      dbout(5000,"type:"<<typeid(**i).name());
 	      delete *i;
 	    }
 	}
@@ -309,7 +309,6 @@
 
       if(mButtonDown)
 	{
-	  //	  TRACE;
 	  AGVector2 v=e->getMousePosition()-mOldMousePos;
 	  e->setVector(v);
 	  eventDragBy(e,v) || sigDragBy(e);
@@ -522,7 +521,9 @@
 void AGWidget::setVisible(bool v)
 {
   if(mVisible!=v)
-    queryRedraw();
+    {
+      queryRedraw();
+    }
   mVisible=v;
 }
 
@@ -611,14 +612,14 @@
     mParent->gainCompleteFocus(this);
   if(pWidget)
     {
-      //      cdebug(mChildren.size());
+      //      dbout(5000,mChildren.size());
       std::list<AGWidget*>::iterator i=std::find(mChildren.begin(),mChildren.end(),pWidget);
       if(i!=mChildren.end())
 	{
 	  mChildren.erase(i);
 	  mChildren.push_front(pWidget);
 	}
-      //      cdebug(mChildren.size());
+      //      dbout(5000,mChildren.size());
     }
 #endif
 }
@@ -628,7 +629,7 @@
 #ifdef FOCUS_BY_SORT
   if(pWidget)
     {
-      //      cdebug(mChildren.size());
+      //      dbout(5000,mChildren.size());
       std::list<AGWidget*>::iterator i=std::find(mChildren.begin(),mChildren.end(),pWidget);
       if(i!=mChildren.end())
 	{
@@ -641,7 +642,7 @@
 	  pWidget->eventGotFocus();
 
 	}
-      //      cdebug(mChildren.size());
+      //      dbout(5000,mChildren.size());
     }
   else if(mParent)
     {
@@ -662,7 +663,6 @@
 
 void AGWidget::gainFocusDown(AGWidget *pWidget)
 {
-  //  CTRACE;
   std::list<AGWidget*>::iterator i;
   i=std::find(mChildren.begin(),mChildren.end(),pWidget);
   if(i!=mChildren.end())
@@ -700,14 +700,13 @@
     {
       if(mFocus!=*mChildren.begin())
 	{
-	  //	  TRACE;
 	  std::list<AGWidget*>::iterator i;
 	  
 	  i=std::find(mChildren.begin(),mChildren.end(),mFocus);
 	  // delete children and set to front 
 	  mChildren.erase(i);
 	  mChildren.push_front(mFocus);
-	  //	  cdebug("mchildren #:"<<mChildren.size());
+	  //	  dbout(5000,"mchildren #:"<<mChildren.size());
 	}
     }
 }
@@ -828,6 +827,8 @@
 
 bool AGWidget::checkRedraw() const
 {
+  if(!mVisible)
+    return false;
   if(redraw())
     return true;
   for(std::list<AGWidget*>::const_iterator i=mChildren.begin();i!=mChildren.end();++i)
@@ -836,7 +837,19 @@
   return false;
 }
 
+void AGWidget::prepareDrawAll()
+{
+  if(!mVisible)
+    return;
 
+  for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();++i)
+    (*i)->prepareDrawAll();
+
+  prepareDraw();
+  
+}
+
+
 void AGWidget::prepareDraw()
 {
   if(!mVisible)
@@ -846,8 +859,6 @@
     {
       if(checkRedraw() || !mCache->hasTexture())
 	{
-	  for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();++i)
-	    (*i)->prepareDraw();
 	  mCache->clearContent();
 
 	  AGPainter p(*mCache);
@@ -856,7 +867,7 @@
 	    draw(p);
 	  
 	  std::list<AGWidget*>::reverse_iterator i=mChildren.rbegin(); // draw from back to front
-	  
+
 	  for(;i!=mChildren.rend();i++)
 	    (*i)->drawAll(p);
 
@@ -864,18 +875,17 @@
 	    draw(p);
 
 	  drawAfter(p);
-	  mCacheTouched=false;
+
 	  setDrawn();
 
 	  if(mParent)
-	    mParent->queryRedraw();
+	    {
+	      mParent->queryRedraw();
+	    }
+
+	  assert(checkRedraw()==false);
 	}
     }
-  else
-    {
-      for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();++i)
-	(*i)->prepareDraw();
-    }
 }
 void AGWidget::setCaching(bool pEnable)
 {
@@ -898,6 +908,9 @@
 
 void AGWidget::setDrawn()
 {
+  if(!mVisible)
+    return;
+
   mCacheTouched=false;
   for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();++i)
     (*i)->setDrawn();

Modified: antargis/trunk/gui/src/ag_widget.h
===================================================================
--- antargis/trunk/gui/src/ag_widget.h	2007-03-25 16:28:54 UTC (rev 1068)
+++ antargis/trunk/gui/src/ag_widget.h	2007-03-26 19:28:15 UTC (rev 1069)
@@ -150,6 +150,9 @@
   // Functions for caching appearance
   virtual bool redraw() const;
   virtual void prepareDraw();
+
+  void prepareDrawAll();
+
   void setCaching(bool pEnable);
   bool checkRedraw() const;
   void setDrawn();

Modified: antargis/trunk/ruby/ant_hljobs.rb
===================================================================
--- antargis/trunk/ruby/ant_hljobs.rb	2007-03-25 16:28:54 UTC (rev 1068)
+++ antargis/trunk/ruby/ant_hljobs.rb	2007-03-26 19:28:15 UTC (rev 1069)
@@ -1117,4 +1117,5 @@
 	return false
 end
 
-require 'ant_new_hljobs.rb'
\ No newline at end of file
+#require 'ant_new_hljobs.rb'
+

Modified: antargis/trunk/ruby/ant_inventory.rb
===================================================================
--- antargis/trunk/ruby/ant_inventory.rb	2007-03-25 16:28:54 UTC (rev 1068)
+++ antargis/trunk/ruby/ant_inventory.rb	2007-03-26 19:28:15 UTC (rev 1069)
@@ -48,15 +48,15 @@
 		getChild("InvBar").setHero(e)
 		updateInspection
 	end
-	def prepareDraw
-		#return
-		checkFriend
-		# FIXME
-		if false
-			updateInspection
-		end
-		super
-	end
+# 	def prepareDraw
+# 		#return
+# 		# FIXME
+# 		if false
+# 			checkFriend
+# 			updateInspection
+# 		end
+# 		super
+# 	end
 
 	def update(e)
 		trace
@@ -65,9 +65,14 @@
 			updateInspection
 		end
 	end
+
+	def draw(p)
+		trace
+		super
+	end
 private
 	def checkFriend
-		trace
+		#trace
 		if @inspect.nil?
 			return
 		end

Modified: antargis/trunk/ruby/ant_new_hljobs.rb
===================================================================
--- antargis/trunk/ruby/ant_new_hljobs.rb	2007-03-25 16:28:54 UTC (rev 1068)
+++ antargis/trunk/ruby/ant_new_hljobs.rb	2007-03-26 19:28:15 UTC (rev 1069)
@@ -219,6 +219,7 @@
 	def eventWon(opponent)
 	end
 	def eventLost(opponent)
+		@finished=true
 		hero.setOwner(opponent) #.getPlayer)
 	end
 



