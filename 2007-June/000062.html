<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Antargis-svn] r1105 - in antargis/branches/rant: build ext	ext/3dengine ext/basic ext/game ext/gui ext/math ext/sound	ext/video ruby ruby/gui
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/antargis-svn/2007-June/index.html" >
   <LINK REL="made" HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1105%20-%20in%20antargis/branches/rant%3A%20build%20ext%0A%09ext/3dengine%20ext/basic%20ext/game%20ext/gui%20ext/math%20ext/sound%0A%09ext/video%20ruby%20ruby/gui&In-Reply-To=%3C200706231507.l5NF7YET027632%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000061.html">
   <LINK REL="Next"  HREF="000063.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Antargis-svn] r1105 - in antargis/branches/rant: build ext	ext/3dengine ext/basic ext/game ext/gui ext/math ext/sound	ext/video ruby ruby/gui</H1>
    <B>davidkamphausen at BerliOS</B> 
    <A HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1105%20-%20in%20antargis/branches/rant%3A%20build%20ext%0A%09ext/3dengine%20ext/basic%20ext/game%20ext/gui%20ext/math%20ext/sound%0A%09ext/video%20ruby%20ruby/gui&In-Reply-To=%3C200706231507.l5NF7YET027632%40sheep.berlios.de%3E"
       TITLE="[Antargis-svn] r1105 - in antargis/branches/rant: build ext	ext/3dengine ext/basic ext/game ext/gui ext/math ext/sound	ext/video ruby ruby/gui">davidkamphausen at mail.berlios.de
       </A><BR>
    <I>Sat Jun 23 17:07:34 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000061.html">[Antargis-svn] r1104 - in antargis/branches/rant: . build	data/gui/layout ext/basic ext/game ext/gui ext/math ext/sound	ext/video ruby ruby/entities ruby/gui ruby/tests
</A></li>
        <LI>Next message: <A HREF="000063.html">[Antargis-svn] r1106 - in antargis/branches/rant/ext: 3dengine game	video
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#62">[ date ]</a>
              <a href="thread.html#62">[ thread ]</a>
              <a href="subject.html#62">[ subject ]</a>
              <a href="author.html#62">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: davidkamphausen
Date: 2007-06-23 17:07:27 +0200 (Sat, 23 Jun 2007)
New Revision: 1105

Added:
   antargis/branches/rant/build/cpp_parser.rb
   antargis/branches/rant/build/create_interface_new.rb
   antargis/branches/rant/ext/3dengine/
   antargis/branches/rant/ext/3dengine/ag_glsl.cc
   antargis/branches/rant/ext/3dengine/ag_glsl.h
   antargis/branches/rant/ext/3dengine/anim_mesh.cc
   antargis/branches/rant/ext/3dengine/anim_mesh.h
   antargis/branches/rant/ext/3dengine/anim_mesh_data.cc
   antargis/branches/rant/ext/3dengine/anim_mesh_data.h
   antargis/branches/rant/ext/3dengine/ant_camera.cc
   antargis/branches/rant/ext/3dengine/ant_camera.h
   antargis/branches/rant/ext/3dengine/ant_projection.cc
   antargis/branches/rant/ext/3dengine/ant_projection.h
   antargis/branches/rant/ext/3dengine/ant_renderer.cc
   antargis/branches/rant/ext/3dengine/ant_renderer.h
   antargis/branches/rant/ext/3dengine/glsl.cc
   antargis/branches/rant/ext/3dengine/glsl.h
   antargis/branches/rant/ext/3dengine/headers.hh
   antargis/branches/rant/ext/3dengine/init.cc
   antargis/branches/rant/ext/3dengine/mesh.cc
   antargis/branches/rant/ext/3dengine/mesh.h
   antargis/branches/rant/ext/3dengine/mesh_2d.cc
   antargis/branches/rant/ext/3dengine/mesh_2d.h
   antargis/branches/rant/ext/3dengine/mesh_2d_data.cc
   antargis/branches/rant/ext/3dengine/mesh_2d_data.h
   antargis/branches/rant/ext/3dengine/mesh_data.cc
   antargis/branches/rant/ext/3dengine/mesh_data.h
   antargis/branches/rant/ext/3dengine/mesh_optimizer.cc
   antargis/branches/rant/ext/3dengine/mesh_optimizer.h
   antargis/branches/rant/ext/3dengine/mesh_sort.cc
   antargis/branches/rant/ext/3dengine/mesh_sort.h
   antargis/branches/rant/ext/3dengine/quadtree.h
   antargis/branches/rant/ext/3dengine/scene.cc
   antargis/branches/rant/ext/3dengine/scene.h
   antargis/branches/rant/ext/3dengine/scene_2d.cc
   antargis/branches/rant/ext/3dengine/scene_2d.h
   antargis/branches/rant/ext/3dengine/scene_base.cc
   antargis/branches/rant/ext/3dengine/scene_base.h
   antargis/branches/rant/ext/3dengine/scenenode.cc
   antargis/branches/rant/ext/3dengine/scenenode.h
   antargis/branches/rant/ext/3dengine/templates.i
   antargis/branches/rant/ext/3dengine/vertex_array.cc
   antargis/branches/rant/ext/3dengine/vertex_array.h
   antargis/branches/rant/ext/basic/ag_messageobject.cc
   antargis/branches/rant/ext/basic/ag_messageobject.h
   antargis/branches/rant/ext/basic/ag_mutex.cc
   antargis/branches/rant/ext/basic/ag_mutex.h
   antargis/branches/rant/ext/game/ant_app.cc
   antargis/branches/rant/ext/game/ant_app.h
   antargis/branches/rant/ext/game/entity.cc
   antargis/branches/rant/ext/game/entity.h
   antargis/branches/rant/ext/game/entptr.cc
   antargis/branches/rant/ext/game/entptr.h
   antargis/branches/rant/ext/game/height_map.cc
   antargis/branches/rant/ext/game/height_map.h
   antargis/branches/rant/ext/game/heuristic.cc
   antargis/branches/rant/ext/game/heuristic.h
   antargis/branches/rant/ext/game/jobs.cc
   antargis/branches/rant/ext/game/jobs.h
   antargis/branches/rant/ext/game/map.cc
   antargis/branches/rant/ext/game/map.h
   antargis/branches/rant/ext/game/minimap.cc
   antargis/branches/rant/ext/game/minimap.h
   antargis/branches/rant/ext/game/resource.cc
   antargis/branches/rant/ext/game/resource.h
   antargis/branches/rant/ext/game/terrain.cc
   antargis/branches/rant/ext/game/terrain.h
   antargis/branches/rant/ext/game/water.cc
   antargis/branches/rant/ext/game/water.h
   antargis/branches/rant/ext/gui/ag_application.cc
   antargis/branches/rant/ext/gui/ag_application.h
   antargis/branches/rant/ext/gui/ag_background.cc
   antargis/branches/rant/ext/gui/ag_background.h
   antargis/branches/rant/ext/gui/ag_border.cc
   antargis/branches/rant/ext/gui/ag_border.h
   antargis/branches/rant/ext/gui/ag_button.cc
   antargis/branches/rant/ext/gui/ag_button.h
   antargis/branches/rant/ext/gui/ag_caption.cc
   antargis/branches/rant/ext/gui/ag_caption.h
   antargis/branches/rant/ext/gui/ag_checkbox.cc
   antargis/branches/rant/ext/gui/ag_checkbox.h
   antargis/branches/rant/ext/gui/ag_colorbutton.cc
   antargis/branches/rant/ext/gui/ag_colorbutton.h
   antargis/branches/rant/ext/gui/ag_combo.cc
   antargis/branches/rant/ext/gui/ag_combo.h
   antargis/branches/rant/ext/gui/ag_edit.cc
   antargis/branches/rant/ext/gui/ag_edit.h
   antargis/branches/rant/ext/gui/ag_frame.cc
   antargis/branches/rant/ext/gui/ag_frame.h
   antargis/branches/rant/ext/gui/ag_image.cc
   antargis/branches/rant/ext/gui/ag_image.h
   antargis/branches/rant/ext/gui/ag_layout.cc
   antargis/branches/rant/ext/gui/ag_layout.h
   antargis/branches/rant/ext/gui/ag_layoutcreators.cc
   antargis/branches/rant/ext/gui/ag_layoutfactory.cc
   antargis/branches/rant/ext/gui/ag_layoutfactory.h
   antargis/branches/rant/ext/gui/ag_listbox.cc
   antargis/branches/rant/ext/gui/ag_listbox.h
   antargis/branches/rant/ext/gui/ag_local.cc
   antargis/branches/rant/ext/gui/ag_local.h
   antargis/branches/rant/ext/gui/ag_menu.cc
   antargis/branches/rant/ext/gui/ag_menu.h
   antargis/branches/rant/ext/gui/ag_menuitem.cc
   antargis/branches/rant/ext/gui/ag_menuitem.h
   antargis/branches/rant/ext/gui/ag_radio.cc
   antargis/branches/rant/ext/gui/ag_radio.h
   antargis/branches/rant/ext/gui/ag_radiogroup.cc
   antargis/branches/rant/ext/gui/ag_radiogroup.h
   antargis/branches/rant/ext/gui/ag_screenwidget.cc
   antargis/branches/rant/ext/gui/ag_screenwidget.h
   antargis/branches/rant/ext/gui/ag_scroller.cc
   antargis/branches/rant/ext/gui/ag_scroller.h
   antargis/branches/rant/ext/gui/ag_table.cc
   antargis/branches/rant/ext/gui/ag_table.h
   antargis/branches/rant/ext/gui/ag_text.cc
   antargis/branches/rant/ext/gui/ag_text.h
   antargis/branches/rant/ext/gui/ag_theme.cc
   antargis/branches/rant/ext/gui/ag_theme.h
   antargis/branches/rant/ext/gui/ag_tooltip.cc
   antargis/branches/rant/ext/gui/ag_tooltip.h
   antargis/branches/rant/ext/gui/ag_widget.cc
   antargis/branches/rant/ext/gui/ag_widget.h
   antargis/branches/rant/ext/gui/ag_window.cc
   antargis/branches/rant/ext/gui/ag_window.h
   antargis/branches/rant/ext/math/ag_algebra.cc
   antargis/branches/rant/ext/math/ag_algebra.h
   antargis/branches/rant/ext/math/ant_frustum.cc
   antargis/branches/rant/ext/math/ant_frustum.h
   antargis/branches/rant/ext/sound/ag_mixer.cc
   antargis/branches/rant/ext/sound/ag_mixer.h
   antargis/branches/rant/ext/video/ag_clip.cc
   antargis/branches/rant/ext/video/ag_clip.h
   antargis/branches/rant/ext/video/ag_clip_painttarget.cc
   antargis/branches/rant/ext/video/ag_clip_painttarget.h
   antargis/branches/rant/ext/video/ag_painter.cc
   antargis/branches/rant/ext/video/ag_painter.h
   antargis/branches/rant/ext/video/ag_projection.cc
   antargis/branches/rant/ext/video/ag_projection.h
   antargis/branches/rant/ext/video/ag_sdlsurface.h
   antargis/branches/rant/ext/video/ag_texturecache.cc
   antargis/branches/rant/ext/video/ag_texturecache.h
   antargis/branches/rant/ruby/antargisgui.rb
   antargis/branches/rant/ruby/antargismath.rb
Modified:
   antargis/branches/rant/ext/basic/ag_main.cc
   antargis/branches/rant/ext/game/headers.hh
   antargis/branches/rant/ext/gui/headers.hh
   antargis/branches/rant/ext/video/ag_texture.cc
   antargis/branches/rant/ext/video/ag_vdebug.cc
   antargis/branches/rant/ext/video/ag_video.h
   antargis/branches/rant/ext/video/headers.hh
   antargis/branches/rant/ruby/ant_models.rb
   antargis/branches/rant/ruby/antargis.rb
   antargis/branches/rant/ruby/gui/ag_tools.rb
   antargis/branches/rant/ruby/map.rb
   antargis/branches/rant/ruby/view.rb
Log:
* added many many files


Added: antargis/branches/rant/build/cpp_parser.rb
===================================================================
--- antargis/branches/rant/build/cpp_parser.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/build/cpp_parser.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,45 @@
+#
+# simple c(++) parser
+
+class Parser
+	def initialize
+		@buf=&quot;&quot;
+		@lines=[]
+	end
+
+	def parse(content)
+		@buf=content
+		# first remove line-comments
+		@buf.gsub!(/\/\/[^\n]*\n/,&quot;&quot;)
+		# remove multi-line-comments
+		@buf.gsub!(/\/\*([^*]|\*[^\/])*\*\//,&quot;&quot;)
+
+		# remove preprocessor
+		@buf=@buf.split(&quot;\n&quot;).collect{|l|l.gsub(/^#.*/,&quot;&quot;)}.join(&quot;\n&quot;)
+
+		@buf.gsub!(&quot;virtual&quot;,&quot;&quot;)
+		@buf.gsub!(/(public|protected|private) *:/,&quot;&quot;)
+
+		@buf.gsub!(/ +/,&quot; &quot;)
+		@buf.gsub!(/\n+/,&quot;\n&quot;)
+
+# 		puts @buf
+# 		puts &quot;---&quot;
+
+
+ 		#@buf.scan(/[^{;]*(\{[^}]*\})?;/) {|r|
+ 		@buf.scan(/(([^{;]|\n)*\{[^}]*\};|[^{;]*;)/) {|r|
+ 			puts &quot;R:&quot;,r.join(&quot;||&quot;),r.class
+ 		}
+
+	end
+
+	def output
+		puts @buf
+	end
+end
+
+f=File.open(&quot;ext/gui/ag_messageobject.h&quot;,&quot;r&quot;)
+p=Parser.new
+p.parse(f.read)
+p.output
\ No newline at end of file

Added: antargis/branches/rant/build/create_interface_new.rb
===================================================================
--- antargis/branches/rant/build/create_interface_new.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/build/create_interface_new.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,592 @@
+#!/usr/bin/env ruby
+#
+# Copyright (c) 2005 by David Kamphausen. All rights reserved.
+#
+# create_interface.rb
+# by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+#
+# The &quot;Antargis&quot; project, including all files needed to compile it,
+# is free software; you can redistribute it and/or use it and/or modify it
+# under the terms of the GNU General Public License as published
+# by the Free Software Foundation; either version 2 of the License,
+# or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+#
+# You should have received a copy of the GNU General Public
+# License along with this program.
+#
+
+require 'build/interface_template.rb'
+require 'build/base_tools.rb'
+
+class MyInput
+	attr_reader :swigInput, :outputDir
+	def initialize
+		@outputDir=Dir.pwd # default
+		@swigInput=&quot;&quot;
+	
+
+		ARGV.each{|a|
+			case a
+				when /^-d=/
+					# in- and output dir
+					@outputDir=a[3..-1]
+				when /^-i=/
+					@swigInput=a[3..-1]
+				when /^-h/, /^--help/
+					@help=true
+					puts &quot;Arguments:&quot;
+					puts &quot; -h, --help     print this help&quot;
+					puts &quot; -d=&lt;DIR&gt;       define output-directory&quot;
+					puts &quot; -i=&lt;SWIGFILE&gt;  define SWIG-input-file (swig.h) - can be set multiple times&quot;
+			end
+		}
+
+		@swigInput=@swigInput.split(&quot;:&quot;)
+	end
+
+	def valid
+		@outputDir!=&quot;&quot; &amp;&amp; @help.nil?
+	end
+
+	def interfaceName
+		name=@outputDir+Dir.separator+&quot;interface.i&quot;
+		puts &quot;INTERFACENAME:&quot;,name
+		name
+	end
+
+	def moduleName
+		moduleName=makeLibName(@outputDir)
+	end
+	def headersName
+		@outputDir+Dir.separator+&quot;/headers.hh&quot;
+	end
+	def markerName
+		@outputDir+Dir.separator+&quot;marker.i&quot;
+	end
+end
+
+class MClass
+  def initialize(name,superClass)
+    @name=name
+    @superClass=superClass
+  end
+end
+
+class SimpleParser
+	@mclasses=[]
+	def initialize(files)
+	end
+	
+end
+
+def getDirs
+  files=`find ext -type d`.gsub(&quot;\r&quot;,&quot;&quot;).split(&quot;\n&quot;)
+end
+
+def getFiles(dir)
+	Dir[dir+Dir.separator+&quot;*.h&quot;].select{|f|not f=~/swig.h/} #-[dir+Dir.separator+&quot;swig.h&quot;]
+end
+
+def grepBool(filename,string)
+	File.open(filename).each_line{|l|return true if l=~/#{string}/}
+	false
+end
+
+def getSwigInterfaceFiles(files)
+	files.select{|f|
+		grepBool(f,&quot;INCLUDE_SWIG&quot;)
+	}
+end
+
+def getClasses
+end
+
+class ParsedClasses
+
+	attr_reader :deriveList
+
+	def initialize(files,allfiles)
+		@rubyClasses=[]
+		@files=files
+		loadAllDerivations(allfiles)
+		@myfiles=files
+		processDerivations
+		initLevels
+	end
+
+
+	def loadAllDerivations(allfiles)
+		@class2File={}
+		@deriveList={} # x=&gt;y :x is child of y
+
+		allfiles.each{|fn|
+			g=File.open(fn)
+			cn=&quot;&quot;
+			g.each{|a|
+				abak=a
+				a.gsub!(&quot;AGEXPORT&quot;,&quot;&quot;)
+				a.gsub!(&quot;EXPORT&quot;,&quot;&quot;)
+				
+				if a =~ /^class.*/ then
+					cn=a.gsub(&quot;class &quot;,&quot;&quot;).gsub(/:.*/,&quot;&quot;).gsub(&quot;\n&quot;,&quot;&quot;).gsub(&quot; &quot;,&quot;&quot;)
+					if cn=~/^[A-Z].*/
+						if a=~ /.*public.*/ then
+							pn=a.gsub(/.*public /,&quot;&quot;).gsub(&quot;\n&quot;,&quot;&quot;)
+							@deriveList[cn]=pn
+							@class2File[cn]=fn
+						elsif not a=~/;/ then
+							@deriveList[cn]=nil
+							@class2File[cn]=fn
+						end
+					end
+				end
+			
+			}
+		}
+		@classList=@class2File.keys
+	end
+
+	def processDerivations
+		@rubyClasses &lt;&lt; &quot;AGRubyObject&quot;
+		@classList.sort!.uniq!
+		
+		# check for children of AGWidget
+		changed=true
+		while changed do
+			changed=false
+			@deriveList.each {|x,y|
+				if @rubyClasses.member?(y) and not @rubyClasses.member?(x) then
+					@rubyClasses &lt;&lt; x
+					changed=true
+				end
+			}
+		end
+		puts &quot;-------------------------&quot;
+		puts &quot;CLASSLIST:&quot;
+		puts @classList
+
+		puts &quot;-------------------------&quot;
+		puts &quot;RUBY CLASSLIST:&quot;
+		puts @rubyClasses
+
+		puts &quot;-------------------------&quot;
+		puts &quot;DERIVATIONS:&quot;
+			@deriveList.each {|x,y|
+				puts &quot;#{x} #{y} #{@class2File[x]} &quot;
+			}
+		puts &quot;-------------------------&quot;
+		puts &quot;my ruby:&quot;
+		puts getMyRubyClasses
+		puts &quot;-------------------------&quot;
+	end
+
+	def initLevels
+		puts &quot;initLevels...&quot;
+		@levels={}
+		@levels[&quot;AGRubyObject&quot;]=0
+		changed=true
+		l=0
+		while changed
+			changed=false
+			@deriveList.each{|x,y|
+				if @levels[y]==l and @levels[x].nil?
+					@levels[x]=l+1
+					changed=true
+				end
+			}
+			l+=1
+		end
+
+		(0..l).each{|i|
+			@levels.each{|n,level|
+				if level==i
+					puts &quot;#{i} #{n}&quot;
+				end
+			}
+		}
+	#if false
+		puts &quot;-------------&quot;		
+		# give classes with no parent next level
+		@classList.each{|c|
+			if @levels[c].nil?
+				if (not @deriveList.keys.member?(c)) 
+					@levels[c]=l
+				end
+			end
+		}
+
+		# repeat process
+		changed=true
+		while changed
+			changed=false
+			@deriveList.each{|x,y|
+				if @levels[y]==l and @levels[x].nil?
+					@levels[x]=l+1
+					changed=true
+				end
+			}
+			l+=1
+		end
+
+		puts &quot;-------------&quot;		
+		# give classes with no parent next level
+		@classList.each{|c|
+			if @levels[c].nil?
+				if (@deriveList[@deriveList[c]].nil?)
+					@levels[c]=l
+				end
+			end
+		}
+
+		# repeat process
+		changed=true
+		while changed
+			changed=false
+			@deriveList.each{|x,y|
+				if @levels[y]==l and @levels[x].nil?
+					@levels[x]=l+1
+					changed=true
+				end
+			}
+			l+=1
+		end
+
+#end
+		(0..l).each{|i|
+			@levels.each{|n,level|
+				if level==i
+					puts &quot;#{i} #{n}&quot;
+				end
+			}
+		}
+		@classList.each{|c|
+			if @levels[c].nil?
+				puts &quot;-- #{c}&quot;
+			end
+		}
+
+		puts &quot;initLevels...ok&quot;
+
+	end
+
+	# in correct order
+	def getFileList
+		files=[]
+		l=@levels.values.max
+		(0..l).each{|i|
+			@levels.each{|n,level|
+				if level==i and @class2File[n]
+					files &lt;&lt; @class2File[n]
+				end
+			}
+		}
+
+		puts &quot;getFileList:&quot;
+		puts files,files.class
+		puts &quot;---------&quot;
+
+		@classList.each{|c|
+			if @levels[c].nil? and @class2File[c]
+				files &lt;&lt; @class2File[c]
+			end
+		}
+
+		puts &quot;getFileList:&quot;
+		puts files,files.class
+		puts &quot;---------&quot;
+		files=files.select{|f|@myfiles.member?(f)}
+		addfiles=@files-files
+		files+=addfiles
+
+
+		puts &quot;getFileList:&quot;
+		puts files,files.class
+		puts &quot;---------&quot;
+		if files.length&gt;0
+			files.uniq!
+		end
+		puts files,files.class
+		puts &quot;---------&quot;
+		files
+	end
+
+
+	def getMyRubyClasses
+		@rubyClasses.select{|c|@myfiles.member?(@class2File[c])}
+	end
+	def getAllRubyClasses
+		@rubyClasses
+	end
+end
+
+
+def generateInterfaceFile(myInput,files,addfiles)
+	filename=myInput.interfaceName
+	puts &quot;filename:&quot;,filename
+	interfaceI=File.open(filename,&quot;w&quot;)
+	
+	
+	puts &quot;SWIGINPUTS:&quot;,myInput.swigInput,&quot;--------------&quot;
+	
+	interfaceI.puts interface_template(myInput.moduleName,files,myInput.swigInput,addfiles,myInput.outputDir)
+	
+	interfaceI.close
+	
+	filename=myInput.headersName
+	headersH=File.open(filename,&quot;w&quot;)
+	headersH.puts &quot;#ifndef __ANTARGIS_H__&quot;
+	headersH.puts &quot;#define __ANTARGIS_H__&quot;
+	headersH.puts addfiles.collect{|f|&quot;#include \&quot;#{f}\&quot;&quot;}.join(&quot;\n&quot;)
+	headersH.puts files.collect{|f|&quot;#include \&quot;#{f}\&quot;&quot;}.join(&quot;\n&quot;)
+	headersH.puts &quot;#ifdef SWIG&quot;
+	headersH.puts files.collect{|f|&quot;%include \&quot;#{f}\&quot;&quot;}.join(&quot;\n&quot;)
+	headersH.puts &quot;#endif&quot;
+	headersH.puts &quot;#endif&quot;
+	headersH.close
+end
+
+
+myInput=MyInput.new
+
+files=getSwigInterfaceFiles(getFiles(myInput.outputDir))
+
+parsedClasses=ParsedClasses.new(files,`find $(pwd) -name &quot;*.h&quot;|grep -v swig`.split(&quot;\n&quot;))
+files=parsedClasses.getFileList
+
+#exit
+
+puts &quot;GETFILES:&quot;,files,files.class
+
+puts files.join(&quot;|&quot;)
+
+addfiles=[]
+myInput.swigInput.each{|inDir|
+	pattern=getDir(inDir)+Dir.separator+&quot;*.h&quot;
+	puts &quot;PATTERN:&quot;,pattern
+	addfiles+=Dir[pattern].select{|f|not f=~/swig.h/}
+}
+
+generateInterfaceFile(myInput,files,addfiles)
+
+# old implementation
+
+
+classList=[]
+deriveList={} # x=&gt;y :x is child of y
+rubyClasses={} # all, which are derived from AGRubyObject
+class2File={}
+
+
+# take RubyObject as base for RubyObjects :-)
+# so simply search for classes deriveListd from this!
+
+files.each{|fn|
+	g=File.open(fn)
+	cn=&quot;&quot;
+	g.each{|a|
+		abak=a
+		a.gsub!(&quot;AGEXPORT&quot;,&quot;&quot;)
+		a.gsub!(&quot;EXPORT&quot;,&quot;&quot;)
+		
+		if a =~ /^class.*/ then
+			cn=a.gsub(&quot;class &quot;,&quot;&quot;).gsub(/[:;].*/,&quot;&quot;).gsub(/\n/,&quot;&quot;).gsub(&quot; &quot;,&quot;&quot;)
+			if cn=~/^[A-Z].*/
+				classList+=[cn]
+				if a=~ /.*public.*/ then
+					pn=a.gsub(/.*public /,&quot;&quot;).gsub(/\n/,&quot;&quot;)
+					deriveList[cn]=pn
+					rubyClasses[cn]=false
+					rubyClasses[pn]=false
+					class2File[cn]=fn
+				elsif not a=~/;/ then
+					deriveList[cn]=nil
+				end
+			end
+		end
+	
+	}
+}
+
+rubyClasses[&quot;AGRubyObject&quot;]=true
+
+classList.sort!.uniq!
+
+# check for children of AGWidget
+changed=true
+while changed do
+	changed=false
+	deriveList.each {|x,y|
+		if rubyClasses[y] and rubyClasses[x]==false then
+			rubyClasses[x]=true
+			changed=true
+		end
+	}
+end
+
+file=File.open(myInput.markerName,&quot;w&quot;)
+
+# ok, first marking is included
+parsedClasses.getMyRubyClasses.each {|x|
+	#if y then
+		file.puts &quot;%exception &quot;+x+&quot;::&quot;+x+&quot; {&quot;
+		file.puts &quot;	$action&quot;
+		file.puts &quot;	result-&gt;mRUBY=self;&quot;
+		file.puts &quot;#ifdef GCDEBUG&quot;
+		file.puts '     result-&gt;mObjName=typeid(*result).name();'
+		file.puts '     printf(&quot;%lx   %s\n&quot;,self,typeid(*result).name());'
+		file.puts &quot;#endif&quot;
+		file.puts &quot;	result-&gt;mRubyObject=true;&quot;
+		file.puts &quot;}&quot;
+		file.puts &quot;%markfunc &quot;+x+&quot; \&quot;general_markfunc\&quot;&quot;
+	#end
+}
+
+# calculate class-derivations
+derivations={}
+rubyClasses.each{|x,y|
+	derivations[x]=[]
+}
+deriveList.each{|x,y|
+	if not derivations[y]
+		derivations[y]=[]
+	end
+	derivations[y].push(x)
+}
+changed=true
+while changed
+	changed=false
+	derivations.each{|x,y|
+		y.each{|a|
+			if derivations[a]
+				old=derivations[x]
+				derivations[x]+=derivations[a]
+				derivations[x].sort!
+				derivations[x].uniq!
+				#puts x+&quot;:&quot;+old.length.to_s+&quot; &quot;+derivations[x].length.to_s
+				if old.length&lt;derivations[x].length
+					changed=true
+				end
+			end
+		}
+	}
+end
+
+# swig typemaps
+# so that always the lowest children in a derivation hierarchy is returned
+myRubyClasses=parsedClasses.getMyRubyClasses
+parsedClasses.deriveList.keys.each{|s|
+	if myRubyClasses.member?(s)
+		file.puts &quot;%typemap(out) #{s}*{&quot;
+		file.puts &quot; if($1)&quot;
+		file.puts &quot; {&quot;
+		file.puts &quot;   $result=AG_NewPointerObj($1,SWIGTYPE_p_#{s},0);&quot;
+		file.puts &quot; }&quot;
+		file.puts &quot;}&quot;
+
+		file.puts &quot;%typemap(directorin) #{s}*{&quot;
+		file.puts &quot; if($1)&quot;
+		file.puts &quot; {&quot;
+		file.puts &quot;   $input=AG_NewPointerObj($1,SWIGTYPE_p_#{s},0);&quot;
+		file.puts &quot; }&quot;
+		file.puts &quot;}&quot;
+
+	end
+}
+# normal typemaps
+classList.each{|c|
+	file.puts &quot;%typemap(directorout) #{c} {&quot;
+	file.puts &quot; #{c} *b;&quot;
+	file.puts &quot; Data_Get_Struct($input,#{c},b);&quot;
+	file.puts &quot; $result=*b;&quot;
+	file.puts &quot;}&quot;
+}
+
+file.puts &quot;%typemap(directorout) Uint8 {&quot;
+file.puts &quot; $result=NUM2INT($input);&quot;
+file.puts &quot;}&quot;
+
+rubyClasses=parsedClasses.getMyRubyClasses
+allRubyClasses=parsedClasses.getAllRubyClasses
+
+myClasses=[]
+
+deriveList.each{|b,a|
+	if rubyClasses.member?(b) || b==&quot;AGRubyObject&quot;
+		myClasses &lt;&lt; b
+	end
+}
+
+myClasses=myClasses.sort.uniq
+
+puts &quot;rubyClasses:&quot;,rubyClasses
+puts &quot;myClasses:&quot;,myClasses
+
+file.puts &lt;&lt;EOT
+%{
+// cast-function map
+// it contains the mapping from parent-classes=&gt;dyn-cast-functions to child-classes
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;list&gt;
+#include &lt;iostream&gt;
+
+typedef swig_type_info*(*CastFunction)(void**);
+extern std::map&lt;std::string,std::list&lt;CastFunction&gt; &gt; agCastFunctions;
+%}
+EOT
+
+myClasses.each{|k|
+file.puts &lt;&lt;EOT	
+%{
+// try to cast from #{k} to one of its child classes (if they exist)
+static swig_type_info* #{k}_dynamic_cast(void **ptr)
+  {
+	  std::list&lt;CastFunction&gt; &amp;funcs=agCastFunctions[&quot;#{k}&quot;];
+    for(std::list&lt;CastFunction&gt;::iterator i=funcs.begin();i!=funcs.end();i++)
+      {
+         swig_type_info*t=(*i)(ptr);
+	       std::cout&lt;&lt;&quot;test:&quot;&lt;&lt;t&lt;&lt;std::endl;
+         if(t)
+           return t;
+      }
+   return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_#{k}, #{k}_dynamic_cast);
+EOT
+}
+
+deriveList.each{|b,a|
+	if rubyClasses.member?(b) and allRubyClasses.member?(a)
+		# for each pair generate a casting function and register it into agCastFunctions
+file.puts &lt;&lt;EOT
+%{
+swig_type_info* #{a}2#{b}cast(void **p)
+{
+        #{a}*a=(#{a}*)(*p);
+        #{b}*b=dynamic_cast&lt;#{b}*&gt;(a);
+				printf(&quot;TRY CAST #{a} 2 #{b} : %lx\\n&quot;,b);
+        if(b)
+        {
+                *p=(void*)b;
+                return SWIGTYPE_p_#{b};
+        }
+        return 0;
+}
+%}
+
+%insert(&quot;init&quot;) %{
+        agCastFunctions[&quot;#{a}&quot;].push_back(&amp;#{a}2#{b}cast);
+%}
+
+
+EOT
+	end
+}
+
+
+

Added: antargis/branches/rant/ext/3dengine/ag_glsl.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/ag_glsl.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ag_glsl.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,298 @@
+#include &quot;ag_glsl.h&quot;
+#include &quot;ag_vdebug.h&quot;
+#include &quot;ag_main.h&quot;
+//#include &quot;scene.h&quot;
+
+std::map&lt;std::string,AGVertexProgram*&gt; mVertexPrograms;
+std::map&lt;std::string,AGFragProgram*&gt; mFragPrograms;
+
+AGVertexProgram *getVertexProgram(const std::string &amp;pFile)
+{
+  std::map&lt;std::string,AGVertexProgram*&gt;::iterator i=mVertexPrograms.find(pFile);
+
+  if(i==mVertexPrograms.end())
+    {
+      AGVertexProgram *p=new AGVertexProgram(pFile);
+      mVertexPrograms[pFile]=p;
+      return p;
+    }
+  return i-&gt;second;
+}
+
+AGFragProgram *getFragProgram(const std::string &amp;pFile)
+{
+  std::map&lt;std::string,AGFragProgram*&gt;::iterator i=mFragPrograms.find(pFile);
+
+  if(i==mFragPrograms.end())
+    {
+      AGFragProgram *p=new AGFragProgram(pFile);
+      mFragPrograms[pFile]=p;
+      return p;
+    }
+  return i-&gt;second;
+}
+
+int GLSL_ok=-1;
+bool glslOk()
+{
+//  return false;
+  // do not check in each call, because this is slow!!!
+  if(GLSL_ok&lt;0)
+    {
+      GLeeInit();
+      GLSL_ok=(GLEE_ARB_vertex_shader &amp;&amp; GLEE_ARB_fragment_shader &amp;&amp; GLEE_ARB_shading_language_100);
+    }
+  
+  return GLSL_ok;
+}
+
+void printInfoLog(GLhandleARB obj)
+{
+    int infologLength = 0;
+    int charsWritten  = 0;
+    char *infoLog;
+
+        glGetObjectParameterivARB(obj, GL_OBJECT_INFO_LOG_LENGTH_ARB,
+                                         &amp;infologLength);
+
+    if (infologLength &gt; 0)
+    {
+      printf(&quot;GLSL ERROR:\n&quot;);
+        infoLog = (char *)malloc(infologLength);
+        glGetInfoLogARB(obj, infologLength, &amp;charsWritten, infoLog);
+                printf(&quot;%s\n&quot;,infoLog);
+        free(infoLog);
+    }
+}
+
+
+AGVertexProgram::AGVertexProgram(const std::string &amp;pFile)
+{
+  //  CTRACE;
+  if(glslOk())
+    {
+      vertexShader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
+      std::string s=loadFile(pFile);
+      
+      const char*a=s.c_str();
+      const GLcharARB**x=&a;
+      glShaderSourceARB(vertexShader, 1, x,NULL);
+      glCompileShaderARB(vertexShader);
+      printInfoLog(vertexShader);
+      assertGL;
+    }
+}
+
+AGVertexProgram::~AGVertexProgram()
+{
+  CTRACE;
+  if(glslOk() &amp;&amp; !hasQuit())
+    glDeleteObjectARB(vertexShader);
+  assertGL;
+}
+
+AGFragProgram::AGFragProgram(const std::string &amp;pFile)
+{
+  mValid=false;
+  //  CTRACE;
+  if(glslOk() &amp;&amp; pFile.length()&gt;0)
+    {
+      fragShader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
+      std::string s=loadFile(pFile);
+      const char*a=s.c_str();
+      const GLcharARB**x=&a;
+      glShaderSourceARB(fragShader, 1, x,NULL);
+      glCompileShaderARB(fragShader);
+      printInfoLog(fragShader);
+      mValid=true;
+      assertGL;
+	
+    }
+}
+
+AGFragProgram::AGFragProgram()
+{
+  mValid=false;
+}
+
+AGFragProgram::~AGFragProgram()
+{
+  CTRACE;
+  if(glslOk() &amp;&amp; !hasQuit())
+    glDeleteObjectARB(fragShader);
+  assertGL;
+
+}
+
+
+bool AGFragProgram::valid() const
+{
+  return mValid;
+}
+
+
+AGShaderProgram::AGShaderProgram(const std::string &amp;pVertexFile,const std::string &amp;pFragFile):
+  //  vertex(getVertexProgram(pVertexFile)),frag(getFragProgram(pFragFile))
+  vertex(pVertexFile),frag(pFragFile)
+{
+  //  CTRACE;
+  if(glslOk())
+    {
+      p = glCreateProgramObjectARB();
+      glAttachObjectARB(p,vertex.vertexShader);
+      if(frag.valid())
+	glAttachObjectARB(p,frag.fragShader);
+      
+      glLinkProgramARB(p);
+      printInfoLog(p);
+
+      assert(p);
+    }
+  on=false;
+  matrixBuf=new float[16*100];
+  name=pVertexFile+&quot;:&quot;+pFragFile;
+  assertGL;
+
+}
+
+AGShaderProgram::~AGShaderProgram()
+{
+  disable();
+  CTRACE;
+  cdebug(&quot;name:&quot;&lt;&lt;name);
+  if(glslOk() &amp;&amp; !hasQuit())
+    glDeleteObjectARB(p);
+  cdebug(&quot;name:&quot;&lt;&lt;name);
+  delete [] matrixBuf;
+  cdebug(&quot;name:&quot;&lt;&lt;name);
+  assertGL;
+
+}
+
+
+void AGShaderProgram::enable()
+{
+  if(glslOk())
+    {
+      glUseProgramObjectARB(p);
+      on=true;
+      assertGL;
+
+    }
+}
+void AGShaderProgram::disable()
+{
+  if(glslOk())
+    {
+      glUseProgramObjectARB(0);
+      on=false;
+      assertGL;
+    }
+}
+
+void AGShaderProgram::update(float time)
+{
+  if(glslOk())
+    {
+      enable();
+      doUpdate(time);
+      disable();
+      assertGL;
+    }
+}
+
+void AGShaderProgram::doUpdate(float time)
+{
+}
+
+void AGShaderProgram::sendUniform(const std::string &amp;pName,int i)
+{
+  glUniform1iARB(getLoc(pName),i);
+  assertGL;
+}
+void AGShaderProgram::sendUniform(const std::string &amp;pName,float f)
+{
+  glUniform1fARB(getLoc(pName),f);
+  assertGL;
+}
+void AGShaderProgram::sendUniform(const std::string &amp;pName,const AGVector3 &amp;m)
+{
+  glUniform3fARB(getLoc(pName),m[0],m[1],m[2]);
+  assertGL;
+}
+void AGShaderProgram::sendUniform(const std::string &amp;pName,const AGVector4 &amp;m)
+{
+  glUniform4fARB(getLoc(pName),m[0],m[1],m[2],m[3]);
+  assertGL;
+}
+void AGShaderProgram::sendUniform(const std::string &amp;pName,const AGMatrix4 &amp;m)
+{
+  glUniformMatrix4fvARB(getLoc(pName),1,false,m);
+  assertGL;
+}
+void AGShaderProgram::sendUniform(const std::string &amp;pName,const std::vector&lt;AGMatrix4&gt; &amp;m)
+{
+  assert(m.size()&lt;100);
+  float *p=matrixBuf;
+
+  for(size_t i=0;i&lt;m.size();i++)
+    {
+      const float *s=m[i];
+      for(size_t j=0;j&lt;16;j++)
+	*(p++)=*(s++);
+    }
+  assertGL;
+  glUniformMatrix4fvARB(getLoc(pName),m.size(),false,matrixBuf);
+  assertGL;
+}
+
+GLint AGShaderProgram::getLoc(const std::string &amp;pName)
+{
+  // register only once !
+  
+  std::map&lt;std::string,GLint&gt;::iterator i=locations.find(pName);
+  if(i!=locations.end())
+    return i-&gt;second;
+  
+  GLint k=glGetUniformLocationARB(p,pName.c_str());
+  locations.insert(std::make_pair(pName,k));
+  assertGL;
+  return k;
+}
+
+GLint AGShaderProgram::getAttr(const std::string &amp;pName)
+{
+  //  TRACE;
+  // register only once !
+  assert(on);
+  std::map&lt;std::string,GLint&gt;::iterator i=attrs.find(pName);
+  if(i!=attrs.end())
+    return i-&gt;second;
+  
+  assertGL;
+  GLint k=glGetAttribLocationARB(p,pName.c_str());
+  //  cdebug(&quot;k:&quot;&lt;&lt;k);
+  if(k&lt;0)
+    {
+      cdebug(&quot;ERROR:attribute could be get! Maybe it was not defined in the vertex-shader? :&quot;&lt;&lt;pName);
+    }
+  assertGL;
+  attrs.insert(std::make_pair(pName,k));
+  assertGL;
+  return k;
+}
+
+void AGShaderProgram::sendAttribute(const std::string &amp;pName,const std::vector&lt;float&gt; &amp;vf)
+{
+  assertGL;
+  GLint loc=getAttr(pName);
+  assertGL;
+  glEnableClientState(GL_VERTEX_ARRAY);
+  assertGL;
+  glEnableVertexAttribArrayARB(loc); // add array
+  assertGL;
+
+  glVertexAttribPointerARB(loc,1,GL_FLOAT,0,0,&amp;vf[0]); // set attributes (for each vertex an attribute)
+  assertGL;
+}
+

Added: antargis/branches/rant/ext/3dengine/ag_glsl.h
===================================================================
--- antargis/branches/rant/ext/3dengine/ag_glsl.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ag_glsl.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_glsl.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef AG_GLSL_H
+#define AG_GLSL_H
+
+#include &quot;GLee.h&quot;
+//#include &quot;renderer.h&quot;
+#include &quot;ag_tools.h&quot;
+#include &quot;ag_geometry.h&quot;
+
+#include &lt;map&gt;
+
+class Scene;
+
+class AGVertexProgram
+{
+ public:
+  AGVertexProgram(const std::string &amp;pFile);
+  ~AGVertexProgram();
+
+ private:
+  GLhandleARB vertexShader;
+
+  friend class AGShaderProgram;
+};
+
+class AGFragProgram
+{
+ public:
+  AGFragProgram(const std::string &amp;pFile);
+  AGFragProgram();
+  ~AGFragProgram();
+
+  bool valid() const;
+
+ private:
+  GLhandleARB fragShader;
+  bool mValid;
+
+  friend class AGShaderProgram;
+};
+
+
+class AGShaderParameter
+{
+ public:
+  
+};
+
+class AGShaderProgram
+{
+  AGVertexProgram vertex;
+  AGFragProgram frag;
+  std::map&lt;std::string,GLint&gt; locations;
+  std::map&lt;std::string,GLint&gt; attrs;
+  float *matrixBuf;
+  bool on;
+  std::string name;
+ protected:  
+  GLhandleARB p;
+
+ public:
+  AGShaderProgram(const std::string &amp;pVertexFile,const std::string &amp;pFragFile);
+  virtual ~AGShaderProgram();
+  virtual void enable();
+  virtual void disable();
+
+  void update(float time);
+  virtual void doUpdate(float time);
+
+  GLint getLoc(const std::string &amp;pName);
+  GLint getAttr(const std::string &amp;pName);
+
+  void sendUniform(const std::string &amp;pName,int i);
+  void sendUniform(const std::string &amp;pName,float f);
+  void sendUniform(const std::string &amp;pName,const AGVector3 &amp;m);
+  void sendUniform(const std::string &amp;pName,const AGVector4 &amp;m);
+  void sendUniform(const std::string &amp;pName,const AGMatrix4 &amp;m);
+  void sendUniform(const std::string &amp;pName,const std::vector&lt;AGMatrix4&gt; &amp;m);
+
+  void sendAttribute(const std::string &amp;pName,const std::vector&lt;float&gt; &amp;vf);
+};
+
+bool glslOk();
+
+#endif

Added: antargis/branches/rant/ext/3dengine/anim_mesh.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/anim_mesh.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/anim_mesh.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,396 @@
+#include &quot;anim_mesh.h&quot;
+#include &quot;scene.h&quot;
+#include &quot;ag_texturecache.h&quot;
+#include &quot;ag_rendercontext.h&quot;
+
+#include &quot;ag_vdebug.h&quot;
+#include &quot;ag_xml.h&quot;
+#include &quot;ag_fs.h&quot;
+#include &quot;ag_config.h&quot;
+#include &quot;ag_profiler.h&quot;
+#include &quot;entity.h&quot;
+
+#include &lt;math.h&gt;
+
+bool useShaderAnimation(); // imported from anim_mesh_data.cc
+
+
+void setRotation(AGMatrix4 &amp;m,const AGVector3 &amp;angles)
+{
+  double cr = cos( angles[0] );
+  double sr = sin( angles[0] );
+  double cp = cos( angles[1] );
+  double sp = sin( angles[1] );
+  double cy = cos( angles[2] );
+  double sy = sin( angles[2] );
+  // FIXME: maybe the coord must be switched
+
+  m.set(0,0,( float )( cp*cy ));
+  m.set(0,1,( float )( cp*sy ));
+  m.set(0,2,( float )( -sp ));
+    double srsp = sr*sp;
+  double crsp = cr*sp;
+
+  m.set(1,0,( float )( srsp*cy-cr*sy ));
+  m.set(1,1,( float )( srsp*sy+cr*cy ));
+  m.set(1,2,( float )( sr*cp ));
+  
+  m.set(2,0,( float )( crsp*cy+sr*sy ));
+  m.set(2,1,( float )( crsp*sy-sr*cy ));
+  m.set(2,2,( float )( cr*cp ));
+
+}
+
+void setTranslation(AGMatrix4 &amp;m,const AGVector3 &amp;t)
+{
+  m.set(3,0,t[0]);
+  m.set(3,1,t[1]);
+  m.set(3,2,t[2]);
+}
+
+
+void inverseRotate(AGVector3 &amp;v, const AGMatrix4 &amp;m )
+{
+  AGVector3 n;
+  n[0]=v[0]*m.get(0,0) + v[1]*m.get(0,1) + v[2]*m.get(0,2);
+  n[1]=v[0]*m.get(1,0) + v[1]*m.get(1,1) + v[2]*m.get(1,2);
+  n[2]=v[0]*m.get(2,0) + v[1]*m.get(2,1) + v[2]*m.get(2,2);
+  v=n;
+}
+
+void inverseTranslate(AGVector3 &amp;v, const AGMatrix4 &amp;m )
+{
+  v[0]-=m.get(3,0);
+  v[1]-=m.get(3,1);
+  v[2]-=m.get(3,2);
+}
+
+
+
+/////////////////////////////////////////////////////////////////////////
+// AnimMesh
+/////////////////////////////////////////////////////////////////////////
+
+
+AnimMesh::AnimMesh(Scene *pScene,AnimMeshData *data):
+  SceneNode(pScene,AGVector4(),data-&gt;bbox()),
+  mData(data),mMatrices(data-&gt;bones.size()+1),mShaderMatrices(20)
+{
+  curKey=0;
+  mTime=0;
+  
+  assert(mData-&gt;mAnimations.size()&gt;0);
+  mAnimName=mData-&gt;mAnimations.begin()-&gt;first;
+  mAnimation=&amp;mData-&gt;mAnimations.begin()-&gt;second;
+
+  mEntity=0;
+  setOrder(MESH_Z);
+
+}
+
+AnimMesh::~AnimMesh()
+{
+  //  CTRACE;
+}
+
+void AnimMesh::setEntity(AntEntity *e)
+{
+  mEntity=e;
+}
+
+
+void AnimMesh::drawDepth()
+{
+  STACKTRACE;
+  drawPrivate(false,false);
+}
+
+void AnimMesh::draw()
+{
+  STACKTRACE;
+  //return;
+  drawPrivate(true,false);
+}
+void AnimMesh::drawPick()
+{
+  STACKTRACE;
+  drawPrivate(false,true);
+}
+
+
+void AnimMesh::drawPrivate(bool textured, bool mem)
+{
+  assertGL;
+  AGRenderContext c;
+  if(textured)
+    {
+      c.setTexture(mData-&gt;mTexture.glTexture());
+      
+      c.setLighting(true);
+    }
+  c.begin();
+  glPushMatrix();
+
+  AGVector4 p=getPos();
+  glTranslatef(p[0],p[1],p[2]);
+  glRotatef(mRot[3],mRot[0],mRot[1],mRot[2]);
+
+  bool pick=mem&amp;&amp;(!textured);
+
+
+  if(useShaderAnimation() &amp;&amp; !pick)
+    {
+      glMultMatrixf(mData-&gt;getTransform());
+      if(textured)
+	{
+	  mData-&gt;animShader.enable();
+
+	  mData-&gt;animShader.sendUniform(&quot;matrices&quot;,mShaderMatrices);
+	  
+	  //	  mData-&gt;mArrayDepth.setColors(false);
+	  mData-&gt;mArray.draw();
+
+	  mData-&gt;animShader.disable();
+
+	}
+      else if(mem)
+	{
+	  mData-&gt;mArray.drawPick();
+	}
+      else
+	{
+	  mData-&gt;animShaderDepth.enable();
+
+	  mData-&gt;animShaderDepth.sendUniform(&quot;matrices&quot;,mShaderMatrices);
+
+	  mData-&gt;mArrayDepth.setColors(false);
+
+	  mData-&gt;mArrayDepth.draw(); // FIXME: drawDepth makes some problems here
+
+	  mData-&gt;animShaderDepth.disable();
+	}
+    }
+
+  else if(!mData-&gt;animate)
+    {
+      glBegin(GL_TRIANGLES);
+      
+      // for a start do a simple drawing 
+      for(std::vector&lt;size_t&gt;::iterator i=mData-&gt;indices.begin();i!=mData-&gt;indices.end();i++)
+	{
+	  AGMatrix4 m(mData-&gt;getTransform());
+	  AGVector3 p((m*AGVector4(mData-&gt;pos[*i],1)).dim3());
+	  if(textured)
+	    {
+	      AGVector3 n((m*AGVector4(mData-&gt;normal[*i],0)).dim3());
+	      
+	      glNormal3fv(n);
+	      glTexCoord2fv(mData-&gt;uv[*i]);
+	    }
+	  glVertex3fv(p);
+	  
+	}
+      
+      glEnd();
+    }
+  else
+    {
+
+      // paint with transform
+
+      glMultMatrixf(mData-&gt;getTransform());
+
+      glBegin(GL_TRIANGLES);
+      
+      // for a start do a simple drawing 
+      for(std::vector&lt;size_t&gt;::iterator i=mData-&gt;indices.begin();i!=mData-&gt;indices.end();i++)
+	{
+	  int b=mData-&gt;bone[*i];
+	  AGMatrix4 m;
+	  if(b&gt;=0)
+	    {
+	      m=mMatrices[b];
+	    }
+	  AGVector3 p((m*AGVector4(mData-&gt;pos[*i],1)).dim3());
+	  if(textured)
+	    {
+	      AGVector3 n((m*AGVector4(mData-&gt;normal[*i],0)).dim3());
+	      
+	      glNormal3fv(n);
+	      glTexCoord2fv(mData-&gt;uv[*i]);
+	    }
+	  glVertex3fv(p);
+	}
+      
+      glEnd();
+
+
+    }
+  
+  glPopMatrix();
+  assertGL;
+}
+
+void AnimMesh::advance(float time)
+{
+  if(!mData-&gt;animate)
+    return;
+  float oldTime=mTime;
+
+  mTime+=mAnimation-&gt;fps*time;
+
+  if(mAnimation-&gt;len&gt;0)
+    {
+      if(mAnimation-&gt;loop)
+	while(mTime&gt;mAnimation-&gt;end)
+	  mTime-=mAnimation-&gt;len;
+      else
+	mTime=std::min(mTime,mAnimation-&gt;end);
+    }
+  else
+    mTime=mAnimation-&gt;begin;
+
+  mTime=std::max(mTime,mAnimation-&gt;begin);
+
+  //  cdebug(mAnimName&lt;&lt;&quot;  &quot;&lt;&lt;mTime&lt;&lt;&quot;  &quot;&lt;&lt;mAnimation-&gt;len&lt;&lt;&quot; &quot;&lt;&lt;mAnimation-&gt;begin&lt;&lt;&quot; &quot;&lt;&lt;mAnimation-&gt;end);
+
+
+  // check events
+  if(mEntity &amp;&amp; mData-&gt;frameEvents.size())
+    {
+      if(oldTime&gt;mTime)
+	{
+	  for(std::map&lt;int,AGString&gt;::iterator i=mData-&gt;frameEvents.begin();i!=mData-&gt;frameEvents.end();i++)
+	    if(i-&gt;first&gt;=oldTime || i-&gt;first&lt;mTime)
+	      mEntity-&gt;animationEvent(i-&gt;second);
+	}
+      else
+	{
+	  for(std::map&lt;int,AGString&gt;::iterator i=mData-&gt;frameEvents.begin();i!=mData-&gt;frameEvents.end();i++)
+	    {
+	      if(i-&gt;first&gt;=oldTime &amp;&amp; i-&gt;first&lt;mTime)
+		mEntity-&gt;animationEvent(i-&gt;second);
+	    }
+	}
+
+    }
+
+
+  update();
+}
+
+void AnimMesh::update()
+{
+  // this doesn't take much of rendering-time
+  // calculate 
+  
+  while(mTime&gt;mData-&gt;animTime)
+    mTime-=mData-&gt;animTime;
+  
+  for(size_t k=0;k&lt;mData-&gt;bones.size();k++)
+    {
+      Bone *bone=mData-&gt;bones[k];
+      AGMatrix4 final(bone-&gt;mRelative);
+      AGMatrix4 trans;
+      AGVector3 rot,pos;
+
+      // first get surrounding keyframes (rot &amp; trans) for this bone 
+      // and calculate ri0,ri1 and ti0,ti1 (1-ti0 == ti1)
+
+      rot=bone-&gt;interpolateRot(mTime);
+      pos=bone-&gt;interpolateTrans(mTime);
+
+      ::setRotation(trans,rot);
+      setTranslation(trans,pos);
+      
+      
+      final=final*trans;
+      
+      if(mData-&gt;bones[k]-&gt;parent)
+	final=mMatrices[mData-&gt;bones[k]-&gt;parent-&gt;id]*final;
+      
+      mMatrices[k]=final;
+    }
+  mMatrices[mData-&gt;bones.size()]=AGMatrix4();
+
+  for(size_t k=0;k&lt;mData-&gt;bones.size();k++)
+    mShaderMatrices[k]=mData-&gt;getTransform()*mMatrices[k];
+  mShaderMatrices[mData-&gt;bones.size()]=mData-&gt;getTransform()*mMatrices[mData-&gt;bones.size()];
+
+
+  for(size_t k=0;k&lt;mData-&gt;bones.size();k++)
+    mShaderMatrices[k]=mMatrices[k];
+
+  mShaderMatrices[mData-&gt;bones.size()]=mMatrices[mData-&gt;bones.size()];
+}
+
+
+AnimMeshData *AnimMesh::getData()
+{
+  return mData;
+}
+
+
+void AnimMesh::setTransform(const AGMatrix4 &amp;m)
+{
+  mTransform=m;
+  assert(mData);
+  mComplete=mData-&gt;getTransform()*mTransform;
+}
+
+void AnimMesh::setPos(const AGVector3 &amp;p)
+{
+  SceneNode::setPos(p);
+
+  mTransform=AGMatrix4(mRot[3],mRot.dim3())*AGMatrix4(getPos());//p);//mPos);
+
+  assert(mData);
+  mComplete=mData-&gt;getTransform()*mTransform;
+}
+void AnimMesh::setRotation(const AGVector3 &amp;r,float a)
+{
+  mRot=AGVector4(r,a);
+
+  mTransform=AGMatrix4(a,r)*AGMatrix4(getPos());
+
+  assert(mData);
+  mComplete=mData-&gt;getTransform()*mTransform;
+}
+
+void AnimMesh::setRotation(float r)
+{
+  setRotation(AGVector3(0,0,1),r+180);
+}
+
+AGString AnimMesh::getAnimation() const
+{
+  return mAnimName;
+}
+
+bool AnimMesh::setAnimation(const AGString &amp;pName)
+{
+  if(mAnimName==pName)
+    return true;
+  if(mData-&gt;mAnimations.find(pName)==mData-&gt;mAnimations.end())
+    {
+      cdebug(AGString(&quot;Animation &quot;)+pName+&quot; is known here!&quot;);
+      return false;
+    }
+
+  mAnimation=&amp;(mData-&gt;mAnimations[pName]);
+  mAnimName=pName;
+  mTime=mAnimation-&gt;begin;
+  return true;
+}
+
+void AnimMesh::mark()
+{
+  markObject(mData);
+}
+
+size_t AnimMesh::getTriangles() const
+{
+  return mData-&gt;indices.size()/3;
+}
+
+

Added: antargis/branches/rant/ext/3dengine/anim_mesh.h
===================================================================
--- antargis/branches/rant/ext/3dengine/anim_mesh.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/anim_mesh.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,70 @@
+#ifndef ANIM_MESH_H
+#define ANIM_MESH_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &quot;scene.h&quot;
+#include &quot;ag_surface.h&quot;
+#include &quot;ag_geometry.h&quot;
+#include &quot;scenenode.h&quot;
+
+#include &lt;vector&gt;
+#include &lt;map&gt;
+
+#include &quot;anim_mesh_data.h&quot;
+
+class AntEntity;
+
+/**
+   AnimMesh is a skeleton animated mesh.
+   It support either shader-based and cpu-based animation.
+*/
+class AnimMesh:public SceneNode
+{
+  AnimMeshData *mData;
+  size_t curKey;
+  float mTime;
+  AGMatrix4 mTransform;
+  AGMatrix4 mComplete;
+  AGVector4 mRot;
+  AGString mAnimName;
+  Animation *mAnimation;
+  AntEntity *mEntity;
+
+  std::vector&lt;AGMatrix4&gt; mMatrices;
+  std::vector&lt;AGMatrix4&gt; mShaderMatrices;
+
+ public:
+  AnimMesh(Scene *pScene,AnimMeshData *data);
+  virtual ~AnimMesh();
+
+  void setTransform(const AGMatrix4 &amp;m);
+
+  AGString getAnimation() const;
+  bool setAnimation(const AGString &amp;pName);
+
+  void setPos(const AGVector3 &amp;p);
+  void setRotation(const AGVector3 &amp;r,float a);
+  void setRotation(float r);
+
+  AnimMeshData *getData();
+
+  virtual void draw();
+  virtual void drawDepth();
+  virtual void drawPick();
+  virtual void advance(float time);
+	
+  virtual void mark();
+
+  void setEntity(AntEntity *e);
+
+  virtual size_t getTriangles() const;
+
+ private:
+
+  void drawPrivate(bool textured,bool mem);
+
+  void update();
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/anim_mesh_data.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/anim_mesh_data.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/anim_mesh_data.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,337 @@
+#include &quot;anim_mesh_data.h&quot;
+#include &quot;ag_texturecache.h&quot;
+#include &quot;ag_config.h&quot;
+#include &quot;ag_xml.h&quot;
+
+#include &lt;ag_serial.h&gt;
+
+void setRotation(AGMatrix4 &amp;m,const AGVector3 &amp;angles); // from anim_mesh.cc
+void setTranslation(AGMatrix4 &amp;m,const AGVector3 &amp;t);
+void inverseRotate(AGVector3 &amp;v, const AGMatrix4 &amp;m );
+void inverseTranslate(AGVector3 &amp;v, const AGMatrix4 &amp;m );
+
+
+bool useAnimation()
+{
+  bool anim=getConfig()-&gt;get(&quot;animationType&quot;)!=&quot;false&quot;;
+  getConfig()-&gt;set(&quot;animationType&quot;,anim?&quot;true&quot;:&quot;false&quot;);
+  return anim;
+}
+
+bool useShaderAnimation()
+{
+  return glslOk() &amp;&amp; GLEE_ARB_vertex_buffer_object; // doesn't work with vbos
+}
+
+AGVector3 Bone::interpolate(const std::vector&lt;KeyFrame&gt; &amp;frames,float t)
+{
+  size_t i;
+  for(i=0;i&lt;frames.size();i++)
+    {
+      if(frames.size()&gt;i+1)
+	{
+	  if(frames[i+1].time&gt;t)
+	    break;
+	}
+      else
+	break;
+    }
+  size_t j=i+1;
+  if(j&gt;=frames.size())
+    return frames[i].v;
+  
+  float t0=frames[i].time;
+  float t1=frames[j].time;
+
+  float i0=(t-t0)/(t1-t0);
+  float i1=1-i0;
+
+  return frames[i].v*i1 + frames[j].v*i0;
+}
+AGVector3 Bone::interpolateRot(float t)
+{
+  return interpolate(rFrames,t);
+}
+AGVector3 Bone::interpolateTrans(float t)
+{
+  return interpolate(tFrames,t);
+}
+
+
+
+AnimMeshData::AnimMeshData(const AGFilename &amp;xmlfile):
+  animShader(&quot;data/shaders/anim.vert&quot;,&quot;data/shaders/anim.frag&quot;),
+  //  animShaderDepth(&quot;data/shaders/anim_depth.vert&quot;,&quot;&quot;),
+  animShaderDepth(&quot;data/shaders/anim_depth.vert&quot;,&quot;data/shaders/anim_depth.frag&quot;),
+  mArray(&amp;animShader),
+  mArrayDepth(&amp;animShaderDepth)
+{
+  Document doc(xmlfile);
+
+  Node &amp;root=doc.root();
+
+  events=false;
+
+  animate=true;
+  if(root.get(&quot;debug&quot;)==&quot;true&quot;)
+    animate=false;
+  if(!useAnimation())
+    animate=false;
+
+  cdebug(&quot;loading from:&quot;&lt;&lt;root.get(&quot;model&quot;));
+
+  loadAnt3(loadFile(root.get(&quot;model&quot;)),root.get(&quot;scale&quot;).toFloat(),root.get(&quot;texture&quot;));
+  
+  // load animations
+  
+  cdebug(&quot;animTime:&quot;&lt;&lt;animTime);
+
+  Node::NodeVector anims=root.getChildren(&quot;animation&quot;);
+  for(Node::NodeVector::iterator i=anims.begin();i!=anims.end();i++)
+    {
+      float begin=(*i)-&gt;get(&quot;begin&quot;).toFloat()-1;
+      float end=(*i)-&gt;get(&quot;end&quot;).toFloat()-1;
+      float fps=(*i)-&gt;get(&quot;fps&quot;).toFloat();
+      assert(fps&gt;0);
+      assert(begin&gt;=0);
+      assert(begin&lt;animTime);
+      assert(begin&lt;=end);
+      assert(end&lt;animTime);
+      mAnimations[(*i)-&gt;get(&quot;name&quot;)]=Animation(begin,end,fps);
+
+      mAnimations[(*i)-&gt;get(&quot;name&quot;)].loop=((*i)-&gt;get(&quot;loop&quot;)!=&quot;false&quot;);
+
+      // parse events
+      Node::NodeVector enodes=(*i)-&gt;getChildren(&quot;event&quot;);
+      for(Node::NodeVector::iterator j=enodes.begin();j!=enodes.end();j++)
+	{
+	  frameEvents.insert(std::make_pair((*j)-&gt;get(&quot;frame&quot;).toInt(),(*j)-&gt;get(&quot;name&quot;)));
+	}
+      
+    }
+
+  if(anims.size()==0)
+    {
+      std::cerr&lt;&lt;&quot;There are no animations in &quot;&lt;&lt;xmlfile&lt;&lt;std::endl;
+      throw std::string(&quot;no animations found in xmlfile&quot;);
+    }
+  mName=AGString(xmlfile);
+}
+
+AnimMeshData::~AnimMeshData()
+{
+  CTRACE;
+  cdebug(mName);
+
+  // delete bones
+  for(std::vector&lt;Bone*&gt;::iterator i=bones.begin();i!=bones.end();++i)
+    delete *i;
+
+
+}
+
+AGBox3 AnimMeshData::bbox() const
+{
+  return mBBox;
+}
+
+void AnimMeshData::setEvents(bool e)
+{
+  events=e;
+}
+
+
+int getMeshDownScale()
+{
+  int s=1;
+  AGString n=&quot;meshDownScaleExp&quot;;
+
+  if(getConfig()-&gt;get(n)!=&quot;&quot;)
+    s=getConfig()-&gt;get(n).toInt();
+  
+  getConfig()-&gt;set(n,AGString(s));
+
+  return s;
+
+}
+
+void AnimMeshData::loadAnt3(const AGData &amp;instr,float scale,const AGFilename &amp;tex)
+{
+  mTexture=getTextureCache()-&gt;get(tex,getMeshDownScale());
+  BinaryStringIn l(instr);
+
+  Uint32 vs,ts;
+
+  l&gt;&gt;vs;
+  for(Uint32 i=0;i&lt;vs;i++)
+    {
+      float x,y,z,tx,ty,nx,ny,nz;
+      Sint32 boneID;
+      l&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;tx&gt;&gt;ty&gt;&gt;boneID&gt;&gt;nx&gt;&gt;ny&gt;&gt;nz;
+
+      AGVector3 v(x,y,z);
+      v*=scale;
+      mBBox.include(v);
+      pos.push_back(v);
+      uv.push_back(AGVector2(tx,1-ty));
+      normal.push_back(AGVector3(nx,ny,nz));
+      bone.push_back(boneID);
+    }
+
+  l&gt;&gt;ts;
+  Uint32 index;
+  for(Uint32 i=0;i&lt;ts*3;i++)
+    {
+      l&gt;&gt;index;
+      indices.push_back(index);
+    }
+
+  Uint32 nbones,frames;
+  l&gt;&gt;frames&gt;&gt;nbones;
+
+  for(size_t k=0;k&lt;bone.size();k++)
+    {
+      if(bone[k]==-1)
+	{
+	  bonef.push_back(nbones);
+	  boneui.push_back(nbones);
+	}
+      else
+	{
+	  bonef.push_back(bone[k]);
+	  boneui.push_back(bone[k]);
+	}
+    }
+
+
+  animTime=frames;
+
+  for(Uint32 i=0;i&lt;nbones;i++)
+    {
+      float x,y,z,rx,ry,rz;
+      Sint32 parent;
+      l&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;rx&gt;&gt;ry&gt;&gt;rz&gt;&gt;parent;
+      Bone *bone=new Bone;
+      bone-&gt;id=i;
+      bone-&gt;pos=AGVector3(x,y,z)*scale;
+      bone-&gt;rot=AGVector3(rx,ry,rz);
+      if(parent&lt;0)
+	bone-&gt;parent=0;
+      else
+	{
+	  assert(parent&lt;(int)i);
+	  bone-&gt;parent=bones[parent];
+	}
+
+      // read rot-frames
+      Sint32 frames;
+      l&gt;&gt;frames;
+      KeyFrame frame;
+      for(Sint32 r=0;r&lt;frames;r++)
+	{
+	  float x,y,z,t;
+	  l&gt;&gt;t&gt;&gt;x&gt;&gt;y&gt;&gt;z;
+	  frame.time=t;
+	  frame.v=AGVector3(x,y,z);
+	  bone-&gt;rFrames.push_back(frame);
+	}
+
+      l&gt;&gt;frames;
+      for(Sint32 r=0;r&lt;frames;r++)
+	{
+	  float x,y,z,t;
+	  l&gt;&gt;t&gt;&gt;x&gt;&gt;y&gt;&gt;z;
+	  frame.time=t;
+	  frame.v=AGVector3(x,y,z)*scale;
+	  bone-&gt;tFrames.push_back(frame);
+	}
+
+
+
+      bones.push_back(bone);
+    }
+
+  if(animate)
+    setupJoints();
+
+  setupArray();
+}
+
+void AnimMeshData::setTransform(const AGMatrix4 &amp;m)
+{
+  mBase=m;
+}
+
+const AGMatrix4 &amp;AnimMeshData::getTransform() const
+{
+  return mBase;
+}
+
+
+void AnimMeshData::setupJoints()
+{
+  for (std::vector&lt;Bone*&gt;::iterator i = bones.begin(); i!=bones.end(); i++ )
+    {
+      Bone&amp; joint = **i;
+
+      setRotation(joint.mRelative, joint.rot);
+      setTranslation(joint.mRelative, joint.pos);
+
+      if(joint.parent)
+	joint.mAbsolute=joint.parent-&gt;mAbsolute*joint.mRelative;
+      else
+	joint.mAbsolute=joint.mRelative;
+
+    }
+
+  for (size_t i=0;i&lt;pos.size();i++)
+    {
+      if(bone[i]!=-1)
+	{
+	  AGMatrix4 m(bones[bone[i]]-&gt;mAbsolute);
+	  AGVector3 test=pos[i];
+	  inverseTranslate(pos[i],m);
+	  inverseRotate(pos[i],m);
+
+	  // normals
+	  inverseRotate(normal[i],m);
+	}
+    }
+}
+
+
+void AnimMeshData::setupArray()
+{
+  for(size_t i=0;i&lt;pos.size();i++)
+    mArray.addVertex(AGVector4(pos[i],1),AGVector4(1,1,1,1),normal[i],uv[i]);
+  for(size_t i=0;i&lt;indices.size();i+=3)
+    mArray.addTriangle(indices[i],indices[i+1],indices[i+2]);
+
+  // set boneIDs
+  mArray.addAttribute(&quot;bones&quot;,bonef);
+  //  mArray.addAttribute(&quot;ibones&quot;,boneui);
+
+
+
+
+  for(size_t i=0;i&lt;pos.size();i++)
+    mArrayDepth.addVertex(AGVector4(pos[i],1),AGVector4(1,1,1,1),normal[i],uv[i]);
+  for(size_t i=0;i&lt;indices.size();i+=3)
+    mArrayDepth.addTriangle(indices[i],indices[i+1],indices[i+2]);
+
+  // set boneIDs
+  mArrayDepth.addAttribute(&quot;bones&quot;,bonef);
+  //  mArrayDepth.addAttribute(&quot;ibones&quot;,boneui);
+
+
+}
+
+std::vector&lt;std::string&gt; AnimMeshData::getAnimations() const
+{
+  std::vector&lt;std::string&gt; l;
+
+  for(std::map&lt;AGString,Animation&gt;::const_iterator i=mAnimations.begin();i!=mAnimations.end();i++)
+    l.push_back(i-&gt;first);
+
+  return l;
+}

Added: antargis/branches/rant/ext/3dengine/anim_mesh_data.h
===================================================================
--- antargis/branches/rant/ext/3dengine/anim_mesh_data.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/anim_mesh_data.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,109 @@
+#ifndef ANIM_MESH_DATA_H
+#define ANIM_MESH_DATA_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &quot;vertex_array.h&quot;
+#include &quot;glsl.h&quot;
+#include &quot;ag_texture.h&quot;
+
+struct KeyFrame
+{
+  float time;
+  AGVector3 v;
+};
+
+struct Bone
+{
+  size_t id;
+  AGVector3 pos,rot;
+  AGMatrix4 mRelative,mAbsolute,mFinal;
+
+  Bone *parent;
+
+  std::vector&lt;KeyFrame&gt; rFrames,tFrames;
+
+
+  AGVector3 interpolateRot(float t);
+  AGVector3 interpolateTrans(float t);
+
+  AGVector3 interpolate(const std::vector&lt;KeyFrame&gt; &amp;frames,float t);
+};
+
+struct Animation
+{
+  float begin;
+  float end;
+  float fps;
+  float len;
+  bool loop;
+
+  Animation()
+  {
+    begin=end=fps=1;
+    len=0;
+  }
+  Animation(float b,float e,float f):begin(b),end(e),fps(f)
+  {
+    len=end-begin;
+  }
+};
+
+class AnimMeshData:public AGRubyObject
+{
+  AntShaderProgram animShader;
+  AntShaderProgram animShaderDepth;
+  VertexArrayShader mArray;
+  VertexArrayShader mArrayDepth;
+
+  std::vector&lt;AGVector3&gt; pos;
+  std::vector&lt;AGVector2&gt; uv;
+  std::vector&lt;AGVector3&gt; normal;
+  std::vector&lt;int&gt; bone;
+  std::vector&lt;float&gt; bonef;
+  std::vector&lt;Uint16&gt; boneui;
+
+  std::vector&lt;size_t&gt; indices;
+
+  std::vector&lt;Bone*&gt; bones;
+
+  std::map&lt;int,AGString&gt; frameEvents;
+
+  float animTime;
+
+  AGTexture mTexture;
+
+  AGMatrix4 mBase;
+
+  std::map&lt;AGString,Animation&gt; mAnimations;
+
+  AGBox3 mBBox;
+
+  bool animate;
+
+  AGString mName;
+
+  bool events;
+
+ private:
+  void setupJoints();
+  void setupArray();
+  void loadAnt3(const AGData &amp;instr,float scale,const AGFilename &amp;pTexName);
+
+ public:
+  AnimMeshData(const AGFilename &amp;xmlfile);
+  ~AnimMeshData();
+
+  AGBox3 bbox() const;
+
+  void setEvents(bool e);
+
+  void setTransform(const AGMatrix4 &amp;m);
+  const AGMatrix4 &amp;getTransform() const;
+
+  friend class AnimMesh;
+
+  std::vector&lt;std::string&gt; getAnimations() const;
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/ant_camera.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_camera.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ant_camera.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,268 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ant_camera.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ant_camera.h&quot;
+#include &quot;ant_renderer.h&quot;
+#include &lt;GL/gl.h&gt;
+#include &lt;GL/glu.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;ag_debug.h&quot;
+
+AntCamera::AntCamera(int w,int h)
+{
+  mWidth=w;
+  mHeight=h;
+
+  cameraPosition=AGVector4(0,-20,20);
+  lightPosition=AGVector4( -25, -50, 60,1);
+  scenePosition=AGVector4(0,0,0,1);
+
+  cameraPosition=AGVector4(0,-15,15);
+
+  mPSM=false;
+  updateMatrices();
+}
+
+void AntCamera::incCameraDistance()
+{
+  float d=cameraPosition[2]+0.3;
+
+  d=std::min(d,20.0f);
+  cameraPosition=AGVector4(0,-d,d);
+  updateMatrices();
+}
+void AntCamera::decCameraDistance()
+{
+  float d=cameraPosition[2]-0.3;
+
+  d=std::max(d,12.0f);
+  cameraPosition=AGVector4(0,-d,d);
+  updateMatrices();
+}
+
+
+void AntCamera::updateMatrices()
+{
+
+  // 1. init camera view matrix
+  glMatrixMode(GL_MODELVIEW);
+  glLoadIdentity();
+  gluLookAt(cameraPosition[0]+scenePosition[0],cameraPosition[1]+scenePosition[1],cameraPosition[2]+scenePosition[2],
+	    scenePosition[0],scenePosition[1],scenePosition[2],
+	    0,0,1);
+  glGetFloatv(GL_MODELVIEW_MATRIX, cameraView);
+  
+  // 2. init camera projection matrix
+  
+  glMatrixMode(GL_PROJECTION);
+  glLoadIdentity();
+  gluPerspective(45.0f, ((float)mWidth)/mHeight, 3.0f, 63.0f);
+  glGetFloatv(GL_PROJECTION_MATRIX, cameraProjection);
+  glMatrixMode(GL_MODELVIEW);
+  if(mPSM)
+    {
+      // PSM
+      // calculation of lightposition is somehow crappy
+
+
+      // PSMs
+      //  lightPosition=AGVector4( -2.0, -3, 5.1,1)*100;
+      
+      // light View Matrix
+      glLoadIdentity();
+      
+      AGVector4 lp=lightPosition;
+      //    lp[
+      lp[3]=1;
+      lp=cameraProjection*cameraView*lp;
+      
+      lp/=lp[3];
+      
+      // it is something like (12,-10,10)
+      
+      
+      
+      
+      lp=AGVector4(-0.5,1.5,-0.5,1); // should be something like this 
+      lp*=100;
+      
+      
+      //lp=AGVector4(-2,2,-2,1);
+      gluLookAt(lp[0], lp[1], lp[2],
+		0,0,0,
+		0.0f, 1.0f, 0.0f);
+      glGetFloatv(GL_MODELVIEW_MATRIX, lightView);
+      
+      lightView=lightView*cameraProjection*cameraView;
+      // light projection Matrix
+      glLoadIdentity();
+      //    glOrtho(-10,10,-15,20,10,1000);
+      cdebug(lp.toString());
+      float s2=sqrt(2.0f);
+      float ldist=lp.length3();
+      
+      glOrtho(-s2,s2,-s2,s2,ldist-2*s2,ldist+10);//1,10);//ldist-2*s2,ldist+10*s2);
+      
+      
+      //very old:glOrtho(-1,2,-1.5,3,700,750);
+      //      glOrtho(-1,2,-1,1,2,8);
+      
+      glGetFloatv(GL_MODELVIEW_MATRIX, lightProjection);
+    }
+
+    {
+      //  lightPosition=AGVector4( -1.0, -3, 5.1,1);
+      
+      // calc light view,too
+      // light View Matrix
+      glLoadIdentity();
+      gluLookAt(lightPosition[0]+scenePosition[0], lightPosition[1]+scenePosition[1], lightPosition[2]+scenePosition[2],
+		scenePosition[0],scenePosition[1],scenePosition[2],
+		0.0f, 0.0f, 1.0f);
+      glGetFloatv(GL_MODELVIEW_MATRIX, lightView);
+      
+      
+      // light projection Matrix
+      glLoadIdentity();
+      
+	{
+#warning &quot;add some decent calculation here&quot;
+	  // use getFrustum for estimating a good light-frustum
+
+	  float near0=20,near1=60;
+	  float far0=20,far1=110;
+
+	  float mnear=sqrt(near0*near0+near1*near1);
+	  float mfar=sqrt(far0*far0+far1*far1);
+	  
+	  float left=-25;
+	  float right=14;
+	  float bottom=-15;
+	  float top=14;
+
+	  if(getRenderer()-&gt;badShadowMap())
+	    top=bottom+(top-bottom)*1024.0f/768.0f;
+
+	  glFrustum(left, right, bottom, top,
+		    mnear,mfar);
+
+	}
+      
+      glGetFloatv(GL_MODELVIEW_MATRIX, lightProjection);
+    }
+
+    // viewport
+  glMatrixMode(GL_MODELVIEW);
+    
+}
+
+
+Viewport AntCamera::getViewport() const
+{
+  Viewport p;
+  p.viewport[0]=0;
+  p.viewport[1]=0;
+  p.viewport[2]=mWidth;
+  p.viewport[3]=mHeight;
+  return p;
+}
+AGMatrix4 AntCamera::getModelview() const
+{
+  return cameraView;
+}
+AGMatrix4 AntCamera::getProjection() const
+{
+  return cameraProjection;
+}
+
+void AntCamera::setPosition(const AGVector3 &amp;p)
+{
+  scenePosition=AGVector4(p,1);
+  updateMatrices();
+}
+
+AGVector4 AntCamera::getCameraPosition() const
+{
+  return AGVector4(scenePosition.dim3()+cameraPosition.dim3(),1);
+}
+AGVector4 AntCamera::getCameraPositionR() const
+{
+  return cameraPosition;
+}
+
+AGVector4 AntCamera::getLightPosition() const
+{
+  return AGVector4(scenePosition.dim3()+lightPosition.dim3(),1);
+}
+
+
+AGVector3 AntCamera::getPosition() const
+{
+  return scenePosition.dim3();
+}
+
+int AntCamera::getWidth() const
+{
+  return mWidth;
+}
+int AntCamera::getHeight() const
+{
+  return mHeight;
+}
+
+AGMatrix4 AntCamera::getLightComplete() const
+{
+  float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
+		0.0f, 0.5f, 0.0f, 0.0f,
+		0.0f, 0.0f, 0.5f, 0.0f,
+		0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
+  static AGMatrix4 biasMatrix(bias);
+  return biasMatrix*lightProjection*lightView;
+}
+
+AGMatrix4 AntCamera::getLightView() const
+{
+  return lightView;
+}
+AGMatrix4 AntCamera::getLightProjectionMatrix() const
+{
+  return lightProjection;
+}
+
+AntProjection AntCamera::getCameraProjection() const
+{
+  return AntProjection(getModelview(),getProjection(),getViewport());
+}
+AntProjection AntCamera::getLightProjection() const
+{
+  return AntProjection(getLightView(),getLightProjectionMatrix(),getViewport());
+}
+
+void AntCamera::setWidth(int w)
+{
+  mWidth=w;
+  updateMatrices();
+}
+void AntCamera::setHeight(int h)
+{
+  mHeight=h;
+  updateMatrices();
+}

Added: antargis/branches/rant/ext/3dengine/ant_camera.h
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_camera.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ant_camera.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ant_camera.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef ANT_CAMERA_H
+#define ANT_CAMERA_H
+
+#include &lt;GLee.h&gt;
+
+#include &lt;ant_frustum.h&gt;
+#include &lt;ant_projection.h&gt;
+#include &lt;ag_rubyobj.h&gt;
+
+/**
+   \brief a camera object for moving over a height map
+   \ingroup Engine3d
+
+   This function provides functions for moving a camera about and
+   computation of the used 4x4-matrixes for camera-view and lighting (mainly used for shadows)
+ */
+
+
+class AntCamera
+{
+ public:
+  AntCamera(int w,int h);
+
+  void incCameraDistance();
+  void decCameraDistance();
+
+  Viewport getViewport() const;
+  AGMatrix4 getModelview() const;
+  AGMatrix4 getProjection() const;
+
+  /// affects scenePosition
+  void setPosition(const AGVector3 &amp;p);
+
+  /// returns absolute camera position
+  AGVector4 getCameraPosition() const;
+  AGVector4 getCameraPositionR() const;
+  AGVector4 getLightPosition() const;
+  AGVector3 getPosition() const;
+
+  int getWidth() const;
+  int getHeight() const;
+
+  void setWidth(int w);
+  void setHeight(int h);
+
+  AGMatrix4 getLightComplete() const;
+  AGMatrix4 getLightView() const;
+  AGMatrix4 getLightProjectionMatrix() const;
+
+  AntProjection getCameraProjection() const;
+  AntProjection getLightProjection() const;
+
+ private:
+
+  void updateMatrices();
+
+
+  /// this position is changed when moving around
+  AGVector4 scenePosition; 
+  /// camera and light position are fixed - to be understand as relative positions to scenePosition
+  AGVector4 cameraPosition;
+  AGVector4 lightPosition;
+
+  AGMatrix4 lightView,lightProjection;
+  AGMatrix4 cameraView,cameraProjection;
+
+  AGMatrix4 cameraPick;
+
+  /// use perspective shadow maps ?
+  bool mPSM; 
+
+  int mWidth,mHeight;
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/ant_projection.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_projection.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ant_projection.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,68 @@
+#include &quot;ant_projection.h&quot;
+
+#include &lt;GL/glu.h&gt;
+
+
+AntProjection::AntProjection(const AGMatrix4 &amp;pMv,const AGMatrix4 &amp;pPr,const Viewport &amp;pVp):
+  modelview(pMv),projection(pPr),viewport(pVp)
+{
+}
+
+AGVector3 AntProjection::project(const AGVector3 &amp;p) const
+{
+  GLdouble x,y,z;
+
+  GLdouble mv[16],pr[16];
+  for(int i=0;i&lt;16;i++)
+    { 
+      mv[i]=((const float*)modelview)[i];
+      pr[i]=((const float*)projection)[i];
+    }
+
+  gluProject(p[0],p[1],p[2],mv,pr,viewport,&amp;x,&amp;y,&amp;z);
+  return AGVector3(x,y,z);
+
+}
+AGVector3 AntProjection::unProject(const AGVector3 &amp;p) const
+{
+  GLdouble x,y,z;
+
+  GLdouble mv[16],pr[16];
+  for(int i=0;i&lt;16;i++)
+    { 
+      mv[i]=((const float*)modelview)[i];
+      pr[i]=((const float*)projection)[i];
+    }
+
+  gluUnProject(p[0],p[1],p[2],mv,pr,viewport,&amp;x,&amp;y,&amp;z);
+  return AGVector3(x,y,z);
+}
+
+
+AntFrustum AntProjection::getFrustum() const
+{
+  float w=viewport[2];
+  float h=viewport[3];
+  float d=1;
+  float d0=0;
+
+  AGVector3 p000(unProject(AGVector3(0,0,d0)));
+  AGVector3 p100(unProject(AGVector3(w,0,d0)));
+  AGVector3 p010(unProject(AGVector3(0,h,d0)));
+  AGVector3 p110(unProject(AGVector3(w,h,d0)));
+  AGVector3 p001(unProject(AGVector3(0,0,d)));
+  AGVector3 p101(unProject(AGVector3(w,0,d)));
+  AGVector3 p011(unProject(AGVector3(0,h,d)));
+  AGVector3 p111(unProject(AGVector3(w,h,d)));
+
+  std::vector&lt;AntPlane&gt; ps;
+
+  ps.push_back(makePlane(p000,p010,p100)); // front
+  ps.push_back(makePlane(p101,p111,p001)); // back
+  ps.push_back(makePlane(p010,p011,p110)); // top
+  ps.push_back(makePlane(p001,p000,p101)); // bottom
+  ps.push_back(makePlane(p001,p011,p000)); // left
+  ps.push_back(makePlane(p100,p110,p101)); // right
+
+  return AntFrustum(ps);
+}

Added: antargis/branches/rant/ext/3dengine/ant_projection.h
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_projection.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ant_projection.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,35 @@
+#ifndef ANT_PROJECTION_H
+#define ANT_PROJECTION_H
+
+#include &lt;GLee.h&gt;
+
+#include &lt;ant_frustum.h&gt;
+
+struct Viewport
+{
+  GLint viewport[4];
+#ifndef SWIG
+  (operator GLint *)() const
+  {
+    return const_cast&lt;Viewport*&gt;(this)-&gt;viewport;
+  }
+#endif
+};
+
+
+class AntProjection
+{
+ public:
+  AntProjection(const AGMatrix4 &amp;pMv,const AGMatrix4 &amp;pPr,const Viewport &amp;pVp);
+
+  AGVector3 project(const AGVector3 &amp;p) const;
+  AGVector3 unProject(const AGVector3 &amp;p) const;
+
+  AntFrustum getFrustum() const;
+
+ private:
+  AGMatrix4 modelview,projection;
+  Viewport viewport;
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/ant_renderer.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_renderer.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ant_renderer.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,381 @@
+#include &quot;ant_renderer.h&quot;
+#include &quot;scene.h&quot;
+#include &quot;ag_vdebug.h&quot;
+#include &quot;ag_kill.h&quot;
+#include &quot;ag_config.h&quot;
+#include &quot;ag_fbo.h&quot;
+
+Renderer *gRenderer=0;
+
+bool usePlainGL=true;
+
+Renderer::Renderer():
+  mCanMultitexture(-1),
+  mCanShadow(-1),
+  mCanGLSL(-1)
+{
+  mFBO=0;
+  CTRACE;
+  GLeeInit(); // this call is essential for letting glee work
+  assert(gRenderer==0);
+  gRenderer=this;
+  mScene=0;
+  
+  AGString shadowType=getConfig()-&gt;get(&quot;shadowType&quot;);
+  if(shadowType==&quot;big&quot; || shadowType==&quot;&quot;)
+    shadowMapSize=1024;
+  else if(shadowType==&quot;small&quot;)
+    shadowMapSize=512;
+  else
+    shadowMapSize=0;
+
+  switch(shadowMapSize)
+    {
+    case 0:
+      getConfig()-&gt;set(&quot;shadowType&quot;,&quot;none&quot;);break;
+    case 512:
+      getConfig()-&gt;set(&quot;shadowType&quot;,&quot;small&quot;);break;
+    case 1024:
+      getConfig()-&gt;set(&quot;shadowType&quot;,&quot;big&quot;);break;
+    }
+  
+
+  shadowInited=false;
+
+  if(!GLEE_EXT_texture3D)
+    std::cerr&lt;&lt;&quot;Sorry, Battles of Antargis won't work without GL_EXT_texture3D extension!&quot;&lt;&lt;std::endl;
+}
+
+Renderer::~Renderer()
+{
+  cdebug(&quot;gRenderer:&quot;&lt;&lt;gRenderer);
+  assert(gRenderer==this);
+  gRenderer=0;
+  delete mFBO;
+}
+
+bool Renderer::canMultitexture()
+{
+  if(mCanMultitexture&lt;0)
+    mCanMultitexture=GLEE_ARB_multitexture;
+  return mCanMultitexture;
+}
+
+bool Renderer::canShadow()
+{
+  if(mCanShadow&lt;0)
+    mCanShadow=(GLEE_ARB_shadow &amp;&amp; GLEE_ARB_shadow_ambient);
+  return mCanShadow &amp;&amp; shadowMapSize&gt;0;
+}
+
+bool Renderer::canGLSL()
+{
+  if(mCanGLSL&lt;0)
+    mCanGLSL=(GLEE_ARB_vertex_shader &amp;&amp; GLEE_ARB_fragment_shader &amp;&amp; GLEE_ARB_shading_language_100);
+  return mCanGLSL;
+}
+
+void Renderer::setCurrentScene(Scene *scene)
+{
+  mScene=scene;
+}
+
+Scene *Renderer::getCurrentScene()
+{
+  assert(mScene);
+  return mScene;
+}
+
+GLint Renderer::getShadowUnit()
+{
+  assert(canMultitexture());
+  return 3;
+}
+GLint Renderer::getNormalUnit()
+{
+  if(canMultitexture())
+    return 0;
+  else
+    return 0;
+}
+
+void Renderer::initShadowTexture()
+{
+  if(!canShadow())
+    return;
+
+  if(shadowInited)
+    return;
+
+  CTRACE;
+  glGenTextures(1, &amp;shadowMapTexture);
+  cdebug(1);
+  glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
+  //  glTexImage2D(   GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, shadowMapSize, shadowMapSize, 0,
+  //		  GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, NULL);
+  cdebug(2);
+
+  cdebug(shadowMapSize);
+  glTexImage2D(   GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT16, shadowMapSize, shadowMapSize, 0,
+		  GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, NULL);
+  cdebug(3);
+
+  assertGL;
+  cdebug(30);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //NEAREST);
+  cdebug(31);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); //NEAREST);
+  cdebug(32);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+  cdebug(33);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+  cdebug(4);
+  
+  glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
+  cdebug(5);
+
+  shadowInited=true;
+
+  if(canFBO())
+    {
+      mFBO=new AGFBO(shadowMapTexture,shadowMapSize,shadowMapSize);//,true);
+    }
+
+}
+
+void Renderer::beginShadowComputation()
+{
+  if(!shadowInited)
+    initShadowTexture();
+
+  if(mFBO)
+    {
+      mFBO-&gt;beginDraw();
+    }
+
+  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+  assertGL;
+  
+  
+  glMatrixMode(GL_PROJECTION);
+  glLoadMatrixf(getCurrentScene()-&gt;getLightProj());
+  
+  glMatrixMode(GL_MODELVIEW);
+  glLoadMatrixf(getCurrentScene()-&gt;getLightView());
+  
+  //Use viewport the same size as the shadow map
+  glViewport(0, 0, shadowMapSize, shadowMapSize);
+  
+  //Draw back faces into the shadow map
+  glCullFace(GL_FRONT);
+  glEnable(GL_CULL_FACE);
+  
+  //Disable color writes, and use flat shading for speed
+  glShadeModel(GL_FLAT);
+  glColorMask(0, 0, 0, 0);
+  
+  //Draw the scene
+  // Offset the drawing a little back, so that slopy surfaces don't get shadowed
+  glEnable(GL_POLYGON_OFFSET_FILL);
+  glPolygonOffset(1,1); // was 1,1
+
+  assertGL;
+
+}
+void Renderer::endShadowComputation()
+{
+  glDisable(GL_POLYGON_OFFSET_FILL);
+  assertGL;
+  //Read the depth buffer into the shadow map texture
+  glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
+  assertGL;
+
+  /// @todo switch to FBOs - this should bring an improvement of 17 to 19 fps
+
+    if(mFBO)
+      {
+	mFBO-&gt;endDraw();
+      }
+    else
+      {
+	glReadBuffer(GL_BACK);
+	
+	glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, 0, 0, shadowMapSize, shadowMapSize,0);
+	
+	glReadBuffer(GL_FRONT);
+      }
+
+  assertGL;
+
+
+  //restore states
+  assertGL;
+  glCullFace(GL_BACK);
+  
+  glShadeModel(GL_SMOOTH);
+  glColorMask(1, 1, 1, 1);
+}
+
+
+void Renderer::beginShadowDrawing()
+{
+  glActiveTexture(getShadowUnit());
+
+  glMatrixMode(GL_MODELVIEW);
+  // draw a flat shadow over 
+  //  glDisable(GL_LIGHTING);
+  //  glEnable(GL_COLOR_MATERIAL);
+  assertGL;
+  
+
+  if(usePlainGL)
+    {
+      //Calculate texture matrix for projection
+      //This matrix takes us from eye space to the light's clip space
+      //It is postmultiplied by the inverse of the current view matrix when specifying texgen
+      float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
+		    0.0f, 0.5f, 0.0f, 0.0f,
+		    0.0f, 0.0f, 0.5f, 0.0f,
+		    0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
+      static AGMatrix4 biasMatrix(bias);
+      AGMatrix4 textureMatrix=biasMatrix * getCurrentScene()-&gt;getLightProj() * getCurrentScene()-&gt;getLightView();
+      
+      //Set up texture coordinate generation.
+      glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+      assertGL;
+      glTexGenfv(GL_S, GL_EYE_PLANE, textureMatrix.getRow(0));
+      assertGL;
+      glEnable(GL_TEXTURE_GEN_S);
+      assertGL;
+      
+      glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+      assertGL;
+      glTexGenfv(GL_T, GL_EYE_PLANE, textureMatrix.getRow(1));
+      assertGL;
+      glEnable(GL_TEXTURE_GEN_T);
+      assertGL;
+      
+      glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+      assertGL;
+      glTexGenfv(GL_R, GL_EYE_PLANE, textureMatrix.getRow(2));
+      assertGL;
+      glEnable(GL_TEXTURE_GEN_R);
+      
+      assertGL;
+      glTexGeni(GL_Q, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+      assertGL;
+      glTexGenfv(GL_Q, GL_EYE_PLANE, textureMatrix.getRow(3));
+      assertGL;
+      glEnable(GL_TEXTURE_GEN_Q);
+      assertGL;
+    }
+  
+  //Bind &amp; enable shadow map texture
+  glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
+  glEnable(GL_TEXTURE_2D);
+  
+  //Enable shadow comparison
+  assertGL;
+
+  if(usePlainGL)
+    {
+            
+#ifndef OLD_SHADOW
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE);
+      assertGL;
+      //Shadow comparison should be true (ie not in shadow) if r&lt;=texture
+      //        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL); // not needed ???
+      assertGL;
+      
+      //Shadow comparison should generate an INTENSITY result
+      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
+      assertGL;
+      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE);//INTENSITY);
+      assertGL;
+      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 1.0f-0.3f);//shadowAlpha);
+      assertGL;
+      //      glColor4f(0,0,0,0.3);
+      assertGL;
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+      //      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+
+#else
+      glEnable(GL_TEXTURE_2D);
+      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE, GL_INTENSITY);  //set this to a &quot;depth texture&quot;
+      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 0.5f);      //set the compare fail value
+
+      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+      
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE_ARB);
+
+
+
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL); // not needed ???
+      assertGL;
+      
+      //Shadow comparison should generate an INTENSITY result
+      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
+      assertGL;
+      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE);//INTENSITY);
+
+
+
+        // Set up the eye plane for projecting the shadow map on the scene
+
+#endif
+      //Set alpha test to discard false comparisons
+      //  glAlphaFunc(GL_GREATER,0.99f);//LEQUAL, 0.999f);
+      //      glAlphaFunc(GL_GEQUAL, 0.99f);
+      //      glDisable(GL_ALPHA_TEST);
+
+      
+    }
+
+  glActiveTexture(getNormalUnit());
+  assertGL;
+
+}
+void Renderer::endShadowDrawing()
+{
+  assertGL;
+
+  glDisable(GL_POLYGON_OFFSET_FILL);
+
+  glActiveTexture(getShadowUnit());
+  glBindTexture(GL_TEXTURE_2D,0);
+
+  if(usePlainGL)
+    {
+      glDisable(GL_ALPHA_TEST);
+      glDisable(GL_TEXTURE_GEN_S);
+      glDisable(GL_TEXTURE_GEN_T);
+      glDisable(GL_TEXTURE_GEN_R);
+      glDisable(GL_TEXTURE_GEN_Q);
+    }
+  glActiveTexture(getNormalUnit());
+  assertGL;
+
+}
+
+
+bool Renderer::badShadowMap()
+{
+  return shadowMapSize==1024;
+}
+
+
+Renderer *getRenderer()
+{
+  if(!gRenderer)
+    {
+      gRenderer=new Renderer;
+      REGISTER_SINGLETON(gRenderer);
+    }
+  assert(gRenderer);
+  return gRenderer;
+}

Added: antargis/branches/rant/ext/3dengine/ant_renderer.h
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_renderer.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ant_renderer.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,56 @@
+#ifndef __RENDERER_H
+#define __RENDERER_H
+
+#include &quot;GLee.h&quot;
+
+class Scene;
+class AGFBO;
+
+class Renderer
+{
+  Renderer();
+ public:
+  ~Renderer();
+
+  bool canMultitexture();
+  bool canShadow();
+  bool canGLSL();
+
+  GLint getShadowUnit();
+  GLint getNormalUnit();
+
+  void setCurrentScene(Scene *scene);
+  Scene *getCurrentScene();
+
+  void initShadowTexture();
+  void beginShadowComputation();
+  void endShadowComputation();
+
+  void beginShadowDrawing();
+  void endShadowDrawing();
+
+  bool badShadowMap();
+  
+ private:
+
+  
+  int mCanMultitexture;
+  int mCanShadow;
+  int mCanGLSL;
+
+  GLuint shadowMapTexture;
+
+  AGFBO *mFBO;
+
+  int shadowMapSize;
+  bool shadowInited;
+
+  Scene *mScene;
+
+  friend Renderer *getRenderer();
+};
+
+Renderer *getRenderer();
+
+#endif
+

Added: antargis/branches/rant/ext/3dengine/glsl.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/glsl.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/glsl.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,370 @@
+#include &quot;glsl.h&quot;
+#include &quot;ag_vdebug.h&quot;
+#include &quot;ag_main.h&quot;
+#include &quot;scene.h&quot;
+/*
+std::map&lt;std::string,AntVertexProgram*&gt; mVertexPrograms2;
+std::map&lt;std::string,AntFragProgram*&gt; mFragPrograms2;
+
+AntVertexProgram *getVertexProgram(const std::string &amp;pFile)
+{
+  std::map&lt;std::string,AntVertexProgram*&gt;::iterator i=mVertexPrograms.find(pFile);
+
+  if(i==mVertexPrograms.end())
+    {
+      AntVertexProgram *p=new AntVertexProgram(pFile);
+      mVertexPrograms[pFile]=p;
+      return p;
+    }
+  return i-&gt;second;
+}
+
+AntFragProgram *getFragProgram(const std::string &amp;pFile)
+{
+  std::map&lt;std::string,AntFragProgram*&gt;::iterator i=mFragPrograms.find(pFile);
+
+  if(i==mFragPrograms.end())
+    {
+      AntFragProgram *p=new AntFragProgram(pFile);
+      mFragPrograms[pFile]=p;
+      return p;
+    }
+  return i-&gt;second;
+}
+*/
+
+bool glslOk();
+
+void printInfoLog(GLhandleARB obj);
+
+
+
+AntVertexProgram::AntVertexProgram(const std::string &amp;pFile)
+{
+  //  CTRACE;
+  if(glslOk())
+    {
+      vertexShader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
+      std::string s=loadFile(pFile);
+      
+      const char*a=s.c_str();
+      const GLcharARB**x=&a;
+      glShaderSourceARB(vertexShader, 1, x,NULL);
+      glCompileShaderARB(vertexShader);
+      printInfoLog(vertexShader);
+      
+    }
+}
+
+AntVertexProgram::~AntVertexProgram()
+{
+  CTRACE;
+  if(glslOk() &amp;&amp; !hasQuit())
+    glDeleteObjectARB(vertexShader);
+}
+
+AntFragProgram::AntFragProgram(const std::string &amp;pFile)
+{
+  mValid=false;
+  //  CTRACE;
+  if(glslOk() &amp;&amp; pFile.length()&gt;0)
+    {
+      fragShader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
+      std::string s=loadFile(pFile);
+      const char*a=s.c_str();
+      const GLcharARB**x=&a;
+      glShaderSourceARB(fragShader, 1, x,NULL);
+      glCompileShaderARB(fragShader);
+      printInfoLog(fragShader);
+      mValid=true;
+      
+    }
+}
+
+AntFragProgram::AntFragProgram()
+{
+  mValid=false;
+}
+
+AntFragProgram::~AntFragProgram()
+{
+  CTRACE;
+  if(glslOk() &amp;&amp; !hasQuit())
+    glDeleteObjectARB(fragShader);
+}
+
+
+bool AntFragProgram::valid() const
+{
+  return mValid;
+}
+
+
+AntShaderProgram::AntShaderProgram(const std::string &amp;pVertexFile,const std::string &amp;pFragFile):
+  //  vertex(getVertexProgram(pVertexFile)),frag(getFragProgram(pFragFile))
+  mVertexFile(pVertexFile),mFragFile(pFragFile),
+  vertex(0),frag(0)
+{
+  //  CTRACE;
+  on=false;
+  matrixBuf=new float[16*100];
+  name=pVertexFile+&quot;:&quot;+pFragFile;
+
+  init();
+}
+
+AntShaderProgram::~AntShaderProgram()
+{
+  takeDown();
+
+  delete [] matrixBuf;
+}
+
+void AntShaderProgram::onScreenUp()
+{
+  CTRACE;
+  init();
+}
+void AntShaderProgram::onScreenDown()
+{
+  CTRACE;
+  takeDown();
+}
+
+
+void AntShaderProgram::init()
+{
+ if(glslOk())
+    {
+      vertex=new AntVertexProgram(mVertexFile);
+      frag=new AntFragProgram(mFragFile);
+
+      p = glCreateProgramObjectARB();
+      glAttachObjectARB(p,vertex-&gt;vertexShader);
+      if(frag-&gt;valid())
+	glAttachObjectARB(p,frag-&gt;fragShader);
+      
+      glLinkProgramARB(p);
+      printInfoLog(p);
+
+      assert(p);
+    }
+}
+
+void AntShaderProgram::takeDown()
+{
+  disable();
+  CTRACE;
+  cdebug(&quot;name:&quot;&lt;&lt;name);
+  if(glslOk() &amp;&amp; !hasQuit())
+    glDeleteObjectARB(p);
+  cdebug(&quot;name:&quot;&lt;&lt;name);
+  cdebug(&quot;name:&quot;&lt;&lt;name);
+  delete vertex;
+  delete frag;
+}
+
+
+
+void AntShaderProgram::enable()
+{
+  if(glslOk())
+    {
+      glUseProgramObjectARB(p);
+      on=true;
+    }
+}
+void AntShaderProgram::disable()
+{
+  if(glslOk())
+    {
+      glUseProgramObjectARB(0);
+      on=false;
+    }
+}
+
+void AntShaderProgram::update(float time)
+{
+  if(glslOk())
+    {
+      enable();
+      doUpdate(time);
+      disable();
+    }
+}
+
+void AntShaderProgram::doUpdate(float time)
+{
+}
+
+void AntShaderProgram::sendUniform(const std::string &amp;pName,int i)
+{
+  glUniform1iARB(getLoc(pName),i);
+}
+void AntShaderProgram::sendUniform(const std::string &amp;pName,float f)
+{
+  glUniform1fARB(getLoc(pName),f);
+}
+void AntShaderProgram::sendUniform(const std::string &amp;pName,const AGVector3 &amp;m)
+{
+  glUniform3fARB(getLoc(pName),m[0],m[1],m[2]);
+}
+void AntShaderProgram::sendUniform(const std::string &amp;pName,const AGVector4 &amp;m)
+{
+  glUniform4fARB(getLoc(pName),m[0],m[1],m[2],m[3]);
+}
+void AntShaderProgram::sendUniform(const std::string &amp;pName,const AGMatrix4 &amp;m)
+{
+  glUniformMatrix4fvARB(getLoc(pName),1,false,m);
+}
+void AntShaderProgram::sendUniform(const std::string &amp;pName,const std::vector&lt;AGMatrix4&gt; &amp;m)
+{
+  assert(m.size()&lt;100);
+  float *p=matrixBuf;
+
+  for(size_t i=0;i&lt;m.size();i++)
+    {
+      const float *s=m[i];
+      for(size_t j=0;j&lt;16;j++)
+	*(p++)=*(s++);
+    }
+  assertGL;
+  glUniformMatrix4fvARB(getLoc(pName),m.size(),false,matrixBuf);
+  assertGL;
+}
+
+GLint AntShaderProgram::getLoc(const std::string &amp;pName)
+{
+  // register only once !
+  
+  std::map&lt;std::string,GLint&gt;::iterator i=locations.find(pName);
+  if(i!=locations.end())
+    return i-&gt;second;
+  
+  GLint k=glGetUniformLocationARB(p,pName.c_str());
+  locations.insert(std::make_pair(pName,k));
+  return k;
+}
+
+GLint AntShaderProgram::getAttr(const std::string &amp;pName)
+{
+  //  TRACE;
+  // register only once !
+  assert(on);
+  std::map&lt;std::string,GLint&gt;::iterator i=attrs.find(pName);
+  if(i!=attrs.end())
+    return i-&gt;second;
+  
+  assertGL;
+  GLint k=glGetAttribLocationARB(p,pName.c_str());
+  //  cdebug(&quot;k:&quot;&lt;&lt;k);
+  if(k&lt;0)
+    {
+      cdebug(&quot;ERROR:attribute could be get! Maybe it was not defined in the vertex-shader? :&quot;&lt;&lt;pName);
+    }
+  assertGL;
+  attrs.insert(std::make_pair(pName,k));
+  return k;
+}
+
+void AntShaderProgram::sendAttribute(const std::string &amp;pName,const std::vector&lt;float&gt; &amp;vf)
+{
+  assertGL;
+  GLint loc=getAttr(pName);
+  assertGL;
+  glEnableClientState(GL_VERTEX_ARRAY);
+  assertGL;
+  glEnableVertexAttribArrayARB(loc); // add array
+  assertGL;
+
+  glVertexAttribPointerARB(loc,1,GL_FLOAT,0,0,&amp;vf[0]); // set attributes (for each vertex an attribute)
+  assertGL;
+}
+
+
+
+///////////////////////////////////////////////////////////////////////////
+// AntShadowShader
+//
+///////////////////////////////////////////////////////////////////////////
+AntShadowShader::AntShadowShader(const std::string &amp;pVertexFile,const std::string &amp;pFragFile):
+	AntShaderProgram(pVertexFile,pFragFile)
+{
+}
+
+void AntShadowShader::doUpdate(float time)
+{
+  if(glslOk())
+    {
+      Renderer *r=getRenderer();
+      sendUniform(&quot;shadowTex&quot;,r-&gt;getShadowUnit());
+      sendUniform(&quot;normalTex&quot;,r-&gt;getNormalUnit());
+      sendUniform(&quot;lightComplete&quot;,r-&gt;getCurrentScene()-&gt;getLightComplete());
+    }
+}
+
+
+void AntShadowShader::enable()
+{
+  AntShaderProgram::enable();
+  if(glslOk())
+    {
+      Scene *scene=getRenderer()-&gt;getCurrentScene();
+
+      glActiveTexture(getRenderer()-&gt;getShadowUnit()); // shadow unit
+
+      glMatrixMode(GL_TEXTURE);
+      glPushMatrix();
+
+      // FIXME: move bias to frag-shader, as this shall reduce z-fighting
+      float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
+		0.0f, 0.5f, 0.0f, 0.0f,
+		0.0f, 0.0f, 0.5f, 0.0f,
+		0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
+      glLoadMatrixf(bias);
+
+      glMultMatrixf(scene-&gt;getLightProj());
+      glMultMatrixf(scene-&gt;getLightView());
+
+      glActiveTexture(getRenderer()-&gt;getNormalUnit()); // tex unit
+
+      glMatrixMode(GL_MODELVIEW);
+    }
+}
+void AntShadowShader::disable()
+{
+  AntShaderProgram::disable();
+  if(glslOk())
+    {
+      glActiveTexture(getRenderer()-&gt;getShadowUnit()); // shadow unit
+      glMatrixMode(GL_TEXTURE);
+      glPopMatrix();
+      glMatrixMode(GL_MODELVIEW);
+      glActiveTexture(getRenderer()-&gt;getNormalUnit()); // tex unit
+    }
+}
+
+
+///////////////////////////////////////////////////////////////////////////
+// AntWaterShader
+//
+///////////////////////////////////////////////////////////////////////////
+
+
+AntWaterShader::AntWaterShader():
+  AntShaderProgram(&quot;data/shaders/simplewater.vert&quot;,&quot;data/shaders/simplewater.frag&quot;)
+{
+}
+void AntWaterShader::doUpdate(float time)
+{
+  if(glslOk())
+    {
+      AntShaderProgram::doUpdate(time);
+      
+      t+=time;
+      sendUniform(&quot;time&quot;, t);
+    }
+}
+
+
+

Added: antargis/branches/rant/ext/3dengine/glsl.h
===================================================================
--- antargis/branches/rant/ext/3dengine/glsl.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/glsl.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,113 @@
+#ifndef ANT_GLSL_H
+#define ANT_GLSL_H
+
+#include &quot;ant_renderer.h&quot;
+#include &quot;ag_tools.h&quot;
+#include &quot;ag_geometry.h&quot;
+#include &quot;ag_glscreen.h&quot;
+
+#include &lt;map&gt;
+
+class Scene;
+
+class AntVertexProgram
+{
+ public:
+  AntVertexProgram(const std::string &amp;pFile);
+  ~AntVertexProgram();
+
+ private:
+  GLhandleARB vertexShader;
+
+  friend class AntShaderProgram;
+};
+
+class AntFragProgram
+{
+ public:
+  AntFragProgram(const std::string &amp;pFile);
+  AntFragProgram();
+  ~AntFragProgram();
+
+  bool valid() const;
+
+ private:
+  GLhandleARB fragShader;
+  bool mValid;
+
+  friend class AntShaderProgram;
+};
+
+
+class AntShaderParameter
+{
+ public:
+  
+};
+
+class AntShaderProgram:public AGGLObject
+{
+  std::string mVertexFile,mFragFile;
+  AntVertexProgram *vertex;
+  AntFragProgram *frag;
+  std::map&lt;std::string,GLint&gt; locations;
+  std::map&lt;std::string,GLint&gt; attrs;
+  float *matrixBuf;
+  bool on;
+  std::string name;
+
+ protected:  
+  GLhandleARB p;
+
+ public:
+  AntShaderProgram(const std::string &amp;pVertexFile,const std::string &amp;pFragFile);
+  virtual ~AntShaderProgram();
+  virtual void enable();
+  virtual void disable();
+
+  void update(float time);
+  virtual void doUpdate(float time);
+
+  GLint getLoc(const std::string &amp;pName);
+  GLint getAttr(const std::string &amp;pName);
+
+  void sendUniform(const std::string &amp;pName,int i);
+  void sendUniform(const std::string &amp;pName,float f);
+  void sendUniform(const std::string &amp;pName,const AGVector3 &amp;m);
+  void sendUniform(const std::string &amp;pName,const AGVector4 &amp;m);
+  void sendUniform(const std::string &amp;pName,const AGMatrix4 &amp;m);
+  void sendUniform(const std::string &amp;pName,const std::vector&lt;AGMatrix4&gt; &amp;m);
+
+  void sendAttribute(const std::string &amp;pName,const std::vector&lt;float&gt; &amp;vf);
+
+  void onScreenUp();
+  void onScreenDown();
+
+
+ private:
+  void check();
+  void init();
+  void takeDown();
+
+};
+
+class AntShadowShader:public AntShaderProgram
+{
+ public:
+  AntShadowShader(const std::string &amp;pVertexFile,const std::string &amp;pFragFile);
+  void doUpdate(float time);
+  virtual void enable();
+  virtual void disable();
+};
+
+class AntWaterShader:public AntShaderProgram
+{
+  float t;
+ public:
+  AntWaterShader();
+  void doUpdate(float time);
+};
+
+bool glslOk();
+
+#endif

Added: antargis/branches/rant/ext/3dengine/headers.hh
===================================================================
--- antargis/branches/rant/ext/3dengine/headers.hh	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/headers.hh	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,47 @@
+#ifndef __ANTARGIS_H__
+#define __ANTARGIS_H__
+#include &quot;ext/basic/ag_base.h&quot;
+#include &quot;ext/basic/ag_collector.h&quot;
+#include &quot;ext/basic/ag_config.h&quot;
+#include &quot;ext/basic/ag_debug.h&quot;
+#include &quot;ext/basic/ag_exception.h&quot;
+#include &quot;ext/basic/ag_fs.h&quot;
+#include &quot;ext/basic/ag_main.h&quot;
+#include &quot;ext/basic/ag_profiler.h&quot;
+#include &quot;ext/basic/ag_regex.h&quot;
+#include &quot;ext/basic/ag_rubyobj.h&quot;
+#include &quot;ext/basic/ag_rand_base.h&quot;
+#include &quot;ext/basic/ag_string.h&quot;
+#include &quot;ext/basic/ag_string_utf8.h&quot;
+#include &quot;ext/basic/ag_stringstream.h&quot;
+#include &quot;ext/basic/ag_tools.h&quot;
+#include &quot;ext/basic/ag_utf8.h&quot;
+#include &quot;ext/basic/ag_video_base.h&quot;
+#include &quot;ext/basic/ag_xml.h&quot;
+#include &quot;ext/basic/ag_plugin.h&quot;
+#include &quot;ext/basic/ag_singleton.h&quot;
+#include &quot;ext/basic/ag_kill.h&quot;
+#include &quot;ext/basic/ag_serial.h&quot;
+#include &quot;ext/basic/ag_messageobject.h&quot;
+#include &quot;ext/basic/ag_mutex.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/3dengine/mesh_data.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/3dengine/scene_base.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/3dengine/scenenode.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/3dengine/mesh_2d_data.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/3dengine/anim_mesh_data.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/3dengine/mesh.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/3dengine/mesh_2d.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/3dengine/scene.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/3dengine/anim_mesh.h&quot;
+#ifdef SWIG
+%include &quot;/home/david/projects/antargis/rant/ext/3dengine/mesh_data.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/3dengine/scene_base.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/3dengine/scenenode.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/3dengine/mesh_2d_data.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/3dengine/anim_mesh_data.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/3dengine/mesh.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/3dengine/mesh_2d.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/3dengine/scene.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/3dengine/anim_mesh.h&quot;
+#endif
+#endif

Added: antargis/branches/rant/ext/3dengine/init.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/init.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/init.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,7 @@
+#include &lt;ag_debug.h&gt;
+
+void AG_Init_libantargis3dengine()
+{
+  TRACE;
+}
+

Added: antargis/branches/rant/ext/3dengine/mesh.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,159 @@
+#include &quot;mesh.h&quot;
+
+#include &lt;map&gt;
+#include &lt;vector&gt;
+#include &lt;math.h&gt;
+#include &lt;ag_vdebug.h&gt;
+#include &lt;ag_texturecache.h&gt;
+#include &lt;ag_profiler.h&gt;
+
+
+
+
+//////////////////////////////////////////////////////////////////////
+// Mesh
+//////////////////////////////////////////////////////////////////////
+
+Mesh::Mesh(Scene *pScene):
+  SceneNode(pScene,AGVector4(),AGBox3())
+{
+  mData=0;
+  mRotation=0;
+  setOrder(MESH_Z);
+  mColor=AGVector4(1,1,1,1);
+  mVisible=true;
+}
+
+Mesh::Mesh(Scene *pScene,MeshData &amp;data,const AGVector4 &amp;pPos,float pRot):
+  SceneNode(pScene,pPos,data.bbox())
+{
+  mData=&data;
+  mRotation=pRot;
+  setOrder(MESH_Z);
+  mColor=AGVector4(1,1,1,1);
+  mVisible=true;
+}
+
+Mesh::~Mesh()
+{
+}
+
+void Mesh::draw()
+{
+  STACKTRACE;
+  if(!mVisible)
+    return;
+
+  begin();
+  if(mData)
+    {
+      mData-&gt;draw(mColor);
+    }
+  end();
+}
+void Mesh::drawDepth()
+{
+  STACKTRACE;
+  if(!mVisible)
+    return;
+  begin();
+  if(mData)
+    mData-&gt;drawDepth();
+  end();
+}
+void Mesh::drawShadow()
+{
+  STACKTRACE;
+  if(!mVisible)
+    return;
+  begin();
+  if(mData)
+    mData-&gt;drawShadow();
+  end();
+}
+
+size_t Mesh::getTriangles() const
+{
+  if(!mData)
+    return 0;
+  return mData-&gt;getTriangles();
+}
+
+void Mesh::begin()
+{
+  assertGL;
+
+  glPushMatrix();
+  AGVector4 p=getPos();
+  glTranslatef(p[0],p[1],p[2]);
+  glRotatef(mRotation,0.0,0.0,1.0);
+}
+void Mesh::end()
+{
+  glPopMatrix();
+}
+
+
+AGVector4 Mesh::lineHit(const AGLine3 &amp;pLine) const
+{
+  if(!mData)
+    return AGVector4(0,0,0,0);
+  AGMatrix4 rot(-mRotation*M_PI/180.0,AGVector3(0,0,1));
+  AGMatrix4 tr(-getPos());
+  AGMatrix4 complete=rot*tr;
+  
+  AGVector4 p0(pLine.getV0(),1);
+  AGVector4 p1(pLine.getV1(),1);
+  
+  p0=complete*p0;
+  p1=complete*p1;
+  return mData-&gt;lineHit(AGLine3(AGVector3(p0[0],p0[1],p0[2]),
+				AGVector3(p1[0],p1[1],p1[2])))+AGVector4(getPos().dim3(),0);
+}
+
+void Mesh::setRotation(float r)
+{
+  mRotation=r;
+}
+
+MeshData *Mesh::getData()
+{
+  return mData;
+}
+
+void Mesh::drawPick()
+{
+  STACKTRACE;
+
+  if(!mVisible)
+    return;
+  begin();
+
+  if(mData)
+    mData-&gt;drawPick();
+  end();
+}
+
+
+bool Mesh::transparent()
+{
+  assert(mData);
+  return mData-&gt;transparent();
+}
+
+
+void Mesh::mark()
+{
+  markObject(getData());
+}
+
+
+void Mesh::setColor(const AGVector4 &amp;pColor)
+{
+  mColor=pColor;
+}
+void Mesh::setVisible(bool v)
+{
+  mVisible=v;
+}
+

Added: antargis/branches/rant/ext/3dengine/mesh.h
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,58 @@
+#ifndef __MESH_H
+#define __MESH_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &quot;scene.h&quot;
+#include &quot;vertex_array.h&quot;
+
+#include &lt;map&gt;
+
+#include &quot;mesh_data.h&quot;
+
+/** A mesh is a scenenode, that displays a mesh ;)
+    ok, now for the real info.
+    it contains a MeshData object, color and positional information.
+    Actual drawing is done by MeshData.
+
+*/
+class Mesh:public SceneNode
+{
+  MeshData *mData;
+  float mRotation;
+  AGVector4 mColor;
+  bool mVisible;
+  
+ public:
+  Mesh(Scene *pScene);
+  Mesh(Scene *pScene,MeshData &amp;data,const AGVector4 &amp;pPos,float pRot);
+  virtual ~Mesh();
+
+  void draw();
+  void drawDepth();
+  void drawShadow();
+  void drawPick();
+
+  virtual AGVector4 lineHit(const AGLine3 &amp;pLine) const;
+
+  virtual size_t getTriangles() const;
+
+  /// set rotation around y-axis (e.g. turn people)
+  void setRotation(float r);
+  /// set color (for rings)
+  void setColor(const AGVector4 &amp;pColor); 
+  void setVisible(bool v);
+
+  MeshData *getData();
+
+  void mark();
+
+  virtual bool transparent();
+
+
+ private:
+  void begin();
+  void end();
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/mesh_2d.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_2d.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_2d.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,93 @@
+#include &quot;mesh_2d.h&quot;
+#include &lt;ag_debug.h&gt;
+#include &lt;ag_painter.h&gt;
+
+Mesh2D::Mesh2D(Scene2D *pScene):
+  SceneNode(pScene,AGVector4(),AGBox3())
+{
+}
+Mesh2D::Mesh2D(Scene2D *pScene,Mesh2DData &amp;data,const AGVector4 &amp;pPos,float pRot):
+  SceneNode(pScene,pPos,data.bbox()),
+  mData(&amp;data)
+{
+}
+Mesh2D::~Mesh2D()
+{
+}
+
+void Mesh2D::draw()
+{
+  Scene2D *s=dynamic_cast&lt;Scene2D*&gt;(getScene());
+  assert(s);
+  AGPainter *painter=s-&gt;getPainter();
+
+  assert(painter);
+
+  AGRect2 r=getDrawingRect();
+  AGTexture *t=mData-&gt;getTexture();
+
+  //  cdebug(&quot;r:&quot;&lt;&lt;r);
+  painter-&gt;blit(*t,r);
+}
+
+AGRect2 Mesh2D::getDrawingRect()
+{
+  Scene2D *s=dynamic_cast&lt;Scene2D*&gt;(getScene());
+  assert(s);
+
+  AGTexture *t=mData-&gt;getTexture();
+  AGVector2 middle(s-&gt;getPosition(getPos()));
+  float w=t-&gt;width();
+  float h=t-&gt;height();
+  AGRect2 r(middle.getX()-w/2,middle.getY()-h/2,w,h);
+
+  mLast=r;
+
+  return r;
+}
+
+AGRect2 Mesh2D::getLastDrawingRect()
+{
+  return mLast;
+}
+
+AGVector4 Mesh2D::lineHit(const AGLine3 &amp;pLine) const
+{
+  //FIXME
+  return AGVector4();
+}
+
+/// set rotation around y-axis (e.g. turn people)
+void Mesh2D::setRotation(float r)
+{
+}
+/// set color (for rings)
+void Mesh2D::setColor(const AGVector4 &amp;pColor)
+{
+}
+void Mesh2D::setVisible(bool v)
+{
+}
+
+Mesh2DData *Mesh2D::getData()
+{
+  return mData;
+}
+
+void Mesh2D::mark()
+{
+  markObject(mData);
+}
+
+bool Mesh2D::hit(const AGVector2 &amp;screenPos)
+{
+  AGRect2 dRect=getDrawingRect();
+  if(dRect.contains(screenPos))
+    {
+      // check if texture is !=transparent there
+      AGVector2 p=screenPos-dRect.getV0();
+      return mData-&gt;getTexture()-&gt;getPixel(p[0],p[1]).a&gt;10; // some threshold here
+      
+    }
+  return false;
+}

Added: antargis/branches/rant/ext/3dengine/mesh_2d.h
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_2d.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_2d.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,46 @@
+#ifndef MESH_2D_H
+#define MESH_2D_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &quot;scenenode.h&quot;
+#include &quot;scene_2d.h&quot;
+#include &quot;mesh_2d_data.h&quot;
+
+class Mesh2D:public SceneNode
+{
+ public:
+  Mesh2D(Scene2D *pScene);
+  Mesh2D(Scene2D *pScene,Mesh2DData &amp;data,const AGVector4 &amp;pPos,float pRot);
+  virtual ~Mesh2D();
+
+  void draw();
+
+  virtual AGVector4 lineHit(const AGLine3 &amp;pLine) const;
+
+  /// set rotation around y-axis (e.g. turn people)
+  void setRotation(float r);
+  /// set color (for rings)
+  void setColor(const AGVector4 &amp;pColor); 
+  void setVisible(bool v);
+
+  Mesh2DData *getData();
+
+  void mark();
+
+  bool hit(const AGVector2 &amp;screenPos);
+
+ public:
+
+  AGRect2 getDrawingRect();
+  AGRect2 getLastDrawingRect();
+
+  Mesh2DData *mData;
+
+
+ private:
+  AGRect2 mLast;
+};
+
+
+#endif

Added: antargis/branches/rant/ext/3dengine/mesh_2d_data.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_2d_data.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_2d_data.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,22 @@
+#include &quot;mesh_2d_data.h&quot;
+
+Mesh2DData::Mesh2DData(AGTexture *pTexture):
+  mTexture(pTexture)
+{
+}
+  
+void Mesh2DData::mark()
+{
+  markObject(mTexture);
+}
+
+AGTexture *Mesh2DData::getTexture()
+{
+  return mTexture;
+}
+
+AGBox3 Mesh2DData::bbox() const
+{
+  // FIXME
+  return AGBox3();
+}

Added: antargis/branches/rant/ext/3dengine/mesh_2d_data.h
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_2d_data.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_2d_data.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,23 @@
+#ifndef MESH_2D_DATA
+#define MESH_2D_DATA
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &lt;ag_texture.h&gt;
+
+class Mesh2DData:public AGRubyObject
+{
+ public:
+  Mesh2DData(AGTexture *pTexture);
+  
+  void mark();
+
+  AGTexture *getTexture();
+
+  AGBox3 bbox() const;
+
+ private:
+  AGTexture *mTexture;
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/mesh_data.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_data.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_data.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,391 @@
+#include &quot;mesh_data.h&quot;
+#include &lt;ag_texturecache.h&gt;
+#include &quot;mesh_optimizer.h&quot;
+#include &lt;ag_rendercontext.h&gt;
+
+#include &lt;ag_serial.h&gt;
+#include &lt;ag_main.h&gt;
+#include &lt;ag_vdebug.h&gt;
+
+//////////////////////////////////////////////////////////////////////
+// MeshData
+//////////////////////////////////////////////////////////////////////
+
+int getMeshDownScale(); // implemented in anim_mesh_data.cc
+
+
+MeshData::MeshData(const VertexArray &amp;va,const std::string &amp;pTexture,bool pShadow):mBBox(AGVector3(0,0,0),AGVector3(-1,0,0))
+{
+  CTRACE;
+  mArray=va;
+  mWithTexture=false;
+  if(pTexture!=&quot;&quot; &amp;&amp; videoInited())
+    {
+      mTexture=getTextureCache()-&gt;get(pTexture,getMeshDownScale());
+      mWithTexture=true;
+    }
+  mShadow=pShadow;
+  //  mAlpha=false;
+  mTransparent=false;
+  overdraw=false;
+  drawColors=true;
+  mPickable=true;
+  mLighting=true;
+  mCulling=true;
+}
+
+
+MeshData::MeshData(const std::string &amp;filename,float zoom,const std::string &amp;pTexture,bool pShadow):mBBox(AGVector3(0,0,0),AGVector3(-1,0,0))
+{
+  CTRACE;
+  Uint16 faces,meshes,vertices;
+  overdraw=false;
+
+  mTransparent=false;
+  mLighting=true;
+  mCulling=true;
+
+  //  mAlpha=false;
+
+  mWithTexture=false;
+  if(pTexture!=&quot;&quot; &amp;&amp; videoInited())
+    {
+      mTexture=getTextureCache()-&gt;get(pTexture,getMeshDownScale());
+      mWithTexture=true;
+    }
+  
+  MeshVertex mVertices[4];
+  MeshOptimizer opt;
+  bool withTex=filename.find(&quot;.ant2&quot;)!=filename.npos;
+
+  BinaryFileIn f(filename);
+  /*
+  
+  FILE *f=fopen(filename.c_str(),&quot;rb&quot;);
+  assert(f);
+  fread(&amp;meshes,sizeof(Uint16),1,f);*/
+
+  f&gt;&gt;meshes;
+  
+  for(;meshes&gt;0;meshes--)
+    {
+      f&gt;&gt;faces;
+      //      fread(&amp;faces,sizeof(Uint16),1,f);
+      
+      for(Uint16 i=0;i&lt;faces;i++)
+	{
+	  //  fread(&amp;vertices,sizeof(Uint16),1,f);
+	  f&gt;&gt;vertices;
+	  assert(vertices&lt;=4);
+	  for(Uint16 j=0;j&lt;vertices;j++)
+	    {
+	      AGVector3 v,n,c;
+	      f&gt;&gt;v;
+	      mVertices[j].v=AGVector4(v,1);
+	      f&gt;&gt;n;
+	      mVertices[j].n=n;
+	      f&gt;&gt;c; // load here first, as mVertices[.].c is a AGVector4
+	      mVertices[j].c=AGVector4(c,1);
+	      if(withTex)
+		f&gt;&gt;mVertices[j].t;
+
+	      mVertices[j].t[1]=1-mVertices[j].t[1];
+
+	      mVertices[j].v*=zoom;
+	      mVertices[j].v[3]=1;
+
+	      mBBox.include(mVertices[j].v.dim3());
+	      /*
+	      fread(mVertices[j].v,sizeof(float),3,f);
+	      fread(mVertices[j].n,sizeof(float),3,f);
+	      fread(mVertices[j].c,sizeof(float),3,f);
+	      if(withTex)
+		fread(mVertices[j].t,sizeof(float),2,f);
+	      mVertices[j].t[1]=1-mVertices[j].t[1];
+
+	      mVertices[j].v*=zoom;
+	      mVertices[j].v[3]=1;
+
+	      mBBox.include(mVertices[j].v.dim3());
+	      */
+	    }
+	  if(vertices==3)
+	    {
+	      opt.add(mVertices[0]);
+	      opt.add(mVertices[1]);
+	      opt.add(mVertices[2]);
+	    }
+	  else
+	    {
+	      opt.add(mVertices[0]);
+	      opt.add(mVertices[1]);
+	      opt.add(mVertices[2]);
+	      opt.add(mVertices[0]);
+	      opt.add(mVertices[2]);
+	      opt.add(mVertices[3]);
+	    }
+	}
+    }
+  //  fclose(f);
+  mShadow=pShadow;
+  mArray=opt.getArray();
+
+
+
+
+  drawColors=true;
+  mPickable=true;
+}
+
+MeshData::~MeshData()
+{
+  //  TRACE;
+}
+
+bool MeshData::transparent()
+{
+  return mTransparent;
+}
+
+void MeshData::setTransparent(bool p)
+{
+  mTransparent=p;
+}
+
+void MeshData::setLighting(bool l)
+{
+  mLighting=l;
+}
+
+AGBox3 MeshData::bbox() const
+{
+  return mBBox;
+}
+
+
+void MeshData::save(const std::string &amp;pFilename)
+{
+  FILE *f=fopen(pFilename.c_str(),&quot;wb&quot;);
+
+  size_t meshes=1;
+  size_t vertices=3;
+  size_t faces=mArray.getTriangles();
+
+  // meshes
+  fwrite(&amp;meshes,sizeof(Uint16),1,f);
+
+  // faces
+  fwrite(&amp;faces,sizeof(Uint16),1,f);
+  for(size_t i=0;i&lt;faces;i++)
+    {
+      fwrite(&amp;vertices,sizeof(Uint16),1,f);
+      for(size_t k=0;k&lt;vertices;k++)
+	{
+	  size_t j=mArray.getIndex(i*vertices+k);
+	  fwrite(mArray.getVertex(j),sizeof(float),3,f);
+	  fwrite(mArray.getNormal(j),sizeof(float),3,f);
+	  fwrite(mArray.getColor(j),sizeof(float),3,f);
+	  fwrite(mArray.getTexCoord(j),sizeof(float),2,f);
+	}
+    }
+
+  fclose(f);
+}
+
+
+void MeshData::setOverdraw(bool o)
+{
+  overdraw=o;
+}
+
+void MeshData::drawPick()
+{
+  if(mPickable)
+    mArray.drawPick();
+}
+#ifdef OLD
+void MeshData::draw()
+{
+  if(!mShadow)
+    glDepthMask(false);
+
+  if(mTransparent)
+    glDisable(GL_CULL_FACE);
+
+  glEnable(GL_ALPHA_TEST);
+  glAlphaFunc(GL_GREATER,0.9);
+
+
+  if(mLighting)
+    glEnable(GL_LIGHTING);
+  else
+    glDisable(GL_LIGHTING);
+
+  glBindTexture(GL_TEXTURE_2D,0);
+  glEnable(GL_COLOR_MATERIAL);
+  glColorMaterial(GL_FRONT,GL_AMBIENT_AND_DIFFUSE);
+  
+
+  if(mWithTexture)
+    glBindTexture(GL_TEXTURE_2D,mTexture.getTextureID());
+
+  if(mTransparent)
+    {
+      glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);//_MIPMAP_LINEAR);//NEAREST);//GL_LINEAR);
+
+      //      glDisable(GL_LIGHTING);
+      glAlphaFunc(GL_GREATER,0.4f);
+      glEnable(GL_ALPHA_TEST);
+    }
+  if(overdraw)
+    {
+      glDisable(GL_ALPHA_TEST);
+      glDisable(GL_DEPTH_TEST);
+    }
+  mArray.setColors(drawColors);
+  mArray.draw();
+  if(overdraw)
+    {
+      glEnable(GL_DEPTH_TEST);
+      glEnable(GL_ALPHA_TEST);
+    }
+  if(mTransparent)
+    {
+      glAlphaFunc(GL_GREATER,0.9f);
+      glEnable(GL_LIGHTING);
+    }
+  //    glEnable(GL_ALPHA_TEST);
+
+
+  glBindTexture(GL_TEXTURE_2D,0);
+  if(!mShadow)
+    glDepthMask(true);
+
+  glDisable(GL_ALPHA_TEST);
+  if(mTransparent)
+    glEnable(GL_CULL_FACE);
+}
+#else
+
+void MeshData::setCulling(bool c)
+{
+  mCulling=c;
+}
+
+
+void MeshData::draw(const AGVector4 &amp;pColor)
+{
+  AGRenderContext c;
+  
+  if(!mShadow)
+    c.setDepthWrite(false);
+
+  //  if(mTransparent)
+  c.setCulling(mCulling);
+
+  c.setAlpha(0.9,GL_GREATER);
+
+  c.setLighting(mLighting);
+
+  if(pColor!=AGVector4(1,1,1,1))
+    c.setColor(pColor);
+
+  if(mWithTexture)
+    c.setTexture(mTexture.glTexture());
+
+  if(mTransparent)
+    {
+      mTexture.setFilter(GL_LINEAR,GL_LINEAR);
+      c.setAlpha(0.4f,GL_GREATER);
+    }
+  if(overdraw)
+    {
+      c.setDepthWrite(false);
+      c.setDepthTest(false);
+      c.setAlpha(0,GL_NONE);
+    }
+  c.begin();
+  mArray.setColors(drawColors);
+  mArray.draw();
+}
+
+#endif
+
+
+void MeshData::setColors(bool c)
+{
+  drawColors=c;
+}
+
+size_t MeshData::getTriangles() const
+{
+  return mArray.getTriangles();
+}
+
+void MeshData::drawShadow()
+{
+  if(mTransparent)
+    glDisable(GL_CULL_FACE);
+
+  drawDepth();
+
+  if(mTransparent)
+    glEnable(GL_CULL_FACE);
+}
+void MeshData::drawDepth()
+{
+  assertGL;
+  AGRenderContext c;
+  if(mTransparent)
+    {
+      c.setCulling(false);
+      c.setAlpha(0.9f,GL_GREATER);
+      c.setTexture(mTexture.glTexture());
+      /*
+      glDisable(GL_CULL_FACE);
+      //      throw int();
+
+      glBindTexture(GL_TEXTURE_2D,mTexture.getTextureID());
+      glEnable(GL_ALPHA_TEST);
+      glAlphaFunc(GL_GREATER,0.9f);
+      */
+      //      cdebug(&quot;muh&quot;);
+    }
+  c.begin();
+  assertGL;
+  if(mShadow)
+    {
+      mArray.setColors(false);
+      mArray.draw();
+      mArray.setColors(true);
+    }
+  /*  if(mTransparent)
+    {
+      glEnable(GL_CULL_FACE);
+      glBindTexture(GL_TEXTURE_2D,0);
+      }*/
+}
+
+void MeshData::texCoordFromPos(float scale)
+{
+  for(size_t i=0;i&lt;mArray.getTriangles()*3;i++)
+    {
+      size_t j=mArray.getIndex(i);
+
+      AGVector4 v=mArray.getVertex(j);
+      AGVector2 t(v[0]+v[1],v[2]);
+      mArray.setTexCoord(j,t*scale);
+    }
+}
+
+void MeshData::setPickable(bool p)
+{
+  mPickable=p;
+}
+
+void MeshData::makeInstances(const std::vector&lt;AGMatrix4&gt; &amp;ts)
+{
+  VertexArray *va=::makeInstances(mArray,ts);
+  mArray=*va;
+  delete va;
+}

Added: antargis/branches/rant/ext/3dengine/mesh_data.h
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_data.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_data.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,67 @@
+#ifndef MESH_DATA_H
+#define MESH_DATA_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &quot;scenenode.h&quot;
+#include &quot;mesh_data.h&quot;
+#include &quot;vertex_array.h&quot;
+#include &quot;ag_texture.h&quot;
+
+// Mesh organizing
+
+class MeshData:public AGRubyObject
+{
+  VertexArray mArray;
+  AGTexture mTexture;
+  bool mWithTexture;
+  bool mShadow;
+
+  AGBox3 mBBox;
+
+  bool mTransparent;
+
+  bool overdraw;
+  bool drawColors;
+  bool mPickable;
+  bool mLighting;
+  bool mCulling;
+
+ public:
+  MeshData(const std::string &amp;filename,float zoom,const std::string &amp;pTexture=&quot;&quot;,bool pShadow=true);
+  MeshData(const VertexArray &amp;va,const std::string &amp;pTexture,bool pShadow=true);
+  ~MeshData();
+
+  void draw(const AGVector4 &amp;pColor);
+  void drawShadow();
+  void drawDepth();
+  void drawPick();
+
+  /// test function &quot;instancing&quot;
+  void makeInstances(const std::vector&lt;AGMatrix4&gt; &amp;ts);
+
+
+  AGBox3 bbox() const;
+
+  void save(const std::string &amp;pFilename);
+
+  virtual size_t getTriangles() const;
+
+  virtual AGVector4 lineHit(const AGLine3 &amp;pLine) const
+  {
+    return mArray.lineHit(pLine);
+  }
+  void texCoordFromPos(float scale);
+  void setPickable(bool p);
+
+  void setTransparent(bool p);
+  virtual bool transparent();
+  void setLighting(bool l);
+
+  void setOverdraw(bool o);
+  void setCulling(bool c);
+  void setColors(bool c);
+};
+
+
+#endif

Added: antargis/branches/rant/ext/3dengine/mesh_optimizer.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_optimizer.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_optimizer.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,175 @@
+#include &quot;mesh_optimizer.h&quot;
+#include &lt;ag_debug.h&gt;
+#include &lt;ag_serial.h&gt;
+
+//////////////////////////////////////////////////////////////////////
+// Mesh-optimizing
+//////////////////////////////////////////////////////////////////////
+
+// sorting
+bool MeshVertex::operator&lt;(const MeshVertex &amp;p) const
+{
+  int i;
+  for(i=0;i&lt;3;i++)
+    if(v[i]&lt;p.v[i])
+      return true;
+  
+  for(i=0;i&lt;4;i++)
+    if(c[i]&lt;p.c[i])
+      return true;
+  
+  for(i=0;i&lt;3;i++) 
+    if(n[i]&lt;p.n[i]) 
+      return true; 
+  
+  for(i=0;i&lt;2;i++)
+    if(t[i]&lt;p.t[i]) 
+      return true;
+  
+    return false;
+}
+
+
+MeshOptimizer::MeshOptimizer()
+{
+  saved=0;
+}
+void MeshOptimizer::add(const MeshVertex &amp;v)
+{
+  size_t index=mVertices.size();
+  std::map&lt;MeshVertex,int&gt;::iterator i=mMap.find(v);
+  if(i!=mMap.end())
+    {
+      saved++;
+      index=i-&gt;second;
+    }
+  else
+    {
+      mVertices.push_back(v);
+      mMap[v]=index;
+    }
+  assert(index&lt;mVertices.size());
+  mIndices.push_back(index);
+  return;
+}
+
+
+struct MeshTriangle
+{
+  size_t i0,i1,i2;
+  MeshTriangle(size_t p0,size_t p1,size_t p2)
+  {
+    i0=p0;
+    i1=p1;
+    i2=p2;
+  }
+
+  bool operator&lt;(const MeshTriangle &amp;t) const;
+};
+
+struct TriCompare
+{
+  MeshOptimizer *o;
+  AGVector3 c;
+  TriCompare(MeshOptimizer *p,AGVector3 cam):o(p),c(cam)
+  {
+  }
+  bool operator()(const MeshTriangle &amp;t1,const MeshTriangle &amp;t2)
+  {
+    AGVector3 m0=(o-&gt;getV(t1.i0).dim3()+o-&gt;getV(t1.i1).dim3()+o-&gt;getV(t1.i2).dim3())/3.0;
+    AGVector3 m1=(o-&gt;getV(t2.i0).dim3()+o-&gt;getV(t2.i1).dim3()+o-&gt;getV(t2.i2).dim3())/3.0;
+
+    return (c-m0).length2()&gt;(c-m1).length2();
+  }
+};
+
+
+
+VertexArray MeshOptimizer::getArray()
+{
+  CTRACE;
+  VertexArray a;
+  for(size_t i=0;i&lt;mVertices.size();i++)
+    {
+      MeshVertex v=mVertices[i];
+      a.addVertex(v.v,v.c,v.n,v.t);
+    }
+
+  std::vector&lt;MeshTriangle&gt; tris;
+  for(size_t i=0;i&lt;mIndices.size();i+=3)
+    {
+      tris.push_back(MeshTriangle(mIndices[i],mIndices[i+1],mIndices[i+2]));
+    }  
+  sort(tris.begin(),tris.end(),TriCompare(this,AGVector3(0,-10,10)));
+
+  for(std::vector&lt;MeshTriangle&gt;::iterator i=tris.begin();i!=tris.end();i++)
+    a.addTriangle(i-&gt;i0,i-&gt;i1,i-&gt;i2);
+
+
+  if(mIndices.size()==0)
+    cdebug(&quot;NO TRIANGLES FOUND!&quot;);
+  cdebug(&quot;SAVED:&quot;&lt;&lt;1.0f-float(saved)/mIndices.size());
+  return a;
+}
+
+AGVector4 MeshOptimizer::getV(size_t i)
+{
+  return mVertices[i].v;
+}
+
+
+MeshOptimizer loadFromText(const std::string &amp;pText, bool withTex, float zoom)
+{
+  MeshOptimizer opt;
+  MeshVertex mVertices[4];
+
+  BinaryStringIn in(pText);
+
+  Uint16 meshes,faces,vertices;
+  AGVector3 v;
+
+  in&gt;&gt;meshes;
+  cdebug(&quot;meshes:&quot;&lt;&lt;meshes);
+  for(;meshes&gt;0;meshes--)
+    {
+      in&gt;&gt;faces;
+      cdebug(&quot;faces:&quot;&lt;&lt;faces);
+      for(Uint16 i=0;i&lt;faces;i++)
+	{
+	  in&gt;&gt;vertices;
+	  cdebug(&quot;vs:&quot;&lt;&lt;vertices);
+	  assert(vertices&lt;=4);
+	  for(Uint16 j=0;j&lt;vertices;j++)
+	    {
+	      in&gt;&gt;v;
+	      mVertices[j].v=AGVector4(v,1);
+	      //	      cdebug(&quot;v:&quot;&lt;&lt;mVertices[j].v.toString());
+	      in&gt;&gt;mVertices[j].n;
+	      in&gt;&gt;v;
+	      mVertices[j].c=AGVector4(v,1);
+	      if(withTex)
+		in&gt;&gt;mVertices[j].t;
+	      mVertices[j].v*=zoom;
+	      mVertices[j].v[3]=1;
+	    }
+	  if(vertices==3)
+	    {
+	      opt.add(mVertices[0]);
+	      opt.add(mVertices[1]);
+	      opt.add(mVertices[2]);
+	    }
+	  else
+	    {
+	      opt.add(mVertices[0]);
+	      opt.add(mVertices[1]);
+	      opt.add(mVertices[2]);
+	      opt.add(mVertices[0]);
+	      opt.add(mVertices[2]);
+	      opt.add(mVertices[3]);
+	    }
+	}
+    }
+
+
+  return opt;
+}

Added: antargis/branches/rant/ext/3dengine/mesh_optimizer.h
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_optimizer.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_optimizer.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,53 @@
+#ifndef MESH_OPTIMIZER
+#define MESH_OPTIMIZER
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &quot;ag_geometry.h&quot;
+#include &quot;vertex_array.h&quot;
+
+#include &lt;map&gt;
+
+/** This file provides functionality for:
+    building of an indexed mesh out of a set of (vertex,color,normal,tex2dcoords)
+    each 3 of them a triangle. Similar vertices will be joined automatically.
+    Use it like this:
+    
+    1) generate a MeshOptimizer objet
+    2) add 3*n vertices
+    3) get a VertexArray by calling getArray()
+*/
+
+struct MeshVertex
+{
+  AGVector4 v,c;
+  AGVector3 n;
+  AGVector2 t;
+
+  // sorting
+  bool operator&lt;(const MeshVertex &amp;p) const;
+};
+
+// generates index list for same vertices (with same colors/normals..)
+class MeshOptimizer
+{
+  std::map&lt;MeshVertex,int&gt; mMap;
+  std::vector&lt;int&gt; mIndices;
+
+  std::vector&lt;MeshVertex&gt; mVertices;
+  int saved;
+ public:
+  MeshOptimizer();
+
+  void add(const MeshVertex &amp;v);
+  VertexArray getArray();
+
+  AGVector4 getV(size_t i);
+};
+
+
+// some old function ???
+// used in gen_tree ?? this gen_tree shouldn't be used anymore, too
+MeshOptimizer loadFromText(const std::string &amp;pText, bool withTex, float zoom);
+
+#endif

Added: antargis/branches/rant/ext/3dengine/mesh_sort.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_sort.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_sort.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,23 @@
+#include &quot;mesh_sort.h&quot;
+
+
+bool SortDistance::operator()(const SceneNode *n1,const SceneNode *n2)
+{
+  AGVector3 m1=const_cast&lt;SceneNode*&gt;(n1)-&gt;bbox().base+const_cast&lt;SceneNode*&gt;(n1)-&gt;bbox().dir*0.5;
+  AGVector3 m2=const_cast&lt;SceneNode*&gt;(n2)-&gt;bbox().base+const_cast&lt;SceneNode*&gt;(n2)-&gt;bbox().dir*0.5;
+  
+  return (m1-cam).length2()&lt;(m2-cam).length2();
+}
+
+bool SortOrder::operator()(const SceneNode *n1,const SceneNode *n2)
+{
+  return n1-&gt;getOrder()&lt;n2-&gt;getOrder();
+}
+
+
+
+bool SortYCoord::operator()(const SceneNode *n1,const SceneNode *n2)
+{
+  //  return n1-&gt;getPos()[1]&gt;n2-&gt;getPos()[1];
+  return n1-&gt;getOrder()&lt;n2-&gt;getOrder() || (n1-&gt;getOrder()==n2-&gt;getOrder() &amp;&amp; n1-&gt;getPos()[1]&gt;n2-&gt;getPos()[1]);
+}

Added: antargis/branches/rant/ext/3dengine/mesh_sort.h
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_sort.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_sort.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,41 @@
+#ifndef MESH_SORT_H
+#define MESH_SORT_H
+
+#include &lt;ag_geometry.h&gt;
+#include &quot;scenenode.h&quot;
+
+/**
+   The class is for sorting purpose only. It provides the operator() function, that's needed
+   for the STL-sorting algorithms.
+   Here SceneNodes are sorted by their middle distance the camera.
+*/
+class SortDistance
+{
+  AGVector3 cam;
+public:
+  SortDistance(AGVector3 c):cam(c){}
+
+  bool operator()(const SceneNode *n1,const SceneNode *n2);
+};
+
+/**
+   This is a sorting class, too. It sorts by the given &quot;SortOrder&quot; of the scene-nodes
+*/
+class SortOrder
+{
+public:
+  SortOrder(){}
+
+  bool operator()(const SceneNode *n1,const SceneNode *n2);
+};
+
+class SortYCoord
+{
+ public:
+  SortYCoord(){}
+  
+  bool operator()(const SceneNode *n1,const SceneNode *n2);
+};
+
+
+#endif

Added: antargis/branches/rant/ext/3dengine/quadtree.h
===================================================================
--- antargis/branches/rant/ext/3dengine/quadtree.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/quadtree.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * quadtree.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef QUADTREE_H
+#define QUADTREE_H
+
+#include &lt;ag_geometry.h&gt;
+#include &lt;ag_debug.h&gt;
+
+#include &lt;set&gt;
+
+/**
+   sadly enough C++ still doesn't support templating in out of object files...
+
+   This is a simple quad-tree, that's based upon some &quot;unknown object&quot;, that must contain
+   these functions:
+   * getRect()
+   * any more ???
+   The Rectangles are defined with AGRect2.
+
+   QuadTree doesn't own objects - you have to delete them yourself
+
+*/
+template&lt;class T&gt;
+class QuadTree
+  {
+    // ignore this node-structure - it works ;-)
+    struct Node
+      {
+        std::set
+          &lt;T*&gt; ts;
+        std::list&lt;Node*&gt; children;
+        AGRect2 r;
+
+        Node(AGRect2 R):r(R)
+      {}
+
+	~Node()
+	{
+	  for(typename std::list&lt;Node*&gt;::iterator i=children.begin();i!=children.end();++i)
+	    delete *i;
+	}
+
+	size_t size() const
+	{
+	  size_t s=ts.size();
+	  for(typename std::list&lt;Node*&gt;::const_iterator i=children.begin();i!=children.end();i++)
+	    s+=(*i)-&gt;size();
+	  return s;
+	}
+	void getAll(std::list&lt;T*&gt; &amp;l)
+	{
+	  std::copy(ts.begin(),ts.end(),std::back_inserter(l));
+	  for(typename std::list&lt;Node*&gt;::iterator i=children.begin();i!=children.end();i++)
+	    (*i)-&gt;getAll(l);
+	}
+      
+        void get(const AGRect2 &amp;pr,std::list&lt;T*&gt; &amp;l)
+        {
+          typename std::set&lt;T*&gt;::iterator i=ts.begin();
+          for(;i!=ts.end();i++)
+            l.push_back(*i);
+            
+          typename std::list&lt;Node*&gt;::iterator j=children.begin();
+          for(;j!=children.end();j++)
+            if((*j)-&gt;r.collide(pr))
+              (*j)-&gt;get(pr,l);
+        }
+
+        void insert(T* t)
+        {
+          if(children.size())
+            {
+              typename std::list&lt;Node*&gt;::iterator i=children.begin();
+              for(;i!=children.end();i++)
+                if((*i)-&gt;r.contains(t-&gt;getRect()))
+                  {
+                    (*i)-&gt;insert(t);
+                    return;
+                  }
+            }
+          ts.insert(t);
+	  if(ts.size()&gt;2 &amp;&amp; children.size()==0 &amp;&amp; r.w()&gt;3 &amp;&amp; r.h()&gt;3)
+	    split();
+        }
+        
+        void clear()
+        {
+          typename std::list&lt;Node*&gt;::iterator i=children.begin();
+          for(;i!=children.end();i++)
+          {
+            (*i)-&gt;clear();
+            delete *i;
+          }
+          children.clear();
+
+          ts.clear();
+          
+        }
+
+        void split()
+        {
+          std::set
+            &lt;T*&gt; ot=ts;
+          ts.clear();
+          std::list&lt;AGRect2&gt; rs=r.split();
+          std::list&lt;AGRect2&gt;::iterator i=rs.begin();
+          for(;i!=rs.end();i++)
+            {
+              children.push_back(new Node(*i));
+            }
+          typename std::set
+            &lt;T*&gt;::iterator j=ot.begin();
+          for(;j!=ot.end();j++)
+            insert(*j);
+        }
+
+        bool remove
+          (T* t)
+          {
+            if(ts.find(t)!=ts.end())
+              {
+                ts.erase(t);
+                return true;
+              }
+            if(children.size())
+              {
+                typename std::list&lt;Node*&gt;::iterator i=children.begin();
+                for(;i!=children.end();i++)
+                  {
+                    if((*i)-&gt;r.contains(t-&gt;getRect()))
+		      return (*i)-&gt;remove(t);
+                  }
+              }
+	    return false;
+          }
+
+      };
+
+    Node *root;
+
+  public:
+
+    /**
+     * A quadtree tiles big rectangles into smaller ones. Elements get inserted into the smallest rectangle that contains an element.
+     * So you have a starting-rectangle
+     * @param r Starting rectangle, that gets tiled. This should contain everything that you want to store here. But don't make this
+     *  rectangle too big, because otherwise must be tiled several times before even one object can be inserted.
+    */
+
+    QuadTree(AGRect2 r)
+    {
+      root=new Node(r);
+    }
+    ~QuadTree()
+      {
+	delete root;
+      }
+
+    /**
+       insert an object
+       @param t the object you want to insert
+    */
+    void insert(T* t)
+    {
+      root-&gt;insert(t);
+    }
+
+    /// get all the objects - should be used at all (only testing purpose)
+    std::list&lt;T*&gt; getAll()
+      {
+	std::list&lt;T*&gt; l;
+	root-&gt;getAll(l);
+	return l;
+      }
+    
+    /// this one you should call - get all objects, that intersect (or are included in) this rectangle
+    std::list&lt;T*&gt; get(const AGRect2 &amp;r)
+    {
+      std::list&lt;T*&gt; l;
+      root-&gt;get(r,l);
+      return l;
+    }
+    
+    /// remove some object
+    bool remove
+      (T* t)
+      {
+	if(t)
+	  return root-&gt;remove(t);
+	return false;
+      }
+      
+    /// empty this tree!
+    void clear()
+    {
+      root-&gt;clear();
+    }
+    size_t size() const
+    {
+      return root-&gt;size();
+    }
+  };
+
+#endif

Added: antargis/branches/rant/ext/3dengine/scene.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/scene.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scene.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,536 @@
+#include &quot;ant_renderer.h&quot;
+#include &quot;scene.h&quot;
+
+#include &lt;GL/gl.h&gt;
+#include &lt;GL/glu.h&gt;
+
+#include &lt;ag_debug.h&gt;
+#include &lt;ag_vdebug.h&gt;
+#include &lt;ag_video.h&gt;
+#include &lt;ag_rendercontext.h&gt;
+#include &lt;algorithm&gt;
+
+#include &lt;math.h&gt;
+
+#include &quot;quadtree.h&quot;
+#include &quot;ag_profiler.h&quot;
+#include &quot;ag_main.h&quot;
+#include &quot;mesh_sort.h&quot;
+
+bool PickNode::operator&lt;(const PickNode &amp;n) const
+{
+  return camDist&lt;n.camDist;
+}
+
+
+
+Scene::Scene(int w,int h):
+  SceneBase(w,h)
+{
+  white=AGVector4(1,1,1,1);
+  black=AGVector4(0,0,0,1);
+  
+  cdebug(&quot;SHADOW:&quot;&lt;&lt;(int)GLEE_ARB_shadow);
+  cdebug(&quot;SHADOW_AMB:&quot;&lt;&lt;(int)GLEE_ARB_shadow_ambient);
+  
+  GLeeInit();
+  
+  if(getRenderer()-&gt;canShadow())
+    mShadow=1;
+  else
+    mShadow=0;
+  
+  mRubyObject=false;
+  mEnabled=true;
+
+}
+
+
+Scene::~Scene()
+{
+}
+
+size_t Scene::getDrawnMeshes() const
+{
+  return mMeshes;
+}
+
+size_t Scene::getTriangles() const
+{
+  return mTriangles;
+}
+
+size_t Scene::getPickTriangles() const
+{
+  return mPickTriangles;
+}
+
+
+void Scene::draw()
+{
+  if(!mEnabled)
+    return;
+  AGRenderContext c;
+  c.begin(); // reset gl-state
+
+  getRenderer()-&gt;setCurrentScene(this);
+  assertGL;
+
+  mMeshes=0;
+  mTriangles=0;
+  mPickTriangles=0;
+
+  for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
+    (*i)-&gt;sort(AGVector4(mCamera.getPosition(),1));
+  
+  if(mShadow)
+    {
+      calcShadowMap();
+      initScene();
+      drawShadow();
+    }
+  else
+    {
+      initScene();
+      drawScene();
+    }
+
+  getRenderer()-&gt;setCurrentScene(0);
+}
+
+void Scene::setShadow(int v)
+{
+  if(getRenderer()-&gt;canShadow())
+    {
+      mShadow=v;
+      cdebug(mShadow);
+    }
+}
+int Scene::getShadow() const
+{
+  return mShadow;
+}
+
+
+
+
+Scene::NodeList Scene::getCurrentNodes()
+{
+  STACKTRACE;
+  AGVector2 p=mCamera.getPosition().dim2();
+  NodeList l=mTree-&gt;get(AGRect2(p+AGVector2(-30,-30),p+AGVector2(30,30)));
+
+  for(NodeList::iterator i=l.begin();i!=l.end();i++)
+    {
+      if(mNodeSet.find(*i)==mNodeSet.end())
+	cdebug(&quot;ERROR:&quot;&lt;&lt;*i);
+      assert(mNodeSet.find(*i)!=mNodeSet.end());
+    }
+  return l;
+}
+
+
+void Scene::calcShadowMap()
+{
+  STACKTRACE;
+  assertGL;
+  //  AGMatrix4 frustum=getFrustum();
+  size_t shadowMeshes=0;
+
+  getRenderer()-&gt;beginShadowComputation();
+
+  {
+    STACKTRACE;
+    NodeList l=getCurrentNodes();
+    Nodes sorted;
+    std::copy(l.rbegin(),l.rend(),std::back_inserter(sorted));
+    
+
+    {
+      // apply frustrum culling
+      AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
+      for(Nodes::iterator i=sorted.begin();i!=sorted.end();)
+	{
+	  if(cFrustum.collides((*i)-&gt;bbox()))
+	    i++;
+	  else
+	    i=sorted.erase(i);
+	}
+    }
+
+    sort(sorted.begin(),sorted.end(),SortOrder());
+      
+    for(Nodes::iterator i=sorted.begin();i!=sorted.end();i++)
+      {
+	{
+	  if((*i)-&gt;visible())
+	    {
+	      (*i)-&gt;drawDepth();
+	      mTriangles+=(*i)-&gt;getTriangles();
+	      shadowMeshes++;
+	    }
+	}
+    }
+  }
+  //  cdebug(&quot;shadowMeshes:&quot;&lt;&lt;shadowMeshes);
+
+  getRenderer()-&gt;endShadowComputation();
+  assertGL;
+}
+
+/**
+   setups up lighting and gl-matrices (projection and such)
+*/
+void Scene::initScene()
+{
+  glClear(GL_DEPTH_BUFFER_BIT);
+  
+  glMatrixMode(GL_PROJECTION);
+  glLoadMatrixf(mCamera.getProjection());
+  
+  glMatrixMode(GL_MODELVIEW);
+  glLoadIdentity();
+
+  float xfactor=float(getVideo()-&gt;realWidth())/getVideo()-&gt;width();
+  float yfactor=float(getVideo()-&gt;realHeight())/getVideo()-&gt;height();
+  
+  glViewport(0, 0,(GLint)(mCamera.getWidth()*xfactor), (GLint)(mCamera.getHeight()*yfactor));
+  
+  //Use dim light to represent shadowed areas
+
+  AGVector4 l=mCamera.getLightPosition();
+  l[3]=1;
+
+  glLightfv(GL_LIGHT1, GL_POSITION, l);
+  glLightfv(GL_LIGHT1, GL_AMBIENT, AGVector4(0.1,0.1,0.1,1));//white*0.05f);
+  glLightfv(GL_LIGHT1, GL_DIFFUSE, AGVector4(0.3,0.3,0.3,1));//white*0.3f);//*0.2f);
+  glLightfv(GL_LIGHT1, GL_SPECULAR, black);
+  glEnable(GL_LIGHT1);
+
+  AGVector4 lightPosition2=AGVector4( 0, 0, -50,1);
+
+  //  glLightfv(GL_LIGHT2, GL_POSITION, lightPosition2+scenePosition);
+  glLightfv(GL_LIGHT2, GL_AMBIENT, black);
+  glLightfv(GL_LIGHT2, GL_DIFFUSE, AGVector4(0.7,0.7,0.7,1));//white*0.7f);//*0.2f);
+  glLightfv(GL_LIGHT2, GL_SPECULAR, white);
+  glLightfv(GL_LIGHT2, GL_SPOT_DIRECTION, AGVector4(0,0,-1,0));
+  glLightf(GL_LIGHT2,GL_LINEAR_ATTENUATION,0);
+  glLightf(GL_LIGHT2,GL_QUADRATIC_ATTENUATION,0);
+  glLightf(GL_LIGHT2,GL_CONSTANT_ATTENUATION,0);
+  glEnable(GL_LIGHT2);
+
+
+
+  glEnable(GL_LIGHTING);
+
+  glDisable(GL_LIGHT0);
+  glDisable(GL_LIGHT3);
+  glDisable(GL_LIGHT4);
+  glDisable(GL_LIGHT5);
+
+  //  glLoadMatrixf(cameraViewMatrix);
+  glLoadMatrixf(mCamera.getModelview());
+}
+
+#ifdef TEST_DL
+static GLuint displayList=0;
+static bool dlInited=false;
+#endif
+
+void Scene::drawScene()
+{
+#ifdef TEST_DL
+  // this was for testing only - to check if display-lists are any good.
+  // it seems they are comparable with VBOs - the problem is that they're inflexible
+  // please leave this code, so we have some example, if we happen to use this again at a later stage
+
+  if(dlInited)
+    {
+      glCallList(displayList);
+    }
+  else
+    {
+      dlInited=true;
+      displayList=glGenLists(1);
+      glNewList(displayList,GL_COMPILE);
+#endif
+
+  STACKTRACE; 
+
+  // this is used for frustum cullin
+  AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
+  
+  //2nd pass - Draw from camera's point of view
+
+  // draw scene with texturing and so
+
+  int drawn=0;
+
+  NodeList l=getCurrentNodes();
+  Nodes sorted;
+  std::copy(l.begin(),l.end(),std::back_inserter(sorted));
+
+  {
+    STACKTRACE;
+    for(Nodes::iterator i=sorted.begin();i!=sorted.end();)
+      {
+	if(cFrustum.collides((*i)-&gt;bbox()))
+	  i++;
+	else
+	  i=sorted.erase(i);
+      }
+  }
+
+  sort(sorted.begin(),sorted.end(),SortOrder());
+  // draw opaque objects first, from front to back
+  for(Nodes::iterator i=sorted.begin();i!=sorted.end();i++)
+    {
+      if(!(*i)-&gt;transparent())
+	{
+	  if((*i)-&gt;visible())
+	    {
+	      (*i)-&gt;draw();
+	      mTriangles+=(*i)-&gt;getTriangles();
+	      drawn++;
+	      mMeshes++;
+	    }
+	}
+    }
+  sort(sorted.begin(),sorted.end(),SortDistance(mCamera.getCameraPosition().dim3()));
+  // draw transparent ones next from back to front
+  for(Nodes::reverse_iterator i=sorted.rbegin();i!=sorted.rend();i++)
+    {
+      if((*i)-&gt;transparent())
+	{
+	  if((*i)-&gt;visible())
+	    {
+	      (*i)-&gt;draw();
+	      mTriangles+=(*i)-&gt;getTriangles();
+	      drawn++;
+	      mMeshes++;
+	    }
+	}
+    }
+
+#ifdef TEST_DL
+  glEndList();
+  glCallList(displayList);
+    }
+#endif
+
+}
+
+
+/// deprecated function - this is done in one pass with &quot;normal&quot; drawing
+/// it was used to paint the shadow afterwards in a 3rd pass
+void Scene::drawShadow()
+{
+  assertGL;
+
+  getRenderer()-&gt;beginShadowDrawing();
+  
+  drawScene();
+
+  getRenderer()-&gt;endShadowDrawing();
+
+  assertGL;
+}
+
+AGVector3 Scene::getCameraDirTo(const AGVector3 &amp;p) const
+{
+  return mCamera.getCameraPosition().dim3()-p;
+}
+
+/** pickDraw is used for picking ;-)
+    it draws all the objects with opengl
+    and not using texturing, shaders and such - if I'm right here??
+*/
+void Scene::pickDraw()
+{
+  STACKTRACE;
+  GLuint name=1;
+  pickNames.clear();
+
+  AGMatrix4 frustum=cameraPickMatrix*mCamera.getModelview();
+
+  AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
+  
+  NodeList l=getCurrentNodes();
+
+  for(NodeList::iterator i=l.begin();i!=l.end();i++)
+    {
+      STACKTRACE;
+      if((*i)-&gt;visible() &amp;&amp; (*i)-&gt;bbox().collides(frustum))
+	if(cFrustum.collides((*i)-&gt;bbox()))
+	  {
+	    STACKTRACE;
+	    glPushName(name);
+	    (*i)-&gt;drawPick();
+	    glPopName();
+	    pickNames.insert(std::make_pair(name,*i));
+	    name++;
+	    mPickTriangles+=(*i)-&gt;getTriangles();
+	  }
+    }
+
+  glEnable(GL_CULL_FACE);
+}
+
+/// this a global function - use this for picking!
+/// x and y are in screen-coordinates in normal fashion
+/// so (0,0) is the top left corner and (1023,767) bottom right.
+/// the same for w and h
+Scene::PickResult Scene::pick(float x,float y,float w,float h)
+{
+  STACKTRACE;
+  size_t bufsize=4000;
+  GLuint buffer[bufsize+1];
+  
+  glSelectBuffer(bufsize,buffer);
+  glRenderMode(GL_SELECT);
+  
+  glMatrixMode(GL_PROJECTION);
+  glPushMatrix();
+  glLoadIdentity();
+  
+  assertGL;
+  gluPickMatrix(x,mCamera.getHeight()-y,h,w,getViewport());
+
+  assertGL;
+  
+  glMultMatrixf(mCamera.getProjection());
+  glGetFloatv(GL_PROJECTION_MATRIX, cameraPickMatrix);
+  assertGL;
+  
+  glMatrixMode(GL_MODELVIEW);
+  glPushMatrix();
+  glLoadIdentity();
+
+  glMultMatrixf(mCamera.getModelview());
+  glInitNames();
+  assertGL;
+
+  pickDraw();
+  assertGL;
+  
+  
+  // back to normality
+  glPopMatrix();
+  glMatrixMode(GL_PROJECTION);
+  glPopMatrix();
+  glMatrixMode(GL_MODELVIEW);
+  glFlush();
+  assertGL;
+  
+  int hits=glRenderMode(GL_RENDER);
+  assertGL;
+  PickResult r=processHits(hits,buffer,x+w/2,mCamera.getHeight()-(y+h/2));
+  std::sort(r.begin(),r.end());
+  return r;
+}
+
+/// helper function for gettin PickResult from opengl's buffers
+Scene::PickResult Scene::processHits (int hits, GLuint *buffer,float px,float py)
+{
+  STACKTRACE;
+  PickResult result;
+  if(hits==0)
+    return result;
+
+   unsigned int i, j;
+   GLuint names, *ptr, minZ,*ptrNames, numberOfNames;
+
+   ptr = (GLuint *) buffer;
+   minZ = 0xffffffff;
+   for (i = 0; i &lt; (unsigned int)hits; i++) { 
+      names = *ptr;
+      ptr++;
+      if (*ptr &lt; minZ) {
+	numberOfNames = names;
+	minZ = *ptr;
+
+	ptrNames = ptr+2;
+
+	GLuint *mptr=ptrNames;
+	for(j=0;j&lt;numberOfNames;j++,mptr++)
+	  {
+	    PickNode n;
+	    n.node=pickNames[*mptr];
+	    n.camDist=minZ/float(0xFFFFFFFF); // (0-1)
+
+	    // get world-position
+	    GLdouble x,y,z;
+
+	    GLdouble modelview[16],projection[16];
+	    for(size_t i=0;i&lt;16;i++)
+	      {
+		modelview[i]=((float*)mCamera.getModelview())[i];
+		projection[i]=((float*)cameraPickMatrix)[i];
+	      }
+
+	    gluUnProject(px,py,n.camDist,modelview,projection,getViewport(),&amp;x,&amp;y,&amp;z);
+	    n.pos=AGVector4(x,y,z,1);
+	    n.camDist=(n.pos-mCamera.getCameraPosition()).length3();
+
+	    result.push_back(n);
+	  }
+
+      }
+      
+      ptr += names+2;
+   }
+
+   return result;
+}
+
+
+Viewport Scene::getViewport() const
+{
+  return mCamera.getViewport();
+}
+
+
+
+AGMatrix4 Scene::getLightComplete() const
+{
+  return mCamera.getLightComplete();
+}
+
+AGMatrix4 Scene::getLightView() const
+{
+  return mCamera.getLightView();
+}
+AGMatrix4 Scene::getLightProj() const
+{
+  return mCamera.getLightProjectionMatrix();
+}
+
+
+AGVector2 Scene::getPosition(const AGVector4 &amp;v) const
+{
+  GLdouble x,y,z;
+  
+  GLdouble modelview[16],projection[16];
+  for(size_t i=0;i&lt;16;i++)
+    {
+      modelview[i]=((const float*)mCamera.getModelview())[i];
+      projection[i]=((const float*)mCamera.getProjection())[i];
+    }
+
+  gluProject(v[0],v[1],v[2],modelview,projection,getViewport(),&amp;x,&amp;y,&amp;z);
+  return AGVector2((int)x,((int)mCamera.getHeight()-y));
+}
+
+
+
+void Scene::setEnabled(bool p)
+{
+  mEnabled=p;
+}
+
+
+void Scene::advance(float time)
+{
+  if(mEnabled)
+    SceneBase::advance(time);
+}

Added: antargis/branches/rant/ext/3dengine/scene.h
===================================================================
--- antargis/branches/rant/ext/3dengine/scene.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scene.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,160 @@
+#ifndef __SCENE_H
+#define __SCENE_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &quot;GLee.h&quot;
+#include &quot;ag_geometry.h&quot;
+#include &quot;ag_geometry.h&quot;
+
+#include &lt;SDL_opengl.h&gt;
+
+#include &lt;vector&gt;
+#include &lt;set&gt;
+#include &lt;map&gt;
+
+#include &quot;scenenode.h&quot;
+#include &quot;scene_base.h&quot;
+#include &quot;ant_camera.h&quot;
+
+/**
+   \defgroup Engine3d 3d-engine of BoA
+   \brief a very small 3d-engine used within BoA
+
+   For more information go to \see Scene
+*/
+
+
+
+
+
+/** 
+    \brief quad-tree based scene-manager
+    \ingroup Engine3d
+
+    Scene is scene-manager. it holds all the 3d-objects (meshes and particles).
+    These objects are stored in a QuadTree (could easily be exchanged for an octree, if needed).
+    It takes further for drawing modes like picking, shadow-rendering and depth-drawing (for shadow-depth-computation).
+    It contains a camera-object!
+    So in the current state it's not possible to render the same scene from to places at the same time.
+
+ */
+
+class Scene:public SceneBase
+{
+ public:
+  ////  typedef std::vector&lt;PickNode&gt; PickResult;
+  ////  typedef std::list&lt;SceneNode*&gt; NodeList;
+
+  Scene(int w,int h);
+  virtual ~Scene();
+
+  void draw();
+
+  // 0 == none, 1 == shadow mapping, 2 == perspective shadow mapping
+  void setShadow(int v);
+  int getShadow() const;
+
+
+  // ATTENTION: nodes are not owned by Scene afterwards - so they won't get deleted!
+  //            You have to do this yourself in the Entities or let ruby's GC do it for you (which would be the normal case)
+  /*  void addNode(SceneNode *node);
+  void removeNode(SceneNode *node);
+  void prepareUpdate(SceneNode *node);
+  void updatePos(SceneNode *node);
+  
+
+  void clear();
+
+  // (mx,my,0)
+  void setCamera(AGVector4 v);
+  AGVector4 getCamera() const;*/
+  virtual void advance(float time);
+  
+  /**
+     picking is currently done with opengl. this uses software (at least on my box), which is
+     pretty slow. Some new implementation using BSPs would be cool!
+     VertexArray or MeshData should contain it's data in such a tree. rays can be transformed using
+     inverse transformation-matrices. This way data can stay as is.
+  */
+  
+  PickResult pick(float x,float y,float w,float h);
+  /*
+  AntCamera &amp;getCameraObject();
+*/
+  size_t getDrawnMeshes() const;
+
+  size_t getTriangles() const;
+  size_t getPickTriangles() const;
+
+
+  /**
+     get 2d-Position on screen for a 3dim vector in 3-space
+   */
+  AGVector2 getPosition(const AGVector4 &amp;v) const;
+
+  /// get camera-viewing-direction to some 3d-point - used for particles
+  AGVector3 getCameraDirTo(const AGVector3 &amp;p) const;
+
+  /*
+  /// width and height of screen
+  float width() const;
+  float height() const;
+
+  void mark();
+  */
+  AGMatrix4 getLightComplete() const;
+  AGMatrix4 getLightView() const;
+  AGMatrix4 getLightProj() const;
+
+  /*
+  AGVector2 getPosition(const AGVector4 &amp;v) const;
+  */
+  NodeList getCurrentNodes();
+
+
+  void setEnabled(bool p);
+
+ private:
+  void calcShadowMap();
+  void drawScene();
+  void drawShadow();
+  void initScene();
+
+  void pickDraw();
+  PickResult processHits (int hits, GLuint *buffer,float x,float y);
+
+  Viewport getViewport() const;
+
+  int mShadow;
+
+  AGMatrix4 cameraPickMatrix;
+  /*
+  typedef std::vector&lt;SceneNode*&gt; Nodes;
+  typedef std::set&lt;SceneNode*&gt; NodeSet;
+
+  typedef QuadTree&lt;SceneNode&gt; Tree;
+
+  Tree *mTree;
+
+  AntCamera mCamera;
+
+  Nodes mNodes;
+  NodeSet mNodeSet;
+  */
+  AGVector4 white,black;
+
+  size_t mTriangles;
+  size_t mPickTriangles;
+  size_t mMeshes;
+
+  // picking vars
+  std::map&lt;GLuint,SceneNode*&gt; pickNames;
+
+  bool mEnabled;
+
+  friend class AntImpostorData;
+};
+
+
+#endif

Added: antargis/branches/rant/ext/3dengine/scene_2d.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/scene_2d.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scene_2d.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,122 @@
+#ifndef NO
+
+#include &quot;scene_2d.h&quot;
+#include &quot;mesh_2d.h&quot;
+#include &quot;mesh_sort.h&quot;
+#include &lt;ag_debug.h&gt;
+
+Scene2D::Scene2D(int w,int h):
+  SceneBase(w,h),mPainter(0)
+{
+}
+
+Scene2D::~Scene2D()
+{
+}
+
+void Scene2D::draw()
+{
+  // FIXME
+  
+  NodeList nodeList=getCurrentNodes();
+  Nodes ns;
+  std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
+
+
+  sort(ns.begin(),ns.end(),SortYCoord());
+
+  //FIXME:sort!!
+
+  for(Nodes::iterator i=ns.begin();i!=ns.end();i++)
+    (*i)-&gt;draw();
+}
+
+SceneBase::PickResult Scene2D::pick(float x,float y,float w,float h)
+{
+  PickResult result;
+  NodeList nodeList=getCurrentNodes();
+
+  Nodes ns;
+  std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
+  sort(ns.begin(),ns.end(),SortOrder());
+
+  for(Nodes::reverse_iterator i=ns.rbegin();i!=ns.rend();i++)
+    {
+      Mesh2D*m=dynamic_cast&lt;Mesh2D*&gt;(*i);
+      if(m)
+	{
+	  if(m-&gt;hit(AGVector2(x,y)))
+	    {
+	      PickNode node;
+	      node.pos=m-&gt;getPos();
+	      node.node=m;
+	      node.camDist=0;
+
+	      cdebug(&quot;hit:&quot;&lt;&lt;node.pos&lt;&lt;&quot;   &quot;&lt;&lt;node.node);
+	      result.push_back(node);
+	    }
+	}
+    }
+  
+
+  return result;
+}
+
+AGVector2 Scene2D::getPosition(const AGVector4 &amp;v) const
+{
+  // FIXME: include camera !!
+  AGVector2 center(width()/2,height()/2);
+  AGVector2 cam(mCamera.getPosition().dim2());
+
+  AGVector2 n=v.dim2()-cam;
+
+  //  cdebug(&quot;n:&quot;&lt;&lt;n);
+
+  //  cdebug(&quot;n:&quot;&lt;&lt;n);
+  n*=32;
+  //  cdebug(&quot;n:&quot;&lt;&lt;n);
+
+  n+=center;
+
+
+  return AGVector2(n[0],height()-n[1]);
+
+  throw std::runtime_error(&quot;FIXME&quot;);
+  return v.dim2();
+}
+
+SceneBase::NodeList Scene2D::getCurrentNodes()
+{
+  //  cdebug(&quot;FIXME&quot;);
+
+  NodeList l;
+  std::copy(mNodes.begin(),mNodes.end(),std::back_inserter(l));
+
+  //  throw std::runtime_error(&quot;FIXME&quot;);
+  return l;
+}
+
+//void setEnabled(bool p);
+
+void Scene2D::setPainter(AGPainter *p)
+{
+  CTRACE;
+  assert(mPainter==0);
+  mPainter=p;
+}
+void Scene2D::discardPainter()
+{
+  CTRACE;
+  assert(mPainter!=0);
+  mPainter=0;
+}
+
+AGPainter *Scene2D::getPainter()
+{
+  CTRACE;
+  assert(mPainter);
+  return mPainter;
+}
+
+
+#endif

Added: antargis/branches/rant/ext/3dengine/scene_2d.h
===================================================================
--- antargis/branches/rant/ext/3dengine/scene_2d.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scene_2d.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,47 @@
+#ifndef SCENE_2D_H
+#define SCENE_2D_H
+
+#include &quot;scene_base.h&quot;
+
+class AGPainter;
+
+class Scene2D:public SceneBase
+{
+ public:
+  typedef std::vector&lt;PickNode&gt; PickResult;
+  typedef std::list&lt;SceneNode*&gt; NodeList;
+
+  Scene2D(int w,int h);
+  virtual ~Scene2D();
+
+  void draw();
+
+  /**
+     picking is currently done with opengl. this uses software (at least on my box), which is
+     pretty slow. Some new implementation using BSPs would be cool!
+     VertexArray or MeshData should contain it's data in such a tree. rays can be transformed using
+     inverse transformation-matrices. This way data can stay as is.
+  */
+  PickResult pick(float x,float y,float w,float h);
+
+  //  AntCamera &amp;getCameraObject();
+
+  AGVector2 getPosition(const AGVector4 &amp;v) const;
+
+  NodeList getCurrentNodes();
+
+  void setEnabled(bool p);
+
+  void setPainter(AGPainter *p);
+  void discardPainter();
+
+  AGPainter *getPainter();
+ private:
+  AGPainter *mPainter;
+  
+  
+  
+
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/scene_base.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/scene_base.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scene_base.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,143 @@
+#include &quot;ag_profiler.h&quot;
+
+#include &quot;quadtree.h&quot;
+
+#include &quot;scene_base.h&quot;
+
+SceneBase::SceneBase(int w,int h):
+  mTree(new QuadTree&lt;SceneNode&gt;(AGRect2(AGVector2(),AGVector2(w,h)))),
+  mCamera(w,h)
+{
+}
+
+
+SceneBase::~SceneBase()
+{
+  // tell nodes, that I'm no longer there :-)
+  for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
+    (*i)-&gt;resetScene(); 
+
+  delete mTree;
+}
+
+
+
+
+
+void SceneBase::addNode(SceneNode *node)
+{
+  if(mNodeSet.find(node)==mNodeSet.end())
+    {
+      node-&gt;setScene(this);
+
+      mNodes.push_back(node);
+      mNodeSet.insert(node);
+      assert(node-&gt;getScene()==this);
+      mTree-&gt;insert(node);
+    }
+}
+
+
+
+void SceneBase::updatePos(SceneNode *node)
+{
+  if(mNodeSet.find(node)==mNodeSet.end())
+    throw std::string(&quot;Dont know about this!&quot;);
+  mTree-&gt;insert(node);
+}
+
+void SceneBase::prepareUpdate(SceneNode *node)
+{
+  if(mNodeSet.find(node)==mNodeSet.end())
+    throw std::string(&quot;Dont know about this!&quot;);
+  mTree-&gt;remove(node);
+}
+
+
+void SceneBase::removeNode(SceneNode *node)
+{
+  if(mNodeSet.find(node)!=mNodeSet.end())
+    {
+      Nodes::iterator i=std::find(mNodes.begin(),mNodes.end(),node);
+      mNodes.erase(i);
+      mNodeSet.erase(node);
+      assert(node-&gt;getScene()==this);
+      node-&gt;resetScene();
+      assert(mTree-&gt;remove(node));
+    }
+  else
+    {
+      throw std::runtime_error(&quot;Trying to remove unknown node&quot;);
+    }
+}
+
+void SceneBase::clear()
+{
+  for(std::vector&lt;SceneNode*&gt;::iterator i=mNodes.begin();i!=mNodes.end();i++)
+    {
+      assert((*i)-&gt;getScene()==this);
+      (*i)-&gt;resetScene();
+    }
+  TRACE;
+  mNodes.clear();
+  mNodeSet.clear();
+  mTree-&gt;clear();
+}
+
+  // (mx,my,0)
+void SceneBase::setCamera(AGVector4 v)
+{
+  mCamera.setPosition(v.dim3());
+}
+
+void SceneBase::advance(float time)
+{
+  STACKTRACE; 
+
+  //  if(!mEnabled)
+  //    return;
+  // advance only in view
+
+  NodeList l=getCurrentNodes();
+
+  for(NodeList::iterator i=l.begin();i!=l.end();i++)
+    {
+      if((*i)-&gt;visible())
+	(*i)-&gt;advance(time);
+    }
+}
+
+float SceneBase::width() const
+{
+  return mCamera.getWidth();
+}
+float SceneBase::height() const
+{
+  return mCamera.getHeight();
+}
+
+void SceneBase::mark()
+{
+  SceneBase::Nodes::iterator i=mNodes.begin();
+
+  for(;i!=mNodes.end();i++)
+    {
+      markObject(*i);
+    }
+}
+
+AGVector4 SceneBase::getCamera() const
+{
+  return AGVector4(mCamera.getPosition(),1);
+}
+
+AntCamera &amp;SceneBase::getCameraObject()
+{
+  return mCamera;
+}
+
+SceneBase::NodeList SceneBase::getCurrentNodes()
+{
+  throw std::runtime_error(&quot;not implemented!&quot;);
+  return NodeList();
+}

Added: antargis/branches/rant/ext/3dengine/scene_base.h
===================================================================
--- antargis/branches/rant/ext/3dengine/scene_base.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scene_base.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,95 @@
+#ifndef SCENE_BASE_H
+#define SCENE_BASE_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &quot;ant_camera.h&quot;
+#include &quot;scenenode.h&quot;
+
+/**
+   some helper structure, which is used for storing
+   results when picking. it holds some information about:
+   * distance to camera (for sorting)
+   * the picked scene-node
+   * and the 3d-position, where the scene-node was touched
+   */
+struct PickNode
+{
+  AGVector4 pos;
+  SceneNode *node;
+  float camDist;
+  
+  bool operator&lt;(const PickNode &amp;n) const;
+};
+
+template&lt;class T&gt;
+class QuadTree;
+
+
+class SceneBase:public AGRubyObject
+{
+ public:
+  typedef std::vector&lt;PickNode&gt; PickResult;
+  typedef std::list&lt;SceneNode*&gt; NodeList;
+
+  SceneBase(int w,int h);
+  virtual ~SceneBase();
+
+//  void draw();
+
+  // ATTENTION: nodes are not owned by Scene afterwards - so they won't get deleted!
+  //            You have to do this yourself in the Entities or let ruby's GC do it for you (which would be the normal case)
+  void addNode(SceneNode *node);
+  void removeNode(SceneNode *node);
+  void prepareUpdate(SceneNode *node);
+  void updatePos(SceneNode *node);
+
+  void clear();
+
+  // (mx,my,0)
+  void setCamera(AGVector4 v);
+  AGVector4 getCamera() const;
+  virtual void advance(float time);
+
+  /**
+     picking is currently done with opengl. this uses software (at least on my box), which is
+     pretty slow. Some new implementation using BSPs would be cool!
+     VertexArray or MeshData should contain it's data in such a tree. rays can be transformed using
+     inverse transformation-matrices. This way data can stay as is.
+  */
+  //  virtual PickResult pick(float x,float y,float w,float h);
+
+  AntCamera &amp;getCameraObject();
+
+//  size_t getDrawnMeshes() const;
+
+  /// width and height of screen
+  float width() const;
+  float height() const;
+
+  void mark();
+
+
+  /** get currently visible nodes */
+  virtual NodeList getCurrentNodes();
+
+  //  void setEnabled(bool p);
+
+ protected:
+
+  typedef std::vector&lt;SceneNode*&gt; Nodes;
+  typedef std::set&lt;SceneNode*&gt; NodeSet;
+
+  typedef QuadTree&lt;SceneNode&gt; Tree;
+
+  Tree *mTree;
+
+  AntCamera mCamera;
+
+  Nodes mNodes;
+  NodeSet mNodeSet;
+
+};
+
+
+#endif

Added: antargis/branches/rant/ext/3dengine/scenenode.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/scenenode.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scenenode.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,165 @@
+#include &quot;scenenode.h&quot;
+#include &quot;scene.h&quot;
+#include &quot;ag_debug.h&quot;
+
+SceneNode::SceneNode(SceneBase *s,const AGVector4 &amp;pPos,const AGBox3 &amp;b):
+  mPos(pPos),mBBox(b)
+{
+  assert(s);
+  mRubyObject=false;
+  mScene=s;
+  mVisible=true;
+  mOrder=1;
+
+  if(mScene)
+    mScene-&gt;addNode(this);
+}
+
+SceneNode::~SceneNode()
+{
+  //  CTRACE;
+  //mRubyObject=false; // why was this here ??????
+
+  // typical calling is:
+  // scenenode is saveDeleted by AntEntity - so mScene should be 0
+
+  //  assert(mScene==0); // but not at program end - this is the reason this is commented
+  if(mScene)
+    mScene-&gt;removeNode(this);
+}
+
+void SceneNode::setScene(SceneBase *pScene)
+{
+  assert(mScene==0 || mScene==pScene);
+  mScene=pScene;
+}
+
+
+/// release attaching to scene
+void SceneNode::resetScene()
+{
+  mScene=0;
+}
+
+/// this function is deprecated. It was once used for drawing 
+/// shadow in a 3rd render-pass.
+void SceneNode::drawShadow()
+{
+}
+
+/// This functions is used in the 1st depth-drawing render-pass,
+/// so you should not use colors or textures, when not needed
+void SceneNode::drawDepth()
+{
+}
+void SceneNode::draw()
+{
+}
+
+/// this function is used for picking objects.
+/// Picking is done one CPU, so shader-animated models are
+/// out of place here.
+void SceneNode::drawPick()
+{
+}
+void SceneNode::advance(float time)
+{
+}
+size_t SceneNode::getTriangles() const
+{
+  return 0;
+}
+AGVector4 SceneNode::lineHit(const AGLine3 &amp;pLine) const
+{
+  AGVector4 mfalse(0,0,0,0);
+  return mfalse;
+}
+
+void SceneNode::sort(const AGVector4 &amp;pCamera)
+{
+}
+
+bool SceneNode::operator==(const SceneNode &amp;n) const
+{
+  return this==&n;
+}
+
+void SceneNode::setPos(const AGVector3&amp;pPos)
+{
+  getScene()-&gt;prepareUpdate(this);
+  mPos=AGVector4(pPos,1);
+  getScene()-&gt;updatePos(this);
+}
+
+void SceneNode::setRotation(float r)
+{
+}
+
+
+bool SceneNode::transparent()
+{
+  return false;
+}
+
+AGBox3 SceneNode::bbox() const
+{
+  return mBBox+getPos().dim3();
+}
+
+AGRect2 SceneNode::getRect() const
+{
+  AGBox3 b=bbox();
+  return AGRect2(AGVector2(b.base[0],b.base[1]),AGVector2(b.base[0]+b.dir[0],b.base[1]+b.dir[1]));
+}
+
+
+SceneBase *SceneNode::getScene()
+{
+  if(!mScene)
+    throw std::runtime_error(&quot;scene==0&quot;);
+  return mScene;
+}
+
+bool SceneNode::sceneValid() const
+{
+  return mScene;
+}
+
+
+void SceneNode::clear()
+{
+  //  cdebug(typeid(*this).name());
+  if(mScene)
+    mScene-&gt;removeNode(this);
+  resetScene();
+}
+
+void SceneNode::setVisible(bool v)
+{
+  mVisible=v;
+}
+bool SceneNode::visible() const
+{
+  return mVisible;
+}
+
+void SceneNode::setOrder(int o)
+{
+  mOrder=o;
+}
+int SceneNode::getOrder() const
+{
+  return mOrder;
+}
+
+AGVector4 SceneNode::getPos() const
+{
+  return mPos;
+}
+
+void SceneNode::setBBox(const AGBox3 &amp;pBox)
+{
+  getScene()-&gt;prepareUpdate(this);
+  mBBox=pBox;
+  getScene()-&gt;updatePos(this);
+}

Added: antargis/branches/rant/ext/3dengine/scenenode.h
===================================================================
--- antargis/branches/rant/ext/3dengine/scenenode.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scenenode.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,99 @@
+#ifndef _SCENE_NODE_H
+#define _SCENE_NODE_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &lt;ag_geometry.h&gt;
+#include &lt;ag_rubyobj.h&gt;
+
+class SceneBase;
+
+/// these are the drawing orders, by which Scene::drawScene orders all the meshes
+/// 1 will be drawn first and so forth
+
+#define TERRAIN_Z 1
+#define WATER_Z 2
+#define DECAL_Z 3
+#define RING_Z 4
+#define MESH_Z 5
+#define TREE_Z 6
+#define PARTICLE_Z 7
+
+/**
+   A scenenode represents any part of a scene. It holds information
+   about position, drawing order, bounding box and visibility.
+   A scenenode is created for exactly one scene and it can't be
+   assigned to any other scene, which shouldn't be necessary.
+
+   Scene and SceneNode give each other information about their 
+   &quot;destroy-state&quot;. That means the destructor notifies the other object.
+
+*/
+class SceneNode:public AGRubyObject
+{
+ public:
+  SceneNode(SceneBase *s,const AGVector4 &amp;pPos,const AGBox3 &amp;pBox);
+  virtual ~SceneNode();
+
+  /// reset my scene pointer - should not be called in &quot;normal&quot; code - only by the Scene-object
+  virtual void resetScene();
+  virtual void drawShadow();
+  virtual void drawDepth();
+  virtual void draw();
+  virtual void drawPick();
+
+  /// advance mesh - e.g. animation
+  virtual void advance(float time);
+
+  virtual size_t getTriangles() const;
+  virtual AGVector4 lineHit(const AGLine3 &amp;pLine) const;
+
+  /// sort triangles for given camera-view - shouldn't be used often!!!
+  virtual void sort(const AGVector4 &amp;pCamera);
+
+  /// references equal??
+  bool operator==(const SceneNode &amp;n) const;
+
+  virtual void setPos(const AGVector3&amp;pPos);
+  AGVector4 getPos() const;
+  virtual void setRotation(float r);
+  void setBBox(const AGBox3 &amp;pBox);
+
+  /// indicates, if this object is transparent. if that's the case, it will be drawn later.
+  /// drawing goes like this:1)draw all opaque objects from front to back; 2)draw transparent from back to front
+  /// this is the fastest way to do this
+  virtual bool transparent();
+
+  /// get bounding box
+  AGBox3 bbox() const;
+  AGRect2 getRect() const;
+
+  virtual void clear();
+
+  SceneBase *getScene();
+  /// this checks, if the current object is inserted into a scene
+  bool sceneValid() const;
+
+  void setVisible(bool v);
+  bool visible() const;
+
+  /// there is a drawing order, used by the scene-manager, which priorized. look at Scene::drawScene for more info.
+  void setOrder(int o);
+  int getOrder() const;
+  
+ private:
+  void setScene(SceneBase *pScene);
+
+  int mOrder;
+
+  SceneBase *mScene;
+  bool mVisible;
+
+  AGVector4 mPos;
+  AGBox3 mBBox;
+
+  friend class SceneBase;
+};
+
+typedef SceneNode *SceneNodePtr;
+#endif

Added: antargis/branches/rant/ext/3dengine/templates.i
===================================================================
--- antargis/branches/rant/ext/3dengine/templates.i	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/templates.i	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,4 @@
+%template(SceneNodeVector) std::vector&lt;SceneNodePtr&gt;;
+%template(PickResult) std::vector&lt;PickNode&gt;;
+%template(AGPairVec2Surface) std::pair&lt;AGVector2,AGSurface*&gt;;
+%template(SceneNodeList) std::list&lt;SceneNode*&gt;;
\ No newline at end of file

Added: antargis/branches/rant/ext/3dengine/vertex_array.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/vertex_array.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/vertex_array.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,705 @@
+#include &quot;vertex_array.h&quot;
+#include &lt;SDL_opengl.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;ag_vdebug.h&gt;
+#include &lt;ag_profiler.h&gt;
+#include &lt;ag_config.h&gt;
+#include &lt;ag_main.h&gt;
+
+static bool useVBO()
+{
+  AGString s=getConfig()-&gt;get(&quot;useVBO&quot;);
+  //cdebug(&quot;useVBO:&quot;&lt;&lt;s);
+  if(s!=&quot;true&quot; &amp;&amp; s!=&quot;false&quot;)
+    {
+      cdebug(&quot;useVBO:&quot;&lt;&lt;s);
+      s=&quot;true&quot;;
+      getConfig()-&gt;set(&quot;useVBO&quot;,s);
+    }
+  return s==&quot;true&quot;;
+}
+
+static bool useVertexArrays()
+{
+  AGString s=getConfig()-&gt;get(&quot;useVertexArrays&quot;);
+  if(s!=&quot;true&quot; &amp;&amp; s!=&quot;false&quot;)
+    {
+      s=&quot;true&quot;;
+      getConfig()-&gt;set(&quot;useVertexArrays&quot;,s);
+    }
+  return s==&quot;true&quot;;
+}
+
+
+VertexArray::VertexArray(bool pDynamic):mDynamic(pDynamic),bbox(AGVector3(),AGVector3())
+{
+  bColor=true;
+  mBuffers=GLEE_ARB_vertex_buffer_object &amp;&amp; useVBO();
+  mArrays=GLEE_EXT_vertex_array &amp;&amp; useVertexArrays();
+
+  if(videoInited())
+    assert(GLEE_EXT_vertex_array);
+
+  displayListInited=false;
+
+  mChanged=false;
+
+  mVertexBuffer=0;
+  mColorBuffer=0;
+  mNormalBuffer=0;
+  mTexBuffer=0;
+  mIndexBuffer=0;
+  mTextures3D=false;
+}
+
+VertexArray::~VertexArray()
+{
+  //  CTRACE;
+  if(mBuffers &amp;&amp; mVertexBuffer!=0) //mChanged==false)
+    {
+      glDeleteBuffersARB( 1, &amp;mVertexBuffer );
+      glDeleteBuffersARB( 1, &amp;mColorBuffer );
+      glDeleteBuffersARB( 1, &amp;mNormalBuffer );
+      glDeleteBuffersARB( 1, &amp;mTexBuffer );
+      if(!mDynamic)
+	glDeleteBuffersARB( 1, &amp;mIndexBuffer );
+    }
+}
+
+
+void VertexArray::addVertex(AGVector4 pVertex, AGVector4 pColor, AGVector3 pNormal, AGVector2 pTex)
+{
+  mVertices.push_back(pVertex);
+  mColors.push_back(pColor);
+  mNormals.push_back(pNormal);
+  mTexCoords.push_back(pTex);
+  mChanged=true;
+  if(mVertices.size()==1)
+    bbox=AGBox3(pVertex.dim3(),AGVector3(0,0,0));
+  else
+    bbox.include(pVertex.dim3());
+}
+
+void VertexArray::addVertex(AGVector4 pVertex, AGVector4 pColor, AGVector3 pNormal, AGVector3 pTex)
+{
+  assert(mTextures3D || mVertices.size()==0);
+  mTextures3D=true;
+  mVertices.push_back(pVertex);
+  mColors.push_back(pColor);
+  mNormals.push_back(pNormal);
+  mTexCoords3D.push_back(pTex);
+  mChanged=true;
+  if(mVertices.size()==1)
+    bbox=AGBox3(pVertex.dim3(),AGVector3(0,0,0));
+  else
+    bbox.include(pVertex.dim3());
+}
+
+void VertexArray::addTriangle(size_t p0,size_t p1,size_t p2)
+{
+  assert(p0&lt;mVertices.size());
+  assert(p1&lt;mVertices.size());
+  assert(p2&lt;mVertices.size());
+  mIndices.push_back(p0);
+  mIndices.push_back(p1);
+  mIndices.push_back(p2);
+  mChanged=true;
+}
+
+void VertexArray::init()
+{
+  if(mBuffers)
+    {
+      STACKTRACE;
+      glGenBuffersARB( 1, &amp;mVertexBuffer );
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer );
+      glBufferDataARB( GL_ARRAY_BUFFER_ARB, mVertices.size()*sizeof(AGVector4), &amp;(mVertices[0]), GL_STATIC_DRAW_ARB );
+      
+      glGenBuffersARB( 1, &amp;mColorBuffer );
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mColorBuffer );
+      glBufferDataARB( GL_ARRAY_BUFFER_ARB, mColors.size()*sizeof(AGVector4), &amp;(mColors[0]), GL_STATIC_DRAW_ARB );
+      
+      glGenBuffersARB( 1, &amp;mNormalBuffer );
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mNormalBuffer );
+      glBufferDataARB( GL_ARRAY_BUFFER_ARB, mNormals.size()*sizeof(AGVector3), &amp;(mNormals[0]), GL_STATIC_DRAW_ARB );
+      
+      glGenBuffersARB( 1, &amp;mTexBuffer );
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer );
+      if(mTextures3D)
+	glBufferDataARB( GL_ARRAY_BUFFER_ARB, mTexCoords3D.size()*sizeof(AGVector3), &amp;(mTexCoords3D[0]), GL_STATIC_DRAW_ARB );
+      else
+	glBufferDataARB( GL_ARRAY_BUFFER_ARB, mTexCoords.size()*sizeof(AGVector2), &amp;(mTexCoords[0]), GL_STATIC_DRAW_ARB );
+
+      if(!mDynamic)
+	{
+	  glGenBuffersARB( 1, &amp;mIndexBuffer );
+	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer );
+	  glBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndices.size()*sizeof(Uint16), &amp;(mIndices[0]), GL_STATIC_DRAW_ARB );
+	}
+
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, 0);
+      glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
+
+
+    }
+  mChanged=false;
+}
+
+void VertexArray::setColors(bool color)
+{
+  bColor=color;
+}
+
+void VertexArray::draw()
+{
+  assertGL;
+  if(mChanged)
+    init();
+
+  assertGL;
+
+  if(mBuffers||mArrays)
+    {
+      glEnableClientState(GL_VERTEX_ARRAY);
+      glEnableClientState(GL_NORMAL_ARRAY);
+      if(bColor)
+	glEnableClientState(GL_COLOR_ARRAY);
+      else
+	glDisableClientState(GL_COLOR_ARRAY);
+      glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+    }
+
+  if(mBuffers)
+    {
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mNormalBuffer );
+      glNormalPointer(GL_FLOAT, 0, 0);
+
+      /*
+      glClientActiveTexture(GL_TEXTURE1);
+      glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer);
+      glTexCoordPointer(2, GL_FLOAT, 0, 0);
+      */
+      glClientActiveTexture(GL_TEXTURE0);
+
+      glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer);
+      if(mTextures3D)
+	glTexCoordPointer(3, GL_FLOAT, 0, 0);
+      else
+	glTexCoordPointer(2, GL_FLOAT, 0, 0);
+
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer);
+      glVertexPointer(4, GL_FLOAT, 0, 0);
+      if(bColor)
+	{
+	  glBindBufferARB( GL_ARRAY_BUFFER_ARB, mColorBuffer);
+	  glColorPointer(4, GL_FLOAT, 0, 0);
+	}
+
+      if(mDynamic)
+	{
+	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+			 &amp;(mIndices[0]));
+	}
+      else
+	{
+	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer);
+	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,0);
+	}
+    }
+  else if(mArrays)
+    {
+      //      cdebug(&quot;too much work&quot;);
+      glNormalPointer(GL_FLOAT, 0, &amp;(mNormals[0]));
+      glClientActiveTexture(GL_TEXTURE0);
+      if(mTextures3D)
+	glTexCoordPointer(3, GL_FLOAT, 0, &amp;(mTexCoords3D[0]));
+      else
+	glTexCoordPointer(2, GL_FLOAT, 0, &amp;(mTexCoords[0]));
+      glVertexPointer(4, GL_FLOAT, 0, &amp;(mVertices[0]));
+      if(bColor)
+	glColorPointer(4, GL_FLOAT, 0, &amp;(mColors[0]));
+      glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+		     &amp;(mIndices[0]));
+  }
+  else
+    {
+      glClientActiveTexture(GL_TEXTURE0);
+      glBegin(GL_TRIANGLES);
+      for(std::vector&lt;Uint16&gt;::iterator i=mIndices.begin();i!=mIndices.end();i++)
+	{
+	  glNormal3fv(mNormals[*i]);
+	  if(mTextures3D)
+	    glTexCoord3fv(mTexCoords3D[*i]);
+	  else
+	    glTexCoord2fv(mTexCoords[*i]);
+	  if(bColor)
+	    glColor4fv(mColors[*i]);
+	  glVertex4fv(mVertices[*i]);
+	}
+      glEnd();
+      
+    }
+
+  if(mBuffers||mArrays)
+    {
+      glDisableClientState(GL_VERTEX_ARRAY);
+      glDisableClientState(GL_NORMAL_ARRAY);
+      glDisableClientState(GL_COLOR_ARRAY);
+      glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+    }
+  assertGL;
+
+}
+
+void VertexArray::drawPick()
+{
+  STACKTRACE;
+  if(false)
+    {
+      // use vertex arrays
+      glEnableClientState(GL_VERTEX_ARRAY);
+
+      glVertexPointer(4, GL_FLOAT, 0, &amp;(mVertices[0]));
+      glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+		     &amp;(mIndices[0]));
+      
+      glDisableClientState(GL_VERTEX_ARRAY);
+
+    }
+
+  else if(true)
+    {
+      if(displayListInited)
+	{
+	  STACKTRACE;
+	  
+	  glCallList(displayList);
+	}
+      else
+	{
+	  displayList=glGenLists(1);
+	  glNewList(displayList,GL_COMPILE);
+	  {
+	    // paint in software - because this is faster for picking
+	    glBegin(GL_TRIANGLES);
+	    for(std::vector&lt;Uint16&gt;::iterator i=mIndices.begin();i!=mIndices.end();i++)
+	      glVertex4fv(mVertices[*i]);
+	    glEnd();
+	  }
+	  glEndList();
+	  glCallList(displayList);
+
+	  displayListInited=true;
+	}
+    }
+  else
+    {
+      // FIXME: some this doesn't - what the heck!
+      if(mChanged)
+	init();
+      
+      
+      glEnableClientState(GL_VERTEX_ARRAY);
+      
+      
+      // disable textures
+      glClientActiveTexture(GL_TEXTURE1);
+      glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+      glClientActiveTexture(GL_TEXTURE0);
+      
+      glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+      
+      {
+	cdebug(mVertices.size());
+	cdebug(mIndices.size());
+	glBindBufferARB( GL_ARRAY_BUFFER_ARB,0);
+	glNormalPointer(GL_FLOAT,0,0);
+	glBindBufferARB( GL_ARRAY_BUFFER_ARB,0);
+	glTexCoordPointer(2,GL_FLOAT,0,0);
+	glVertexPointer(4, GL_FLOAT, 0, &amp;(mVertices[0]));
+	glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+		       &amp;(mIndices[0]));
+      }
+      
+      glDisableClientState(GL_VERTEX_ARRAY);
+    }
+}
+
+
+
+void VertexArray::drawDepth()
+{
+#ifdef OLD
+  if(mChanged)
+    init();
+
+  glEnableClientState(GL_VERTEX_ARRAY);
+
+
+  //  glDisable(GL_TEXTURE_2D);
+
+  if(mBuffers)
+    {
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer);
+      glVertexPointer(4, GL_FLOAT, 0, 0);
+
+      if(mDynamic)
+	{
+	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+			 &amp;(mIndices[0]));
+	}
+      else
+	{
+	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer);
+	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,0);
+	}
+
+    }
+  else
+    {
+      //      cdebug(&quot;too much work&quot;);
+      glVertexPointer(4, GL_FLOAT, 0, &amp;(mVertices[0]));
+
+      glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+		     &amp;(mIndices[0]));
+  }
+
+  //  glEnable(GL_TEXTURE_2D);
+
+  glDisableClientState(GL_VERTEX_ARRAY);
+#else
+  if(mChanged)
+    init();
+
+  glEnableClientState(GL_VERTEX_ARRAY);
+
+  glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+
+
+  if(mBuffers)
+    {
+      glClientActiveTexture(GL_TEXTURE0);
+
+      glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer);
+      if(mTextures3D)
+	glTexCoordPointer(3, GL_FLOAT, 0, 0);
+      else
+	glTexCoordPointer(2, GL_FLOAT, 0, 0);
+
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer);
+      glVertexPointer(4, GL_FLOAT, 0, 0);
+
+      if(mDynamic)
+	{
+	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+			 &amp;(mIndices[0]));
+	}
+      else
+	{
+	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer);
+	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,0);
+	}
+
+    }
+  else
+    {
+      if(mTextures3D)
+	glTexCoordPointer(3, GL_FLOAT, 0, &amp;(mTexCoords3D[0]));
+      else
+	glTexCoordPointer(2, GL_FLOAT, 0, &amp;(mTexCoords[0]));
+      glVertexPointer(4, GL_FLOAT, 0, &amp;(mVertices[0]));
+
+      glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+		     &amp;(mIndices[0]));
+  }
+
+  glDisableClientState(GL_VERTEX_ARRAY);
+  glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+#endif
+}
+
+
+
+AGVector4 VertexArray::lineHit(const AGLine3 &amp;pLine) const
+{
+  AGVector4 mfalse(0,0,0,0);
+  //  cdebug(&quot;box:&quot;&lt;&lt;bbox.toString());
+  if(!bbox.collides(pLine))
+    return mfalse;
+
+  for(size_t i=0;i&lt;mIndices.size();i+=3)
+    {
+      AGVector4 v0=mVertices[mIndices[i]];
+      AGVector4 v1=mVertices[mIndices[i+1]];
+      AGVector4 v2=mVertices[mIndices[i+2]];
+
+      AGTriangle3 t(v0.dim3(),v1.dim3(),v2.dim3());
+      AGVector4 r;
+      r=t.collide(pLine);
+      if(r[3]==1)
+	{
+	  return r;
+	}
+    }
+  return mfalse;
+}
+
+void VertexArray::update()
+{
+  if(mBuffers &amp;&amp; mVertexBuffer!=0) //mChanged==false)
+    {
+      glDeleteBuffersARB( 1, &amp;mVertexBuffer );
+      glDeleteBuffersARB( 1, &amp;mColorBuffer );
+      glDeleteBuffersARB( 1, &amp;mNormalBuffer );
+      glDeleteBuffersARB( 1, &amp;mTexBuffer );
+      glDeleteBuffersARB( 1, &amp;mIndexBuffer );
+      mVertexBuffer=0;
+    }
+  mChanged=true;
+}
+void VertexArray::clear()
+{
+  /*  if(mBuffers &amp;&amp; mVertexBuffer!=0) //mChanged==false)
+    {
+      glDeleteBuffersARB( 1, &amp;mVertexBuffer );
+      glDeleteBuffersARB( 1, &amp;mColorBuffer );
+      glDeleteBuffersARB( 1, &amp;mNormalBuffer );
+      glDeleteBuffersARB( 1, &amp;mTexBuffer );
+      glDeleteBuffersARB( 1, &amp;mIndexBuffer );
+      }*/
+  mVertices.clear();
+  mColors.clear();
+  mNormals.clear();
+  mTexCoords.clear();
+  mTexCoords3D.clear();
+  mIndices.clear();
+  update();
+}
+
+void VertexArray::setBuffers(bool pBuffers)
+{
+  mBuffers=false;
+}
+
+
+size_t VertexArray::getIndex(size_t i)
+{
+  return mIndices[i];
+}
+AGVector4 VertexArray::getVertex(size_t i)
+{
+  return mVertices[i];
+}
+AGVector4 VertexArray::getColor(size_t i)
+{
+  return mColors[i];
+}
+AGVector3 VertexArray::getNormal(size_t i)
+{
+  return mNormals[i];
+}
+  AGVector2 VertexArray::getTexCoord(size_t i)
+{
+  return mTexCoords[i];
+}
+
+void VertexArray::setTexCoord(size_t i,const AGVector2 &amp;t)
+{
+  mTexCoords[i]=t;
+  update();
+}
+
+bool VertexArray::useVertexArrays() const
+{
+  return mArrays;
+}
+
+
+void VertexArray::onScreenUp()
+{
+    init();
+}
+
+void VertexArray::onScreenDown()
+{
+  if(mBuffers &amp;&amp; mVertexBuffer!=0) //mChanged==false)
+    {
+      glDeleteBuffersARB( 1, &amp;mVertexBuffer );
+      glDeleteBuffersARB( 1, &amp;mColorBuffer );
+      glDeleteBuffersARB( 1, &amp;mNormalBuffer );
+      glDeleteBuffersARB( 1, &amp;mTexBuffer );
+      if(!mDynamic)
+	glDeleteBuffersARB( 1, &amp;mIndexBuffer );
+    }
+  mVertexBuffer=mColorBuffer=mNormalBuffer=mTexBuffer=mIndexBuffer=0;
+}
+
+
+
+
+////////////////////////////////////////////////////////////////////
+// VertexArrayShader
+////////////////////////////////////////////////////////////////////
+
+
+
+VertexArrayShader::VertexArrayShader(AntShaderProgram *_p):p(_p)
+{
+  aInited=false;
+}
+VertexArrayShader::~VertexArrayShader()
+{
+  for(std::map&lt;std::string,std::vector&lt;float&gt;*&gt;::iterator i=as.begin();i!=as.end();++i)
+    {
+      if(i-&gt;second)
+	delete i-&gt;second;
+    }
+
+  for(std::map&lt;std::string,std::vector&lt;Uint16&gt;*&gt;::iterator i=elementAs.begin();i!=elementAs.end();++i)
+    {
+      if(i-&gt;second)
+	delete i-&gt;second;
+    }
+
+}
+
+void VertexArrayShader::addAttribute(const std::string &amp;pName,const std::vector&lt;float&gt; &amp;a)
+{
+  as[pName]=new std::vector&lt;float&gt;(a);
+  aInited=false;
+}
+
+void VertexArrayShader::addAttribute(const std::string &amp;pName,const std::vector&lt;Uint16&gt; &amp;a)
+{
+  elementAs[pName]=new std::vector&lt;Uint16&gt;(a);
+  aInited=false;
+}
+
+
+void VertexArrayShader::draw()
+{
+  assertGL;
+  p-&gt;enable();
+  assertGL;
+  if(!aInited)
+    aInit();
+  assertGL;
+  attach();
+  assertGL;
+  VertexArray::draw();
+  p-&gt;disable();
+}
+
+void VertexArrayShader::attach()
+{
+  //  if(useVertexArrays())
+    {
+      for(std::map&lt;std::string,unsigned int&gt;::iterator i=aids.begin();i!=aids.end();i++)
+	{
+	  GLint loc=p-&gt;getAttr(i-&gt;first);
+	  glEnableClientState(GL_VERTEX_ARRAY);
+	  glEnableVertexAttribArrayARB(loc); // add array
+	  glBindBufferARB( GL_ARRAY_BUFFER_ARB, i-&gt;second);
+	  glVertexAttribPointerARB(loc,1,GL_FLOAT,0,0,0);
+	  //      glTexCoordPointer(2, GL_FLOAT, 0, 0);
+	}
+
+      for(std::map&lt;std::string,unsigned int&gt;::iterator i=elementIds.begin();i!=elementIds.end();i++)
+	{
+  assertGL;
+	  GLint loc=p-&gt;getAttr(i-&gt;first);
+  assertGL;
+	  glEnableClientState(GL_VERTEX_ARRAY);
+  assertGL;
+	  glEnableVertexAttribArrayARB(loc); // add array
+  assertGL;
+	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, i-&gt;second);
+  assertGL;
+	  glVertexAttribPointerARB(loc,1,GL_UNSIGNED_SHORT,0,0,0);
+  assertGL;
+	  //      glTexCoordPointer(2, GL_FLOAT, 0, 0);
+	}
+
+    }
+}
+
+void VertexArrayShader::aInit()
+{
+  for(std::map&lt;std::string,std::vector&lt;float&gt;*&gt;::iterator i=as.begin();i!=as.end();i++)
+    {
+      unsigned int id;
+
+      glGenBuffersARB( 1, &amp;id);
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, id);
+      glBufferDataARB( GL_ARRAY_BUFFER_ARB, i-&gt;second-&gt;size()*sizeof(float), &amp;((*i-&gt;second)[0]), GL_STATIC_DRAW_ARB );
+
+      aids[i-&gt;first]=id;
+    }
+
+  for(std::map&lt;std::string,std::vector&lt;Uint16&gt;*&gt;::iterator i=elementAs.begin();i!=elementAs.end();i++)
+    {
+      unsigned int id;
+
+      glGenBuffersARB( 1, &amp;id);
+      glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, id);
+      glBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, i-&gt;second-&gt;size()*sizeof(Uint16), &amp;((*i-&gt;second)[0]), GL_STATIC_DRAW_ARB );
+
+      elementIds[i-&gt;first]=id;
+    }
+
+
+  aInited=true;
+}
+
+
+VertexArray *makeInstances(const VertexArray &amp;va,const std::vector&lt;AGMatrix4&gt; &amp;ts)
+{
+  VertexArray *na=new VertexArray;
+  size_t start=0;
+  size_t ci;
+
+  for(std::vector&lt;AGMatrix4&gt;::const_iterator i=ts.begin();i!=ts.end();i++)
+    {
+      assert(va.mVertices.size()==va.mNormals.size());
+      // transform normals and vertices
+      for(size_t j=0;j&lt;va.mVertices.size();j++)
+	{
+	  AGVector4 v=va.mVertices[j];
+	  AGVector3 n=va.mNormals[j];
+
+	  v=*i*v;
+	  n=(*i*AGVector4(n,0)).dim3();
+	  
+	  na-&gt;mVertices.push_back(v);
+	  na-&gt;mNormals.push_back(n);
+	}
+
+      std::copy(va.mColors.begin(),va.mColors.end(),std::back_inserter(na-&gt;mColors));
+      std::copy(va.mTexCoords.begin(),va.mTexCoords.end(),std::back_inserter(na-&gt;mTexCoords));
+      std::copy(va.mTexCoords3D.begin(),va.mTexCoords3D.end(),std::back_inserter(na-&gt;mTexCoords3D));
+      for(std::vector&lt;Uint16&gt;::const_iterator j=va.mIndices.begin();j!=va.mIndices.end();j++)
+	{
+	  ci=*j+start;
+	  assert(ci&gt;=start);
+	  assert(ci&lt;na-&gt;mVertices.size());
+	  assert(ci&lt;na-&gt;mColors.size());
+	  assert(ci&lt;na-&gt;mNormals.size());
+	    
+	  na-&gt;mIndices.push_back(*j+start);
+	}
+      start+=va.mVertices.size();
+    }
+
+  na-&gt;bColor=va.bColor;
+  na-&gt;mChanged=true;
+
+  // calc bbox
+  na-&gt;bbox=AGBox3(AGVector3(),AGVector3());
+
+  
+
+  return na;
+}

Added: antargis/branches/rant/ext/3dengine/vertex_array.h
===================================================================
--- antargis/branches/rant/ext/3dengine/vertex_array.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/vertex_array.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,127 @@
+#ifndef __vertex_array_h
+#define __vertex_array_h
+
+#include &quot;scene.h&quot;
+#include &quot;glsl.h&quot;
+#include &lt;ag_geometry.h&gt;
+#include &lt;vector&gt;
+#define GL_GLEXT_PROTOTYPES
+#include &lt;SDL_opengl.h&gt;
+
+#include &lt;ag_surface.h&gt;
+
+/**
+   VertexArray is for fast drawing meshes (3d-models).
+   It supports indexed vertex-arrays. If you do not have them in this format
+   look at mesh_optimizer.h.
+   The possible drawing modes are detected automatically. The best one is always used.
+   These include:
+   * vertex-arrays
+   * vertex-buffers
+   * direct drawing mode (glVertex4f...)
+
+   if you have to do special drawing like picking, use the corresp. functions (drawDepth,drawPick)
+*/
+
+class VertexArray:public AGGLObject
+{
+  std::vector&lt;AGVector4&gt; mVertices,mColors;
+  std::vector&lt;AGVector3&gt; mNormals;
+  std::vector&lt;AGVector2&gt; mTexCoords;
+  std::vector&lt;AGVector3&gt; mTexCoords3D;
+  std::vector&lt;Uint16&gt;  mIndices;
+
+  bool bColor;
+  bool mBuffers;
+  bool mArrays;
+  bool mChanged;
+  bool mTextures3D;
+
+  /// VA is dynamic, when index-buffer changes
+  bool mDynamic;
+
+  unsigned int mVertexBuffer,mColorBuffer,mNormalBuffer,mTexBuffer,mIndexBuffer;
+
+  AGBox3 bbox;
+
+  GLuint displayList;
+  bool displayListInited;
+
+ public:
+  VertexArray(bool pDynamic=false);
+  virtual ~VertexArray();
+  void addVertex(AGVector4 pVertex, AGVector4 pColor, AGVector3 pNormal, AGVector2 pTex);
+  void addVertex(AGVector4 pVertex, AGVector4 pColor, AGVector3 pNormal, AGVector3 pTex);
+  void addTriangle(size_t p0,size_t p1,size_t p2);
+
+  void setColors(bool color);
+  void setBuffers(bool pBuffers);
+  
+  virtual void draw();
+  virtual void drawDepth();
+  void drawPick();
+  void init();
+
+  void clear();
+  void update();
+
+  size_t getTriangles() const
+  {
+    return mIndices.size()/3;
+  }
+  
+  size_t getIndex(size_t i);
+  AGVector4 getVertex(size_t i);
+  AGVector4 getColor(size_t i);
+  AGVector3 getNormal(size_t i);
+  AGVector2 getTexCoord(size_t i);
+
+  void setTexCoord(size_t i,const AGVector2 &amp;t);
+
+  AGVector4 lineHit(const AGLine3 &amp;pLine) const;
+
+  bool useVertexArrays() const;
+  friend VertexArray *makeInstances(const VertexArray &amp;va,const std::vector&lt;AGMatrix4&gt; &amp;ts);
+
+  void onScreenUp();
+  void onScreenDown();
+
+};
+
+/**
+   makeInstances can be used for some kind of &quot;batching&quot;.
+   It creates several instances of a mesh stored in va. The positions of the instances are 
+   given through transformation matrices in ts
+*/
+VertexArray *makeInstances(const VertexArray &amp;va,const std::vector&lt;AGMatrix4&gt; &amp;ts);
+
+/**
+   VertexArrayShader adds shader-support to vertex-arrays. You might need to attach data
+   to each vertex. You can do so by calling addAttribute(.,.).
+ */
+class VertexArrayShader:public VertexArray
+{
+  AntShaderProgram *p;
+  std::map&lt;std::string,std::vector&lt;float&gt;*&gt; as;
+  std::map&lt;std::string,unsigned int&gt; aids;
+
+  std::map&lt;std::string,std::vector&lt;Uint16&gt;*&gt; elementAs;
+  std::map&lt;std::string,unsigned int&gt; elementIds;
+
+  bool aInited;
+ public:
+  VertexArrayShader(AntShaderProgram *_p);
+  ~VertexArrayShader();
+  /// adds attributes to each vertex. the size of a should equal the vertex count
+  void addAttribute(const std::string &amp;pName,const std::vector&lt;float&gt; &amp;a);
+  void addAttribute(const std::string &amp;pName,const std::vector&lt;Uint16&gt; &amp;a);
+
+  virtual void draw();
+
+ private:
+  void aInit();
+  void attach();
+  
+};
+
+#endif

Modified: antargis/branches/rant/ext/basic/ag_main.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_main.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/basic/ag_main.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -52,11 +52,11 @@
 {
   return quited;
 }
-
+/*
 bool glMode()
 {
   return lastGL;
-}
+}*/
 
 
 /**

Added: antargis/branches/rant/ext/basic/ag_messageobject.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_messageobject.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/basic/ag_messageobject.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,677 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_messageobject.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_messageobject.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_main.h&quot;
+#include &quot;ag_stringstream.h&quot;
+#include &quot;ag_video.h&quot;
+
+SDL_Event AGEvent::NullEvent={SDL_NOEVENT};
+
+// AGEvent
+AGEvent::AGEvent(AGListener *pCaller,const AGString &amp;pName,const SDL_Event &amp;e):mCaller(pCaller),mName(pName),mEvent(e)
+{
+}
+AGEvent::~AGEvent()
+{
+}
+
+
+void AGEvent::setVector(const AGVector2 &amp;v)
+{
+  mVector=v;
+}
+/// returns the drag-vector in case of a drag-event
+AGVector2 AGEvent::getVector() const
+{
+  return mVector;
+}
+
+
+/// sets the caller of this event - shouldn't be used outside of AGWidget
+void AGEvent::setCaller(AGListener *pCaller)
+{
+  mCaller=pCaller;
+}
+
+/// return the name of the event
+AGString AGEvent::getName() const
+{
+  return mName;
+}
+
+
+void AGEvent::setName(const AGString &amp;n)
+{
+  mName=n;
+}
+
+bool AGEvent::isSDLEvent() const
+{
+  return eventOk(mEvent);
+}
+
+
+/// returns the caller of this event
+AGListener *AGEvent::getCaller() const
+{
+  return mCaller;
+}
+
+// AGSDLEvent
+
+const SDL_Event &amp;AGEvent::get() const
+{
+  assert(eventOk(mEvent));
+  return mEvent;
+}
+
+AGVector2 AGEvent::getMousePosition() const
+{
+  assert(eventOk(mEvent));
+  AGVector2 p;
+  switch(mEvent.type) {
+  case SDL_MOUSEMOTION:
+    p[0]=mEvent.motion.x*getVideo()-&gt;width()/getVideo()-&gt;realWidth();
+    p[1]=mEvent.motion.y*getVideo()-&gt;height()/getVideo()-&gt;realHeight();
+    break;
+    
+  case SDL_MOUSEBUTTONUP:
+  case SDL_MOUSEBUTTONDOWN:
+    p[0]=mEvent.button.x*getVideo()-&gt;width()/getVideo()-&gt;realWidth();
+    p[1]=mEvent.button.y*getVideo()-&gt;height()/getVideo()-&gt;realHeight();
+    break;
+    
+  }
+  return p;
+}
+
+Uint16 AGEvent::getUnicode() const
+{
+  assert(eventOk(mEvent));
+  return mEvent.key.keysym.unicode;
+}
+
+
+SDLKey AGEvent::getKey() const
+{
+  assert(eventOk(mEvent));
+  return mEvent.key.keysym.sym;
+}
+
+SDLMod AGEvent::getMod() const
+{
+  assert(eventOk(mEvent));
+  return mEvent.key.keysym.mod;
+}
+
+int AGEvent::getButton() const
+{
+  assert(eventOk(mEvent));
+  switch(mEvent.type) {
+  case SDL_MOUSEMOTION:
+    return mEvent.motion.state;
+    break;
+    
+  case SDL_MOUSEBUTTONUP:
+  case SDL_MOUSEBUTTONDOWN:
+    return mEvent.button.button;
+    break;
+    
+  }
+  return 0;
+}
+
+
+
+// AGMouseEvent
+
+/*
+AGMouseEvent::AGMouseEvent(AGListener *pCaller,SDL_Event *pEvent):AGEvent(pCaller)
+{
+}
+AGMouseEvent::~AGMouseEvent()
+{
+}*/
+
+// AGListener
+
+AGListener::AGListener()
+{
+}
+
+AGListener::~AGListener()
+{
+}
+
+bool AGListener::signal(AGEvent *m)
+{
+  return false;
+}
+
+AGCPPListener::~AGCPPListener()
+{
+}
+
+
+
+// AGSignal
+
+AGSignal::AGSignal():mCaller(0)
+{
+}
+
+//AGSignal::AGSignal(const AGSignal &amp;s):mListeners(s.mListeners
+
+
+
+AGSignal::AGSignal(AGMessageObject *pCaller):mCaller(pCaller)
+{
+}
+
+AGSignal::AGSignal(AGMessageObject *pCaller,const AGString &amp;pName):
+  mName(pName),mCaller(pCaller)
+{
+}
+
+AGSignal::~AGSignal()
+{
+  std::set&lt;AGListener*&gt;::iterator i=mListeners.begin();
+  for(;i!=mListeners.end();i++)
+    {
+      AGMessageObject *o=dynamic_cast&lt;AGMessageObject*&gt;(*i);
+      if(o)
+	o-&gt;popSignal(this);
+    }
+}
+#undef connect
+
+
+/**
+   This is the simple connect version. You have to override signal(.) in AGListener and
+   provide a reasonable functionality there. For simple usage use AGSignal::connect( AGCPPListener *pListener);
+
+*/
+void AGSignal::connect(AGListener &amp;pListener)
+{
+  mListeners.insert(&amp;pListener);
+  AGMessageObject *o=dynamic_cast&lt;AGMessageObject*&gt;(&amp;pListener);
+  if(o)
+    o-&gt;pushSignal(this);
+}
+void AGSignal::disconnect(AGListener &amp;pListener)
+{
+  mListeners.erase(&amp;pListener);
+}
+
+
+/**
+   When connecting a signal to a slot you call this function.
+   For instance you have a class:
+   &lt;pre&gt;
+   class A
+   {
+     public:
+     AGSignal sigSomething;
+   };
+   class B
+   {
+     public:
+     bool eventSomething( AGEvent *e);
+   };
+   A a;
+   B b;
+   // you can connect them like this;
+   A.sigSomething.connect(slot(&amp;b,&amp;B::eventSomething));
+   &lt;/pre&gt;
+*/
+
+void AGSignal::connect(AGCPPListener *pListener)
+{
+  mSimpleListeners.insert(pListener);
+}
+void AGSignal::disconnect(AGCPPListener *pListener)
+{
+  mSimpleListeners.erase(pListener);
+}
+
+bool AGSignal::signal(AGEvent *m)
+{
+  m-&gt;setName(mName);
+  std::set&lt;AGListener*&gt;::iterator i=mListeners.begin();
+  bool value=false;
+  for(;i!=mListeners.end();i++)
+    {
+      if((*i)-&gt;signal(m))
+	value=true;
+    }
+
+  std::set&lt;AGCPPListener*&gt;::iterator j=mSimpleListeners.begin();
+  for(;j!=mSimpleListeners.end();j++)
+    {
+      if((*j)-&gt;signal(m))
+	value=true;
+    }
+
+  return value;
+}
+
+bool AGSignal::operator()(AGEvent *m)
+{
+  m-&gt;setName(mName);
+  return signal(m);
+}
+
+// AGMessageObject
+
+
+AGMessageObject *AGMessageObject::captureObject=0;
+
+
+AGMessageObject::AGMessageObject():
+  sigActive(this,&quot;sigActive&quot;),
+  sigKeyDown(this,&quot;sigKeyDown&quot;),
+  sigKeyUp(this,&quot;sigKeyUp&quot;),
+  sigMouseMotion(this,&quot;sigMouseMotion&quot;),
+  sigMouseButtonDown(this,&quot;sigMouseButtonDown&quot;),
+  sigMouseButtonUp(this,&quot;sigMouseButtonUp&quot;),
+  sigQuit(this,&quot;sigQuit&quot;),
+  sigSysWM(this,&quot;sigSysWM&quot;),
+  sigVideoResize(this,&quot;sigVideoResize&quot;),
+  mCanReceiveMessages(true)
+{
+}
+
+AGMessageObject::~AGMessageObject()
+{
+  std::set&lt;AGSignal*&gt; sigs=mSignals;
+  std::set&lt;AGSignal*&gt;::iterator i=sigs.begin();
+  for(;i!=sigs.end();i++)
+    (*i)-&gt;disconnect(*this);
+}
+
+void AGMessageObject::pushSignal(AGSignal *pSignal)
+{
+  mSignals.insert(pSignal);
+}
+
+void AGMessageObject::popSignal(AGSignal *pSignal)
+{
+  mSignals.erase(pSignal);
+}
+
+
+// 
+// exchange with a processEvent(const AGEvent &amp;event)
+
+bool AGMessageObject::processEvent(AGEvent* agEvent) 
+{
+
+  //  dbout(1,&quot;typeid:&quot;&lt;&lt;typeid(this).name());
+  //  TRACE;
+  //  SDL_Event e;
+  bool rc=false;
+
+  //  const AGSDLEvent *agEvent=reinterpret_cast&lt;const AGSDLEvent*&gt;(pEvent);
+  if(agEvent-&gt;isSDLEvent())
+    {
+      const SDL_Event &amp;event=agEvent-&gt;get();
+      switch(event.type) {
+      case SDL_ACTIVEEVENT:
+	rc = eventActive(agEvent) || sigActive(agEvent);
+	break;
+	
+      case SDL_KEYDOWN:
+	rc = eventKeyDown(agEvent) || sigKeyDown(agEvent);
+	break;
+    
+      case SDL_KEYUP:
+	rc = eventKeyUp(agEvent) || sigKeyUp(agEvent);
+	break;
+	
+      case SDL_MOUSEMOTION:
+	rc = eventMouseMotion(agEvent) || sigMouseMotion(agEvent);
+	break;
+	
+      case SDL_MOUSEBUTTONDOWN:
+	rc = eventMouseButtonDown(agEvent) || sigMouseButtonDown(agEvent);
+	break;
+	
+      case SDL_MOUSEBUTTONUP:
+	rc = eventMouseButtonUp(agEvent) || sigMouseButtonUp(agEvent);
+	break;
+	
+      case SDL_QUIT:
+	rc = eventQuit(agEvent) || sigQuit(agEvent);
+	break;
+	
+      case SDL_SYSWMEVENT:
+	rc = eventSysWM(agEvent) || sigSysWM(agEvent);
+	break;
+	
+      case SDL_VIDEORESIZE:
+	rc = eventResize(agEvent) || sigVideoResize(agEvent);
+	break;
+	
+      default:
+	rc = false;
+	break;
+      }
+    }
+  
+  return rc;
+}
+
+
+
+bool AGMessageObject::eventActive(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventKeyDown(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventKeyUp(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventMouseMotion(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventMouseButtonDown(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventMouseButtonUp(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventQuit(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventQuitModal(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventSysWM(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventResize(AGEvent *m)
+{
+  return false;
+}
+
+Uint8 AGMessageObject::getButtonState() const
+{
+  int x,y;
+  Uint8 b=SDL_GetMouseState(&amp;x,&amp;y);
+  return b;
+}
+AGVector2 AGMessageObject::getMousePosition() const
+{
+  int x,y;
+  SDL_GetMouseState(&amp;x,&amp;y);
+  return AGVector2(x,y);
+}
+
+
+bool AGMessageObject::acceptEvent(const SDL_Event *pEvent)
+{
+  return true;
+}
+
+AGEvent *newEvent(AGListener *pCaller,const AGString &amp;pName,const SDL_Event &amp;s)
+{
+  return new AGEvent(pCaller,pName,s);
+}
+
+
+AGString toString(SDL_keysym k)
+{
+  AGStringStream os;
+  os&lt;&lt;k.scancode&lt;&lt;&quot;:&quot;&lt;&lt;(int)k.sym&lt;&lt;&quot;:&quot;&lt;&lt;k.mod&lt;&lt;&quot;:&quot;&lt;&lt;k.unicode;
+
+  return os.str();
+}
+
+AGString getUntil(AGString &amp;b,const AGString &amp;f)
+{
+  size_t i=b.find(f);
+  AGString s=b.substr(0,i);
+  if(i!=AGString::npos)
+    b=b.substr(i+1,AGString::npos);
+  return s;
+}
+
+SDL_keysym toKeysym(const AGString &amp;s)
+{
+  SDL_keysym k;
+  AGString b=s;
+  k.scancode=getUntil(b,&quot;:&quot;).toUint8();
+  k.sym=(SDLKey)getUntil(b,&quot;:&quot;).toUint8();
+  k.mod=(SDLMod)getUntil(b,&quot;:&quot;).toUint8();
+  k.unicode=getUntil(b,&quot;:&quot;).toSint16();
+  
+
+  return k;
+}
+
+AGString toString(SDL_Event *pEvent)
+{
+  AGStringStream os;
+  if(pEvent)
+    {
+      switch(pEvent-&gt;type)
+	{
+	case SDL_ACTIVEEVENT:
+	  os&lt;&lt;&quot;SDL_ACTIVEEVENT:&quot;&lt;&lt;(int)pEvent-&gt;active.gain&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;active.state;
+	  break;
+	case SDL_KEYDOWN:
+	  os&lt;&lt;&quot;SDL_KEYDOWN:&quot;&lt;&lt;(int)pEvent-&gt;key.which&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;key.state&lt;&lt;&quot;:&quot;&lt;&lt;toString(pEvent-&gt;key.keysym);
+	  break;
+	case SDL_KEYUP:
+	  os&lt;&lt;&quot;SDL_KEYUP:&quot;&lt;&lt;(int)pEvent-&gt;key.which&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;key.state&lt;&lt;&quot;:&quot;&lt;&lt;toString(pEvent-&gt;key.keysym);
+	  break;
+	case SDL_MOUSEMOTION:
+	  os&lt;&lt;&quot;SDL_MOUSEMOTION:&quot;&lt;&lt;(int)pEvent-&gt;motion.which&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;motion.state&lt;&lt;&quot;:&quot;&lt;&lt;pEvent-&gt;motion.x&lt;&lt;&quot;:&quot;&lt;&lt;pEvent-&gt;motion.y&lt;&lt;&quot;:&quot;&lt;&lt;pEvent-&gt;motion.xrel&lt;&lt;&quot;:&quot;&lt;&lt;pEvent-&gt;motion.yrel;
+	  break;
+	case SDL_MOUSEBUTTONDOWN:
+	  os&lt;&lt;&quot;SDL_MOUSEBUTTONDOWN:&quot;&lt;&lt;(int)pEvent-&gt;button.which&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;button.button&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;button.state&lt;&lt;&quot;:&quot;&lt;&lt;pEvent-&gt;button.x&lt;&lt;&quot;:&quot;&lt;&lt;pEvent-&gt;button.y;
+	  break;
+	case SDL_MOUSEBUTTONUP:
+	  os&lt;&lt;&quot;SDL_MOUSEBUTTONUP:&quot;&lt;&lt;(int)pEvent-&gt;button.which&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;button.button&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;button.state&lt;&lt;&quot;:&quot;&lt;&lt;pEvent-&gt;button.x&lt;&lt;&quot;:&quot;&lt;&lt;pEvent-&gt;button.y;
+	  break;
+	case SDL_JOYAXISMOTION:
+	  os&lt;&lt;&quot;SDL_JOYAXISMOTION:&quot;&lt;&lt;(int)pEvent-&gt;jaxis.which&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;jaxis.axis&lt;&lt;&quot;:&quot;&lt;&lt;pEvent-&gt;jaxis.value;
+	  break;
+	case SDL_JOYBALLMOTION:
+	  os&lt;&lt;&quot;SDL_JOYBALLMOTION:&quot;&lt;&lt;(int)pEvent-&gt;jball.which&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;jball.ball&lt;&lt;&quot;:&quot;&lt;&lt;pEvent-&gt;jball.xrel&lt;&lt;&quot;:&quot;&lt;&lt;pEvent-&gt;jball.yrel;
+	  break;
+	case SDL_JOYHATMOTION:
+	  os&lt;&lt;&quot;SDL_JOYHATMOTION:&quot;&lt;&lt;(int)pEvent-&gt;jhat.which&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;jhat.hat&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;jhat.value;
+	  break;
+	case SDL_JOYBUTTONDOWN:
+	  os&lt;&lt;&quot;SDL_JOYBUTTONDOWN:&quot;&lt;&lt;(int)pEvent-&gt;jbutton.which&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;jbutton.button&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;jbutton.state;
+	  break;
+	case SDL_JOYBUTTONUP:
+	  os&lt;&lt;&quot;SDL_JOYBUTTONUP:&quot;&lt;&lt;(int)pEvent-&gt;jbutton.which&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;jbutton.button&lt;&lt;&quot;:&quot;&lt;&lt;(int)pEvent-&gt;jbutton.state;
+	  break;
+	case SDL_QUIT:
+	  os&lt;&lt;&quot;SDL_QUIT:&quot;;
+	  break;
+	case SDL_SYSWMEVENT:
+	  os&lt;&lt;&quot;SDL_DUMMY;&quot;;
+	  break;
+	case SDL_VIDEOEXPOSE:
+	  os&lt;&lt;&quot;SDL_VIDEOEXPOSE&quot;;
+	  break;
+	case SDL_NOEVENT:
+	  os&lt;&lt;&quot;SDL_NOEVENT&quot;;
+	  break;
+	default:
+	  dbout(1,&quot;UNKNOWN SDL_EVENT:&quot;&lt;&lt;pEvent-&gt;type);
+	  os&lt;&lt;&quot;SDL_NOEVENT&quot;;
+	  break;
+	}
+      if(os.str().length())
+	return os.str();
+      
+    }
+  return &quot;SDL_NOEVENT&quot;;
+}
+
+
+
+SDL_Event *toSDLEvent(const AGString &amp;p)
+{
+  AGString b=p;
+  AGString t=getUntil(b,&quot;:&quot;);
+  static SDL_Event event;
+
+  event.type=0;
+
+  if(t==&quot;SDL_ACTIVEEVENT&quot;)
+    {
+      event.type=SDL_ACTIVEEVENT;
+      event.active.gain=getUntil(b,&quot;:&quot;).toUint8();
+      event.active.state=getUntil(b,&quot;:&quot;).toUint8();
+    }
+  else if(t==&quot;SDL_KEYDOWN&quot;)
+    {
+      event.type=SDL_KEYDOWN;
+      event.key.which=getUntil(b,&quot;:&quot;).toUint8();
+      event.key.state=getUntil(b,&quot;:&quot;).toUint8();
+      event.key.keysym=toKeysym(b);
+    }
+  else if(t==&quot;SDL_KEYUP&quot;)
+    {
+      event.type=SDL_KEYUP;
+      event.key.which=getUntil(b,&quot;:&quot;).toUint8();
+      event.key.state=getUntil(b,&quot;:&quot;).toUint8();
+      event.key.keysym=toKeysym(b);
+
+    }
+  else if(t==&quot;SDL_MOUSEMOTION&quot;)
+    {
+      event.type=SDL_MOUSEMOTION;
+      event.motion.which=getUntil(b,&quot;:&quot;).toUint8();
+      event.motion.state=getUntil(b,&quot;:&quot;).toUint8();
+      event.motion.x=getUntil(b,&quot;:&quot;).toSint16();
+      event.motion.y=getUntil(b,&quot;:&quot;).toSint16();
+      event.motion.xrel=getUntil(b,&quot;:&quot;).toSint16();
+      event.motion.yrel=getUntil(b,&quot;:&quot;).toSint16();
+    }
+  else if(t==&quot;SDL_MOUSEBUTTONDOWN&quot;)
+    {
+      event.type=SDL_MOUSEBUTTONDOWN;
+      event.button.which=getUntil(b,&quot;:&quot;).toUint8();
+      event.button.button=getUntil(b,&quot;:&quot;).toUint8();
+      event.button.state=getUntil(b,&quot;:&quot;).toUint8();
+      event.button.x=getUntil(b,&quot;:&quot;).toSint16();
+      event.button.y=getUntil(b,&quot;:&quot;).toSint16();
+    }
+  else if(t==&quot;SDL_MOUSEBUTTONUP&quot;)
+    {
+      event.type=SDL_MOUSEBUTTONUP;
+      event.button.which=getUntil(b,&quot;:&quot;).toUint8();
+      event.button.button=getUntil(b,&quot;:&quot;).toUint8();
+      event.button.state=getUntil(b,&quot;:&quot;).toUint8();
+      event.button.x=getUntil(b,&quot;:&quot;).toSint16();
+      event.button.y=getUntil(b,&quot;:&quot;).toSint16();
+    }
+  else if(t==&quot;SDL_JOYAXISMOTION&quot;)
+    {
+      event.type=SDL_JOYAXISMOTION;
+      event.jaxis.which=getUntil(b,&quot;:&quot;).toUint8();
+      event.jaxis.axis=getUntil(b,&quot;:&quot;).toUint8();
+      event.jaxis.value=getUntil(b,&quot;:&quot;).toUint8();
+    }
+  else if(t==&quot;SDL_JOYBALLMOTION&quot;)
+    {
+      event.type=SDL_JOYBALLMOTION;
+      event.jball.which=getUntil(b,&quot;:&quot;).toUint8();
+      event.jball.ball=getUntil(b,&quot;:&quot;).toUint8();
+      event.jball.xrel=getUntil(b,&quot;:&quot;).toSint16();
+      event.jball.yrel=getUntil(b,&quot;:&quot;).toSint16();
+    }
+  else if(t==&quot;SDL_JOYHATMOTION&quot;)
+    {
+      event.type=SDL_JOYHATMOTION;
+      event.jhat.which=getUntil(b,&quot;:&quot;).toUint8();
+      event.jhat.hat=getUntil(b,&quot;:&quot;).toUint8();
+      event.jhat.value=getUntil(b,&quot;:&quot;).toUint8();
+    }
+  else if(t==&quot;SDL_JOYBUTTONDOWN&quot;)
+    {
+      event.type=SDL_JOYBUTTONDOWN;
+      event.jbutton.which=getUntil(b,&quot;:&quot;).toUint8();
+      event.jbutton.button=getUntil(b,&quot;:&quot;).toUint8();
+      event.jbutton.state=getUntil(b,&quot;:&quot;).toUint8();
+    }
+  else if(t==&quot;SDL_JOYBUTTONUP&quot;)
+    {
+      event.type=SDL_JOYBUTTONUP;
+      event.jbutton.which=getUntil(b,&quot;:&quot;).toUint8();
+      event.jbutton.button=getUntil(b,&quot;:&quot;).toUint8();
+      event.jbutton.state=getUntil(b,&quot;:&quot;).toUint8();
+    }
+  else if(t==&quot;SDL_SYSWMEVENT&quot;)
+    {
+      event.type=SDL_SYSWMEVENT;
+      // FIXME
+    }
+  else if(t==&quot;SDL_VIDEOEXPOSE&quot;)
+    {
+      event.type=SDL_VIDEOEXPOSE;
+      
+    }
+  else if(t==&quot;SDL_DUMMY&quot;)
+    {
+      event.type=SDL_USEREVENT;
+    }
+  else if(t==&quot;SDL_QUIT&quot;)
+    {
+      event.type=SDL_QUIT;
+    }
+  else
+    {
+      event.type=SDL_NOEVENT;
+      return &event;
+    }
+  if(event.type)
+    return &event;
+
+  return 0;
+}
+bool eventOk(const SDL_Event &amp;pEvent)
+{
+  //  dbout(1,&quot;eventOk: check &quot;&lt;&lt;(int)pEvent.type&lt;&lt;&quot;!=&quot;&lt;&lt;SDL_NOEVENT&lt;&lt;&quot; ???&quot;);
+  return (int)pEvent.type!=SDL_NOEVENT;
+}
+
+void resetEvent(SDL_Event &amp;pEvent)
+{
+  pEvent.type=SDL_NOEVENT;
+}

Added: antargis/branches/rant/ext/basic/ag_messageobject.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_messageobject.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/basic/ag_messageobject.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,251 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_messageobject.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_MESSAGEOBJECT_H
+#define AG_MESSAGEOBJECT_H
+
+#include &lt;SDL.h&gt;
+#include &lt;string&gt;
+#include &lt;set&gt;
+
+#include &quot;ag_geometry.h&quot;
+#include &quot;ag_rubyobj.h&quot;
+
+class AGListener;
+class AGSignal;
+
+/** \defgroup events Event handling
+    \brief A small event handling mechanism
+
+    AntargisGUI contains a small event handling mechanism for both ruby and C++.
+    However they do work a little different.
+    
+    Each object that wants to send or receive a message (or event) must be derived from
+    AGMessageObject.
+
+*/
+
+
+
+/** AGEvent is the typical event which is passed when the user does anything.
+    You can however derive from it and pass it through a signal.
+    But you shouldn't delete it for yourself.
+ */
+class AGEvent
+{
+ public:
+  AGEvent(AGListener *pCaller,const AGString &amp;pName,const SDL_Event &amp;pEvent=NullEvent);
+  virtual ~AGEvent();
+
+  AGListener *getCaller() const;
+  
+  void setCaller(AGListener *pCaller);
+  AGString getName() const;
+
+  AGVector2 getMousePosition() const;
+  SDLKey getKey() const;
+  SDLMod getMod() const;
+  Uint16 getUnicode() const;
+  int getButton() const;
+
+  const SDL_Event &amp;get() const;
+
+  bool isSDLEvent() const;
+
+  void setName(const AGString &amp;n);
+
+  void setVector(const AGVector2 &amp;v);
+  AGVector2 getVector() const;
+
+ private:
+  AGListener *mCaller;
+  AGString mName;
+
+  SDL_Event mEvent;
+
+  AGVector2 mVector;
+
+ protected:
+  static SDL_Event NullEvent;
+};
+
+
+/**
+   AGListener is the base for receiving an event. Any object which is derived from AGListener can
+   receive an event. But you should use AGMessageObject for this, as it holds basic &quot;listening&quot;
+   facilities.
+   @see AGEvent
+*/
+class AGListener:public AGRubyObject
+{
+ public:
+  AGListener();
+  virtual ~AGListener();
+  virtual bool signal(AGEvent *m);
+  
+};
+
+/**
+   some syntactic sugar for simple connecting of slots and signals.
+   @see AGSignal
+   @see AGMessageObject
+*/
+class AGCPPListener
+{
+ public:
+  virtual ~AGCPPListener();
+  virtual bool signal(AGEvent *m) const=0;
+};
+
+/**
+   some syntactic sugar for simple connecting of slots and signals.
+   @see AGSignal
+   @see AGMessageObject
+*/
+template&lt;class T&gt;
+class AGSlot0:public AGCPPListener
+{
+ public:
+  typedef bool (T::*FKT)(AGEvent *m);
+  T *base;
+  FKT f;
+  
+  AGSlot0(T *pBase,FKT pF):
+    base(pBase),f(pF)
+    {
+    }
+    virtual ~AGSlot0()
+      {
+      }
+
+    virtual bool signal(AGEvent *m) const
+    {
+      return (base-&gt;*f)(m);
+    }
+};
+
+class AGMessageObject;
+
+/** AGSignal is a placeholder-class for a function which calls all the Slots, which 
+    are connected to this signal.
+    For instance a button named &quot;close&quot; holds a sigClick signal and a dialog box has a slotClose.
+    You call sigClick(event) in the button and the connected slot is automatically called.
+    @see connect()
+*/
+class AGSignal
+{
+ public:
+  AGSignal();
+  AGSignal(AGMessageObject *pCaller);
+  AGSignal(AGMessageObject *pCaller,const AGString &amp;pName);
+
+  virtual ~AGSignal();
+
+  void connect(AGListener &amp;pListener);
+  void disconnect(AGListener &amp;pListener);
+
+  void connect(AGCPPListener *pListener);
+  void disconnect(AGCPPListener *pListener);
+
+  bool signal(AGEvent *m);
+
+  bool operator()(AGEvent *m);
+ private:
+  std::set&lt;AGListener*&gt; mListeners;
+
+  std::set&lt;AGCPPListener*&gt; mSimpleListeners;
+
+  AGString mName;
+  AGMessageObject *mCaller;
+};
+
+/**
+   AGMessageObject handles libSDL-events and provides virtual handlers.
+*/
+class AGMessageObject:public AGListener
+{
+ public:
+  AGMessageObject();
+  virtual ~AGMessageObject();
+
+  bool processEvent(AGEvent *pEvent);
+
+  virtual bool acceptEvent(const SDL_Event *pEvent);
+
+
+  // event handler
+  virtual bool eventActive(AGEvent *m);
+  virtual bool eventKeyDown(AGEvent *m);
+  virtual bool eventKeyUp(AGEvent *m);
+  virtual bool eventMouseMotion(AGEvent *m);
+  virtual bool eventMouseButtonDown(AGEvent *m);
+  virtual bool eventMouseButtonUp(AGEvent *m);
+  virtual bool eventQuit(AGEvent *m);
+  virtual bool eventQuitModal(AGEvent *m);
+  virtual bool eventSysWM(AGEvent *m);
+  virtual bool eventResize(AGEvent *m);
+
+  virtual Uint8 getButtonState() const;
+  virtual AGVector2 getMousePosition() const;
+
+
+  AGSignal sigActive;
+  AGSignal sigKeyDown;
+  AGSignal sigKeyUp;
+  AGSignal sigMouseMotion;
+  AGSignal sigMouseButtonDown;
+  AGSignal sigMouseButtonUp;
+  AGSignal sigQuit;
+  AGSignal sigSysWM;
+  AGSignal sigVideoResize;
+
+  void pushSignal(AGSignal *pSignal);
+  void popSignal(AGSignal *pSignal);
+
+ private:
+  bool mCanReceiveMessages;
+
+  std::set&lt;AGSignal*&gt; mSignals;
+
+  static AGMessageObject *captureObject;
+};
+
+
+AGEvent *newEvent(AGListener *pCaller,const AGString &amp;pName,const SDL_Event &amp;s);
+
+/**
+ */   
+
+template&lt;class T&gt;
+AGCPPListener *slot(T *base,bool (T::*f)(AGEvent *))
+{
+  return new AGSlot0&lt;T&gt;(base,f);
+}
+
+
+AGString toString(SDL_Event *pEvent);
+SDL_Event *toSDLEvent(const AGString &amp;p);
+
+bool eventOk(const SDL_Event &amp;pEvent);
+void resetEvent(SDL_Event &amp;pEvent);
+
+#endif

Added: antargis/branches/rant/ext/basic/ag_mutex.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_mutex.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/basic/ag_mutex.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,28 @@
+#include &quot;ag_mutex.h&quot;
+#include &lt;stdlib.h&gt;
+
+AGMutex::AGMutex()
+{
+  mut=SDL_CreateMutex();
+
+}
+AGMutex::~AGMutex()
+{
+  SDL_DestroyMutex(mut);
+}
+
+void AGMutex::enter()
+{
+  if(SDL_mutexP(mut)==-1){
+    fprintf(stderr, &quot;Couldn't lock mutex\n&quot;);
+    exit(-1);
+  }
+}
+
+void AGMutex::leave()
+{
+  if(SDL_mutexV(mut)==-1){
+    fprintf(stderr, &quot;Couldn't unlock mutex\n&quot;);
+    exit(-1);
+  }
+}

Added: antargis/branches/rant/ext/basic/ag_mutex.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_mutex.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/basic/ag_mutex.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,20 @@
+#ifndef AG_MUTEX
+#define AG_MUTEX
+
+#include &lt;SDL.h&gt;
+#include &lt;SDL_thread.h&gt;
+
+class AGMutex
+{
+ public:
+  AGMutex();
+  ~AGMutex();
+
+  void enter();
+  void leave();
+ private:
+  SDL_mutex *mut;
+
+};
+
+#endif

Added: antargis/branches/rant/ext/game/ant_app.cc
===================================================================
--- antargis/branches/rant/ext/game/ant_app.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/ant_app.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,185 @@
+#include &quot;ant_app.h&quot;
+#include &quot;ag_vdebug.h&quot;
+#include &quot;ag_profiler.h&quot;
+
+GLApp::GLApp(int w,int h):scene(w,h)
+{
+  CTRACE;
+  shadow=true;
+  mx=my=0;
+  omx=-1;
+  frameTime=0;
+  frameCount=0;
+  hx=hy=-1;
+}
+
+GLApp::~GLApp()
+{
+  CTRACE;
+}
+
+
+void GLApp::draw()
+{
+  STACKTRACE;
+  drawGL();
+  AGApplication::draw();
+}
+
+void GLApp::drawGL()
+{
+  STACKTRACE;
+  glEnable(GL_DEPTH_TEST); // enable depth test
+  glDepthMask(true);
+
+  assertGL;
+  scene.draw();
+  assertGL;
+}
+
+bool GLApp::eventFrame(float t)
+{
+  if(hx&gt;=0)
+    {
+      // check hovering
+      Scene::PickResult nodes=scene.pick(hx,hy,1,1);
+      
+      if(nodes.size())
+	eventHover(nodes,hb);
+      hx=hy=-1;
+    }
+  return true;
+}
+
+bool GLApp::eventMouseButtonDown(AGEvent *e)
+{
+  mMayClick=true;
+
+  if(e-&gt;isSDLEvent())
+    {
+      if(e-&gt;getButton()==5)
+	{
+	  getScene().getCameraObject().incCameraDistance();
+	}
+      else if(e-&gt;getButton()==4)
+	{
+	  getScene().getCameraObject().decCameraDistance();
+	}
+      else if(e-&gt;getButton()==1)
+	{
+	  AGVector2 p=e-&gt;getMousePosition();
+	  omx=p[0];
+	  omy=p[1];
+	}
+      /*      else if(e-&gt;getButton()==1)
+	{
+	  AGVector2 p=e-&gt;getMousePosition();
+	  Scene::PickResult nodes=scene.pick(p[0],p[1],1,1);
+	  }*/
+    }
+  return AGApplication::eventMouseButtonDown(e);
+}
+bool GLApp::eventMouseButtonUp(AGEvent *e)
+{
+  CTRACE;
+  omx=-1;
+  omy=-1;
+  if(mMayClick)
+    {
+      if(e-&gt;isSDLEvent())
+	{
+	  if(e-&gt;getButton()&lt;4)
+	    {
+	      STACKTRACE;
+	      AGVector2 p=e-&gt;getMousePosition();
+	      Scene::PickResult nodes=scene.pick(p[0],p[1],1,1);
+
+	      eventClick(nodes,e-&gt;getButton());
+	    }
+	}
+    }
+  else
+    {
+      cdebug(&quot;click failed&quot;);
+    }
+  return AGApplication::eventMouseButtonUp(e);
+}
+
+void GLApp::eventClick(const Scene::PickResult &amp;pNodes,int button)
+{
+}
+
+void GLApp::eventHover(const Scene::PickResult &amp;pNodes,int button)
+{
+}
+
+
+bool GLApp::eventMouseMotion(AGEvent *e)
+{
+  if(e-&gt;isSDLEvent() &amp;&amp; omx&gt;=0)
+    {
+      AGVector2 p=e-&gt;getMousePosition();
+      //      AGVector4 cam=scene.getCamera();
+      mx=p[0]-omx;
+      my=p[1]-omy;
+      
+      setCamera(getCamera()+AGVector2(-mx*0.03,my*0.03));
+      //      camera=cam+AGVector4(-mx*0.03,my*0.03,0);
+      //      scene.setCamera(camera);
+      
+      omx=p[0];
+      omy=p[1];
+    }
+  if(e-&gt;isSDLEvent())
+    {
+      // check hovering - delayed 
+      AGVector2 p=e-&gt;getMousePosition();
+      hx=p[0];
+      hy=p[1];
+      hb=e-&gt;getButton();
+    }
+
+  mMayClick=false;
+  return AGApplication::eventMouseMotion(e);
+}
+
+AGVector2 GLApp::getCamera() const
+{
+  return scene.getCamera().dim2();
+}
+
+void GLApp::setCamera(const AGVector2 &amp;p)
+{
+  scene.setCamera(AGVector4(p[0],p[1],getCameraHeight(p)));
+}
+
+bool GLApp::eventKeyDown(AGEvent *e)
+{
+  if(e-&gt;isSDLEvent())
+    {
+      if(e-&gt;getKey()==SDLK_s)
+	{
+	  //	    shadow=!shadow;
+	  scene.setShadow((scene.getShadow()+1)%3);
+	}
+    }
+  return AGApplication::eventKeyDown(e);
+}
+
+Scene &amp;GLApp::getScene()
+{
+  assert(&amp;scene);
+  return scene;
+}
+
+void GLApp::mark()
+{
+  //CTRACE;
+  markObject(&amp;scene);
+  AGApplication::mark();
+}
+
+float GLApp::getCameraHeight(const AGVector2&amp;p)
+{
+  return 0;
+}

Added: antargis/branches/rant/ext/game/ant_app.h
===================================================================
--- antargis/branches/rant/ext/game/ant_app.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/ant_app.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,84 @@
+#ifndef ANT_APP_H
+#define ANT_APP_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+/**
+ *	
+ * \mainpage Battles of Antargis - C++ documentation
+ *  \section Overview
+ *    This is the C++ part of the API-documentation.
+ *    It consists of three major parts:
+ *    \see AntargisGUI
+ *    \see Engine3d
+ *    \see GameEngine
+ * 
+ *    For information about the overall-architecture please refer to the ruby-documentation at: ../ruby/index.html
+ *
+ * 
+
+
+
+*/
+
+
+
+#include &quot;scene.h&quot;
+#include &quot;ant_renderer.h&quot;
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+#include &lt;ag_application.h&gt;
+#include &lt;ag_debug.h&gt;
+#include &lt;ag_main.h&gt;
+#include &lt;ag_geometry.h&gt;
+
+#ifndef SWIG
+extern std::ofstream out;
+#endif
+
+class GLApp:public AGApplication
+{
+  bool shadow;
+  float mx,my;
+  float omx,omy;
+  AGVector4 camera;
+  float frameTime;
+  size_t frameCount;
+
+  bool mMayClick;
+
+  float hx,hy;
+  int hb;
+
+protected:
+  Scene scene;
+  
+public:
+  GLApp(int w,int h);
+  ~GLApp();
+
+  virtual void draw();
+  void drawGL();
+
+  bool eventFrame(float t);
+
+  virtual void eventClick(const Scene::PickResult &amp;pNodes,int button);
+  virtual void eventHover(const Scene::PickResult &amp;pNodes,int button);
+
+  virtual bool eventMouseButtonDown(AGEvent *m);
+  virtual bool eventMouseButtonUp(AGEvent *m);
+  virtual bool eventMouseMotion(AGEvent *m);
+  virtual bool eventKeyDown(AGEvent *m);
+
+  Scene &amp;getScene();
+
+  virtual float getCameraHeight(const AGVector2&amp;p);
+  virtual void setCamera(const AGVector2&amp;p);
+  AGVector2 getCamera() const;
+
+  void mark();
+};
+
+
+
+#endif

Added: antargis/branches/rant/ext/game/entity.cc
===================================================================
--- antargis/branches/rant/ext/game/entity.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/entity.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,888 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * entity.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;entity.h&quot;
+#include &quot;map.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;jobs.h&quot;
+#include &quot;mesh.h&quot;
+#include &quot;anim_mesh.h&quot;
+
+AntEntity::AntEntity(const AGVector3 &amp;p):mPos(p)
+{
+  init();
+}
+AntEntity::AntEntity(const AGVector2 &amp;p):mPos(getMap()-&gt;getPos(p))
+{
+  init();
+}
+
+AntEntity::AntEntity():mPos(0,0,0)
+{
+  init();
+}
+
+void AntEntity::init()
+{
+  mRubyObject=false;
+
+  mID=getMap()-&gt;getNewID();
+
+  mShowOnMinimap=false;
+  onGround=true;
+  onWater=false;
+
+  mJob=0;
+
+  mVirtualY=40;
+
+  mEnergy=1.0;
+  mHealSpeed=0.07;
+
+  mMorale=1.0;
+  mMoraleHeal=0.05;
+
+  mMoveSpeed=2;
+
+  mAggression=1;
+
+  //  mSurface=0;
+  //esh=0;
+  mDir=0;
+
+  mStrength=0.02;
+  mMoraleStrength=0.04;
+
+  mFood=1.0;
+  mHunger=0.006;
+  mHungerHitEnergy=0.02;
+  mHungerHitMorale=0.14;
+
+  mMoraleFlag=true;
+
+  mDefense=1.0;
+  //  mDirNum=1;
+
+  mMinimapSize=2;
+
+  experience=0;
+  learnAmount=0.1;
+
+  mDefeated=false;
+}
+
+
+AntEntity::~AntEntity()
+{
+  //  CTRACE;
+  for(Meshes::iterator i=mMeshes.begin();i!=mMeshes.end();i++)
+    saveDelete(*i);
+  mMeshes.clear();
+  delete mJob;
+}
+
+void AntEntity::resourceChanged()
+{
+}
+
+void AntEntity::saveXML(Node &amp;node) const
+  {
+    Node &amp;child=node.addChild(&quot;position&quot;);
+    mPos.saveXML(child);
+    node.set(&quot;energy&quot;,AGString(mEnergy));
+    node.set(&quot;healSpeed&quot;,AGString(mHealSpeed));
+    node.set(&quot;onGround&quot;,AGString(onGround));
+    node.set(&quot;onWater&quot;,AGString(onWater));
+    //    node.set(&quot;entityID&quot;,AGString(getID()));
+    node.set(&quot;name&quot;,getName());
+    //    node.set(&quot;classtype&quot;,getType());
+    node.set(&quot;morale&quot;,AGString(mMorale));
+    node.set(&quot;aggression&quot;,AGString(mAggression));
+    node.set(&quot;food&quot;,AGString(mFood));
+    node.set(&quot;id&quot;,AGString(mID));
+    node.set(&quot;exp&quot;,AGString(experience));
+    node.set(&quot;learnAmount&quot;,AGString(learnAmount));
+
+    node.set(&quot;defeated&quot;,AGString(mDefeated));
+
+    Node &amp;res=node.addChild(&quot;resource&quot;);
+    resource.saveXML(res);
+
+
+
+    if(mJob)
+      {
+	Node &amp;j=node.addChild(&quot;job&quot;);
+	j.set(&quot;type&quot;,mJob-&gt;xmlName());
+	mJob-&gt;saveXML(j);
+      }
+
+  }
+void AntEntity::loadXML(const Node &amp;node)
+{
+  mEnergy=node.get(&quot;energy&quot;).toFloat();
+  mHealSpeed=node.get(&quot;healSpeed&quot;).toFloat();
+  onGround=node.get(&quot;onGround&quot;).toBool();
+  onWater=node.get(&quot;onWater&quot;).toBool();
+
+  mDefeated=node.get(&quot;defeated&quot;).toBool();
+  //  assert(onGround);
+  Node::NodeVector v=node.getChildren(&quot;position&quot;);
+  Node::const_iterator i=v.begin();
+  for(;i!=v.end();i++)
+    mPos.loadXML(**i);
+  mID=node.get(&quot;entityID&quot;).toInt();
+  getMap()-&gt;useID(mID);
+  if(node.get(&quot;morale&quot;)!=&quot;&quot;)
+    mMorale=node.get(&quot;morale&quot;).toFloat();
+  else
+    mMorale=1.0f;
+  mAggression=node.get(&quot;aggression&quot;).toFloat();
+  mAggression=std::min(3,std::max(1,int(mAggression))); //1,2,3 nothing else
+
+  if(node.get(&quot;food&quot;)!=&quot;&quot;)
+    mFood=node.get(&quot;food&quot;).toFloat();
+  if(node.get(&quot;hunger&quot;)!=&quot;&quot;)
+    mHunger=node.get(&quot;hunger&quot;).toFloat();
+
+  setName(node.get(&quot;name&quot;));
+  //  setType(node.get(&quot;classtype&quot;));
+
+  if(node.get(&quot;exp&quot;)!=&quot;&quot;)
+    experience=node.get(&quot;exp&quot;).toFloat();
+  if(node.get(&quot;learnAmount&quot;)!=&quot;&quot;)
+    learnAmount=node.get(&quot;learnAmount&quot;).toFloat();
+
+  Node::NodeVector v2=node.getChildren(&quot;resource&quot;);
+  if(v2.size()&gt;0)
+    resource.loadXML(v2[0]);
+  
+  v2=node.getChildren(&quot;job&quot;);
+  if(v2.size()&gt;0)
+    {
+      loadJob(v2[0]);
+    }
+  resourceChanged();
+}
+
+void AntEntity::loadJob(const Node &amp;pNode)
+{
+  AGString t=pNode.get(&quot;type&quot;);
+  if(t==&quot;restJob&quot;)
+    mJob=new RestJob;
+  else if(t==&quot;fightJob&quot;)
+    mJob=new FightJob;
+  else if(t==&quot;moveJob&quot;)
+    mJob=new MoveJob;
+  else if(t==&quot;fetchJob&quot;)
+    mJob=new FetchJob;
+  if(mJob)
+    mJob-&gt;loadXML(pNode);
+}
+
+
+AGVector3 AntEntity::getPos3D() const
+  {
+    return mPos;
+  }
+AGVector2 AntEntity::getPos2D() const
+  {
+    return AGVector2(mPos[0],mPos[1]);
+  }
+
+void AntEntity::updatePos(const AGVector3 &amp;p)
+{
+  if(mMeshes.size()==1)
+    {
+      mMeshes.front()-&gt;setPos(p);
+      return;
+    }
+  for(Meshes::iterator i=mMeshes.begin();i!=mMeshes.end();i++)
+    {
+      (*i)-&gt;setPos(p+mMeshPos[*i]);
+      (*i)-&gt;setRotation(mDir);
+    }
+  
+}
+
+void AntEntity::setPos(const AGVector3 &amp;p)
+{
+  mPos=p;
+  updatePos(p);
+}
+void AntEntity::setPos(const AGVector2 &amp;pp)
+{
+  AGVector2 p=getMap()-&gt;truncPos(pp); // make sure, that position is ok
+  if(onGround)
+    mPos=getMap()-&gt;getPos(p);
+  else if(onWater)
+    mPos=AGVector3(p,0);
+  else
+    {
+      mPos=AGVector3(p,mPos[2]);
+    }
+  updatePos(mPos);
+}
+
+void AntEntity::delJob()
+{
+  setJob(0);
+}
+
+void AntEntity::setJob(Job *pJob)
+{
+  //  assert(pJob);
+  if(mJob)
+    {
+      if(pJob)
+	{
+	  if((*mJob)&lt;=(*pJob))
+	    {
+	      mJobFinished.push_back(mJob);
+	      //delete mJob;
+	    }
+	  else
+	    {
+	      // FIXME: Priorities are ignored for now
+	      //	      throw int(); // FIXME: delete this, it's a test if priorities get handled correctly
+	      mJobFinished.push_back(mJob);
+	      //	      delete pJob;
+	      //	  return;
+	    }
+	}
+      else
+	mJobFinished.push_back(mJob);
+    }
+  mJob=0;
+  if(mEnergy&gt;=0.0) // do job anyways
+    {
+      if(!pJob)
+	mJob=pJob;
+      else
+	{
+	  if(mMorale&gt;0.1 || !pJob-&gt;needsMorale()) // at least 10% morale
+	    mJob=pJob;
+	  else
+	    mJobFinished.push_back(pJob);
+	}
+    }
+  else
+    {
+      if(pJob)
+	mJobFinished.push_back(pJob);
+    }
+  if(mJob)
+    eventGotNewJob();
+}
+
+void AntEntity::eventGotNewJob()
+{
+}
+
+
+/** do anything in given time frame */
+void AntEntity::move(float pTime)
+{
+  if(mJobFinished.size() || mEnergy==0.0)
+    {
+      std::list&lt;Job*&gt;::iterator i=mJobFinished.begin();
+      for(;i!=mJobFinished.end();i++)
+	delete *i;
+      mJobFinished.clear();
+    }
+  else if(mEnergy&gt;0.0)
+    {
+      starve(pTime);
+
+      if(mMorale&lt;=0.1)
+	if(mJob)
+	  {
+	    assert(mJob-&gt;valid());
+	    if(mJob-&gt;needsMorale())
+	      setJob(0);// kill job
+	  }
+      if(!isStarving())
+	{
+	  mEnergy+=pTime*getHealSpeed()*0.2; // very slow healing when doin something
+	  if(mEnergy&gt;1.0)
+	    mEnergy=1.0;
+	}
+    }
+  if(mJob)
+    {
+      assert(mJob-&gt;valid());
+      mJob-&gt;move(this,pTime);
+    }
+  else
+    eventNoJob();
+
+}
+
+void AntEntity::heal(float pTime)
+{
+  if(!isStarving())
+    {
+      mEnergy+=pTime*getHealSpeed()*0.8; // only rest til 1.0
+      if(mEnergy&gt;1.0)
+	mEnergy=1.0;
+    }
+}
+
+void AntEntity::incMorale(float pTime)
+{
+  if(!isStarving())
+    {
+      mMorale+=pTime*mMoraleHeal;
+      if(mMorale&gt;1.0)
+	mMorale=1.0;
+      if(mMorale&gt;0.5)
+	mDefeated=false;
+    }
+}
+
+
+
+
+void AntEntity::eventJobFinished()
+{
+}
+
+void AntEntity::eventNoJob()
+{
+}
+
+
+void AntEntity::eventMapChanged()
+{
+  setPos(mPos);
+  /*
+  if(onGround)
+    mPos=getMap()-&gt;getPos(AGVector2(getPos2D()));
+  else if(onWater)
+    mPos=AGVector3(getPos2D()[0],getPos2D()[1],0);
+  */
+  updatePos(mPos);
+}
+
+void AntEntity::setMesh(SceneNode *m)
+{
+  // clear meshes from scene
+  for(Meshes::iterator i=mMeshes.begin();i!=mMeshes.end();i++)
+      saveDelete(*i);
+
+  mMeshes.clear();
+  mMeshPos.clear();
+  if(m)
+    {
+      AnimMesh *mesh=dynamic_cast&lt;AnimMesh*&gt;(m);
+      if(mesh)
+	mesh-&gt;setEntity(this);
+      mMeshes.push_back(m);
+
+      updatePos(mPos);
+    }
+}
+
+void AntEntity::addMesh(SceneNode *m,const AGVector3 &amp;v)
+{
+  if(m)
+    {
+      AnimMesh *mesh=dynamic_cast&lt;AnimMesh*&gt;(m);
+      if(mesh)
+	mesh-&gt;setEntity(this);
+      mMeshes.push_back(m);
+      mMeshPos.insert(std::make_pair(m,v));
+
+      updatePos(mPos);
+    }
+}
+
+
+AntEntity::Meshes AntEntity::getMesh()
+{
+  return mMeshes;
+}
+
+SceneNode *AntEntity::getFirstMesh()
+{
+  return mMeshes.front();
+}
+
+
+
+int AntEntity::getID() const
+{
+  return mID;
+}
+
+AGString AntEntity::xmlName() const
+{
+  return &quot;antEntity&quot;;
+}
+float AntEntity::getDirection() const
+{
+  return mDir;
+}
+
+
+void AntEntity::setDirection(float dir)
+{
+  mDir=dir;
+
+  if(mMeshes.size())
+    {
+      SceneNode *m=mMeshes.front();
+      if(m)
+	m-&gt;setRotation(dir);
+    }
+}
+
+void AntEntity::setVisible(bool v)
+{
+  for(Meshes::iterator i=mMeshes.begin();i!=mMeshes.end();i++)
+    (*i)-&gt;setVisible(v);
+}
+
+
+
+
+void AntEntity::newRestJob(float pTime)
+{
+  setJob(new RestJob(pTime));
+}
+void AntEntity::newFetchJob(int p,AGVector2 &amp;pTarget,const AGString &amp;what)
+{
+  setJob(new FetchJob(p,pTarget,what));
+}
+void AntEntity::newFetchJob(int p,AntEntity *pTarget,const AGString &amp;what)
+{
+  setJob(new FetchJob(p,pTarget,what));
+}
+void AntEntity::newMoveJob(int p,const AGVector2 &amp;pTarget,float pnear)
+{
+  setJob(new MoveJob(p,pTarget,pnear));
+}
+void AntEntity::newMoveJob(int p,const AGVector3 &amp;pTarget,float pnear)
+{
+  setJob(new MoveJob(p,pTarget,pnear));
+}
+
+void AntEntity::newMoveJob(int p,AntEntity *pTarget,float pnear)
+{
+  setJob(new MoveJob(p,pTarget,pnear));
+}
+
+
+void AntEntity::newFightJob(int p,AntEntity *target,float distance)
+{
+  if(!canFight())
+    return;
+  if(mJob)
+    {
+      FightJob *f=dynamic_cast&lt;FightJob*&gt;(mJob);
+      if(f)
+	if(f-&gt;getTarget()==target)
+	  return;
+    }
+  setJob(new FightJob(p,target,distance));
+}
+
+void AntEntity::setSpeed(float f)
+{
+  mMoveSpeed=f;
+}
+float AntEntity::getSpeed() const
+{
+  return mMoveSpeed;
+}
+
+void AntEntity::setHealSpeed(float f)
+{
+  mHealSpeed=f;
+}
+
+void AntEntity::setMoraleHealSpeed(float f)
+{
+  mMoraleHeal=f;
+}
+
+void AntEntity::setMoraleFlag(bool f)
+{
+  mMoraleFlag=f;
+}
+
+
+void AntEntity::decEnergy(float amount)
+{
+  mEnergy-=amount;
+  if(mEnergy&lt;0.0)
+    {
+      mEnergy=0.0;
+      eventDie();
+    }
+}
+
+bool AntEntity::hasJob() const
+      {
+        return mJob;
+      }
+
+float AntEntity::getHealSpeed() const
+      {
+        return mHealSpeed;
+      }
+
+
+void AntEntity::decMorale(float amount)
+{
+  if(!mMoraleFlag)
+    return;
+  mMorale-=amount;
+  if(mMorale&lt;0.0)
+    {
+      mMorale=0.0;
+      mDefeated=true;
+      eventMoraleLow();
+    }
+}
+
+
+void AntEntity::eventDie()
+{
+  sigJobFinished();
+}
+
+float AntEntity::getMorale() const
+{
+  return mMorale;
+}
+float AntEntity::getEnergy() const
+{
+  return mEnergy;
+}
+
+void AntEntity::setAggression(float agg)
+{
+  mAggression=agg;
+}
+float AntEntity::getAggression() const
+{
+  return mAggression;
+}
+
+void AntEntity::eventGotFight(AntEntity*pOther)
+{
+}
+
+void AntEntity::eventDefeated()
+{
+}
+
+void AntEntity::sigDefeated()
+{
+  if(!mMoraleFlag)
+    return;
+  mMorale=-0.1; // really deep morale
+  mDefeated=true;
+  // this prevents other fight-jobs from not being discarded
+  eventDefeated();
+}
+
+
+
+void AntEntity::setName(const AGString &amp;pName)
+{
+  mName=pName;
+}
+AGString AntEntity::getName() const
+{
+  return mName;
+}
+
+/*void AntEntity::setType(const AGString &amp;pType)
+{
+  mType=pType;
+}
+AGString AntEntity::getType() const
+{
+  return mType;
+  }*/
+
+AGRect2 AntEntity::getRect() const
+{
+  // FIXME: exchange this with something suitable
+  return AGRect2(mPos[0]-0.1, mPos[1]-0.1, 0.2, 0.2);
+}
+
+
+
+void AntEntity::mark()
+{
+  AGRubyObject::mark();
+  for(Meshes::iterator i=mMeshes.begin();i!=mMeshes.end();i++)
+    markObject(*i);
+
+  if(mJob)
+    {
+      MoveJob *mj=dynamic_cast&lt;MoveJob*&gt;(mJob);
+      FightJob *fj=dynamic_cast&lt;FightJob*&gt;(mJob);
+      if(mj)
+	if(mj-&gt;getTarget())
+	  markObject(mj-&gt;getTarget(),false);
+      if(fj)
+	if(fj-&gt;getTarget())
+	  markObject(fj-&gt;getTarget(),false);
+	
+    }
+}
+
+
+void AntEntity::clear()
+{
+  clearMeshes();
+}
+
+
+void AntEntity::clearMeshes()
+{
+  for(Meshes::iterator i=mMeshes.begin();i!=mMeshes.end();i++)
+    {
+      saveDelete(*i);
+    }
+  mMeshes.clear();
+}
+
+void AntEntity::animationEvent(const AGString &amp;pName)
+{
+}
+
+void AntEntity::setMinimapColor(const AGColor &amp;c)
+{
+  mMinimapColor=c;
+  mShowOnMinimap=true;
+}
+
+AGColor AntEntity::getMinimapColor() const
+{
+  return mMinimapColor;
+}
+
+bool AntEntity::showOnMinimap() const
+{
+  return mShowOnMinimap;
+}
+
+void AntEntity::setStrength(float f)
+{
+  mStrength=f;
+}
+float AntEntity::getStrength() const
+{
+  return mStrength;
+}
+void AntEntity::setMoraleStrength(float f)
+{
+  mMoraleStrength=f;
+}
+float AntEntity::getMoraleStrength() const
+{
+  return mMoraleStrength;
+}
+
+void AntEntity::setDefense(float f)
+{
+  assert(f&gt;0);
+  mDefense=f;
+}
+float AntEntity::getDefense() const
+{
+  return mDefense;
+}
+
+
+void AntEntity::setProvide(const AGString &amp;pName,bool flag)
+{
+  if(flag)
+    mProvides.insert(pName);
+  else
+    mProvides.erase(pName);
+}
+
+bool AntEntity::provides(const AGString &amp;pName) const
+{
+  return(mProvides.find(pName)!=mProvides.end());
+}
+
+bool AntEntity::canFight() const
+{
+  return (getEnergy()&gt;0.0 &amp;&amp; getMorale()&gt;=0.1 &amp;&amp; !mDefeated);
+}
+
+bool AntEntity::isFighting() const
+{
+  if(mJob)
+    {
+      FightJob *f=dynamic_cast&lt;FightJob*&gt;(mJob);
+      return f;
+    }
+  return false;
+}
+
+void AntEntity::sigJobFinished()
+{
+  mJobFinished.push_back(mJob);
+  mJob=0;
+  eventJobFinished();
+}
+
+void AntEntity::eventHaveDefeated(AntEntity *e)
+{
+}
+
+
+
+float AntEntity::getFood() const
+{
+  return mFood;
+}
+
+void AntEntity::incFood(float v)
+{
+  mFood+=v;
+  mFood=std::min(1.0f,mFood);
+}
+
+void AntEntity::starve(float pTime)
+{
+  mFood-=pTime*mHunger;
+  if(isStarving())
+    {
+      // get time for which mFood==0
+      float t=-mFood/mHunger;
+
+      // hit energy
+      decEnergy(mHungerHitEnergy*t);
+
+      // hit morale
+      decMorale(mHungerHitMorale*t);
+
+
+      mFood=0;
+    }
+}
+
+void AntEntity::eventMoraleLow()
+{
+}
+
+bool AntEntity::isStarving() const
+{
+  return mFood&lt;=0;
+}
+
+void AntEntity::eventStartFighting()
+{
+}
+void AntEntity::eventStartMoving()
+{
+}
+
+void AntEntity::setHunger(float f)
+{
+  mHunger=f;
+}
+
+bool AntEntity::eventHitWaterMark(bool fromAbove)
+{
+  return true;
+}
+
+void AntEntity::setOnGround(bool p)
+{
+  onGround=false;
+}
+
+void AntEntity::setOnWater(bool p)
+{
+  if(p)
+    {
+      onWater=true;
+      onGround=false;
+    }
+  else
+    {
+      onWater=false;
+      onGround=true;
+    }
+  
+}
+bool AntEntity::isMoving() const
+{
+  if(!mJob)
+    return false;
+  return dynamic_cast&lt;MoveJob*&gt;(mJob);
+}
+
+AntEntity *AntEntity::getFightTarget()
+{
+  if(mJob)
+    {
+      FightJob *f=dynamic_cast&lt;FightJob*&gt;(mJob);
+      if(f)
+	return f-&gt;getTarget();
+    }
+  return 0;
+}
+
+void AntEntity::setMinimapSize(float f)
+{
+  mMinimapSize=f;
+}
+
+float AntEntity::getMinimapSize() const
+{
+  return mMinimapSize;
+}
+
+bool AntEntity::isOnWater() const
+{
+  return onWater;
+}
+
+bool AntEntity::isOnGround() const
+{
+  return onGround;
+}
+
+void AntEntity::experienceFull()
+{
+}
+
+void AntEntity::incExperience(float a)
+{
+  experience+=a;
+  if(experience&gt;1)
+    experienceFull();
+}
+
+bool AntEntity::defeated() const
+{
+  return mDefeated;
+}

Added: antargis/branches/rant/ext/game/entity.h
===================================================================
--- antargis/branches/rant/ext/game/entity.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/entity.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,285 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * entity.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef ANT_ENTITY_H
+#define ANT_ENTITY_H
+
+#include &quot;scene.h&quot;
+#include &lt;ag_xml.h&gt;
+#include &lt;ag_geometry.h&gt;
+#include &lt;ag_color.h&gt;
+#include &lt;ag_string.h&gt;
+
+
+#include &lt;set&gt;
+#include &lt;vector&gt;
+
+class Mesh;
+class SceneNode;
+class Job;
+
+#include &quot;resource.h&quot;
+
+class AntEntity:public AGRubyObject
+  {
+  public:
+    typedef std::list&lt;SceneNode*&gt; Meshes;
+  private:
+    int mID;
+    AGString mName;
+
+    AGVector3 mPos;   // 3d-position
+    bool onGround;    // is this on the ground of the map?
+    bool onWater;
+
+    Job *mJob;        // current job
+
+    std::list&lt;Job*&gt; mJobFinished;  // finished jobs, in cue, so that they get deleted next time possible
+
+    std::set&lt;AGString&gt; mProvides;
+
+    // energy and healing
+    float mEnergy;
+    float mHealSpeed;
+
+    // morale and moralehealing
+    float mMorale;
+    float mMoraleHeal;
+
+    bool mMoraleFlag;
+
+    /// current food in stomach
+    float mFood;
+    /// food needed per second
+    float mHunger; 
+    /// hunger impact on energy
+    float mHungerHitEnergy;
+    /// hunger impact on morale
+    float mHungerHitMorale;
+
+    // moving
+    float mMoveSpeed;
+
+    float mAggression;
+
+    AGString mType;
+
+    Meshes mMeshes;
+    std::map&lt;SceneNode*,AGVector3&gt; mMeshPos;
+
+    int mVirtualY;
+
+    AGColor mMinimapColor;
+    bool mShowOnMinimap;
+    float mMinimapSize;
+
+    float mStrength;
+    float mMoraleStrength;
+    
+    float mDefense;
+
+    bool mDefeated;
+  public:
+    float experience;
+    float learnAmount;
+
+
+  public: //virtually protected
+    float mDir;  // direction in (0,360)
+    Resource resource;
+
+  public:
+    AntEntity();
+    AntEntity(const AGVector3 &amp;p);
+    AntEntity(const AGVector2 &amp;p);
+    virtual ~AntEntity();
+
+    bool defeated() const;
+
+    void setMinimapColor(const AGColor &amp;c);
+    void setMinimapSize(float f);
+    AGColor getMinimapColor() const;
+    bool showOnMinimap() const;
+    float getMinimapSize() const;
+
+    void setStrength(float f);
+    float getStrength() const;
+    void setMoraleStrength(float f);
+    float getMoraleStrength() const;
+    void setDefense(float f);
+    float getDefense() const;
+
+    void setMoraleFlag(bool f);
+
+
+    // Positions
+    AGVector3 getPos3D() const;
+    AGVector2 getPos2D() const;
+    virtual void setPos(const AGVector2 &amp;p); // overwrite this only on static Entities, otherwise this gets called really (!) often
+    void setPos(const AGVector3 &amp;p);
+
+    // IDs, names and types
+    int getID() const;
+
+    AGString getName() const;
+    void setName(const AGString &amp;pName);
+
+    //    AGString getType() const;
+    //    void setType(const AGString &amp;pType);
+
+    void setProvide(const AGString &amp;pName,bool flag);
+    bool provides(const AGString &amp;pName) const;
+
+    // saving and loading
+    virtual AGString xmlName() const;
+
+    virtual void saveXML(Node &amp;node) const;
+    virtual void loadXML(const Node &amp;node);
+
+    // jobs
+
+  private:
+    void setJob(Job *pJob); // only for internal use and reseting
+
+  public:
+    virtual void newRestJob(float pTime);
+    virtual void newFetchJob(int p,AGVector2 &amp;pTarget,const AGString &amp;pWhat);
+    virtual void newFetchJob(int p,AntEntity *pTarget,const AGString &amp;pWhat);
+    virtual void newMoveJob(int p,const AGVector2 &amp;pTarget,float pnear=0.0);
+    virtual void newMoveJob(int p,const AGVector3 &amp;pTarget,float pnear=0.0);
+    virtual void newMoveJob(int p,AntEntity *target,float pnear=0.0);
+    virtual void newFightJob(int p,AntEntity *target,float distance);
+    virtual void delJob();
+
+    bool isMoving() const;
+
+    virtual void resourceChanged();
+
+    bool hasJob() const;
+
+    AGRect2 getRect() const;
+
+    virtual void eventNoJob();
+    virtual void eventJobFinished();
+    virtual void eventGotNewJob();
+    virtual void eventGotFight(AntEntity*pOther);
+
+    // set/get speeds
+    void setSpeed(float f);
+    float getSpeed() const;
+
+    float getHealSpeed() const;
+    void setHealSpeed(float f);
+
+    void setMoraleHealSpeed(float f);
+
+    void setHunger(float f);
+
+    // aggression - handling
+
+    void setAggression(float agg);
+    float getAggression() const;
+    
+    virtual void eventDie(); // energy too low
+    virtual void eventDefeated(); // morale too low
+    virtual void eventHaveDefeated(AntEntity *e);
+    virtual void eventMoraleLow();
+
+    // called by FightJob
+    virtual void eventStartFighting();
+    virtual void eventStartMoving();
+
+    // should return if it's ok to proceed
+    virtual bool eventHitWaterMark(bool fromAbove);
+
+    void sigDefeated(); // morale too low
+    void sigJobFinished();
+
+    float getEnergy() const;
+    float getMorale() const;
+
+    bool canFight() const;
+    bool isFighting() const;
+
+    // appearance
+
+    // FIXME: this shouldn't be virtual, because it gets called too often!
+    //    virtual AGString getTexture() const;
+
+    // anything below shouldn't be used by ruby-functions
+
+    void setMesh(SceneNode *pMesh);
+    Meshes getMesh();
+    SceneNode *getFirstMesh();
+    void addMesh(SceneNode *pMesh,const AGVector3 &amp;v);
+
+    // used only by *Jobs
+    void setDirection(float pAngle);
+    float getDirection() const;
+
+    void decEnergy(float amount);
+    void decMorale(float amount);
+    void incMorale(float pTime);
+
+    void incExperience(float amount);
+
+
+    virtual void experienceFull();
+
+    float getFood() const;
+    void incFood(float v);
+    bool isStarving() const;
+
+    bool isOnWater() const;
+    bool isOnGround() const;
+
+    void setOnWater(bool p);
+    void setOnGround(bool p);
+
+    // used only by Map - so that Position gets updated, when onGround
+    void eventMapChanged();
+    virtual void move(float pTime); // move entity FIXME: del move
+
+    void mark();
+
+    void clear();
+    void clearMeshes();
+
+    void setVisible(bool v);
+
+    virtual void animationEvent(const AGString &amp;pName);
+
+    void heal(float pTime);
+
+    AntEntity *getFightTarget();
+
+  private:
+    void init();
+    void updatePos(const AGVector3 &amp;p);
+
+    void starve(float pTime);
+
+    void loadJob(const Node &amp;pNode);
+  };
+
+
+#endif

Added: antargis/branches/rant/ext/game/entptr.cc
===================================================================
--- antargis/branches/rant/ext/game/entptr.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/entptr.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,18 @@
+#include &quot;entptr.h&quot;
+// AntEntityPtr
+AntEntityPtr::AntEntityPtr():p(0)
+{
+}
+
+AntEntityPtr::AntEntityPtr(const AntEntityPtr &amp;pp):p(pp.p)
+{
+}
+AntEntityPtr::AntEntityPtr(AntEntity *pp):p(pp)
+{
+}
+
+AntEntity *AntEntityPtr::get()
+{
+  assert(p);
+  return p;
+}

Added: antargis/branches/rant/ext/game/entptr.h
===================================================================
--- antargis/branches/rant/ext/game/entptr.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/entptr.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,20 @@
+#ifndef ENTPTR_H
+#define ENTPTR_H
+
+#include &quot;entity.h&quot;
+
+class AntEntityPtr
+{
+ public:
+  AntEntityPtr(const AntEntityPtr &amp;p);
+  AntEntityPtr(AntEntity *p);
+  AntEntityPtr();
+
+  AntEntity *get();
+
+ private:
+  AntEntity *p;
+};
+
+
+#endif

Modified: antargis/branches/rant/ext/game/headers.hh
===================================================================
--- antargis/branches/rant/ext/game/headers.hh	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/headers.hh	2007-06-23 15:07:27 UTC (rev 1105)
@@ -104,15 +104,17 @@
 #include &quot;ext/3dengine/ant_projection.h&quot;
 #include &quot;ext/3dengine/ag_glsl.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/game/terrain.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/game/entity.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/game/height_map.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/game/ant_app.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/game/minimap.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/game/map.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/game/entity.h&quot;
 #ifdef SWIG
 %include &quot;/home/david/projects/antargis/rant/ext/game/terrain.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/game/entity.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/game/height_map.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/game/ant_app.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/game/minimap.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/game/map.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/game/entity.h&quot;
 #endif
 #endif

Added: antargis/branches/rant/ext/game/height_map.cc
===================================================================
--- antargis/branches/rant/ext/game/height_map.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/height_map.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,633 @@
+#include &quot;height_map.h&quot;
+#include &quot;terrain.h&quot;
+#include &lt;ag_serial.h&gt;
+#include &lt;ag_main.h&gt;
+#include &lt;ag_rand.h&gt;
+
+//////////////////////////////////////////////////////////////////////////
+// HeightMap
+//////////////////////////////////////////////////////////////////////////
+
+char TerrainNames[][20]={&quot;water&quot;,&quot;sand&quot;,&quot;earth&quot;,&quot;grass&quot;,&quot;grass2&quot;,&quot;forest&quot;,&quot;rock&quot;,&quot;rock2&quot;};
+
+std::vector&lt;float&gt; genSomeHeights(int mW,int mH,float mMaxHeight);
+
+HeightMap::HeightMap(SceneBase *pScene,int w,int h):
+  sigMapChanged(this,&quot;mapChanged&quot;),
+  sigMapChangedComplete(this,&quot;mapChangedComplete&quot;),
+  mTerrainTypes(LASTTERRAIN+1),
+  mW(w),mH(h),mChangeRect(AGVector2(),AGVector2()),mChanges(0),
+  mScene(pScene)
+  
+{
+  mHeights=genSomeHeights(w+2,h+2,5);
+
+  for(int t=FIRSTTERRAIN;t&lt;LASTTERRAIN; t++)
+    mTerrainTypes[TerrainType(t)]=genSomeHeights(w+2,h+2,1);
+
+  mTerrain=0;
+  //  initTerrainMesh();
+
+
+  setTerrainScale(WATER,0);
+  setTerrainScale(SAND,8/32.0);
+  setTerrainScale(EARTH,12/32.0);
+  setTerrainScale(GRASS,16/32.0);
+  setTerrainScale(GRASS2,20/32.0);
+  setTerrainScale(FOREST,23/32.0);
+  setTerrainScale(ROCK,31/32.0);
+  setTerrainScale(ROCK2,31/32.0);
+}
+
+HeightMap::~HeightMap()
+{
+  saveDelete(mTerrain);
+}
+
+void HeightMap::initTerrainMesh()
+{
+  if(videoInited())
+    mTerrain=new Terrain(mScene,*this);
+}
+
+void HeightMap::setTerrain(TerrainBase *pTerrain)
+{
+  assert(pTerrain);
+  assert(!mTerrain);
+  mTerrain=pTerrain;
+}
+
+
+void HeightMap::setHeight(float height)
+{
+  for(size_t y=0;y&lt;mH+2;y++)
+    for(size_t x=0;x&lt;mW+2;x++)
+      {
+	set(x,y,height);
+	setTerrain(x,y,EARTH,1);
+      }
+
+  mapChanged();
+}
+
+void HeightMap::addChange(const AGVector2 &amp;v)
+{
+  mChanges++;
+  if(mChanges==1)
+    {
+      mChangeRect=AGRect2(v,v);
+    }
+  else
+    mChangeRect.include(v);
+}
+
+AGRect2 HeightMap::getChangeRect() const
+{
+  return mChangeRect;
+}
+
+
+void HeightMap::setTerrain(size_t x,size_t y,TerrainType t,float v)
+{
+  size_t p=x+y*(mW+2);
+
+  //  cdebug(p&lt;&lt;&quot;  &quot;&lt;&lt;EARTH&lt;&lt;&quot; &quot;&lt;&lt;mTerrainTypes[EARTH].size());
+  assert(mTerrainTypes[EARTH].size()&gt;p);
+  mTerrainTypes[t][p]=v;
+  
+  float sum=0;
+  for(int i=FIRSTTERRAIN;i&lt;LASTTERRAIN;i++)
+    {
+      assert(mTerrainTypes[TerrainType(i)].size()&gt;p);
+      if(t!=i)
+	sum+=mTerrainTypes[TerrainType(i)][p];
+    }
+
+  for(int i=FIRSTTERRAIN;i&lt;LASTTERRAIN;i++)
+    if(t!=i)
+      {
+	if(sum==0 || v==1)
+	  mTerrainTypes[TerrainType(i)][p]=0;
+	else
+	  mTerrainTypes[TerrainType(i)][p]=mTerrainTypes[TerrainType(i)][p]/sum*(1-v); // so sum(mTerraintypes[x][.]) == 1
+      }
+  addChange(AGVector2(x,y));
+}
+
+float HeightMap::getTerrain(size_t x,size_t y,TerrainType t) const
+{
+  size_t p=x+y*(mW+2);
+  return const_cast&lt;HeightMap*&gt;(this)-&gt;mTerrainTypes[t][p];
+}
+
+
+
+
+void HeightMap::set(size_t x,size_t y,float height)
+{
+  assert(x&gt;=0);
+  assert(y&gt;=0);
+  assert(x&lt;mW+2);
+  assert(y&lt;mH+2);
+  mHeights[x+y*(mW+2)]=height;
+  addChange(AGVector2(x,y));
+}
+
+void HeightMap::loadBinary(BinaryIn &amp;is)
+{
+  CTRACE;
+  //  cdebug(&quot;file:&quot;&lt;&lt;pName);
+  //  BinaryFileIn is(pName);
+  float f;
+
+  Uint32 tw,th; // temporary sizes for AMD64
+  is&gt;&gt;tw&gt;&gt;th;
+  mW=tw;
+  mH=th;
+
+  cdebug(&quot;mw:&quot;&lt;&lt;mW&lt;&lt;&quot;  &quot;&lt;&lt;mH);
+  //  cdebug(&quot;pos:&quot;&lt;&lt;is.pos());
+
+  assert(mW&lt;10000 &amp;&amp; mH&lt;10000);
+  
+  
+  mHeights=std::vector&lt;float&gt;(mW*mH*4);
+  for(size_t y=0;y&lt;mH+2;y++)
+    {
+      for(size_t x=0;x&lt;mW+2;x++)
+	{
+	  is&gt;&gt;f;
+	  //	  cdebug(f);
+	  mHeights[x+y*(mW+2)]=f;
+	}
+    }
+
+  for(int i=FIRSTTERRAIN;i&lt;LASTTERRAIN;i++)
+    {
+      mTerrainTypes[TerrainType(i)]=std::vector&lt;float&gt;(mW*mH*4);
+      
+      for(size_t y=0;y&lt;mH+2;y++)
+	{
+	  for(size_t x=0;x&lt;mW+2;x++)
+	    {
+	      is&gt;&gt;f;
+	      mTerrainTypes[TerrainType(i)][x+y*(mW+2)]=f;
+	      addChange(AGVector2(x,y));
+	    }
+	}
+    }
+}
+
+void HeightMap::saveBinary(BinaryOut &amp;os) const
+{
+  CTRACE;
+  //  BinaryFileOut os(pName);
+
+  os&lt;&lt;(Uint32)mW&lt;&lt;(Uint32)mH;
+  //  cdebug(&quot;pos:&quot;&lt;&lt;os.pos());
+
+  for(size_t y=0;y&lt;mH+2;y++)
+    {
+      for(size_t x=0;x&lt;mW+2;x++)
+	{
+	  os&lt;&lt;mHeights[x+y*(mW+2)];
+	}
+    }
+  
+  
+  for(int i=FIRSTTERRAIN;i&lt;LASTTERRAIN;i++)
+    {
+      for(size_t y=0;y&lt;mH+2;y++)
+	{
+	  for(size_t x=0;x&lt;mW+2;x++)
+	    {
+	      os&lt;&lt;const_cast&lt;HeightMap*&gt;(this)-&gt;mTerrainTypes[TerrainType(i)][x+y*(mW+2)]; // trust me - I'm const
+	    }
+	}
+    }
+}
+
+void HeightMap::loadXML(const Node &amp;node)
+{
+  CTRACE;
+  AGFilename filename=node.get(&quot;filename&quot;);
+  if(filename.length())
+    {
+      BinaryFileIn is(filename);
+      loadBinary(is);
+    }
+  else
+    {
+      Node::NodeVector nv=node.getChildren(&quot;data&quot;);
+      if(nv.size())
+	{
+	  AGString c=nv[0]-&gt;getContent();
+	  BinaryStringIn is(hexToBinary(c));
+	  loadBinary(is);
+	}
+      else
+	{
+	  mW=node.get(&quot;width&quot;).toInt();
+	  mH=node.get(&quot;height&quot;).toInt();
+	  
+	  cdebug(&quot;mW:&quot;&lt;&lt;mW);
+	  cdebug(&quot;mH:&quot;&lt;&lt;mH);
+	  mHeights=std::vector&lt;float&gt;(mW*mH*4);
+	  
+	  for(int i=FIRSTTERRAIN;i&lt;LASTTERRAIN;i++)
+	    {
+	      mTerrainTypes[TerrainType(i)]=std::vector&lt;float&gt;(mW*mH*4);
+	      cdebug(mW&lt;&lt;&quot;   &quot;&lt;&lt;mH);
+	      cdebug(mTerrainTypes[TerrainType(i)].size());
+	      Node::NodeVector gv=node.getChildren(TerrainNames[i]);
+	      if(gv.size()==0)
+		continue;
+	      Node &amp;g=**gv.begin();
+	      
+	      std::istringstream is(g.getContent());
+	      
+	      float f;
+	      for(size_t y=0;y&lt;mH+2;y++)
+		{
+		  for(size_t x=0;x&lt;mW+2;x++)
+		    {
+		      is&gt;&gt;f;
+		      mTerrainTypes[TerrainType(i)][x+y*(mW+2)]=f;
+		      addChange(AGVector2(x,y));
+		    }
+		}
+	    }
+	  
+	  
+	  Node::NodeVector hv=node.getChildren(&quot;height&quot;);
+	  
+	  if(hv.size()==0)// || gv.size()==0)
+	    return;
+	  assert(hv.size()==1);
+	  Node &amp;h=**hv.begin();
+	  
+	  
+	  std::istringstream ish(h.getContent());
+	  
+	  float f;
+	  for(size_t y=0;y&lt;mH+2;y++)
+	    {
+	      for(size_t x=0;x&lt;mW+2;x++)
+		{
+		  ish&gt;&gt;f;
+		  mHeights[x+y*(mW+2)]=f;
+		}
+	    }
+	}
+    }
+  
+  checkTerrain();
+  
+  // compete change
+  if(mTerrain)
+    mTerrain-&gt;mapChangedComplete();
+  //  mTerrain-&gt;addToScenes();
+  mChanges=0;
+  mChangeRect=AGRect2(AGVector2(),AGVector2());
+
+
+  sigMapChangedComplete(new AGEvent(this,&quot;mapChangedComplete&quot;));
+}
+
+void HeightMap::newMap(int w,int h)
+{
+  mW=w;
+  mH=h;
+
+  mHeights=genSomeHeights(w+2,h+2,5);
+
+  for(int t=FIRSTTERRAIN;t&lt;LASTTERRAIN; t++)
+    mTerrainTypes[TerrainType(t)]=genSomeHeights(w+2,h+2,1);
+  
+  checkTerrain();
+
+  // compete change
+  if(mTerrain)
+    mTerrain-&gt;mapChangedComplete();
+  //  mTerrain-&gt;addToScenes();
+  mChanges=0;
+  mChangeRect=AGRect2(AGVector2(),AGVector2());
+
+}
+
+
+void HeightMap::mapChanged()
+{
+  {
+    CTRACE;
+    sigMapChanged(new AGEvent(this,&quot;mapChanged&quot;));
+  }
+  {
+    CTRACE;
+    //    mTerrain-&gt;addToScenes();
+    //    mTerrain-&gt;mapChanged();
+    mChanges=0;
+    mChangeRect=AGRect2(AGVector2(),AGVector2());
+  }
+}
+
+
+void HeightMap::saveXML(Node &amp;node) const
+{
+  node.set(&quot;width&quot;,AGString(mW));
+  node.set(&quot;height&quot;,AGString(mH));
+  
+  if(false) //(mW&lt;=64 &amp;&amp; mH&lt;=64) || mName.length()==0)
+    {
+      AGStringStream osh;
+      osh.precision(2);
+      
+      for(size_t y=0;y&lt;mH+2;y++)
+	{
+	  for(size_t x=0;x&lt;mW+2;x++)
+	    {
+	      osh&lt;&lt;get(x,y)&lt;&lt;&quot; &quot;;
+	    }
+	  osh&lt;&lt;&quot;\n&quot;;
+	}
+      node.addChild(&quot;height&quot;).setContent(osh.str());
+      
+      for(int i=FIRSTTERRAIN;i&lt;LASTTERRAIN;i++)
+	{
+	  std::ostringstream os;
+	  os.precision(2);
+	  for(size_t y=0;y&lt;mH+2;y++)
+	    {
+	      for(size_t x=0;x&lt;mW+2;x++)
+		{
+		  os&lt;&lt;getTerrain(x,y,TerrainType(i))&lt;&lt;&quot; &quot;;
+		}
+	      os&lt;&lt;std::endl;
+	    }
+	  node.addChild(TerrainNames[i]).setContent(AGString(os.str()));
+	  
+	}
+    }
+  else if(false)
+    {
+      std::string name=mName.replace(&quot;.antlvl&quot;,&quot;.hmap&quot;);
+      BinaryFileOut os(name);
+      saveBinary(os);
+      node.set(&quot;filename&quot;,AGString(name));
+    }
+  else
+    {
+      BinaryStringOut os;
+      saveBinary(os);
+      Node &amp;n=node.addChild(&quot;data&quot;);
+      n.setContent(AGString(binaryToHex(os.getString())));
+    }
+}
+
+
+std::vector&lt;float&gt; genSomeHeights(int mW,int mH,float mMaxHeight)
+{
+  std::vector&lt;float&gt; h(mW*mH);
+
+  for(int i=0;i&lt;mW*mH;i++)
+    h[i]=0;
+  return h;
+  
+  for(int i=0;i&lt;mW*mH;i++)
+    h[i]=agRand(mMaxHeight);
+  
+  int x,y;
+  // blur
+  
+  for(int j=0;j&lt;2;j++) // once
+    for(x=0;x&lt;mW-1;x++)
+      for(y=0;y&lt;mH-1;y++)
+	h[x+y*mW]=(h[x+y*mW]+h[x+y*mW+1]+h[x+(y+1)*mW]+h[x+1+(y+1)*mW])/4;
+  
+  
+  return h;
+}
+
+float HeightMap::get(size_t x,size_t y) const
+{
+  assert(x&gt;=0);
+  assert(y&gt;=0);
+  if(x&gt;=mW+2)
+    cdebug(&quot;x:&quot;&lt;&lt;x&lt;&lt;&quot;  mW:&quot;&lt;&lt;mW);
+  assert(x&lt;mW+2);
+  if(y&gt;=mH+2)
+    cdebug(&quot;y:&quot;&lt;&lt;y);
+  assert(y&lt;mH+2);
+  return mHeights[x+y*(mW+2)];
+}
+
+AGVector4 HeightMap::getVertex(int x,int y)
+{
+  return AGVector4(x,y,getHeight(x,y),1);
+}
+
+float HeightMap::getHeight(float x,float y) const
+{
+  int mx=(int)(x);
+  int my=(int)(y);
+
+  float dx=x-mx;
+  float dy=y-my;
+
+  float a0=get(mx,my);
+  float a1=get(mx+1,my);
+  float a2=get(mx,my+1);
+  float a3=get(mx+1,my+1);
+
+  float h=(a0*(1-dx)+a1*dx)*(1-dy)+(a2*(1-dx)+a3*dx)*dy;
+  return h;
+
+}
+
+AGVector3 HeightMap::getNormalF(float x,float y) const
+{
+  AGVector4 v1,v2;
+  if(x&gt;2)
+    v1=AGVector4(1,0,getHeight(x,y)-getHeight(x-1,y),0);
+  else
+    v1=AGVector4(1,0,getHeight(x+1,y)-getHeight(x,y),0);
+
+  if(y&gt;2)
+    v2=AGVector4(0,1,getHeight(x,y)-getHeight(x,y-1),0);
+  else
+    v2=AGVector4(0,1,getHeight(x,y+1)-getHeight(x,y),0);
+  
+  AGVector4 v3=v1%v2;
+  v3.normalize3();
+
+  return AGVector3(v3[0],v3[1],v3[2]);
+}
+
+
+AGVector3 HeightMap::getNormal(int x,int y) const
+{
+  AGVector4 v1=AGVector4(1,0,get(x+1,y)-get(x,y),0);
+  AGVector4 v2=AGVector4(0,1,get(x,y+1)-get(x,y),0);
+  
+  AGVector4 v3=v1%v2;
+  v3.normalize3();
+  //  v3*=-1;
+  return AGVector3(v3[0],v3[1],v3[2]);
+}
+
+AGVector2 HeightMap::truncPos(const AGVector2 &amp;p) const
+{
+  AGVector2 maxPos(mW+0.5,mH+0.5);
+  return AGVector2(std::max(0.0f,std::min(maxPos[0],p[0])),
+		   std::max(0.0f,std::min(maxPos[1],p[1])));
+}
+
+AGVector3 HeightMap::truncPos(const AGVector3 &amp;p) const
+{
+  AGVector2 maxPos(mW+0.5,mH+0.5);
+  return AGVector3(std::max(0.0f,std::min(maxPos[0],p[0])),
+		   std::max(0.0f,std::min(maxPos[1],p[1])),
+		   p[2]);
+}
+
+void HeightMap::setTerrainScale(TerrainType t,float s)
+{
+  mTerrainScale[t]=s;
+}
+
+float HeightMap::getTerrainValue(float x,float y,TerrainType t)
+{
+  int mx=(int)(x);
+  int my=(int)(y);
+
+  float dx=x-mx;
+  float dy=y-my;
+
+  float a0=getTerrain(mx,my,t);
+  float a1=getTerrain(mx+1,my,t);
+  float a2=getTerrain(mx,my+1,t);
+  float a3=getTerrain(mx+1,my+1,t);
+
+  float h=(a0*(1-dx)+a1*dx)*(1-dy)+(a2*(1-dx)+a3*dx)*dy;
+  return h;
+}
+
+TerrainType HeightMap::getTerrain(float x,float y)
+{
+  TerrainType t=FIRSTTERRAIN;
+  float mmax=0.0f;
+  for(int i=FIRSTTERRAIN;i&lt;LASTTERRAIN;i++)
+    {
+      float v=getTerrainValue(x,y,TerrainType(i));
+      if(v&gt;mmax)
+	{
+	  t=TerrainType(i);
+	  mmax=v;
+	}
+    }
+  return t;
+}
+
+// mean value
+float HeightMap::getTerrainWeight(float x,float y)
+{
+  float mean=0;
+  for(int i=FIRSTTERRAIN;i&lt;LASTTERRAIN;i++)
+    {
+      float v=getTerrainValue(x,y,TerrainType(i));
+      mean+=v*i;
+    }
+  return mean/(LASTTERRAIN-FIRSTTERRAIN);
+}
+
+float HeightMap::getMean(float x,float y)
+{
+  float mean=0;
+  for(int i=FIRSTTERRAIN;i&lt;LASTTERRAIN;i++)
+    {
+      float v=getTerrainValue(x,y,TerrainType(i));
+      mean+=v*mTerrainScale[TerrainType(i)];
+    }
+  return mean;
+
+}
+
+
+float HeightMap::getTerrainScale(float x,float y)
+{
+  TerrainType t=getTerrain(x,y),t2;
+
+  float mean=getTerrainWeight(x,y);
+
+  if(mean&lt;t)
+    {
+      t2=TerrainType(t-1);
+    }
+  else
+    t2=TerrainType(t+1);
+
+  float s1=mTerrainScale[t];
+  float s2=mTerrainScale[t2];
+
+  mean=fabs(std::max(std::min(mean,1.0f),-1.0f));
+
+  //  cdebug(mean);
+  float w=0;
+  return getMean(x,y)*(1-w)+s1*w;
+
+  return s1*(1-mean)+s2*mean;
+}
+
+SceneBase *HeightMap::getScene()
+{
+  return mScene;
+}
+
+AGVector2 HeightMap::getNextPlaceAbove(const AGVector2 &amp;p,float height) const
+{
+  int x=(int)p[0];
+  int y=(int)p[1];
+  int d;
+  float maxh=height;
+  AGVector2 found(x,y);
+
+  for(d=0;d&lt;5;d++)
+    {
+      for(int i=-d;i&lt;=d;i++)
+	{
+	  std::vector&lt;AGVector2&gt; p;
+	  p.push_back(AGVector2(i,y-d));
+	  p.push_back(AGVector2(i,y+d));
+	  p.push_back(AGVector2(x-d,i));
+	  p.push_back(AGVector2(x+d,i));
+	  for(std::vector&lt;AGVector2&gt;::iterator k=p.begin();k!=p.end();++k)
+	    {
+	      if((*k)[0]&lt;0 || (*k)[0]&gt;mW || (*k)[1]&lt;0 || (*k)[1]&gt;mH)
+		continue;
+	      cdebug((*k)[0]&lt;&lt;&quot;  &quot;&lt;&lt;(*k)[1]&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;d);
+	      float h=getHeight((*k)[0],(*k)[1]);
+	      if(h&gt;maxh)
+		{
+		  maxh=h;
+		  found=*k;
+		}
+	    }
+	}
+
+      if(maxh&gt;height)
+	break;
+    }
+  return found;
+}
+
+void HeightMap::mark()
+{
+  if(mTerrain)
+    markObject(mTerrain);
+}
+
+void HeightMap::checkTerrain()
+{
+  if(!mTerrain)
+    initTerrainMesh();
+}

Added: antargis/branches/rant/ext/game/height_map.h
===================================================================
--- antargis/branches/rant/ext/game/height_map.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/height_map.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,124 @@
+#ifndef HEIGHT_MAP_H
+#define HEIGHT_MAP_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &quot;scene.h&quot;
+#include &lt;ag_geometry.h&gt;
+#include &lt;ag_xml.h&gt;
+#include &quot;entptr.h&quot;
+#include &lt;ag_messageobject.h&gt;
+#include &lt;ag_serial.h&gt;
+
+class AntEntity;
+class AntEntityPtr;
+class Scene;
+class Mesh;
+class TerrainBase;
+
+enum TerrainType { WATER=0, SAND, EARTH, GRASS, GRASS2, FOREST, ROCK, ROCK2, LASTTERRAIN};
+
+#define FIRSTTERRAIN WATER
+
+class HeightMap:public AGMessageObject
+{
+ public:
+  HeightMap(SceneBase *pScene,int w,int h);
+  virtual ~HeightMap();
+
+  // get status
+
+  AGVector2 getNextPlaceAbove(const AGVector2 &amp;p,float height) const;
+
+  float getHeight(float x,float y) const;
+  AGVector3 getNormal(int x,int y) const;
+  AGVector3 getNormalF(float x,float y) const;
+  AGVector4 getVertex(int x,int y);
+  float get(size_t x,size_t y) const;
+  //float getGrass(size_t x,size_t y) const;
+
+  void setTerrain(size_t x,size_t y,TerrainType t,float v);
+  float getTerrain(size_t x,size_t y,TerrainType t) const;
+
+  float getMean(float x,float y);
+  size_t getW() const
+  {
+    return mW;
+  }
+  size_t getH() const
+  {
+    return mH;
+  }
+
+  // truncate pos at borders
+  AGVector2 truncPos(const AGVector2 &amp;p) const;
+  AGVector3 truncPos(const AGVector3 &amp;p) const;
+
+  // save load
+  virtual void saveXML(Node &amp;node) const;
+  virtual void loadXML(const Node &amp;node);
+
+  // editing
+  void setHeight(float height); // for whole plane
+  void set(size_t x,size_t y,float height);
+
+  virtual void mapChanged();  
+
+
+  void setTerrainScale(TerrainType t,float s);
+  float getTerrainValue(float x,float y,TerrainType t);
+  TerrainType getTerrain(float x,float y);
+  float getTerrainWeight(float x,float y);
+  float getTerrainScale(float x,float y);
+
+
+  void addChange(const AGVector2 &amp;v);
+
+  AGRect2 getChangeRect() const;
+
+  virtual void newMap(int w,int h);
+
+  AGSignal sigMapChanged;
+  AGSignal sigMapChangedComplete;
+
+  SceneBase *getScene();
+
+  /// override this function to include another terrain-mesh-type (like 2d-terrain)
+  virtual void initTerrainMesh();
+
+  void mark();
+
+  /// to be used by initTerrainMesh() - not otherwise !!!
+  void setTerrain(TerrainBase *pTerrain);
+
+ private:
+
+  void checkTerrain();
+
+  void loadBinary(BinaryIn &amp;s);
+  void saveBinary(BinaryOut &amp;s) const;
+
+
+  std::vector&lt;float&gt; mHeights;
+
+
+  std::map&lt;TerrainType,float&gt; mTerrainScale;
+
+  // sum of all should be one - or at least they get normalized to 1 and then the heighest is chosen and weighted with the mean value
+  //std::map&lt;TerrainType,std::vector&lt;float&gt; &gt; mTerrainTypes;
+  std::vector&lt;std::vector&lt;float&gt; &gt; mTerrainTypes;
+
+  size_t mW,mH;
+
+  AGRect2 mChangeRect;
+  size_t mChanges;
+
+  SceneBase *mScene;
+
+ protected:
+
+  TerrainBase *mTerrain;
+  AGString mName;
+};
+
+#endif

Added: antargis/branches/rant/ext/game/heuristic.cc
===================================================================
--- antargis/branches/rant/ext/game/heuristic.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/heuristic.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,78 @@
+#include &quot;heuristic.h&quot;
+#include &lt;ag_debug.h&gt;
+
+
+HeuristicFunction::Output HeuristicFunction::operator()(const Input &amp;input) 
+{
+  return (input.second-input.first).length()*1.5;
+}
+
+
+StoredHeuristicFunction::StoredHeuristicFunction(size_t res,float width):
+  a(res*res*res*res),
+  r(res),
+  w(width)
+{
+}
+
+void StoredHeuristicFunction::store(Input in,Output out)
+{
+  size_t i=getIndex(in);
+  //  cdebug(&quot;index:&quot;&lt;&lt;i);
+  //  cdebug(&quot;value:&quot;&lt;&lt;out);
+  a[i]=out;
+}
+
+StoredHeuristicFunction::Output StoredHeuristicFunction::operator()(const Input &amp;input)
+{
+  size_t i=getIndex(input);
+  //  cdebug(&quot;index:&quot;&lt;&lt;i);
+  float v=a[i];
+  //  cdebug(&quot;value:&quot;&lt;&lt;v);
+
+  return v*6;
+}
+
+size_t StoredHeuristicFunction::getIndex(const Input &amp;in)
+{
+  size_t a,b,c,d;
+
+  //  cdebug(in.first&lt;&lt;&quot;:::&quot;&lt;&lt;in.second);
+
+  a=in.first[0]*r/w;
+  b=in.first[1]*r/w;
+  c=in.second[0]*r/w;
+  d=in.second[1]*r/w;
+
+  a=std::min(a,r-1);
+  b=std::min(b,r-1);
+  c=std::min(c,r-1);
+  d=std::min(d,r-1);
+
+  assert(a&lt;r);
+  assert(b&lt;r);
+  assert(c&lt;r);
+  assert(d&lt;r);
+
+  size_t i=((a*r+b)*r+c)*r+d;
+
+  //  cdebug(i);
+  return i;
+}
+
+
+void StoredHeuristicFunction::display()
+{
+  for(int a=0;a&lt;r;a++)
+    for(int b=0;b&lt;r;b++)
+      for(int c=0;c&lt;r;c++)
+	for(int d=0;d&lt;r;d++)
+	  {
+	    AGVector2 p0(a*w/r,b*w/r);
+	    AGVector2 p1(c*w/r,d*w/r);
+
+	    float value=operator()(std::make_pair(p0,p1));
+	    if(value&gt;0)
+	      std::cout&lt;&lt;a&lt;&lt;&quot;,&quot;&lt;&lt;b&lt;&lt;&quot;,&quot;&lt;&lt;c&lt;&lt;&quot;,&quot;&lt;&lt;d&lt;&lt;&quot;:&quot;&lt;&lt;value&lt;&lt;std::endl;
+	  }
+}

Added: antargis/branches/rant/ext/game/heuristic.h
===================================================================
--- antargis/branches/rant/ext/game/heuristic.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/heuristic.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,40 @@
+#ifndef HEURISTIC_H
+#define HEURISTIC_H
+
+#include &lt;ag_geometry.h&gt;
+
+class HeuristicFunction
+{
+ public:
+  typedef std::pair&lt;AGVector2,AGVector2&gt; Input;
+  typedef float Output;
+
+  virtual ~HeuristicFunction()
+    {
+    }
+
+  virtual Output operator()(const Input &amp;input);
+};
+
+class StoredHeuristicFunction:public HeuristicFunction
+{
+  // FIXME: maybe store measure-count, too - and average!!!
+
+  std::vector&lt;float&gt; a;
+  size_t r;
+  float w;
+ public:
+  StoredHeuristicFunction(size_t res,float width);
+
+  void store(Input in,Output out);
+
+  void display();
+
+  virtual Output operator()(const Input &amp;input);
+ private:
+  size_t getIndex(const Input &amp;in);
+};
+
+
+#endif
+

Added: antargis/branches/rant/ext/game/jobs.cc
===================================================================
--- antargis/branches/rant/ext/game/jobs.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/jobs.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,486 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * jobs.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;jobs.h&quot;
+#include &quot;entity.h&quot;
+#include &quot;map.h&quot;
+#include &lt;math.h&gt;
+
+
+#define WATER_MARK -0.2
+
+Job::Job():priority(0),inited(false)
+{
+}
+
+Job::Job(int p):priority(p),inited(true)
+{}
+
+bool Job::valid() const
+{
+  return inited;
+}
+
+void Job::move(AntEntity *,float ptime)
+{}
+
+bool Job::operator&lt;=(const Job &amp;j) const
+{
+  return priority&lt;=j.priority;
+}
+
+Job::~Job()
+{
+}
+
+void Job::jobFinished(AntEntity *e)
+{
+  e-&gt;sigJobFinished();
+}
+
+bool Job::needsMorale() const
+{
+  return false;
+}
+
+void Job::saveXML(Node &amp;pNode) const
+{
+  pNode.set(&quot;priority&quot;,AGString(priority));
+}
+void Job::loadXML(const Node &amp;pNode)
+{
+  if(pNode.get(&quot;priority&quot;).length())
+    priority=pNode.get(&quot;priority&quot;).toInt();
+  inited=true;
+}
+
+AGString Job::xmlName() const
+{
+  return &quot;antJob&quot;;
+}
+
+
+/************************************************************************
+* MoveJob
+************************************************************************/
+
+MoveJob::MoveJob():
+  mTargetEntity(0)
+{
+}
+
+MoveJob::MoveJob(int p,AntEntity *pTarget,float pNear,bool pRun):Job(p),mTargetEntity(pTarget),mNear(pNear),mRun(pRun)
+{
+  assert(mTargetEntity);
+  m3d=false;
+  // speed=70; // pixels per second
+  //  runSpeed=100;
+}
+
+MoveJob::MoveJob(int p,const AGVector2 &amp;pTarget,float pNear,bool pRun):Job(p),mTarget(getMap()-&gt;truncPos(pTarget)),mTargetEntity(0),mNear(pNear),mRun(pRun)
+{
+  m3d=false;
+  // speed=70; // pixels per second
+  //  runSpeed=100;
+}
+
+MoveJob::MoveJob(int p,const AGVector3 &amp;pTarget,float pNear,bool pRun):Job(p),mTarget3(pTarget),mTargetEntity(0),mNear(pNear),mRun(pRun)
+{
+  m3d=true;
+  // speed=70; // pixels per second
+  //  runSpeed=100;
+}
+
+
+MoveJob::~MoveJob()
+{
+}
+
+// Jobs
+void MoveJob::move(AntEntity *e,float ptime)
+{
+  float aspeed;
+  float speed=e-&gt;getSpeed();
+
+  if(mTargetEntity)
+    {
+      mTarget=mTargetEntity-&gt;getPos2D();
+      mTarget3=mTargetEntity-&gt;getPos3D();
+    }
+ 
+#ifdef ENABLE_RUNNING  
+  float runSpeed=speed*1.3;
+
+  if(mRun &amp;&amp; e-&gt;getCondition()&gt;0.0)
+  {
+    // decrease condition and if condition is zero - switch of running
+    float newtime=e-&gt;decCondition(ptime);
+    moveBy(e,ptime-newtime,runSpeed);// take same runSpeed always
+    
+    ptime=newtime;
+  }
+#endif
+  aspeed=0.5*speed+0.5*e-&gt;getEnergy()*speed;
+  assert(this);
+  moveBy(e,ptime,aspeed); // use rest of time
+  assert(this);
+  
+}
+
+AGVector2 MoveJob::getDirection(const AntEntity *e) const
+{
+  return (mTarget-e-&gt;getPos2D()).normalized();
+}
+
+
+void MoveJob::moveBy(AntEntity *e,float ptime,float aspeed)
+{
+  float d0=getMap()-&gt;getPos(e-&gt;getPos2D())[2];
+
+  if(d0&lt;WATER_MARK &amp;&amp; e-&gt;isOnGround())
+    {
+      e-&gt;eventHitWaterMark(true);
+      return; // do nothing
+    }
+  else if(d0&gt;WATER_MARK &amp;&amp; e-&gt;isOnWater())
+    {
+      e-&gt;eventHitWaterMark(false);
+      return; // do nothing
+    }
+
+  AGVector3 oldPos=e-&gt;getPos3D();
+
+  if(m3d)
+    {
+      AGVector3 diff=e-&gt;getPos3D()-mTarget3;
+      float norm=diff.length();
+
+      if(norm-mNear&gt;ptime*aspeed)
+	{
+	  diff=diff.normalized();
+	  e-&gt;setDirection(-diff.getAngle().angle*180.0/M_PI);
+	  e-&gt;setPos(e-&gt;getPos3D()-diff*ptime*aspeed);
+	}
+      else
+	{
+	  if(norm&gt;mNear)
+	    e-&gt;setPos(mTarget3+diff.normalized()*mNear);
+	  e-&gt;setDirection(-diff.dim2().getAngle().angle*180.0/M_PI);
+	  jobFinished(e);
+	}
+
+    }
+  else
+    {
+      AGVector2 diff=e-&gt;getPos2D()-mTarget;
+      float norm=diff.length();
+      
+      if(norm-mNear&gt;ptime*aspeed)
+	{
+	  diff=diff.normalized();
+	  e-&gt;setDirection(-diff.getAngle().angle*180.0/M_PI);
+	  e-&gt;setPos(e-&gt;getPos2D()-diff*ptime*aspeed);
+	}
+      else
+	{
+	  if(norm&gt;mNear)
+	    e-&gt;setPos(mTarget+diff.normalized()*mNear);
+	  e-&gt;setDirection(-diff.getAngle().angle*180.0/M_PI);
+	  jobFinished(e);
+	}
+    }
+
+
+  float d1=getMap()-&gt;getPos(e-&gt;getPos2D())[2];
+  /*  if(d0&lt;WATER_MARK &amp;&amp; d1&gt;WATER_MARK)
+    e-&gt;eventHitWaterMark(false);
+  else if(d0&gt;WATER_MARK &amp;&amp; d1&lt;WATER_MARK)
+    e-&gt;eventHitWaterMark(true);
+  */
+
+  bool resetPos=false;
+
+  if(d1&lt;WATER_MARK &amp;&amp; e-&gt;isOnGround())
+    {
+      if(!e-&gt;eventHitWaterMark(true))
+	resetPos=true;
+    }
+  else if(d1&gt;WATER_MARK &amp;&amp; e-&gt;isOnWater())
+    {
+      if(!e-&gt;eventHitWaterMark(false))
+	resetPos=true;
+    }
+  if(resetPos)
+    e-&gt;setPos(oldPos);
+
+}
+
+void MoveJob::saveXML(Node &amp;pNode) const
+{
+  Job::saveXML(pNode);
+  pNode.set(&quot;pos&quot;,mTarget.toString());
+  pNode.set(&quot;near&quot;,AGString(mNear));
+  pNode.set(&quot;run&quot;,mRun?&quot;true&quot;:&quot;false&quot;);
+}
+void MoveJob::loadXML(const Node &amp;pNode)
+{
+  Job::loadXML(pNode);
+  if(pNode.get(&quot;pos&quot;).length())
+    mTarget=AGVector2(pNode.get(&quot;pos&quot;));
+  if(pNode.get(&quot;near&quot;).length())
+    mNear=pNode.get(&quot;near&quot;).toFloat();
+  if(pNode.get(&quot;run&quot;).length())
+    mRun=pNode.get(&quot;run&quot;)==&quot;true&quot;;
+}
+AGString MoveJob::xmlName() const
+{
+  return &quot;moveJob&quot;;
+}
+
+
+
+/************************************************************************
+* FightJob
+************************************************************************/
+
+FightJob::FightJob():mTarget(0),mTargetID(-1)
+{
+}
+
+FightJob::FightJob(int p,AntEntity *pTarget,float pDistance):Job(p),mTarget(pTarget)
+{
+  fightDistance=pDistance;
+  moving=true;
+}
+
+FightJob::~FightJob()
+{
+}
+
+bool FightJob::needsMorale() const
+{
+  return true;
+}
+
+void FightJob::move(AntEntity *e,float ptime)
+{
+  if(mTarget==0)
+    {
+      mTarget=getMap()-&gt;getEntity(mTargetID);
+      if(!mTarget)
+	{
+	  cdebug(&quot;Could not find id:&quot;&lt;&lt;mTargetID);
+	}
+      assert(mTarget);
+    }
+
+  if(e-&gt;getEnergy()&lt;0)
+    throw std::runtime_error(&quot;Problem: fighting, but I'm alread dead!&quot;);
+    
+  if(mTarget-&gt;defeated())
+    {
+      // already died - so no sigDefeated
+      e-&gt;eventHaveDefeated(mTarget);
+      jobFinished(e);
+      return; // early out
+    }
+
+  if(mTarget-&gt;getEnergy()&lt;=0.0)
+    {
+      // already died - so no sigDefeated
+      e-&gt;eventHaveDefeated(mTarget);
+      jobFinished(e);
+      return; // early out
+    }
+  else if(mTarget-&gt;getMorale()&lt;0.1)
+    {
+      mTarget-&gt;sigDefeated();
+      e-&gt;eventHaveDefeated(mTarget);
+      jobFinished(e);
+      return; // early out
+    }
+  // if target is too far away run there, otherwise fight
+  AGVector2 diff=e-&gt;getPos2D()-mTarget-&gt;getPos2D();
+  float norm=diff.length();
+  float speed=e-&gt;getSpeed();
+
+
+  e-&gt;setDirection(-diff.getAngle().angle*180.0/M_PI);
+
+  if(norm-fightDistance&gt;ptime*speed)
+    {
+      // run
+      diff=diff.normalized();
+      e-&gt;setPos(e-&gt;getPos2D()-diff*ptime*speed);
+      //    e-&gt;setDirection(-diff.getAngle().angle*180.0/M_PI);
+      if(!moving)
+	{
+	  e-&gt;eventStartMoving();
+	  moving=true;
+	}
+    }
+  else
+    {
+      // fight
+      mTarget-&gt;decEnergy(ptime*e-&gt;getStrength()*e-&gt;getAggression()/mTarget-&gt;getDefense());
+      mTarget-&gt;decMorale(ptime*e-&gt;getMoraleStrength()/mTarget-&gt;getDefense()); // FIXME: estimate this value
+      mTarget-&gt;eventGotFight(e);
+
+      e-&gt;incExperience(ptime*e-&gt;learnAmount);
+      if(moving)
+	{
+	  e-&gt;eventStartFighting();
+	  moving=false;
+	}
+
+    }
+}
+
+void FightJob::saveXML(Node &amp;pNode) const
+{
+  Job::saveXML(pNode);
+  pNode.set(&quot;target&quot;,AGString(mTarget-&gt;getID()));
+  pNode.set(&quot;distance&quot;,AGString(fightDistance));
+  pNode.set(&quot;moving&quot;,moving?&quot;true&quot;:&quot;false&quot;);
+}
+void FightJob::loadXML(const Node &amp;pNode)
+{
+  Job::loadXML(pNode);
+  if(pNode.get(&quot;target&quot;).length())
+    {
+      mTarget=0;
+      mTargetID=pNode.get(&quot;target&quot;).toInt();
+    }
+
+  if(pNode.get(&quot;distance&quot;).length())
+    fightDistance=pNode.get(&quot;distance&quot;).toFloat();
+  if(pNode.get(&quot;moving&quot;).length())
+    moving=pNode.get(&quot;moving&quot;)==&quot;true&quot;;
+}
+AGString FightJob::xmlName() const
+{
+  return &quot;fightJob&quot;;
+}
+
+
+/***************************************************************************
+ *
+ ***************************************************************************/
+
+FetchJob::FetchJob():
+  mTarget(0)
+{
+}
+
+FetchJob::FetchJob(int p,const AGVector2&amp;pTarget,AGString what):MoveJob(p,pTarget,0.5),mWhat(what),mTarget(0)
+{
+}
+FetchJob::FetchJob(int p,AntEntity *pTarget,AGString what):MoveJob(p,pTarget-&gt;getPos2D(),0.5),mWhat(what),mTarget(pTarget)
+{
+}
+
+
+FetchJob::~FetchJob()
+{
+}
+void FetchJob::move(AntEntity *e,float ptime)
+{
+  MoveJob::move(e,ptime);
+}
+
+void FetchJob::jobFinished(AntEntity *e)
+{
+  e-&gt;resource.add(mWhat,1);
+  e-&gt;resourceChanged();
+  MoveJob::jobFinished(e);
+
+  if(mTarget)
+    {
+      mTarget-&gt;resource.sub(mWhat,1);
+      mTarget-&gt;resourceChanged();
+    }
+}
+
+void FetchJob::saveXML(Node &amp;pNode) const
+{
+  MoveJob::saveXML(pNode);
+  pNode.set(&quot;target&quot;,AGString(mTarget-&gt;getID()));
+  pNode.set(&quot;what&quot;,AGString(mWhat));
+}
+void FetchJob::loadXML(const Node &amp;pNode)
+{
+  MoveJob::loadXML(pNode);
+  if(pNode.get(&quot;target&quot;).length())
+    {
+      mTarget=0;
+      mTargetID=pNode.get(&quot;target&quot;).toInt();
+    }
+
+  if(pNode.get(&quot;what&quot;).length())
+    mWhat=pNode.get(&quot;what&quot;);
+
+}
+AGString FetchJob::xmlName() const
+{
+  return &quot;fetchJob&quot;;
+}
+
+
+/***************************************************************************
+ *
+ ***************************************************************************/
+
+RestJob::RestJob():mTime(0)
+{
+}
+
+RestJob::RestJob(float pTime):Job(0),mTime(pTime)
+{
+}
+RestJob::~RestJob()
+{
+}
+void RestJob::move(AntEntity *e,float ptime)
+{
+  e-&gt;incMorale(std::min(ptime,mTime));
+  e-&gt;heal(std::min(ptime,mTime));
+  mTime-=ptime;
+  if(mTime&lt;0)
+    jobFinished(e);
+}
+
+void RestJob::saveXML(Node &amp;pNode) const
+{
+  Job::saveXML(pNode);
+
+  pNode.set(&quot;time&quot;,AGString(mTime));
+}
+void RestJob::loadXML(const Node &amp;pNode)
+{
+  Job::loadXML(pNode);
+
+  if(pNode.get(&quot;time&quot;).length())
+    mTime=pNode.get(&quot;time&quot;).toFloat();
+}
+AGString RestJob::xmlName() const
+{
+  return &quot;restJob&quot;;
+}
+

Added: antargis/branches/rant/ext/game/jobs.h
===================================================================
--- antargis/branches/rant/ext/game/jobs.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/jobs.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,144 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * jobs.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef ANT_JOBS_H
+#define ANT_JOBS_H
+#include &lt;ag_geometry.h&gt;
+
+class AntEntity;
+
+/**
+   Job class won't be exported to Ruby, because their constant
+   creation and deletion fills up the GC otherwise.
+*/
+class Job
+{
+  int priority;
+  bool inited;
+ public:
+  Job();
+  Job(int p);
+  virtual ~Job();
+  virtual void move(AntEntity *,float ptime);
+
+  virtual void saveXML(Node &amp;pNode) const;
+  virtual void loadXML(const Node &amp;pNode);
+
+  virtual AGString xmlName() const;
+
+  virtual void jobFinished(AntEntity *e);
+  bool operator&lt;=(const Job &amp;j) const;
+
+  virtual bool needsMorale() const;
+
+  bool valid() const;
+};
+
+class RestJob:public Job
+{
+  float mTime;
+ public:
+  RestJob();
+  RestJob(float pTime);
+  virtual ~RestJob();
+  void move(AntEntity *e,float ptime);
+
+  virtual void saveXML(Node &amp;pNode) const;
+  virtual void loadXML(const Node &amp;pNode);
+  virtual AGString xmlName() const;
+
+};
+
+class MoveJob:public Job
+{
+  AGVector2 mTarget;
+  AGVector3 mTarget3;
+  AntEntity *mTargetEntity;
+  float mNear;
+  bool mRun;
+
+  bool m3d;
+ public:
+  MoveJob();
+  MoveJob(int p,AntEntity *pTarget,float pnear=0,bool pRun=false);
+  MoveJob(int p,const AGVector2 &amp;pTarget,float pnear=0,bool pRun=false);
+  MoveJob(int p,const AGVector3 &amp;pTarget,float pnear=0,bool pRun=false);
+  virtual ~MoveJob();
+  void move(AntEntity *e,float ptime);
+  AGVector2 getDirection(const AntEntity *e) const;
+  
+  virtual void saveXML(Node &amp;pNode) const;
+  virtual void loadXML(const Node &amp;pNode);
+  virtual AGString xmlName() const;
+
+  AntEntity *getTarget()
+    {
+      return mTargetEntity;
+    }
+  
+ private:
+  void moveBy(AntEntity *e,float ptime,float aspeed);
+};
+
+// FIXME: implement near and far fighting (arrows)
+class FightJob:public Job
+{
+  AntEntity *mTarget;
+  float fightDistance;
+  bool moving;
+  int mTargetID;
+  
+ public:
+  FightJob();
+  FightJob(int p,AntEntity *pTarget, float pDistance=1);
+  
+  virtual ~FightJob();
+  void move(AntEntity *e,float ptime);
+  virtual bool needsMorale() const;
+  AntEntity *getTarget()
+    {
+      return mTarget;
+    }
+  
+  virtual void saveXML(Node &amp;pNode) const;
+  virtual void loadXML(const Node &amp;pNode);
+  virtual AGString xmlName() const;
+  
+};
+
+class FetchJob:public MoveJob
+{
+  AGString mWhat;
+  AntEntity *mTarget;
+  int mTargetID;
+ public:
+  FetchJob();
+  FetchJob(int p,const AGVector2 &amp;pTarget,AGString what);
+  FetchJob(int p,AntEntity *pTarget,AGString what);
+  virtual ~FetchJob();
+  void move(AntEntity *e,float ptime);
+  virtual void jobFinished(AntEntity *e);
+  
+  virtual void saveXML(Node &amp;pNode) const;
+  virtual void loadXML(const Node &amp;pNode);
+  virtual AGString xmlName() const;
+};
+
+#endif

Added: antargis/branches/rant/ext/game/map.cc
===================================================================
--- antargis/branches/rant/ext/game/map.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/map.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,475 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * map.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;scene.h&quot;
+#include &quot;ag_rand.h&quot;
+#include &quot;map.h&quot;
+#include &quot;entity.h&quot;
+#include &lt;vector&gt;
+#include &lt;math.h&gt;
+#include &lt;ag_debug.h&gt;
+#include &quot;mesh.h&quot;
+#include &quot;terrain.h&quot;
+#include &quot;quadtree.h&quot;
+#include &quot;anim_mesh.h&quot;
+#include &quot;mesh_2d.h&quot;
+#include &quot;ag_profiler.h&quot;
+
+
+
+//////////////////////////////////////////////////////////////////////////
+// AntMap
+//////////////////////////////////////////////////////////////////////////
+
+AntMap *myAntargisMap=0;
+AntMap *getMap()
+{
+  assert(myAntargisMap);
+  return myAntargisMap;
+}
+
+AntMap::AntMap(SceneBase *pScene,int w,int h):
+  HeightMap(pScene,w,h),
+  mEntQuad(new QuadTree&lt;AntEntity&gt;(AGRect2(0,0,w,h))),
+  mHeuristicFunction(0)
+{
+  myAntargisMap=this;
+  maxID=0;
+}
+AntMap::~AntMap()
+{
+  CTRACE;
+  printf(&quot;%lX\n&quot;,mRUBY);
+  if(myAntargisMap==this)
+    myAntargisMap=0;
+}
+
+AGVector3 AntMap::getPos(const AGVector2 &amp;pPos) const
+{
+  return AGVector3(pPos[0],pPos[1],getHeight(pPos[0],pPos[1]));
+}
+
+
+
+AntEntity *AntMap::getEntity(int id) const
+{
+  EntityMap::const_iterator i=mEntityMap.find(id);
+  if(i==mEntityMap.end())
+    return 0;
+  return i-&gt;second;
+}
+
+// FIXME: exchange this function somehow!!
+int AntMap::getNewID()
+{
+  return maxID++;
+}
+
+void AntMap::useID(int id)
+{
+  maxID=std::max(maxID,id+1);
+}
+
+
+void AntMap::saveXML(Node &amp;node) const
+{
+  HeightMap::saveXML(node);
+  
+  // entities
+  std::list&lt;AntEntity*&gt;::const_iterator i=mEntities.begin();
+  for(;i!=mEntities.end();i++)
+    {
+      Node &amp;child=node.addChild((*i)-&gt;xmlName());
+      (*i)-&gt;saveXML(child);
+    }
+  
+}
+
+
+void AntMap::loadXML(const Node &amp;node)
+{
+  HeightMap::loadXML(node);
+
+  Node::const_iterator i=node.begin();
+  for(;i!=node.end();i++)
+    {
+      //      AntEntity *e=0;
+      Node *n=*i;
+      processXMLNode(*n);
+      /*        {
+	  e-&gt;loadXML(*n);
+	  insertEntity(e);
+	  }*/
+    }
+  // tell entities, that map has changed
+  std::list&lt;AntEntity*&gt;::iterator k=mEntities.begin();
+  for(;k!=mEntities.end();k++)
+    (*k)-&gt;eventMapChanged();
+}
+
+void AntMap::insertEntity(AntEntity *e)
+{
+  //  cdebug(&quot;INSERTING:&quot;&lt;&lt;e);
+  mEntities.push_back(e);
+  //  mEntList.push_back(e);
+  mEntityMap[e-&gt;getID()]=e;
+  mEntQuad-&gt;insert(e);
+  //  entsChanged();
+  //  mByType[e-&gt;getType()].insert(e);
+}
+
+void AntMap::removeEntity(AntEntity *p)
+{
+  {
+    EntityList::iterator i=std::find(mToDel.begin(),mToDel.end(),p);
+    if(i!=mToDel.end())
+      {
+	cdebug(&quot;Entity already deleted:&quot;&lt;&lt;p);
+	return;
+      }
+  }
+
+
+  EntityList::iterator i=std::find(mEntities.begin(),mEntities.end(),p);
+  if(i!=mEntities.end())
+    mToDel.push_back(p);
+  else
+    {
+      cdebug(&quot;ERROR: Entity not found while removing:&quot;&lt;&lt;p);
+      //      throw std::runtime_error(&quot;ERROR: Entity not found while removing&quot;);
+    }
+}
+
+
+void AntMap::move(float pTime)
+{
+  STACKTRACE; 
+  //return;
+  // first remove entities, which shall be deleted
+  std::list&lt;AntEntity*&gt;::iterator d=mToDel.begin();
+  for(;d!=mToDel.end();d++)
+    {
+      EntityList::iterator i=std::find(mEntities.begin(),mEntities.end(),*d);
+      if(i!=mEntities.end())
+	mEntities.erase(i);
+      else
+	cdebug(&quot;ERROR: Entity not found while deleting:&quot;&lt;&lt;*d);
+      mEntityMap.erase((*d)-&gt;getID());
+      mEntQuad-&gt;remove(*i);
+      //      mByType[(*d)-&gt;getType()].erase(*d);
+
+      saveDelete(*d);
+    }
+  mToDel.clear();
+
+  // now move all entities
+
+  EntityList::iterator i=mEntities.begin();
+
+  for(;i!=mEntities.end();i++)
+    {
+      (*i)-&gt;move(pTime);
+    }
+}
+
+
+void AntMap::processXMLNode(const Node &amp;node)
+{
+  //  AntEntity *e=0;
+  cdebug(&quot;type unknown:&quot;&lt;&lt;node.getName());
+  //  return e;
+}
+
+/*std::vector&lt;AntEntityPtr&gt; AntMap::getByType(const AGString &amp;pType)
+{
+  std::vector&lt;AntEntityPtr&gt; l;
+  EntityByType::iterator i=mByType.find(pType);
+  if(i!=mByType.end())
+    {
+      std::copy(i-&gt;second.begin(),i-&gt;second.end(),std::back_inserter(l));
+    }
+
+  return l;  
+  }*/
+
+
+AntMap::EntityList AntMap::getEntities(const AGRect2&amp;r)
+{
+  return mEntQuad-&gt;get(r);
+}
+AntMap::EntityList AntMap::getAllEntities()
+{
+  return mEntities;
+}
+std::vector&lt;AntEntityPtr&gt; AntMap::getAllEntitiesV()
+{
+  std::vector&lt;AntEntityPtr&gt; v;
+  std::copy(mEntities.begin(),mEntities.end(),std::back_inserter(v));
+  return v;
+}
+std::vector&lt;AntEntityPtr&gt; AntMap::getEntities(const AGString &amp;pName)
+{
+  std::vector&lt;AntEntityPtr&gt; v;
+  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+    if((*i)-&gt;provides(pName))
+      v.push_back(*i);
+  return v;
+}
+
+std::vector&lt;AntEntityPtr&gt; AntMap::getNextList(AntEntity *me,const AGString &amp;pType,size_t atLeast)
+{
+  //  assert(mHeuristicFunction);
+
+  // FIXME: optimize this - use quadtree
+
+  std::multimap&lt;float,AntEntity*&gt; ents;
+
+
+  EntityList::iterator i=mEntities.begin();
+  AGVector2 p=me-&gt;getPos2D(); // FIXME: check for reachability, too ??
+
+  for(;i!=mEntities.end();i++)
+    {
+      if(me!=*i)
+        {
+          if((*i)-&gt;provides(pType) &amp;&amp; (*i)-&gt;resource.get(pType)&gt;=atLeast)
+            {
+	      /*
+              AGVector2 p2=(*i)-&gt;getPos2D()-p;
+              float norm=p2.length2();*/
+	      float norm;
+	      if(mHeuristicFunction)
+		norm=(*mHeuristicFunction)(std::make_pair((*i)-&gt;getPos2D(),p));
+	      else
+		norm=((*i)-&gt;getPos2D()-p).length2();
+              ents.insert(std::make_pair(norm,*i));
+            }
+        }
+    }
+
+  std::vector&lt;AntEntityPtr&gt; vec;
+
+  // take one of the nearest, but no farer away than 30% of nearest
+  //  AntEntity *e=0;
+  if(ents.size())
+    {
+      std::multimap&lt;float,AntEntity*&gt;::iterator j=ents.begin();
+      float nearest=j-&gt;first;
+      for(;j!=ents.end();j++)
+	{
+	  if(j-&gt;first&lt;=nearest*1.3)
+	    vec.push_back(j-&gt;second);
+	}
+    }
+
+  return vec;
+}
+
+
+AntEntity *AntMap::getNext(AntEntity *me,const AGString &amp;pType,size_t atLeast)
+{
+  //  assert(mHeuristicFunction);
+  // FIXME: optimize this - use quadtree
+
+  std::multimap&lt;float,AntEntity*&gt; ents;
+
+
+  EntityList::iterator i=mEntities.begin();
+  AGVector2 p=me-&gt;getPos2D(); // FIXME: check for reachability, too ??
+  //  float dist=0;
+
+  for(;i!=mEntities.end();i++)
+    {
+      if(me!=*i)
+        {
+          if((*i)-&gt;provides(pType) &amp;&amp; (*i)-&gt;resource.get(pType)&gt;=atLeast)
+            {
+	      //              AGVector2 p2=(*i)-&gt;getPos2D()-p;
+	      float norm;
+
+	      if(mHeuristicFunction)
+	        norm=(*mHeuristicFunction)(std::make_pair((*i)-&gt;getPos2D(),p));
+	      else
+		norm=((*i)-&gt;getPos2D()-p).length2();
+	      cdebug(&quot;norm:&quot;&lt;&lt;norm&lt;&lt;&quot; i:&quot;&lt;&lt;*i&lt;&lt;&quot; name:&quot;&lt;&lt;(*i)-&gt;getName());
+	      //              float norm=p2.length2();
+              ents.insert(std::make_pair(norm,*i));
+            }
+        }
+    }
+
+
+  // take one of the nearest, but no farer away than 30% of nearest
+  AntEntity *e=0;
+  if(ents.size())
+    {
+      std::multimap&lt;float,AntEntity*&gt;::iterator j=ents.begin();
+      float nearest=j-&gt;first;
+      int r=agRand(std::min((int)ents.size(),5));
+      while(r&gt;0 &amp;&amp; (j-&gt;first&lt;=nearest*1.3 || j-&gt;first&lt;2000*2000))
+        {
+          j++;
+          r--;
+        }
+      if(r&gt;0)
+        j--;
+      assert((j!=ents.end()));
+      e=j-&gt;second;
+      //      cdebug(&quot;DIST:&quot;&lt;&lt;j-&gt;first);
+    }
+
+  return e;
+}
+
+void AntMap::setHeuristic(HeuristicFunction *pFunction)
+{
+  mHeuristicFunction=pFunction;
+}
+
+
+AntEntity *AntMap::getByName(const AGString &amp;pName)
+{
+  EntityList::iterator i=mEntities.begin();
+
+  for(;i!=mEntities.end();i++)
+    {
+      if((*i)-&gt;getName()==pName)
+        return *i;
+    }
+  return 0;
+}
+
+void AntMap::loadMapFromMemory(const AGData &amp;pMem)
+{
+  if(pMem.length())
+    {
+      Document d;
+      d.parseMemory(pMem);
+      loadXML(d.root());
+    }
+}
+
+void AntMap::loadMap(const AGFilename &amp;pFilename)
+{
+  
+  loadMapFromMemory(loadFile(pFilename));
+}
+void AntMap::saveMap(const AGFilename &amp;pFilename)
+{
+  mName=AGString(pFilename);
+  Document d;
+  Node &amp;root=d.root();
+  root.setName(&quot;antargisLevel&quot;);
+  //  cdebug(&quot;root:&quot;&lt;&lt;root);
+  saveXML(root);
+
+  AGData c=d.toString();
+  cdebug(c);
+  saveFile(pFilename,c);
+}
+
+void AntMap::clear()
+{
+  //  getScene()-&gt;clear();
+  CTRACE;
+  //  mPlayers.clear();
+
+  mEntQuad-&gt;clear();
+  mEntityMap.clear();
+
+  // save delete entities
+  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+    saveDelete(*i);
+  
+
+  mEntities.clear();
+
+}
+
+void AntMap::mapChanged()
+{
+  HeightMap::mapChanged();
+  // send info to entitites
+  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+    (*i)-&gt;setPos((*i)-&gt;getPos2D());
+}
+
+AntEntity *AntMap::getEntity(const Mesh &amp;pMesh)
+{
+  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+    {
+      AntEntity::Meshes meshes=(*i)-&gt;getMesh();
+      if(std::find(meshes.begin(),meshes.end(),&amp;pMesh)!=meshes.end())
+	//      if((*i)-&gt;getMesh()==&amp;pMesh)
+	return *i;
+    }
+  return 0;
+}
+
+AntEntity *AntMap::getEntity(const AnimMesh &amp;pMesh)
+{
+  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+    {
+      AntEntity::Meshes meshes=(*i)-&gt;getMesh();
+      if(std::find(meshes.begin(),meshes.end(),&amp;pMesh)!=meshes.end())
+	return *i;
+    }
+  return 0;
+}
+
+AntEntity *AntMap::getEntity(const Mesh2D &amp;pMesh)
+{
+  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+    {
+      AntEntity::Meshes meshes=(*i)-&gt;getMesh();
+      if(std::find(meshes.begin(),meshes.end(),&amp;pMesh)!=meshes.end())
+	//      if((*i)-&gt;getMesh()==&amp;pMesh)
+	return *i;
+    }
+  return 0;
+}
+
+
+
+
+
+
+//bool markingFinished=true;
+
+void AntMap::mark()
+{
+  CTRACE;
+  HeightMap::mark();
+  AntMap::EntityList::iterator i=mEntities.begin();
+
+  for(;i!=mEntities.end();i++)
+    markObject(*i);
+
+  // mark to del, too, otherwise it crashes when tidying before move() is called
+  for(i=mToDel.begin();i!=mToDel.end();i++)
+    markObject(*i);
+}
+
+
+void AntMap::newMap(int w,int h)
+{
+  clear();
+  HeightMap::newMap(w,h);
+}

Added: antargis/branches/rant/ext/game/map.h
===================================================================
--- antargis/branches/rant/ext/game/map.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/map.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * map.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef __MAP_H__
+#define __MAP_H__
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &quot;height_map.h&quot;
+#include &quot;heuristic.h&quot;
+
+/**
+ * \defgroup GameEngine BoA Game-Engine
+ * \brief the C++ parts of the BoA game-engine
+ *
+*/
+
+
+//FIXME: add quadtree
+
+template&lt;class T&gt;
+class QuadTree;
+
+class AnimMesh;
+class Mesh2D;
+
+class AntMap:public HeightMap
+{
+ public:
+  typedef std::list&lt;AntEntity*&gt; EntityList;
+
+  AntMap(SceneBase *pScene,int w,int h);
+  ~AntMap();
+  
+  virtual void insertEntity(AntEntity *e);
+  virtual void removeEntity(AntEntity *p);
+  void clear();
+
+  int getNewID();
+  void useID(int id);
+
+  void newMap(int w,int h);
+  
+  EntityList getEntities(const AGRect2&amp;r);
+  EntityList getAllEntities();
+  std::vector&lt;AntEntityPtr&gt; getAllEntitiesV();
+  std::vector&lt;AntEntityPtr&gt; getEntities(const AGString &amp;pName);
+
+  AntEntity *getEntity(const Mesh &amp;pMesh);
+  AntEntity *getEntity(const AnimMesh &amp;pMesh);
+  AntEntity *getEntity(const Mesh2D &amp;pMesh);
+  AntEntity *getEntity(int id) const;
+  AntEntity *getByName(const AGString &amp;pName);
+
+  AntEntity *getNext(AntEntity *me,const AGString &amp;pType,size_t atLeast=0);
+  std::vector&lt;AntEntityPtr&gt; getNextList(AntEntity *me,const AGString &amp;pType,size_t atLeast=0);
+
+  void setHeuristic(HeuristicFunction *pFunction);
+
+  virtual void processXMLNode(const Node &amp;node);
+
+  void saveXML(Node &amp;node) const;
+  void loadXML(const Node &amp;node);
+
+  void saveMap(const AGFilename &amp;pFilename);
+  virtual void loadMap(const AGFilename &amp;pFilename);
+  virtual void loadMapFromMemory(const AGData &amp;Memory);
+
+  void move(float pTime);
+
+  AGVector3 getPos(const AGVector2 &amp;pPos) const;
+
+  virtual void mark();
+
+  virtual void mapChanged();  
+
+
+  //  std::vector&lt;AntEntityPtr&gt; getByType(const AGString &amp;pType);
+ private:
+  typedef std::map&lt;size_t,AntEntity*&gt; EntityMap;
+
+  EntityList mEntities;
+  EntityMap mEntityMap;
+  QuadTree&lt;AntEntity&gt; *mEntQuad;
+
+  //  typedef std::map&lt;AGString,std::set&lt;AntEntity*&gt; &gt; EntityByType;
+  
+  EntityList mToDel;
+
+  //  EntityByType mByType;
+
+  int maxID;
+
+  HeuristicFunction *mHeuristicFunction;
+
+
+};
+
+AntMap *getMap();
+
+
+#endif

Added: antargis/branches/rant/ext/game/minimap.cc
===================================================================
--- antargis/branches/rant/ext/game/minimap.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/minimap.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,378 @@
+#include &quot;minimap.h&quot;
+#include &lt;ag_layoutfactory.h&gt;
+#include &lt;ag_screen.h&gt;
+#include &lt;ag_profiler.h&gt;
+#include &quot;ant_app.h&quot;
+
+#define MAP_BORDER
+
+MiniMap::MiniMap(AGWidget *p,const AGRect2 &amp;r,AntMap *pMap):
+  AGWidget(p,r),
+  mMap(pMap),
+  mSurface(r.w(),r.h())
+{
+  mMapBorder=24;
+  mScene=0;
+  mTexture=new AGTexture(mSurface);
+  setMap(mMap);
+}
+
+MiniMap::~MiniMap()
+{
+  delete mTexture;
+}
+
+
+bool MiniMap::mapChangedComplete(AGEvent *e)
+{
+  CTRACE;
+  mapChangedP(true);
+  return false;
+}
+  
+bool MiniMap::mapChanged(AGEvent *e)
+{
+  CTRACE;
+  mapChangedP(false);
+  return false;
+}
+
+float MiniMap::getNoise(int x,int y)
+{
+  return 1.0-((x*87644+y*653635+x*y*153637)%100)/float(1000.0);
+}
+
+void MiniMap::mapChangedP(bool forceFull=false)
+{
+  CTRACE;
+  if(!mMap)
+    return;
+  int w,h;
+  int x,y;
+  //  forceFull=true;
+  bool inmem=forceFull;
+
+  w=getRect().w();
+  h=getRect().h();
+
+  AGRect2 change=mMap-&gt;getChangeRect();
+  //  float mw=mMap-&gt;getW();
+  //  float mh=mMap-&gt;getH();
+
+  AGVector2 p0(change[0]),p1(change[1]);
+
+  AGVector2 sp0(fromMapCoords(p0));
+  AGVector2 sp1(fromMapCoords(p1));
+
+  int x0=std::min(sp0[0],sp1[0]);
+  int x1=std::max(sp0[0],sp1[0]);
+  int y0=std::min(sp0[1],sp1[1]);
+  int y1=std::max(sp0[1],sp1[1]);
+
+  AGPainter *p=0;
+
+  if((x1-x0)*(y1-y0)&gt;w*h/8 || inmem)
+    {
+      TRACE;
+      p=new AGPainter(mSurface);
+      inmem=true;
+      x0=0;
+      y0=0;
+      x1=width()-1;
+      y1=height()-1;
+    }
+  else
+    {
+      p=new AGPainter(*mTexture);
+      inmem=false;
+    }
+
+  
+
+  AGVector3 light(-1,1,1);
+  light.normalize();
+
+  TerrainType t;
+
+  assert(mMap);  
+  
+  if(mMap)
+    {
+      CTRACE;
+      for(x=x0;x&lt;x1;x++)
+	for(y=y0;y&lt;y1;y++)
+	  {
+	    AGVector2 mv(toMapCoords(AGVector2(x,y)));
+
+	    AGColor c(0,0,0xFF);
+
+	    t=mMap-&gt;getTerrain(mv[0],mv[1]);
+	    float height=mMap-&gt;getHeight(mv[0],mv[1]);
+
+	    AGVector3 n=mMap-&gt;getNormalF(mv[0],mv[1]);
+
+	    float l=std::min(1.0f,n*light*0.5f+0.5f);
+	    
+	    if(t==WATER)
+	      c=AGColor(0xAA,0xAA,0xFF);
+	    else if(t==SAND)
+	      c=AGColor(0xFF,0x77,0);
+	    else if(t==EARTH)
+	      c=AGColor(0xAA,0x66,0);
+	    else if(t==GRASS)
+	      c=AGColor(0,0xaa,0);
+	    else if(t==GRASS2)
+	      c=AGColor(0x00,0xdd,0x00);
+	    else if(t==FOREST)
+	      c=AGColor(0x00,0x77,0x00);
+	    else if(t==ROCK)
+	      c=AGColor(0xAA,0xAA,0xAA);
+	    else if(t==ROCK2)
+	      c=AGColor(0xFF,0xFF,0xFF);
+
+	    c=c*l;
+
+	    if(height&lt;=0)
+	      c=c*0.25+AGColor(0,0,0xFF)*0.75;
+	    else if(height&lt;0.2)
+	      c=c*(height*4)+AGColor(0,0,0xFF)*(1-(height*4));
+	    else if(height&lt;0.4)
+	      c=c*0.25+AGColor(0xFF,0x77,0)*0.75; // sand
+	    c*=getNoise(x,y);
+
+	    
+	    p-&gt;putPixel(AGVector2(x,y),c);
+	  }
+    }
+  else
+    {
+      for(x=0;x&lt;w;x++)
+	for(y=0;y&lt;h;y++)
+	  {
+	    p-&gt;putPixel(AGVector2(x,y),AGColor(0xFF,0,0));
+	  }
+    }
+
+  delete p;
+  if(inmem)
+    {
+      //      mSurface.save(&quot;sicke.png&quot;);
+      cdebug(mTexture);
+      delete mTexture;
+      mTexture=new AGTexture(mSurface);
+      cdebug(mTexture);
+      CTRACE;
+    }
+  return;
+}
+
+void MiniMap::draw(AGPainter &amp;p)
+{
+  STACKTRACE;
+  //  CTRACE;
+  AGRect2 m=getRect().origin();
+  //  cdebug(mTexture&lt;&lt;&quot;   &quot;&lt;&lt;m);
+  p.blit(*mTexture,m);
+
+  drawEntities(p);
+
+  if(mScene)
+    {
+      AGVector4 cam=mScene-&gt;getCamera();
+      
+      int w,h;
+
+      AGVector2 v=fromMapCoords(cam.dim2());
+
+      // now with approx. frustum
+
+      w=25*getRect().w()/mMap-&gt;getW();
+      h=25*getRect().h()/mMap-&gt;getH();
+      
+      v-=AGVector2(w/2,h/2);
+
+      AGRect2 r(v[0],v[1],w,h);
+      AGColor c1(0xff,0xaa,0,0x77);
+      AGColor c2(0xee,0x77,0,0x77);
+      
+      p.drawBorder(r,2,c1,c2);
+      r=r.shrink(1);
+      p.drawBorder(r,2,c2,c1);
+    }
+}
+
+void MiniMap::drawEntities(AGPainter &amp;p)
+{
+  //  return;
+  if(mMap)
+    {
+      std::vector&lt;std::pair&lt;AGRect2,AGVector4&gt; &gt; rects;
+      size_t es=0;
+      AntMap::EntityList e=mMap-&gt;getAllEntities();
+      for(AntMap::EntityList::iterator i=e.begin();i!=e.end();i++)
+	{
+	  if((*i)-&gt;showOnMinimap())
+	    {
+	      AGVector2 v=(*i)-&gt;getPos2D();
+	      v=fromMapCoords(v);
+
+	      float s=(*i)-&gt;getMinimapSize();
+	      AGVector4 c0=(*i)-&gt;getMinimapColor().toVec();
+	      AGVector4 c1=((*i)-&gt;getMinimapColor()*1.2).toVec();
+	      AGVector4 c2=((*i)-&gt;getMinimapColor()*1.5).toVec();
+
+	      if(s&gt;2)
+		{
+		  rects.push_back(std::make_pair(AGRect2(v[0],v[1],s,s),c2));
+		  rects.push_back(std::make_pair(AGRect2(v[0]+1,v[1]+1,s-2,s-2),AGVector4(1,1,1,1)));
+		  if(s&gt;4)
+		    rects.push_back(std::make_pair(AGRect2(v[0]+2,v[1]+2,s-4,s-4),c2));
+		}
+	      else
+		{
+		  rects.push_back(std::make_pair(AGRect2(v[0],v[1],s,s),c0));
+		  rects.push_back(std::make_pair(AGRect2(v[0],v[1],1,1),c2));
+		  rects.push_back(std::make_pair(AGRect2(v[0]+1,v[1],1,1),c1));
+		  rects.push_back(std::make_pair(AGRect2(v[0],v[1]+1,1,1),c1));
+		}
+	      es++;
+	    }
+	}
+      p.fillRects(rects); // batch processing - in gl much faster!!
+    }
+}
+
+void MiniMap::setMap(AntMap *pMap)
+{
+  mMap=pMap;
+  if(mMap)
+    {
+      mMap-&gt;sigMapChanged.connect(slot(this,&amp;MiniMap::mapChanged));
+      mMap-&gt;sigMapChangedComplete.connect(slot(this,&amp;MiniMap::mapChangedComplete));
+      mapChangedComplete(0);
+    }
+}
+void MiniMap::setScene(SceneBase *pScene)
+{
+  mScene=pScene;
+}
+
+bool MiniMap::eventMouseButtonDown(AGEvent *m)
+{
+  if(mMap==0 || mScene==0)
+    return AGWidget::eventMouseButtonDown(m);
+
+  AGWidget::eventMouseButtonDown(m);
+      
+      // eat up event - so antView, doesn't get it
+  if(m-&gt;isSDLEvent())
+    if(getScreenRect().contains(m-&gt;getMousePosition()))
+      return true;
+  return false;
+}
+
+bool MiniMap::eventMouseClick(AGEvent *m)
+{
+  AGVector2 p(m-&gt;getMousePosition()-getScreenRect()[0]);
+  if(mMap==0 || mScene==0)
+    return AGWidget::eventMouseClick(m);
+
+  AGVector2 v(p);
+
+  float w=25*getRect().w()/mMap-&gt;getW();
+  float h=25*getRect().h()/mMap-&gt;getH();
+
+  w/=2;
+  h/=2;
+  if(v[0]&lt;w)
+    v[0]=w;
+  if(v[1]&lt;h)
+    v[1]=h;
+  if(v[0]&gt;width()-w)
+    v[0]=width()-w;
+  if(v[1]&gt;height()-h)
+    v[1]=height()-h;
+
+  v=toMapCoords(v);
+
+  //  mScene-&gt;setCamera(AGVector4(v[0],v[1],0,0));
+  AGApplication *app=getApplication();
+  if(app)
+    {
+      GLApp *glapp=dynamic_cast&lt;GLApp*&gt;(app);
+      if(glapp)
+	glapp-&gt;setCamera(v);
+    }
+
+  return true;
+}
+
+AGVector2 MiniMap::toMapCoords(AGVector2 v) const
+{
+  AGRect2 r=getRect();
+  v[0]/=r.w();
+  v[1]/=r.h();
+
+  v[1]=1-v[1];
+
+#ifdef MAP_BORDER
+  v[0]*=mMap-&gt;getW()-mMapBorder*2;
+  v[1]*=mMap-&gt;getH()-mMapBorder*1.5;
+  v[0]+=mMapBorder;
+  v[1]+=mMapBorder*0.35;
+#else
+  v[0]*=mMap-&gt;getW();
+  v[1]*=mMap-&gt;getH();
+#endif
+  return v;
+}
+AGVector2 MiniMap::fromMapCoords(AGVector2 v) const
+{
+  AGRect2 r=getRect();
+
+#ifdef MAP_BORDER
+  v[0]-=mMapBorder;
+  v[1]-=mMapBorder*0.35;
+
+  v[0]/=mMap-&gt;getW()-mMapBorder*2;
+  v[1]/=mMap-&gt;getH()-mMapBorder*1.5;
+#else
+  v[0]/=mMap-&gt;getW();
+  v[1]/=mMap-&gt;getH();
+#endif
+
+  v[1]=1-v[1];
+
+  v[0]*=r.w();
+  v[1]*=r.h();
+
+  return v;
+}
+
+
+
+
+MiniMap *toMiniMap(AGWidget *w)
+{
+  return dynamic_cast&lt;MiniMap*&gt;(w);
+}
+
+// AGLayout creator
+class AGMiniMapLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(MiniMap,&quot;miniMap&quot;)
+
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    CTRACE;
+    setResult(new MiniMap(pParent,pRect,0));
+  }
+};
+
+void registerMinimapCreator()
+{
+	TRACE;
+  getLayoutFactory()-&gt;addCreator(&quot;miniMap&quot;,new AGMiniMapLayoutCreator);
+}
+

Added: antargis/branches/rant/ext/game/minimap.h
===================================================================
--- antargis/branches/rant/ext/game/minimap.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/minimap.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,66 @@
+#ifndef MINIMAP_H
+#define MINIMAP_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &quot;map.h&quot;
+#include &lt;ag_widget.h&gt;
+#include &lt;ag_texture.h&gt;
+
+class SceneBase;
+
+/**
+   MiniMap is the small map in lower corner.
+   it's displayed through some single texture. the people are drawn on top of this.
+   when the height-map changes, the texture has to be changed.
+   So there are two different functions (mapChanged*)
+
+   Two things you have to take care of:
+   1) you have to set a map with setMap
+   2) you have to set a scene (for frustum-display) (setScene)
+
+   because typically this object is created within an xml-layout-file
+
+ */
+class MiniMap:public AGWidget
+{
+ public:
+  MiniMap(AGWidget *p,const AGRect2 &amp;r,AntMap *pMap);
+  virtual ~MiniMap();
+  
+  /// changes only part of the texture - shouldn't be called if the whole texture is changed, because this is SLOW!
+  bool mapChanged(AGEvent *e);
+  /// call this only if the complete texture is changed - otherwise this is SLOW!
+  bool mapChangedComplete(AGEvent *e);
+
+  void draw(AGPainter &amp;p);
+
+  void setMap(AntMap *pMap);
+  void setScene(SceneBase *pScene);
+
+  virtual bool eventMouseClick(AGEvent *m);
+  virtual bool eventMouseButtonDown(AGEvent *m);
+
+ private:
+  // adds some fancy noise to the map display
+  float getNoise(int x,int y);
+
+  AGVector2 toMapCoords(AGVector2 v) const;
+  AGVector2 fromMapCoords(AGVector2 v) const;
+
+  void mapChangedP(bool force);
+
+  void drawEntities(AGPainter &amp;p);
+
+  float mMapBorder;
+  AntMap *mMap;
+  SceneBase *mScene;
+  AGTexture *mTexture;
+  AGSurface mSurface;
+};
+
+MiniMap *toMiniMap(AGWidget *w);
+
+void registerMinimapCreator();
+
+#endif

Added: antargis/branches/rant/ext/game/resource.cc
===================================================================
--- antargis/branches/rant/ext/game/resource.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/resource.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,66 @@
+#include &quot;resource.h&quot;
+
+
+// RESOURCE
+
+Resource::Resource()
+{
+}
+float Resource::get(const std::string &amp;pName)
+{
+  return r[pName];
+}
+void Resource::add(const std::string &amp;pName,float value)
+{
+  r[pName]+=value;
+}
+void Resource::sub(const std::string &amp;pName,float value)
+{
+  r[pName]=std::max(r[pName]-value,0.0f);
+}
+void Resource::set(const std::string &amp;pName,float value)
+{
+  r[pName]=value;
+}
+
+void Resource::takeAll(Resource &amp;pr)
+{
+  std::map&lt;std::string,float&gt;::iterator i=pr.r.begin();
+  for(;i!=pr.r.end();i++)
+    add(i-&gt;first,i-&gt;second);
+  pr.r.clear();
+}
+
+void Resource::take(Resource &amp;r,const std::string &amp;pName)
+{
+  add(pName,r.get(pName));
+  r.set(pName,0);
+}
+
+
+std::map&lt;std::string,float&gt; Resource::getAll() const
+{
+  return r;
+}
+
+
+void Resource::saveXML(Node &amp;node) const
+{
+  for(std::map&lt;std::string,float&gt;::const_iterator i=r.begin();i!=r.end();++i)
+    node.set(i-&gt;first,AGString(i-&gt;second));
+  
+}
+void Resource::loadXML(const Node &amp;node)
+{
+  Node::Attributes a=node.getAttributes();
+  for(Node::Attributes::iterator i=a.begin();i!=a.end();++i)
+    r[i-&gt;first]=i-&gt;second.toFloat();
+}
+
+bool Resource::empty() const
+{
+  for(std::map&lt;std::string,float&gt;::const_iterator i=r.begin();i!=r.end();++i)
+    if(i-&gt;second&gt;0)
+      return false;
+  return true;
+}

Added: antargis/branches/rant/ext/game/resource.h
===================================================================
--- antargis/branches/rant/ext/game/resource.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/resource.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,45 @@
+#ifndef RESOURCE_H
+#define RESOURCE_H
+
+#include &lt;map&gt;
+#include &lt;ag_xml.h&gt;
+
+
+
+/**
+   Resource manages resources with BoA. Every entity has some kind of &quot;bag&quot;, where
+   everything is stored. This is it. Resources are identified by strings.
+   You can get,set,sub and add resources.
+
+   
+FIXME: maybe remove Resource from c++??
+
+*/
+class Resource
+{
+  std::map&lt;std::string,float&gt; r;
+ public:
+  Resource();
+
+  void saveXML(Node &amp;node) const;
+  void loadXML(const Node &amp;node);
+
+  float get(const std::string &amp;pName);
+  void add(const std::string &amp;pName,float value);
+  void sub(const std::string &amp;pName,float value);
+  void set(const std::string &amp;pName,float value);
+
+  std::map&lt;std::string,float&gt; getAll() const;
+
+  /// take everything, that's in r and put it into &quot;this&quot;
+  void takeAll(Resource &amp;r);
+
+  /// take everything of type pname, that's in r and put it into &quot;this&quot;
+  void take(Resource &amp;r,const std::string &amp;pName);
+
+  /// check if the &quot;bag&quot; is empty
+  bool empty() const;
+};
+
+
+#endif

Added: antargis/branches/rant/ext/game/terrain.cc
===================================================================
--- antargis/branches/rant/ext/game/terrain.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/terrain.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,346 @@
+#include &quot;terrain.h&quot;
+#include &lt;ag_texturecache.h&gt;
+#include &lt;ag_rendercontext.h&gt;
+#include &lt;ag_profiler.h&gt;
+#include &lt;ag_config.h&gt;
+#include &lt;ag_vdebug.h&gt;
+
+static bool gUse3dTextures=true;
+void setUsing3dTextures(bool use3dTextures)
+{
+  gUse3dTextures=use3dTextures;
+}
+
+bool use3dTextures()
+{
+  return gUse3dTextures;
+}
+
+//////////////////////////////////////////////////////////////////////////
+// TerrainPiece
+//////////////////////////////////////////////////////////////////////////
+TerrainPiece::TerrainPiece(SceneBase *pScene,Terrain *t,HeightMap &amp;map,int xs,int ys,int w,int h,const AGVector4 &amp;pPos,int scale):
+  SceneNode(pScene,AGVector4(),AGBox3()),
+  mXs(xs),mYs(ys),mW(w),mH(h),
+  mMap(&amp;map)
+{
+  mScale=scale;
+  if(scale&gt;0)
+    {
+      mXs/=scale;
+      mYs/=scale;
+      mW/=scale;
+      mH/=scale;
+    }
+  mTerrain=t;
+  mapChanged();
+  setOrder(TERRAIN_Z);
+}
+
+TerrainPiece::~TerrainPiece()
+{
+  if(sceneValid())
+    getScene()-&gt;removeNode(this);
+}
+
+void TerrainPiece::mapChanged()
+{
+  AGBox3 bb=bbox();
+
+  // first check, if this piece was really affected
+  if(bb.valid())
+    {
+      AGRect2 r=AGRect2(AGVector2(bb.base[0]-2,bb.base[1]-2),AGVector2(bb.base[0]+bb.dir[0]+4,bb.base[1]+bb.dir[1]+4));  // add some border (2)
+
+      if(!r.collide(mMap-&gt;getChangeRect()))
+	{
+	  return;
+	}
+    }
+
+
+  bb=AGBox3();
+  m3dArray.clear();
+
+  AGVector4 white(1,1,1,1);
+  AGVector4 v;
+  AGVector3 n;
+  AGVector2 tp;
+  AGVector3 tp3;
+  float texFactor3w=0.5;
+
+  size_t stepping=1;
+
+
+  // add Vertices
+  size_t x,y;
+  for(x=mXs;x&lt;=mXs+mW;x+=stepping)
+    for(y=mYs;y&lt;=mYs+mH;y+=stepping)
+      {
+	int sx=x*mScale,sy=y*mScale;
+	v=mMap-&gt;getVertex(sx,sy);
+
+	n=mMap-&gt;getNormal(sx,sy);
+
+	if(use3dTextures())
+	  {
+	    float texHeight=mMap-&gt;getTerrainScale(sx,sy);
+	    
+	    tp3=AGVector3(-v[0]*texFactor3w,-v[1]*texFactor3w,texHeight);
+	    m3dArray.addVertex(v,white,n,tp3);
+	  }
+	else
+	  {
+	    tp=AGVector2(-v[0]*texFactor3w,-v[1]*texFactor3w);
+	    m3dArray.addVertex(v,white,n,tp);
+	  }
+
+
+	bb.include(v.dim3());
+      }
+
+  for(x=mXs;x&lt;mXs+mW;x+=stepping)
+    for(y=mYs;y&lt;mYs+mH;y+=stepping)
+      {
+	int p0=(x-mXs)/stepping+(y-mYs)/stepping*(mW/stepping+1);
+	int p1=p0+1;
+	int p2=p0+(mW/stepping+1);
+	int p3=p2+1;
+	if(((x+y)%2)==0)
+	  {
+	    m3dArray.addTriangle(p2,p1,p0);
+	    m3dArray.addTriangle(p3,p1,p2);
+
+	  }
+	else
+	  {
+	    m3dArray.addTriangle(p3,p1,p0);
+	    m3dArray.addTriangle(p3,p0,p2);
+	  }
+
+      }
+  setBBox(bb);
+}
+
+void TerrainPiece::drawShadow()
+{
+  STACKTRACE;
+  m3dArray.setColors(false);
+  m3dArray.draw();
+  m3dArray.setColors(true);
+}
+void TerrainPiece::drawDepth()
+{
+  return;
+  glDepthMask(true);
+  m3dArray.setColors(false);
+  m3dArray.draw();
+  m3dArray.setColors(true);
+}
+
+void TerrainPiece::drawPick()
+{
+  STACKTRACE;
+  //  cdebug(m3dArray.getTriangles());
+
+  m3dArray.drawPick();
+}
+
+
+void TerrainPiece::draw()
+{
+  assertGL;
+
+  STACKTRACE;
+  AGRenderContext c;
+  c.setLighting(true);
+  if(use3dTextures())
+    {
+      c.setTexture(mTerrain-&gt;get3dTexture()-&gt;glTexture());
+      mTerrain-&gt;get3dTexture()-&gt;setFilter(GL_LINEAR,GL_LINEAR);
+    }
+  else
+    c.setTexture(mTerrain-&gt;getGrassTexture()-&gt;glTexture());
+
+  c.begin();
+
+  m3dArray.draw();
+  assertGL;
+}
+
+
+AGVector4 TerrainPiece::lineHit(const AGLine3 &amp;pLine) const
+{
+  return m3dArray.lineHit(pLine);
+}
+
+size_t TerrainPiece::getTriangles() const
+{
+  return m3dArray.getTriangles();
+}
+
+int getTerrainTriangleSize()
+{
+  int s=1;
+
+  if(getConfig()-&gt;get(&quot;terrainTriangleSize&quot;)!=&quot;&quot;)
+    s=getConfig()-&gt;get(&quot;terrainTriangleSize&quot;).toInt();
+  
+  getConfig()-&gt;set(&quot;terrainTriangleSize&quot;,AGString(s));
+
+  return s;
+}
+
+
+int getTerrainDownScale()
+{
+  int s=1;
+
+  if(getConfig()-&gt;get(&quot;terrainDownScaleExp&quot;)!=&quot;&quot;)
+    s=getConfig()-&gt;get(&quot;terrainDownScaleExp&quot;).toInt();
+  
+  getConfig()-&gt;set(&quot;terrainDownScaleExp&quot;,AGString(s));
+
+  return s;
+}
+
+int getTerrainDownScaleZ()
+{
+  int s=1;
+
+  if(getConfig()-&gt;get(&quot;terrainDownScaleZExp&quot;)!=&quot;&quot;)
+    s=getConfig()-&gt;get(&quot;terrainDownScaleZExp&quot;).toInt();
+  
+  getConfig()-&gt;set(&quot;terrainDownScaleZExp&quot;,AGString(s));
+
+  return s;
+}
+
+////////////////////////////////////////////////////////////////////////////
+// TerrainBase
+////////////////////////////////////////////////////////////////////////////
+
+
+TerrainBase::TerrainBase(SceneBase *pScene,HeightMap &amp;map):
+  mMap(&amp;map),mScene(pScene)
+{
+  map.sigMapChanged.connect(slot(this,&amp;TerrainBase::slotMapChanged));
+  map.sigMapChangedComplete.connect(slot(this,&amp;TerrainBase::slotMapChangedComplete));
+}
+
+TerrainBase::~TerrainBase()
+{
+}
+
+bool TerrainBase::slotMapChanged(AGEvent *e)
+{
+  mapChanged();
+  return false;
+}
+bool TerrainBase::slotMapChangedComplete(AGEvent *e)
+{
+  mapChangedComplete();
+  return false;
+}
+
+
+SceneBase *TerrainBase::getScene()
+{
+  return mScene;
+}
+
+HeightMap *TerrainBase::getMap()
+{
+  return mMap;
+}
+
+void TerrainBase::mapChanged()
+{
+}
+
+void TerrainBase::mapChangedComplete()
+{
+}
+
+
+////////////////////////////////////////////////////////////////////////////
+// Terrain
+////////////////////////////////////////////////////////////////////////////
+
+Terrain::Terrain(SceneBase *pScene,HeightMap &amp;map):
+  TerrainBase(pScene,map),
+  m3D(getTextureCache()-&gt;get3D(&quot;data/textures/terrain/new3d.png&quot;,getTerrainDownScale(),getTerrainDownScaleZ())),
+  mGrass(getTextureCache()-&gt;get(&quot;data/textures/terrain/grass4.png&quot;))
+{
+  init();
+
+}
+
+void Terrain::init()
+{
+  size_t y,x;
+  int tilesize=16;
+  size_t tiles=0;
+
+  HeightMap *map=getMap();
+
+  for(y=0; y&lt;map-&gt;getH();y+=tilesize)
+    for(x=0;x&lt;map-&gt;getW();x+=tilesize)
+      {
+	TerrainPiece *t=new TerrainPiece(getScene(),this,*map,x,y,tilesize,tilesize,AGVector4(x,y,0,0),getTerrainTriangleSize());
+	WaterPiece *w=new WaterPiece(getScene(),*map,x,y,tilesize,tilesize,AGVector4(x,y,0,0));
+	pieces.push_front(t); // at least it's correct at the beginning
+	water.push_front(w);
+	mNodes.push_back(w);
+	mNodes.push_back(t);
+	tiles++;
+      }
+
+  w=map-&gt;getW();
+  h=map-&gt;getH();
+}
+
+void Terrain::mapChangedComplete()
+{
+  for(Pieces::iterator i=pieces.begin();i!=pieces.end();i++)
+    delete *i;
+  for(WPieces::iterator i=water.begin();i!=water.end();i++)
+    delete *i;
+
+  pieces.clear();
+  water.clear();
+  mNodes.clear();
+
+
+  init();
+}
+
+
+Terrain::~Terrain()
+{
+  for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
+    saveDelete(*i);
+}
+
+void Terrain::mapChanged()
+{
+  for(Pieces::iterator i=pieces.begin();i!=pieces.end();i++)
+    {
+      (*i)-&gt;mapChanged();
+    }
+  for(WPieces::iterator i=water.begin();i!=water.end();i++)
+    {
+      (*i)-&gt;mapChanged();
+    }
+}
+
+AGTexture *Terrain::get3dTexture()
+{
+  return &amp;m3D;
+}
+
+AGTexture *Terrain::getGrassTexture()
+{
+  return &mGrass;
+}
+

Added: antargis/branches/rant/ext/game/terrain.h
===================================================================
--- antargis/branches/rant/ext/game/terrain.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/terrain.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,132 @@
+#ifndef __antargis_gl_terrain_h
+#define __antargis_gl_terrain_h
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &lt;vector&gt;
+
+#include &quot;scene.h&quot;
+#include &quot;ag_geometry.h&quot;
+#include &lt;ag_surface.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;vertex_array.h&quot;
+#include &quot;water.h&quot;
+
+#include &lt;ag_xml.h&gt;
+
+#include &quot;map.h&quot;
+
+using namespace std;
+
+class Terrain;
+
+/**
+   TerrainPiece displays (like WaterPiece) some small patch of terrain.
+   (Terrain and water is tiled for the ease of culling)
+   for more information on drawing-modes and such go to SceneNode.
+ */
+class TerrainPiece:public SceneNode
+{
+ public:
+  TerrainPiece(SceneBase *pScene,Terrain *t,HeightMap &amp;map,int x,int y,int w,int h,const AGVector4 &amp;pPos,int scale);
+  virtual ~TerrainPiece();
+
+  void draw();
+  void drawShadow();
+  void drawDepth();
+  void drawPick();
+
+  // returns (0,0,0,0) if no collision
+  // returns (x,y,z,1) if collision takes place
+  AGVector4 lineHit(const AGLine3 &amp;pLine) const;
+  size_t getTriangles() const;
+
+  /// rebuilds the mesh
+  virtual void mapChanged();
+  
+ private:
+
+  Terrain *mTerrain;
+
+  size_t mXs,mYs;
+  size_t mW,mH;
+  int mScale;
+  HeightMap *mMap;
+
+  VertexArray m3dArray;
+};
+
+
+class TerrainBase:public AGRubyObject
+{
+ public:
+  TerrainBase(SceneBase *pScene,HeightMap &amp;map);
+  virtual ~TerrainBase();
+
+  HeightMap *getMap();
+  SceneBase *getScene();
+
+  /// some parts of the map are changed
+  virtual void mapChanged();
+  /// the whole map is changed - so better take care of this (texture-upload instead of repainting on GPU)
+  virtual void mapChangedComplete();
+
+
+  virtual bool slotMapChanged(AGEvent *e);
+  virtual bool slotMapChangedComplete(AGEvent *e);
+
+
+ private:
+  /// the height-map
+  HeightMap *mMap;
+  
+  SceneBase *mScene;
+};
+
+/**
+   In a game-world there exists exactly one Terrain-object.
+   This object holds references to all water- and terrain-pieces, so
+   that in case the terrain changes these will be changed,too.
+
+*/
+class Terrain:public TerrainBase
+{
+  // Some containers for all the meshes
+  typedef std::list&lt;TerrainPiece*&gt; Pieces;
+  typedef std::list&lt;WaterPiece*&gt; WPieces;
+  typedef std::list&lt;SceneNode*&gt; Nodes;
+  Nodes mNodes;
+  Pieces pieces;
+  WPieces water;
+
+  float w,h;
+
+  /// 3d-texture used for the terrain
+  AGTexture m3D;
+
+  /// some (currently not used) grass-texture
+  AGTexture mGrass;
+
+
+public:
+  Terrain(SceneBase *pScene,HeightMap &amp;map);
+
+  virtual ~Terrain();
+
+  AGTexture *get3dTexture();
+  AGTexture *getGrassTexture();
+
+  /// some parts of the map are changed
+  virtual void mapChanged();
+  /// the whole map is changed - so better take care of this (texture-upload instead of repainting on GPU)
+  virtual void mapChangedComplete();
+
+ private:
+  void init();
+};
+
+void setUsing3dTextures(bool use3dTextures);
+
+
+#endif

Added: antargis/branches/rant/ext/game/water.cc
===================================================================
--- antargis/branches/rant/ext/game/water.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/water.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,148 @@
+#include &quot;water.h&quot;
+#include &quot;ag_vdebug.h&quot;
+#include &quot;ag_kill.h&quot;
+#include &quot;ag_rendercontext.h&quot;
+#include &quot;ag_profiler.h&quot;
+#include &quot;ag_config.h&quot;
+
+AntWaterShader *gWaterShader=0;
+AntWaterShader *getWaterShader()
+{
+  if(!gWaterShader)
+    {
+      gWaterShader=new AntWaterShader;
+      REGISTER_SINGLETON(gWaterShader);
+    }
+  assert(gWaterShader);
+  return gWaterShader;
+}
+
+static int gWaterAnim=-10;
+bool useWaterAnimation()
+{
+  if(gWaterAnim==-10)
+    {
+      gWaterAnim=getConfig()-&gt;get(&quot;animationType&quot;)!=&quot;false&quot;;
+    }
+  return gWaterAnim;
+}
+
+
+WaterPiece::WaterPiece(SceneBase *pScene,HeightMap &amp;map,int x,int y,int w,int h,const AGVector4 &amp;pos):
+  SceneNode(pScene,pos,AGBox3()),
+  mX(x),mY(y),mW(w),mH(h),mMap(&amp;map)
+{
+  step=2;
+  tex=getTextureCache()-&gt;get(&quot;data/textures/terrain/water.png&quot;);
+
+  //  mShader=new AntWaterShader;
+
+  mapChanged();
+  setOrder(WATER_Z);
+}
+
+
+WaterPiece::~WaterPiece()
+{
+  if(sceneValid())
+    getScene()-&gt;removeNode(this);
+
+}
+
+void WaterPiece::mapChanged()
+{
+  AGBox3 bb;
+  mArray.clear();
+
+  setVisible(false);
+  bool vis=false;
+  int x,y;
+  int step=2;
+  for(x=0;x&lt;mW+step;x+=step)
+    for(y=0;y&lt;mH+step;y+=step)
+      {
+	AGVector4 p(x,y,0);
+	p+=getPos();
+	AGVector4 c(1,1,1,0.7);
+	AGVector3 n(0,0,1);
+	AGVector2 t(x,y);
+	
+	mArray.addVertex(p,c,n,t);
+
+	bb.include(p.dim3()-AGVector3(0,0,1));
+	bb.include(p.dim3()+AGVector3(0,0,1));
+
+	if(mMap-&gt;get(mX+x,mY+y)&lt;0.1 &amp;&amp; !vis)
+	  {
+	    vis=true;
+	  }
+      }
+  setBBox(bb-getPos().dim3());
+
+  for(x=0;x&lt;mW/step;x++)
+    for(y=0;y&lt;mH/step;y++)
+      {
+	addTriangle(x,y, x+1,y, x,y+1);
+
+	addTriangle(x+1,y, x+1,y+1, x,y+1);
+      }
+
+  if(vis)
+    setVisible(true);
+}
+
+void WaterPiece::addTriangle(int x0,int y0,int x1,int y1,int x2, int y2)
+{
+  int w=(mW/step)+1;
+  mArray.addTriangle(x2+y2*w,x1+y1*w,x0+y0*w);
+}
+
+void WaterPiece::draw()
+{
+  STACKTRACE;
+  assertGL;
+
+  AGRenderContext c;
+  c.setAlpha(0,GL_NONE);
+  c.setCulling(false);
+  c.setTexture(tex.glTexture());
+  //  tex.setClamp(GL_REPEAT,GL_REPEAT,GL_REPEAT);//CLAMP_TO_EDGE);
+  //  c.setColor(AGVector4(0,0,1,1));
+  c.begin();
+
+  glDisable(GL_COLOR_MATERIAL);
+  glDisable(GL_CULL_FACE);
+  glDisable(GL_ALPHA_TEST);
+  glColor4f(1,1,1,1);
+  if(useWaterAnimation())
+    getWaterShader()-&gt;enable();
+  mArray.draw();
+  if(useWaterAnimation())
+    getWaterShader()-&gt;disable();
+  assertGL;
+}
+
+void WaterPiece::drawPick()
+{
+  STACKTRACE;
+  //cdebug(mArray.getTriangles());
+  //  mArray.drawPick();
+}
+
+void WaterPiece::advance(float t)
+{
+  assertGL;
+  getWaterShader()-&gt;update(t);
+  assertGL;
+}
+
+size_t WaterPiece::getTriangles() const
+{
+  return mArray.getTriangles();
+}
+
+bool WaterPiece::transparent()
+{
+  return true;
+}
+

Added: antargis/branches/rant/ext/game/water.h
===================================================================
--- antargis/branches/rant/ext/game/water.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/water.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,56 @@
+#ifndef __antargis_gl_water_h
+#define __antargis_gl_water_h
+
+#include &quot;glsl.h&quot;
+#include &quot;scene.h&quot;
+#include &quot;ag_texturecache.h&quot;
+#include &quot;ag_geometry.h&quot;
+#include &quot;ag_texture.h&quot;
+#include &quot;vertex_array.h&quot;
+#include &quot;map.h&quot;
+#include &lt;math.h&gt;
+
+class AntWaterShader;
+
+/**
+   A waterpiece is a scenenode, that displays some small patch of water. Water has
+   currently always the same height (==0).
+   The water is rendered with a VertexArray-object and is able to use some minor vertex shading
+   for animation.
+   In future some fragment shader using fresnel effects would be nice :-)
+*/
+class WaterPiece:public SceneNode
+{
+  AGTexture tex;
+ public:
+  WaterPiece(SceneBase *pScene,HeightMap &amp;map,int x,int y,int w,int h,const AGVector4 &amp;pos);
+  virtual ~WaterPiece();
+
+  /// draw in normal mode
+  void draw();
+  /// draw for picking (without shader)
+  void drawPick();
+
+  /// advance animation
+  void advance(float t);
+  size_t getTriangles() const;
+  bool transparent();
+
+  /// check for visibility, set bounding box and update vertex-array
+  virtual void mapChanged();
+
+ private:
+  void addTriangle(int x0,int y0,int x1,int y1,int x2, int y2);
+
+ private:
+  VertexArray mArray;
+  int mX;
+  int mY;
+  int mW;
+  int mH;
+  HeightMap *mMap;
+  int step;
+  AntWaterShader *mShader;
+};
+#endif
+

Added: antargis/branches/rant/ext/gui/ag_application.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_application.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_application.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,577 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_application.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_application.h&quot;
+#include &quot;ag_main.h&quot;
+#include &quot;ag_screen.h&quot;
+#include &quot;ag_glscreen.h&quot;
+#include &quot;ag_main.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_mixer.h&quot;
+#include &quot;ag_texturecache.h&quot;
+#include &quot;ag_profiler.h&quot;
+#include &quot;ag_clip_painttarget.h&quot;
+#include &quot;ag_video.h&quot;
+
+#include &lt;ruby.h&gt;
+
+void disableKeyrepeat()
+{
+  SDL_EnableKeyRepeat(0,0);
+}
+
+AGApplication *gApplication=0;
+
+AGVector2 gAppCursorPos;
+
+AGApplication *getApplication()
+{
+  return gApplication;
+}
+
+
+AGApplication::AGApplication():mRunning(true),mIdleCalls(true),mainWidget(0),mTooltip(0),mOverlay(0)
+{
+  SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY,SDL_DEFAULT_REPEAT_INTERVAL);
+  if(videoInited())
+    {
+      setCursor(getTextureCache()-&gt;get(&quot;blue_cursor.png&quot;));
+      setNormalCursor();
+    }
+  mDemoTime=-1;
+}
+
+AGApplication::~AGApplication()
+{
+  CTRACE;
+  delete mCursor;
+}
+
+void AGApplication::setKeyRepeat(bool enable)
+{
+  if(enable)
+    SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY,SDL_DEFAULT_REPEAT_INTERVAL);
+  else
+    SDL_EnableKeyRepeat(0,0);
+}
+
+
+void AGApplication::setMainWidget(AGWidget *w)
+{
+  mainWidget=w;
+  setOverlay(0);
+  if(w)
+    w-&gt;redraw();
+}
+
+AGWidget *AGApplication::getMainWidget()
+{
+  return mainWidget;
+}
+
+/**
+ * \brief the main-loop of each application
+ *
+ * Each program has one or more application-objects.
+ * An application normally represents a single UI-screen. So it has
+ */
+
+bool AGApplication::run() 
+{
+  STACKTRACE; 
+  Uint32 last,now;
+  SDL_Event event;
+  float t;
+  mRunning=true;
+
+  gApplication=this;
+  
+  flushEventQueue();
+  last=now=SDL_GetTicks();
+
+  size_t loopCount=0;
+  
+  while(mRunning)
+    {
+      STACKTRACE; 
+      
+      gApplication=this;
+
+      {
+	// event handling
+	STACKTRACE;
+	// check for finished music
+	getMain()-&gt;repeatedCalls();
+	//	getSoundManager()-&gt;checkFinished();
+	
+	now=SDL_GetTicks();
+	/*
+	// pull motion events (may flood the eventqueue)
+		while(SDL_PeepEvents(&amp;event, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) &gt; 0)
+	  ;
+	*/
+	clearOldMousePosition();
+	dbout(2,&quot;loop pre-event:&quot;&lt;&lt;loopCount);
+	event=getNewEvent();
+	if(eventOk(event))
+	  {
+	    do
+	      {
+		dbout(2,&quot;eventok  &quot;&lt;&lt;toString(&amp;event));
+		doEvent(event);
+		if(mIdleCalls)
+		  {
+		    dbout(2,&quot;getNewEvent...  (idlecalls:&quot;&lt;&lt;mIdleCalls&lt;&lt;&quot;)&quot;);
+		    event=getNewEvent();
+		  }
+		else
+		  resetEvent(event);
+	      }while(eventOk(event));
+	  } 
+	dbout(2,&quot;loop post-event:&quot;&lt;&lt;loopCount);
+	/*
+	if(mIdleCalls) 
+	  {
+	    if (SDL_PollEvent(&amp;event) == 0) 
+	      eventIdle();
+	    else
+	      {
+		do
+		  {
+		    doEvent(&amp;event);
+		  }while(SDL_PollEvent(&amp;event)!=0);
+	      }
+	    
+	  } 
+	else 
+	  {
+	    SDL_WaitEvent(&amp;event);
+	    doEvent(&amp;event);
+	    }*/
+
+	if(mDemoTime&gt;=0)
+	  {
+	    t=mDemoTime;
+	    mDemoTime=-1;
+	    dbout(2,&quot;demo time:&quot;&lt;&lt;t);
+	  }
+	else
+	  {
+	    t=(now-last)/1000.0;
+	  }
+	if(mainWidget)
+	  mainWidget-&gt;sigTick(t);
+	
+	dbout(2,&quot;frame events:&quot;&lt;&lt;t);
+	eventPrepareFrame(t);
+
+	eventFrame(t);
+      }
+      {
+	// drawing
+	STACKTRACE;
+	{
+	  STACKTRACE;
+	  prepareDraw();
+	}
+	{
+	  STACKTRACE;
+	  draw();
+	}
+      }
+      
+      eventFrameEnd(t);
+      last=now;
+
+      loopCount++;
+      dbout(2,&quot;Running:&quot;&lt;&lt;mRunning);
+    }
+  gApplication=0;
+
+  return true;
+}
+
+void AGApplication::setDemoTime(float t)
+{
+  dbout(2,&quot;demoTime:&quot;&lt;&lt;t);
+  mDemoTime=t;
+}
+
+
+SDL_Event AGApplication::getNewEvent()
+{
+  SDL_Event mEvent;
+  resetEvent(mEvent);
+  // pull motion events (may flood the eventqueue)
+  while(SDL_PeepEvents(&amp;mEvent, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) &gt; 0)
+    ;
+  
+  if(mIdleCalls) 
+    {
+      if (SDL_PollEvent(&amp;mEvent) == 0) 
+	{
+	  resetEvent(mEvent);
+	  return mEvent;
+	}
+    } 
+  else 
+    SDL_WaitEvent(&amp;mEvent);
+  return mEvent;
+}
+
+
+
+bool AGApplication::doEvent(const SDL_Event &amp;event) 
+{
+  STACKTRACE;
+  SDL_Event e;
+  
+  // eat up old mouse motion events
+  while(SDL_PeepEvents(&amp;e, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) &gt; 0);
+  
+  AGEvent *message=newEvent(this,&quot;&quot;,event);
+  bool processed=false;
+  if(mOverlay)
+    processed=mOverlay-&gt;processEvent(message);
+
+  if(!processed)
+    {
+      if(!processed &amp;&amp; mainWidget)
+	processed=mainWidget-&gt;processEvent(message);
+
+      if(!processed)
+	processed=processEvent(message);
+    }
+  
+  delete message;
+  return processed;
+}
+
+void AGApplication::clearOldMousePosition()
+{
+}
+void AGApplication::drawCursor()
+{
+  if(!videoInited())
+    return;
+  AGPainter p;
+  if(mCursor)
+    {
+      mCursorOld=AGRect2(gAppCursorPos[0],gAppCursorPos[1],mCursor-&gt;width(),mCursor-&gt;height());
+      p.blit(*mCursor,mCursorOld);
+    }
+
+}
+
+void AGApplication::flushEventQueue()
+{
+}
+ 
+bool AGApplication::eventQuit(AGEvent *m)
+{
+  CTRACE;
+  mRunning=false;
+  return false;
+}
+
+bool AGApplication::eventIdle()
+{
+  return false;
+}
+
+
+/**
+   \brief prepares the actual drawing process
+
+   prepareDraw runs prepareDraw for the main-widget, which itself runs
+   prepareDraw recursively. This functions are meant to prepare possible
+   texture contents and other things, that might be updated in each frame.
+*/
+void AGApplication::prepareDraw()
+{
+  STACKTRACE; 
+
+  if(mainWidget)
+    {
+      mainWidget-&gt;prepareDrawAll();
+      mainWidget-&gt;useTexturesRecursive();
+    }
+  if(mOverlay)
+    mOverlay-&gt;prepareDrawAll();
+}  
+
+
+AGWidget *pLastDrawn=0;
+
+/**
+ * \brief query redraw
+ *
+ * Queries a complete screen redraw. This makes sense in SDL-mode only.
+ * There a dirty rectangle kind of painting is used.
+ */
+
+void AGApplication::redraw()
+{
+  pLastDrawn=0;
+
+  if(mainWidget)
+    mainWidget-&gt;redraw();
+}
+
+/**
+ * \brief calls the draw-function of the main-widget
+
+ * AGApplication::draw() calls the draw-function of the mainWidget and cares
+ * about drawing a custom mouse-cursor, the tooltip and possible overlays.
+ * At the end the screen-buffer is flipped.
+ */
+
+void AGApplication::draw()
+{
+  CTRACE;
+  if(delCue.size()&gt;0)
+    {
+      for(std::list&lt;AGWidget*&gt;::iterator i=delCue.begin();i!=delCue.end();i++)
+	if(*i)
+	  saveDelete(*i);
+      delCue.clear();
+    }
+
+  if(!videoInited())
+    return;
+
+  bool oldClippingTechnique=false;
+  AGClipping clip;
+
+  STACKTRACE;
+  beginRender();
+
+  cdebug(&quot;mainWidget:&quot;&lt;&lt;mainWidget);
+  if(mainWidget)
+    {
+      getScreen().begin();
+      
+      AGPainter *p;
+      AGClipPaintTarget paintTarget(&amp;getScreen());
+
+      if(opengl())
+	p=new AGPainter(getScreen());
+      else
+	p=new AGPainter(paintTarget);
+
+      clip.exclude(mainWidget-&gt;getScreenRect());
+      if(pLastDrawn==mainWidget &amp;&amp; !opengl())
+	{
+	  if(oldClippingTechnique)
+	    {
+	      AGRect2 r=mainWidget-&gt;getChangeRect();
+	      if(mCursor)
+		r+=mCursorOld;
+	      
+	      p-&gt;clip(r);
+	    }
+	  else
+	    {
+	      // FIXME: do some advanced clipping
+	      mainWidget-&gt;acquireClipping(clip);
+	    }
+	}
+      else
+	{
+	  clip.include(mainWidget-&gt;getScreenRect());
+	}
+
+      cdebug(&quot;CLIP:&quot;&lt;&lt;clip.toString());
+      paintTarget.clip(clip);
+      mainWidget-&gt;drawAll(*p);
+
+      if(mTooltip)
+	{
+	  AGPainter p;
+	  mTooltip-&gt;drawAll(p);
+	}
+      if(mOverlay)
+	{
+	  AGPainter p;
+	  mOverlay-&gt;drawAll(p);
+	}
+
+      pLastDrawn=mainWidget;
+
+      delete p;
+    }
+  else
+    cdebug(&quot;no mainwidget&quot;);
+  drawCursor();
+
+  std::list&lt;AGRect2&gt; changeList;
+  if(mainWidget)
+    {
+      changeList=mainWidget-&gt;aquireChanges();
+      mainWidget-&gt;clearChangeRects();
+    }
+  if(opengl())// || true)
+    getScreen().flip();
+  else
+    {
+      std::vector&lt;AGRect2&gt; changeV=clip.clip(mainWidget-&gt;getScreenRect());
+      changeList.clear();
+      std::copy(changeV.begin(),changeV.end(),std::back_inserter(changeList));
+      getScreen().update(changeList);
+    }
+
+  endRender();
+  cdebug(&quot;end render&quot;);
+}
+
+/**
+ * \brief quit the application
+ *
+ * This sets the private mRunning to false. One might add a function, that
+ * checks if quitting is ok or reset mRunning to true. But this is not yet
+ * part of AGApplication.
+ */
+
+void AGApplication::tryQuit()
+{
+  CTRACE;
+  mRunning=false;
+}
+
+bool AGApplication::eventKeyDown(AGEvent *m)
+{
+  if(m-&gt;isSDLEvent())
+    {
+      SDLKey k=m-&gt;getKey();
+      SDLMod mod=m-&gt;getMod();
+
+      if(k==SDLK_RETURN &amp;&amp; ((mod&amp;KMOD_LALT)||(mod&amp;KMOD_RALT)))
+	{
+	  getVideo()-&gt;toggleFull();
+	  eventChangedRes();
+	  redraw();
+	}
+      else if(k==SDLK_F10)
+	tryQuit();
+    }
+  return false;
+}
+
+void AGApplication::eventChangedRes()
+{
+}
+
+bool AGApplication::eventPrepareFrame(float pTime)
+{
+  return false;
+}
+
+
+bool AGApplication::eventFrame(float pTime)
+{
+  return false;
+}
+bool AGApplication::eventFrameEnd(float pTime)
+{
+  return false;
+}
+
+long AGApplication::getTicks() const
+{
+  return SDL_GetTicks();
+}
+
+/// delays execution for ms milliseconds. This can be used to decrease framerate and cpu-load.
+void AGApplication::delay(int ms)
+{
+  dbout(2,&quot;delay:&quot;&lt;&lt;ms);
+  SDL_Delay(ms);
+}
+
+
+/// mark my mainWidget and my tooltip, as they can be ruby-objects
+void AGApplication::mark()
+{
+  //  CTRACE;
+  if(mainWidget)
+    markObject(mainWidget);
+  if(mTooltip)
+    markObject(mTooltip);
+}
+
+/// this function sets the current tooltip, which is display above all widgets
+void AGApplication::setTooltip(AGTooltip *pTooltip)
+{
+  delete mTooltip;
+  mTooltip=pTooltip;
+    
+}
+
+/// this functions resets the tooltip pTooltip.
+/// @param pTooltip a tooltip of a widget
+void AGApplication::resetTooltip(AGTooltip *pTooltip)
+{
+  if(pTooltip==mTooltip)
+    {
+      delete mTooltip;
+      mTooltip=0;
+    }
+}
+
+AGWidget *AGApplication::getOverlay()
+{
+  return mOverlay;
+}
+
+
+void AGApplication::setOverlay(AGWidget *pOverlay)
+{
+  CTRACE;
+  if(mOverlay)
+    delCue.push_back(mOverlay);
+  mOverlay=pOverlay;
+}
+
+
+bool AGApplication::eventMouseMotion(AGEvent *m)
+{
+  gAppCursorPos=m-&gt;getMousePosition();
+  return AGMessageObject::eventMouseMotion(m);
+}
+
+/// this function disables hardware cursor and shows software-cursor instead
+void AGApplication::setCursor(const AGTexture &amp;pTexture)
+{
+  mCursor=new AGTexture(pTexture);
+  SDL_ShowCursor(0);
+}
+
+/// this function enables hardware-cursor
+void AGApplication::setNormalCursor()
+{
+  SDL_ShowCursor(1);
+  delete mCursor;
+  mCursor=0;
+}
+
+bool AGApplication::hardwareCursor() const
+{
+  return mCursor==0;
+}

Added: antargis/branches/rant/ext/gui/ag_application.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_application.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_application.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_application.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_APPLICATION_H
+#define AG_APPLICATION_H
+
+#include &lt;ag_messageobject.h&gt;
+#include &lt;ag_widget.h&gt;
+#include &lt;ag_tooltip.h&gt;
+#include &lt;ag_texture.h&gt;
+
+/**
+   \defgroup application Application
+*/
+
+
+/**
+   \brief Base class for application - holds the main loop
+   \ingroup application
+
+  Use AGApplication as base class your application's class.
+  In this library it's assumed that you have different parts of your program, that
+  are really different. Each of these parts has its own AGApplication.
+  The actual control of these applications is done through a main-loop, that
+  queries new events from libSDL and gives them to the correct widgets.
+  This main-loop can by started by run(). After this your have some possibilities to access
+  control. FOr instance there are the different event* functions, which you can override in
+  an AGApplication's subclass.
+
+  If you want to quit this application call tryQuit().
+
+  Each AGApplication has a single main-widget, which is drawn in every frame.
+  Set it by calling setMainWidget().
+
+  The typical usage looks like this:
+  &lt;pre&gt;
+  class MyApp:public AGApplication
+  {
+    public:
+    bool eventFrame(float t)
+    {
+      std::cout&lt;&lt;&quot;In this frame &quot;&lt;&lt;t&lt;&lt;&quot; seconds have passed.&quot;&lt;&lt;std::endl;
+    }
+  };
+
+  int main()
+  {
+    // here you have to init the video mode
+    AGMain main;
+    main.initVideo(800,600,32,false,false);
+
+    // the actual example
+    MyApp app;
+    app.run();
+    return 0;
+  }
+  &lt;/pre&gt;
+*/
+class AGApplication:public AGMessageObject
+{
+ public:
+  AGApplication();
+  virtual ~AGApplication();
+
+  bool run();
+
+  /// called in each frame when idling
+  virtual bool eventIdle();           
+
+  virtual bool eventPrepareFrame(float pTime);
+
+  /// called between event-handling and drawing
+  virtual bool eventFrame(float pTime);
+  /// called after drawing - so before event handling
+  virtual bool eventFrameEnd(float pTime);
+
+
+  virtual bool eventQuit(AGEvent *m);
+  virtual bool eventKeyDown(AGEvent *m2);
+  virtual bool eventMouseMotion(AGEvent *m);
+
+  virtual void eventChangedRes();
+
+  void setMainWidget(AGWidget *w);
+  AGWidget *getMainWidget();
+
+  virtual void draw();
+  virtual void prepareDraw();
+
+  void redraw();
+
+  virtual void tryQuit();
+
+  long getTicks() const;
+  void delay(int ms);
+
+  void setTooltip(AGTooltip *pTooltip); // transfers ownage !
+  void resetTooltip(AGTooltip *pTooltip); // try to reset this one
+
+  void setOverlay(AGWidget *pOverlay);
+  AGWidget *getOverlay();
+
+  void setCursor(const AGTexture &amp;pTexture);
+  void setNormalCursor();
+  bool hardwareCursor() const;
+
+  virtual SDL_Event getNewEvent();
+
+  void setKeyRepeat(bool enable);
+
+  void setDemoTime(float t);
+  
+ private:
+  void clearOldMousePosition();
+  void drawCursor();
+
+  void flushEventQueue();
+  bool doEvent(const SDL_Event &amp;e);
+
+  bool mRunning;
+  bool mIdleCalls;
+  AGWidget *mainWidget;
+  AGTooltip *mTooltip;
+
+  AGWidget *mOverlay;
+
+  AGTexture *mCursor;
+  AGRect2 mCursorOld;
+
+  std::list&lt;AGWidget*&gt; delCue;
+
+  SDL_Event mEvent;
+
+  float mDemoTime;
+
+ public:
+  void mark();
+};
+
+/**
+   getApplication returns the current active application.
+   This gets set on each iteration of AGApplication::run. 
+   So it will be correct after finishing a frame, when you are
+   using nested AGApplications.
+*/
+AGApplication *getApplication(); // returns current active application
+
+void disableKeyrepeat();
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_background.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_background.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_background.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_background.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_background.h&quot;
+#include &quot;ag_draw.h&quot;
+#include &quot;ag_theme.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_painter.h&quot;
+#include &quot;ag_texturecache.h&quot;
+
+/** sets a uniform background of color pColor
+    @param pColor an rgba-color. so you can use transparent backgrounds,too.
+*/
+AGBackground::AGBackground(const AGColor &amp;pColor):mTexture(0)
+{
+  //  CTRACE;
+  mColor=true;
+  mColors[0]=pColor;
+  mColors[1]=pColor;
+  mColors[2]=pColor;
+  mColors[3]=pColor;
+  mBorder=0;
+}
+
+
+/**
+   This constructor set a themed background.
+   @param pThemeName a typical string is &quot;button.background.normal&quot;. Then the entry in the theme.xml file should look something like:
+&lt;pre&gt;
+ &lt;button&gt;
+   &lt;background&gt;
+     &lt;normal&gt;
+       &lt;color name='gradientColor1' color='#12141c'/&gt;
+       &lt;color name='gradientColor2' color='#12141c'/&gt;
+       &lt;color name='gradientColor3' color='#12141c'/&gt;
+       &lt;color name='gradientColor4' color='#12141c'/&gt;
+     &lt;/normal&gt;
+   &lt;/background&gt;
+  &lt;/button&gt;
+&lt;/pre&gt;
+*/
+
+AGBackground::AGBackground(const AGString &amp;pThemeName):mTexture(0)
+{
+  //  CTRACE;
+
+  AGTheme *theme=getTheme();
+  mColor=false;
+  if(theme-&gt;hasSurface(pThemeName+&quot;.image&quot;))
+    {
+      //      CTRACE;
+      cdebug(pThemeName+&quot;.image&quot;);
+      mTexture=&amp;getTextureCache()-&gt;get(getTheme()-&gt;getSurfaceName(pThemeName+&quot;.image&quot;));
+      //mTexture=new AGTexture(theme-&gt;getSurface(pThemeName+&quot;.image&quot;));
+    }
+  else if(theme-&gt;hasColor(pThemeName+&quot;.&quot;+&quot;gradientColor1&quot;))
+    {
+      mColor=true;
+      mColors[0]=theme-&gt;getColor(pThemeName+&quot;.&quot;+&quot;gradientColor1&quot;);
+      mColors[1]=theme-&gt;getColor(pThemeName+&quot;.&quot;+&quot;gradientColor2&quot;);
+      mColors[2]=theme-&gt;getColor(pThemeName+&quot;.&quot;+&quot;gradientColor3&quot;);
+      mColors[3]=theme-&gt;getColor(pThemeName+&quot;.&quot;+&quot;gradientColor4&quot;);
+    }
+
+  mBorder=theme-&gt;getInt(pThemeName+&quot;.&quot;+&quot;border&quot;);
+}
+
+/*
+AGBackground::AGBackground(const AGBackground &amp;p):mTexture(0)
+{
+  if(p.mTexture)
+    mTexture=new AGTexture(*p.mTexture);
+  mColors[0]=p.mColors[0];
+  mColors[1]=p.mColors[1];
+  mColors[2]=p.mColors[2];
+  mColors[3]=p.mColors[3];
+
+  mColor=p.mColor;
+  mBorder=p.mBorder;
+}
+
+AGBackground::~AGBackground()
+{
+  delete mTexture;
+  }*/
+
+
+/// draws the background on painter in the given rectangle
+void AGBackground::draw(const AGRect2 &amp;r,AGPainter &amp;p)
+{
+  if(mTexture)
+    {
+      p.tile(*mTexture,r.shrink(mBorder));
+    }
+  else if(mColor)
+    p.drawGradient(r.shrink(mBorder),mColors[0],mColors[1],mColors[2],mColors[3]);
+ 
+}
+
+/// this is a help function, so that once made textures aren't automatically discarded.
+void AGBackground::useTextures()
+{
+  if(mTexture)
+    const_cast&lt;AGTexture*&gt;(mTexture)-&gt;useTexture();
+}

Added: antargis/branches/rant/ext/gui/ag_background.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_background.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_background.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_background.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_BACKGROUND_H
+#define AG_BACKGROUND_H
+
+#include &lt;string&gt;
+#include &quot;ag_geometry.h&quot;
+#include &quot;ag_texture.h&quot;
+#include &quot;ag_color.h&quot;
+
+class AGPainter;
+
+/** AGBackground is a helper class for widget-drawing
+    It is used to draw gradients and tiled backgrounds of widgets.
+    It is themable.
+ */
+class AGBackground
+{
+ public:
+  AGBackground(const AGString &amp;pThemeName=&quot;&quot;);
+  AGBackground(const AGColor &amp;pColor);
+  //  AGBackground(const AGBackground &amp;pBackground);
+  //  ~AGBackground();
+
+  void draw(const AGRect2 &amp;r,AGPainter &amp;p);
+
+  void useTextures();
+ private:
+  const AGTexture *mTexture;
+  AGColor mColors[4];
+
+  bool mColor;
+  int mBorder;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_border.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_border.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_border.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_border.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_border.h&quot;
+#include &quot;ag_painter.h&quot;
+#include &quot;ag_theme.h&quot;
+#include &quot;ag_texturecache.h&quot;
+
+AGBorder::AGBorder(const AGString &amp;pTheme)
+{
+  mTheme=pTheme;
+  AGString imageName=pTheme+&quot;.image&quot;;
+
+  if((mEnable=getTheme()-&gt;hasSurface(imageName)))
+    {
+      AGSurface surface(getTheme()-&gt;getSurface(imageName));
+      //      mSurface=getTextureManager()-&gt;makeTexture(getTheme()-&gt;getSurface(pTheme+&quot;.image&quot;));
+      mTexture=&amp;getTextureCache()-&gt;get(getTheme()-&gt;getSurfaceName(imageName));
+      mWidth=mTexture-&gt;width()/3;
+
+      // build textures
+      for(int y=0;y&lt;3;y++)
+	for(int x=0;x&lt;3;x++)
+	  {
+	    AGRect2 r(x*mWidth,y*mWidth,mWidth,mWidth);
+	    mTextures.push_back(&amp;getTextureCache()-&gt;get(getTheme()-&gt;getSurfaceName(imageName),r));
+	  }
+    }
+  else
+    {
+      mWidth=0;
+      mTexture=0;
+    }
+}
+
+void AGBorder::draw(const AGRect2 &amp;pd,AGPainter &amp;p)
+{
+  AGRect2 d=pd.alignGrid();
+  if(mTexture==0 || !mEnable)
+    return;
+
+  if(!mTexture-&gt;hasTexture())
+    {
+      // FIXME: discard this and fix border-painting -problem in GL!
+      mTexture=&amp;getTextureCache()-&gt;get(getTheme()-&gt;getSurfaceName(mTheme+&quot;.image&quot;));
+    }
+
+  int w=mTexture-&gt;width()/3;
+  int w2=w*2;
+
+  float x2=d.x1();
+  float y2=d.y1();
+  /*
+  // corners
+  p.blit(*mTexture,AGRect2(0,0,w,w),AGRect2(0,0,w,w));
+ 
+  p.blit(*mTexture,AGRect2(0,y2-w,w,w),AGRect2(0,w2,w,w));
+ 
+  p.blit(*mTexture,AGRect2(x2-w,0,w,w),AGRect2(w2,0,w,w));
+ 
+  p.blit(*mTexture,AGRect2(x2-w,y2-w,w,w),AGRect2(w2,w2,w,w));
+
+  // borders
+
+  // hor
+  p.tile(*mTexture,AGRect2(w,0,d.w()-w2,w),AGRect2(w,0,w,w));
+  p.tile(*mTexture,AGRect2(w,y2-w,d.w()-w2,w),AGRect2(w,w2,w,w));
+  // ver
+  p.tile(*mTexture,AGRect2(0,w,w,d.h()-w2),AGRect2(0,w,w,w));
+  p.tile(*mTexture,AGRect2(x2-w,w,w,d.h()-w2),AGRect2(w2,w,w,w));
+*/
+  // skip interior
+
+
+  p.tile(*mTextures[0],AGRect2(0,0,w,w));
+  p.tile(*mTextures[6],AGRect2(0,y2-w,w,w));
+  p.tile(*mTextures[2],AGRect2(x2-w,0,w,w));
+  p.tile(*mTextures[8],AGRect2(x2-w,y2-w,w,w));
+
+  // hor
+  p.tile(*mTextures[1],AGRect2(w,0,d.w()-w2,w));
+  p.tile(*mTextures[7],AGRect2(w,y2-w,d.w()-w2,w));
+  // ver
+  p.tile(*mTextures[3],AGRect2(0,w,w,d.h()-w2));
+  p.tile(*mTextures[5],AGRect2(x2-w,w,w,d.h()-w2));
+
+  
+}
+
+size_t AGBorder::getWidth() const
+{
+  return mWidth;
+}
+
+void AGBorder::useTextures()
+{
+  if(mTexture)
+    const_cast&lt;AGTexture*&gt;(mTexture)-&gt;useTexture();
+
+  for(std::vector&lt;const AGTexture*&gt;::iterator i=mTextures.begin();i!=mTextures.end();i++)
+    const_cast&lt;AGTexture*&gt;(*i)-&gt;useTexture();
+
+}
+

Added: antargis/branches/rant/ext/gui/ag_border.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_border.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_border.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_border.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef __AG_BORDER_H__
+#define __AG_BORDER_H__
+
+#include &lt;string&gt;
+#include &quot;ag_texture.h&quot;
+#include &quot;ag_geometry.h&quot;
+
+class AGPainter;
+
+
+class AGBorder
+{
+ public:
+  AGBorder(const AGString &amp;pTheme=&quot;&quot;);
+
+  void draw(const AGRect2 &amp;r,AGPainter &amp;p);
+
+  size_t getWidth() const;
+
+  void useTextures();
+
+ private:
+  const AGTexture *mTexture;
+
+  std::vector&lt;const AGTexture*&gt; mTextures;
+
+  AGString mTheme;
+  bool mEnable;
+  size_t mWidth;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_button.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_button.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_button.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,390 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_button.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_button.h&quot;
+#include &quot;ag_draw.h&quot;
+#include &quot;ag_edit.h&quot;
+#include &quot;ag_theme.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_image.h&quot;
+#include &quot;ag_border.h&quot;
+#include &quot;ag_glscreen.h&quot;
+
+using namespace std;
+
+/**
+ * \brief creates a button with a text
+ *
+ * @param pParent the parent widget
+ * @param r       relative position within the parent
+ * @param pText   the caption displayed on the button. take '' for no text
+ * @param id      currently not any longer used id
+*/
+
+AGButton::AGButton(AGWidget *pParent,const AGRect2 &amp;r,const AGStringUtf8&amp;pText,int id):
+  AGWidget(pParent,r),
+  mText(pText),mID(id),mState(NORMAL),mTextW(0)
+{
+  mImageW=0;
+  setTheme(&quot;&quot;);
+  AGFont font(&quot;FreeSans.ttf&quot;);
+  font.setColor(AGColor(0,0,0));
+  mTextW=new AGEdit(this,r.origin().shrink(borderWidth));//,mText,font);
+  mTextW-&gt;setText(mText);
+  mTextW-&gt;setAlign(EDIT_CENTER);
+  mTextW-&gt;setVAlign(EDIT_VCENTER);
+  mTextW-&gt;setFont(font);
+  mTextW-&gt;setMutable(false);
+  mTextW-&gt;setBackground(false);
+  addChild(mTextW);
+
+  setTheme(&quot;&quot;);
+  mChecked=false;
+
+  //  cdebug(&quot;borderWidth:&quot;&lt;&lt;borderWidth);
+  mEnabled=true;
+
+  if(opengl())
+    setCaching(true);
+}
+
+void AGButton::setSurface(AGSurface pSurface,bool pChangeSize)
+{
+  mSurface=pSurface;
+  mGrayedSurface=mSurface.grayed();
+  if(!mImageW)
+    {
+      mImageW=new AGImage(this,getRect().origin(),mSurface,false);
+      addChild(mImageW);
+    }
+  else
+    {
+      mImageW-&gt;setSurface(pSurface);
+      mImageW-&gt;show();
+    }
+  mTextW-&gt;hide();
+  if(pChangeSize)
+    {
+      setWidth(mImageW-&gt;width()+2+2*borderWidth);
+      setHeight(mImageW-&gt;height()+2+2*borderWidth);
+    }
+
+  else
+    {
+      // then center
+      mImageW-&gt;setLeft((width()-mImageW-&gt;width())/2);
+      mImageW-&gt;setTop((height()-mImageW-&gt;height())/2);
+    }
+  queryRedraw();
+}
+
+void AGButton::setTexture(const AGTexture &amp;pTexture)
+{
+  if(!mImageW)
+    {
+      mImageW=new AGImage(this,getRect().origin(),mSurface,false);
+      addChild(mImageW);
+    }
+  else
+    {
+      //      mImageW-&gt;setSurface(pTexture);
+      mImageW-&gt;show();
+    }
+  mImageW-&gt;setTexture(pTexture);
+}
+
+
+void AGButton::draw(AGPainter &amp;p)
+{
+  p.pushMatrix();
+  p.transform(AGRect2(0,0,width(),height()).shrink(borderWidth));
+  AGRect2 pr=getRect().origin();
+  mBG[mState].draw(pr,p);
+  mBorder[mState].draw(pr,p);
+  p.popMatrix();
+
+  if(borderWidth==0)
+    return;
+
+  AGColor bc1;
+  AGColor bc2;
+  AGTheme *theme=getTheme();
+
+  bc1=theme-&gt;getColor(mTheme+&quot;button.border.color1&quot;);
+  bc2=theme-&gt;getColor(mTheme+&quot;button.border.color2&quot;);
+
+  // draw border
+  
+  AGRect2 mr;
+  
+  mr=getRect().origin();
+  
+  if(mState==NORMAL || mState==LIGHTED)
+    p.drawBorder(mr,borderWidth,bc1,bc2);
+  else 
+    p.drawBorder(mr,borderWidth,bc2,bc1);
+}
+
+
+bool AGButton::eventMouseEnter()
+{
+  AGWidget::eventMouseEnter();
+  queryRedraw();
+  if(!mEnabled)
+    return false;
+  if(mChecked)
+    mState=CHECKEDLIGHTED;
+  else
+    mState=LIGHTED;
+  return false;
+}
+bool AGButton::eventMouseLeave()
+{
+  AGWidget::eventMouseLeave();
+  queryRedraw();
+  if(!mEnabled)
+    return false;
+  if(mChecked)
+    mState=CHECKED;
+  else
+    mState=NORMAL;
+  return false;
+}
+
+
+bool AGButton::eventMouseButtonDown(AGEvent *e)
+{
+  if(e-&gt;isSDLEvent())
+    {
+      if(getScreenRect().contains(e-&gt;getMousePosition()))
+	{
+	  if(mEnabled)
+	    {
+	      queryRedraw();
+	      if(mChecked)
+		mState=CHECKEDPRESSED;
+	      else
+		mState=PRESSED;
+
+	      AGWidget::eventMouseButtonDown(e); // let it get the buttondown-info
+	    }
+	  
+	  return true;
+	}
+    }
+  return AGWidget::eventMouseButtonDown(e);
+}
+
+bool AGButton::eventMouseButtonUp(AGEvent *e)
+{
+  if(e-&gt;isSDLEvent())
+    {
+      if(mEnabled)
+	{
+	  queryRedraw();
+	  if(getScreenRect().contains(e-&gt;getMousePosition()))
+	    {
+	      if(mChecked)
+		mState=CHECKEDLIGHTED;
+	      else
+		mState=LIGHTED;
+	    }
+	  else
+	    {
+	      if(mChecked)
+		mState=CHECKED;
+	      else
+		mState=NORMAL;
+	    }
+	}
+     
+    }
+  return AGWidget::eventMouseButtonUp(e);
+}
+
+void AGButton::setWidth(float w)
+{
+  assert(w&gt;=0);
+  ccdebug(w);
+  AGWidget::setWidth(w);
+  std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();
+  for(;i!=mChildren.end();i++)
+    (*i)-&gt;setRect(getRect().shrink(borderWidth));
+}
+void AGButton::setHeight(float h)
+{
+  assert(h&gt;=0);
+  AGWidget::setHeight(h);
+  std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();
+  for(;i!=mChildren.end();i++)
+    (*i)-&gt;setRect(getRect().shrink(borderWidth));
+}
+
+/**
+   \return returns the text displayed on the button
+*/
+AGStringUtf8 AGButton::getCaption() const
+{
+  return mText;
+}
+
+/**
+   dis- or enables the button. disabled buttons are typically displayed greyed and are 
+   not hoverable or clckable
+
+   \param pEnable true or false
+*/
+
+void AGButton::setEnabled(bool pEnable)
+{
+  if(mEnabled!=pEnable)
+    {
+      mEnabled=pEnable;
+      setState(mState); // check
+      queryRedraw();
+      if(mImageW)
+	{
+	  if(mEnabled)
+	    mImageW-&gt;setSurface(mSurface);
+	  else
+	    mImageW-&gt;setSurface(mGrayedSurface);
+	}
+
+    }
+}
+
+void AGButton::setTheme(const AGString &amp;pTheme)
+{
+  queryRedraw();
+  mTheme=addPoint(pTheme);
+
+  lower=getTheme()-&gt;getInt(mTheme+&quot;buttonLowerOnClick&quot;);
+  borderWidth=getTheme()-&gt;getInt(mTheme+&quot;button.border.width&quot;);
+
+  mBG[NORMAL]=AGBackground(mTheme+&quot;button.background.normal&quot;);
+  mBG[PRESSED]=AGBackground(mTheme+&quot;button.background.pressed&quot;);
+  mBG[LIGHTED]=AGBackground(mTheme+&quot;button.background.lighted&quot;);
+  mBG[CHECKED]=AGBackground(mTheme+&quot;button.background.checked&quot;);
+  mBG[CHECKEDLIGHTED]=AGBackground(mTheme+&quot;button.background.checkedlighted&quot;);
+  mBG[CHECKEDPRESSED]=AGBackground(mTheme+&quot;button.background.checkedpressed&quot;);
+  mBG[DISABLED]=AGBackground(mTheme+&quot;button.background.disabled&quot;);
+
+  mBorder[NORMAL]=AGBorder(mTheme+&quot;button.border.normal&quot;);
+  mBorder[PRESSED]=AGBorder(mTheme+&quot;button.border.pressed&quot;);
+  mBorder[LIGHTED]=AGBorder(mTheme+&quot;button.border.lighted&quot;);
+  mBorder[CHECKED]=AGBorder(mTheme+&quot;button.border.checked&quot;);
+  mBorder[CHECKEDLIGHTED]=AGBorder(mTheme+&quot;button.border.checkedlighted&quot;);
+  mBorder[CHECKEDPRESSED]=AGBorder(mTheme+&quot;button.border.checkedpressed&quot;);
+  mBorder[DISABLED]=AGBorder(mTheme+&quot;button.border.disabled&quot;);
+
+  if(mTextW)
+    mTextW-&gt;setTheme(mTheme+&quot;button.text&quot;);
+
+}
+
+void AGButton::setCaption(const AGStringUtf8 &amp;pCaption)
+{
+  queryRedraw();
+  mText=pCaption;
+  if(mTextW)
+    mTextW-&gt;setText(pCaption);
+  if(mImageW)
+    mImageW-&gt;hide();
+}
+
+void AGButton::setState(const State &amp;pState)
+{
+  queryRedraw();
+  if(mEnabled)
+    {
+      if(mState==DISABLED)
+	mState=NORMAL;
+      else
+	mState=pState;
+    }
+  else
+    mState=DISABLED;
+}
+
+AGButton::State AGButton::getState() const
+{
+  return mState;
+}
+
+
+void AGButton::setChecked(bool pChecked)
+{
+  queryRedraw();
+  mChecked=pChecked;
+  if(mChecked)
+    {
+      if(mState==LIGHTED || mState==CHECKEDLIGHTED)
+	setState(CHECKEDLIGHTED);
+      else
+	setState(CHECKED);
+    }
+  else
+    {
+      if(mState==LIGHTED || mState==CHECKEDLIGHTED)
+	setState(LIGHTED);
+      else
+	setState(NORMAL);
+    }
+}
+bool AGButton::isChecked() const
+{
+  return mChecked;
+}
+
+
+AGButton &amp;toAGButton(AGWidget &amp;pWidget)
+{
+  return dynamic_cast&lt;AGButton&amp;&gt;(pWidget);
+}
+
+/**
+   \brief can this widget widget be focused.
+
+   \return always true
+*/
+bool AGButton::canFocus() const
+{
+  return true;
+}
+
+/**
+   \brief special function for &quot;using textures&quot;
+
+   within a texture-garbage-collection run all unused textures get cleaned,
+   so this function &quot;uses&quot; the textures. This way they won't get collected
+*/
+
+void AGButton::useTextures()
+{
+  for(std::map&lt;State,AGBackground&gt;::iterator i=mBG.begin();i!=mBG.end();++i)
+    i-&gt;second.useTextures();
+  for(std::map&lt;State,AGBorder&gt;::iterator i=mBorder.begin();i!=mBorder.end();++i)
+    i-&gt;second.useTextures();
+}
+
+bool AGButton::isOpaque() const
+{
+  return true;
+}

Added: antargis/branches/rant/ext/gui/ag_button.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_button.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_button.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_button.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_BUTTON_H
+#define AG_BUTTON_H
+
+#include &quot;ag_widget.h&quot;
+#include &quot;ag_surface.h&quot;
+#include &quot;ag_background.h&quot;
+#include &quot;ag_border.h&quot;
+
+#include &lt;iostream&gt;
+#include &lt;map&gt;
+
+class AGEdit;
+class AGImage;
+
+/**
+   \brief implements push-buttons
+   \ingroup widgets
+
+   AGButton represents a button, which can hold a text-caption or an image-caption, but not both.
+   Further it can have following states:
+*/
+
+class AGButton:public AGWidget
+{
+ public:
+  /// the different drawing states
+   enum State {
+     NORMAL,         //!&lt; the normal state of a button
+     LIGHTED,        //!&lt; the button is lighted or hovered
+     PRESSED,        //!&lt; the button is pressed (typically hovered)
+     CHECKED,        //!&lt; the button is checked (and not pressed)
+     CHECKEDLIGHTED, //!&lt; a hovered and checked button
+     CHECKEDPRESSED, //!&lt; hovered, checked and pressed
+     DISABLED        //!&lt; the button disabled (greyed)
+   };
+
+  AGButton(AGWidget *pParent,const AGRect2 &amp;r,const AGStringUtf8&amp;pText,int id=-1);
+
+  void setSurface(AGSurface pSurface,bool pChangeSize=false);
+  void setTexture(const AGTexture &amp;pTexture);
+
+  virtual void draw(AGPainter &amp;p);
+
+  virtual bool eventMouseEnter();
+  virtual bool eventMouseLeave();
+
+  virtual bool eventMouseButtonDown(AGEvent *m);
+  virtual bool eventMouseButtonUp(AGEvent *m);
+
+  virtual void setWidth(float w);
+  virtual void setHeight(float w);
+
+  virtual AGStringUtf8 getCaption() const;
+
+  void setEnabled(bool pEnable);
+
+  void setTheme(const AGString &amp;pTheme);
+
+  void setCaption(const AGStringUtf8 &amp;pCaption);
+
+  /// sets the current state and ensures a redraw
+  virtual void setState(const State &amp;pState);
+  State getState() const;
+
+  virtual void setChecked(bool pChecked);
+  bool isChecked() const;
+
+  bool canFocus() const;
+
+  virtual void useTextures();
+
+  bool isOpaque() const;
+
+ private:
+  AGStringUtf8 mText;
+  int mID;
+  AGString mTheme;
+  State mState;
+  int borderWidth;
+  AGSurface mSurface;
+  AGSurface mGrayedSurface;
+  bool mHasSurface;
+  AGEdit *mTextW;
+  AGImage *mImageW;
+
+  bool lower;
+  bool mChecked;
+
+  std::map&lt;State,AGBackground&gt; mBG;
+  std::map&lt;State,AGBorder&gt; mBorder;
+  bool mEnabled;
+};
+
+AGButton &amp;toAGButton(AGWidget &amp;pWidget);
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_caption.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_caption.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_caption.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_caption.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_caption.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_screen.h&quot;
+
+AGCaption::AGCaption(AGWidget *pParent,const AGRect2 &amp;pRect,const AGStringUtf8 &amp;pText,const AGFont &amp;pFont,const AGBackground &amp;pBG):
+  AGText(pParent,pRect,pText,pFont),
+  mBG(pBG)
+{
+}
+
+void AGCaption::draw(AGPainter &amp;p)
+{
+  // draw bg
+  mBG.draw(getRect().origin(),p);
+  AGText::draw(p);
+}
+
+void AGCaption::setBackground(AGBackground pBG)
+{
+  mBG=pBG;
+}

Added: antargis/branches/rant/ext/gui/ag_caption.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_caption.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_caption.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_caption.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_CAPTION_H
+#define AG_CAPTION_H
+
+#include &quot;ag_text.h&quot;
+#include &quot;ag_background.h&quot;
+
+class AGCaption:public AGText
+{
+ public:
+  AGCaption(AGWidget *pParent,const AGRect2 &amp;pRect,const AGStringUtf8 &amp;pText,const AGFont &amp;pFont,const AGBackground &amp;pBG);
+
+  void draw(AGPainter &amp;p);
+
+  void setBackground(AGBackground pBG);
+ private:
+  AGBackground mBG;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_checkbox.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_checkbox.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_checkbox.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_checkbox.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_checkbox.h&quot;
+#include &quot;ag_image.h&quot;
+#include &quot;ag_text.h&quot;
+#include &quot;ag_theme.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_layoutfactory.h&quot;
+#include &quot;ag_local.h&quot;
+
+AGCheckBox::AGCheckBox(AGWidget *pParent,AGRect2 pRect):
+  AGButton(pParent,pRect,&quot;&quot;)//,mChecked(false)
+{
+  mSurfaces[0]=mSurfaces[1]=0;
+  /*  mImage=0;
+  if(getTheme()-&gt;hasSurface(mType+&quot;.normal&quot;))
+    addChild(mImage=new AGImage(this,AGVector2(0,0),getTheme()-&gt;getSurface(mType+&quot;.normal&quot;),false));
+  addChild(new AGText(this,AGVector2(0,0),pName,getTheme()-&gt;getFont(std::string(&quot;Font.&quot;)+mType)));
+
+  adaptHeightFromChildren();*/
+}
+
+bool AGCheckBox::eventMouseClick(AGEvent *m)
+{
+  CTRACE;
+  setChecked(!isChecked());
+  /*
+  mChecked=!mChecked;
+  if(mChecked)
+    setState(CHECKED);
+  else
+  setState(NORMAL);*/
+    /*
+
+  if(mImage)
+    {
+      if(mChecked)
+	mImage-&gt;setSurface(getTheme()-&gt;getSurface(mType+&quot;.checked&quot;));
+      else
+	mImage-&gt;setSurface(getTheme()-&gt;getSurface(mType+&quot;.normal&quot;));
+	}*/
+  return AGButton::eventMouseClick(m);//false;//true; // eat
+}
+
+/*
+std::string AGCheckBox::getName() const
+{
+  return mName;
+}
+*/
+
+
+void AGCheckBox::setSurfaces(AGSurface pDisabledSurface,AGSurface pEnabledSurface)
+{
+  delete mSurfaces[0];
+  delete mSurfaces[1];
+  mSurfaces[0]=new AGSurface(pDisabledSurface);
+  mSurfaces[1]=new AGSurface(pEnabledSurface);
+
+  //  setState(getState());
+  queryRedraw();
+}
+
+void AGCheckBox::setState(const State &amp;pState)
+{
+  if(mSurfaces[0])
+    {
+      if(pState==NORMAL || pState==LIGHTED || pState==PRESSED)
+	setSurface(*(mSurfaces[0]));
+      else
+	setSurface(*(mSurfaces[1]));
+    }
+
+  AGButton::setState(pState);
+}
+
+

Added: antargis/branches/rant/ext/gui/ag_checkbox.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_checkbox.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_checkbox.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_checkbox.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_CHECK_BOX_H
+#define AG_CHECK_BOX_H
+
+//#include &quot;ag_vtiler.h&quot;
+#include &quot;ag_button.h&quot;
+
+class AGImage;
+
+class AGCheckBox:public AGButton
+{
+ public:
+  AGCheckBox(AGWidget *pParent,AGRect2 pRect);
+
+  void setSurfaces(AGSurface pDisabledSurface,AGSurface pEnabledSurface);
+
+  void setState(const State &amp;pState);
+  virtual bool eventMouseClick(AGEvent *m);
+ private:
+  AGSurface *mSurfaces[2];
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_colorbutton.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_colorbutton.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_colorbutton.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_colorbutton.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_colorbutton.h&quot;
+#include &quot;ag_layoutfactory.h&quot;
+
+AGColorButton::AGColorButton(AGWidget *pParent,const AGRect2 &amp;r,int x,int y):
+  AGWidget(pParent,r),gridx(x),gridy(y),mColors(x*y)
+{
+}
+
+void AGColorButton::draw(AGPainter &amp;p)
+{
+  AGWidget::draw(p);
+  
+  int i=0;
+  AGRect2 ar(getRect().origin());
+  float w=ar.w()/gridx;
+  float h=ar.h()/gridy;
+  for(int y=0;y&lt;gridy;y++)
+    for(int x=0;x&lt;gridx;x++)
+      {
+	AGRect2 r(ar.w()*x/gridx,ar.h()*y/gridy,w,h);
+	p.fillRect(r,mColors[i++]);
+      }
+}
+
+AGColor AGColorButton::getColor() const
+{
+  return mColor;
+}
+
+void AGColorButton::setColor(const AGColor &amp;c)
+{
+  mColor=c;
+}
+void AGColorButton::setColor(int x,int y,const AGColor &amp;c)
+{
+  assert(x&gt;=0);
+  assert(y&gt;=0);
+  assert(x&lt;gridx);
+  assert(y&lt;gridy);
+  mColors[x+y*gridx]=c;
+}
+
+
+AGColorButton &amp;toAGColorButton(AGWidget &amp;pWidget)
+{
+  return dynamic_cast&lt;AGColorButton&amp;&gt;(pWidget);
+}
+
+bool AGColorButton::eventMouseClick(AGEvent *e)
+{
+  //  const AGSDLEvent *e=dynamic_cast&lt;const AGSDLEvent*&gt;(m);
+  if(e-&gt;isSDLEvent())
+    {
+      AGVector2 p=e-&gt;getMousePosition();
+      p-=getScreenRect().getV0();
+      float gx=p[0]*gridx/getRect().w();
+      float gy=p[1]*gridy/getRect().h();
+      float d=gx+gy*gridx;
+      cdebug(p[0]&lt;&lt;&quot;   &quot;&lt;&lt;p[1]);
+      cdebug(&quot;gx:&quot;&lt;&lt;gx&lt;&lt;&quot;  gy:&quot;&lt;&lt;gy);
+      assert(d&lt;gridx*gridy &amp;&amp; d&gt;=0);
+      mColor=mColors[size_t(d)];
+      cdebug(mColor.toString());
+    }
+
+  return AGWidget::eventMouseClick(e);
+}
+
+

Added: antargis/branches/rant/ext/gui/ag_colorbutton.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_colorbutton.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_colorbutton.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_colorbutton.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_COLORBUTTON_H
+#define AG_COLORBUTTON_H
+
+#include &quot;ag_widget.h&quot;
+#include &quot;ag_color.h&quot;
+#include &lt;vector&gt;
+
+class AGColorButton:public AGWidget
+{
+ public:
+  AGColorButton(AGWidget *pParent,const AGRect2 &amp;r,int x,int y);
+
+  virtual void draw(AGPainter &amp;p);
+
+  AGColor getColor() const;
+  void setColor(const AGColor &amp;c);
+  void setColor(int x,int y,const AGColor &amp;c);
+
+  virtual bool eventMouseClick(AGEvent *m);
+
+ private:
+  int gridx,gridy;
+  std::vector&lt;AGColor&gt; mColors;
+
+  AGColor mColor;
+};
+
+AGColorButton &amp;toAGColorButton(AGWidget &amp;pWidget);
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_combo.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_combo.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_combo.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,129 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_combo.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_application.h&quot;
+#include &quot;ag_button.h&quot;
+#include &quot;ag_combo.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_edit.h&quot;
+#include &quot;ag_listbox.h&quot;
+#include &quot;ag_theme.h&quot;
+
+AGComboBox::AGComboBox(AGWidget *pParent,const AGRect2 &amp;pRect):
+  AGWidget(pParent,pRect),sigSelect(this,&quot;sigSelect&quot;)
+{
+  mEdit=new AGEdit(this,AGRect2(0,0,width()-height(),height()));
+  mButton=new AGButton(this,AGRect2(width()-height(),0,height(),height()),&quot;&quot;);
+
+  mButton-&gt;setSurface(AGSurface::load(&quot;data/gui/arrow_down.png&quot;));
+
+  AGFont f=getTheme()-&gt;getFont(&quot;combobox.font&quot;);
+
+  mEdit-&gt;setMutable(false);
+  mEdit-&gt;setFont(f);
+  addChild(mEdit);
+  addChild(mButton);
+
+  mButton-&gt;sigClick.connect(slot(this,&amp;AGComboBox::eventButtonClicked));
+}
+
+
+void AGComboBox::insertItem(const AGString &amp;pID,const AGStringUtf8 &amp;pContent)
+{
+  ops.push_back(std::make_pair(pID,pContent));
+  if(ops.size()==1)
+    mID=pID;
+  update();
+}
+
+void AGComboBox::update()
+{
+  if(ops.size()&gt;0)
+    {
+      // find
+      AGStringUtf8 text;
+      for(std::list&lt;std::pair&lt;AGString,AGStringUtf8&gt; &gt;::iterator i=ops.begin();i!=ops.end();i++)
+	if(i-&gt;first==mID)
+	  {
+	    text=i-&gt;second;
+	    break;
+	  }
+
+      mEdit-&gt;setText(text);
+    }
+}
+
+bool AGComboBox::eventButtonClicked(AGEvent *pEvent)
+{
+  if(ops.size()==0)
+    return true;
+
+  AGRect2 sr=getScreenRect();
+
+  cdebug(sr.x());
+  cdebug(sr.y());
+  cdebug(width());
+  cdebug(getTheme()-&gt;getInt(&quot;listbox.item.height&quot;)*std::min(8,(int)ops.size()));
+
+  float mItemHeight=getTheme()-&gt;getInt(&quot;listbox.item.height&quot;);
+  if(mItemHeight&lt;5)
+    mItemHeight=25;
+
+
+  mListBox=new AGListBox(0,AGRect2(sr.x(),sr.y()+height(),width(),mItemHeight*8));
+
+  mListBox-&gt;sigSelect.connect(slot(this,&amp;AGComboBox::eventSelected));
+
+  for(std::list&lt;std::pair&lt;AGString,AGStringUtf8&gt; &gt;::iterator i=ops.begin();i!=ops.end();i++)
+    mListBox-&gt;insertItem(i-&gt;first,i-&gt;second);
+  if(ops.size()&gt;0)
+    mListBox-&gt;selectItem(mID);
+
+  getApplication()-&gt;setOverlay(mListBox);
+  return true;
+}
+
+bool AGComboBox::eventSelected(AGEvent *pEvent)
+{
+  CTRACE;
+  mID=mListBox-&gt;getSelectedID();
+  update();
+  getApplication()-&gt;setOverlay(0);
+
+  sigSelect(new AGEvent(this,&quot;sigSelect&quot;));
+  return true;
+}
+
+AGString AGComboBox::getSelected() const
+{
+  return mID;
+}
+void AGComboBox::setSelected(const AGString &amp;pID)
+{
+  mID=pID;
+  update();
+}
+
+void AGComboBox::clear()
+{
+  ops.clear();
+  mID=&quot;&quot;;
+  update();
+}

Added: antargis/branches/rant/ext/gui/ag_combo.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_combo.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_combo.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_combo.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_COMBO_H
+#define AG_COMBO_H
+
+#include &lt;ag_widget.h&gt;
+
+class AGEdit;
+class AGButton;
+class AGListBox;
+
+class AGComboBox:public AGWidget
+{
+ public:
+  AGComboBox(AGWidget *pParent,const AGRect2 &amp;pRect);
+
+  void insertItem(const AGString &amp;pID,const AGStringUtf8 &amp;pContent);
+
+  bool eventButtonClicked(AGEvent *pEvent);
+  bool eventSelected(AGEvent *pEvent);
+
+  AGSignal sigSelect;
+  
+  AGString getSelected() const;
+  void setSelected(const AGString &amp;pID);
+
+  void clear();
+
+ private:
+  void update();
+
+  AGEdit *mEdit;
+  AGButton *mButton;
+  AGListBox *mListBox;
+
+  AGString mID;
+
+  std::list&lt;std::pair&lt;AGString,AGStringUtf8&gt; &gt; ops;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_edit.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_edit.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_edit.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,996 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_edit.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_edit.h&quot;
+#include &quot;ag_fontengine.h&quot;
+#include &quot;ag_theme.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_menu.h&quot;
+#include &quot;ag_sgeexport.h&quot;
+#include &quot;ag_glscreen.h&quot;
+#include &quot;ag_tools.h&quot;
+
+
+AGEditLine::AGEditLine(const AGStringUtf8 &amp;pText,AGFont pFont,bool pHardEnd):
+  mText(pText),mFont(pFont),mHardEnd(pHardEnd)
+{
+  mAlign=EDIT_LEFT;
+  mVAlign=EDIT_TOP;
+}
+
+AGEditLine::~AGEditLine()
+{
+}
+
+void AGEditLine::setAlign(AGAlign pAlign)
+{
+  mAlign=pAlign;
+}
+
+void AGEditLine::setVAlign(AGVAlign pVAlign)
+{
+  mVAlign=pVAlign;
+}
+
+void AGEditLine::setFont(const AGFont &amp;pFont)
+{
+  mFont=pFont;
+}
+
+
+AGFont AGEditLine::getFont() const
+{
+  return mFont;
+}
+
+#define SMALL_CHUNKS
+
+void AGEditLine::draw(AGPainter &amp;p,const AGVector2 &amp;pPoint,const AGRect2 &amp;pClip)
+{
+  int x=0;
+  if(mAlign==EDIT_CENTER)
+    x=(int)((pClip.w()-mFont.getWidth(mText))/2);
+
+#ifdef SMALL_CHUNKS
+  int mx=0;
+  std::vector&lt;AGStringUtf8&gt; a=mText.split(AGStringUtf8(&quot; &quot;));
+  for(std::vector&lt;AGStringUtf8&gt;::iterator i=a.begin();i!=a.end();i++)
+    {
+      //      cdebug(*i);
+      p.renderText(*i,AGVector2(pPoint[0]+x+mx,pPoint[1]),mFont);
+      mx+=getFontEngine()-&gt;getWidth(mFont,*i+&quot; &quot;);
+    }
+#else
+  p.renderText(mText+(mHardEnd?&quot;&quot;:&quot;&quot;),AGVector2(pPoint.x+x,pPoint.y),mFont);
+#endif
+}
+
+void AGEditLine::drawCursor(AGPainter &amp;p,int cx,const AGVector2 &amp;pPoint,const AGRect2 &amp;pClip,const AGColor &amp;c)
+{
+  int x1=getFontEngine()-&gt;getWidth(mFont,mText.substr(0,cx));
+  int x2=getFontEngine()-&gt;getWidth(mFont,mText.substr(0,cx+1));
+
+  int w=x2-x1;
+  if(w==0)
+    w=8;
+
+#ifdef SIMPLE_BOX_CURSOR
+  p.fillRect(AGRect2(pPoint[0]+x1,pPoint[1],w,height()),c);
+#else
+  float x=pPoint[0]+x1-4;
+  float y=pPoint[1];
+  float h=height();
+
+  w=10;
+
+  p.fillRect(AGRect2(x,y,w+1,3),c);
+  p.fillRect(AGRect2(x+w/2-1,y+3,3,h-6),c);
+  p.fillRect(AGRect2(x,y+h-3,w+1,3),c);
+#endif
+}
+
+
+int AGEditLine::height() const
+{
+  return getFontEngine()-&gt;getHeight(mFont,mText);
+}
+int AGEditLine::width() const
+{
+  return getFontEngine()-&gt;getWidth(mFont,mText);
+}
+
+void AGEditLine::insert(const AGStringUtf8 &amp;c,int cx,bool pInsert)
+{
+  if(pInsert)
+    mText=mText.substr(0,cx)+c+mText.substr(cx,AGString::npos);
+  else if(cx&lt;(long)mText.length())
+    mText[cx]=c;
+  else
+    mText+=c;
+}
+
+void AGEditLine::doDelete(int cx)
+{
+  if(mText.length()&gt;0)
+    if(cx&gt;=0&amp;&amp;cx&lt;int(mText.length()))
+      mText=mText.substr(0,cx)+mText.substr(cx+1,AGString::npos);
+
+}
+
+AGEditLine AGEditLine::split(int cx)
+{
+  AGStringUtf8 n=mText.substr(cx,mText.npos);
+  mText=mText.substr(0,cx);
+  bool hard=mHardEnd;
+  mHardEnd=true;
+  return AGEditLine(n,mFont,hard);
+}
+
+int AGEditLine::length() const
+{
+  return mText.length();
+}
+
+void AGEditLine::append(const AGStringUtf8 &amp;s)
+{
+  mText+=s;
+}
+
+void AGEditLine::prepend(const AGStringUtf8 &amp;s)
+{
+  mText=s+mText;
+}
+AGStringUtf8 AGEditLine::getText() const
+{
+  return mText;
+}
+
+// returns the remaing string after wrapping
+std::pair&lt;AGStringUtf8,bool&gt; AGEditLine::checkWrap(int pW)
+{
+  // first check, if line is too long
+
+  if(getFontEngine()-&gt;getWidth(mFont,mText)&lt;pW)
+    return std::make_pair(&quot;&quot;,false);
+
+  // ok, line is too long
+  // so search for a good split (between words), but not before half of width
+  std::vector&lt;AGStringUtf8&gt; words=mText.split(&quot; &quot;);
+  
+  std::vector&lt;AGStringUtf8&gt;::iterator i=words.begin();
+  int w=0,ow=0;
+  AGStringUtf8 s,os;
+
+  for(;i!=words.end();i++)
+    {
+      s+=*i;
+      w=getFontEngine()-&gt;getWidth(mFont,s);
+      if(w&gt;pW)
+	break;
+
+      ow=w;
+      os=s;
+      s+=&quot; &quot;;
+    }
+  if(ow&gt;pW/4 &amp;&amp; ow&lt;width())
+    {
+      // check if width will be at least a 1/4 of whole width
+      AGStringUtf8 n=mText.substr(os.length()+1,n.npos);
+      mText=mText.substr(0,os.length()+1);
+
+      bool hard=mHardEnd;
+      mHardEnd=false;
+      return std::make_pair(n,hard);
+    }
+
+
+  // find first character, which stands over
+  size_t k=0;
+  w=ow=0;
+  s=os=&quot;&quot;;
+  for(;k&lt;mText.length();k++)
+    {
+      s+=mText.substr(k,1);
+      w=getFontEngine()-&gt;getWidth(mFont,s);
+      if(w&gt;pW)
+	break;
+
+      ow=w;
+      os=s;
+    }
+  if(k&gt;=mText.length())
+    return std::make_pair(&quot;&quot;,false); // some error
+  AGStringUtf8 n=mText.substr(k,mText.length());
+  mText=mText.substr(0,k);
+  bool hard=mHardEnd;
+  mHardEnd=false;
+  return std::make_pair(n,hard);
+}
+
+void AGEditLine::setHardEnd(bool pHardEnd)
+{
+  mHardEnd=pHardEnd;
+}
+
+bool AGEditLine::hardEnd() const
+{
+  return mHardEnd;
+}
+
+std::pair&lt;AGStringUtf8,bool&gt; AGEditLine::checkUnwrap(int pW,const AGStringUtf8 &amp;s)
+{
+  AGStringUtf8 oldtext=mText;
+  //  mText+=&quot; &quot;;
+  mText+=s;
+  AGStringUtf8 testtext=mText;
+  std::pair&lt;AGStringUtf8,bool&gt; res=checkWrap(pW);
+  if(mText!=oldtext)
+    return std::make_pair(testtext.substr(mText.length(),AGString::npos),true);
+  else
+    return std::make_pair(&quot;&quot;,false);
+  
+}
+
+void AGEditLine::setText(const AGStringUtf8 &amp;s)
+{
+  mText=s;
+}
+
+
+
+
+
+
+  
+AGEdit::AGEdit(AGWidget *pParent,const AGRect2 &amp;pRect):
+  AGWidget(pParent,pRect),mCursorTime(0),mCursorLast(SDL_GetTicks()),
+  mLShift(false),mRShift(false),mLCtrl(false),mRCtrl(false),mLAlt(false),mRAlt(false),
+  mMultiLine(true),mWrapLines(true)
+{
+  mInserting=true;
+  mMaxLength=-1;
+  mMutable=true;
+  mShowCursor=true;
+  AGFont font1(&quot;FreeSans.ttf&quot;,14);
+  AGFont font2(&quot;FreeSans.ttf&quot;,13);
+  font1.setColor(AGColor(0,0,0));
+  font2.setColor(AGColor(0,0,0xFF));
+  AGEditLine l(&quot;&quot;,font1,true);
+  mAlign=EDIT_LEFT;
+  mVAlign=EDIT_TOP;
+  l.setAlign(mAlign);
+  l.setVAlign(mVAlign);
+  mLines.push_back(l);
+
+  mCx=mCy=0;
+  mViewCy=0;
+
+  AGString t=mTheme;
+  if(t.length())
+    t+=&quot;.&quot;;
+  mBackground=AGBackground(t+&quot;edit.background&quot;);
+  mDrawBackground=true;
+  setTheme(&quot;edit&quot;);
+}
+
+void AGEdit::setMaxLength(int i)
+{
+  mMaxLength=i;
+}
+
+
+void AGEdit::draw(AGPainter &amp;p)
+{
+  
+  int x,y,cy;
+  int completeHeight=0;
+  x=y=cy=0;
+  
+  drawBackground(p);//pRect);
+
+  std::list&lt;AGEditLine&gt;::iterator i=mLines.begin();
+
+  //  cdebug(pRect);
+  //  cdebug(&quot;getRect:&quot;&lt;&lt;getRect());
+  AGRect2 mr(getRect());//pRect.project(getRect()));
+
+  AGColor cursorC=AGColor(0,0,0,0x7f);
+  if(mShowCursor) // &amp;&amp; opengl())
+    cursorC=AGColor(0x7f,0x7f,0x7f,0x7f);
+  
+  if(mCy&lt;mViewCy)
+    mViewCy=mCy;
+
+  // get complete height - for hor. centering
+  for(i=mLines.begin();i!=mLines.end();i++)
+    {
+      completeHeight+=i-&gt;height();
+    }
+
+  //  cdebug(&quot;completeHeight:&quot;&lt;&lt;completeHeight);
+  //  cdebug(&quot;height:&quot;&lt;&lt;getRect().h);
+  if(mVAlign==EDIT_VCENTER)
+    y=(int)(getRect().h()/2-completeHeight/2);
+  //  cdebug(&quot;y:&quot;&lt;&lt;y);
+
+  i=mLines.begin();
+
+
+  //  cdebug(&quot;mRect:&quot;&lt;&lt;getRect());
+  //  cdebug(&quot;mViewCy:&quot;&lt;&lt;mViewCy);
+  for(int k=0;k&lt;mViewCy;k++)
+    i++;
+
+  //  cdebug(&quot;mLines:&quot;&lt;&lt;mLines.size());
+  for(;i!=mLines.end();i++)
+    {
+      //      cdebug((*i).getText());
+      //      cdebug(&quot;(&quot;&lt;&lt;x&lt;&lt;&quot;;&quot;&lt;&lt;y&lt;&lt;&quot;)&quot;);
+      //      cdebug(mr);
+      i-&gt;draw(p,AGVector2(x,y),getRect().origin());//pRect.project(getRect()));
+      if(cy+mViewCy==mCy &amp;&amp; mMutable &amp;&amp; hasFocus()) // FIXME: Change show cursor only if widget has focus
+	i-&gt;drawCursor(p,mCx,AGVector2(x,y),getRect(),cursorC);
+      y+=i-&gt;height();
+      if(y&gt;getRect().h())
+	{
+	  //	  cdebug(&quot;break - too far y:&quot;&lt;&lt;y&lt;&lt;&quot; h:&quot;&lt;&lt;getRect().h);
+	  break;
+	}
+      cy++;
+      if(!mMultiLine)
+	{
+	  //	  cdebug(&quot;break - no multiline&quot;);
+	  break;
+	}
+    }
+
+  // do it next time
+  if(cy+mViewCy-1&lt;mCy)
+    mViewCy=mCy-cy+1;
+
+}
+
+void AGEdit::drawBackground(AGPainter &amp;p)
+{
+  //  CTRACE;
+  if(mDrawBackground)
+    {
+      //  CTRACE;
+      mBackground.draw(getRect().origin(),p);
+    }
+  //    p.tile(mBackground,getRect());
+}
+
+bool AGEdit::eventKeyUp(AGEvent *m)
+{
+  if(!mMutable)
+    return false;
+  //  const AGSDLEvent *m=reinterpret_cast&lt;const AGSDLEvent*&gt;(m2);
+  if(m-&gt;isSDLEvent())
+    {
+      SDLKey k=m-&gt;getKey();
+      //      char ins=0;
+      //      bool doInsert=false;
+      if(k==SDLK_LSHIFT)
+	mLShift=false;
+      else if(k==SDLK_RSHIFT)
+	mRShift=false;
+      else if(k==SDLK_LCTRL)
+	mLCtrl=false;
+      else if(k==SDLK_RCTRL)
+	mRCtrl=false;
+      else if(k==SDLK_LALT)
+	mLAlt=false;
+      else if(k==SDLK_RALT)
+	mRAlt=false;
+    }
+  return false;
+}
+bool AGEdit::eventKeyDown(AGEvent *m)
+{
+  if(!mMutable)
+    return false;
+  if(!hasFocus())
+    return false;
+  queryRedraw();
+  if(m-&gt;isSDLEvent())
+    {
+      SDLKey k=m-&gt;getKey();
+      Uint16 unicode=m-&gt;getUnicode();
+      AGStringUtf8 ins;
+      bool doInsert=false;
+      bool used=false;
+      if(k==SDLK_RIGHT)
+	{
+	  getActLine();
+	  if(actLine-&gt;length()&gt;mCx)
+	    mCx++;
+	  else if(mCy&lt;(int)mLines.size()-1)
+	    {
+	      mCy++;
+	      mCx=0;
+	    }
+	  return true;
+	}
+      else if(k==SDLK_LEFT)
+	{
+	  if(mCx&gt;0)
+	    mCx--;
+	  else if(mCy&gt;0)
+	    {
+	      mCy--;
+	      getActLine();
+	      mCx=actLine-&gt;length();
+	    }
+	  
+	  return true;
+	}
+      else if(k==SDLK_UP &amp;&amp; mMultiLine)
+	{
+	  if(mCy&gt;0)
+	    mCy--;
+	  getActLine();
+	  if(mCx&gt;=actLine-&gt;length())
+	    mCx=actLine-&gt;length();
+	  return true;
+	}
+      else if(k==SDLK_DOWN &amp;&amp; mMultiLine)
+	{
+	  if((int)mLines.size()&gt;mCy+1)
+	    mCy++;
+	  getActLine();
+	  if(mCx&gt;=actLine-&gt;length())
+	    mCx=actLine-&gt;length();
+	  return true;
+	}
+      /*      else if(k&gt;=SDLK_0 &amp;&amp; k&lt;=SDLK_9)
+	{
+	  doInsert=true;
+	  if(mRShift||mLShift)
+	    {
+	      AGString s=&quot;=!\&quot;&#194;&#167;$%&amp;/()&quot;;
+	      ins=s[k-SDLK_0];
+	    }
+	  else
+	    ins='0'+(k-SDLK_0);
+	}
+      else if(k&gt;=SDLK_a &amp;&amp; k&lt;=SDLK_z)
+	{
+	  doInsert=true;
+	  if(mRShift||mLShift)
+	    ins='A'+(k-SDLK_a);
+	  else
+	    ins='a'+(k-SDLK_a);
+	    }*/
+      else if(k==SDLK_SPACE)
+	{
+	  doInsert=true;
+	  ins=&quot; &quot;;
+	}
+      else if(k==SDLK_BACKSPACE)
+	{
+	  if(mCx&gt;0)
+	    {
+	      doDelete(mCx-1);
+	      mCx--;
+	    }
+	  else if(mCy&gt;0 &amp;&amp; mMultiLine)
+	    {
+	      mCy--;
+	      getActLine();
+	      mCx=actLine-&gt;length();
+	      if(!actLine-&gt;hardEnd())
+		{
+		  // delete last char
+		  doDelete(actLine-&gt;length()-1);
+		  mCx--;
+		}
+	      mergeLine(mCy);
+	    }
+	  checkWrap();
+	  used=true;
+	}
+      else if(k==SDLK_DELETE)
+	{
+	  doDelete(mCx);
+	  checkWrap();
+	  used=true;
+	}
+      else if(k==SDLK_RETURN &amp;&amp; mMultiLine)
+	{
+	  getActLine();
+	  AGEditLine l=actLine-&gt;split(mCx);
+	  l.setAlign(mAlign);
+	  l.setVAlign(mVAlign);
+	  mCx=0;
+	  mCy++;
+	  insertLine(l);
+	  checkWrap();
+	  used=true;
+	}
+      else if(k==SDLK_END)
+	{
+	  getActLine();
+	  mCx=actLine-&gt;length();
+	  used=true;
+	}
+      else if(k==SDLK_HOME)
+	{
+	  mCx=0;
+	  used=true;
+	}
+
+      else if(k==SDLK_LSHIFT)
+	{
+	  used=true;
+	  mLShift=true;
+	}
+      else if(k==SDLK_RSHIFT)
+	{
+	  used=true;
+	  mRShift=true;
+	}
+      else if(k==SDLK_LCTRL)
+	{
+	  used=true;
+	  mLCtrl=true;
+	}
+      else if(k==SDLK_RCTRL)
+	{
+	  used=true;
+	  mRCtrl=true;
+	}
+      else if(k==SDLK_LALT)
+	{
+	  cdebug(&quot;lalt&quot;);
+	  mLAlt=true;
+	}
+      else if(k==SDLK_RALT)
+	{
+	  cdebug(&quot;ralt&quot;);
+	  mRAlt=true;
+	}
+      /*      else if(strlen(SDL_GetKeyName(k))==1)
+	{
+	  cdebug(k&lt;&lt;&quot;:&quot;&lt;&lt;SDL_GetKeyName(k));
+	  ins=SDL_GetKeyName(k)[0];
+	  doInsert=true;
+	  }*/
+      //      else if(k==SDLK_WORLD_68)
+      else if((unicode&amp;0xFFF8)!=0 || (k&gt;=SDLK_0 &amp;&amp; k&lt;=SDLK_9) || (k&gt;=SDLK_a &amp;&amp; k&lt;=SDLK_z))
+	{
+	  //	  ins=(mLShift||mRShift)?&quot;&#196;&quot;:&quot;&#228;&quot;;
+
+	  /*
+	  cdebug(unicode);
+	  //	  ins=(mLShift||mRShift)?&quot;&#196;&quot;:&quot;&#228;&quot;;
+
+	  cdebug(1);
+	  std::string n=&quot;  &quot;;
+	  //	  ins=&quot;  &quot;;
+	  cdebug(1);
+	  n[1]=(unicode&gt;&gt;8)&amp;0xFF;
+	  cdebug(1);
+	  n[0]=(unicode)&amp;0xFF;
+	  cdebug(1);
+	  ins=AGStringUtf8(n);
+	  cdebug(1);
+	  */
+	  ins=AGStringUtf8(unicode2Utf8(unicode));
+
+	  cdebug((int)ins.toString()[0]&lt;&lt;&quot;  &quot;&lt;&lt;(int)ins.toString()[1]);
+
+	  doInsert=true;
+	}
+      /*      else if(k==SDLK_WORLD_86)
+	{
+	  ins=(mLShift||mRShift)?&quot;&#214;&quot;:&quot;&#246;&quot;;
+	  doInsert=true;
+	}
+      else if(k==SDLK_WORLD_92)
+	{
+	  ins=(mLShift||mRShift)?&quot;&#220;&quot;:&quot;&#252;&quot;;
+	  doInsert=true;
+	}
+      else if(k==SDLK_WORLD_63)
+	{
+	  ins=&quot;&#223;&quot;;
+	  doInsert=true;
+	}
+      */
+      cdebug(&quot;KEY:&quot;&lt;&lt;SDL_GetKeyName(k)&lt;&lt;&quot;  &quot;&lt;&lt;k);
+
+      if(doInsert)
+	{
+	  if(insert(ins))
+	    mCx++;
+	  checkWrap();
+	  return true;
+	}
+      if(used)
+	return true;
+    }
+  return false;
+}
+
+bool AGEdit::insert(const AGStringUtf8 &amp;c)
+{
+  if(mMaxLength&gt;0)
+    {
+      if((int)getText().length()==mMaxLength)
+	{
+	  if(mInserting || mCx==actLine-&gt;length())
+	    return false; // ignore input
+	}
+    }
+  getActLine(); // FIXME:try to cache
+  actLine-&gt;insert(c,mCx,mInserting);
+  return true;
+}
+
+void AGEdit::getActLine()
+{
+  // slow
+  int i=0;
+  std::list&lt;AGEditLine&gt;::iterator j=mLines.begin();
+
+  for(;i!=mCy;i++)
+    j++;
+  actLine=&amp;(*j);
+}
+
+void AGEdit::doDelete(int p)
+{
+  if(p&gt;=0)
+    {
+      getActLine();
+      if(p==(int)actLine-&gt;length() &amp;&amp; mCy&lt;(int)mLines.size()-1)
+	{
+	  // merge 2 lines
+	  mergeLine(mCy);
+	}
+      else
+	actLine-&gt;doDelete(p);
+
+    }
+}
+
+void AGEdit::insertLine(AGEditLine l)
+{
+  std::list&lt;AGEditLine&gt;::iterator j=mLines.begin();
+  for(;&amp;(*j)!=actLine;j++);
+  j++;
+  mLines.insert(j,l);
+}
+
+void AGEdit::mergeLine(int p)
+{
+  if(!mMultiLine)
+    return;
+  std::list&lt;AGEditLine&gt;::iterator j=mLines.begin();
+  int i=0;
+  for(;i&lt;p;i++)
+    j++;
+  actLine=&amp;(*j);
+  j++;
+  actLine-&gt;append(j-&gt;getText());
+  bool h=j-&gt;hardEnd();
+  mLines.erase(j);
+  actLine-&gt;setHardEnd(h);
+}
+
+void AGEdit::setMulti(bool pMultiLine)
+{
+  mMultiLine=pMultiLine;
+}
+
+void AGEdit::checkWrap()
+{
+  if(mWrapLines)
+    {
+      std::list&lt;AGEditLine&gt;::iterator i=mLines.begin();
+      for(;i!=mLines.end();)
+	{
+	  std::pair&lt;AGStringUtf8,bool&gt; n=i-&gt;checkWrap((int)width());
+	  if(n.first.length())
+	    {
+	      // make new line
+	      if(i-&gt;length()&lt;mCx)
+		{
+		  mCx-=i-&gt;length();
+		  mCy++;
+		}
+	      i++;
+	      if(n.second) // is hard end
+		{
+		  AGEditLine l(n.first,actLine-&gt;getFont(),n.second);
+		  l.setAlign(mAlign);
+		  l.setVAlign(mVAlign);
+		  i=mLines.insert(i,l);
+		}
+	      else
+		{
+		  if(i==mLines.end())
+		    {
+		      AGEditLine l(n.first,actLine-&gt;getFont(),n.second);
+		      l.setAlign(mAlign);
+		      l.setVAlign(mVAlign);
+		      mLines.push_back(l);
+		      i=mLines.end();
+		      i--;
+		    }
+		  else
+		    {
+		      // fill line after
+		      i-&gt;prepend(n.first);
+		    }
+		}
+
+	    }
+	  else
+	    i++;
+	}
+     
+      // unwrapping -test
+
+      int cy=0;
+      i=mLines.begin();
+      for(;i!=mLines.end();)
+	{
+	  std::list&lt;AGEditLine&gt;::iterator j=i;
+	  j++;
+	  if(j!=mLines.end() &amp;&amp; !i-&gt;hardEnd())
+	    {
+	      //	      cdebug(i-&gt;getText());
+	      std::pair&lt;AGStringUtf8,bool&gt; nText=i-&gt;checkUnwrap((int)width(),j-&gt;getText());
+	      if(nText.second) // changed
+		{
+		  int count=j-&gt;getText().length()-nText.first.length();
+		  // do nothing
+		  j-&gt;setText(nText.first);
+
+		  // correct cursor position
+		  if(cy==mCy-1)
+		    {
+		      // cursor is in next line
+		      mCx-=count;
+		      if(mCx&lt;0)
+			{
+			  mCy--;
+			  mCx+=i-&gt;length();
+			}
+		    }
+		  else if(cy==mCy)
+		    {
+		      if(mCx&gt;i-&gt;length())
+			{
+			  mCy++;
+			  mCx-=i-&gt;length();
+			}
+		    }
+		  if(nText.first==&quot;&quot;)
+		    {
+		      // empty line
+		      i-&gt;setHardEnd(j-&gt;hardEnd());
+		      mLines.erase(j);
+		    }
+		}
+	      else
+		{
+		  i++;
+		  cy++;
+		}
+	    }
+	  else
+	    {
+	      i++;
+	      cy++;
+	    }
+	}
+ 
+    }
+}
+
+
+void AGEdit::setFont(const AGFont &amp;pFont)
+{
+  mFont=pFont;
+  std::list&lt;AGEditLine&gt;::iterator i=mLines.begin();
+  for(;i!=mLines.end();i++)
+    i-&gt;setFont(mFont);
+
+}
+
+void AGEdit::setText(const AGStringUtf8 &amp;pText)
+{
+  if(getText()==pText)
+    return;
+
+  queryRedraw();
+
+  clear();
+
+  size_t i;
+  for(i=0;i&lt;pText.length();i++)
+    {
+      if(pText[i]=='\n')
+	{
+	  getActLine();
+	  AGEditLine l=actLine-&gt;split(mCx);
+	  l.setAlign(mAlign);
+	  l.setVAlign(mVAlign);
+	  mCx=0;
+	  mCy++;
+	  insertLine(l);
+	  checkWrap();
+	}
+      else
+	{
+	  insert(AGStringUtf8(pText[i]));
+	  mCx++;
+	  checkWrap();
+	}
+    }
+  setFont(mFont); // reset Font
+  checkWrap();
+  //  mCy=0;
+  //  mCx=mT
+  setFont(mFont); // reset Font
+}
+void AGEdit::setMutable(bool pMutable)
+{
+  mMutable=pMutable;
+  mShowCursor=pMutable; // FIXME: show cursor only if widget has focus
+}
+
+void AGEdit::setAlign(AGAlign pAlign)
+{
+  mAlign=pAlign;
+  std::list&lt;AGEditLine&gt;::iterator i=mLines.begin();
+  for(;i!=mLines.end();i++)
+    i-&gt;setAlign(pAlign);
+}
+
+void AGEdit::setVAlign(AGVAlign pVAlign)
+{
+  mVAlign=pVAlign;
+  std::list&lt;AGEditLine&gt;::iterator i=mLines.begin();
+  for(;i!=mLines.end();i++)
+    i-&gt;setVAlign(pVAlign);
+}
+
+void AGEdit::setBackground(const AGBackground &amp;bg)
+{
+  mDrawBackground=true;
+  mBackground=bg;
+}
+
+
+void AGEdit::setBackground(bool pDrawBackground)
+{
+  queryRedraw();
+  mDrawBackground=pDrawBackground;
+}
+
+void AGEdit::setTheme(const AGString &amp;s)
+{
+  queryRedraw();
+  AGString ms=s;
+  if(ms==&quot;&quot;)
+    ms=&quot;edit&quot;;
+
+  AGFont font=getTheme()-&gt;getFont(s+&quot;.font&quot;);
+  setFont(font);
+  mTheme=s;
+
+  AGString t=mTheme;
+  if(t.length())
+    t+=&quot;.&quot;;
+
+  mBackground=AGBackground(t+&quot;background&quot;);
+}
+
+bool AGEdit::canFocus() const
+{
+  return mMutable;
+}
+
+AGEdit &amp;toAGEdit(AGWidget &amp;w)
+{
+  return dynamic_cast&lt;AGEdit&amp;&gt;(w);
+}
+
+AGStringUtf8 AGEdit::getText() const
+{
+  std::ostringstream os;
+  std::list&lt;AGEditLine&gt;::const_iterator i=mLines.begin();
+  for(;i!=mLines.end();)
+    {
+      bool hard=i-&gt;hardEnd();
+      os&lt;&lt;i-&gt;getText().toString();
+      i++;
+      if(i!=mLines.end() &amp;&amp; hard)
+	os&lt;&lt;std::endl;
+    }
+  return AGStringUtf8(os.str());
+}
+
+void AGEdit::clear()
+{
+  mLines.clear();
+  mCx=mCy=0;
+  mViewCy=0;
+  AGFont font1(&quot;FreeSans.ttf&quot;,14);
+  AGEditLine l(&quot;&quot;,font1,true);
+  l.setAlign(mAlign);
+  l.setVAlign(mVAlign);
+  mLines.push_back(l);
+  getActLine();
+}
+
+
+bool AGEdit::eventGotFocus()
+{
+  queryRedraw();
+  return AGWidget::eventGotFocus();
+}
+bool AGEdit::eventLostFocus()
+{
+  queryRedraw();
+  return AGWidget::eventLostFocus();
+}
+
+void AGEdit::prepareDraw()
+{
+  mCursorTime+=SDL_GetTicks()-mCursorLast;
+  mCursorLast=SDL_GetTicks();
+  if(mCursorTime&gt;300 &amp;&amp; mMutable &amp;&amp; hasFocus())
+    {
+      mCursorTime=0;
+      mShowCursor=!mShowCursor;
+      queryRedraw();
+    }
+
+
+  AGWidget::prepareDraw();
+}
+
+void AGEdit::setInsert(bool pInsert)
+{
+  mInserting=pInsert;
+}
+
+/// set Cursor to defined position p in text
+void AGEdit::setCursor(int p)
+{
+  std::list&lt;AGEditLine&gt;::iterator j=mLines.begin();
+
+  mCy=0;
+  mCx=0;
+  for(;j-&gt;length()&lt;p;)
+    {
+      mCy++;
+      p-=j-&gt;length();
+      j++;
+    }
+  mCx=p;
+  actLine=&amp;(*j);
+  
+}

Added: antargis/branches/rant/ext/gui/ag_edit.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_edit.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_edit.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,168 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_edit.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef __AG_EDIT_H
+#define __AG_EDIT_H
+
+#include &quot;ag_widget.h&quot;
+#include &quot;ag_font.h&quot;
+#include &quot;ag_surface.h&quot;
+#include &quot;ag_background.h&quot;
+#include &quot;ag_utf8.h&quot;
+#include &quot;ag_string_utf8.h&quot;
+
+enum AGAlign {EDIT_LEFT,EDIT_RIGHT,EDIT_JUSTIFY,EDIT_CENTER};
+enum AGVAlign {EDIT_TOP,EDIT_BOTTOM,EDIT_VCENTER};
+
+class AGEditLine
+{
+ public:
+  AGEditLine(const AGStringUtf8 &amp;pText,AGFont pFont,bool pHardEnd);
+  virtual ~AGEditLine();
+
+  void setAlign(AGAlign pAlign);
+  void setVAlign(AGVAlign pVAlign);
+
+  virtual void draw(AGPainter &amp;p,const AGVector2 &amp;pPoint,const AGRect2 &amp;pClip);
+  virtual void drawCursor(AGPainter &amp;p,int cx,const AGVector2 &amp;pPoint,const AGRect2 &amp;pClip,const AGColor &amp;c);
+  
+  int height() const;
+  int width() const;
+
+  void insert(const AGStringUtf8 &amp;c,int cx,bool pInsert);
+  void doDelete(int cx);
+  AGEditLine split(int cx);
+
+  int length() const;
+
+  void append(const AGStringUtf8 &amp;s);
+  void prepend(const AGStringUtf8 &amp;s);
+  AGStringUtf8 getText() const;
+  AGFont getFont() const;
+  void setText(const AGStringUtf8 &amp;s);
+
+  bool hardEnd() const;
+  void setHardEnd(bool pHardEnd);
+  std::pair&lt;AGStringUtf8,bool&gt; checkUnwrap(int pW,const AGStringUtf8 &amp;s);
+
+  std::pair&lt;AGStringUtf8,bool&gt; checkWrap(int pW);
+
+  void setFont(const AGFont &amp;pFont);
+
+ private:
+  AGStringUtf8 mText;
+  AGFont mFont;
+  bool mHardEnd;
+  AGAlign mAlign;
+  AGVAlign mVAlign;
+};
+
+class AGEdit:public AGWidget
+{
+ public:
+  AGEdit(AGWidget *pParent,const AGRect2 &amp;pRect);
+
+  virtual void draw(AGPainter &amp;p);
+  virtual void drawBackground(AGPainter &amp;p);
+
+  virtual bool eventKeyDown(AGEvent *m);
+  virtual bool eventKeyUp(AGEvent *m);
+
+  void setMulti(bool mMultiLine);
+
+  bool insert(const AGStringUtf8 &amp;c);
+  void doDelete(int p);
+
+  void setText(const AGStringUtf8 &amp;pText);
+  void setFont(const AGFont &amp;pFont);
+
+  void clear();
+
+  void setMutable(bool pMutable);
+
+  void setAlign(AGAlign pAlign);
+  void setVAlign(AGVAlign pVAlign);
+
+  void setBackground(bool pDrawBackground);
+  void setBackground(const AGBackground &amp;bg);
+
+  void setTheme(const AGString &amp;s);
+
+  bool canFocus() const;
+
+  AGStringUtf8 getText() const;
+
+  void setMaxLength(int i);
+
+  virtual bool eventGotFocus();
+  virtual bool eventLostFocus();
+
+  virtual void prepareDraw();
+
+  void setInsert(bool pInsert);
+
+  void setCursor(int p);
+
+ private:
+
+  void getActLine();
+  void insertLine(AGEditLine l);
+  void mergeLine(int p);
+  void checkWrap();
+
+  std::list&lt;AGEditLine&gt; mLines;
+  AGEditLine *actLine;
+  
+  int mCx,mCy; // cursor position
+  int mViewCy;
+  
+  Uint32 mCursorTime;
+  Uint32 mCursorLast;
+  bool mShowCursor;
+  bool mLShift,mRShift;
+  bool mLCtrl,mRCtrl;
+  bool mLAlt,mRAlt;
+
+  bool mInserting;
+
+  bool mMultiLine;
+
+  bool mWrapLines;
+
+  AGBackground mBackground;
+
+  AGFont mFont;
+
+  AGAlign mAlign;
+  AGVAlign mVAlign;
+
+  bool mMutable;
+  bool mDrawBackground;
+
+  AGString mTheme;
+
+  int mMaxLength;
+};
+
+AGEdit &amp;toAGEdit(AGWidget &amp;w);
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_frame.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_frame.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_frame.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,66 @@
+#include &quot;ag_frame.h&quot;
+#include &quot;ag_screen.h&quot;
+#include &quot;ag_debug.h&quot;
+
+AGFrame::AGFrame(AGWidget *pParent,const AGRect2 &amp;pRect,size_t pWidth):AGWidget(pParent,pRect),
+								       mWidth(pWidth),mBorder(0),mTexture((int)width(),(int)height())
+{
+  mTextureInited=false;
+  mUseTexture=true;
+  mBg=0;
+}
+AGFrame::AGFrame(AGWidget *pParent,const AGRect2 &amp;pRect,const AGBorder &amp;pBorder):AGWidget(pParent,pRect),
+										 mWidth(pBorder.getWidth()),mBorder(new AGBorder(pBorder)),mTexture((int)width(),(int)height())
+{
+  mTextureInited=false;
+  mUseTexture=true;
+  mBg=0;
+}
+
+AGFrame::~AGFrame()
+{
+  delete mBorder;
+  delete mBg;
+}
+
+AGRect2 AGFrame::getClientRect() const
+{
+  return getRect().origin().shrink(mWidth);
+}
+
+void AGFrame::prepareDraw()
+{
+  if(mUseTexture &amp;&amp; mBorder)
+    {
+      //      if(!mTextureInited)
+      if(!mTexture.hasTexture())
+	{
+	  AGPainter p(mTexture);
+	  mBorder-&gt;draw(getRect().origin(),p);
+	  mTextureInited=true;
+
+	}
+    }
+  AGWidget::prepareDraw();
+}
+
+void AGFrame::draw(AGPainter &amp;p)
+{
+  //  CTRACE;
+  if(mBg)
+    {
+      mBg-&gt;draw(getRect().origin(),p);
+    }
+  if(mBorder)
+    {
+      if(mUseTexture &amp;&amp; mTextureInited)
+	p.blit(mTexture,mTexture.getRect());
+      else
+	mBorder-&gt;draw(getRect().origin(),p);
+    }
+}
+
+void AGFrame::setBackground(const AGBackground &amp;pBg)
+{
+  mBg=new AGBackground(pBg);
+}

Added: antargis/branches/rant/ext/gui/ag_frame.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_frame.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_frame.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,33 @@
+#ifndef AG_FRAME_H
+#define AG_FRAME_H
+
+#include &quot;ag_border.h&quot;
+#include &quot;ag_background.h&quot;
+#include &quot;ag_widget.h&quot;
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+class AGFrame:public AGWidget
+{
+ public:
+  AGFrame(AGWidget *pParent,const AGRect2 &amp;pRect,size_t width); // transparent frame
+  AGFrame(AGWidget *pParent,const AGRect2 &amp;pRect,const AGBorder &amp;pBorder);
+  ~AGFrame();
+
+  void setBackground(const AGBackground &amp;pBg);
+
+  AGRect2 getClientRect() const;
+
+  void draw(AGPainter &amp;p);
+  void prepareDraw();
+
+ private:
+  size_t mWidth;
+  AGBorder *mBorder;
+  AGBackground *mBg;
+  AGTexture mTexture;
+  bool mTextureInited;
+  bool mUseTexture;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_image.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_image.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_image.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_image.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_image.h&quot;
+#include &quot;ag_debug.h&quot;
+
+AGImage::AGImage(AGWidget *pParent,const AGRect2 &amp;r,AGSurface pSurface,bool pTile):
+  AGWidget(pParent,r),
+  mTexture(pSurface),mTile(pTile)
+{
+  mCenter=true;
+  //  CTRACE;
+  /*  if(pRect!=pSurface.getRect() &amp;&amp; pRect.w()!=0 &amp;&amp; pRect.h()!=0)
+    {
+      //      mSrcRect=pRect;
+
+      setHeight(pRect.h());
+      setWidth(pRect.w());
+      }*/
+}
+AGImage::AGImage(AGWidget *pParent,const AGRect2 &amp;r,AGTexture pTexture,bool pTile):
+  AGWidget(pParent,r),
+  mTexture(pTexture),mTile(pTile)
+{
+  mCenter=true;
+  //  CTRACE;
+  /*  if(pRect!=pTexture.getRect() &amp;&amp; pRect.w()!=0 &amp;&amp; pRect.h()!=0)
+    {
+      mSrcRect=pRect;
+
+      setHeight(pRect.h());
+      setWidth(pRect.w());
+      }*/
+}
+
+
+
+AGImage::~AGImage()
+{
+}
+
+void AGImage::draw(AGPainter &amp;p)
+{
+  // do always center for now
+  bool center=true;
+
+
+  if(mTile)
+    {
+      //      if(mSrcRect.w()==0 || mSrcRect.h()==0)
+      //	mSrcRect=mTexture.getRect();
+      p.tile(mTexture,getRect().origin());//,mSrcRect);
+    }
+  else if(center)
+    {
+      
+      AGRect2 mr=getRect().origin();
+
+      if(mCenter)
+	mr+=AGVector2((width()-mTexture.width())/2,(height()-mTexture.height())/2);
+
+      p.blit(mTexture,mr);
+    }
+  else
+    p.blit(mTexture,getRect().origin());
+}
+
+void AGImage::setSurface(const AGSurface &amp;pSurface)
+{
+  AGTexture t(pSurface);
+  mTexture=t;
+  queryRedraw();
+}
+void AGImage::setTexture(const AGTexture &amp;pTexture)
+{
+  mTexture=pTexture;
+  queryRedraw();
+}
+
+void AGImage::useTextures()
+{
+  mTexture.useTexture();
+}
+
+void AGImage::setCenter(bool c)
+{
+  mCenter=c;
+}

Added: antargis/branches/rant/ext/gui/ag_image.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_image.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_image.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_image.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_IMAGE_H
+#define AG_IMAGE_H
+
+#include &quot;ag_widget.h&quot;
+#include &quot;ag_texture.h&quot;
+
+class AGImage:public AGWidget
+{
+ public:
+  AGImage(AGWidget *pParent,const AGRect2 &amp;r,AGSurface pSurface,bool pTile);
+  AGImage(AGWidget *pParent,const AGRect2 &amp;r,AGTexture pTexture,bool pTile);
+  virtual ~AGImage();
+
+  virtual void draw(AGPainter &amp;p);
+
+  void setSurface(const AGSurface &amp;pSurface);
+  void setTexture(const AGTexture &amp;pTexture);
+
+  void useTextures();
+
+  void setCenter(bool c);
+
+ private:
+  AGTexture mTexture;
+  bool mTile;
+  bool mCenter;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_layout.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_layout.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_layout.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,231 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_layout.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_layout.h&quot;
+#include &quot;ag_xml.h&quot;
+#include &quot;ag_tools.h&quot;
+#include &quot;ag_theme.h&quot;
+#include &quot;ag_listbox.h&quot;
+#include &quot;ag_combo.h&quot;
+#include &quot;ag_image.h&quot;
+#include &quot;ag_frame.h&quot;
+
+#include &quot;ag_button.h&quot;
+#include &quot;ag_edit.h&quot;
+#include &quot;ag_window.h&quot;
+#include &quot;ag_text.h&quot;
+#include &quot;ag_main.h&quot;
+#include &quot;ag_video.h&quot;
+
+#include &quot;ag_layoutfactory.h&quot;
+
+// keep in mind: ag_local.h must be included after ruby.h!!!
+#include &quot;ag_local.h&quot;
+
+AGLayout::AGLayout(AGWidget *pgParent):
+  AGWidget(pgParent,AGRect2(0,0,0,0))
+{
+  CTRACE;
+}
+
+void AGLayout::loadXML(const std::string &amp;pXMLData)
+{
+  CTRACE;
+
+  // disable GC here
+  // marking makes problems here - as the widgets are not inserted into the tree 
+  // when _() is called, which itself is a ruby-dependent thingy
+  Document p;
+  p.parseMemory(pXMLData);
+
+
+	cdebug(&quot;dump of XML:&quot;&lt;&lt;p.toString());
+
+
+  AGWidget *pgParent=getParent();
+
+  AGRect2 geom;
+  AGString geomS=p.root().get(&quot;geometry&quot;);
+  if(geomS.length())
+    geom=AGRect2(geomS);
+  else if(getParent())
+    geom=pgParent-&gt;getRect().origin();
+  else
+    geom=AGRect2(0,0,getVideo()-&gt;width(),getVideo()-&gt;height());
+
+
+  cdebug(&quot;GEOMETRY:&quot;&lt;&lt;geom.toString());
+
+  setRect(geom);
+  setName(p.root().get(&quot;name&quot;));
+
+  parseChildren(this,p.root());
+
+
+  if(mTabIndices.size())
+    {
+      AGWidget *w=mTabIndices.begin()-&gt;second;
+      w-&gt;gainCompleteFocus(); // is ok, because till here layout isn't inserted into screen yet
+    }
+}
+
+bool AGLayout::eventKeyDown(AGEvent *m)
+{
+  if(m-&gt;getKey()==SDLK_TAB)
+    {
+      // search element, which has focus
+      std::map&lt;int,AGWidget*&gt;::iterator i=mTabIndices.begin();
+
+      for(;i!=mTabIndices.end();i++)
+	if(i-&gt;second-&gt;hasFocus())
+	  break;
+
+      if(i!=mTabIndices.end())
+	i++;
+      if(i==mTabIndices.end())
+	i=mTabIndices.begin();
+      if(i!=mTabIndices.end())
+	i-&gt;second-&gt;gainFocus();
+
+      return true;
+    }
+  else
+    return AGWidget::eventKeyDown(m);
+}
+
+
+void AGLayout::addTabIndex(int i,AGWidget *pWidget)
+{
+  mTabIndices[i]=pWidget;
+}
+
+int AGLayout::getNextTabIndex() const
+{
+  if(mTabIndices.size()&gt;0)
+    return mTabIndices.rbegin()-&gt;first+1;
+  else
+    return 1;
+}
+
+
+
+AGLayout *getLayout(AGWidget *pWidget)
+{
+  AGLayout *l=dynamic_cast&lt;AGLayout*&gt;(pWidget);
+  if(l)
+    return l;
+  else if(pWidget-&gt;getParent())
+    return getLayout(pWidget-&gt;getParent());
+  return 0;
+}
+
+
+AGWidget *parseNode(AGWidget *pParent,const Node &amp;pNode)
+{
+  AGString n=pNode.getName();
+
+  AGRect2 geom=getLayoutGeometry(pParent,pNode);
+
+  AGWidget *w=0;
+
+  //  cdebug(&quot;n:&quot;&lt;&lt;n);
+
+  w=getLayoutFactory()-&gt;create(pParent,geom,pNode);
+
+  if(w!=0 &amp;&amp; pNode.get(&quot;name&quot;).length())
+      w-&gt;setName(pNode.get(&quot;name&quot;));
+
+  if(w!=0 &amp;&amp; pNode.get(&quot;visible&quot;)==&quot;false&quot;)
+    w-&gt;hide();
+
+  if(w!=0 &amp;&amp; pNode.get(&quot;tooltip&quot;).length())
+    w-&gt;setTooltip(_(pNode.get(&quot;tooltip&quot;)));
+
+  if(w!=0 &amp;&amp; pNode.get(&quot;tabindex&quot;).length())
+    {
+      AGLayout *l=getLayout(pParent);
+      if(l)
+	{
+	  l-&gt;addTabIndex(pNode.get(&quot;tabindex&quot;).toInt(),w);
+	}
+      else
+	cdebug(&quot;ERROR in parseNode(.):tabindex given but not embedded in layout???&quot;);
+    }
+
+  if(w!=0 &amp;&amp; pNode.get(&quot;cache&quot;)==&quot;true&quot;)
+    w-&gt;setCaching(true);
+
+  parseChildren(w,pNode);
+
+  if(w)
+    w-&gt;initHandlers();
+
+  return w;
+}
+
+AGRect2 getLayoutGeometry(AGWidget *pParent,const Node &amp;pNode)
+{
+  //  TRACE;
+  AGRect2 geom=pParent-&gt;getClientRect();
+  AGTable *t=dynamic_cast&lt;AGTable*&gt;(pParent);
+  //  cdebug(pNode.getName());
+  //  cdebug(geom);
+  if(t)
+    if(pNode.get(&quot;col&quot;)!=&quot;&quot; &amp;&amp; pNode.get(&quot;row&quot;)!=&quot;&quot;)
+      {
+	int col=pNode.get(&quot;col&quot;).toInt();
+	int row=pNode.get(&quot;row&quot;).toInt();
+	
+	geom=t-&gt;getClientRect(col,row);
+	//	assert(pParent-&gt;getRect().origin().contains(geom));
+	//	cdebug(&quot;col:&quot;&lt;&lt;col&lt;&lt;&quot; row:&quot;&lt;&lt;row&lt;&lt;&quot;:&quot;&lt;&lt;geom);
+	if(!pParent-&gt;getRect().origin().contains(geom))
+	  {
+	    std::cerr&lt;&lt;&quot;parent-geometry doesn't contain geom:&quot;&lt;&lt;std::endl;
+	    std::cerr&lt;&lt;&quot;parent:&quot;&lt;&lt;pParent-&gt;getRect().origin()&lt;&lt;&quot; geom:&quot;&lt;&lt;geom&lt;&lt;std::endl;
+	    std::cerr&lt;&lt;&quot;node-name:&quot;&lt;&lt;pNode.getName()&lt;&lt;&quot;  parent-name:&quot;&lt;&lt;pParent-&gt;getName()&lt;&lt;std::endl;
+	  }
+	assert(pParent-&gt;getRect().origin().contains(geom));
+      }
+  
+
+  AGString geomS=pNode.get(&quot;geometry&quot;);
+  if(geomS.length())
+    geom=AGRect2(geomS);
+  return geom;
+}
+
+void parseChildren(AGWidget *pParent,const Node &amp;pNode)
+{
+	TRACE;
+  if(pParent)
+    {
+      Node::const_iterator i=pNode.begin();
+      for(;i!=pNode.end();i++)
+	{
+		cdebug(&quot;I:&quot;&lt;&lt;(*i)-&gt;getName()&lt;&lt;&quot; name:&quot;&lt;&lt;(*i)-&gt;get(&quot;name&quot;));
+	  AGWidget *w=parseNode(pParent,**i);
+	  if(w)
+	    pParent-&gt;addChild(w);
+	}
+    }
+}
+
+

Added: antargis/branches/rant/ext/gui/ag_layout.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_layout.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_layout.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_layout.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_LAYOUT_H
+#define AG_LAYOUT_H
+
+#include &quot;ag_widget.h&quot;
+#include &quot;ag_xml.h&quot;
+
+class AGTable;
+
+class AGLayout:public AGWidget
+{
+ public:
+  AGLayout(AGWidget *pgParent);
+  
+  virtual void loadXML(const std::string &amp;pXMLData);
+
+  void addTabIndex(int i,AGWidget *pWidget);
+
+  virtual bool eventKeyDown(AGEvent *m);
+  int getNextTabIndex() const;
+
+  static void registerLayouts();
+
+ private:
+  std::map&lt;int,AGWidget*&gt; mTabIndices;
+};
+
+AGWidget *parseNode(AGWidget *pParent,const Node &amp;pNode);
+void parseChildren(AGWidget *pParent,const Node &amp;pNode);
+//AGTable *parseTable(AGWidget *pParent,const Node &amp;pNode,const AGRect2 &amp;geom);
+AGRect2 getLayoutGeometry(AGWidget *pParent,const Node &amp;pNode);
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_layoutcreators.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_layoutcreators.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_layoutcreators.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,518 @@
+#include &lt;ag_button.h&gt;
+#include &lt;ag_checkbox.h&gt;
+#include &lt;ag_colorbutton.h&gt;
+#include &lt;ag_combo.h&gt;
+#include &lt;ag_edit.h&gt;
+#include &lt;ag_frame.h&gt;
+#include &lt;ag_image.h&gt;
+#include &lt;ag_layout.h&gt;
+#include &lt;ag_listbox.h&gt;
+#include &lt;ag_local.h&gt;
+#include &lt;ag_radio.h&gt;
+#include &lt;ag_radiogroup.h&gt;
+#include &lt;ag_table.h&gt;
+#include &lt;ag_theme.h&gt;
+#include &lt;ag_window.h&gt;
+#include &lt;ag_screenwidget.h&gt;
+
+#include &quot;ag_layoutfactory.h&quot;
+
+AGWidget *parseNode(AGWidget *pParent,const Node &amp;pNode);
+
+
+// Layout-Factories
+class AGButtonLayoutCreator:public AGLayoutCreator
+{
+ public:
+  REGISTER_COMPONENT(Button,&quot;button&quot;)
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    AGButton *b;
+    AGStringUtf8 caption=_(pNode.get(&quot;caption&quot;));
+    b=new AGButton(pParent,pRect,AGStringUtf8(caption));
+    setResult(b);
+    AGFilename captionImage=pNode.get(&quot;caption-image&quot;);
+    if(captionImage.length())
+      b-&gt;setSurface(AGSurface::load(captionImage),false);
+    if(pNode.get(&quot;enabled&quot;)==&quot;false&quot;)
+      b-&gt;setEnabled(false);
+
+    b-&gt;setTheme(pNode.get(&quot;theme&quot;));
+  }
+};
+
+
+class AGTableLayoutCreator:public AGLayoutCreator
+{
+ public:
+  REGISTER_COMPONENT(Table,&quot;table&quot;)
+
+
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    AGWidget *w=parseTable(pParent,pNode,pRect);
+    pParent-&gt;addChild(w);
+    w=0;
+    setResult(0);
+  }
+
+AGTable *parseTable(AGWidget *pParent,const Node &amp;pNode,const AGRect2 &amp;geom)
+{
+  AGTable *t;
+  t=new AGTable(pParent,geom);
+  setResult(t); // set result - so garbage collector gets to know this one
+
+  int w,h;
+  w=pNode.get(&quot;cols&quot;).toInt();
+  h=pNode.get(&quot;rows&quot;).toInt();
+
+  t-&gt;setName(pNode.get(&quot;name&quot;));
+
+  if(pNode.get(&quot;visible&quot;)==&quot;false&quot;)
+    t-&gt;hide();
+
+
+  std::vector&lt;std::pair&lt;float,bool&gt; &gt; rows(h);
+  std::vector&lt;std::pair&lt;float,bool&gt; &gt; cols(w);
+
+  // parse rows/cols info
+  Node::const_iterator i=pNode.begin();
+  for(;i!=pNode.end();i++)
+    {
+      if((*i)-&gt;getName()==&quot;colsize&quot;)
+	{
+	  int id=(*i)-&gt;get(&quot;col&quot;).toInt();
+	  assert(id&gt;=0 &amp;&amp; id&lt;w);
+	  //	  cdebug(&quot;id:&quot;&lt;&lt;id);
+	  AGString s=(*i)-&gt;get(&quot;fixed&quot;);
+	  //	  cdebug(&quot;fixed:&quot;&lt;&lt;s);
+	  if(s.length())
+	    cols[id]=std::make_pair(s.toFloat(),true);
+	  else
+	    {
+	      s=(*i)-&gt;get(&quot;relative&quot;);
+	      //	      cdebug(&quot;relative:&quot;&lt;&lt;s);
+	      cols[id]=std::make_pair(s.toFloat(),false);
+	    }
+	}
+      else if((*i)-&gt;getName()==&quot;rowsize&quot;)
+	{
+	  int id=(*i)-&gt;get(&quot;row&quot;).toInt();
+	  assert(id&gt;=0 &amp;&amp; id&lt;h);
+
+	  AGString s=(*i)-&gt;get(&quot;fixed&quot;);
+	  if(s.length())
+	    rows[id]=std::make_pair(s.toFloat(),true);
+	  else
+	    {
+	      s=(*i)-&gt;get(&quot;relative&quot;);
+	      rows[id]=std::make_pair(s.toFloat(),false);
+	    }
+	}
+    }
+
+  for(int k=0;k&lt;w;k++)
+    {
+      if(cols[k].first==0.0f) // not inited
+	t-&gt;addColumn(1.0f);
+      else if(cols[k].second)
+	t-&gt;addFixedColumn(cols[k].first);
+      else
+	t-&gt;addColumn(cols[k].first);
+    }
+  for(int k=0;k&lt;h;k++)
+    {
+      if(rows[k].first==0.0f) // not inited
+	t-&gt;addRow(1.0f);
+      else if(rows[k].second)
+	t-&gt;addFixedRow(rows[k].first);
+      else
+	t-&gt;addRow(rows[k].first);
+    }
+
+  // now get children
+
+  i=pNode.begin();
+  for(;i!=pNode.end();i++)
+    {
+      AGWidget *w=parseNode(t,**i);
+      if(w)
+	{
+	  int col=(*i)-&gt;get(&quot;col&quot;).toInt();
+	  int row=(*i)-&gt;get(&quot;row&quot;).toInt();
+	  //	  cdebug(col&lt;&lt;&quot;/&quot;&lt;&lt;row);
+	  t-&gt;addChild(col,row,w);
+	}
+    }
+  //  t-&gt;arrange();
+
+  if(pNode.get(&quot;cache&quot;)==&quot;true&quot;)
+    t-&gt;setCaching(true);
+
+  return t;
+}
+
+
+};
+
+class AGWindowLayoutCreator:public AGLayoutCreator
+{
+ public:
+  REGISTER_COMPONENT(Window,&quot;window&quot;)
+  
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    AGStringUtf8 title=_(pNode.get(&quot;title&quot;));
+    AGString theme=pNode.get(&quot;theme&quot;);
+    
+    AGWidget *w=new AGWindow(pParent,pRect,AGStringUtf8(title),theme);
+    setResult(w);
+  }
+};
+
+IMPLEMENT_COMPONENT_FACTORY(Table);
+IMPLEMENT_COMPONENT_FACTORY(Button);
+IMPLEMENT_COMPONENT_FACTORY(Window);
+
+
+// AGText creator
+class AGTextLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(Text,&quot;text&quot;)
+
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    //    AGWidget *w=new AGText(pParent,pRect,text,font);
+    AGEdit *w=new AGEdit(pParent,pRect);
+    setResult(w);
+
+
+    AGStringUtf8 text=_(pNode.get(&quot;caption&quot;));
+    text=text.replace(&quot;\\n&quot;,&quot;\n&quot;);
+    w-&gt;setText(AGStringUtf8(text));
+    AGString fontname=pNode.get(&quot;font&quot;);
+    if(fontname==&quot;&quot;)
+      fontname=&quot;text.font&quot;;
+
+    AGFont font;
+    font=getTheme()-&gt;getFont(fontname);
+    w-&gt;setFont(font);
+    
+    if(pNode.get(&quot;align&quot;)==&quot;left&quot;)
+      w-&gt;setAlign(EDIT_LEFT);
+    if(pNode.get(&quot;align&quot;)==&quot;right&quot;)
+      w-&gt;setAlign(EDIT_RIGHT);
+    if(pNode.get(&quot;align&quot;)==&quot;center&quot;)
+      w-&gt;setAlign(EDIT_CENTER);
+
+    if(pNode.get(&quot;valign&quot;)==&quot;top&quot;)
+      w-&gt;setVAlign(EDIT_TOP);
+    if(pNode.get(&quot;valign&quot;)==&quot;bottom&quot;)
+      w-&gt;setVAlign(EDIT_BOTTOM);
+    if(pNode.get(&quot;valign&quot;)==&quot;center&quot;)
+      w-&gt;setVAlign(EDIT_VCENTER);
+
+    //    w-&gt;setAlign(EDIT_CENTER);
+    w-&gt;setMutable(false);
+    w-&gt;setBackground(false);
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(Text);
+
+
+// AGText creator
+class AGEditLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(Edit,&quot;edit&quot;)
+
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    CTRACE;
+    AGString text=pNode.get(&quot;text&quot;);
+    bool multi=pNode.get(&quot;multi&quot;)==&quot;true&quot;;
+    
+    //    AGWidget *w=new AGText(pParent,pRect,text,font);
+    AGEdit *w=new AGEdit(pParent,pRect);
+    setResult(w);
+    w-&gt;setText(AGStringUtf8(text));
+    if(pNode.get(&quot;font&quot;)!=&quot;&quot;)
+    {
+      AGFont font;
+      font=getTheme()-&gt;getFont(pNode.get(&quot;font&quot;));
+      w-&gt;setFont(font);
+    }
+    //    w-&gt;setAlign(EDIT_CENTER);
+    w-&gt;setMutable(true);//false);
+    w-&gt;setBackground(true);//false);
+    w-&gt;setMulti(multi);
+    if(!multi)
+      w-&gt;setVAlign(EDIT_VCENTER);
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(Edit);
+
+
+
+// AGListBox creator
+class AGListBoxLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(ListBox,&quot;listBox&quot;)
+
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    setResult(new AGListBox(pParent,pRect));
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(ListBox);
+
+
+// AGComboBox creator
+class AGComboBoxLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(ComboBox,&quot;comboBox&quot;)
+
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    CTRACE;
+    AGComboBox *l=new AGComboBox(pParent,pRect);
+    setResult(l);
+
+    Node::const_iterator i=pNode.begin();
+    for(;i!=pNode.end();i++)
+      {
+	if((*i)-&gt;getName()==&quot;item&quot;)
+	  l-&gt;insertItem((*i)-&gt;get(&quot;id&quot;),AGStringUtf8((*i)-&gt;get(&quot;text&quot;)));
+      }
+
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(ComboBox);
+
+
+
+// AGLayout creator
+class AGLayoutLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(Layout,&quot;layout&quot;)
+
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    CTRACE;
+    AGFilename filename=pNode.get(&quot;filename&quot;);
+    AGWidget *w=new AGWidget(pParent,pRect);
+    setResult(w);
+    AGLayout *l=new AGLayout(w);
+    l-&gt;loadXML(loadFile(filename));//pRect);
+    w-&gt;addChild(l);
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(Layout);
+
+
+// AGLayout creator
+class AGImageLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(Image,&quot;image&quot;)
+
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    AGFilename filename=pNode.get(&quot;filename&quot;);
+
+    AGSurface s(0,0);
+    if(filename.length())
+      s=AGSurface::load(filename);
+
+    AGRect2 r=pRect;
+    if(pNode.get(&quot;x&quot;).length())
+      r.setX(pNode.get(&quot;x&quot;).toFloat());
+    if(pNode.get(&quot;y&quot;).length())
+      r.setY(pNode.get(&quot;y&quot;).toFloat());
+
+#warning &quot;add subsurfaces&quot;
+    
+
+    AGWidget *w;
+
+    if(pNode.get(&quot;tile&quot;)==&quot;true&quot;)
+      w=new AGImage(pParent,r,s,true);
+    else
+      w=new AGImage(pParent,r,s,false);
+
+    setResult(w);
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(Image);
+
+
+// AGLayout creator
+class AGFrameLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(Frame,&quot;frame&quot;)
+
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    CTRACE;
+    AGString border=pNode.get(&quot;border&quot;);
+    size_t width=pNode.get(&quot;width&quot;).toInt();
+
+    AGFrame *w;
+    if(border.length())
+      w=new AGFrame(pParent,pRect,AGBorder(border));
+    else
+      w=new AGFrame(pParent,pRect,width);
+
+    setResult(w);
+    if(pNode.get(&quot;background&quot;).length())
+      w-&gt;setBackground(AGBackground(pNode.get(&quot;background&quot;)));
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(Frame);
+
+
+// AGLayout creator
+class AGCellLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(Cell,&quot;cell&quot;)
+
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    setResult(new AGWidget(pParent,pRect));
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(Cell);
+
+
+// AGRadio creator
+class AGCheckBoxLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(CheckBox,&quot;checkBox&quot;)
+
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    AGCheckBox *b=new AGCheckBox(pParent,pRect);
+    AGStringUtf8 caption=_(pNode.get(&quot;caption&quot;));
+    if(caption.length())
+      b-&gt;setCaption(AGStringUtf8(caption));
+
+    std::string captionImage=pNode.get(&quot;caption-image&quot;);
+    if(captionImage.length())
+      b-&gt;setSurface(AGSurface::load(captionImage),false);
+    if(pNode.get(&quot;enabled&quot;)==&quot;false&quot;)
+      b-&gt;setEnabled(false);
+    if(pNode.get(&quot;theme&quot;).length())
+      b-&gt;setTheme(pNode.get(&quot;theme&quot;));
+    if(pNode.get(&quot;checked&quot;)==&quot;true&quot;)
+      b-&gt;setChecked(true);
+
+    if(pNode.get(&quot;disabledImage&quot;)!=&quot;&quot; &amp;&amp; pNode.get(&quot;enabledImage&quot;)!=&quot;&quot;)
+      {
+	b-&gt;setSurfaces(AGSurface::load(pNode.get(&quot;disabledImage&quot;)),AGSurface::load(pNode.get(&quot;enabledImage&quot;)));
+      }
+      
+
+    setResult(b);
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(CheckBox);
+
+// Layout-Factories
+class AGColorButtonLayoutCreator:public AGLayoutCreator
+{
+ public:
+  REGISTER_COMPONENT(ColorButton,&quot;colorButton&quot;)
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    setResult(new AGColorButton(pParent,pRect,pNode.get(&quot;gridx&quot;).toInt(),pNode.get(&quot;gridy&quot;).toInt()));
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(ColorButton);
+
+
+
+// AGRadioGroup creator
+class AGRadioGroupLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(RadioGroup,&quot;radioGroup&quot;)
+
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    setResult(new AGRadioGroup(pParent,pRect));
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(RadioGroup);
+
+// AGRadio creator
+class AGRadioLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(Radio,&quot;radio&quot;)
+
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    AGRadio *b=new AGRadio(pParent,pRect);
+    AGStringUtf8 caption=_(pNode.get(&quot;caption&quot;));
+    if(caption.length())
+      b-&gt;setCaption(AGStringUtf8(caption));
+
+    AGFilename captionImage=pNode.get(&quot;caption-image&quot;);
+    if(captionImage.length())
+      b-&gt;setSurface(AGSurface::load(captionImage),false);
+    if(pNode.get(&quot;enabled&quot;)==&quot;false&quot;)
+      b-&gt;setEnabled(false);
+    if(pNode.get(&quot;theme&quot;).length())
+      b-&gt;setTheme(pNode.get(&quot;theme&quot;));
+    if(pNode.get(&quot;checked&quot;)==&quot;true&quot;)
+      b-&gt;setChecked(true);
+    setResult(b);
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(Radio);
+
+
+
+class AGScreenWidgetLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(ScreenWidget,&quot;screenWidget&quot;)
+
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+  {
+    CTRACE;
+    setResult(new AGScreenWidget());
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(ScreenWidget);
+
+
+void AGLayout::registerLayouts()
+{
+	TRACE;
+  getLayoutFactory()-&gt;addCreator(&quot;checkBox&quot;,new AGCheckBoxLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;colorButton&quot;,new AGColorButtonLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;table&quot;,new AGTableLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;button&quot;,new AGButtonLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;window&quot;,new AGWindowLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;text&quot;,new AGTextLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;edit&quot;,new AGEditLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;listBox&quot;,new AGListBoxLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;comboBox&quot;,new AGComboBoxLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;layout&quot;,new AGLayoutLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;image&quot;,new AGImageLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;frame&quot;,new AGFrameLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;cell&quot;,new AGCellLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;radioGroup&quot;,new AGRadioGroupLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;radio&quot;,new AGRadioLayoutCreator);
+//  getLayoutFactory()-&gt;addCreator(&quot;miniMap&quot;,new AGMiniMapLayoutCreator);
+  getLayoutFactory()-&gt;addCreator(&quot;screenWidget&quot;,new AGScreenWidgetLayoutCreator);
+
+}

Added: antargis/branches/rant/ext/gui/ag_layoutfactory.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_layoutfactory.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_layoutfactory.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_layoutfactory.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_layoutfactory.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_kill.h&quot;
+
+AGLayoutCreator::AGLayoutCreator():mWidget(0)
+{
+}
+
+void AGLayoutCreator::create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+{
+}
+
+void AGLayoutCreator::setResult(AGWidget *pWidget)
+{
+  mWidget=pWidget;
+}
+AGWidget *AGLayoutCreator::getResult()
+{
+  return mWidget;
+}
+
+void AGLayoutCreator::clearResult()
+{
+  mWidget=0;
+}
+
+void AGLayoutCreator::mark()
+{
+  if(mWidget)
+    markObject(mWidget);
+}
+
+
+
+AGLayoutFactory::AGLayoutFactory()
+{
+  REGISTER_SINGLETON(this);
+}
+
+AGLayoutFactory::~AGLayoutFactory()
+{
+}
+
+void AGLayoutFactory::addCreator(const AGString &amp;pName,AGLayoutCreator *creator)
+{
+  mCreators[pName]=creator;
+}
+
+void AGLayoutFactory::removeCreator(const AGString &amp;pName,AGLayoutCreator *creator)
+{
+  std::map&lt;AGString,AGLayoutCreator*&gt;::iterator i=mCreators.find(pName);
+  if(i-&gt;second==creator)
+    mCreators.erase(i);
+}
+
+
+AGWidget *AGLayoutFactory::create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode)
+{
+  AGLayoutCreator *creator=mCreators[pNode.getName()];
+
+  if(creator)
+    {
+      AGWidget *w;
+      creator-&gt;create(pParent,pRect,pNode);
+      w=creator-&gt;getResult();
+      creator-&gt;clearResult();
+
+      return w;
+    }
+  std::string name;
+  if(name!=&quot;&quot; &amp;&amp; name!=&quot;colsize&quot; &amp;&amp; name!=&quot;rowsize&quot;)
+    {
+      cdebug(&quot;no creation at:&quot;&lt;&lt;name);
+    }
+  return 0;
+}
+  
+AGLayoutFactory *mLayoutFactory=0;
+AGLayoutFactory *getLayoutFactory()
+{
+  if(!mLayoutFactory)
+    mLayoutFactory=new AGLayoutFactory;
+  return mLayoutFactory;
+}
+
+
+

Added: antargis/branches/rant/ext/gui/ag_layoutfactory.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_layoutfactory.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_layoutfactory.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_layoutfactory.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_LAYOUTFACTORY_H
+#define AG_LAYOUTFACTORY_H
+
+#include &lt;ag_singleton.h&gt;
+#include &lt;ag_utf8.h&gt;
+#include &lt;ag_widget.h&gt;
+#include &lt;ag_xml.h&gt;
+
+class AGLayoutCreator:public AGSingleton
+{
+ public:
+  AGLayoutCreator();//const AGString &amp;pName);
+  //  virtual ~AGLayoutCreator();
+  virtual void create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode);
+  void setResult(AGWidget *pWidget);
+  AGWidget *getResult();
+
+  void clearResult();
+
+  void mark();
+ private:
+  AGWidget *mWidget;
+    //std::string mName;
+
+};
+
+class AGLayoutFactory
+{
+  std::map&lt;AGString,AGLayoutCreator*&gt; mCreators;
+
+  AGLayoutFactory();
+ public:
+  ~AGLayoutFactory();
+
+  void addCreator(const AGString &amp;pName,AGLayoutCreator *creator);
+  void removeCreator(const AGString &amp;pName,AGLayoutCreator *creator);
+
+  AGWidget *create(AGWidget *pParent,const AGRect2 &amp;pRect,const Node &amp;pNode);
+  
+  friend AGLayoutFactory *getLayoutFactory();
+};
+
+AGLayoutFactory *getLayoutFactory();
+/*
+#define IMPLEMENT_COMPONENT_FACTORY(CLASS) \
+AG##CLASS##LayoutCreator factory_##CLASS
+
+#define REGISTER_COMPONENT(CLASS,NAME) AG##CLASS##LayoutCreator():AGLayoutCreator(NAME){}
+*/
+
+#define IMPLEMENT_COMPONENT_FACTORY(CLASS)
+#define REGISTER_COMPONENT(CLASS,NAME)
+
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_listbox.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_listbox.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_listbox.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,272 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_listbox.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_edit.h&quot;
+#include &quot;ag_listbox.h&quot;
+#include &quot;ag_theme.h&quot;
+#include &quot;ag_scroller.h&quot;
+#include &quot;ag_stringstream.h&quot;
+
+#include &lt;sstream&gt;
+
+AGListBoxItem::AGListBoxItem(AGString pID,AGStringUtf8 pValue)
+{
+  id=pID;
+  value=pValue;
+}
+
+AGListBox::AGListBox(AGWidget *pParent,const AGRect2 &amp;pRect):AGWidget(pParent,pRect),
+							     sigSelect(this,&quot;sigSelect&quot;),
+							     sigDoubleClick(this,&quot;sigDoubleClick&quot;)
+{
+  mBackground=AGBackground(&quot;listbox.background&quot;);
+  mHilight=AGBackground(&quot;listbox.selected&quot;);
+  // insert AGEdits
+  int y=0;
+  int count=0;
+  mItemHeight=getTheme()-&gt;getInt(&quot;listbox.item.height&quot;);
+  if(mItemHeight&lt;5)
+    mItemHeight=25;
+
+  AGFont f=getTheme()-&gt;getFont(&quot;listbox.font&quot;);
+
+
+  mScroller=new AGScroller(this,AGRect2(width()-mItemHeight,0,mItemHeight,height()),false);
+  addChild(mScroller);
+
+  mScroller-&gt;sigValueChanged.connect(slot(this,&amp;AGListBox::eventScroller));
+
+  for(;y&lt;pRect.h();y+=mItemHeight,count++)
+    {
+      AGRect2 r(0,y,pRect.w()-mItemHeight,mItemHeight);
+      //      cdebug(r);
+      AGEdit *e=new AGEdit(this,r);
+      e-&gt;setMutable(false);
+      e-&gt;setBackground(false);
+      e-&gt;setFont(f);
+      AGStringStream os;
+      os&lt;&lt;&quot;ListBoxItem&quot;&lt;&lt;count;
+      e-&gt;setName(os.str());
+
+      mEdits.push_back(e);
+      addChild(e);
+    }
+  mHeight=count;
+  mY=0;
+  mSelected=-1;
+}
+
+void AGListBox::insertItem(AGString pID,AGStringUtf8 pValue)
+{
+  mItems.push_back(AGListBoxItem(pID,pValue));
+  arrange();
+}
+void AGListBox::selectItem(AGString pID)
+{
+  for(size_t i=0;i&lt;mItems.size();i++)
+    if(mItems[i].id==pID)
+      {
+	mSelected=i;
+	mY=std::max(0,int(i)-mHeight/2); // FIXME: maybe find better zoom
+      }
+  arrange();
+}
+
+AGString AGListBox::getSelectedID() const
+{
+  if(mSelected&gt;=0 &amp;&amp; size_t(mSelected)&lt;mItems.size())
+    return mItems[mSelected].id;
+  return &quot;&quot;;
+}
+
+AGString AGListBox::getSelectedValue() const
+{
+  if(mSelected&gt;=0 &amp;&amp; size_t(mSelected)&lt;mItems.size())
+    return mItems[mSelected].id;
+  return &quot;&quot;;
+}
+
+bool AGListBox::eventKeyDown(AGEvent *m)
+{
+  if(m-&gt;isSDLEvent())
+    {
+      SDLKey k=m-&gt;getKey();
+      if(k==SDLK_UP)
+	{
+	  if(mSelected&lt;2 &amp;&amp; mItems.size()&gt;0)
+	    mSelected=0;
+	  else
+	    mSelected--;
+	  if(mSelected&lt;mY)
+	    mY=mSelected;
+	  arrange();
+	  return true;
+	}
+      else if(k==SDLK_DOWN)
+	{
+	  if(mSelected&lt;int(mItems.size())-1)
+	    mSelected++;
+	  if(mSelected&gt;=mY+mHeight)
+	    mY++;
+	  arrange();
+	  return true;
+	}
+    }
+  return AGWidget::eventKeyDown(m);
+}
+
+
+void AGListBox::arrange()
+{
+  size_t y,y2=0;
+  
+  // first clear all
+  for(y=0;y&lt;mEdits.size();y++)
+    mEdits[y]-&gt;setText(&quot;&quot;);
+
+  for(y=mY,y2=0;y&lt;(size_t)(mY+mHeight) &amp;&amp; y&lt;mItems.size();y++,y2++)
+    mEdits[y2]-&gt;setText(mItems[y].value);
+
+  updateScroller();
+}
+
+void AGListBox::draw(AGPainter &amp;p)
+{
+  mBackground.draw(getRect().origin(),p);
+  p.pushMatrix();
+
+  if(mSelected&gt;=0 &amp;&amp; mSelected&lt;(int)mItems.size())
+    {
+      int y=mSelected-mY;
+      
+      AGRect2 r(0,y*mItemHeight,width(),mItemHeight);
+      p.transform(r);
+      mHilight.draw(getRect().origin(),p);
+    }
+  p.popMatrix();
+  AGWidget::draw(p);
+}
+
+bool AGListBox::eventMouseClick(AGEvent *e)
+{
+  CTRACE;
+  if(e-&gt;isSDLEvent())
+    {
+      AGVector2 p=e-&gt;getMousePosition();
+
+      int b=e-&gt;getButton();
+      //      cdebug(b);
+      if(b==4)
+	{
+	  // up wheel
+	  if(mY&gt;0)
+	    mY--;
+	  arrange();
+	  return true;
+	}
+      else if(b==5)
+	{
+	  // down wheel
+	  if(mY&lt;=(int)mItems.size()-mHeight)
+	    mY++;
+	  arrange();
+	  return true;
+	}
+      else
+	{
+
+	  int y=(int)(p[1]-getScreenRect().y());
+	  //	  cdebug(&quot;y:&quot;&lt;&lt;y);
+	  y/=mItemHeight;
+	  //	  cdebug(&quot;y:&quot;&lt;&lt;y);
+	  //	  cdebug(mItemHeight);
+	  int n=y+mY;
+	  //	  cdebug(&quot;n:&quot;&lt;&lt;n);
+	  if(n&lt;(int)mItems.size())
+	    mSelected=n;
+
+	  e-&gt;setName(&quot;sigSelect&quot;);
+	      
+	  sigSelect(e);
+	  return true;
+	}
+    }
+  return false;
+}
+
+AGListBox &amp;toAGListBox(AGWidget &amp;w)
+{
+  return dynamic_cast&lt;AGListBox&amp;&gt;(w);
+}
+
+void AGListBox::clearList()
+{
+  mY=mSelected=0;
+  mItems.clear();
+}
+
+bool AGListBox::eventMouseButtonDown(AGEvent *m)
+{
+  // ensure that event is eaten
+  bool r=AGWidget::eventMouseButtonDown(m);
+  if(m-&gt;isSDLEvent())
+    if(getScreenRect().contains(m-&gt;getMousePosition()))
+      return true;
+  return r;
+}
+bool AGListBox::eventMouseButtonUp(AGEvent *m)
+{
+  // ensure that event is eaten
+  bool r=AGWidget::eventMouseButtonUp(m);
+  if(m-&gt;isSDLEvent())
+    if(getScreenRect().contains(m-&gt;getMousePosition()))
+      return true;
+  return r;
+}
+
+bool AGListBox::eventScroller(AGEvent *e)
+{
+  mY=(int)mScroller-&gt;getValue();
+  arrange();
+  return false;
+}
+
+void AGListBox::updateScroller()
+{
+  // update scroller
+  {
+    int itemCount=mItems.size();
+    int visibleCount=(int)(height()/mItemHeight);
+
+    int maxVal=std::max(0,itemCount-visibleCount);
+
+    /*    cdebug(&quot;maxVal:&quot;&lt;&lt;maxVal);
+    cdebug(&quot;vis:&quot;&lt;&lt;visibleCount);
+    cdebug(&quot;items:&quot;&lt;&lt;itemCount);
+    cdebug(&quot;my:&quot;&lt;&lt;mY);
+    */
+    mScroller-&gt;setInterval(0,maxVal);
+    mScroller-&gt;setScrollerSize(std::min(visibleCount,maxVal));
+    mScroller-&gt;setValue(mY);
+    mScroller-&gt;setStepping(1);
+  }
+
+}

Added: antargis/branches/rant/ext/gui/ag_listbox.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_listbox.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_listbox.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_listbox.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef __AG_LISTBOX_H
+#define __AG_LISTBOX_H
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &quot;ag_widget.h&quot;
+#include &quot;ag_background.h&quot;
+
+class AGEdit;
+class AGScroller;
+
+struct AGListBoxItem
+{
+  AGListBoxItem(AGString pID,AGStringUtf8 pValue);
+  AGString id;
+  AGStringUtf8 value;
+};
+
+
+// Single selection for a start
+class AGListBox:public AGWidget
+{
+ public:
+  AGListBox(AGWidget *pParent,const AGRect2 &amp;pRect);
+
+  void insertItem(AGString pID,AGStringUtf8 pValue);
+  void selectItem(AGString pID);
+
+  AGString getSelectedID() const;
+  AGString getSelectedValue() const;
+
+  virtual bool eventKeyDown(AGEvent *m);
+
+  AGSignal sigSelect;
+  AGSignal sigDoubleClick;
+
+  virtual void draw(AGPainter &amp;p);
+  virtual bool eventMouseClick(AGEvent *m);
+  virtual bool eventMouseButtonDown(AGEvent *m);
+  virtual bool eventMouseButtonUp(AGEvent *m);
+
+  bool eventScroller(AGEvent *e);
+
+  void clearList();
+
+  void updateScroller();
+
+ private:
+
+  void arrange();
+
+  int mY;
+  std::vector&lt;AGListBoxItem&gt; mItems;
+  int mSelected;
+  int mHeight;
+  int mItemHeight;
+  std::vector&lt;AGEdit*&gt; mEdits;
+  AGBackground mBackground,mHilight;
+
+  AGScroller *mScroller;
+};
+
+
+AGListBox &amp;toAGListBox(AGWidget &amp;w);
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_local.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_local.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_local.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_local.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_local.h&quot;
+#include &quot;ag_debug.h&quot;
+
+
+AGLocalizer *gLocalizer=0;
+
+AGLocalizer::~AGLocalizer()
+{
+  if(gLocalizer==this)
+    gLocalizer=0;
+}
+  
+AGStringUtf8 AGLocalizer::find(const AGString &amp;p)
+{
+  return AGStringUtf8(p);
+}
+
+void setLocalizer(AGLocalizer *p)
+{
+  gLocalizer=p;
+}
+
+AGLocalizer *getLocalizer()
+{
+  return gLocalizer;
+}
+
+
+AGStringUtf8 translate(const AGString &amp;s)
+{
+  AGLocalizer *l=getLocalizer();
+
+  if(l)
+    return l-&gt;find(s);
+  return AGStringUtf8(s);
+}

Added: antargis/branches/rant/ext/gui/ag_local.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_local.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_local.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_local.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_LOCAL_H
+#define AG_LOCAL_H
+
+#include &lt;ag_string.h&gt;
+#include &lt;ag_string_utf8.h&gt;
+
+class AGLocalizer
+{
+ public:
+  virtual ~AGLocalizer();
+  
+  virtual AGStringUtf8 find(const AGString &amp;p);
+  
+};
+
+void setLocalizer(AGLocalizer *p);
+AGLocalizer *getLocalizer();
+
+AGStringUtf8 translate(const AGString &amp;s);
+
+#ifndef SWIG
+#ifdef _
+#undef _
+#endif
+#ifdef __
+#undef __
+#endif
+#define _(x) translate(x)
+#define __(x) translate(x)
+#endif
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_menu.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_menu.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_menu.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,129 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_menu.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_menu.h&quot;
+#include &quot;ag_menuitem.h&quot;
+#include &quot;ag_font.h&quot;
+#include &quot;ag_text.h&quot;
+#include &quot;ag_surface.h&quot;
+#include &quot;ag_theme.h&quot;
+
+#include &quot;ag_debug.h&quot;
+
+using namespace std;
+
+AGMenu::AGMenu(AGWidget *pParent,AGVector2 pWishPos,const AGStringUtf8 &amp;pName):
+  AGTable(pParent,AGRect2(pWishPos[0],pWishPos[1],1,1)),
+  sigSelected(this,&quot;sigSelected&quot;),
+  mName(pName.toString()),
+  mWishPos(pWishPos)
+{
+  mBg=AGTexture(getTheme()-&gt;getSurface(&quot;menu.background.image&quot;));
+  hide();
+  addColumn(1);
+  mW=0;
+  mH=0;
+}
+
+void AGMenu::show(AGVector2 pWishPos)
+{
+  AGWidget::show();
+  mWishPos=pWishPos;
+  AGVector2 p=fromScreen(mWishPos);
+  setTop(p[1]);
+  setLeft(p[0]);
+
+  std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();
+  for(;i!=mChildren.end();i++)
+    cdebug((*i)-&gt;getRect().toString());
+
+}
+
+void AGMenu::addItem(const AGStringUtf8 &amp;pString)
+{
+  AGMenuItem *i=new AGMenuItem(this,pString);
+  addFixedRow(i-&gt;height());
+  
+  addChild(0,getRows()-1,i);
+
+  mW=std::max(mW,i-&gt;width());
+  setWidth(mW);
+  setHeight(mW);
+  arrange();
+}
+
+AGMenu &amp;AGMenu::addMenu(const AGStringUtf8 &amp;pString)
+{
+  AGSubMenu *s=new AGSubMenu(this,pString);
+  addFixedRow(s-&gt;height());
+  addChild(0,getRows()-1,s);
+
+  mH+=s-&gt;height();
+  setWidth(mW);
+  setHeight(mW);
+  arrange();
+
+  return *s-&gt;getMenu();
+}
+
+
+void AGMenu::draw(AGPainter &amp;p)
+{
+  //  cdebug(&quot;draw&quot;);
+  //  return;
+  //  adaptWidthFromChildren();
+  //  AGPainter p(getScreen());
+  p.tile(mBg);//,r.project(getRect()));
+
+  //  cdebug(r.project(getRect()).toString());
+}
+
+void AGMenu::eventItemSelected(const AGString &amp;pString)
+{
+  std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();
+  for(;i!=mChildren.end();i++)
+    {
+      AGMenuItem *item=dynamic_cast&lt;AGMenuItem*&gt;(*i);
+      //cdebug(&quot;item:&quot;&lt;&lt;item);
+      if(item)
+	{
+	  //  cdebug(item-&gt;getName()&lt;&lt;&quot; &quot;&lt;&lt;pString);
+	  if(item-&gt;getSelected() &amp;&amp; item-&gt;getName()!=pString)
+	    {
+	      //  cdebug(&quot;unSelect&quot;);
+	      item-&gt;unSelect();
+	    }
+	}
+    }
+}
+void AGMenu::eventItemClicked(const AGString &amp;pString)
+{
+  sigSelected(new AGEvent(this,pString));
+  
+  AGMenuItem *mi=dynamic_cast&lt;AGMenuItem*&gt;(getParent());
+  if(mi)
+    {
+      AGMenu *m=dynamic_cast&lt;AGMenu*&gt;(mi-&gt;getParent());
+      if(m)
+	m-&gt;eventItemClicked(pString);
+    }
+  hide();
+  cdebug(&quot;hide&quot;);
+}

Added: antargis/branches/rant/ext/gui/ag_menu.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_menu.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_menu.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_menu.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_MENU_H
+#define AG_MENU_H
+
+#include &quot;ag_table.h&quot;
+#include &quot;ag_texture.h&quot;
+
+class AGMenu:public AGTable
+{
+ public:
+  AGMenu(AGWidget *pParent,AGVector2 pWishPos,const AGStringUtf8 &amp;pName);
+
+  void show(AGVector2 pWishPos);
+
+  void addItem(const AGStringUtf8 &amp;pString);
+  AGMenu &amp;addMenu(const AGStringUtf8 &amp;pString);
+
+  void draw(AGPainter &amp;p);
+
+  void eventItemSelected(const AGString &amp;pString);
+  void eventItemClicked(const AGString &amp;pString);
+
+  AGSignal sigSelected;
+
+ private:
+  AGTexture mBg;
+  AGString mName;
+  AGVector2 mWishPos;
+
+  float mW,mH;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_menuitem.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_menuitem.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_menuitem.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,173 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_menuitem.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_menuitem.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_draw.h&quot;
+#include &quot;ag_theme.h&quot;
+#include &quot;ag_image.h&quot;
+#include &quot;ag_menu.h&quot;
+
+AGMenuItem::AGMenuItem(AGWidget *pParent,const AGStringUtf8 &amp;pText):
+  AGTable(pParent,AGRect2(0,0,0,0)),mText(pText),mMouseOver(false),mSelected(false)
+{
+  AGFont font(getTheme()-&gt;getFont(&quot;Font.menu&quot;));
+
+
+  //  adaptWidthFromChildren(); // so that parent can adapt to this
+
+  //  addChild(new AGText(this,AGVector2(0,0),&quot;X&quot;,AGFont(&quot;Arial.ttf&quot;,25))); // test
+  AGSurface surface=getTheme()-&gt;getSurface(&quot;menu.item.image&quot;);//getScreen().loadSurface(&quot;/home/david/projects/oldantargis/graphics/menu_house_small.png&quot;);
+
+  addFixedRow(surface.height());
+  addFixedColumn(surface.width());
+  addColumn(1);
+  arrange();
+
+  addChild(0,0,new AGImage(this,getRect().origin(),surface,false));
+  addChild(1,0,new AGText(this,getRect().origin(),pText,font));
+
+}
+AGMenuItem::~AGMenuItem()
+{
+}
+
+void AGMenuItem::draw(AGPainter &amp;p)//const AGRect2 &amp;pr)
+{
+  //  AGRect2 r=pr.project(getRect());
+
+  AGColor c1,c2,c3,c4;
+
+  AGString style=&quot;.menu&quot;;
+  if(mSelected)//MouseOver)
+    {
+      style+=&quot;.lighted&quot;;
+      
+      AGTheme *theme=getTheme();
+      
+      c1=theme-&gt;getColor(AGString(&quot;gradientColor1&quot;)+style);
+      c2=theme-&gt;getColor(AGString(&quot;gradientColor2&quot;)+style);
+      c3=theme-&gt;getColor(AGString(&quot;gradientColor3&quot;)+style);
+      c4=theme-&gt;getColor(AGString(&quot;gradientColor4&quot;)+style);
+      
+      //      AGSurface s(getScreen());
+      p.drawGradient(p.getRect(),c1,c2,c3,c4);
+    }
+
+
+}
+
+bool AGMenuItem::eventMouseEnter()
+{
+  mMouseOver=true;
+  mSelected=true;
+  eventSelect();
+
+  AGMenu *p=dynamic_cast&lt;AGMenu*&gt;(getParent());
+  //  cdebug(p);
+  if(p)
+    {
+      p-&gt;eventItemSelected(mText.toString());
+    }
+  return false;
+}
+
+bool AGMenuItem::eventMouseLeave()
+{
+  mMouseOver=false;
+  return false;
+}
+
+AGString AGMenuItem::getName() const
+{
+  return mText.toString();
+}
+
+bool AGMenuItem::getSelected() const
+{
+  return mSelected;
+}
+void AGMenuItem::unSelect()
+{
+  mSelected=false;
+  eventUnselect();
+}
+
+void AGMenuItem::eventSelect()
+{
+}
+void AGMenuItem::eventUnselect()
+{
+}
+
+bool AGMenuItem::eventMouseClick(AGEvent *m)
+{
+  cdebug(&quot;bool AGMenuItem::eventMouseClick(const AGEvent *m)&quot;);
+  AGMenu *me=dynamic_cast&lt;AGMenu*&gt;(getParent());
+  if(me)
+    {
+      me-&gt;eventItemClicked(mText.toString());
+      
+      return true;
+    }
+  return false;
+}
+
+// AGSubMenu
+
+AGSubMenu::AGSubMenu(AGWidget *pParent,const AGStringUtf8 &amp;pText):
+  AGMenuItem(pParent,pText)
+{
+  AGSurface surface2=AGSurface::load(&quot;right_arrow.png&quot;);
+  addChildBack(new AGImage(this,getRect().origin(),surface2,false));
+
+  addChild(mSubMenu=new AGMenu(this,AGVector2(0,0),pText));
+  mSubMenu-&gt;hide();
+}
+
+AGSubMenu::~AGSubMenu()
+{
+}
+
+AGMenu *AGSubMenu::getMenu()
+{
+  return mSubMenu;
+}
+
+void AGSubMenu::addChild(AGWidget*pWidget)
+{
+  AGWidget::addChild(pWidget);
+}
+
+void AGSubMenu::eventSelect()
+{
+  AGRect2 r(getScreenRect());
+
+  getMenu()-&gt;show(r.getV10());
+}
+void AGSubMenu::eventUnselect()
+{
+  getMenu()-&gt;hide();
+}
+
+bool AGSubMenu::eventMouseClick(AGEvent *m)
+{
+  return false;
+}

Added: antargis/branches/rant/ext/gui/ag_menuitem.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_menuitem.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_menuitem.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_menuitem.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_MENUITEM_H
+#define AG_MENUITEM_H
+
+#include &quot;ag_text.h&quot;
+#include &quot;ag_table.h&quot;
+
+class AGMenu;
+
+class AGMenuItem:public AGTable
+{
+ public:
+  AGMenuItem(AGWidget *pParent,const AGStringUtf8 &amp;pText);
+  virtual ~AGMenuItem();
+
+  void draw(AGPainter &amp;p);
+
+  virtual bool eventMouseEnter();
+  virtual bool eventMouseLeave();
+  
+  bool getSelected() const;
+  void unSelect();
+
+  AGString getName() const;
+
+  virtual bool eventMouseClick(AGEvent *m);
+
+  virtual void eventSelect();
+  virtual void eventUnselect();
+
+ private:
+  AGStringUtf8 mText;
+  bool mMouseOver;
+  bool mSelected;
+};
+
+class AGSubMenu:public AGMenuItem
+{
+ public:
+  AGSubMenu(AGWidget *pParent,const AGStringUtf8 &amp;ptext);
+  virtual ~AGSubMenu();
+
+  AGMenu *getMenu();
+
+  virtual void eventSelect();
+  virtual void eventUnselect();
+
+  virtual bool eventMouseClick(AGEvent *m);
+
+ private:
+  void addChild(AGWidget*pWidget);
+
+  AGMenu *mSubMenu;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_radio.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_radio.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_radio.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_radio.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+
+#include &quot;ag_radio.h&quot;
+#include &quot;ag_local.h&quot;
+#include &quot;ag_theme.h&quot;
+#include &quot;ag_image.h&quot;
+#include &quot;ag_layoutfactory.h&quot;
+#include &quot;ag_radiogroup.h&quot;
+#include &lt;typeinfo&gt;
+
+
+AGRadio::AGRadio(AGWidget *pParent,AGRect2 pRect):
+  AGCheckBox(pParent,pRect),mGroup(0)
+{
+  // search mGroup
+  AGWidget *w=pParent;
+  AGRadioGroup *g=0;
+  while(w &amp;&amp; g==0)
+    {
+      g=dynamic_cast&lt;AGRadioGroup*&gt;(w);
+      w=w-&gt;getParent();
+    }
+  if(g)
+    mGroup=g;
+
+  if(mGroup)
+    mGroup-&gt;add(this);
+}
+
+AGRadio::~AGRadio()
+{
+  if(mGroup)
+    mGroup-&gt;erase(this);
+}
+
+void AGRadio::setChecked(bool pChecked)
+{
+  bool c=isChecked();
+  if(c!=pChecked)
+    {
+      AGCheckBox::setChecked(pChecked);
+      
+      if(pChecked)
+	{
+	  if(mGroup)
+	    mGroup-&gt;eventChange(getName());
+	}
+    }
+}
+
+void AGRadio::deselect()
+{
+  setChecked(false);
+}
+
+void AGRadio::setGroup(AGRadioGroup *pGroup)
+{
+  mGroup=pGroup;
+}
+
+bool AGRadio::eventMouseClick(AGEvent *m)
+{
+  if(!isChecked())
+    setChecked(true);
+
+  return AGButton::eventMouseClick(m);
+}
+
+
+

Added: antargis/branches/rant/ext/gui/ag_radio.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_radio.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_radio.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_radio.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_RADIO_H
+#define AG_RADIO_H
+
+#include &quot;ag_checkbox.h&quot;
+
+class AGRadioGroup;
+
+class AGRadio:public AGCheckBox
+{
+ public:
+  AGRadio(AGWidget *pParent,AGRect2 pRect);
+  virtual ~AGRadio();
+
+  void setGroup(AGRadioGroup *pGroup);
+  bool eventMouseClick(AGEvent *m);
+  
+  void deselect();
+
+  virtual void setChecked(bool pChecked);
+
+ private:
+  AGRadioGroup *mGroup;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_radiogroup.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_radiogroup.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_radiogroup.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_radiogroup.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+
+#include &quot;ag_radio.h&quot;
+#include &quot;ag_radiogroup.h&quot;
+#include &quot;ag_local.h&quot;
+#include &quot;ag_theme.h&quot;
+#include &quot;ag_image.h&quot;
+#include &quot;ag_layoutfactory.h&quot;
+#include &lt;typeinfo&gt;
+
+
+AGRadioGroup::AGRadioGroup(AGWidget *p,const AGRect2 &amp;r):
+  AGWidget(p,r),
+  sigChanged(this,&quot;sigChanged&quot;)
+{
+}
+AGRadioGroup::~AGRadioGroup()
+{
+  std::set&lt;AGRadio*&gt;::iterator i=mChildren.begin();
+
+  for(;i!=mChildren.end();i++)
+    (*i)-&gt;setGroup(0);
+}
+
+void AGRadioGroup::eventChange(const AGString &amp;p)
+{
+  std::set&lt;AGRadio*&gt;::iterator i=mChildren.begin();
+
+  for(;i!=mChildren.end();i++)
+    {
+      if((*i)-&gt;getName()!=p)
+	(*i)-&gt;deselect();
+    }
+
+}
+
+void AGRadioGroup::add(AGRadio *r)
+{
+  mChildren.insert(r);
+}
+void AGRadioGroup::erase(AGRadio *r)
+{
+  mChildren.erase(r);
+}
+
+
+
+
+

Added: antargis/branches/rant/ext/gui/ag_radiogroup.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_radiogroup.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_radiogroup.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2007 by David Kamphausen. All rights reserved.
+ *
+ * ag_radiogroup.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_RADIOGROUP_H
+#define AG_RADIOGROUP_H
+
+#include &lt;ag_widget.h&gt;
+
+class AGRadio;
+
+// derive from AGWidget, so that it can be put into the hierarchy
+class AGRadioGroup:public AGWidget
+{
+ public:
+  AGRadioGroup(AGWidget *pParent,const AGRect2 &amp;pr);
+  virtual ~AGRadioGroup();
+
+  virtual void eventChange(const AGString &amp;p);
+
+  void add(AGRadio *r);
+  void erase(AGRadio *r);
+  
+  AGSignal sigChanged;
+ private:
+  std::set&lt;AGRadio*&gt; mChildren;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_screenwidget.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_screenwidget.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_screenwidget.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_screenwidget.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_screen.h&quot;
+#include &quot;ag_screenwidget.h&quot;
+#include &quot;ag_surface.h&quot;
+#include &quot;ag_theme.h&quot;
+#include &quot;ag_debug.h&quot;
+
+
+AGScreenWidget::AGScreenWidget():
+  AGWidget(0,getScreen().getRect())
+{
+  //  mTexture=AGTexture(getTheme()-&gt;getSurface(&quot;screen.background.image&quot;));
+}
+AGScreenWidget::~AGScreenWidget()
+{
+}
+
+void AGScreenWidget::draw(AGPainter &amp;p)
+{
+  //  p.clip(AGRect2(10,10,50,50));
+  //p.tile(mTexture);
+  p.fillRect(p.getRect().origin(),AGColor(0,0,0));
+}

Added: antargis/branches/rant/ext/gui/ag_screenwidget.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_screenwidget.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_screenwidget.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_screenwidget.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef AG_SCREENWIDGET_H
+#define AG_SCREENWIDGET_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &quot;ag_widget.h&quot;
+#include &quot;ag_texture.h&quot;
+
+class AGScreenWidget:public AGWidget
+{
+ public:
+  AGScreenWidget();
+  virtual ~AGScreenWidget();
+
+  virtual void draw(AGPainter &amp;p);
+ private:
+  AGTexture mTexture;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_scroller.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_scroller.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_scroller.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,251 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_scroller.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+
+#include &quot;ag_scroller.h&quot;
+#include &quot;ag_button.h&quot;
+#include &quot;ag_border.h&quot;
+#include &quot;ag_background.h&quot;
+#include &quot;ag_debug.h&quot;
+
+AGScroller::AGScroller(AGWidget *pParent,const AGRect2 &amp;pRect,bool pHor):
+  AGWidget(pParent,pRect),
+  sigValueChanged(this,&quot;sigValueChanged&quot;),
+  mHorizontal(pHor)
+{
+  mBorder=new AGBorder(&quot;button.border.normal&quot;);
+  mBackground=new AGBackground(&quot;button.background.normal&quot;);
+
+  mMax=1;
+  mMin=0;
+  mValueWidth=0.3;
+  mValue=0.2;
+  mStepping=0.1;
+
+  mVirtualValue=mValue;
+
+  mBorderWidth=2;
+
+  if(mHorizontal)
+    {
+      mB1=new AGButton(this,AGRect2(mBorderWidth,mBorderWidth,height()-mBorderWidth*2,height()-mBorderWidth*2),&quot;&quot;);
+      mB2=new AGButton(this,AGRect2(width()+mBorderWidth-height(),mBorderWidth,height()-mBorderWidth*2,height()-mBorderWidth*2),&quot;&quot;);
+
+      mScroller=new AGButton(this,AGRect2(mBorderWidth+height(),mBorderWidth,(width()-2*height())*0.5  ,height()-mBorderWidth*2),&quot;&quot;);
+
+      //      mScroller-&gt;setSurface(AGSurface::load(&quot;data/gui/v_bars.png&quot;));
+    }
+  else
+    {
+      mB1=new AGButton(this,AGRect2(mBorderWidth,mBorderWidth,width()-mBorderWidth*2,width()-mBorderWidth*2),&quot;&quot;);
+      mB2=new AGButton(this,AGRect2(mBorderWidth,height()+mBorderWidth-width(),width()-mBorderWidth*2,width()-mBorderWidth*2),&quot;&quot;);
+
+      mScroller=new AGButton(this,AGRect2(mBorderWidth,mBorderWidth+width(),width()-mBorderWidth*2,(height()-2*width())*0.5),&quot;&quot;);
+
+      //      mScroller-&gt;setSurface(AGSurface::load(&quot;data/gui/h_bars.png&quot;));
+    }
+
+  addChild(mB1);
+  addChild(mB2);
+  addChild(mScroller);
+
+  mScroller-&gt;sigDragBy.connect(slot(this,&amp;AGScroller::eventDragBy));
+  mB1-&gt;sigClick.connect(slot(this,&amp;AGScroller::eventUpClick));
+  mB2-&gt;sigClick.connect(slot(this,&amp;AGScroller::eventDownClick));
+
+  updateScroller();
+
+  if(mHorizontal)
+    {
+      mB1-&gt;setSurface(AGSurface::load(&quot;data/gui/arrow_left.png&quot;));
+      mB2-&gt;setSurface(AGSurface::load(&quot;data/gui/arrow_right.png&quot;));
+      mScroller-&gt;setSurface(AGSurface::load(&quot;data/gui/v_bars.png&quot;));
+    }
+  else
+    {
+      mB1-&gt;setSurface(AGSurface::load(&quot;data/gui/arrow_up.png&quot;));
+      mB2-&gt;setSurface(AGSurface::load(&quot;data/gui/arrow_down.png&quot;));
+      mScroller-&gt;setSurface(AGSurface::load(&quot;data/gui/h_bars.png&quot;));
+    }
+  
+  mB1-&gt;setCaching(false);
+  mB2-&gt;setCaching(false);
+  mScroller-&gt;setCaching(false);
+  setCaching(true);
+}
+
+AGScroller::~AGScroller()
+{
+  delete mBorder;
+  delete mBackground;
+}
+
+void AGScroller::draw(AGPainter &amp;p)
+{
+  AGRect2 pr=getRect().origin();
+  mBackground-&gt;draw(pr,p);
+  mBorder-&gt;draw(pr,p);
+}
+
+
+bool AGScroller::eventDragBy(AGEvent *pEvent)
+{
+  AGVector2 v=pEvent-&gt;getVector();
+  if(mHorizontal)
+    {
+      mVirtualValue+=v[0]/getMovingWidth()*(mMax-mMin);
+      mVirtualValue=std::max(mVirtualValue,mMin);
+      mVirtualValue=std::min(mVirtualValue,mMax);
+      updateScroller();
+    }
+  else
+    {
+      mVirtualValue+=v[1]/getMovingWidth()*(mMax-mMin);
+      mVirtualValue=std::max(mVirtualValue,mMin);
+      mVirtualValue=std::min(mVirtualValue,mMax);
+      updateScroller();
+    }
+  return true;
+}
+
+float AGScroller::getScrollerWidth()
+{
+  float v=0;
+  if(mHorizontal)
+    v=(width()-mBorderWidth*2-getScrollerHeight()*2);
+  else
+    v=(height()-mBorderWidth*2-getScrollerHeight()*2);
+
+  if(mMax!=mMin)
+    v*=mValueWidth/(mMax-mMin);
+  return v;
+    
+}
+float AGScroller::getScrollerHeight()
+{
+  if(mHorizontal)
+    return (height()-mBorderWidth*2);
+  else
+    return (width()-mBorderWidth*2);
+    
+}
+float AGScroller::getMovingWidth()
+{
+  if(mHorizontal)
+    return width()-getScrollerWidth()-2*mBorderWidth-2*getScrollerHeight();
+  else
+    {
+      return height()-getScrollerWidth()-2*mBorderWidth-2*getScrollerHeight();
+    }
+}
+
+void AGScroller::updateScroller()
+{
+  mVirtualValue=std::max(mVirtualValue,mMin);
+  mVirtualValue=std::min(mVirtualValue,mMax);
+
+
+  float nv=int((mVirtualValue-mMin)/mStepping+0.5)*mStepping+mMin;
+
+  if(nv!=mValue)
+    {
+      mValue=nv;
+      sigValueChanged(new AGEvent(this,&quot;sigValueChanged&quot;));
+    }
+
+
+  if(mHorizontal)
+    {
+      float x=mBorderWidth+getScrollerHeight();
+      if(mMax!=mMin)
+	x+=getMovingWidth()*(mValue-mMin)/(mMax-mMin);
+      float y=mBorderWidth;
+      float w=getScrollerWidth();
+      float h=getScrollerHeight();
+      mScroller-&gt;setRect(AGRect2(x,y,w,h));
+    }
+  else
+    {
+      float x=mBorderWidth;
+      float y=mBorderWidth+getScrollerHeight();
+
+      if(mMax!=mMin)
+	y+=getMovingWidth()*(mValue-mMin)/(mMax-mMin);
+      float h=getScrollerWidth();
+      float w=getScrollerHeight();
+
+      mScroller-&gt;setRect(AGRect2(x,y,w,h));
+    }
+  queryRedraw();
+}
+
+bool AGScroller::eventUpClick(AGEvent *pEvent)
+{
+  mVirtualValue-=mStepping;
+  mVirtualValue=std::max(mVirtualValue,mMin);
+  mVirtualValue=std::min(mVirtualValue,mMax);
+  updateScroller();
+  return true;
+}
+bool AGScroller::eventDownClick(AGEvent *pEvent)
+{
+  mVirtualValue+=mStepping;
+  mVirtualValue=std::max(mVirtualValue,mMin);
+  mVirtualValue=std::min(mVirtualValue,mMax);
+  updateScroller();
+  return true;
+}
+
+void AGScroller::setValue(float pValue)
+{
+  mVirtualValue=pValue;
+  updateScroller();
+}
+void AGScroller::setScrollerSize(float pSize)
+{
+  mValueWidth=pSize;
+  updateScroller();
+}
+void AGScroller::setInterval(float pMin,float pMax)
+{
+  mMin=pMin;
+  mMax=pMax;
+  assert(mMin&lt;=mMax);
+  updateScroller();
+}
+void AGScroller::setStepping(float pStep)
+{
+  mStepping=pStep;
+  updateScroller();
+}
+
+
+float AGScroller::getValue() const
+{
+  return mValue;
+}
+float AGScroller::getMin() const
+{
+  return mMin;
+}
+float AGScroller::getMax() const
+{
+  return mMax;
+}

Added: antargis/branches/rant/ext/gui/ag_scroller.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_scroller.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_scroller.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_scroller.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef __AG_SCROLLER_H
+#define __AG_SCROLLER_H
+
+#include &lt;ag_widget.h&gt;
+
+class AGButton;
+class AGBorder;
+class AGBackground;
+
+class AGScroller:public AGWidget
+{
+ public:
+  AGScroller(AGWidget *pParent,const AGRect2 &amp;pRect,bool pHor);
+  ~AGScroller();
+
+  void draw(AGPainter &amp;p);
+
+  bool eventDragBy(AGEvent *pEvent);
+  bool eventUpClick(AGEvent *pEvent);
+  bool eventDownClick(AGEvent *pEvent);
+
+  AGSignal sigValueChanged;
+
+  void setValue(float pValue);
+  void setScrollerSize(float pSize);
+  void setInterval(float pMin,float pMax);
+  void setStepping(float pStep);
+
+  float getValue() const;
+  float getMin() const;
+  float getMax() const;
+
+ private:
+
+  /// width of scroller if hor (otherwise height)
+  float getScrollerWidth();
+  /// height of scroller if hor (otherwise width)
+  float getScrollerHeight();
+  float getMovingWidth();
+
+  void updateScroller();
+
+
+  float mValue;
+  float mValueWidth;
+  float mMin,mMax;
+  float mStepping;
+
+  float mVirtualValue;
+
+  float mBorderWidth;
+
+  bool mHorizontal;
+  AGButton *mB1,*mB2;
+  AGButton *mScroller;
+  AGBorder *mBorder;
+  AGBackground *mBackground;
+};
+
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_table.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_table.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_table.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,320 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_table.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_table.h&quot;
+#include &quot;ag_debug.h&quot;
+
+AGTable::AGTable(AGWidget *pWidget,const AGRect2 &amp;pRect):
+  AGWidget(pWidget,pRect),
+  w(0),h(0),xw(0),yw(0),mInserted(false)
+{
+}
+
+AGTable::~AGTable()
+{
+}
+
+/// add a column with fixed size of 'size'
+/// @param size gives to size of the column in pixels
+void AGTable::addFixedColumn(float size)
+{
+  if(mInserted)
+    return;
+  cols.push_back(std::make_pair(size,true));
+  w++;
+}
+/// add a row with fixed size of 'size'
+/// @param size gives to size of the row in pixels
+void AGTable::addFixedRow(float size)
+{
+  if(mInserted)
+    return;
+  rows.push_back(std::make_pair(size,true));
+  h++;
+}
+
+/// add a column with relative size.
+/// @param weight
+///  All weights of columns are summed up. After giving their space
+///  to the fixed columns ( AGTable::addFixedColumn() ), each relative sized
+///  column gets its relative size according the weight. (size_left*weight/sum(weights))
+void AGTable::addColumn(float weight)
+{
+  if(mInserted || weight&lt;=0.0f)
+    return;
+  cols.push_back(std::make_pair(weight,false));
+  w++;
+  xw+=weight;
+}
+
+/// add a row with relative size.
+/// @param weight
+///  All weights of rows are summed up. After giving their space
+///  to the fixed rows ( AGTable::addFixedRow() ), each relative sized
+///  row gets its relative size according the weight. (size_left*weight/sum(weights))
+void AGTable::addRow(float weight)
+{
+  if(mInserted || weight&lt;=0.0f)
+    return;
+  rows.push_back(std::make_pair(weight,false));
+  h++;
+  yw+=weight;
+}
+
+/// adds a widget to the given cell (px,py)
+void AGTable::addChild(int px,int py,AGWidget *pWidget)
+{
+  if(px&gt;=w || py&gt;=h || px&lt;0 || py&lt;0)
+    {
+      std::cerr&lt;&lt;&quot;ERROR: wrong table-position:&quot;&lt;&lt;px&lt;&lt;&quot;,&quot;&lt;&lt;py&lt;&lt;std::endl;
+      std::cerr&lt;&lt;&quot;table size is:&quot;&lt;&lt;w&lt;&lt;&quot;,&quot;&lt;&lt;h&lt;&lt;std::endl;
+      throw std::runtime_error(&quot;WARNING:wrong input position&quot;);
+      return;
+    }
+
+  if(!mInserted)
+    children=std::vector&lt;AGWidget*&gt;(w*h,(AGWidget*)0);
+
+  if(children[px+py*w])
+    cdebug(&quot;Children &quot;&lt;&lt;px&lt;&lt;&quot;,&quot;&lt;&lt;py&lt;&lt;&quot; already set!&quot;);
+
+  mInserted=true;
+  children[px+py*w]=pWidget;
+  AGWidget::addChild(pWidget);
+}
+
+/// returns the Position and size of a given cell (x,y)
+AGRect2 AGTable::getClientRect(int x,int y) const
+{
+  AGRect2 mrect(0,0,0,0);
+
+  int mx,my;
+
+  // first get the fixed sizes
+  int fx,fy;
+  int mfx,mfy; // max
+  fx=fy=0;
+  mfx=mfy=0;
+  
+  // in y dir
+  for(mx=0;mx&lt;w;mx++)
+    {
+      fy=0;
+      //      if(cols[mx]==0.0)
+	for(my=0;my&lt;h;my++)
+	  {
+	    if(rows[my].second)
+	      fy+=(int)(rows[my].first);
+	  }
+      mfy=std::max(mfy,fy);
+    }
+
+  // x dir
+  for(my=0;my&lt;h;my++)
+    {
+      fx=0;
+      //      if(rows[my]==0.0) // only check fixed
+	for(mx=0;mx&lt;w;mx++)
+	  {
+	    if(cols[mx].second)
+	      {
+		fx+=(int)(cols[mx].first);
+	      }
+	    
+	  }
+      mfx=std::max(mfx,fx);
+    }
+
+
+  if(cols[x].second)
+    mrect.setWidth(cols[x].first);
+  else
+    mrect.setWidth((width()-mfx)*cols[x].first/xw);
+  
+  if(rows[y].second)
+    mrect.setHeight(rows[y].first);
+  else
+    mrect.setHeight((height()-mfy)*rows[y].first/yw);
+  
+  int ax=0;
+  for(mx=0;mx&lt;w;mx++)
+    {
+      if(mx==x)
+	{
+	  mrect.setX(ax);
+	  break;
+	}
+      else
+	{
+	  if(cols[mx].second)
+	    ax+=(int)(cols[mx].first);
+	  else
+	    ax+=(int)((width()-mfx)*cols[mx].first/xw);
+	}
+    }
+
+  int ay=0;
+  for(my=0;my&lt;h;my++)
+    {
+      if(my==y)
+	{
+	  mrect.setY(ay);
+	  break;
+	}
+      else
+	{
+	  if(rows[my].second)
+	    ay+=(int)(rows[my].first);
+	  else
+	    ay+=(int)((height()-mfy)*rows[my].first/yw);
+	}
+    }
+  return mrect;
+}
+
+void AGTable::arrange()
+{
+  CTRACE;
+  int mx,my;
+
+  // first get the fixed sizes
+  int fx,fy;
+  int mfx,mfy; // max
+  fx=fy=0;
+  mfx=mfy=0;
+  
+  // in y dir
+  for(mx=0;mx&lt;w;mx++)
+    {
+      fy=0;
+      //      if(cols[mx]==0.0)
+	for(my=0;my&lt;h;my++)
+	  {
+	    //	    AGWidget *wd=children[mx+my*w];
+	    //	    if(wd)
+	      {
+		if(rows[my].second)
+		  fy+=(int)(rows[my].first);
+	      }
+	  }
+      mfy=std::max(mfy,fy);
+    }
+
+  // x dir
+  for(my=0;my&lt;h;my++)
+    {
+      fx=0;
+      //      if(rows[my]==0.0) // only check fixed
+	for(mx=0;mx&lt;w;mx++)
+	  {
+	    //	    AGWidget *wd=children[mx+my*w];
+	    //	    if(wd)
+	      {
+		if(cols[mx].second)
+		  {
+		    fx+=(int)(cols[mx].first);
+		  }
+	      }
+	  }
+      mfx=std::max(mfx,fx);
+    }
+
+  // assign width's and height's for all non-fixed
+  for(mx=0;mx&lt;w;mx++)
+    for(my=0;my&lt;h;my++)
+      {
+	if(!cols[mx].second)
+	  {
+	    AGWidget *wd=children[mx+my*w];
+	    if(wd)
+	      {
+		wd-&gt;setWidth((int)((width()-mfx)*cols[mx].first/xw));
+	      }
+	  }
+	if(!rows[my].second)
+	  {
+	    AGWidget *wd=children[mx+my*w];
+	    if(wd)
+	      {
+		wd-&gt;setHeight((int)((height()-mfy)*rows[my].first/yw));
+	      }
+	  }
+      }
+
+  // assign positions
+  // first x 
+  float ax=0;
+  for(mx=0;mx&lt;w;mx++)
+    {
+      float maxx=0;
+      for(my=0;my&lt;h;my++)
+	{
+	  AGWidget *wd=children[mx+my*w];
+	  if(wd)
+	    {
+	      wd-&gt;setLeft(ax);
+
+	      maxx=std::max(maxx,wd-&gt;width());
+	    }
+	}
+      ax+=maxx;
+    }
+
+  // now y
+  float ay=0;
+  for(my=0;my&lt;h;my++)
+    {
+      float maxy=0;
+      for(mx=0;mx&lt;w;mx++)
+	{
+	  AGWidget *wd=children[mx+my*w];
+	  if(wd)
+	    {
+	      wd-&gt;setTop(ay);
+
+	      maxy=std::max(maxy,wd-&gt;height());
+	    }
+	}
+      ay+=maxy;
+    }
+  
+}
+
+
+void AGTable::setWidth(float w)
+{
+  cdebug(w);
+  AGWidget::setWidth(w);
+  arrange();
+}
+void AGTable::setHeight(float w)
+{
+  AGWidget::setHeight(w);
+  arrange();
+}
+
+size_t AGTable::getRows() const
+{
+  return rows.size();
+}
+size_t AGTable::getColumns() const
+{
+  return cols.size();
+}

Added: antargis/branches/rant/ext/gui/ag_table.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_table.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_table.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_table.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_TABLE_H
+#define AG_TABLE_H
+
+#include &quot;ag_widget.h&quot;
+
+#include &lt;vector&gt;
+
+/**
+   Description:
+   At first you can adjust rows/columns - then you can insert some children.
+   after that rows and columns are fixed.
+
+   Please call AGTable::arrange() whenever you changed extends and/or row/column-info.
+   
+   @todo children should be re-arranged whenever AGTable::arrange() is called!
+*/
+
+class AGTable:public AGWidget
+{
+ public:
+  AGTable(AGWidget *pWidget,const AGRect2 &amp;pRect);
+  virtual ~AGTable();
+
+  void addFixedColumn(float size);
+  void addFixedRow(float size);
+
+  void addColumn(float weight);
+  void addRow(float weight);
+
+  void addChild(int x,int y,AGWidget *pWidget);
+  AGRect2 getClientRect(int x,int y) const;
+
+  void arrange();
+
+  virtual void setWidth(float w);
+  virtual void setHeight(float w);
+
+  size_t getRows() const;
+  size_t getColumns() const;
+
+ private:
+  int w,h;
+  float xw,yw; // weights
+
+  std::vector&lt;std::pair&lt;float,bool&gt; &gt; rows,cols;
+
+  std::vector&lt;AGWidget*&gt; children;
+
+  bool mInserted;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_text.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_text.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_text.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_text.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+
+#include &quot;ag_text.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_surface.h&quot;
+#include &quot;ag_fontengine.h&quot;
+#include &quot;ag_geometry.h&quot;
+
+#include &lt;iostream&gt;
+
+
+using namespace std;
+
+AGText::AGText(AGWidget *pParent,const AGRect2 &amp;r,const AGStringUtf8 &amp;pText,const AGFont &amp;pFont):
+  AGWidget(pParent,r),
+  mText(pText),mFont(pFont)
+{
+  mFixedSize=true;
+}
+
+AGText::AGText(AGWidget *pParent,const AGVector2 &amp;p,const AGStringUtf8 &amp;pText,const AGFont &amp;pFont):
+  AGWidget(pParent,AGRect2(p[0],p[1],pFont.getWidth(pText),pFont.getHeight(pText))),
+  mText(pText),mFont(pFont)
+{
+  mFixedSize=false;
+}
+
+void AGText::draw(AGPainter &amp;p)
+{
+  float x=(width()-mFont.getWidth(mText))/2;
+  float y=(height()-mFont.getHeight(mText))/2;
+  p.renderText(mText,AGVector2((int)x,(int)y),mFont);
+}
+
+void AGText::setDeriveRect()
+{
+  setRect(AGRect2(getRect().x(),getRect().y(),mFont.getWidth(mText),mFont.getHeight(mText)));
+}
+
+void AGText::setText(const AGStringUtf8 &amp;pText)
+{
+  mText=pText;
+  if(!mFixedSize)
+    {
+      setWidth(mFont.getWidth(pText));
+      setHeight(mFont.getHeight(pText));
+    }
+}
+AGStringUtf8 AGText::getText() const
+{
+  return mText;
+}
+
+AGText &amp;toAGText(AGWidget &amp;w)
+{
+  return dynamic_cast&lt;AGText&amp;&gt;(w);
+}
+
+void AGText::setFont(const AGFont &amp;f)
+{
+  mFont=f;
+}

Added: antargis/branches/rant/ext/gui/ag_text.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_text.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_text.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_text.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_TEXT_H
+#define AG_TEXT_H
+
+#include &quot;ag_widget.h&quot;
+#include &quot;ag_font.h&quot;
+
+class AGText:public AGWidget
+{
+ public:
+  AGText(AGWidget *pParent,const AGRect2 &amp;pRect,const AGStringUtf8 &amp;pText,const AGFont &amp;pFont);
+#ifndef SWIG
+  AGText(AGWidget *pParent,const AGVector2 &amp;pPoint,const AGStringUtf8 &amp;pText,const AGFont &amp;pFont);
+#endif
+
+  void setDeriveRect();
+  virtual void draw(AGPainter &amp;p);
+
+  void setText(const AGStringUtf8 &amp;pText);
+  AGStringUtf8 getText() const;
+
+  void setFont(const AGFont &amp;f);
+
+ private:
+  AGStringUtf8 mText;
+  AGFont mFont;
+  bool mFixedSize;
+};
+
+AGText &amp;toAGText(AGWidget &amp;w);
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_theme.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_theme.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_theme.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,226 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_theme.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_theme.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_xml.h&quot;
+#include &quot;ag_tools.h&quot;
+#include &quot;ag_config.h&quot;
+
+#include &lt;iostream&gt;
+using namespace std;
+
+AGTheme *mTheme=0;
+
+AGTheme::AGTheme()
+{
+}
+
+AGTheme::~AGTheme()
+{
+}
+
+void AGTheme::setFont(const AGString &amp;pName,AGFont pFont)
+{
+  mFonts[pName]=pFont;
+}
+void AGTheme::setColor(const AGString &amp;pName,AGColor pColor)
+{
+  //  cdebug(pName);
+  mColors[pName]=pColor;
+  //  cout&lt;&lt;&quot;setting:&quot;&lt;&lt;pName&lt;&lt;&quot;:&quot;&lt;&lt;pColor.toString()&lt;&lt;endl;
+}
+
+
+AGFont AGTheme::getFont(const AGString &amp;pName)
+{
+  //  cdebug(pName&lt;&lt;&quot;:&quot;&lt;&lt;mFonts[pName].toString());
+  if(mFonts.find(pName)==mFonts.end())
+    return mFonts[trunk(pName)];
+  return mFonts[pName];
+}
+AGColor AGTheme::getColor(const AGString &amp;pName)
+{
+  //  cdebug(pName);
+  if(mColors.find(pName)==mColors.end())
+    return mColors[trunk(pName)];
+  return mColors[pName];
+}
+
+AGString AGTheme::trunk(AGString s)
+{
+  //  cdebug(s);
+  size_t i=s.find(&quot;.&quot;);
+  if(i!=s.npos)
+    s=s.substr(0,i);
+  return s;
+}
+
+int AGTheme::getInt(const AGString &amp;pName)
+{
+  if(mInts.find(pName)==mInts.end())
+    return mInts[trunk(pName)];
+  return mInts[pName];
+}
+void AGTheme::setInt(const AGString &amp;pName,int i)
+{
+  mInts[pName]=i;
+}
+
+
+
+void loadDefaultTheme()
+{
+  loadThemeFile(&quot;theme.xml&quot;);
+  
+  if(!mTheme)
+    mTheme=new AGTheme;
+}
+
+void setTheme(const AGTheme &amp;t)
+{
+  if(mTheme)
+    delete mTheme;
+  mTheme=new AGTheme(t);
+}
+
+AGTheme *getTheme()
+{
+  if(mTheme==0)
+    loadDefaultTheme();
+  return mTheme;
+}
+
+bool AGTheme::hasSurface(const AGString &amp;pName) const
+{
+  //  cdebug(pName);
+  return(mSurfaces.find(pName)!=mSurfaces.end());
+}
+bool AGTheme::hasColor(const AGString &amp;pName) const
+{
+  //  cdebug(pName);
+  return(mColors.find(pName)!=mColors.end());
+}
+
+
+AGSurface AGTheme::getSurface(const AGString &amp;pName)
+{
+  if(mSurfaces.find(pName)==mSurfaces.end())
+    return mSurfaces[trunk(pName)];
+  return mSurfaces[pName];
+}
+void AGTheme::setSurface(const AGString &amp;pName,const AGSurface &amp;pSurface)
+{
+  assert(pSurface.valid());
+  mSurfaces[pName]=pSurface;
+  assert(mSurfaces[pName].valid());
+}
+
+std::string AGTheme::getSurfaceName(const AGString &amp;pName)
+{
+  if(mSurfaceNames.find(pName)==mSurfaceNames.end())
+    return mSurfaceNames[trunk(pName)];
+  return mSurfaceNames[pName];
+}
+void AGTheme::setSurfaceName(const AGString &amp;pName,const std::string &amp;pSurface)
+{
+  mSurfaceNames[pName]=pSurface;
+}
+
+
+void loadTheme(const Node&amp;node,AGTheme &amp;t,AGString name)
+{
+  Node::const_iterator i=node.begin();
+  for(;i!=node.end();i++)
+    {
+      
+      AGString n=name;
+      if(n.length())
+	n+=&quot;.&quot;;
+      n+=(*i)-&gt;getName();
+      if((*i)-&gt;get(&quot;name&quot;).length())
+	{
+	  AGString sname=name+&quot;.&quot;+(*i)-&gt;get(&quot;name&quot;);
+	  // read color /image whatever
+	  if((*i)-&gt;getName()==&quot;color&quot;)
+	    t.setColor(sname,AGColor((*i)-&gt;get(&quot;color&quot;)));
+	  if((*i)-&gt;getName()==&quot;image&quot;)
+	    {
+	      t.setSurface(sname,AGSurface::load((*i)-&gt;get(&quot;file&quot;)));
+	      t.setSurfaceName(sname,(*i)-&gt;get(&quot;file&quot;));
+	    }
+	  if((*i)-&gt;getName()==&quot;value&quot;)
+	    t.setInt(sname,(*i)-&gt;get(&quot;value&quot;).toInt());
+	  if((*i)-&gt;getName()==&quot;font&quot;)
+	    {
+	      AGFont f((*i)-&gt;get(&quot;file&quot;),(*i)-&gt;get(&quot;size&quot;).toInt());
+	      f.setColor(AGColor((*i)-&gt;get(&quot;color&quot;)));
+	      f.setEmbossed((*i)-&gt;get(&quot;embossed&quot;)==&quot;true&quot;);
+	      f.setInset((*i)-&gt;get(&quot;inset&quot;)==&quot;true&quot;);
+	      if((*i)-&gt;get(&quot;style&quot;)==&quot;bold&quot;)
+		f.setStyle(AGFont::BOLD);
+	      f.setBorderColor(AGColor((*i)-&gt;get(&quot;borderColor&quot;)));
+	      f.setBorder((*i)-&gt;get(&quot;borderWidth&quot;).toInt());
+
+	      t.setFont(sname,f);
+	    }
+	}
+      else
+	loadTheme(**i,t,n);
+    }
+}
+
+void loadTheme(const AGData &amp;pXML)
+{
+  AGTheme theme;
+
+  Document p;
+  p.parseMemory(pXML);
+
+  Node n=p.root();
+
+  loadTheme(n,theme,&quot;&quot;);
+  
+  setTheme(theme);
+}
+
+bool loadThemeFile(const AGFilename &amp;pFilename)
+{
+  AGTheme theme;
+
+  Document p;
+  if(!p.parseFile(pFilename))
+    return false;
+
+  const Node &amp;n=p.root();
+
+  loadTheme(n,theme,&quot;&quot;);
+  
+  setTheme(theme);
+  return true;
+}
+
+AGString addPoint(const AGString &amp;pTheme)
+{
+  if(pTheme.length())
+    if(pTheme[pTheme.length()-1]!='.')
+      return pTheme+&quot;.&quot;;
+  return pTheme;
+}

Added: antargis/branches/rant/ext/gui/ag_theme.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_theme.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_theme.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_theme.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_THEME_H
+#define AG_THEME_H
+
+#include &quot;ag_font.h&quot;
+#include &quot;ag_surface.h&quot;
+
+#include &lt;map&gt;
+
+class AGTheme
+{
+ public:
+  AGTheme();
+  virtual ~AGTheme();
+
+  AGFont getFont(const AGString &amp;pName);
+  AGColor getColor(const AGString &amp;pName);
+
+  void setFont(const AGString &amp;pName,AGFont pFont);
+  void setColor(const AGString &amp;pName,AGColor pColor);
+
+  int getInt(const AGString &amp;pName);
+  void setInt(const AGString &amp;pName,int i);
+
+  AGSurface getSurface(const AGString &amp;pName);
+  void setSurface(const AGString &amp;pName,const AGSurface &amp;pSurface);
+
+  std::string getSurfaceName(const AGString &amp;pName);
+  void setSurfaceName(const AGString &amp;pName,const std::string &amp;pSurface);
+
+
+  bool hasSurface(const AGString &amp;pName) const;
+  bool hasColor(const AGString &amp;pName) const;
+
+ private:
+
+  AGString trunk(AGString s);
+
+  std::map&lt;AGString,AGFont&gt; mFonts;
+  std::map&lt;AGString,AGColor&gt; mColors;
+  std::map&lt;AGString,AGSurface&gt; mSurfaces;
+  std::map&lt;AGString,std::string&gt; mSurfaceNames;
+  std::map&lt;AGString,int&gt; mInts;
+};
+
+AGTheme *getTheme();
+void setTheme(const AGTheme &amp;aTheme);
+void loadTheme(const AGData &amp;pXML);
+bool loadThemeFile(const AGFilename &amp;pFilename);
+
+AGString addPoint(const AGString &amp;pTheme);
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_tooltip.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_tooltip.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_tooltip.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_tooltip.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_tooltip.h&quot;
+#include &quot;ag_theme.h&quot;
+#include &quot;ag_screen.h&quot;
+#include &quot;ag_edit.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_tools.h&quot;
+
+AGTooltip::AGTooltip(const AGRect2 &amp;pRect,const AGStringUtf8 &amp;pText):
+  AGWidget(0,pRect),
+  mText(pText),
+  mFont(getTheme()-&gt;getFont(&quot;tooltip.font&quot;)),
+  mBgColor(getTheme()-&gt;getColor(&quot;tooltip.bgcolor&quot;)),
+  mBorderColor(getTheme()-&gt;getColor(&quot;tooltip.bordercolor&quot;))
+{
+
+  float sw=getScreen().getWidth();
+  float sh=getScreen().getHeight();
+
+  mText=mText.replace(&quot;\\n&quot;,&quot;\n&quot;);
+
+  float tw,th;
+
+  if(mText.find(&quot;\n&quot;)!=std::string::npos)
+    {
+      // estimate each line size
+      std::vector&lt;AGStringUtf8&gt; a=mText.split(&quot;\n&quot;);
+      tw=th=0;
+      for(std::vector&lt;AGStringUtf8&gt;::iterator i=a.begin();i!=a.end();++i)
+	{
+	  tw=std::max(tw,(float)mFont.getWidth(*i));
+	  th+=mFont.getHeight(*i);
+	}
+    }
+  else
+    {
+      // first estimate a rectangle which can hold the text
+      float ftw=mFont.getWidth(mText);
+      float fth=mFont.getHeight(mText);
+      float maxw=150;
+      if(ftw&gt;maxw)
+	{
+	  tw=maxw;
+	  th=(ftw+50)/maxw*(fth+4);
+	}
+      else
+	{
+	  // 1 line only
+	  tw=ftw;
+	  th=fth;
+	}
+    }
+  tw+=6;
+  th+=5;
+
+  // now estimate a nice position
+
+  // check below
+
+  cdebug(&quot;th:&quot;&lt;&lt;th);
+  cdebug(&quot;bottom:&quot;&lt;&lt;bottom());
+  cdebug(&quot;sh:&quot;&lt;&lt;sh);
+  cdebug(&quot;left:&quot;&lt;&lt;left());
+
+  if(th+bottom()+4&lt;sh)
+    setRect(AGRect2(left(),bottom()+2,tw,th));
+  else if(top()-4-tw&gt;0)
+    // above
+    setRect(AGRect2(left(),top()-th-2,tw,th));
+  else if(tw+right()+4&lt;sw)
+    // right
+    setRect(AGRect2(right()+2,top(),tw,th));
+  else
+    // above
+    setRect(AGRect2(left(),top()-th-2,tw,th));
+
+  if(right()&gt;sw)
+    setLeft(sw-2-width());
+  //  setRect(AGRect2(0,0,tw,th));
+
+  cdebug(getRect());
+  
+  //  mFont.setColor(AGColor(0,0,0));
+  AGEdit *e=new AGEdit(this,getRect().origin().shrink(1));
+  e-&gt;setText(mText);
+  e-&gt;setFont(mFont);
+  e-&gt;setMutable(false);
+  e-&gt;setBackground(false);
+  addChild(e);
+}
+
+void AGTooltip::draw(AGPainter &amp;p)
+{
+  //  p.transform(getRect());
+  p.fillRect(getRect().origin(),mBorderColor);
+  p.fillRect(getRect().origin().shrink(1),mBgColor);
+}

Added: antargis/branches/rant/ext/gui/ag_tooltip.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_tooltip.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_tooltip.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_tooltip.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_TOOLTIP_H
+#define AG_TOOLTIP_H
+
+#include &lt;ag_widget.h&gt;
+
+class AGTooltip:public AGWidget
+{
+ public:
+  AGTooltip(const AGRect2 &amp;pRect,const AGStringUtf8 &amp;pText);
+
+  virtual void draw(AGPainter &amp;p);
+ private:
+  AGStringUtf8 mText;
+  AGFont mFont;
+  AGColor mBgColor;
+  AGColor mBorderColor;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_widget.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_widget.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_widget.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,1110 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_widget.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_widget.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_screen.h&quot;
+#include &quot;ag_main.h&quot;
+#include &quot;ag_menu.h&quot;
+#include &quot;ag_kill.h&quot;
+#include &lt;map&gt;
+#include &lt;iostream&gt;
+#include &lt;algorithm&gt;
+#include &lt;typeinfo&gt;
+#include &lt;ag_tooltip.h&gt;
+#include &quot;ag_application.h&quot;
+#include &quot;ag_layout.h&quot;
+#include &quot;ag_config.h&quot;
+#include &quot;ag_clip.h&quot;
+
+#define FOCUS_BY_SORT
+
+
+using namespace std;
+
+//AGWidget *agNoParent=0;
+
+static bool gNewClippingTechnique=true;
+
+void setNewClippingTechnique(bool f)
+{
+  gNewClippingTechnique=f;
+}
+bool getNewClippingTechnique()
+{
+  return gNewClippingTechnique;
+}
+
+
+
+class MWidgetSet:public std::set&lt;AGWidget*&gt;
+{
+public:
+  virtual ~MWidgetSet();
+};
+MWidgetSet *mPAllWidgets=0; // workaround - to check if still widget exists or not
+bool mWidgetSetDeleted=false;
+
+MWidgetSet::~MWidgetSet()
+{
+  CTRACE;
+  mPAllWidgets=0;
+  mWidgetSetDeleted=true;
+}
+
+MWidgetSet *getAllWidgets()
+{
+  if(!mPAllWidgets)
+    {
+      if(!mWidgetSetDeleted)
+	{
+	  mPAllWidgets=new MWidgetSet;
+	  REGISTER_SINGLETON(mPAllWidgets);
+	}
+    }
+  return mPAllWidgets;
+}
+
+
+AGWidget::AGWidget(AGWidget *pParent,const AGRect2 &amp;r):
+  sigMouseEnter(this,&quot;sigMouseEnter&quot;),
+  sigMouseLeave(this,&quot;sigMouseLeave&quot;),
+  sigClick(this,&quot;sigClick&quot;),
+  mr(r),mParent(pParent),mChildrenEventFirst(false),mChildrenDrawFirst(false),mMouseIn(false),mButtonDown(false),
+  mFixedWidth(false),mFixedHeight(false),mVisible(true),mCaching(false),
+  mHasFocus(false),mFocus(0)
+
+{
+  mChangeRect=AGRect2(0,0,0,0);
+  mCache=0;
+  mCacheTouched=false;
+  mTooltipWidget=0;
+  mRubyObject=false;
+  mModal=false;
+  if(getAllWidgets())
+    getAllWidgets()-&gt;insert(this);
+
+  getMain()-&gt;getCollector()-&gt;insertGlobal(this);
+}
+
+AGWidget::~AGWidget()
+{
+  CTRACE;
+
+  if(!mParent)
+    if(hasMain())
+      getMain()-&gt;getCollector()-&gt;removeGlobal(this);
+
+
+  //  throw int();
+  std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();
+  for(;i!=mChildren.end();i++)
+    {
+      (*i)-&gt;setParent(0);
+    }
+  if(getParent())
+    {
+      if(getAllWidgets())
+	{
+	  if(getAllWidgets()-&gt;find(getParent())==getAllWidgets()-&gt;end())
+	    {
+	      dbout(5000,&quot;WARNING:Error in ~AGWidget!!!&quot;);
+	    }
+	  else
+	    getParent()-&gt;eventChildrenDeleted(this);
+	}
+    }
+  if(getAllWidgets())
+    getAllWidgets()-&gt;erase(this);
+}
+
+void AGWidget::removeChild(AGWidget *w)
+{
+  std::list&lt;AGWidget*&gt;::iterator i=std::find(mChildren.begin(),mChildren.end(),w);
+  if(i!=mChildren.end())
+    {
+      mChildren.erase(i);
+      w-&gt;setParent(0);
+    }
+}
+
+
+void AGWidget::eventChildrenDeleted(AGWidget *pWidget)
+{
+  std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();
+  for(;i!=mChildren.end();i++)
+    {
+      if(*i==pWidget)
+	{
+	  mChildren.erase(i);
+	  break;
+	}
+    }
+  i=mToClear.begin();
+  for(;i!=mToClear.end();i++)
+    {
+      if(*i==pWidget)
+	{
+	  mToClear.erase(i);
+	  break;
+	}
+    }
+}
+
+
+void AGWidget::draw(AGPainter &amp;p)
+{
+}
+
+void AGWidget::delObjects()
+{
+ // clearing widgets
+  if(mToClear.size())
+    {
+      std::list&lt;AGWidget*&gt;::iterator i=mToClear.begin();
+      for(;i!=mToClear.end();i++)
+	{
+	  if(!(*i)-&gt;mRubyObject) // don't delete ruby-objects - they get deleted by garbage collection
+	    {
+	      dbout(5000,&quot;type:&quot;&lt;&lt;typeid(**i).name());
+	      delete *i;
+	    }
+	}
+      mToClear.clear();
+    }
+}
+
+void AGWidget::drawAll(AGPainter &amp;p)
+{
+  delObjects();
+
+  if(!mVisible)
+    return;
+
+  if(mCache)
+    {
+      p.blit(*mCache,getRect(),getRect().origin());
+    }
+  else
+    {
+      p.pushMatrix();
+
+      p.transform(getRect());
+
+      if(!mChildrenDrawFirst)
+	draw(p);
+
+      std::list&lt;AGWidget*&gt;::reverse_iterator i=mChildren.rbegin(); // draw from back to front
+      
+      for(;i!=mChildren.rend();i++)
+	(*i)-&gt;drawAll(p);
+      
+      if(mChildrenDrawFirst)
+	draw(p);
+
+      drawAfter(p);
+    
+      p.popMatrix();
+      setDrawn();
+      //	  getScreen().flip();
+      //	  SDL_Delay(500);
+    }
+}
+
+AGRect2 AGWidget::getRect() const
+{
+  return mr;
+}
+
+AGRect2 AGWidget::getClientRect() const
+{
+  return mr.origin();
+}
+
+bool AGWidget::processEvent(AGEvent *event)
+{
+  if(!mVisible)
+    return false;
+
+  bool processed = false;
+  // do i have a capturehook set ? (modal)
+  // i will send that event to my children
+
+  std::list&lt;AGWidget*&gt;::iterator i;
+
+  std::list&lt;AGWidget*&gt; children=mChildren; // copy children, so that changes do not affect iteration
+  for(i=children.begin();i!=children.end() &amp;&amp; !processed; i++)
+    processed=(*i)-&gt;processEvent(event);
+  
+  if(processed)
+    return processed;
+
+  event-&gt;setCaller(this);
+  
+  // let me see if i can process it myself
+  if(AGMessageObject::processEvent(event))
+    return true;
+  
+  checkFocus();
+  if(mModal)
+    return true;
+  return false;
+}
+
+bool AGWidget::eventShow()
+{
+  return false;
+}
+bool AGWidget::eventHide()
+{
+  return false;
+}
+
+bool AGWidget::eventMouseEnter()
+{
+  if(mTooltip.length())
+    {
+      mTooltipWidget=new AGTooltip(getScreenRect(),mTooltip);
+      getApplication()-&gt;setTooltip(mTooltipWidget);
+    }
+
+  return false;
+}
+bool AGWidget::eventMouseLeave()
+{
+  if(mTooltipWidget)
+    {
+      getApplication()-&gt;resetTooltip(mTooltipWidget);
+      mTooltipWidget=0;
+    }
+  return false;
+}
+
+bool AGWidget::eventMouseMotion(AGEvent *e)
+{
+  if(!visible())
+    return false;
+
+  if(e-&gt;isSDLEvent())
+    {
+      if(getScreenRect().contains(e-&gt;getMousePosition()))
+	{
+	  if(!mMouseIn)
+	    {
+	      mMouseIn=true;
+	      eventMouseEnter() || sigMouseEnter(e);
+	    }
+	}
+      else
+	{
+	  if(mMouseIn)
+	    {
+	      mMouseIn=false;
+	      eventMouseLeave() || sigMouseLeave(e);
+	    }
+	}
+
+      if(mButtonDown)
+	{
+	  AGVector2 v=e-&gt;getMousePosition()-mOldMousePos;
+	  e-&gt;setVector(v);
+	  eventDragBy(e,v) || sigDragBy(e);
+	  mOldMousePos=e-&gt;getMousePosition();
+	}
+    }
+  return false;
+}
+
+bool AGWidget::eventMouseButtonDown(AGEvent *e)
+{
+  if(e-&gt;isSDLEvent())
+    {
+      if(getScreenRect().contains(e-&gt;getMousePosition()))
+	{
+	  mButtonDown=true;
+	  mOldMousePos=e-&gt;getMousePosition();
+	}
+    }
+  return false;
+}
+
+bool AGWidget::eventMouseButtonUp(AGEvent *e)
+{
+  bool was=mButtonDown;
+
+  mButtonDown=false;
+  
+  if(e-&gt;isSDLEvent())
+    {
+      if(getScreenRect().contains(e-&gt;getMousePosition()))
+	{
+	  if(was)
+	    {
+	      e-&gt;setName(&quot;sigClick&quot;);
+	      if(!isParent(getApplication()-&gt;getOverlay()))
+		getApplication()-&gt;setOverlay(0);
+	      
+	      if(canFocus())
+		gainFocus();
+
+	      return (eventMouseClick(e) || sigClick(e));
+
+	    }
+	}
+    }
+  return false;
+
+}
+
+bool AGWidget::eventMouseClick(AGEvent *m)
+{
+  return false;
+}
+
+void AGWidget::addChild(AGWidget *w)
+{
+  mChildren.push_front(w); // set on top
+  if(mHasFocus &amp;&amp; w-&gt;canFocus())
+    {
+      gainFocus(w);
+    }
+  queryRedraw();
+}
+
+void AGWidget::clear()
+{
+  // delay it till be draw everything - so this doesn't kill widgets while processing events
+  std::copy(mChildren.begin(),mChildren.end(),std::back_inserter(mToClear));
+  mChildren.clear();
+}
+
+void AGWidget::erase(AGWidget *w)
+{
+  std::list&lt;AGWidget*&gt;::iterator i=std::find(mChildren.begin(),mChildren.end(),w);
+  if(i!=mChildren.end())
+    {
+      mToClear.push_back(w);
+      
+      mChildren.erase(i);
+    }
+}
+
+void AGWidget::addChildBack(AGWidget *w)
+{
+  mChildren.push_back(w); // set on top
+}
+
+void AGWidget::regChange()
+{
+  AGRect2 t=getScreenRect().grow(5);
+
+  pushChangeRect(t);
+
+  if(mChangeRect.width()==0 || mChangeRect.height()==0)
+    mChangeRect=t;
+  else
+    {
+      mChangeRect.include(t[0]);
+      mChangeRect.include(t[1]);
+    }
+}
+
+void AGWidget::setRect(const AGRect2 &amp;pRect)
+{
+  regChange();
+  mr=pRect;
+  regChange();
+  if(mParent)
+    mParent-&gt;redraw();
+}
+
+float AGWidget::minWidth() const
+{
+  // accumulate max
+  std::list&lt;AGWidget*&gt;::const_iterator i=mChildren.begin();
+  float m=0;
+
+  for(;i!=mChildren.end();i++)
+    m=std::max(m,(*i)-&gt;minWidth());
+
+  return m;
+}
+
+float AGWidget::minHeight() const
+{
+  // accumulate max
+  std::list&lt;AGWidget*&gt;::const_iterator i=mChildren.begin();
+  float m=0;
+
+  for(;i!=mChildren.end();i++)
+    m=std::max(m,(*i)-&gt;minHeight());
+
+  return m;
+}
+
+float AGWidget::width() const
+{
+  return mr.w();
+}
+
+float AGWidget::height() const
+{
+  return mr.h();
+}
+
+bool AGWidget::fixedWidth() const
+{
+  return mFixedWidth;
+}
+
+bool AGWidget::fixedHeight() const
+{
+  return mFixedHeight;
+}
+
+void AGWidget::setWidth(float w)
+{
+  regChange();
+  mr.setWidth(w);
+  regChange();
+}
+void AGWidget::setHeight(float h)
+{
+  regChange();
+  mr.setHeight(h);
+  regChange();
+}
+
+void AGWidget::setTop(float y)
+{
+  regChange();
+  mr.setTop(y);
+  regChange();
+}
+void AGWidget::setLeft(float x)
+{
+  regChange();
+  mr.setLeft(x);
+  regChange();
+}
+float AGWidget::bottom() const
+{
+  return mr[1][1];
+}
+float AGWidget::right() const
+{
+  return mr[1][0];
+}
+
+
+float AGWidget::top() const
+{
+  return mr.y();
+}
+
+float AGWidget::left() const
+{
+  return mr.x();
+}
+
+void AGWidget::show()
+{
+  mVisible=true;
+  queryRedraw();
+}
+void AGWidget::hide()
+{
+  mVisible=false;
+  queryRedraw();
+}
+
+void AGWidget::setVisible(bool v)
+{
+  if(mVisible!=v)
+    {
+      queryRedraw();
+    }
+  mVisible=v;
+}
+
+
+void AGWidget::setParent(AGWidget *pParent)
+{
+  if(!mParent)
+    {
+      if(hasMain())
+	getMain()-&gt;getCollector()-&gt;removeGlobal(this);
+    }
+
+  mParent=pParent;
+}
+
+
+AGWidget *AGWidget::getParent()
+{
+  return mParent;
+}
+
+AGVector2 AGWidget::getScreenPosition() const
+{
+  AGVector2 p=mr[0];
+
+  if(mParent)
+    p+=mParent-&gt;getScreenPosition();
+
+  return p;
+}
+
+
+AGRect2 AGWidget::getScreenRect() const
+{
+  AGRect2 srect(mr.origin()+getScreenPosition());
+  return srect;
+}
+
+AGVector2 AGWidget::fromScreen(const AGVector2 &amp;p) const
+{
+  if(!mParent)
+    return p;
+  AGRect2 r(mParent-&gt;getScreenRect());
+  return p-r[0];
+}
+
+bool AGWidget::canFocus() const
+{
+  std::list&lt;AGWidget*&gt;::const_iterator i=mChildren.begin();
+
+  for(;i!=mChildren.end();i++)
+    if((*i)-&gt;canFocus())
+      {
+
+	return true;
+      }
+
+  return false;
+}
+
+bool AGWidget::eventGotFocus()
+{
+  mHasFocus=true;
+  return false;
+}
+
+bool AGWidget::eventLostFocus()
+{
+  if(mFocus)
+    mFocus-&gt;eventLostFocus();
+  mHasFocus=false;
+  mFocus=0;
+  
+  return false;
+}
+/*
+void AGWidget::setMenu(AGMenu *pMenu)
+{
+  mMenu=pMenu;
+  }*/
+
+void AGWidget::gainCompleteFocus(AGWidget *pWidget)
+{
+#ifdef FOCUS_BY_SORT
+  if(mParent)
+    mParent-&gt;gainCompleteFocus(this);
+  if(pWidget)
+    {
+      //      dbout(5000,mChildren.size());
+      std::list&lt;AGWidget*&gt;::iterator i=std::find(mChildren.begin(),mChildren.end(),pWidget);
+      if(i!=mChildren.end())
+	{
+	  mChildren.erase(i);
+	  mChildren.push_front(pWidget);
+	}
+      //      dbout(5000,mChildren.size());
+    }
+#endif
+}
+
+void AGWidget::gainFocus(AGWidget *pWidget)
+{
+#ifdef FOCUS_BY_SORT
+  if(pWidget)
+    {
+      //      dbout(5000,mChildren.size());
+      std::list&lt;AGWidget*&gt;::iterator i=std::find(mChildren.begin(),mChildren.end(),pWidget);
+      if(i!=mChildren.end())
+	{
+	  mChildren.erase(i);
+
+	  if(mChildren.size()&gt;0)
+	    (*mChildren.begin())-&gt;eventLostFocus();
+
+	  mChildren.push_front(pWidget);
+	  pWidget-&gt;eventGotFocus();
+
+	}
+      //      dbout(5000,mChildren.size());
+    }
+  else if(mParent)
+    {
+      if(canFocus())
+	{
+	  mParent-&gt;gainFocus(this);
+	}
+    }
+#else
+  if(pWidget==0 &amp;&amp; mParent)
+    mParent-&gt;gainFocus(this);
+  else if(mParent)
+    mParent-&gt;gainFocus(pWidget);
+  else
+    gainFocusDown(pWidget);
+#endif
+}
+
+void AGWidget::gainFocusDown(AGWidget *pWidget)
+{
+  std::list&lt;AGWidget*&gt;::iterator i;
+  i=std::find(mChildren.begin(),mChildren.end(),pWidget);
+  if(i!=mChildren.end())
+    {
+      // found
+      if(!mHasFocus)
+	{
+	  if(mParent)
+	    mParent-&gt;gainFocus(this);
+	  else
+	    {
+	      mHasFocus=true;
+	      eventGotFocus();
+	    }
+	}
+      
+      if(mFocus!=pWidget)
+	{
+	  if(mFocus)
+	    mFocus-&gt;eventLostFocus();
+	  mFocus=pWidget;
+	  mFocus-&gt;eventGotFocus();
+	}
+    }
+  else
+    {
+      for(i=mChildren.begin();i!=mChildren.end();i++)
+	(*i)-&gt;gainFocusDown(pWidget);
+    }
+}
+
+void AGWidget::checkFocus()
+{
+  if(mChildren.size()&gt;0 &amp;&amp; mFocus &amp;&amp; mHasFocus)
+    {
+      if(mFocus!=*mChildren.begin())
+	{
+	  std::list&lt;AGWidget*&gt;::iterator i;
+	  
+	  i=std::find(mChildren.begin(),mChildren.end(),mFocus);
+	  // delete children and set to front 
+	  mChildren.erase(i);
+	  mChildren.push_front(mFocus);
+	  //	  dbout(5000,&quot;mchildren #:&quot;&lt;&lt;mChildren.size());
+	}
+    }
+}
+
+bool AGWidget::hasFocus(const AGWidget *pWidget)
+{
+#ifdef FOCUS_BY_SORT
+  if(pWidget==0)
+    {
+      if(mParent)
+	return mParent-&gt;hasFocus(this);
+      else
+	return true;
+    }
+  if(mChildren.size()==0)
+    return true; // some error
+
+  if(*mChildren.begin()==pWidget)
+    {
+      if(mParent)
+	return mParent-&gt;hasFocus(this); // ok - so go on and check if &quot;this&quot; has focus
+      return true; // ok
+    }
+
+  return false;
+#else
+  if(pWidget==0)
+    {
+      if(mParent)
+	return mParent-&gt;hasFocus(this);
+      else
+	return true;
+    }
+  else if(mFocus!=pWidget)
+    return false;
+  else if(mParent)
+    return mParent-&gt;hasFocus(this);
+  return true;
+#endif
+}
+
+
+bool AGWidget::eventDragBy(AGEvent *event,const AGVector2 &amp;pDiff)
+{
+  return false;
+}
+
+bool AGWidget::getFocus() const
+{
+  return mHasFocus;
+}
+
+const AGString &amp;AGWidget::getName() const
+{
+  return mName;
+}
+void AGWidget::setName(const AGString &amp;pName)
+{
+  mName=pName;
+}
+
+void AGWidget::drawAfter(AGPainter &amp;p)
+{
+}
+
+bool AGWidget::visible() const
+{
+  return mVisible;
+}
+
+/// override this and return true, if widget is opaque and you want to increase performance
+bool AGWidget::isOpaque() const
+{
+  return false;
+}
+
+
+
+AGWidget *AGWidget::getChild(const AGString &amp;pName)
+{
+	CTRACE;
+  if(mName==pName)
+    return this;
+
+  AGWidget *w=0;
+  std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();
+
+  for(;i!=mChildren.end();i++)
+    {
+      w=(*i)-&gt;getChild(pName);
+      if(w)
+				break;
+    }
+	cdebug(&quot;w:&quot;&lt;&lt;w);
+  return w;
+}
+
+void AGWidget::setModal(bool pModal)
+{
+  mModal=pModal;
+}
+
+void AGWidget::mark()
+{
+  for(std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();i!=mChildren.end();i++)
+    {
+      markObject(*i);
+    }
+
+  // mark mToClear also - as it can be that they are still used on stack
+  for(std::list&lt;AGWidget*&gt;::iterator i=mToClear.begin();i!=mToClear.end();i++)
+    markObject(*i);
+}
+
+
+
+AGWidget *toAGWidget(AGMessageObject *o)
+{
+  return dynamic_cast&lt;AGWidget*&gt;(o);
+}
+
+
+bool AGWidget::redraw() const
+{
+  return mCacheTouched;
+}
+
+bool AGWidget::checkRedraw() const
+{
+  if(!mVisible)
+    return false;
+  if(redraw())
+    return true;
+  for(std::list&lt;AGWidget*&gt;::const_iterator i=mChildren.begin();i!=mChildren.end();++i)
+    if((*i)-&gt;checkRedraw())
+      return true;
+  return false;
+}
+
+void AGWidget::prepareDrawAll()
+{
+  if(!mVisible)
+    return;
+
+  for(std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();i!=mChildren.end();++i)
+    (*i)-&gt;prepareDrawAll();
+
+  prepareDraw();
+  
+}
+
+
+void AGWidget::prepareDraw()
+{
+  if(!mVisible)
+    return;
+
+  if(mCache)
+    {
+      if(checkRedraw() || !mCache-&gt;hasTexture())
+	{
+	  mCache-&gt;clearContent();
+
+	  AGPainter p(*mCache);
+
+	  if(!mChildrenDrawFirst)
+	    draw(p);
+	  
+	  std::list&lt;AGWidget*&gt;::reverse_iterator i=mChildren.rbegin(); // draw from back to front
+
+	  for(;i!=mChildren.rend();i++)
+	    (*i)-&gt;drawAll(p);
+
+	  if(mChildrenDrawFirst)
+	    draw(p);
+
+	  drawAfter(p);
+
+	  setDrawn();
+
+	  /*
+	  {
+	    static int i=0;
+	    i++;
+	    std::ostringstream os;
+	    os&lt;&lt;&quot;widget_&quot;&lt;&lt;i&lt;&lt;&quot;.png&quot;;
+	    AGSurface ms(mCache-&gt;sdlTexture());
+	    ms.save(os.str());
+	    
+	  }
+	  */
+
+	  if(mParent)
+	    {
+	      //CTRACE;
+	      cdebug(&quot;parent-&gt;queryRedraw::&quot;&lt;&lt;typeid(*this).name()&lt;&lt;&quot;:&quot;&lt;&lt;getName());
+	      mParent-&gt;queryRedraw();
+	    }
+
+	  assert(checkRedraw()==false);
+	  assert(mCache-&gt;hasTexture());
+	}
+    }
+}
+void AGWidget::setCaching(bool pEnable)
+{
+  // FIXME: really no caching without GL? 
+  //  if(!glMode())
+  //    return;
+
+
+  if(getConfig()-&gt;get(&quot;widgetTextureCache&quot;)==&quot;false&quot;)
+    return;
+  getConfig()-&gt;set(&quot;widgetTextureCache&quot;,&quot;true&quot;);
+
+  mCaching=pEnable;
+  delete mCache;
+
+  mCache=0;
+  mCacheTouched=false;
+  if(pEnable)
+    {
+      mCache=new AGTexture((int)width(),(int)height());
+      
+      mCacheTouched=true;
+    }
+}
+
+void AGWidget::setDrawn()
+{
+  if(!mVisible)
+    return;
+
+  mCacheTouched=false;
+  for(std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();i!=mChildren.end();++i)
+    (*i)-&gt;setDrawn();
+  mChangeRect=AGRect2(0,0,0,0);
+}
+
+void AGWidget::queryRedraw()
+{
+  cdebug(getName()&lt;&lt;&quot;::&quot;&lt;&lt;typeid(*this).name());
+  mCacheTouched=true;
+  regChange();
+}
+
+/**
+   \brief special function for &quot;using textures&quot;
+
+   within a texture-garbage-collection run all unused textures get cleaned,
+   so this function &quot;uses&quot; the textures. This way they won't get collected
+*/
+void AGWidget::useTextures()
+{
+}
+
+/**
+   \brief special function for &quot;using textures&quot;
+
+   within a texture-garbage-collection run all unused textures get cleaned,
+   so this function &quot;uses&quot; the textures. This way they won't get collected.
+
+   This function calles useTextures() recursively. Don't override this one!
+*/
+void AGWidget::useTexturesRecursive()
+{
+  useTextures();
+  for(std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();i!=mChildren.end();++i)
+    (*i)-&gt;useTexturesRecursive();
+}
+
+AGRect2 AGWidget::getChangeRect()
+{
+  AGRect2 r=mChangeRect;
+  
+  for(std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();i!=mChildren.end();++i)
+    {
+      AGRect2 n=(*i)-&gt;getChangeRect();
+      if(n.width()!=0 &amp;&amp; n.height()!=0)
+	{
+	  if(r.width()!=0 &amp;&amp; r.height()!=0)
+	    {
+	      r.include(n[0]);
+	      r.include(n[1]);
+	    }
+	  else
+	    r=n;
+	}
+    }
+  return r;
+}
+
+void AGWidget::setTooltip(const AGStringUtf8 &amp;pTooltip)
+{
+  mTooltip=pTooltip;
+}
+
+AGLayout *AGWidget::getLayout()
+{
+  AGLayout *l=dynamic_cast&lt;AGLayout*&gt;(this);
+  if(l)
+    return l;
+  if(mParent)
+    return mParent-&gt;getLayout();
+  return 0;
+}
+
+void AGWidget::initHandlers()
+{
+}
+
+void AGWidget::eventTick(float pTime)
+{
+}
+void AGWidget::sigTick(float pTime)
+{
+  eventTick(pTime);
+  for(std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();i!=mChildren.end();++i)
+    (*i)-&gt;sigTick(pTime);
+}
+
+void AGWidget::close()
+{
+  if(mParent)
+    mParent-&gt;removeChild(this);
+}
+
+bool AGWidget::isParent(AGWidget *pParent)
+{
+  if(mParent==pParent)
+    return true;
+  else if(mParent!=0)
+    return mParent-&gt;isParent(pParent);
+  return false;
+}
+
+void AGWidget::acquireClipping(AGClipping &amp;p)
+{
+  if(!visible())
+    return;
+
+  //  cdebug(&quot;clipping before:&quot;&lt;&lt;p.toString());
+  if(isOpaque())
+    p.exclude(getScreenRect());
+  
+  for(std::list&lt;AGRect2&gt;::iterator i=mMyChanges.begin();i!=mMyChanges.end();i++)
+    p.include(*i);//+getScreenPosition());
+
+  //  cdebug(&quot;clipping in:&quot;&lt;&lt;p.toString());
+  
+  for(std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();i!=mChildren.end();i++)
+    (*i)-&gt;acquireClipping(p);
+
+  //  cdebug(&quot;clipping after:&quot;&lt;&lt;p.toString());
+  return;
+}
+
+
+std::list&lt;AGRect2&gt; AGWidget::aquireChanges()
+{
+  std::list&lt;AGRect2&gt; l;
+
+  for(std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();i!=mChildren.end();i++)
+    {
+      std::list&lt;AGRect2&gt; t=(*i)-&gt;aquireChanges();
+      // FIXME: check, if opaque and truncates rectangles
+      std::copy(t.begin(),t.end(),std::back_inserter(l));
+    }
+  std::copy(mMyChanges.begin(),mMyChanges.end(),std::back_inserter(l));
+  
+  return l;
+}
+void AGWidget::pushChangeRect(const AGRect2 &amp;pRect)
+{
+  cdebug(&quot;push:&quot;&lt;&lt;pRect);
+  mMyChanges.push_back(pRect);
+}
+void AGWidget::clearChangeRects()
+{
+  cdebug(&quot;clearing - size was:&quot;&lt;&lt;mMyChanges.size());
+  mMyChanges.clear();
+  for(std::list&lt;AGWidget*&gt;::iterator i=mChildren.begin();i!=mChildren.end();i++)
+    (*i)-&gt;clearChangeRects();
+}

Added: antargis/branches/rant/ext/gui/ag_widget.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_widget.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_widget.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,263 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_widget.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_WIDGET_H
+#define AG_WIDGET_H
+
+#include &quot;ag_geometry.h&quot;
+#include &quot;ag_messageobject.h&quot;
+
+#include &lt;list&gt;
+
+#include &quot;ag_painter.h&quot;
+
+class AGTooltip;
+class AGLayout;
+class AGClipping;
+
+/** 
+    \defgroup widgets Widgets
+    \brief contains all the widgets
+
+    Everything that has a display on screen is called a widget. There are plenty of different widget-types
+    and you are free to define new ones.
+
+    An AGApplication object has one single main-widget, that you can define.
+    All other widgets are children (or grandchildren ...) of this main-widget.
+
+    A simple example how to use nested widgets is:
+    &lt;pre&gt;
+    AGWidget *parent,*w;
+    AGApplication app;
+    
+    parent=new AGWidget(0,AGRect2(0,0,640,480));
+    w=new AGWidget(parent,AGRect2(0,0,100,100));
+    parent-&gt;addChild(w);
+    app.setMainWidget(parent);
+    &lt;/pre&gt;
+
+    Nearly all of the widget-types are created this way. Adding a widget to another will automate
+    the drawing and event-processing.
+
+*/
+
+
+
+/**
+   \brief base class for all widgets
+
+   \ingroup widgets
+
+   AGWidget is the base class for all widgets. It manages the hierarchy and memory of the widgets.
+   You should never delete an AGWidget for yourself if you don't know exactly what you're doing.
+   The widgets get deleted by their parents
+*/
+
+class AGWidget:public AGMessageObject
+{
+ public:
+  AGWidget(AGWidget *pParent,const AGRect2 &amp;r);
+  virtual ~AGWidget();
+
+  virtual void initHandlers();
+  
+  virtual void draw(AGPainter &amp;p);
+  virtual void drawAfter(AGPainter &amp;p);
+  virtual void drawAll(AGPainter &amp;p);
+  AGRect2 getRect() const;
+  virtual AGRect2 getClientRect() const;
+  void setRect(const AGRect2 &amp;pRect);
+  
+  void setParent(AGWidget *pParent);
+  AGWidget *getParent();
+  bool isParent(AGWidget *pParent);
+
+  virtual bool eventShow();
+  virtual bool eventHide();
+
+  virtual bool eventMouseMotion(AGEvent *m);
+
+  virtual bool eventMouseEnter();
+  virtual bool eventMouseLeave();
+  virtual bool eventMouseClick(AGEvent *m);
+
+  virtual bool eventMouseButtonDown(AGEvent *m);
+  virtual bool eventMouseButtonUp(AGEvent *m);
+
+  virtual bool eventGotFocus();
+  virtual bool eventLostFocus();
+
+  virtual void eventTick(float pTime);
+  void sigTick(float pTime);
+
+  virtual bool canFocus() const;
+
+  bool processEvent(AGEvent *event);
+
+  AGSignal sigMouseEnter;
+  AGSignal sigMouseLeave;
+  AGSignal sigClick;
+  AGSignal sigDragBy;
+
+  virtual float minWidth() const;
+  virtual float minHeight() const;
+
+  float width() const;
+  float height() const;
+  float top() const;
+  float left() const;
+  float bottom() const;
+  float right() const;
+
+  bool visible() const;
+  void setVisible(bool v);
+  bool isOpaque() const;
+
+  virtual void setWidth(float w);
+  virtual void setHeight(float w);
+  virtual void setTop(float y);
+  virtual void setLeft(float x);
+
+  bool fixedWidth() const;
+  bool fixedHeight() const;
+
+  void show();
+  void hide();
+  void close();
+
+  virtual void mark();
+
+  virtual void addChild(AGWidget *w);
+  virtual void addChildBack(AGWidget *w);
+
+  virtual void removeChild(AGWidget *w);
+
+  // Functions for caching appearance
+  virtual bool redraw() const;
+  virtual void prepareDraw();
+
+  void prepareDrawAll();
+
+  void setCaching(bool pEnable);
+  bool checkRedraw() const;
+  void setDrawn();
+  void queryRedraw();
+  AGRect2 getChangeRect();
+
+  // when caching, &quot;normal&quot; textures are not used, so they get discarded
+  // to prevent this, use this function to &quot;use&quot; them in each frame
+  virtual void useTextures(); // when caching
+  void useTexturesRecursive(); // when caching
+
+
+  // clear children
+  void clear();
+
+  AGRect2 getScreenRect() const;
+  AGVector2 getScreenPosition() const;
+  AGVector2 fromScreen(const AGVector2 &amp;p) const;
+
+  // focus
+
+  /** should only be called by a child */
+  void gainFocus(AGWidget *pWidget=0);
+  void gainCompleteFocus(AGWidget *pWidget=0);
+
+
+  virtual bool eventDragBy(AGEvent *event,const AGVector2 &amp;pDiff);
+
+  bool getFocus() const;
+  bool hasFocus(const AGWidget *pWidget=0);
+
+  AGLayout *getLayout();
+
+
+  const AGString &amp;getName() const;
+  void setName(const AGString &amp;pName);
+  AGWidget *getChild(const AGString &amp;pName);
+
+  void setModal(bool pModal);
+
+  void erase(AGWidget *w);
+
+  void eventChildrenDeleted(AGWidget *pWidget);
+
+  void setTooltip(const AGStringUtf8 &amp;pTooltip);
+
+  void acquireClipping(AGClipping &amp;p);
+
+  std::list&lt;AGRect2&gt; aquireChanges();
+  void pushChangeRect(const AGRect2 &amp;pRect);
+  void clearChangeRects();
+
+ private:
+  std::list&lt;AGRect2&gt; mMyChanges;
+
+  void regChange();
+
+  void drawCache();
+
+  void delObjects();
+
+  void gainFocusDown(AGWidget *pWidget);
+
+  void checkFocus();
+
+  std::list&lt;AGWidget*&gt; mToClear;
+
+  AGRect2 mr;
+  AGWidget *mParent;
+  bool mChildrenEventFirst;
+  bool mChildrenDrawFirst;
+  bool mMouseIn;
+  bool mButtonDown;
+  bool mFixedWidth,mFixedHeight;
+  bool mVisible;
+  bool mCaching;
+  AGTexture *mCache;
+  bool mCacheTouched;
+
+  bool mHasFocus;
+  AGWidget *mFocus;
+
+  AGVector2 mOldMousePos;
+
+  AGString mName;
+  bool mModal;
+
+  AGRect2 mChangeRect;
+
+  AGStringUtf8 mTooltip;
+  AGTooltip *mTooltipWidget;
+
+ protected:
+  std::list&lt;AGWidget*&gt; mChildren;
+
+};
+
+AGWidget *toAGWidget(AGMessageObject *o);
+
+void setNewClippingTechnique(bool f);
+bool getNewClippingTechnique();
+
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_window.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_window.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_window.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,227 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_window.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_window.h&quot;
+#include &quot;ag_surface.h&quot;
+#include &quot;ag_theme.h&quot;
+#include &quot;ag_image.h&quot;
+#include &quot;ag_text.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_button.h&quot;
+#include &quot;ag_caption.h&quot;
+#include &quot;ag_texturecache.h&quot;
+
+#undef connect
+
+AGWindow::AGWindow(AGWidget *pWidget,const AGRect2 &amp;pRect,const AGStringUtf8 &amp;pTitle,const AGString &amp;pTheme):
+  AGTable(pWidget,pRect),sigClose(this,&quot;sigClose&quot;),mTitle(pTitle)
+
+{
+  CTRACE;
+
+  AGString tstr=&quot;window.border.image&quot;;
+  if(pTheme!=&quot;&quot;)
+    tstr=pTheme+&quot;.&quot;+tstr;
+
+
+  cdebug(&quot;image:&quot;&lt;&lt;tstr);
+  AGSurface s=getTheme()-&gt;getSurface(tstr);
+  float bw=s.getRect().w()/3;
+  int titBarHeight=20;
+
+  //  cdebug(&quot;window_border:&quot;&lt;&lt;s.width()&lt;&lt;&quot;/&quot;&lt;&lt;s.height());
+  AGTable *t=0;
+
+
+  std::vector&lt;const AGTexture*&gt; textures;
+
+  // build textures
+  for(int y=0;y&lt;3;y++)
+    for(int x=0;x&lt;3;x++)
+      {
+	AGRect2 r(x*bw,y*bw,bw,bw);
+	
+	textures.push_back(&amp;getTextureCache()-&gt;get(getTheme()-&gt;getSurfaceName(tstr),r));
+      }
+
+
+
+ 
+  if(pTitle.length())
+    {
+      // use 4 rows
+      addFixedRow(bw); // upper border
+      addFixedRow(titBarHeight); // titletext and button
+      //      addFixedRow(bw); // lower border below titletext
+      addRow(1.0); 
+      addFixedRow(bw); // lower lower below window
+      addFixedColumn(bw);
+      addColumn(1.0);
+      addFixedColumn(bw);
+      
+      AGTable::addChild(0,0,new AGImage(this,AGRect2(0,0,bw,bw),*textures[0],true));
+      AGTable::addChild(1,0,new AGImage(this,AGRect2(0,0,bw,bw),*textures[1],true));
+      AGTable::addChild(2,0,new AGImage(this,AGRect2(0,0,bw,bw),*textures[2],true));
+      
+      AGImage *i1,*i2;
+
+      AGTable::addChild(0,1,i1=new AGImage(this,AGRect2(0,0,bw,titBarHeight),*textures[3],true));//,AGRect2(0,bw,bw,bw)));
+      // title
+      t=dynamic_cast&lt;AGTable*&gt;(getTitleBar((int)(width()-2*bw),titBarHeight));
+
+      AGTable::addChild(2,1,i2=new AGImage(this,AGRect2(0,0,bw,titBarHeight),*textures[5],true));
+      i1-&gt;setHeight(t-&gt;height());
+      i2-&gt;setHeight(t-&gt;height());
+
+      cdebug(&quot;i2:&quot;&lt;&lt;i2-&gt;width()&lt;&lt;&quot;   &quot;&lt;&lt;i2-&gt;height());
+      cdebug(&quot;bw:&quot;&lt;&lt;bw);
+
+      
+      AGTable::addChild(0,2,new AGImage(this,AGRect2(0,0,bw,bw),*textures[3],true));
+      AGTable::addChild(2,2,new AGImage(this,AGRect2(0,0,bw,bw),*textures[5],true));
+      
+      AGTable::addChild(0,3,new AGImage(this,AGRect2(0,0,bw,bw),*textures[6],true));
+      AGTable::addChild(1,3,new AGImage(this,AGRect2(0,0,bw,bw),*textures[7],true));
+      AGTable::addChild(2,3,new AGImage(this,AGRect2(0,0,bw,bw),*textures[8],true));
+      
+      AGTable::addChild(1,2,mClient=new AGCaption(this,AGRect2(0,0,0,0),&quot;&quot;,getTheme()-&gt;getFont(&quot;window.title.font&quot;),AGBackground(&quot;window.background&quot;)));
+
+    }
+  else
+    {
+      // use 3 rows
+      addFixedRow(bw);
+      addRow(1.0);
+      addFixedRow(bw);
+      addFixedColumn(bw);
+      addColumn(1.0);
+      addFixedColumn(bw);
+      
+      AGTable::addChild(0,0,new AGImage(this,AGRect2(0,0,bw,bw),*textures[0],true));
+      AGTable::addChild(1,0,new AGImage(this,AGRect2(0,0,bw,bw),*textures[1],true));
+      AGTable::addChild(2,0,new AGImage(this,AGRect2(0,0,bw,bw),*textures[2],true));
+      
+      AGTable::addChild(0,1,new AGImage(this,AGRect2(0,0,bw,bw),*textures[3],true));
+      AGTable::addChild(2,1,new AGImage(this,AGRect2(0,0,bw,bw),*textures[5],true));
+      
+      AGTable::addChild(0,2,new AGImage(this,AGRect2(0,0,bw,bw),*textures[6],true));
+      AGTable::addChild(1,2,new AGImage(this,AGRect2(0,0,bw,bw),*textures[7],true));
+      AGTable::addChild(2,2,new AGImage(this,AGRect2(0,0,bw,bw),*textures[8],true));
+      
+      AGTable::addChild(1,1,mClient=new AGCaption(this,AGRect2(0,0,0,0),&quot;&quot;,getTheme()-&gt;getFont(&quot;window.title.font&quot;),AGBackground(&quot;window.background&quot;)));
+    }
+
+  arrange();
+}
+
+void AGWindow::addChild(AGWidget *w)
+{
+  // FIXME: change this somehow?
+  AGWidget::addChild(w);
+  //  mClient-&gt;addChild(w);
+}
+
+AGWidget *AGWindow::getClient()
+{
+  return mClient;
+}
+
+bool AGWindow::eventMouseButtonDown(AGEvent *e)
+{
+  CTRACE;
+  if(!hasFocus())
+    {
+      CTRACE;
+      if(e-&gt;isSDLEvent())
+	if(getScreenRect().contains(e-&gt;getMousePosition()))
+	  if(getParent())
+	    {
+	      getParent()-&gt;gainFocus(this);
+	      return true;
+	    }
+    }
+
+  bool ret=AGTable::eventMouseButtonDown(e);
+
+  if(e-&gt;isSDLEvent())
+    if(getScreenRect().contains(e-&gt;getMousePosition()))
+      return true; // eat - if it was here - always!!!
+  return ret;
+
+}
+
+bool AGWindow::eventDragBy(AGEvent *event,const AGVector2 &amp;pDiff)
+{
+  //  TRACE;
+  setTop(top()+pDiff[1]);
+  setLeft(left()+pDiff[0]);
+  return true;
+}
+
+AGWidget *AGWindow::getTitleBar(int w,int h)
+{
+  cdebug(&quot;W:&quot;&lt;&lt;w);
+  AGTable *t=new AGTable(this,AGRect2(0,0,0,20));//60,20));
+  AGSurface closeSurface=getTheme()-&gt;getSurface(&quot;window.buttons.close&quot;);
+  AGButton *closeButton;
+  AGWidget *title;
+
+  AGTable::addChild(1,1,t);
+
+  t-&gt;addRow(1.0);
+
+  t-&gt;addColumn(1.0);
+  t-&gt;addFixedColumn(h);//close button
+  
+  //  t-&gt;addChild(0,0,title=new AGButton(t,AGRect2(0,0,0,0),mTitle));
+  t-&gt;addChild(0,0,title=new AGCaption(t,AGRect2(0,0,0,0),mTitle,getTheme()-&gt;getFont(&quot;window.title.font&quot;),AGBackground(&quot;window.title.background&quot;)));
+  t-&gt;addChild(1,0,closeButton=new AGButton(t,AGRect2(0,0,20,20),&quot;aa&quot;));
+  closeButton-&gt;setSurface(closeSurface,false);
+  title-&gt;setName(&quot;title&quot;); // FIXME: maybe name getName()+&quot;.title&quot;
+
+  //  AGListener 
+  closeButton-&gt;sigClick.connect(slot(this,&amp;AGWindow::tryClose));
+  //  t-&gt;arrange();
+  return t;
+}
+
+bool AGWindow::tryClose(AGEvent *m)
+{
+  TRACE;
+  hide();
+  m-&gt;setCaller(this);
+  sigClose(m);
+  return false;
+}
+
+void AGWindow::close()
+{
+  hide();
+}
+
+AGRect2 AGWindow::getClientRect() const
+{
+  return const_cast&lt;AGWindow*&gt;(this)-&gt;getClient()-&gt;getClientRect()+mClient-&gt;getRect().getV0();
+}
+
+AGWindow &amp;toAGWindow(AGWidget &amp;w)
+{
+  return dynamic_cast&lt;AGWindow&amp;&gt;(w);
+}

Added: antargis/branches/rant/ext/gui/ag_window.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_window.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_window.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_window.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_WINDOW_H
+#define AG_WINDOW_H
+
+#include &quot;ag_table.h&quot;
+
+class AGWindow:public AGTable
+{
+ public:
+  AGWindow(AGWidget *pWidget,const AGRect2 &amp;pRect,const AGStringUtf8 &amp;pTitle=&quot;&quot;,const AGString &amp;pTheme=&quot;&quot;);
+
+  void addChild(AGWidget *w);
+
+  AGWidget *getClient();
+
+  virtual bool eventMouseButtonDown(AGEvent *m);
+  bool eventDragBy(AGEvent *event,const AGVector2 &amp;pDiff);
+
+  void close();
+
+  // slot
+  virtual bool tryClose(AGEvent *m);
+
+  AGRect2 getClientRect() const;
+
+  AGSignal sigClose;
+
+ private:
+
+  AGWidget *getTitleBar(int w,int h);
+
+  AGStringUtf8 mTitle;
+  AGWidget *mClient;
+};
+
+AGWindow &amp;toAGWindow(AGWidget &amp;w);
+
+#endif

Modified: antargis/branches/rant/ext/gui/headers.hh
===================================================================
--- antargis/branches/rant/ext/gui/headers.hh	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/headers.hh	2007-06-23 15:07:27 UTC (rev 1105)
@@ -63,27 +63,27 @@
 #include &quot;/home/david/projects/antargis/rant/ext/gui/ag_table.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/gui/ag_layout.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/gui/ag_colorbutton.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_button.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_image.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/gui/ag_screenwidget.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_combo.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_listbox.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/gui/ag_frame.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/gui/ag_text.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_button.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_edit.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_radiogroup.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/gui/ag_scroller.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_radiogroup.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/gui/ag_tooltip.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_menuitem.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_combo.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_menu.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/gui/ag_caption.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/gui/ag_window.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/gui/ag_checkbox.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_menuitem.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_radio.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/gui/ag_theme.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_border.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_background.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/gui/ag_local.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_edit.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_radio.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_menu.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_background.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_listbox.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_image.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/gui/ag_border.h&quot;
 #ifdef SWIG
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_layoutfactory.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_widget.h&quot;
@@ -91,26 +91,26 @@
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_table.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_layout.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_colorbutton.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_button.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_image.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_screenwidget.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_combo.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_listbox.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_frame.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_text.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_button.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_edit.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_radiogroup.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_scroller.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_radiogroup.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_tooltip.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_menuitem.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_combo.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_menu.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_caption.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_window.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_checkbox.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_menuitem.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_radio.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_theme.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_border.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_background.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/gui/ag_local.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_edit.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_radio.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_menu.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_background.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_listbox.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_image.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/gui/ag_border.h&quot;
 #endif
 #endif

Added: antargis/branches/rant/ext/math/ag_algebra.cc
===================================================================
--- antargis/branches/rant/ext/math/ag_algebra.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/math/ag_algebra.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,208 @@
+#include &quot;ag_algebra.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_gauss.h&quot;
+#include &quot;ag_stringstream.h&quot;
+
+
+
+AGMatrixN::AGMatrixN(size_t w,size_t h):m(w*h,0),
+					mW(w),mH(h)
+{
+}
+
+AGMatrixN::AGMatrixN(const AGMatrixN &amp;n):m(n.m),
+					mW(n.mW),
+					mH(n.mH)
+{
+}
+
+void AGMatrixN::set(size_t x,size_t y,float v)
+{
+  assert(x&lt;mW);
+  assert(y&lt;mH);
+  m[index(x,y)]=v;
+}
+float AGMatrixN::get(size_t x,size_t y) const
+{
+  assert(x&lt;mW);
+  assert(y&lt;mH);
+  return m[index(x,y)];
+}
+
+AGMatrixN &amp;AGMatrixN::operator*=(const AGMatrixN &amp;p)
+{
+  assert(mW==p.mH);
+  AGMatrixN n(p.mW,mH);
+  for(size_t x=0;x&lt;p.mW;x++)
+    for(size_t y=0;y&lt;mH;y++)
+      {
+	float v=0;
+	for(size_t k=0;k&lt;mW;k++)
+	  v+=get(k,y)*p.get(x,k);
+	n.set(x,y,v);
+      }
+  *this=n;
+  return *this;
+    
+}
+AGMatrixN AGMatrixN::operator*(const AGMatrixN &amp;p) const
+{
+  assert(mW==p.mH);
+  AGMatrixN n(p.mW,mH);
+  for(size_t x=0;x&lt;p.mW;x++)
+    for(size_t y=0;y&lt;mH;y++)
+      {
+	float v=0;
+	for(size_t k=0;k&lt;mW;k++)
+	  v+=get(k,y)*p.get(x,k);
+	n.set(x,y,v);
+      }
+  return n;
+}
+
+AGMatrixN AGMatrixN::operator-(const AGMatrixN &amp;p) const
+{
+  assert(mW==p.mW);
+  assert(mH==p.mH);
+  AGMatrixN n(mW,mH);
+
+  for(size_t x=0;x&lt;mW;x++)
+    for(size_t y=0;y&lt;mH;y++)
+      n.set(x,y,get(x,y)-p.get(x,y));
+  return n;
+}
+
+float AGMatrixN::scalar() const
+{
+  float s=0;
+  float v;
+  for(size_t x=0;x&lt;mW;x++)
+    for(size_t y=0;y&lt;mH;y++)
+      {
+	v=get(x,y);
+	s+=v*v;
+      }
+  return sqrt(s);
+}
+
+
+AGMatrixN AGMatrixN::makeQuadratic() const
+{
+  size_t nw=std::max(mW,mH);
+  AGMatrixN a(nw,nw);
+  a.copyFrom(*this);
+  return a;
+}
+
+/// a very simple way to compute a pseudo-inverse
+/// using svd may be better - no matter ;-)
+/// for details go to <A HREF="http://en.wikipedia.org/wiki/Pseudoinverse">http://en.wikipedia.org/wiki/Pseudoinverse</A>
+AGMatrixN AGMatrixN::pseudoInverse() const
+{
+  AGMatrixN t=transposed();
+  if(mW&lt;mH)
+    return (t*(*this)).inverse()*t;
+  else
+    return t*((*this)*t).inverse();
+}
+
+AGMatrixN AGMatrixN::transposed() const
+{
+  AGMatrixN a(mH,mW);
+  for(size_t x=0;x&lt;mW;x++)
+    for(size_t y=0;y&lt;mH;y++)
+      a.set(y,x,get(x,y));
+  return a;
+}
+
+
+
+AGMatrixN AGMatrixN::inverse() const
+{
+  size_t nw=std::max(mW,mH);
+  AGMatrixN a(nw,nw),b(nw,nw);
+
+  a.makeUnitMatrix();
+  b.copyFrom(*this);
+  /*
+  std::cout&lt;&lt;&quot;A:&quot;&lt;&lt;std::endl;
+  a.output();
+  std::cout&lt;&lt;&quot;B:&quot;&lt;&lt;std::endl;
+  b.output();
+  */
+  gauss(a,b,nw);
+  /*
+  std::cout&lt;&lt;&quot;A:&quot;&lt;&lt;std::endl;
+  a.output();
+  std::cout&lt;&lt;&quot;B:&quot;&lt;&lt;std::endl;
+  b.output();*/
+  return a;
+}
+
+void AGMatrixN::makeUnitMatrix()
+{
+  for(size_t x=0;x&lt;mW;x++)
+    for(size_t y=0;y&lt;mH;y++)
+      set(x,y,(x==y?1:0));
+}
+  
+void AGMatrixN::copyFrom(const AGMatrixN &amp;p)
+{
+  for(size_t x=0;x&lt;mW &amp;&amp; x&lt;p.mW;x++)
+    for(size_t y=0;y&lt;mH &amp;&amp; y&lt;p.mH;y++)
+      set(x,y,p.get(x,y));
+}
+
+void AGMatrixN::output() const
+{
+  for(size_t y=0;y&lt;mH;y++)
+    {
+      for(size_t x=0;x&lt;mW;x++)
+	{
+	  std::cout&lt;&lt;get(x,y)&lt;&lt;&quot;\t&quot;;
+	}
+      std::cout&lt;&lt;&quot;\n&quot;;
+    }
+
+}
+
+AGString AGMatrixN::toString() const
+{
+  AGStringStream s;
+  for(size_t y=0;y&lt;mH;y++)
+    {
+      for(size_t x=0;x&lt;mW;x++)
+	{
+	  s&lt;&lt;get(x,y)&lt;&lt;&quot;\t&quot;;
+	}
+      s&lt;&lt;&quot;\n&quot;;
+    }
+  return s.str();
+}
+
+void AGMatrixN::swapRows(size_t a,size_t b)
+{
+  if(a==b)
+    return;
+  assert(a&lt;mH);
+  assert(b&lt;mH);
+  for(size_t x=0;x&lt;mW;x++)
+    {
+      float t=get(x,a);
+      set(x,a,get(x,b));
+      set(x,b,t);
+    }
+}
+void AGMatrixN::swapCols(size_t a,size_t b)
+{
+  if(a==b)
+    return;
+  assert(a&lt;mW);
+  assert(b&lt;mW);
+  for(size_t y=0;y&lt;mH;y++)
+    {
+      float t=get(a,y);
+      set(a,y,get(b,y));
+      set(b,y,t);
+    }
+}

Added: antargis/branches/rant/ext/math/ag_algebra.h
===================================================================
--- antargis/branches/rant/ext/math/ag_algebra.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/math/ag_algebra.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,50 @@
+#ifndef AG_ALGEBRA_H
+#define AG_ALGEBRA_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &lt;vector&gt;
+#include &lt;ag_string.h&gt;
+
+class AGMatrixN
+{
+ public:
+  AGMatrixN(size_t w,size_t h);
+  AGMatrixN(const AGMatrixN &amp;p);
+
+  void set(size_t x,size_t y,float v);
+  float get(size_t x,size_t y) const;
+
+  AGMatrixN &amp;operator*=(const AGMatrixN &amp;p);
+  AGMatrixN operator*(const AGMatrixN &amp;p) const;
+
+  AGMatrixN operator-(const AGMatrixN &amp;p) const;
+
+  float scalar() const;
+
+  AGMatrixN inverse() const;
+  AGMatrixN pseudoInverse() const;
+  AGMatrixN makeQuadratic() const;
+
+  AGMatrixN transposed() const;
+
+  void makeUnitMatrix();
+
+  void copyFrom(const AGMatrixN &amp;p);
+
+  void output() const;
+
+  AGString toString() const;
+
+  void swapRows(size_t a,size_t b);
+  void swapCols(size_t a,size_t b);
+
+ private:
+  
+  inline size_t index(size_t x,size_t y) const { return x+y*mW; }
+
+  std::vector&lt;float&gt; m;
+  size_t mW,mH;
+};
+
+#endif

Added: antargis/branches/rant/ext/math/ant_frustum.cc
===================================================================
--- antargis/branches/rant/ext/math/ant_frustum.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/math/ant_frustum.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ant_frustum.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ant_frustum.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_profiler.h&quot;
+
+/////////////////////////////////////////////////////////////////////
+// AntPlane
+/////////////////////////////////////////////////////////////////////
+
+AntPlane::AntPlane(const AGVector3 &amp;dir,float offset):
+  mDir(dir),
+  mOffset(offset)
+{
+}
+
+AntPlane makePlane(const AGVector3 &amp;p0,const AGVector3 &amp;p1,const AGVector3 &amp;p2)
+{
+  AGVector3 up=p1-p0;
+  AGVector3 right=p2-p0;
+  up/=up.length();
+  right/=right.length();
+#warning &quot;maybe this must be swapped!&quot;
+  AGVector3 dir=up%right;
+  
+  return AntPlane(dir,dir*p0);
+}
+
+
+/////////////////////////////////////////////////////////////////////
+// AntFrustum
+/////////////////////////////////////////////////////////////////////
+AntFrustum::AntFrustum(const std::vector&lt;AntPlane&gt; &amp;pPlanes):
+  mPlanes(pPlanes)
+{
+  assert(mPlanes.size()==6);
+
+  //  cdebug(*this);
+}
+
+bool AntFrustum::inside(const AGVector3 &amp;v) const
+{
+  for(std::vector&lt;AntPlane&gt;::const_iterator i=mPlanes.begin();i!=mPlanes.end();++i)
+    if(!i-&gt;inside(v))
+      return false;
+  return true;
+}
+
+bool AntFrustum::collides(const AGBox3 &amp;b) const
+{
+  static std::vector&lt;AGVector3&gt; vs(8);
+  {
+    b.calcVertices(vs);
+  }
+  static bool outside;
+  static std::vector&lt;AntPlane&gt;::const_iterator i;
+  static std::vector&lt;AGVector3&gt;::iterator j;
+
+  
+  for(i=mPlanes.begin();i!=mPlanes.end();++i)
+    {
+      outside=true;
+      for(j=vs.begin();j!=vs.end();++j)
+	{
+	  if(i-&gt;inside(*j))
+	    {
+	      outside=false;
+	      break;
+	    }
+	}
+      if(outside)
+	return false;
+    }
+  return true;
+}
+
+
+std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AntPlane &amp;p)
+{
+  o&lt;&lt;&quot;(&quot;&lt;&lt;p.mDir&lt;&lt;&quot;,&quot;&lt;&lt;p.mOffset&lt;&lt;&quot;)&quot;;
+  return o;
+}
+std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AntFrustum &amp;p)
+{
+  for(std::vector&lt;AntPlane&gt;::const_iterator i=p.mPlanes.begin();i!=p.mPlanes.end();++i)
+    o&lt;&lt;*i&lt;&lt;&quot;;&quot;;
+  return o;
+}

Added: antargis/branches/rant/ext/math/ant_frustum.h
===================================================================
--- antargis/branches/rant/ext/math/ant_frustum.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/math/ant_frustum.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ant_frustum.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef ANT_FRUSTUM_H
+#define ANT_FRUSTUM_H
+
+#include &quot;ag_geometry.h&quot;
+
+class AntPlane
+{
+ public:
+  AntPlane(const AGVector3 &amp;dir,float offset);
+
+  bool inside(const AGVector3 &amp;v) const;
+
+  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AntPlane &amp;p);
+ private:
+  AGVector3 mDir;
+  float mOffset;
+};
+
+/// p0 is center - p1 is above and p2 at the right, then positive normal points into screen
+AntPlane makePlane(const AGVector3 &amp;p0,const AGVector3 &amp;p1,const AGVector3 &amp;p2);
+
+class AntFrustum
+{
+ public:
+  AntFrustum(const std::vector&lt;AntPlane&gt; &amp;pPlanes);
+
+  bool inside(const AGVector3 &amp;v) const;
+  bool collides(const AGBox3 &amp;v) const;
+
+  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AntFrustum &amp;p);
+ private:
+  std::vector&lt;AntPlane&gt; mPlanes;
+};
+
+std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AntPlane &amp;p);
+std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AntFrustum &amp;p);
+
+inline bool AntPlane::inside(const AGVector3 &amp;v) const
+{
+  return v*mDir-mOffset&gt;0;
+}
+
+#endif

Added: antargis/branches/rant/ext/sound/ag_mixer.cc
===================================================================
--- antargis/branches/rant/ext/sound/ag_mixer.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/sound/ag_mixer.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,455 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_sound.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_mixer.h&quot;
+#include &quot;ag_kill.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_mutex.h&quot;
+#include &quot;ag_fs.h&quot;
+#include &quot;ag_config.h&quot;
+#include &quot;ag_main.h&quot;
+
+#define USE_RWOPS
+
+#include &lt;SDL_mixer.h&gt;
+#include &lt;map&gt;
+#include &lt;set&gt;
+
+Mix_Music *mMusic=0;
+bool mMusicFinished=false;
+bool mMusicInited=false;
+
+bool mNoSound=false;
+
+const int cSoundChannels=16;
+
+std::map&lt;std::string,Mix_Chunk*&gt; mSounds;
+
+std::set&lt;int&gt; mFreeChannels;
+AGMutex *mSoundMutex;
+
+void musicFinished()
+{
+  mMusicFinished=true;
+}
+void channelDone(int channel)
+{
+  mSoundMutex-&gt;enter();
+  mFreeChannels.insert(channel);
+  mSoundMutex-&gt;leave();
+}
+int getFreeChannel()
+{
+  mSoundMutex-&gt;enter();
+  // FIXME: lock
+  int c=-1;
+  if(mFreeChannels.size())
+    {
+      c=*mFreeChannels.begin();
+      mFreeChannels.erase(c);
+    }
+  // FIXME: unlock
+  mSoundMutex-&gt;leave();
+  return c;
+}
+
+
+class AGPrivateSoundNotifier:public AGRepeatedCall
+{
+public:
+  void call()
+  {
+    getSoundManager()-&gt;checkFinished();
+  }
+};
+
+static AGPrivateSoundNotifier *privateSoundNotifier=0;
+
+
+void initSoundEngine()
+{
+  if(!mMusicInited)
+    {
+      TRACE;
+      mSoundMutex=new AGMutex;
+
+      size_t chunkSize=1024;
+      if(getConfig()-&gt;get(&quot;mixerChunkSize&quot;)==&quot;2048&quot;)
+	chunkSize=2048;
+      if(getConfig()-&gt;get(&quot;mixerChunkSize&quot;)==&quot;4096&quot;)
+	chunkSize=4096;
+      if(getConfig()-&gt;get(&quot;mixerChunkSize&quot;)==&quot;8192&quot;)
+	chunkSize=8192;
+
+      cdebug(&quot;CHUNKSIZE:&quot;&lt;&lt;chunkSize);
+
+      if(Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, chunkSize)==-1) {
+	printf(&quot;Mix_OpenAudio: %s\n&quot;, Mix_GetError());
+	mNoSound=true;
+	return;
+      }
+      mMusic=0;
+      
+      Mix_HookMusicFinished(musicFinished);
+
+      // enable mixing
+
+
+      Mix_AllocateChannels(cSoundChannels);
+      for(int i=0;i&lt;cSoundChannels;i++)
+	mFreeChannels.insert(i);
+
+
+      Mix_ChannelFinished(channelDone);
+      mMusicInited=true;
+    }
+
+  if(!privateSoundNotifier)
+    {
+      privateSoundNotifier=new AGPrivateSoundNotifier;
+    }
+
+}
+
+void closeSoundEngine()
+{
+  if(mNoSound)
+    return;
+  if(mMusicInited)
+    {
+      if(mMusic)
+	{
+	  // free music
+	  Mix_FreeMusic(mMusic);
+	  mMusic=0;
+	}
+      //FIXME: readd this
+      Mix_CloseAudio();
+      delete mSoundMutex;
+    }
+}
+
+
+AGSound::~AGSound()
+{ 
+	if(getCollector())
+		getCollector()-&gt;removeGlobal(this);
+
+  closeSoundEngine();
+}
+
+bool AGSound::playMp3(const std::string &amp;pFilename)
+{
+  if(mNoSound)
+    return false;
+  if(mMusic)
+    {
+      return false;
+    }
+  initSoundEngine();
+  // load the MP3 file &quot;music.mp3&quot; to play as music
+  mMusic=Mix_LoadMUS(pFilename.c_str());
+  if(!mMusic) {
+    printf(&quot;Mix_LoadMUS(\&quot;%s\&quot;): %s\n&quot;,pFilename.c_str(), Mix_GetError());
+    //    assertGL;
+    return false;
+  }
+    
+  // this might be a critical error...
+  
+  
+  
+  // play music forever
+  // Mix_Music *music; // I assume this has been loaded already
+  // -1 is forever
+  // 0 is never
+  // 1 is once
+  if(Mix_PlayMusic(mMusic, 1)==-1) {
+    printf(&quot;Mix_PlayMusic: %s\n&quot;, Mix_GetError());
+    //    assertGL;
+    // well, there's no music, but most games don't break without music...
+  }
+  
+  
+    
+  mMusicFinished=false;
+
+  // set hook
+
+  //  assertGL;
+    
+  return true;
+}
+
+bool AGSound::isMusicPlaying() const
+{
+  return mMusicFinished;
+}
+
+
+bool AGSound::playMp3DRM(const std::string &amp;pFilename,AGDecryptor &amp;pDec)
+{
+  //  assertGL;
+  if(mNoSound)
+    return false;
+  // must decrypt and write to disc :-(((
+  std::string file=loadFile(pFilename);
+
+  file=pDec.decrypt(file,pFilename);
+
+  /*  return playMp3(findFile(&quot;file.ogg&quot;));
+  playWave(findFile(&quot;file.wav&quot;),1);
+  return true;*/
+
+#ifndef OLDDEC
+  cdebug(&quot;ok decrypting&quot;);
+  if(!saveFile(&quot;drm.dat&quot;,file))
+    {
+      cdebug(&quot;error before playing!&quot;);
+      return false;
+    }
+  cdebug(&quot;playing&quot;);
+
+
+
+
+
+  return playMp3(findFile(&quot;drm.dat&quot;));
+#else
+
+  SDL_RWops* rw=SDL_RWFromMem(const_cast&lt;char*&gt;(file.c_str()),file.length());
+
+
+  initSoundEngine();
+  // load the MP3 file &quot;music.mp3&quot; to play as music
+  mMusic=Mix_LoadMUS_RW(rw);
+  if(!mMusic) {
+    printf(&quot;Mix_LoadMUS_RW(\&quot;%s\&quot;): %s\n&quot;,pFilename.c_str(), Mix_GetError());
+    //    assertGL;
+    return false;
+  }
+    
+  //  assertGL;
+  // this might be a critical error...
+  
+  
+  
+  // play music forever
+  // Mix_Music *music; // I assume this has been loaded already
+  // -1 is forever
+  // 0 is never
+  // 1 is once
+  if(Mix_PlayMusic(mMusic, 1)==-1) {
+    printf(&quot;Mix_PlayMusic: %s\n&quot;, Mix_GetError());
+    // well, there's no music, but most games don't break without music...
+  }
+  
+  
+  //  assertGL;
+    
+  mMusicFinished=false;
+
+  // set hook
+    
+  return true;
+
+
+
+
+
+
+#endif
+}
+
+
+
+void AGSound::stopMp3()
+{
+  if(mNoSound)
+    return;
+  if(mMusic)
+    {
+      Mix_HaltMusic();
+      Mix_FreeMusic(mMusic);
+      mMusic=0;
+    }      
+}
+AGSound::AGSound():AGMessageObject(),sigMp3Finished(this,&quot;sigMp3Finished&quot;)
+{
+	if(getCollector())
+		getCollector()-&gt;insertGlobal(this);
+	else
+		std::cerr&lt;&lt;&quot;Possible Error:getCollector()==0!&quot;&lt;&lt;std::endl;
+  REGISTER_SINGLETON(this);
+  soundVol=1.0f;
+
+  mNoSound=getConfig()-&gt;get(&quot;soundEnabled&quot;)==&quot;false&quot;;
+  getConfig()-&gt;set(&quot;soundEnabled&quot;,mNoSound?&quot;false&quot;:&quot;true&quot;);
+}
+
+void AGSound::checkFinished()
+{
+  if(mNoSound)
+    return;
+  if(mMusicInited)
+    if(mMusicFinished)
+      {
+	Mix_FreeMusic(mMusic);
+	mMusic=0;
+	
+	
+	sigMp3Finished(new AGEvent(this,&quot;musicFinished&quot;));
+	mMusicFinished=false;
+      }
+}
+
+void AGSound::fadeOutMusic(int ms)
+{
+  if(mNoSound)
+    return;
+  assert(ms&gt;0);
+  Mix_FadeOutMusic(ms);
+}
+
+void AGSound::volumeSound(int i,float v)
+{
+  int mv=((int)(v*MIX_MAX_VOLUME));
+  mv=std::min(std::max(0,mv),MIX_MAX_VOLUME);
+  if(i&gt;=0 &amp;&amp; i&lt;cSoundChannels)
+    Mix_Volume(i,mv);
+}
+
+
+void AGSound::volumeSound(float v)
+{
+  if(mNoSound)
+    return;
+  initSoundEngine();
+  if(mNoSound)
+    return;
+  int mv=((int)(v*MIX_MAX_VOLUME));
+  mv=std::min(std::max(0,mv),MIX_MAX_VOLUME);
+  for(int i=0;i&lt;cSoundChannels;++i)
+    Mix_Volume(i,mv);
+  soundVol=v;
+}
+void AGSound::volumeMusic(float v)
+{
+  if(mNoSound)
+    return;
+  initSoundEngine();
+  Mix_VolumeMusic(((int)(v*MIX_MAX_VOLUME)));
+}
+
+
+
+void AGSound::playWave(const std::string &amp;pFilename,float volume)
+{
+  if(mNoSound)
+    return;
+  initSoundEngine();
+  if(volume&lt;0)
+    volume=soundVol;
+  else
+    volume*=soundVol;
+  if(mFreeChannels.size()&gt;0)
+    {
+      loadWave(pFilename);
+      int channel=getFreeChannel();
+      if(channel&gt;=0)
+	{
+	  Mix_Chunk *c=mSounds[pFilename];
+	  Mix_Volume(channel,(int)(std::min(1.0f,volume)*MIX_MAX_VOLUME));
+	  Mix_PlayChannel(channel,c,0);
+	}
+    }
+
+}
+
+
+int AGSound::loopPlay(const std::string &amp;pFilename,float volume)
+{
+  if(mNoSound)
+    return false;
+  initSoundEngine();
+  if(volume&lt;0)
+    volume=soundVol;
+  if(mFreeChannels.size()&gt;0)
+    {
+      loadWave(pFilename);
+      int channel=getFreeChannel();
+      if(channel&gt;=0)
+	{
+	  Mix_Chunk *c=mSounds[pFilename];
+	  Mix_Volume(channel,(int)(std::min(1.0f,volume)*MIX_MAX_VOLUME));
+	  Mix_PlayChannel(channel,c,-1);
+	}
+      return channel;
+    }
+  return -1;
+}
+void AGSound::stopChannel(int i,int ms)
+{
+  if(mNoSound)
+    return;
+  if(i&gt;=0 &amp;&amp; i&lt;cSoundChannels)
+    Mix_FadeOutChannel(i,ms);
+  channelDone(i);
+}
+
+void AGSound::stopAllChannels(int ms)
+{
+  if(mNoSound)
+    return;
+  for(int i=0;i&lt;cSoundChannels;i++)
+    if(mFreeChannels.find(i)==mFreeChannels.end())
+      stopChannel(i,ms);
+}
+
+
+
+void AGSound::loadWave(const std::string &amp;pFilename)
+{
+  if(mNoSound)
+    return;
+  std::map&lt;std::string,Mix_Chunk*&gt;::iterator i=mSounds.find(pFilename);
+  if(i!=mSounds.end())
+    return;
+  
+  Mix_Chunk *sample;
+  std::string file=loadFile(pFilename);
+  sample=Mix_LoadWAV_RW(SDL_RWFromMem(const_cast&lt;char*&gt;(file.c_str()),file.length()),1);
+
+  mSounds[pFilename]=sample;
+}
+
+
+
+AGSound *mSoundManager=0;
+AGSound *getSoundManager()
+{
+  if(!mSoundManager)
+    {
+      mSoundManager=new AGSound;
+    }
+  return mSoundManager;
+}
+
+

Added: antargis/branches/rant/ext/sound/ag_mixer.h
===================================================================
--- antargis/branches/rant/ext/sound/ag_mixer.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/sound/ag_mixer.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_sound.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_SOUND_H
+#define AG_SOUND_H
+
+#include &lt;string&gt;
+#include &lt;ag_widget.h&gt;
+#include &lt;ag_surface.h&gt; // for decryptor
+
+// use widget, though this isn't one, because it provides useable functions
+class AGSound:public AGMessageObject
+// #Widget
+{
+ public:
+  AGSound(); // NEVER use this! - it's only provided due to swig
+  ~AGSound();
+  bool playMp3(const std::string &amp;pFilename);
+  bool playMp3DRM(const std::string &amp;pFilename,AGDecryptor &amp;pDec);
+
+  bool isMusicPlaying() const;
+
+  void stopMp3();
+  void checkFinished();
+  void fadeOutMusic(int ms);
+
+  void playWave(const std::string &amp;pFilename,float v=-1.0);
+  int loopPlay(const std::string &amp;pFilename,float v=-1.0);
+  void stopChannel(int i,int ms=200);
+  void stopAllChannels(int ms=200);
+
+  void volumeSound(int i,float v); // 0 to 1
+  void volumeSound(float v); // 0 to 1
+  void volumeMusic(float v); // 0 to 1
+
+  void loadWave(const std::string &amp;pFilename);
+
+
+  AGSignal sigMp3Finished;
+ private:
+
+  friend AGSound *getSoundManager();
+  float soundVol;
+
+};
+
+AGSound *getSoundManager();
+
+#endif
+

Added: antargis/branches/rant/ext/video/ag_clip.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_clip.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_clip.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,101 @@
+#include &quot;ag_clip.h&quot;
+#include &quot;ag_projection.h&quot;
+#include &quot;ag_stringstream.h&quot;
+#include &lt;stdexcept&gt;
+
+void AGClipping::exclude(const AGRect2 &amp;r)
+{
+  mExclude.push_back(r);
+  //FIXME: check for intersections
+}
+ 
+void AGClipping::include(const AGRect2 &amp;r)
+{
+  std::vector&lt;AGRect2&gt; n;
+  
+  for(std::vector&lt;AGRect2&gt;::iterator i=mExclude.begin();i!=mExclude.end();i++)
+    {
+      std::vector&lt;AGRect2&gt; t=(*i).difference(r);
+      std::copy(t.begin(),t.end(),std::back_inserter(n));
+    }
+  mExclude=n;
+}
+  
+std::vector&lt;AGRect2&gt; AGClipping::clip(const AGRect2&amp;r)
+{
+  std::vector&lt;AGRect2&gt; t,n;
+
+  t.push_back(r);
+
+  for(std::vector&lt;AGRect2&gt;::iterator i=mExclude.begin();i!=mExclude.end();i++)
+    {
+      for(std::vector&lt;AGRect2&gt;::iterator j=t.begin();j!=t.end();j++)
+	{
+	  std::vector&lt;AGRect2&gt; t2=j-&gt;difference(*i);
+	  for(std::vector&lt;AGRect2&gt;::iterator k=t2.begin();k!=t2.end();k++)
+	    {
+	      if(k-&gt;w()&gt;0 &amp;&amp; k-&gt;h()&gt;0)
+		n.push_back(*k);
+	    }
+	}
+      t=n;
+      n.clear();
+      
+    }
+
+  // FIXME: check for optimization
+
+  return t;
+  
+}
+
+bool AGClipping::included(const AGVector2 &amp;v)
+{
+  for(std::vector&lt;AGRect2&gt;::iterator i=mExclude.begin();i!=mExclude.end();i++)
+    if(i-&gt;contains(v))
+      return false;
+  return true;
+}
+
+
+std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt; AGClipping::clip(const AGRect2&amp;r,const AGRect2 &amp;sync)
+{
+  std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt; n;
+
+  std::vector&lt;AGRect2&gt; t=clip(r);
+
+  AGProjection2D p(r,sync);
+  
+  for(std::vector&lt;AGRect2&gt;::iterator i=t.begin();i!=t.end();i++)
+    {
+      n.push_back(std::make_pair(*i,p.project(*i)));
+    }
+
+  return n;
+}
+
+AGString AGClipping::toString() const
+{
+  AGStringStream os;
+
+  os&lt;&lt;&quot;[AGClipping:&quot;;
+  for(std::vector&lt;AGRect2&gt;::const_iterator i=mExclude.begin();i!=mExclude.end();i++)
+    os&lt;&lt;i-&gt;toString()&lt;&lt;&quot;;&quot;;
+  os&lt;&lt;&quot;]&quot;;
+
+  return os.str();
+}
+
+std::vector&lt;AGLine2&gt; AGClipping::clip(const AGLine2 &amp;p)
+{
+  #warning &quot;implement me&quot;
+  std::vector&lt;AGLine2&gt; l;
+  l.push_back(p);
+  return l;
+}
+
+bool AGClipping::valid() const
+{
+  #warning &quot;IMPLEMENT ME&quot;
+  return true;
+}

Added: antargis/branches/rant/ext/video/ag_clip.h
===================================================================
--- antargis/branches/rant/ext/video/ag_clip.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_clip.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,33 @@
+#ifndef AG_CLIP_H
+#define AG_CLIP_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include &lt;ag_geometry.h&gt;
+
+class AGClipping
+{
+ public:
+  void include(const AGRect2 &amp;r);
+  void exclude(const AGRect2 &amp;r);
+  
+  std::vector&lt;AGRect2&gt; clip(const AGRect2&amp;r);
+  std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt; clip(const AGRect2&amp;r,const AGRect2 &amp;sync);
+
+  std::vector&lt;AGLine2&gt; clip(const AGLine2 &amp;p);
+
+  bool included(const AGVector2 &amp;v);
+
+  bool valid() const;
+
+  AGString toString() const;
+
+ private:
+
+  void optimize();
+
+  //  std::vector&lt;AGRect2&gt; mInclude;
+  std::vector&lt;AGRect2&gt; mExclude;
+};
+
+#endif

Added: antargis/branches/rant/ext/video/ag_clip_painttarget.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_clip_painttarget.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_clip_painttarget.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,197 @@
+#include &quot;ag_clip_painttarget.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &quot;ag_projection.h&quot;
+
+AGClipPaintTarget::AGClipPaintTarget(AGPaintTarget *pTarget):mTarget(pTarget)
+{
+}
+
+void AGClipPaintTarget::blitTri(const AGTexture &amp;pSource,const AGTriangle2 &amp;pSrc,const AGTriangle2 &amp;pDest)
+{
+  cdebug(&quot;NOT IMPLEMENTED!&quot;);
+}
+
+void AGClipPaintTarget::blit(const AGTexture &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc,const AGColor &amp;pColor)
+{
+  std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt; l=mClipping.clip(pDest,pSrc);
+  for(std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt;::iterator i=l.begin();i!=l.end();i++)
+    {
+      mTarget-&gt;blit(pSource,i-&gt;first,i-&gt;second,pColor);
+    }
+}
+
+void AGClipPaintTarget::blit(const AGTexture &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc)
+{
+  std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt; l=mClipping.clip(pDest,pSrc);
+  for(std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt;::iterator i=l.begin();i!=l.end();i++)
+    {
+      mTarget-&gt;blit(pSource,i-&gt;first,i-&gt;second);
+    }
+}
+
+void AGClipPaintTarget::blit(const AGSurface &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc)
+{
+  std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt; l=mClipping.clip(pDest,pSrc);
+  for(std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt;::iterator i=l.begin();i!=l.end();i++)
+    {
+      mTarget-&gt;blit(pSource,i-&gt;first,i-&gt;second);
+    }
+}
+
+void AGClipPaintTarget::drawLine(const AGVector2 &amp;p0,const AGVector2 &amp;p1,const AGColor &amp;c)
+{
+  std::vector&lt;AGLine2&gt; l=mClipping.clip(AGLine2(p0,p1));
+  for(std::vector&lt;AGLine2&gt;::iterator i=l.begin();i!=l.end();i++)
+    mTarget-&gt;drawLine(i-&gt;getV0(),i-&gt;getV1(),c);
+}
+
+void AGClipPaintTarget::fillRect(const AGRect2 &amp;pr,const AGColor &amp;c)
+{
+  std::vector&lt;AGRect2&gt; l=mClipping.clip(pr);
+  for(std::vector&lt;AGRect2&gt;::iterator i=l.begin();i!=l.end();i++)
+    mTarget-&gt;fillRect(*i,c);
+}
+
+void AGClipPaintTarget::fillRects(const std::vector&lt;std::pair&lt;AGRect2,AGVector4&gt; &gt; &amp;pr)
+{
+  std::vector&lt;std::pair&lt;AGRect2,AGVector4&gt; &gt; l;
+
+  // collect clippings
+  for(std::vector&lt;std::pair&lt;AGRect2,AGVector4&gt; &gt;::const_iterator i=pr.begin();i!=pr.end();i++)
+    {
+      std::vector&lt;AGRect2&gt; l2=mClipping.clip(i-&gt;first);
+      for(std::vector&lt;AGRect2&gt;::iterator i2=l2.begin();i2!=l2.end();i2++)
+	l.push_back(std::make_pair(*i2,i-&gt;second));
+    }
+  mTarget-&gt;fillRects(l);
+}
+   
+void AGClipPaintTarget::blit(const AGTexture &amp;pSource,const std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt; &amp;pSrcDestRects,const AGColor &amp;pColor)
+{
+  std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt; l;
+
+  // collect clippings
+  for(std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt;::const_iterator i=pSrcDestRects.begin();i!=pSrcDestRects.end();i++)
+    {
+      std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt; l2=mClipping.clip(i-&gt;first,i-&gt;second);
+      std::copy(l2.begin(),l2.end(),std::back_inserter(l));
+    }
+  mTarget-&gt;blit(pSource,l,pColor);
+}
+
+void AGClipPaintTarget::tile(const AGTexture &amp;pSource,const AGRect2 &amp;pTarget, const AGColor &amp;pColor)
+{
+  //std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt; l2=mClipping.clip(i-&gt;first);
+  
+  cdebug(&quot;WARNING: AGClipPaintTarget::tile not implemented yet!&quot;);
+}
+   
+void AGClipPaintTarget::putPixel(int x,int y,const AGColor &amp;c)
+{
+  if(mClipping.included(AGVector2(x,y)))
+    mTarget-&gt;putPixel(x,y,c);
+}
+
+AGColor AGClipPaintTarget::getPixel(int x,int y) const
+{
+  return mTarget-&gt;getPixel(x,y);
+}
+
+  // manage painting sessions
+void AGClipPaintTarget::clip(const AGClipping &amp;c)
+{
+  mClipping=c;
+}
+
+void AGClipPaintTarget::unclip()
+{
+  mClipping=AGClipping();
+}
+
+AGRect2 AGClipPaintTarget::getRect() const
+{
+  return mTarget-&gt;getRect();
+}
+
+void AGClipPaintTarget::drawGradientAlpha(const AGRect2&amp; rect, const AGColor&amp; ul, const AGColor&amp; ur, const AGColor&amp; dl, const AGColor&amp; dr)
+{
+  CTRACE;
+  std::vector&lt;AGRect2&gt; rs=mClipping.clip(rect);
+
+  AGRect2 t(0,0,1,1);
+  AGProjection2D p(rect,t);
+
+  for(std::vector&lt;AGRect2&gt;::iterator i=rs.begin();i!=rs.end();i++)
+    {
+      AGRect2 r2=p.project(*i);
+      float x,y;
+      AGColor ul2,ur2,dl2,dr2;
+      
+      x=r2.x0();y=r2.y0();
+      ul2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x1();y=r2.y0();
+      ur2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x0();y=r2.y1();
+      dl2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x1();y=r2.y1();
+      dr2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      mTarget-&gt;drawGradientAlpha(*i,ul2,ur2,dl2,dr2);
+			    
+    }
+}
+
+void AGClipPaintTarget::drawGradient(const AGRect2&amp; rect, const AGColor&amp; ul, const AGColor&amp; ur, const AGColor&amp; dl, const AGColor&amp; dr)
+{
+  std::vector&lt;AGRect2&gt; rs=mClipping.clip(rect);
+
+  AGRect2 t(0,0,1,1);
+  AGProjection2D p(rect,t);
+
+  for(std::vector&lt;AGRect2&gt;::iterator i=rs.begin();i!=rs.end();i++)
+    {
+      AGRect2 r2=p.project(*i);
+      float x,y;
+      AGColor ul2,ur2,dl2,dr2;
+
+      cdebug(&quot;rect:&quot;&lt;&lt;rect);
+      cdebug(&quot;r2:&quot;&lt;&lt;r2);
+      cdebug(&quot;i:&quot;&lt;&lt;*i);
+      
+      x=r2.x0();y=r2.y0();
+      ul2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x1();y=r2.y0();
+      ur2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x0();y=r2.y1();
+      dl2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x1();y=r2.y1();
+      dr2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      cdebug(&quot;ul:&quot;&lt;&lt;ul);
+      cdebug(&quot;ur:&quot;&lt;&lt;ur);
+      cdebug(&quot;dl:&quot;&lt;&lt;dl);
+      cdebug(&quot;dr:&quot;&lt;&lt;dr);
+
+      cdebug(&quot;ul2:&quot;&lt;&lt;ul2);
+      cdebug(&quot;ur2:&quot;&lt;&lt;ur2);
+      cdebug(&quot;dl2:&quot;&lt;&lt;dl2);
+      cdebug(&quot;dr2:&quot;&lt;&lt;dr2);
+
+      mTarget-&gt;drawGradient(*i,ul2,ur2,dl2,dr2);
+			    
+    }
+}

Added: antargis/branches/rant/ext/video/ag_clip_painttarget.h
===================================================================
--- antargis/branches/rant/ext/video/ag_clip_painttarget.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_clip_painttarget.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_painttarget.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef __AG_CLIP_PAINTTARGET_H
+#define __AG_CLIP_PAINTTARGET_H
+
+#include &lt;ag_painttarget.h&gt;
+#include &lt;ag_clip.h&gt;
+
+/// virtual paint target - use this for advanced clipping !
+class AGClipPaintTarget:public AGPaintTarget
+{
+ public:
+  AGClipPaintTarget(AGPaintTarget *pTarget);
+
+  virtual void blitTri(const AGTexture &amp;pSource,const AGTriangle2 &amp;pSrc,const AGTriangle2 &amp;pDest);
+
+  virtual void blit(const AGTexture &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc,const AGColor &amp;pColor);
+  virtual void blit(const AGTexture &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc);
+  virtual void blit(const AGSurface &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc);
+
+  virtual void drawLine(const AGVector2 &amp;p0,const AGVector2 &amp;p1,const AGColor &amp;c);
+  virtual void fillRect(const AGRect2 &amp;pr,const AGColor &amp;c);
+
+  virtual void fillRects(const std::vector&lt;std::pair&lt;AGRect2,AGVector4&gt; &gt; &amp;pr);
+   
+  virtual void blit(const AGTexture &amp;pSource,const std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt; &amp;pSrcDestRects,const AGColor &amp;pColor);
+
+  virtual void tile(const AGTexture &amp;pSource,const AGRect2 &amp;pTarget, const AGColor &amp;pColor);
+
+  virtual void drawGradientAlpha(const AGRect2&amp; rect, const AGColor&amp; ul, const AGColor&amp; ur, const AGColor&amp; dl, const AGColor&amp; dr);
+  virtual void drawGradient(const AGRect2&amp; rect, const AGColor&amp; ul, const AGColor&amp; ur, const AGColor&amp; dl, const AGColor&amp; dr);
+   
+  virtual AGRect2 getRect() const;
+
+  virtual void putPixel(int x,int y,const AGColor &amp;c);
+  virtual AGColor getPixel(int x,int y) const;
+
+  // manage painting sessions
+  virtual void clip(const AGClipping &amp;c);
+
+  virtual void unclip();
+
+ private:
+  AGPaintTarget *mTarget;
+  AGClipping mClipping;
+};
+
+
+#endif
+

Added: antargis/branches/rant/ext/video/ag_painter.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_painter.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_painter.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,614 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_painter.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &lt;ag_debug.h&gt;
+#include &lt;ag_draw.h&gt;
+#include &lt;ag_fontengine.h&gt;
+#include &lt;ag_glscreen.h&gt;
+#include &lt;ag_painter.h&gt;
+#include &lt;ag_profiler.h&gt;
+#include &lt;ag_sdlsurface.h&gt;
+#include &lt;ag_texture.h&gt;
+#include &lt;math.h&gt;
+
+#include &lt;stdexcept&gt;
+
+//#define SPEED_TEST
+
+/////////////////////////////////////////////////////////////////////////////////
+// AGProjection
+/////////////////////////////////////////////////////////////////////////////////
+
+
+AGProjection::AGProjection(const AGRect2 &amp;pClip):clip(pClip)
+{
+  a.set(0,0,1);
+  a.set(0,1,0);
+  a.set(0,2,0);
+  a.set(1,0,0);
+  a.set(1,1,1);
+  a.set(1,2,0);
+  a.set(2,0,0);
+  a.set(2,1,0);
+  a.set(2,2,0);
+}
+
+AGProjection::AGProjection(const AGClipping &amp;pClip):advancedClipping(pClip)
+{
+  a.set(0,0,1);
+  a.set(0,1,0);
+  a.set(0,2,0);
+  a.set(1,0,0);
+  a.set(1,1,1);
+  a.set(1,2,0);
+  a.set(2,0,0);
+  a.set(2,1,0);
+  a.set(2,2,0);
+}
+
+
+AGVector2 AGProjection::project(const AGVector2 &amp;p) const
+{
+  AGVector2 r=(a*AGVector3(p[0],p[1],1)).dim2();
+
+  return r;
+}
+bool AGProjection::pointOk(const AGVector2 &amp;p) const
+{
+  return clip.contains(p);
+}
+
+AGRect2 AGProjection::project(const AGRect2 &amp;p) const
+{
+  AGRect2 r((a*AGVector3(p[0],1)).dim2(),
+	    (a*AGVector3(p[1],1)).dim2());
+  return r;
+}
+AGRect2 AGProjection::clipRect(AGRect2 target) const
+{
+  return clip.intersect(target);
+}
+
+
+std::pair&lt;AGRect2,AGRect2&gt; AGProjection::clipRect(AGRect2 target,AGRect2 src) const
+{
+  AGRect2 i=clip.intersect(target);
+  if(i.width()&lt;=0 || i.height()&lt;=0)
+    return std::make_pair(AGRect2(0,0,0,0),AGRect2(0,0,0,0));
+
+  assert(target.x0()&lt;clip.x1());
+
+
+ // clip left
+  if(target.x0()&lt;clip.x0())
+    {
+      float a=(clip.x0()-target.x0())/target.w();
+      float nw=target.x1()-clip.x0();
+      target.setLeft(clip.x0());
+      target.setWidth(nw);
+      nw=src.w()*(1.0f-a);
+      src.setLeft(src.x0()+src.w()*a);
+      src.setWidth(nw);
+    }
+
+  // clip top
+  if(target.y0()&lt;clip.y0())
+    {
+      float a=(clip.y0()-target.y0())/target.h();
+      float nh=target.y1()-clip.y0();
+      target.setTop(clip.y0());
+      target.setHeight(nh);
+      nh=src.h()*(1.0f-a);
+      src.setTop(src.y0()+src.h()*a);
+      src.setHeight(nh);
+    }
+
+  // clip right
+  if(target.x1()&gt;clip.x1())
+    {
+      float a=(target.x1()-clip.x1())/target.w();
+      target.setRight(clip.x1());
+      src.setRight(src.x1()-src.w()*a);
+    }
+
+  // clip bottom
+  if(target.y1()&gt;clip.y1())
+    {
+      float a=(target.y1()-clip.y1())/target.h();
+      target.setBottom(clip.y1());
+      src.setBottom(src.y1()-src.h()*a);
+    }
+
+  return std::make_pair(target,src);
+}
+
+void AGProjection::translate(const AGVector2 &amp;v)
+{
+  a.get(2,0)+=v[0];
+  a.get(2,1)+=v[1];
+}
+
+void AGProjection::setClip(const AGRect2&amp;p)
+{
+  clip=clip.intersect(p);
+}
+
+
+AGRect2 AGProjection::getRect() const
+{
+  AGRect2 r=clip;
+
+  r-=AGVector2(a.get(2,0),a.get(2,1));
+  return r;
+}
+
+AGLine2 AGProjection::clipLine(AGLine2 l) const
+{
+  AGLine2 d;
+
+  AGRect2 r=clip;
+
+  if((l[0][0]&lt;r.x0() &amp;&amp; l[1][0]&lt;r.x0()) ||
+     (l[0][0]&gt;r.x1() &amp;&amp; l[1][0]&gt;r.x1()) ||
+     (l[0][1]&lt;r.y0() &amp;&amp; l[1][1]&lt;r.y0()) ||
+     (l[0][1]&gt;r.y1() &amp;&amp; l[1][1]&gt;r.y1()))
+    return d; // hidden
+
+  float a;
+  // clip
+  for(size_t i=0;i&lt;1;i++)
+    {
+      if(l[i][0]&lt;r.x0())
+	{
+	  a=(r.x0()-l[i][0])/(l[1-i][0]-l[i][0]);
+	  l[i][0]=r.x0();
+	  l[i][1]=l[i][1]+(l[1-i][1]-l[i][1])*a;
+	}
+      if(l[i][1]&lt;r.y0())
+	{
+	  a=(r.y0()-l[i][1])/(l[1-i][1]-l[i][1]);
+	  l[i][1]=r.y0();
+	  l[i][0]=l[i][0]+(l[1-i][0]-l[i][0])*a;
+	}
+      if(l[i][0]&gt;r.x1())
+	{
+	  a=(l[i][0]-r.x1())/(l[i][0]-l[1-i][0]);
+	  l[i][0]=r.x1();
+	  l[i][1]=l[i][1]+(l[1-i][1]-l[i][1])*a;
+	}
+      if(l[i][1]&gt;r.y1())
+	{
+	  a=(l[i][1]-r.y1())/(l[i][1]-l[1-i][1]);
+	  l[i][1]=r.y1();
+	  l[i][0]=l[i][0]+(l[1-i][0]-l[i][0])*a;
+	}
+
+    }
+  return l;
+    
+}
+
+
+
+/////////////////////////////////////////////////////////////////////////////////
+// AGPainter
+/////////////////////////////////////////////////////////////////////////////////
+
+AGPainter::AGPainter():mCurrent(getScreen().getRect()),mTarget(&amp;getScreen())
+{
+  mTarget-&gt;beginPaint();
+}
+
+AGPainter::AGPainter(const AGPainter &amp;p):ps(p.ps),mCurrent(p.mCurrent),mTarget(p.mTarget)
+{
+  mTarget-&gt;beginPaint();
+}
+
+AGPainter::AGPainter(AGPaintTarget &amp;pTarget):mCurrent(pTarget.getRect()),mTarget(&amp;pTarget)
+{
+  mTarget-&gt;beginPaint();
+}
+
+
+AGPainter::~AGPainter()
+{
+  if(mTarget.valid())
+    {
+      mTarget-&gt;unclip();
+      mTarget-&gt;endPaint();
+    }
+}
+
+void AGPainter::putPixel(const AGVector2 &amp;p,const AGColor &amp;c)
+{
+  AGVector2 n=project(p);
+  if(pointOk(n))
+    {
+      mTarget-&gt;putPixel((int)n[0],(int)n[1],c);
+    }
+}
+
+void AGPainter::blit(const AGTexture &amp;pSource,const AGRect2 &amp;pDest)
+{
+  AGRect2 s=pSource.getRect();
+  // ASSUME: we don't want to scale
+  blit(pSource,AGRect2(pDest.x(),pDest.y(),s.w(),s.h()),s);
+}
+
+AGVector2 AGPainter::project(const AGVector2 &amp;p) const
+{
+  return mCurrent.project(p);
+}
+bool AGPainter::pointOk(const AGVector2 &amp;p) const
+{
+  return mCurrent.pointOk(p);
+}
+
+
+void AGPainter::blit(const AGTexture &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc)
+{
+  STACKTRACE;
+  AGRect2 d;
+  d=mCurrent.project(pDest);
+
+#ifdef OLDCLIP
+
+  std::pair&lt;AGRect2,AGRect2&gt; p=mCurrent.clipRect(d,pSrc);
+
+  //  cdebug(p.first&lt;&lt;&quot;   &quot;&lt;&lt;p.second);
+  if(p.first.w()&gt;0 &amp;&amp; p.first.h()&gt;0 &amp;&amp; p.second.w()&gt;0 &amp;&amp; p.second.h()&gt;0)
+    mTarget-&gt;blit(pSource,p.first,p.second);
+
+
+#else
+  #warning &quot;add clipping!&quot;
+
+  mTarget-&gt;blit(pSource,d,pSrc);//pSource.getRect());
+#endif
+}
+
+void AGPainter::blit(const AGTexture &amp;pSource,const AGRect2 &amp;pDest,const AGColor &amp;pColor)
+{
+  AGRect2 s=pSource.getRect();
+  // ASSUME: we don't want to scale
+  blit(pSource,AGRect2(pDest.x(),pDest.y(),s.w(),s.h()),s,pColor);
+}
+
+void AGPainter::blit(const AGTexture &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc,const AGColor &amp;pColor)
+{
+  STACKTRACE;
+#ifdef SPEED_TEST
+  mTarget-&gt;blit(pSource,pDest,pSrc,pColor);
+  return;
+#endif
+
+  AGRect2 d;
+  d=mCurrent.project(pDest);
+  std::pair&lt;AGRect2,AGRect2&gt; p=mCurrent.clipRect(d,pSrc);
+
+  if(p.first.w()&gt;0 &amp;&amp; p.first.h()&gt;0 &amp;&amp; p.second.w()&gt;0 &amp;&amp; p.second.h()&gt;0)
+    mTarget-&gt;blit(pSource,p.first,p.second,pColor);
+}
+
+
+void AGPainter::tile(const AGTexture &amp;pSource)
+{
+  tile(pSource,mTarget-&gt;getRect());
+}
+void AGPainter::tile(const AGTexture &amp;pSource,const AGRect2 &amp;pDest)
+{
+  tile(pSource,pDest,pSource.getRect());
+}
+void AGPainter::tile(const AGTexture &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc)
+{
+  STACKTRACE;
+  float x,y;
+  if(!dynamic_cast&lt;AGGLScreen*&gt;(mTarget.getPtr()))
+    {
+      #warning &quot;remove this and implement in agtexture*&quot;
+      for(y=pDest.y0();y&lt;pDest.y1();y+=pSrc.h())
+	for(x=pDest.x0();x&lt;pDest.x1();x+=pSrc.w())
+	  {
+	    float w=std::min(pSrc.w(),pDest.x1()-x);
+	    float h=std::min(pSrc.h(),pDest.y1()-y);
+	    blit(pSource,AGRect2(x,y,w,h),AGRect2(pSrc.x0(),pSrc.y0(),w,h));
+	  }
+      
+    }
+  else
+    {
+      mTarget-&gt;tile(pSource,mCurrent.project(pDest),AGColor(0xff,0xff,0xff,0xff));
+    }
+
+
+}
+
+
+// AGSurface-painting
+void AGPainter::blit(const AGSurface &amp;pSource,const AGRect2 &amp;pDest)
+{
+  AGRect2 s=pSource.getRect();
+  // ASSUME: we don't want to scale
+  blit(pSource,AGRect2(pDest.x(),pDest.y(),s.w(),s.h()),s);
+}
+void AGPainter::blit(const AGSurface &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc)
+{
+  STACKTRACE;
+  AGRect2 d;
+  d=mCurrent.project(pDest);
+  std::pair&lt;AGRect2,AGRect2&gt; p=mCurrent.clipRect(d,pSrc);
+
+  if(p.first.w()&gt;0 &amp;&amp; p.first.h()&gt;0 &amp;&amp; p.second.w()&gt;0 &amp;&amp; p.second.h()&gt;0)
+    mTarget-&gt;blit(pSource,p.first,p.second);
+}
+void AGPainter::tile(const AGSurface &amp;pSource)
+{
+  tile(pSource,mTarget-&gt;getRect());
+}
+void AGPainter::tile(const AGSurface &amp;pSource,const AGRect2 &amp;pDest)
+{
+  tile(pSource,pDest,pSource.getRect());
+
+}
+void AGPainter::tile(const AGSurface &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc)
+{
+  STACKTRACE;
+  float x,y;
+
+  std::vector&lt;std::pair&lt;AGRect2,AGRect2&gt; &gt; rects;
+  for(y=pDest.y0();y&lt;pDest.y1();y+=pSrc.h())
+    for(x=pDest.x0();x&lt;pDest.x1();x+=pSrc.w())
+      {
+	float w=std::min(pSrc.w(),pDest.x1()-x);
+	float h=std::min(pSrc.h(),pDest.y1()-y);
+	
+	rects.push_back(std::make_pair(AGRect2(pSrc.x0(),pSrc.y0(),w,h),AGRect2(x,y,w,h)));
+      }
+  mTarget-&gt;blit(pSource,rects,AGColor(0xff,0xff,0xff,0xff));
+}
+
+AGColor calcColor(AGVector2 p,const AGColor &amp;pc0,const AGColor &amp;pc1,const AGColor &amp;pc2,const AGColor &amp;pc3)
+{
+  return (pc0*(1-p[0]) + pc1*p[0])*(1-p[1]) + (pc2*(1-p[0]) + pc3*p[0])*p[1];
+}
+  
+void AGPainter::drawGradient(const AGRect2 &amp;pr,const AGColor &amp;pc0,const AGColor &amp;pc1,const AGColor &amp;pc2,const AGColor &amp;pc3)
+{
+  STACKTRACE;
+  AGGLScreen *glScreen=dynamic_cast&lt;AGGLScreen*&gt;(mTarget.getPtr());
+  
+  AGRect2 src(0,0,1,1);
+
+  AGRect2 d=mCurrent.project(pr);
+  std::pair&lt;AGRect2,AGRect2&gt; p=mCurrent.clipRect(d,src);
+
+  AGColor c0=calcColor(p.second.getV0(),pc0,pc1,pc2,pc3);
+  AGColor c1=calcColor(p.second.getV10(),pc0,pc1,pc2,pc3);
+  AGColor c2=calcColor(p.second.getV01(),pc0,pc1,pc2,pc3);
+  AGColor c3=calcColor(p.second.getV1(),pc0,pc1,pc2,pc3);
+
+  AGRect2 r=p.first;
+
+  if(p.first.w()&gt;0 &amp;&amp; p.first.h()&gt;0 &amp;&amp; p.second.w()&gt;0 &amp;&amp; p.second.h()&gt;0)
+    {
+      mTarget-&gt;drawGradient(r,c0,c1,c2,c3);
+      /*
+      if(glScreen)
+	{
+	  glScreen-&gt;drawGradient(r,c0,c1,c2,c3);
+	}
+      else if(opengl() &amp;&amp; dynamic_cast&lt;AGTexture*&gt;(mTarget.getPtr()))
+	{
+	  dynamic_cast&lt;AGTexture*&gt;(mTarget.getPtr())-&gt;drawGradient(r,c0,c1,c2,c3);
+	}
+      else
+	{
+	  AGSDLScreen *sdlScreen=dynamic_cast&lt;AGSDLScreen*&gt;(mTarget.getPtr());
+	    
+	  if(sdlScreen)
+	    {
+	      sdlScreen-&gt;drawGradient(d,pc0,pc1,pc2,pc3);
+	      //	      sdlScreen-&gt;drawGradient(r,c0,c1,c2,c3);
+	    }
+	  else
+	    {
+	      float cx,cy,y,x;
+	      float dx=1.0/r.w();
+	      float dy=1.0/r.h();
+	      for(cy=0,y=r.y0();y&lt;r.y1();y+=1,cy+=dy)
+		for(cx=0,x=r.x0();x&lt;r.x1();x+=1,cx+=dx)
+		  putPixel(AGVector2(x,y),(c0*(1-cx)+c1*cx)*(1-cy)+(c2*(1-cx)+c3*cx)*cy);
+	    }
+
+	    }*/
+    }
+}
+void AGPainter::renderText(const AGStringUtf8 &amp;pText,const AGVector2 &amp;p,const AGFont &amp;f)
+{
+  STACKTRACE;
+  AGTexture *t=getFontEngine()-&gt;renderText(0,0,pText,f);
+  if(t)
+    blit(*t,AGRect2(p[0],p[1],t-&gt;getSurfaceWidth(),t-&gt;getSurfaceHeight()));
+
+}
+void AGPainter::drawBorder(const AGRect2&amp; pRect,int width, const AGColor&amp; c1, const AGColor&amp; c2)
+{
+  STACKTRACE;
+  AGGLScreen *glScreen=dynamic_cast&lt;AGGLScreen*&gt;(mTarget.getPtr());
+  if(glScreen)
+    {
+      #warning &quot;add clipping in gl&quot;
+      glScreen-&gt;clip(mCurrent.clip);
+      glScreen-&gt;drawBorder(mCurrent.project(pRect),width,c1,c2);
+      //      glScreen-&gt;fillRect(AGRect2(0,0,1024,768),c1);
+      glScreen-&gt;unclip();
+      return;
+    }
+  // FIXME: 
+  // 1) maybe improve gl-renderer by using triangles
+  // 2) otherwise use line-drawing (which is clipped and transformed itself
+  // 3) transform is done for each line - maybe is slow
+  AGRect2 d=pRect;
+
+  for(int t=0;t&lt;width;t++)
+    {
+      drawLine(d.getV0(),d.getV01(),c1);
+      drawLine(d.getV0(),d.getV10(),c1);
+
+      drawLine(d.getV01(),d.getV1(),c2);
+      drawLine(d.getV10(),d.getV1(),c2);
+      d=d.shrink(1);
+    }
+}
+
+void AGPainter::fillRect(const AGRect2 &amp;pDest,const AGColor &amp;c)
+{
+  STACKTRACE;
+  AGRect2 d,pSrc;
+  d=mCurrent.project(pDest);
+  // FIXME: remove clipRect !!
+  AGRect2 p=mCurrent.clipRect(d);
+  if(p.w()&gt;0 &amp;&amp; p.h()&gt;0)
+    {
+      //      cdebug(p);
+      mTarget-&gt;fillRect(p,c);
+    }
+}
+
+void AGPainter::fillRects(const std::vector&lt;std::pair&lt;AGRect2,AGVector4&gt; &gt; &amp;pRects)
+{
+  STACKTRACE;
+  std::vector&lt;std::pair&lt;AGRect2,AGVector4&gt; &gt; rs;
+
+  for(std::vector&lt;std::pair&lt;AGRect2,AGVector4&gt; &gt;::const_iterator i=pRects.begin();i!=pRects.end();++i)
+    {
+      AGRect2 d=mCurrent.project(i-&gt;first);
+      if(!opengl())
+	d=mCurrent.clipRect(d);
+      if(d.w()&gt;0 &amp;&amp; d.h()&gt;0)
+	rs.push_back(std::make_pair(d,i-&gt;second));
+    }
+
+  if(rs.size())
+    mTarget-&gt;fillRects(rs);
+}
+
+
+void AGPainter::drawPoint(const AGVector2 &amp;p,const AGColor &amp;c,float size)
+{
+  STACKTRACE;
+  AGVector2 d=mCurrent.project(p);
+  if(mCurrent.pointOk(p))
+    {
+      mTarget-&gt;putPixel((int)d[0],(int)d[1],c);
+    }
+}
+
+
+AGColor AGPainter::getPixel(int x,int y)
+{
+  AGVector2 p=mCurrent.project(AGVector2(x,y));
+  if(!mCurrent.pointOk(p))
+    throw std::string(&quot;pixel out of clipping!&quot;);
+  return mTarget-&gt;getPixel((int)p[0],(int)p[1]);
+}
+
+void AGPainter::drawLine(const AGVector2 &amp;p0,const AGVector2 &amp;p1,const AGColor &amp;c)
+{
+  #warning &quot;Add line clipping&quot;
+  AGVector2 m0=mCurrent.project(p0);
+  AGVector2 m1=mCurrent.project(p1);
+  mTarget-&gt;drawLine(m0,m1,c);
+}
+
+void AGPainter::blitTri(const AGTexture &amp;pSource,const AGTriangle2 &amp;pSrc,const AGTriangle2 &amp;pDest)
+{
+  mTarget-&gt;blitTri(pSource,pSrc,pDest);
+}
+
+void AGPainter::drawCircle(const AGVector2 &amp;p,float rad,const AGColor &amp;color)
+{
+  // clipping done in putPixel
+
+  int x,y;
+  float r2=rad*rad;
+  for(x=((int)(p[0]-rad-1));x&lt;=p[0]+rad+1;x++)
+    for(y=((int)(p[1]-rad-1));y&lt;=p[1]+rad+1;y++)
+      {
+	float dx=x-p[0];
+	float dy=y-p[1];
+	float d2=dx*dx+dy*dy;
+
+	if(d2&lt;r2)
+	  {
+	    AGVector2 c(x,y);
+	    putPixel(c,color);
+	  }
+      }
+}
+
+void AGPainter::pushMatrix()
+{
+  ps.push_back(mCurrent);
+}
+void AGPainter::popMatrix()
+{
+  mCurrent=ps.back();
+  ps.pop_back();
+  mTarget-&gt;clip(mCurrent.clip);
+}
+void AGPainter::translate(const AGVector2 &amp;v)
+{
+  mCurrent.translate(v);
+}
+void AGPainter::scale(const AGVector2 &amp;v)
+{
+  throw std::string(&quot;not implemented!&quot;);
+}
+void AGPainter::clip(const AGRect2 &amp;r)
+{
+  AGRect2 p=mCurrent.project(r);
+  mCurrent.setClip(p);
+  mTarget-&gt;clip(mCurrent.clip);
+}
+
+void AGPainter::transform(const AGRect2 &amp;r)
+{
+  translate(r[0]);
+  clip(r.origin());
+}
+
+AGRect2 AGPainter::getRect() const
+{
+  return mCurrent.getRect();
+}
+
+void AGPainter::clip(const AGClipping &amp;clip)
+{
+	CTRACE;
+	throw std::runtime_error(&quot;NOT IMPLEMENTED !&quot;);
+}
+
+
+AGPaintTarget *AGPainter::getTarget()
+{
+  return mTarget.getPtr();
+}
+

Added: antargis/branches/rant/ext/video/ag_painter.h
===================================================================
--- antargis/branches/rant/ext/video/ag_painter.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_painter.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_painter.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef __AG_PAINTER_H
+#define __AG_PAINTER_H
+
+#include &lt;ag_color.h&gt;
+#include &lt;ag_surface.h&gt;
+#include &lt;ag_geometry.h&gt;
+#include &lt;ag_font.h&gt;
+#include &lt;ag_painttarget.h&gt;
+#include &lt;ag_clip.h&gt;
+#include &lt;ag_base.h&gt;
+
+
+#include &lt;list&gt;
+
+class AGTriangle2;
+class AGRect2;
+
+struct AGProjection
+{
+  AGMatrix3 a;
+  AGRect2 clip;
+  AGClipping advancedClipping;
+
+  AGProjection(const AGRect2 &amp;pClip);
+  AGProjection(const AGClipping &amp;pClip);
+
+  AGVector2 project(const AGVector2 &amp;p) const;
+  bool pointOk(const AGVector2 &amp;p) const;
+
+  AGRect2 project(const AGRect2 &amp;p) const;
+
+  std::pair&lt;AGRect2,AGRect2&gt; clipRect(AGRect2 target,AGRect2 src) const;
+  AGRect2 clipRect(AGRect2 target) const;
+
+
+  AGLine2 clipLine(AGLine2 l) const;
+
+  void translate(const AGVector2 &amp;v);
+  void setClip(const AGRect2&amp;p);
+
+  AGRect2 getRect() const;
+};
+
+#ifdef SWIG
+#undef AGEXPORT
+#define AGEXPORT
+#endif
+
+class AGEXPORT AGPainter
+{
+ public:
+  AGPainter();
+  AGPainter(const AGPainter &amp;p);
+  AGPainter(AGPaintTarget &amp;pTarget);
+  
+  ~AGPainter();
+
+  void putPixel(const AGVector2 &amp;p,const AGColor &amp;c);
+  AGColor getPixel(int x,int y);
+
+  void drawCircle(const AGVector2 &amp;p,float rad,const AGColor &amp;c);
+
+  void blitTri(const AGTexture &amp;pSource,const AGTriangle2 &amp;pSrc,const AGTriangle2 &amp;pDest);
+
+  void blit(const AGTexture &amp;pSource,const AGRect2 &amp;pDest);
+  void blit(const AGTexture &amp;pSource,const AGRect2 &amp;pDest,const AGColor &amp;pColor);
+  void blit(const AGTexture &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc);
+  void blit(const AGTexture &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc,const AGColor &amp;pColor);
+  void tile(const AGTexture &amp;pSource);
+  void tile(const AGTexture &amp;pSource,const AGRect2 &amp;pDest);
+  void tile(const AGTexture &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc);
+
+  void blit(const AGSurface &amp;pSource,const AGRect2 &amp;pDest);
+  void blit(const AGSurface &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc);
+  void tile(const AGSurface &amp;pSource);
+  void tile(const AGSurface &amp;pSource,const AGRect2 &amp;pDest);
+  void tile(const AGSurface &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc);
+  
+  void renderText(const AGStringUtf8 &amp;pText,const AGVector2 &amp;p,const AGFont &amp;f);
+
+  AGRect2 getRect() const;
+
+  void drawGradient(const AGRect2 &amp;r,const AGColor &amp;c0,const AGColor &amp;c1,const AGColor &amp;c2,const AGColor &amp;c3);
+  void drawBorder(const AGRect2&amp; rect,int width, const AGColor&amp; c1, const AGColor&amp; c2);
+  void fillRect(const AGRect2 &amp;pRect,const AGColor &amp;c);
+  void drawLine(const AGVector2 &amp;p0,const AGVector2 &amp;p1,const AGColor &amp;c);
+  void drawPoint(const AGVector2 &amp;p,const AGColor &amp;c,float size);
+
+  void fillRects(const std::vector&lt;std::pair&lt;AGRect2,AGVector4&gt; &gt; &amp;pRects);
+
+  void pushMatrix();
+  void popMatrix();
+  void translate(const AGVector2 &amp;v);
+  void scale(const AGVector2 &amp;v);
+  void clip(const AGRect2 &amp;r);
+
+  void clip(const AGClipping &amp;clip);
+
+  void transform(const AGRect2 &amp;r);
+
+  AGVector2 project(const AGVector2 &amp;p) const;
+  bool pointOk(const AGVector2 &amp;p) const;
+
+  AGPaintTarget *getTarget();
+
+ private:
+  std::list&lt;AGProjection&gt; ps;
+
+  AGProjection mCurrent;
+
+  gc_ptr&lt;AGPaintTarget&gt; mTarget;
+};
+
+#endif

Added: antargis/branches/rant/ext/video/ag_projection.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_projection.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_projection.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,38 @@
+#include &quot;ag_projection.h&quot;
+#include &quot;ag_debug.h&quot;
+
+
+AGProjection2D::AGProjection2D(const AGRect2 &amp;from, const AGRect2 &amp;to)
+{
+  assert(from.content()&gt;0 &amp;&amp; to.content()&gt;0);
+
+  float sx=to.w()/from.w();
+  float sy=to.h()/from.h();
+  AGMatrix3 m1(-from.getV0());
+  AGMatrix3 m2(sx,sy);
+  AGMatrix3 m3(to.getV0());
+
+  m=m3*m2*m1;
+  /*  cdebug(&quot;m1:&quot;&lt;&lt;m1.toString());
+  cdebug(&quot;m2:&quot;&lt;&lt;m2.toString());
+  cdebug(&quot;m3:&quot;&lt;&lt;m3.toString());
+  
+
+  cdebug(&quot;sx:&quot;&lt;&lt;sx);
+  cdebug(&quot;sy:&quot;&lt;&lt;sy);
+  cdebug(&quot;M:&quot;&lt;&lt;m.toString());*/
+}
+  
+AGRect2 AGProjection2D::project(const AGRect2 &amp;r)
+{
+  return AGRect2((m*r.getV0()).dim2(),(m*r.getV1()).dim2());
+}
+AGVector2 AGProjection2D::project(const AGVector2 &amp;p)
+{
+  return (m*p).dim2();
+}
+
+void AGProjection2D::pushProjection(const AGProjection2D &amp;p)
+{
+  m*=p.m;
+}

Added: antargis/branches/rant/ext/video/ag_projection.h
===================================================================
--- antargis/branches/rant/ext/video/ag_projection.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_projection.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,21 @@
+#ifndef AG_PROJECTION
+#define AG_PROJECTION
+
+#include &lt;ag_geometry.h&gt;
+
+
+class AGProjection2D
+{
+  AGMatrix3 m;
+ public:
+  AGProjection2D(const AGRect2 &amp;from, const AGRect2 &amp;to);
+  
+  AGRect2 project(const AGRect2 &amp;r);
+  AGVector2 project(const AGVector2 &amp;p);
+
+  void pushProjection(const AGProjection2D &amp;p);
+};
+
+
+
+#endif

Added: antargis/branches/rant/ext/video/ag_sdlsurface.h
===================================================================
--- antargis/branches/rant/ext/video/ag_sdlsurface.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_sdlsurface.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_sdlsurface.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef __GUI_SDLSURFACE_H
+#define __GUI_SDLSURFACE_H
+
+#include &quot;ag_screen.h&quot;
+
+class AGSDLScreen:public AGScreen
+{
+ public:
+  AGSDLScreen(SDL_Surface *s);
+
+  virtual void blit(const AGTexture &amp;pSource,const AGRect2 &amp;pDest,const AGRect2 &amp;pSrc);
+
+  virtual void flip();
+  virtual void update(const std::list&lt;AGRect2&gt; &amp;rs);
+
+  virtual AGRect2 getRect() const;
+
+  virtual void fillRect(const AGRect2 &amp;pRect,const AGColor &amp;c);
+  virtual void fillRects(const std::vector&lt;std::pair&lt;AGRect2,AGVector4&gt; &gt; &amp;pRects);
+  virtual void drawLine(const AGVector2 &amp;p0,const AGVector2 &amp;p1,const AGColor &amp;c);
+
+  virtual void drawGradientAlpha(const AGRect2&amp; rect, const AGColor&amp; ul, const AGColor&amp; ur, const AGColor&amp; dl, const AGColor&amp; dr);
+  virtual void drawGradient(const AGRect2&amp; rect, const AGColor&amp; ul, const AGColor&amp; ur, const AGColor&amp; dl, const AGColor&amp; dr);
+
+  virtual void drawBorder(const AGRect2&amp; rect,int W, const AGColor&amp; c1, const AGColor&amp; c2);
+
+  virtual void putPixel(int x,int y,const AGColor &amp;c);
+
+  //  virtual SDL_Surface *newSurface(int x,int y);
+
+  //  virtual AGSurface loadSurface(const std::string &amp;pFilename);
+
+  //  virtual AGTexture displayFormat(SDL_Surface *s);
+
+  //  virtual AGTexture makeTexture(const AGSurface &amp;s);
+
+  virtual size_t getWidth() const;
+  virtual size_t getHeight() const;
+
+  virtual void clip(const AGRect2 &amp;r);
+  virtual void unclip();
+
+  AGSurface screenshot(bool frontBuffer=true);
+
+ private:
+  SDL_Surface *s;
+ public:
+};
+
+#endif

Modified: antargis/branches/rant/ext/video/ag_texture.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_texture.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_texture.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -169,7 +169,7 @@
 
 bool AGTexture::hasTexture() const
 {
-  return mTexture || !glMode();
+  return mTexture || !opengl();
 }
 void AGTexture::clearTexture()
 {

Added: antargis/branches/rant/ext/video/ag_texturecache.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_texturecache.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_texturecache.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,158 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_texturecache.cpp
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &quot;ag_texture.h&quot;
+#include &quot;ag_texturecache.h&quot;
+#include &quot;ag_png.h&quot;
+#include &quot;ag_kill.h&quot;
+#include &quot;ag_geometry.h&quot;
+
+AGTextureCache *mTextureCache=0;
+AGTextureCache *getTextureCache()
+{
+  if(!mTextureCache)
+    mTextureCache=new AGTextureCache;
+  return mTextureCache;
+}
+
+AGTextureCache::AGTextureCache()
+{
+  getInstanceKiller()-&gt;reg(createKiller(this));
+}
+
+const AGTexture &amp;AGTextureCache::get(const AGFilename &amp;pTexture,const AGRect2 &amp;pSub)
+{
+  std::string s=pTexture+&quot;:&quot;+pSub.toString();
+
+  std::map&lt;AGFilename,AGTexture*&gt;::iterator i=mTextures.find(s);
+  if(i==mTextures.end())
+    {
+      // load
+      AGSurface ms=AGSurface::load(pTexture).getSubSurface(pSub);
+      
+
+
+      /*      while(downScaleExp&gt;1 &amp;&amp; ms.width()&gt;16 &amp;&amp; ms.height()&gt;16)
+	{
+	  ms=ms.scale(ms.width()/2,ms.height()/2);
+	  downScaleExp--;
+	}
+      */
+      mTextures[s]=new AGTexture(ms,false);
+    }
+  return *(mTextures[s]);
+}
+
+
+const AGTexture &amp;AGTextureCache::get(const AGFilename &amp;pTexture,int downScaleExp)
+  {
+    std::map&lt;AGFilename,AGTexture*&gt;::iterator i=mTextures.find(pTexture);
+    if(i==mTextures.end())
+      {
+        // load
+        AGSurface ms=AGSurface::load(pTexture);
+
+	while(downScaleExp&gt;1 &amp;&amp; ms.width()&gt;16 &amp;&amp; ms.height()&gt;16)
+	  {
+	    ms=ms.scale(ms.width()/2,ms.height()/2);
+	    downScaleExp--;
+	  }
+
+        mTextures[pTexture]=new AGTexture(ms,false);
+      }
+    return *(mTextures[pTexture]);
+  }
+
+AGSurface skipHalfTexture(const AGSurface &amp;s)
+{
+  TRACE;
+  if(s.width()&gt;s.height())
+    {
+      int w=s.width();
+      int h=s.height();
+      int nw=w/2;
+      int nh=h;
+      AGSurface n(nw,nh);
+
+      for(int i=0;i&lt;nw/nh;i++)
+	{
+	  for(int y=0;y&lt;nh;y++)
+	    for(int x=0;x&lt;nh;x++)
+	      {
+		n.putPixel(x+nh*i,y,s.getPixel(x+2*nh*i,y));
+	      }
+	}
+
+      return n;
+    }
+  else
+    {
+      int w=s.width();
+      int h=s.height();
+      int nw=w;
+      int nh=h/2;
+      AGSurface n(nw,nh);
+
+      for(int i=0;i&lt;nh/nw;i++)
+	{
+	  for(int y=0;y&lt;nw;y++)
+	    for(int x=0;x&lt;nw;x++)
+	      {
+		n.putPixel(x,y+nw*i,s.getPixel(x,y+2*nw*i));
+	      }
+	}
+
+      return n;
+    }
+}
+
+
+const AGTexture &amp;AGTextureCache::get3D(const AGFilename &amp;pTexture,int downScaleExp,int downScaleZ)
+{
+  std::map&lt;AGFilename,AGTexture*&gt;::iterator i=mTextures.find(pTexture);
+  if(i==mTextures.end())
+    {
+      // load
+      AGSurface ms=AGSurface::load(pTexture);
+
+      cdebug(&quot;3d texture size old0:&quot;&lt;&lt;ms.width()&lt;&lt;&quot;,&quot;&lt;&lt;ms.height());
+      
+      while(downScaleExp&gt;1 &amp;&amp; ms.width()&gt;16 &amp;&amp; ms.height()&gt;16)
+	{
+	  ms=ms.scale(ms.width()/2,ms.height()/2);
+	  downScaleExp--;
+	}
+
+      cdebug(&quot;3d texture size old1:&quot;&lt;&lt;ms.width()&lt;&lt;&quot;,&quot;&lt;&lt;ms.height());
+
+      while(downScaleZ&gt;1)
+	{
+	  ms=skipHalfTexture(ms);
+	  
+	  downScaleZ--;
+	}
+
+      cdebug(&quot;3d texture size:&quot;&lt;&lt;ms.width()&lt;&lt;&quot;,&quot;&lt;&lt;ms.height());
+
+      
+      mTextures[pTexture]=new AGTexture(ms,true);
+    }
+  return *(mTextures[pTexture]);
+}

Added: antargis/branches/rant/ext/video/ag_texturecache.h
===================================================================
--- antargis/branches/rant/ext/video/ag_texturecache.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_texturecache.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_texturecache.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef __TEXTURE_CACHE_H__
+#define __TEXTURE_CACHE_H__
+
+#include &quot;ag_surface.h&quot;
+#include &quot;ag_debug.h&quot;
+#include &lt;ag_fs.h&gt;
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+
+class AGRect2;
+
+class AGTextureCache
+  {
+    AGTextureCache();
+  public:
+    const AGTexture &amp;get(const AGFilename &amp;pTexture,int downScaleExp=1);
+    const AGTexture &amp;get3D(const AGFilename &amp;pTexture,int downScaleExp=1,int downScaleZ=1);
+
+    const AGTexture &amp;get(const AGFilename &amp;pTexture,const AGRect2 &amp;pSub);
+  private:
+    std::map&lt;AGFilename,AGTexture*&gt; mTextures;
+    
+    friend AGTextureCache *getTextureCache();
+  };
+
+AGTextureCache *getTextureCache();
+
+
+#endif

Modified: antargis/branches/rant/ext/video/ag_vdebug.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_vdebug.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_vdebug.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -3,7 +3,7 @@
 
 void agAssertGL(std::string s)
 {
-  if(glMode())
+  if(opengl())
     {
       GLenum error = glGetError();
       if(error != GL_NO_ERROR) {

Modified: antargis/branches/rant/ext/video/ag_video.h
===================================================================
--- antargis/branches/rant/ext/video/ag_video.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_video.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -39,7 +39,8 @@
 
 };
 
-bool glMode();
+//bool glMode();
+bool opengl();
 
 AGVideoManager *getVideo();
 

Modified: antargis/branches/rant/ext/video/headers.hh
===================================================================
--- antargis/branches/rant/ext/video/headers.hh	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/headers.hh	2007-06-23 15:07:27 UTC (rev 1105)
@@ -32,26 +32,26 @@
 #include &quot;ext/basic/ag_mutex.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/video/ag_painttarget.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/video/ag_surface.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/video/ag_texture.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/video/ag_screen.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/video/ag_fontengine.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/video/ag_video.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/video/ag_fontengine.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/video/ag_painter.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/video/ag_clip.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/video/ag_rendercontext.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/video/ag_font.h&quot;
+#include &quot;/home/david/projects/antargis/rant/ext/video/ag_painter.h&quot;
 #include &quot;/home/david/projects/antargis/rant/ext/video/ag_color.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/video/ag_screen.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/video/ag_texture.h&quot;
-#include &quot;/home/david/projects/antargis/rant/ext/video/ag_clip.h&quot;
 #ifdef SWIG
 %include &quot;/home/david/projects/antargis/rant/ext/video/ag_painttarget.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/video/ag_surface.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/video/ag_texture.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/video/ag_screen.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/video/ag_fontengine.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/video/ag_video.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/video/ag_fontengine.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/video/ag_painter.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/video/ag_clip.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/video/ag_rendercontext.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/video/ag_font.h&quot;
+%include &quot;/home/david/projects/antargis/rant/ext/video/ag_painter.h&quot;
 %include &quot;/home/david/projects/antargis/rant/ext/video/ag_color.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/video/ag_screen.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/video/ag_texture.h&quot;
-%include &quot;/home/david/projects/antargis/rant/ext/video/ag_clip.h&quot;
 #endif
 #endif

Modified: antargis/branches/rant/ruby/ant_models.rb
===================================================================
--- antargis/branches/rant/ruby/ant_models.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ruby/ant_models.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -229,8 +229,14 @@
 				if not fileExists(pngname)
 					pngname=&quot;&quot;
 				end
-	
-				scenenode=Mesh.new(getMap.getScene,getMeshData(ant2name,getStaticModelScaling(name),pngname),AGVector4.new(0,0,0),angle)
+
+				s=getMap.getScene
+
+				s=getMap.getScene
+				data=getMeshData(ant2name,getStaticModelScaling(name),pngname)
+				v=AGVector4.new(0,0,0)
+				puts &quot;scene:#{s} data:#{data} vec:#{v} angle:#{angle}&quot;
+				scenenode=Mesh.new(s,data,v,angle)
 			end
 		end
 	

Modified: antargis/branches/rant/ruby/antargis.rb
===================================================================
--- antargis/branches/rant/ruby/antargis.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ruby/antargis.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -105,7 +105,7 @@
 		puts &quot;PANEL:&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at buttonpanel</A>
 		raise 1 if @buttonpanel.nil?
 
-		@miniMap=toMiniMap(@layout.getChild(&quot;miniMap&quot;))
+		@miniMap=@layout.getChild(&quot;miniMap&quot;)
 		@fps=0
 
 		setMainWidget(@layout)

Added: antargis/branches/rant/ruby/antargisgui.rb
===================================================================
--- antargis/branches/rant/ruby/antargisgui.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ruby/antargisgui.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,14 @@
+@@programDir=Dir.pwd+&quot;/ruby&quot;
+@@extDir=Dir.pwd+&quot;/ext&quot;
+# add programdir to path
+$:.push(@@programDir)
+$:.push(@@extDir)
+
+
+require 'ext/antargisgui.so'
+include Antargisgui
+#require 'ext/antargisbasic.so'
+include Antargisbasic
+include Antargismath
+include Antargisvideo
+

Added: antargis/branches/rant/ruby/antargismath.rb
===================================================================
--- antargis/branches/rant/ruby/antargismath.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ruby/antargismath.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,11 @@
+@@programDir=Dir.pwd+&quot;/ruby&quot;
+@@extDir=Dir.pwd+&quot;/ext&quot;
+# add programdir to path
+$:.push(@@programDir)
+$:.push(@@extDir)
+
+
+require 'ext/antargismath.so'
+include Antargisbasic
+include Antargismath
+

Modified: antargis/branches/rant/ruby/gui/ag_tools.rb
===================================================================
--- antargis/branches/rant/ruby/gui/ag_tools.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ruby/gui/ag_tools.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -134,23 +134,12 @@
 	eval(&quot;@#{name}=AGSignal.new(self,'#{name}')\n&quot;)
 end
 
-if hasLibantargis
-	module Libantargis
-		class AGApplication
-			include AGHandler
-		end
-		class AGWidget
-			include AGHandler
-		end
+module Antargisgui
+	class AGApplication
+		include AGHandler
 	end
-else
-	module Libantargisgui
-		class AGApplication
-			include AGHandler
-		end
-		class AGWidget
-			include AGHandler
-		end
+	class AGWidget
+		include AGHandler
 	end
 end
 

Modified: antargis/branches/rant/ruby/map.rb
===================================================================
--- antargis/branches/rant/ruby/map.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ruby/map.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -52,6 +52,11 @@
 	attr_reader :path
 
 	def initialize(app,pScene,w,h,playerName=&quot;Rowen&quot;)
+		assert{app.is_a?(AGApplication)}
+		assert{pScene.is_a?(SceneBase)}
+		assert{w.is_a?(Numeric)}
+		assert{h.is_a?(Numeric)}
+
 		super(pScene,w,h)
 		@pause=false # is game paused
 		@app=app

Modified: antargis/branches/rant/ruby/view.rb
===================================================================
--- antargis/branches/rant/ruby/view.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ruby/view.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -203,6 +203,7 @@
 	def initialize(p,r)
 		super(p,r)
 		setName(&quot;ButtonPanel&quot;)
+		puts self,self.class,respond_to?(:clearHandlers),self.is_a?(AGWidget),self.methods.join(&quot;//&quot;)
 		clearHandlers
 		@jobButtons=[&quot;doRest&quot;,&quot;doDismiss&quot;,&quot;doDropFood&quot;,&quot;doDropWeapon&quot;,&quot;doBuild&quot;]
 		@aggButtons={&quot;doAgg0&quot;=&gt;1,&quot;doAgg1&quot;=&gt;2,&quot;doAgg2&quot;=&gt;3}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000061.html">[Antargis-svn] r1104 - in antargis/branches/rant: . build	data/gui/layout ext/basic ext/game ext/gui ext/math ext/sound	ext/video ruby ruby/entities ruby/gui ruby/tests
</A></li>
	<LI>Next message: <A HREF="000063.html">[Antargis-svn] r1106 - in antargis/branches/rant/ext: 3dengine game	video
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#62">[ date ]</a>
              <a href="thread.html#62">[ thread ]</a>
              <a href="subject.html#62">[ subject ]</a>
              <a href="author.html#62">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/antargis-svn">More information about the Antargis-svn
mailing list</a><br>
</body></html>
