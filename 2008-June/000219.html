<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Antargis-svn] r1263 - in antargis/trunk: .	data/gui/layout/editor/campaign ext/3dengine ext/basic	ext/gui ext/video rookey ruby ruby/editor/campaign	ruby/entities ruby/entities/spec ruby/gui ruby/jobs	ruby/jobs/spec ruby/meshes ruby/spec ruby/state_machine	ruby/state_machine/spec ruby/state_machine/tests ruby/tests	ruby/tests/3d_engine ruby/tests/path ruby/tools ruby/widgets
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/antargis-svn/2008-June/index.html" >
   <LINK REL="made" HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1263%20-%20in%20antargis/trunk%3A%20.%0A%09data/gui/layout/editor/campaign%20ext/3dengine%20ext/basic%0A%09ext/gui%20ext/video%20rookey%20ruby%20ruby/editor/campaign%0A%09ruby/entities%20ruby/entities/spec%20ruby/gui%20ruby/jobs%0A%09ruby/jobs/spec%20ruby/meshes%20ruby/spec%20ruby/state_machine%0A%09ruby/state_machine/spec%20ruby/state_machine/tests%20ruby/tests%0A%09ruby/tests/3d_engine%20ruby/tests/path%20ruby/tools%20ruby/widgets&In-Reply-To=%3C200806051924.m55JOudO013506%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000220.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Antargis-svn] r1263 - in antargis/trunk: .	data/gui/layout/editor/campaign ext/3dengine ext/basic	ext/gui ext/video rookey ruby ruby/editor/campaign	ruby/entities ruby/entities/spec ruby/gui ruby/jobs	ruby/jobs/spec ruby/meshes ruby/spec ruby/state_machine	ruby/state_machine/spec ruby/state_machine/tests ruby/tests	ruby/tests/3d_engine ruby/tests/path ruby/tools ruby/widgets</H1>
    <B>davidkamphausen at BerliOS</B> 
    <A HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1263%20-%20in%20antargis/trunk%3A%20.%0A%09data/gui/layout/editor/campaign%20ext/3dengine%20ext/basic%0A%09ext/gui%20ext/video%20rookey%20ruby%20ruby/editor/campaign%0A%09ruby/entities%20ruby/entities/spec%20ruby/gui%20ruby/jobs%0A%09ruby/jobs/spec%20ruby/meshes%20ruby/spec%20ruby/state_machine%0A%09ruby/state_machine/spec%20ruby/state_machine/tests%20ruby/tests%0A%09ruby/tests/3d_engine%20ruby/tests/path%20ruby/tools%20ruby/widgets&In-Reply-To=%3C200806051924.m55JOudO013506%40sheep.berlios.de%3E"
       TITLE="[Antargis-svn] r1263 - in antargis/trunk: .	data/gui/layout/editor/campaign ext/3dengine ext/basic	ext/gui ext/video rookey ruby ruby/editor/campaign	ruby/entities ruby/entities/spec ruby/gui ruby/jobs	ruby/jobs/spec ruby/meshes ruby/spec ruby/state_machine	ruby/state_machine/spec ruby/state_machine/tests ruby/tests	ruby/tests/3d_engine ruby/tests/path ruby/tools ruby/widgets">davidkamphausen at mail.berlios.de
       </A><BR>
    <I>Thu Jun  5 21:24:56 CEST 2008</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000220.html">[Antargis-svn] r1264 - in antargis/trunk: ext/basic main ruby	ruby/spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#219">[ date ]</a>
              <a href="thread.html#219">[ thread ]</a>
              <a href="subject.html#219">[ subject ]</a>
              <a href="author.html#219">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: davidkamphausen
Date: 2008-06-05 21:24:45 +0200 (Thu, 05 Jun 2008)
New Revision: 1263

Added:
   antargis/trunk/ruby/spec/spec_drawing.rb
Removed:
   antargis/trunk/ruby/spec/spec_translation.rb
Modified:
   antargis/trunk/TODO
   antargis/trunk/data/gui/layout/editor/campaign/main.xml
   antargis/trunk/ext/3dengine/vertex_array.cc
   antargis/trunk/ext/basic/ag_gauss.h
   antargis/trunk/ext/basic/ag_geometry.cc
   antargis/trunk/ext/basic/ag_geometry.h
   antargis/trunk/ext/basic/ag_messageobject.cc
   antargis/trunk/ext/basic/ag_messageobject.h
   antargis/trunk/ext/gui/ag_button.cc
   antargis/trunk/ext/gui/ag_widget.cc
   antargis/trunk/ext/gui/ag_widget.h
   antargis/trunk/ext/video/ag_gltexture.cc
   antargis/trunk/ext/video/ag_painter.cc
   antargis/trunk/ext/video/ag_painter.h
   antargis/trunk/ext/video/ag_projection.cc
   antargis/trunk/ext/video/ag_projection.h
   antargis/trunk/rookey/tasks.rb
   antargis/trunk/ruby/editor/campaign/drag_grid.rb
   antargis/trunk/ruby/entities/ant_wolf.rb
   antargis/trunk/ruby/entities/ant_workshop.rb
   antargis/trunk/ruby/entities/entity.rb
   antargis/trunk/ruby/entities/spec/entities.rb
   antargis/trunk/ruby/game_result.rb
   antargis/trunk/ruby/gen_tree.rb
   antargis/trunk/ruby/gui/ag_tools.rb
   antargis/trunk/ruby/gui/testing.rb
   antargis/trunk/ruby/intro.rb
   antargis/trunk/ruby/jobs/ant_state_machine.rb
   antargis/trunk/ruby/jobs/spec/recruit.rb
   antargis/trunk/ruby/level.rb
   antargis/trunk/ruby/mainmenu.rb
   antargis/trunk/ruby/map_generator.rb
   antargis/trunk/ruby/map_generator2.rb
   antargis/trunk/ruby/mesh_view.rb
   antargis/trunk/ruby/meshes/grass.rb
   antargis/trunk/ruby/mpmap.rb
   antargis/trunk/ruby/obj_import.rb
   antargis/trunk/ruby/runtests.rb
   antargis/trunk/ruby/spec/level_testing.rb
   antargis/trunk/ruby/spec/spec_basic.rb
   antargis/trunk/ruby/spec/spec_call.rb
   antargis/trunk/ruby/spec/spec_campaign.rb
   antargis/trunk/ruby/spec/spec_formation.rb
   antargis/trunk/ruby/spec/spec_gc.rb
   antargis/trunk/ruby/spec/spec_geometry.rb
   antargis/trunk/ruby/spec/spec_hljob_saving.rb
   antargis/trunk/ruby/spec/spec_map.rb
   antargis/trunk/ruby/spec/spec_math.rb
   antargis/trunk/ruby/spec/spec_menu.rb
   antargis/trunk/ruby/spec/spec_minimap.rb
   antargis/trunk/ruby/spec/spec_run_tutorial.rb
   antargis/trunk/ruby/spec/spec_screenshot.rb
   antargis/trunk/ruby/spec/spec_scrollingwidget.rb
   antargis/trunk/ruby/state_machine/ant_hl_job_states.rb
   antargis/trunk/ruby/state_machine/spec/job_states.rb
   antargis/trunk/ruby/state_machine/spec/state_machine.rb
   antargis/trunk/ruby/state_machine/state_machine.rb
   antargis/trunk/ruby/state_machine/tests/state_machine_test.rb
   antargis/trunk/ruby/storyflow.rb
   antargis/trunk/ruby/terrain_2d.rb
   antargis/trunk/ruby/test_ant3.rb
   antargis/trunk/ruby/tests/3d_engine/wireframe.rb
   antargis/trunk/ruby/tests/algebra_test.rb
   antargis/trunk/ruby/tests/basis_test.rb
   antargis/trunk/ruby/tests/clip_test.rb
   antargis/trunk/ruby/tests/clip_widget_test.rb
   antargis/trunk/ruby/tests/dirty_rects.rb
   antargis/trunk/ruby/tests/graph_test.rb
   antargis/trunk/ruby/tests/gui_tests.rb
   antargis/trunk/ruby/tests/impostor.rb
   antargis/trunk/ruby/tests/path/fields_test.rb
   antargis/trunk/ruby/tests/path/fields_test2.rb
   antargis/trunk/ruby/tests/path/heuristic_test.rb
   antargis/trunk/ruby/tests/rect_test.rb
   antargis/trunk/ruby/tests/scene_2d.rb
   antargis/trunk/ruby/tests/scissor_test.rb
   antargis/trunk/ruby/tests/sdl_texture.rb
   antargis/trunk/ruby/tests/swig_derivation_test.rb
   antargis/trunk/ruby/tests/test_path.rb
   antargis/trunk/ruby/tools/anim_import.rb
   antargis/trunk/ruby/tools/anim_import4.rb
   antargis/trunk/ruby/tools/ant2obj.rb
   antargis/trunk/ruby/two_d_app.rb
   antargis/trunk/ruby/widgets/ant_buttonpanel.rb
   antargis/trunk/ruby/widgets/ant_name_display.rb
Log:
Incomplete - task 6: Cleanup 
<A HREF="http://localhost:3000/issues/show/6">http://localhost:3000/issues/show/6</A>
Incomplete - task 9: Scrollingwidget 
<A HREF="http://localhost:3000/issues/show/9">http://localhost:3000/issues/show/9</A>
Incomplete - task 45: Check clipping when hovering 
<A HREF="http://localhost:3000/issues/show/45">http://localhost:3000/issues/show/45</A>
Complete - task 44: Gauss implementation is buggy 
<A HREF="http://localhost:3000/issues/show/44">http://localhost:3000/issues/show/44</A>

Modified: antargis/trunk/TODO
===================================================================
--- antargis/trunk/TODO	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/TODO	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,17 +1,3 @@
-* move build/*.rb files to build/unused_tools/* if they're not used
-* issue with mingw: 
-** google for &quot;/tmp/cciSLVG5.s:932678: Warning: .stabs: description field '1c216' too big, try a different debug format&quot;
-
-* check how many times AG_NewPointer is called !!!! - not so often - could be replaced by traceobjects from swig
-** check if it's any good to switch over to standard-swig ??? seems so.
-
-!!! AGTexture - not wrapped correctly in bliTri etc ???
-
-
-* moveto doesn't really work with &quot;near&quot; (hljob)
-* heroes don't die in reasonable fashion - starving men too
-* add seasons
-
 * Spreading should be done only for men who need it!
 
 * why is the story-telling dialog taking so much time ??
@@ -20,7 +6,6 @@
 * check level-editor
 ** make wish-list
 
-* check dep-handling with swig
 * move single entities with path-finder, too?
 
 * docs

Modified: antargis/trunk/data/gui/layout/editor/campaign/main.xml
===================================================================
--- antargis/trunk/data/gui/layout/editor/campaign/main.xml	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/data/gui/layout/editor/campaign/main.xml	2008-06-05 19:24:45 UTC (rev 1263)
@@ -5,7 +5,7 @@
   &lt;rowsize row=&quot;0&quot; fixed=&quot;50&quot;/&gt;
   
   &lt;cell col=&quot;0&quot; row=&quot;0&quot;&gt;
-    &lt;toolBar&gt;
+    &lt;toolBar name=&quot;toolbar&quot;&gt;
          &lt;toolButton text=&quot;Save&quot; name=&quot;save&quot; caption=&quot;muh&quot; caption-image=&quot;gui/save.png&quot;/&gt;
          &lt;toolButton text=&quot;Load&quot; name=&quot;load&quot; caption=&quot;muh&quot; caption-image=&quot;gui/load.png&quot;/&gt;
     &lt;/toolBar&gt;
@@ -59,8 +59,8 @@
   &lt;/table&gt;
   &lt;/cell&gt;
   &lt;/table&gt;
-  
+  &lt;!--
   &lt;appearEffect name=&quot;showEdit&quot; table=&quot;bigTable&quot; row=&quot;1&quot; size=&quot;40&quot; duration=&quot;0.2&quot;/&gt;
-  
+--&gt;  
 &lt;/dragEnvironment&gt;
 &lt;/layout&gt;
\ No newline at end of file

Modified: antargis/trunk/ext/3dengine/vertex_array.cc
===================================================================
--- antargis/trunk/ext/3dengine/vertex_array.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/3dengine/vertex_array.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -38,7 +38,7 @@
   mArrays=GLEE_EXT_vertex_array &amp;&amp; useVertexArrays();
 
   if(videoInited())
-    assert(GLEE_EXT_vertex_array || GLEE_VERSION_1_2); //FIXME: check if this really version 1.2
+    assert(GLEE_EXT_vertex_array || GLEE_VERSION_1_2); // vertex-arrays were introduced in GL 1.1, but glee has no flag for  that
 
   displayListInited=false;
 

Modified: antargis/trunk/ext/basic/ag_gauss.h
===================================================================
--- antargis/trunk/ext/basic/ag_gauss.h	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/basic/ag_gauss.h	2008-06-05 19:24:45 UTC (rev 1263)
@@ -23,6 +23,7 @@
             for(k=1;k+c&lt;size;k++)
               if(fabs(b.get(c,c+k))&gt;0)
                 {
+                  //cdebug(&quot;SWAP:&quot;&lt;&lt;c&lt;&lt;&quot; and &quot;&lt;&lt;c+k);
                   // swap rows
                   b.swapRows(c,c+k);
                   a.swapRows(c,c+k);
@@ -39,6 +40,7 @@
                 float f=-b.get(c,c)/b.get(c,r);
                 for(int i=0;i&lt;size;i++)
                   {
+                    //cdebug(&quot;modrows:(&quot;&lt;&lt;r&lt;&lt;&quot;)=(&quot;&lt;&lt;c&lt;&lt;&quot;)+(&quot;&lt;&lt;r&lt;&lt;&quot;)*&quot;&lt;&lt;f);
                     // modify row
                     a.set(i,r,a.get(i,c)+a.get(i,r)*f);
                     b.set(i,r,b.get(i,c)+b.get(i,r)*f);
@@ -49,28 +51,41 @@
               }
           }
       }
-    // cdebug(&quot;A:\n&quot;&lt;&lt;a.toString());
-    // cdebug(&quot;B:\n&quot;&lt;&lt;b.toString());
+    //cdebug(&quot;A:\n&quot;&lt;&lt;a.toString());
+    //cdebug(&quot;B:\n&quot;&lt;&lt;b.toString());
 
     // upper-right triangle
     for(int c=size-1;c&gt;0;c--) // cols
       {
         for(int r=0;r&lt;c;r++) // rows
           {
+            // (c,r) is to be set to zero
             if(fabs(b.get(c,r))&gt;0.0001)
               {
-                float f=-b.get(c,r+1)/b.get(c,r);
+                // search a line &gt;r, that is !=0
+                int r2;
+                for(r2=r+1;r2&lt;size;r2++)
+                  if(b.get(c,r2)&gt;0.0001)
+                    break;
+                if(r2&gt;=size)
+                  throw GeometryException(&quot;Matrix is not invertable - no cell!=0 found in upper-right triangle.&quot;);
+                
+                float f=-b.get(c,r2)/b.get(c,r);
+                if(f==0)
+                  throw GeometryException(&quot;Matrix is not invertable - f=0&quot;);
+
+                //cdebug(&quot;modifyrow:(&quot;&lt;&lt;r&lt;&lt;&quot;)=(&quot;&lt;&lt;r+1&lt;&lt;&quot;)+(&quot;&lt;&lt;r&lt;&lt;&quot;)*&quot;&lt;&lt;f);
                 for(int i=0;i&lt;size;i++)
                   {
                     // modify row
-                    a.set(i,r,a.get(i,r+1)+a.get(i,r)*f);
-                    b.set(i,r,b.get(i,r+1)+b.get(i,r)*f);
+                    a.set(i,r,a.get(i,r2)+a.get(i,r)*f);
+                    b.set(i,r,b.get(i,r2)+b.get(i,r)*f);
                   }
               }
           }
       }
-    // cdebug(&quot;A:\n&quot;&lt;&lt;a.toString());
-    // cdebug(&quot;B:\n&quot;&lt;&lt;b.toString());
+    //cdebug(&quot;A:\n&quot;&lt;&lt;a.toString());
+    //cdebug(&quot;B:\n&quot;&lt;&lt;b.toString());
 
     // norming
 
@@ -84,8 +99,8 @@
               b.set(c,r,b.get(c,r)/v);
             }
       }
-    // cdebug(&quot;A:\n&quot;&lt;&lt;a.toString());
-    // cdebug(&quot;B:\n&quot;&lt;&lt;b.toString());
+    //cdebug(&quot;A:\n&quot;&lt;&lt;a.toString());
+    //cdebug(&quot;B:\n&quot;&lt;&lt;b.toString());
     return true; // everythin ok
   }
 

Modified: antargis/trunk/ext/basic/ag_geometry.cc
===================================================================
--- antargis/trunk/ext/basic/ag_geometry.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/basic/ag_geometry.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -150,8 +150,8 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGAngle::AGAngle(float p):angle(p)
-  {
-  }
+      {
+      }
 
 /////////////////////////////////////////////////////////////////////////////
 // AGVector2
@@ -297,9 +297,9 @@
 }
 
 (AGVector2::operator float*)()
-  {
-    return v;
-  }
+      {
+        return v;
+      }
 (AGVector2::operator const float*)() const
 {
   return v;
@@ -314,34 +314,34 @@
   return AGVector2(v[0]+p.v[0],v[1]+p.v[1]);
 }
 AGVector2 &amp;AGVector2::operator+=(const AGVector2 &amp;p)
-  {
-    v[0]+=p.v[0];
-    v[1]+=p.v[1];
-    return *this;
-  }
+      {
+        v[0]+=p.v[0];
+        v[1]+=p.v[1];
+        return *this;
+      }
 AGVector2 &amp;AGVector2::operator-=(const AGVector2 &amp;p)
-  {
-    v[0]-=p.v[0];
-    v[1]-=p.v[1];
-    return *this;
-  }
+      {
+        v[0]-=p.v[0];
+        v[1]-=p.v[1];
+        return *this;
+      }
 
 float AGVector2::operator*(const AGVector2 &amp;p) const
 {
   return v[0]*p.v[0]+v[1]*p.v[1];
 }
 AGVector2 &amp;AGVector2::operator*=(float f)
-  {
-    v[0]*=f;
-    v[1]*=f;
-    return *this;
-  }
+      {
+        v[0]*=f;
+        v[1]*=f;
+        return *this;
+      }
 AGVector2 &amp;AGVector2::operator/=(float f)
-  {
-    v[0]/=f;
-    v[1]/=f;
-    return *this;
-  }
+      {
+        v[0]/=f;
+        v[1]/=f;
+        return *this;
+      }
 AGVector2 AGVector2::operator*(float f) const
 {
   return AGVector2(v[0]*f,v[1]*f);
@@ -376,10 +376,10 @@
   return v[index];
 }
 float &amp;AGVector2::operator[](int index)
-  {
-    assert(index&gt;=0 &amp;&amp; index&lt;2);
-    return v[index];
-  }
+      {
+        assert(index&gt;=0 &amp;&amp; index&lt;2);
+        return v[index];
+      }
 
 
 /////////////////////////////////////////////////////////////////////////////
@@ -537,9 +537,9 @@
 }
 
 (AGVector3::operator float*)()
-  {
-    return v;
-  }
+      {
+        return v;
+      }
 AGVector3 AGVector3::operator%(const AGVector3 &amp;a) const
 {
   return AGVector3(v[1] * a.v[2] - v[2] * a.v[1],
@@ -557,34 +557,34 @@
   return AGVector3(v[0]+p.v[0],v[1]+p.v[1],v[2]+p.v[2]);
 }
 AGVector3 &amp;AGVector3::operator+=(const AGVector3 &amp;p)
-  {
-    v[0]+=p.v[0];
-    v[1]+=p.v[1];
-    v[2]+=p.v[2];
-    return *this;
-  }
+      {
+        v[0]+=p.v[0];
+        v[1]+=p.v[1];
+        v[2]+=p.v[2];
+        return *this;
+      }
 AGVector3 &amp;AGVector3::operator-=(const AGVector3 &amp;p)
-  {
-    v[0]+=p.v[0];
-    v[1]+=p.v[1];
-    v[2]+=p.v[2];
-    return *this;
-  }
+      {
+        v[0]+=p.v[0];
+        v[1]+=p.v[1];
+        v[2]+=p.v[2];
+        return *this;
+      }
 
 AGVector3 &amp;AGVector3::operator*=(float f)
-  {
-    v[0]*=f;
-    v[1]*=f;
-    v[2]*=f;
-    return *this;
-  }
+      {
+        v[0]*=f;
+        v[1]*=f;
+        v[2]*=f;
+        return *this;
+      }
 AGVector3 &amp;AGVector3::operator/=(float f)
-  {
-    v[0]/=f;
-    v[1]/=f;
-    v[2]/=f;
-    return *this;
-  }
+      {
+        v[0]/=f;
+        v[1]/=f;
+        v[2]/=f;
+        return *this;
+      }
 AGVector3 AGVector3::operator*(float f) const
 {
   return AGVector3(v[0]*f,v[1]*f,v[2]*f);
@@ -619,10 +619,10 @@
   return v[index];
 }
 float &amp;AGVector3::operator[](int index)
-  {
-    assert(index&gt;=0 &amp;&amp; index&lt;3);
-    return v[index];
-  }
+      {
+        assert(index&gt;=0 &amp;&amp; index&lt;3);
+        return v[index];
+      }
 
 
 ////////////////////////////////////////////////////////////////////////////
@@ -688,17 +688,23 @@
 }
 
 
-AGMatrix3 AGMatrix3::inverted() const
-{
-  CTRACE;
-  // gauss-alg.
-  AGMatrix3 a;
-  AGMatrix3 b(*this);
+AGMatrix3 AGMatrix3::inverted() const throw(GeometryException)
+    {
+      CTRACE;
+      // gauss-alg.
+      AGMatrix3 a;
+      AGMatrix3 b(*this);
+      try
+      {
+        gauss(a,b,3);
+      }
+      catch(...)
+      {
+        throw GeometryException(&quot;Matrix is not invertable&quot;);
+      }
+      return a;
+    }
 
-  gauss(a,b,3);
-  return a;
-}
-
 void AGMatrix3::swapRows(size_t a,size_t b)
   {
     if(a==b)
@@ -761,12 +767,12 @@
 
 
 AGMatrix3::Row AGMatrix3::operator[](size_t y)
-  {
-    Row r;
-    r.matrix=this;
-    r.y=y;
-    return r;
-  }
+      {
+        Row r;
+        r.matrix=this;
+        r.y=y;
+        return r;
+      }
 const AGMatrix3::Row AGMatrix3::operator[](size_t y) const
 {
   Row r;
@@ -798,10 +804,10 @@
   return n;
 }
 AGMatrix3 &amp;AGMatrix3::operator*=(const AGMatrix3 &amp;m)
-  {
-    *this=(*this)*m;
-    return *this;
-  }
+      {
+        *this=(*this)*m;
+        return *this;
+      }
 
 AGVector3 AGMatrix3::operator*(const AGVector3 &amp;v) const
 {
@@ -1095,8 +1101,8 @@
 /////////////////////////////////////////////////////////////////////////////
 
 AGCircle2::AGCircle2(const AGVector2 &amp;v,float rad):p(v),radius(rad)
-  {
-  }
+      {
+      }
 
 std::list&lt;AGVector2&gt; AGCircle2::collide(const AGLine2 &amp;pLine) const
 {
@@ -1265,13 +1271,13 @@
 
 AGRect2::AGRect2(const AGVector2 &amp;pv0,const AGVector2 &amp;pv1):
   v0(pv0),v1(pv1)
-    {
-    }
+        {
+        }
 
 AGRect2::AGRect2(float x,float y,float w,float h):
   v0(x,y),v1(x+w,y+h)
-    {
-    }
+        {
+        }
 
 AGVector2 AGRect2::clip(const AGVector2 &amp;v) const
 {
@@ -1310,16 +1316,16 @@
 }
 
 AGRect2&amp; AGRect2::operator+=(const AGRect2 &amp;r)
-  {
-    if(width()==0 || height()==0)
-      *this=r;
-    else
       {
-        include(r[0]);
-        include(r[1]);
+        if(width()==0 || height()==0)
+          *this=r;
+        else
+          {
+            include(r[0]);
+            include(r[1]);
+          }
+        return *this;
       }
-    return *this;
-  }
 
 
 
@@ -1408,18 +1414,18 @@
   return v0;
 }
 AGVector2 &amp;AGRect2::operator[](size_t i)
-  {
-    switch(i)
       {
-    case 0:
-      return v0;
-    case 1:
-      return v1;
-    default:
-      throw AGString(&quot;invalid index in AGRect2::operator[]&quot;);
+        switch(i)
+          {
+        case 0:
+          return v0;
+        case 1:
+          return v1;
+        default:
+          throw AGString(&quot;invalid index in AGRect2::operator[]&quot;);
+          }
+        return v0;
       }
-    return v0;
-  }
 
 AGRect2 AGRect2::shrink(float f) const
 {
@@ -1608,18 +1614,18 @@
   return AGRect2(v0-v,v1-v);
 }
 AGRect2 &amp;AGRect2::operator+=(const AGVector2 &amp;v)
-  {
-    v0+=v;
-    v1+=v;
-    return *this;
-  }
+      {
+        v0+=v;
+        v1+=v;
+        return *this;
+      }
 
 AGRect2 &amp;AGRect2::operator-=(const AGVector2 &amp;v)
-  {
-    v0-=v;
-    v1-=v;
-    return *this;
-  }
+      {
+        v0-=v;
+        v1-=v;
+        return *this;
+      }
 
 float AGRect2::x() const
 {
@@ -1658,22 +1664,22 @@
 
 AGLine2::AGLine2(const AGVector2 &amp;pv0,const AGVector2 &amp;pv1):
   v0(pv0),v1(pv1)
-    {
-    }
+        {
+        }
 
 AGVector2 &amp;AGLine2::operator[](size_t i)
-  {
-    switch(i)
       {
-    case 0:
-      return v0;
-    case 1:
-      return v1;
-    default:
-      throw AGString(&quot;wrong index in AGLine::op[]&quot;);
+        switch(i)
+          {
+        case 0:
+          return v0;
+        case 1:
+          return v1;
+        default:
+          throw AGString(&quot;wrong index in AGLine::op[]&quot;);
+          }
+        return v0;
       }
-    return v0;
-  }
 AGVector2 AGLine2::operator[](size_t i) const
 {
   switch(i)
@@ -1836,8 +1842,8 @@
 
 AGLine3::AGLine3(const AGVector3 &amp;pv0,const AGVector3 &amp;pv1):
   v0(pv0),v1(pv1)
-    {
-    }
+        {
+        }
 
 float AGLine3::distance(const AGVector3 &amp;p) const
 {
@@ -1982,21 +1988,21 @@
       v[3]+p.v[3]);
 }
 AGVector4 &amp;AGVector4::operator+=(const AGVector4 &amp;p)
-  {
-    v[0]+=p.v[0];
-    v[1]+=p.v[1];
-    v[2]+=p.v[2];
-    v[3]+=p.v[3];
-    return *this;
-  }
+      {
+        v[0]+=p.v[0];
+        v[1]+=p.v[1];
+        v[2]+=p.v[2];
+        v[3]+=p.v[3];
+        return *this;
+      }
 AGVector4 &amp;AGVector4::operator-=(const AGVector4 &amp;p)
-  {
-    v[0]-=p.v[0];
-    v[1]-=p.v[1];
-    v[2]-=p.v[2];
-    v[3]-=p.v[3];
-    return *this;
-  }
+      {
+        v[0]-=p.v[0];
+        v[1]-=p.v[1];
+        v[2]-=p.v[2];
+        v[3]-=p.v[3];
+        return *this;
+      }
 
 float AGVector4::operator*(const AGVector4 &amp;p) const
 {
@@ -2006,21 +2012,21 @@
   v[3]*p.v[3];
 }
 AGVector4 &amp;AGVector4::operator*=(float f)
-  {
-    v[0]*=f;
-    v[1]*=f;
-    v[2]*=f;
-    v[3]*=f;
-    return *this;
-  }
+      {
+        v[0]*=f;
+        v[1]*=f;
+        v[2]*=f;
+        v[3]*=f;
+        return *this;
+      }
 AGVector4 &amp;AGVector4::operator/=(float f)
-  {
-    v[0]/=f;
-    v[1]/=f;
-    v[2]/=f;
-    v[3]/=f;
-    return *this;
-  }
+      {
+        v[0]/=f;
+        v[1]/=f;
+        v[2]/=f;
+        v[3]/=f;
+        return *this;
+      }
 AGVector4 AGVector4::operator*(float f) const
 {
   return AGVector4(v[0]*f,v[1]*f,v[2]*f,v[3]*f);
@@ -2078,10 +2084,10 @@
   }
 
 float &amp;AGVector4::operator[](int index)
-  {
-    assert(index&gt;=0 &amp;&amp; index&lt;4);
-    return v[index];
-  }
+      {
+        assert(index&gt;=0 &amp;&amp; index&lt;4);
+        return v[index];
+      }
 
 float AGVector4::operator[](int index) const
 {
@@ -2105,9 +2111,9 @@
 }
 
 (AGVector4::operator float*)()
-  {
-    return v;
-  }
+      {
+        return v;
+      }
 
 (AGVector4::operator const float*)() const
 {
@@ -2193,12 +2199,12 @@
   }
 
 AGMatrix4 &amp;AGMatrix4::operator+=(const AGMatrix4 &amp;m)
-  {
-    for(size_t x=0;x&lt;4;x++)
-      for(size_t y=0;y&lt;4;y++)
-        get(x,y)+=m.get(x,y);
-    return *this;
-  }
+      {
+        for(size_t x=0;x&lt;4;x++)
+          for(size_t y=0;y&lt;4;y++)
+            get(x,y)+=m.get(x,y);
+        return *this;
+      }
 
 AGMatrix4 AGMatrix4::transposed() const
 {
@@ -2295,10 +2301,10 @@
   return n;
 }
 AGMatrix4 &amp;AGMatrix4::operator*=(const AGMatrix4 &amp;m)
-  {
-    *this=(*this)*m;
-    return *this;
-  }
+      {
+        *this=(*this)*m;
+        return *this;
+      }
 
 AGVector4 AGMatrix4::operator*(const AGVector4 &amp;v) const
 {
@@ -2319,9 +2325,9 @@
 }
 
 (AGMatrix4::operator float*)()
-  {
-    return a;
-  }
+      {
+        return a;
+      }
 
 (AGMatrix4::operator const float*)() const
 {
@@ -2342,9 +2348,9 @@
   return get(x,y);
 }
 float &amp;AGMatrix4::operator()(size_t x,size_t y)
-  {
-    return get(x,y);
-  }
+      {
+        return get(x,y);
+      }
 
 AGVector4 AGMatrix4::getRow(size_t i) const
 {
@@ -2354,12 +2360,12 @@
 
 
 AGMatrix4::MRow AGMatrix4::operator[](size_t y)
-  {
-    MRow r;
-    r.matrix=this;
-    r.y=y;
-    return r;
-  }
+      {
+        MRow r;
+        r.matrix=this;
+        r.y=y;
+        return r;
+      }
 /*
 const AGMatrix4::Row AGMatrix4::operator[](size_t y) const
 {
@@ -2376,23 +2382,23 @@
 
 AGBox3::AGBox3(const AGVector3 &amp;pBase,const AGVector3 &amp;pDir):
   base(pBase),dir(pDir)
-    {
-      // assert that pDir[i]&gt;0
-      for(size_t i=0;i&lt;3;i++)
-        if(dir[i]&lt;0)
-          {
-            base[i]+=dir[i];
-            dir[i]=-dir[i];
-          }
-      mValid=true;
-    }
+        {
+          // assert that pDir[i]&gt;0
+          for(size_t i=0;i&lt;3;i++)
+            if(dir[i]&lt;0)
+              {
+                base[i]+=dir[i];
+                dir[i]=-dir[i];
+              }
+          mValid=true;
+        }
 
 
 
 AGBox3::AGBox3():base(AGVector3(0,0,0)),dir(AGVector3(0,0,0))
-  {
-    mValid=false;
-  }
+      {
+        mValid=false;
+      }
 
 bool AGBox3::valid() const
 {
@@ -2585,15 +2591,15 @@
 
 AGRect3::AGRect3(const AGVector3 &amp;pBase,const AGVector3 &amp;pDir):
   base(pBase),dir(pDir)
-    {
-      // assert that dir[i]&gt;=0
-      for(size_t i=0;i&lt;3;i++)
-        if(dir[i]&lt;0)
-          {
-            base[i]+=dir[i];
-            dir[i]=-dir[i];
-          }
-    }
+        {
+          // assert that dir[i]&gt;=0
+          for(size_t i=0;i&lt;3;i++)
+            if(dir[i]&lt;0)
+              {
+                base[i]+=dir[i];
+                dir[i]=-dir[i];
+              }
+        }
 
 bool AGRect3::collides(const AGLine3&amp;pLine) const
 {
@@ -2679,3 +2685,23 @@
     o&lt;&lt;&quot;(&quot;&lt;&lt;v.base&lt;&lt;&quot; &quot;&lt;&lt;v.dir&lt;&lt;&quot;/&quot;&lt;&lt;v.valid()&lt;&lt;&quot;)&quot;;
     return o;
   }
+
+std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGMatrix3&amp;v)
+  {
+    o&lt;&lt;&quot;(&quot;;
+    o&lt;&lt;&quot;(&quot;&lt;&lt;v.get(0,0)&lt;&lt;&quot;;&quot;&lt;&lt;v.get(1,0)&lt;&lt;&quot;;&quot;&lt;&lt;v.get(2,0)&lt;&lt;&quot;),&quot;;
+    o&lt;&lt;&quot;(&quot;&lt;&lt;v.get(0,1)&lt;&lt;&quot;;&quot;&lt;&lt;v.get(1,1)&lt;&lt;&quot;;&quot;&lt;&lt;v.get(2,1)&lt;&lt;&quot;),&quot;;
+    o&lt;&lt;&quot;(&quot;&lt;&lt;v.get(0,2)&lt;&lt;&quot;;&quot;&lt;&lt;v.get(1,2)&lt;&lt;&quot;;&quot;&lt;&lt;v.get(2,2)&lt;&lt;&quot;),&quot;;
+    o&lt;&lt;&quot;)&quot;;
+    return o;
+  }
+std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGMatrix4&amp;v)
+  {
+    o&lt;&lt;&quot;(&quot;;
+    o&lt;&lt;&quot;(&quot;&lt;&lt;v.get(0,0)&lt;&lt;&quot;;&quot;&lt;&lt;v.get(1,0)&lt;&lt;&quot;;&quot;&lt;&lt;v.get(2,0)&lt;&lt;v.get(3,0)&lt;&lt;&quot;),&quot;;
+    o&lt;&lt;&quot;(&quot;&lt;&lt;v.get(0,1)&lt;&lt;&quot;;&quot;&lt;&lt;v.get(1,1)&lt;&lt;&quot;;&quot;&lt;&lt;v.get(2,1)&lt;&lt;v.get(3,1)&lt;&lt;&quot;),&quot;;
+    o&lt;&lt;&quot;(&quot;&lt;&lt;v.get(0,2)&lt;&lt;&quot;;&quot;&lt;&lt;v.get(1,2)&lt;&lt;&quot;;&quot;&lt;&lt;v.get(2,2)&lt;&lt;v.get(3,2)&lt;&lt;&quot;),&quot;;
+    o&lt;&lt;&quot;(&quot;&lt;&lt;v.get(0,3)&lt;&lt;&quot;;&quot;&lt;&lt;v.get(1,3)&lt;&lt;&quot;;&quot;&lt;&lt;v.get(2,3)&lt;&lt;v.get(3,3)&lt;&lt;&quot;),&quot;;
+    o&lt;&lt;&quot;)&quot;;
+    return o;
+  }

Modified: antargis/trunk/ext/basic/ag_geometry.h
===================================================================
--- antargis/trunk/ext/basic/ag_geometry.h	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/basic/ag_geometry.h	2008-06-05 19:24:45 UTC (rev 1263)
@@ -29,6 +29,7 @@
 #include &lt;vector&gt;
 #include &lt;ag_base.h&gt;
 #include &lt;ag_string.h&gt;
+#include &lt;stdexcept&gt;
 
 /* There are following classes:
 
@@ -61,154 +62,171 @@
     explicit AGAngle(float a);
   };
 
+class GeometryException
+  {
+    public:
+      GeometryException(const std::string &amp;p):s(p)
+    {}
+#ifdef SWIG
+      %rename(to_s) what() const;
+#endif
+      std::string what() const
+      {
+        return s;
+      }
+      
+    private:
+      std::string s;
+  };
+
 class AGEXPORT AGVector2
   {
-public:
-  float v[2];
+  public:
+    float v[2];
 
-  AGVector2(const AGString &amp;s);
-  AGVector2(float pX,float pY);
-  AGVector2(const AGAngle &amp;a);
-  AGVector2(const AGVector2 &amp;a);
-  AGVector2();
+    AGVector2(const AGString &amp;s);
+    AGVector2(float pX,float pY);
+    AGVector2(const AGAngle &amp;a);
+    AGVector2(const AGVector2 &amp;a);
+    AGVector2();
 
-  void setX(float pX);
-  void setY(float pY);
+    void setX(float pX);
+    void setY(float pY);
 
-  AGVector2 dim2() const;
+    AGVector2 dim2() const;
 
 
 #ifdef SWIG
-  %rename(x) getX() const;
-  %rename(y) getY() const;
+    %rename(x) getX() const;
+    %rename(y) getY() const;
 #endif
-  float getX() const;
-  float getY() const;
+    float getX() const;
+    float getY() const;
 
-  AGAngle getAngle() const;
+    AGAngle getAngle() const;
 
 
-  bool operator&lt;(const AGVector2 &amp;p) const;
+    bool operator&lt;(const AGVector2 &amp;p) const;
 
-  AGVector2 operator-() const;
-  AGVector2 operator-(const AGVector2 &amp;p) const;
-  AGVector2 operator+(const AGVector2 &amp;p) const;
-  AGVector2 &amp;operator+=(const AGVector2 &amp;p);
-  AGVector2 &amp;operator-=(const AGVector2 &amp;p);
+    AGVector2 operator-() const;
+    AGVector2 operator-(const AGVector2 &amp;p) const;
+    AGVector2 operator+(const AGVector2 &amp;p) const;
+    AGVector2 &amp;operator+=(const AGVector2 &amp;p);
+    AGVector2 &amp;operator-=(const AGVector2 &amp;p);
 
-  float operator*(const AGVector2 &amp;p) const;
-  AGVector2 &amp;operator*=(float f);
-  AGVector2 &amp;operator/=(float f);
-  AGVector2 operator*(float f) const;
-  AGVector2 operator/(float f) const;
+    float operator*(const AGVector2 &amp;p) const;
+    AGVector2 &amp;operator*=(float f);
+    AGVector2 &amp;operator/=(float f);
+    AGVector2 operator*(float f) const;
+    AGVector2 operator/(float f) const;
 
-  bool operator==(const AGVector2 &amp;a) const;
-  bool operator!=(const AGVector2 &amp;a) const;
+    bool operator==(const AGVector2 &amp;a) const;
+    bool operator!=(const AGVector2 &amp;a) const;
 
-  float length() const;
-  float length2() const;
+    float length() const;
+    float length2() const;
 
-  AGVector2 normalized() const;
-  void normalize();
+    AGVector2 normalized() const;
+    void normalize();
 
-  AGVector2 normal() const;
+    AGVector2 normal() const;
 
 #ifdef SWIG
-  %rename(__getitem__) operator[](int index) const;
+    %rename(__getitem__) operator[](int index) const;
 #endif
-  float operator[](int index) const;
-  float &amp;operator[](int index);
+    float operator[](int index) const;
+    float &amp;operator[](int index);
 
-  bool nonZero() const;
+    bool nonZero() const;
 
-  void saveXML(Node &amp;node) const;
-  void loadXML(const Node &amp;node);
+    void saveXML(Node &amp;node) const;
+    void loadXML(const Node &amp;node);
 
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
 
 #ifndef SWIG
-  (operator float*)();
-  (operator const float*)() const;
+    (operator float*)();
+    (operator const float*)() const;
 #endif
   };
 
 // 2-dim homogenous vector
 class AGEXPORT AGVector3
   {
-public:
-  float v[3];
+  public:
+    float v[3];
 
-  AGVector3(const AGVector2 &amp;p,float h=1.0f);
-  AGVector3(float pX,float pY,float pZ=0.0f);
-  AGVector3(const AGAngle &amp;a);
-  AGVector3(const AGVector3 &amp;a);
-  AGVector3();
+    AGVector3(const AGVector2 &amp;p,float h=1.0f);
+    AGVector3(float pX,float pY,float pZ=0.0f);
+    AGVector3(const AGAngle &amp;a);
+    AGVector3(const AGVector3 &amp;a);
+    AGVector3();
 
-  void setX(float pX);
-  void setY(float pY);
-  void setZ(float pZ);
+    void setX(float pX);
+    void setY(float pY);
+    void setZ(float pZ);
 
 
 #ifdef SWIG
-  %rename(x) getX() const;
-  %rename(y) getY() const;
-  %rename(z) getZ() const;
+    %rename(x) getX() const;
+    %rename(y) getY() const;
+    %rename(z) getZ() const;
 #endif
-  float getX() const;
-  float getY() const;
-  float getZ() const;
+    float getX() const;
+    float getY() const;
+    float getZ() const;
 
-  AGAngle getAngle() const;
+    AGAngle getAngle() const;
 
-  AGVector3 operator-() const;
+    AGVector3 operator-() const;
 
-  AGVector3 operator-(const AGVector3 &amp;p) const;
-  AGVector3 operator+(const AGVector3 &amp;p) const;
+    AGVector3 operator-(const AGVector3 &amp;p) const;
+    AGVector3 operator+(const AGVector3 &amp;p) const;
 #ifdef SWIG
-  %rename(add) operator+=(const AGVector3 &amp;p);
-  %rename(sub) operator-=(const AGVector3 &amp;p);
+    %rename(add) operator+=(const AGVector3 &amp;p);
+    %rename(sub) operator-=(const AGVector3 &amp;p);
 #endif
-  AGVector3 &amp;operator+=(const AGVector3 &amp;p);
-  AGVector3 &amp;operator-=(const AGVector3 &amp;p);
+    AGVector3 &amp;operator+=(const AGVector3 &amp;p);
+    AGVector3 &amp;operator-=(const AGVector3 &amp;p);
 
-  float operator*(const AGVector3 &amp;p) const;
-  AGVector3 &amp;operator*=(float f);
-  AGVector3 &amp;operator/=(float f);
-  AGVector3 operator*(float f) const;
-  AGVector3 operator/(float f) const;
-  AGVector3 operator%(const AGVector3 &amp;a) const;
+    float operator*(const AGVector3 &amp;p) const;
+    AGVector3 &amp;operator*=(float f);
+    AGVector3 &amp;operator/=(float f);
+    AGVector3 operator*(float f) const;
+    AGVector3 operator/(float f) const;
+    AGVector3 operator%(const AGVector3 &amp;a) const;
 
-  bool operator==(const AGVector3 &amp;a) const;
-  bool operator!=(const AGVector3 &amp;a) const;
+    bool operator==(const AGVector3 &amp;a) const;
+    bool operator!=(const AGVector3 &amp;a) const;
 
-  float length() const;
-  float length2() const;
+    float length() const;
+    float length2() const;
 
-  AGVector3 normalized() const;
-  void normalize();
+    AGVector3 normalized() const;
+    void normalize();
 
-  AGVector3 normal() const;
+    AGVector3 normal() const;
 
-  float operator[](int index) const;
-  float &amp;operator[](int index);
+    float operator[](int index) const;
+    float &amp;operator[](int index);
 
-  bool nonZero() const;
+    bool nonZero() const;
 
-  void saveXML(Node &amp;node) const;
-  void loadXML(const Node &amp;node);
+    void saveXML(Node &amp;node) const;
+    void loadXML(const Node &amp;node);
 
-  AGVector2 dim2() const;
+    AGVector2 dim2() const;
 
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
 
 #ifndef SWIG
-  (operator float*)();
+    (operator float*)();
 #endif
   };
 
@@ -216,120 +234,120 @@
 class AGEXPORT AGMatrix3
   {
     float a[3][3];
-public:
-  struct Row
-    {
-      AGMatrix3 *matrix;
-      int y;
-
-      float &amp;operator[](size_t x)
+  public:
+    struct Row
       {
-        return matrix-&gt;get(x,y);
-      }
-      float operator[](size_t x) const
-      {
-        return matrix-&gt;get(x,y);
-      }
-    };
+        AGMatrix3 *matrix;
+        int y;
 
-  AGMatrix3();
-  AGMatrix3(const AGAngle &amp;a); // rotate
-  AGMatrix3(const AGVector3 &amp;a); // transpose
-  AGMatrix3(float x,float y); // scale
-  AGMatrix3(const AGMatrix3 &amp;m);
-  void set(size_t x,size_t y,float f);
-  float get(size_t x,size_t y) const;
-  float &amp;get(size_t x,size_t y);
+        float &amp;operator[](size_t x)
+        {
+          return matrix-&gt;get(x,y);
+        }
+        float operator[](size_t x) const
+        {
+          return matrix-&gt;get(x,y);
+        }
+      };
 
-  AGMatrix3 operator*(const AGMatrix3 &amp;m) const;
-  AGMatrix3 &amp;operator*=(const AGMatrix3 &amp;m);
+    AGMatrix3();
+    AGMatrix3(const AGAngle &amp;a); // rotate
+    AGMatrix3(const AGVector3 &amp;a); // transpose
+    AGMatrix3(float x,float y); // scale
+    AGMatrix3(const AGMatrix3 &amp;m);
+    void set(size_t x,size_t y,float f);
+    float get(size_t x,size_t y) const;
+    float &amp;get(size_t x,size_t y);
 
-  AGVector3 operator*(const AGVector3 &amp;v) const;
-  //  AGVector2 operator*(const AGVector2 &amp;v) const;
+    AGMatrix3 operator*(const AGMatrix3 &amp;m) const;
+    AGMatrix3 &amp;operator*=(const AGMatrix3 &amp;m);
 
-  AGMatrix3 operator-() const;
+    AGVector3 operator*(const AGVector3 &amp;v) const;
+    //  AGVector2 operator*(const AGVector2 &amp;v) const;
 
-  AGMatrix3 inverted() const;
-  AGMatrix3 transposed() const;
+    AGMatrix3 operator-() const;
 
-  Row operator[](size_t y);
-  const Row operator[](size_t y) const;
+    AGMatrix3 inverted() const throw (GeometryException);
+    AGMatrix3 transposed() const;
 
-  void swapRows(size_t a,size_t b);
-  void swapCols(size_t a,size_t b);
-  
-  bool operator==(const AGMatrix3&amp;p) const;
+    Row operator[](size_t y);
+    const Row operator[](size_t y) const;
 
+    void swapRows(size_t a,size_t b);
+    void swapCols(size_t a,size_t b);
 
+    bool operator==(const AGMatrix3&amp;p) const;
+
+
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
   };
 
 class AGEXPORT AGLine2
   {
     AGVector2 v0,v1;
-public:
-  AGLine2();
-  AGLine2(const AGVector2 &amp;pv0,const AGVector2 &amp;pv1);
+  public:
+    AGLine2();
+    AGLine2(const AGVector2 &amp;pv0,const AGVector2 &amp;pv1);
 
-  AGVector2 getV0() const;
-  AGVector2 getV1() const;
+    AGVector2 getV0() const;
+    AGVector2 getV1() const;
 
-  bool has(const AGVector2 &amp;v) const;
+    bool has(const AGVector2 &amp;v) const;
 
-  bool collide(const AGLine2 &amp;l) const;
-  AGVector2 collisionPoint(const AGLine2 &amp;l) const;
-  AGVector2 collisionPointNI(const AGLine2 &amp;l) const; // no inclusion test
-  bool includes(const AGVector2 &amp;v) const;
+    bool collide(const AGLine2 &amp;l) const;
+    AGVector2 collisionPoint(const AGLine2 &amp;l) const;
+    AGVector2 collisionPointNI(const AGLine2 &amp;l) const; // no inclusion test
+    bool includes(const AGVector2 &amp;v) const;
 
-  AGRect2 getBBox() const;
+    AGRect2 getBBox() const;
 
-  AGVector2 normal() const;
-  AGVector2 direction() const;
+    AGVector2 normal() const;
+    AGVector2 direction() const;
 
-  float distance(const AGVector2 &amp;v) const;
+    float distance(const AGVector2 &amp;v) const;
 
-  AGVector2 &amp;operator[](size_t i);
-  AGVector2 operator[](size_t i) const;
+    AGVector2 &amp;operator[](size_t i);
+    AGVector2 operator[](size_t i) const;
 
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
   };
 
 class AGEXPORT AGLine3
   {
     AGVector3 v0,v1;
-public:
-  AGLine3();
-  AGLine3(const AGVector3 &amp;pv0,const AGVector3 &amp;pv1);
+  public:
+    AGLine3();
+    AGLine3(const AGVector3 &amp;pv0,const AGVector3 &amp;pv1);
 
-  AGVector3 getV0() const;
-  AGVector3 getV1() const;
+    AGVector3 getV0() const;
+    AGVector3 getV1() const;
 
-  bool has(const AGVector3 &amp;v) const;
-  /*
+    bool has(const AGVector3 &amp;v) const;
+    /*
   bool collide(const AGLine3 &amp;l) const;
   AGVector3 collisionPoint(const AGLine3 &amp;l) const;
   AGVector3 collisionPointNI(const AGLine3 &amp;l) const; // no inclusion test
   bool includes(const AGVector3 &amp;v) const;
-   */
-  //  AGBox3 getBBox() const;
+     */
+    //  AGBox3 getBBox() const;
 
-  //  AGVector3 normal() const;
-  AGVector3 direction() const;
+    //  AGVector3 normal() const;
+    AGVector3 direction() const;
 
-  float distance(const AGVector3 &amp;p) const;
+    float distance(const AGVector3 &amp;p) const;
 
-  //  float distance(const AGVector3 &amp;v) const;
+    //  float distance(const AGVector3 &amp;v) const;
 
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
   };
 
 class AGEXPORT AGCollisionData
@@ -341,368 +359,368 @@
 class AGEXPORT AGTriangle2
   {
     AGVector2 p[3];
-public:
-  AGTriangle2();
-  AGTriangle2(const AGVector2 &amp;v0,const AGVector2 &amp;v1,const AGVector2 &amp;v2);
+  public:
+    AGTriangle2();
+    AGTriangle2(const AGVector2 &amp;v0,const AGVector2 &amp;v1,const AGVector2 &amp;v2);
 
-  AGVector2 operator[](int index) const;
+    AGVector2 operator[](int index) const;
 
-  AGVector2 get(int index) const;
+    AGVector2 get(int index) const;
 
-  bool collide(const AGTriangle2 &amp;t) const;
+    bool collide(const AGTriangle2 &amp;t) const;
 
-  // FIXME: sweep-based test
-  //  AGCollisionData collide(const AGTriangle &amp;t,const AGVector &amp;v0,const AGVector &amp;v1) const;
+    // FIXME: sweep-based test
+    //  AGCollisionData collide(const AGTriangle &amp;t,const AGVector &amp;v0,const AGVector &amp;v1) const;
 
-  std::vector&lt;AGVector2&gt; getNormals() const;
+    std::vector&lt;AGVector2&gt; getNormals() const;
 
-  void apply(const AGMatrix3 &amp;m);
-  AGTriangle2 applied(const AGMatrix3 &amp;m) const;
+    void apply(const AGMatrix3 &amp;m);
+    AGTriangle2 applied(const AGMatrix3 &amp;m) const;
 
-  // estimate touching point (or middle of touching area)
-  AGVector2 touchPoint(const AGTriangle2 &amp;t) const;
-  AGVector2 touchVector(const AGTriangle2 &amp;t) const;
+    // estimate touching point (or middle of touching area)
+    AGVector2 touchPoint(const AGTriangle2 &amp;t) const;
+    AGVector2 touchVector(const AGTriangle2 &amp;t) const;
 
-  std::vector&lt;AGVector2&gt; collisionPoints(const AGLine2 &amp;l) const;
+    std::vector&lt;AGVector2&gt; collisionPoints(const AGLine2 &amp;l) const;
 
-  bool contains(const AGVector2 &amp;p) const;
+    bool contains(const AGVector2 &amp;p) const;
 
-  AGRect2 getBBox() const;
+    AGRect2 getBBox() const;
 
-  AGLine2 nearestLine(const AGVector2 &amp;v) const;
+    AGLine2 nearestLine(const AGVector2 &amp;v) const;
 
-  std::vector&lt;AGLine2&gt; getLines() const;
+    std::vector&lt;AGLine2&gt; getLines() const;
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
   };
 
 class AGEXPORT AGCircle2
   {
     AGVector2 p;
     float radius;
-public:
-  AGCircle2(const AGVector2 &amp;v,float rad);
+  public:
+    AGCircle2(const AGVector2 &amp;v,float rad);
 
-  bool inCircle(const AGTriangle2 &amp;t) const;
-  bool outCircle(const AGTriangle2 &amp;t) const;
-  bool inCircle(const AGVector2 &amp;v) const;
-  bool outCircle(const AGVector2 &amp;v) const;
+    bool inCircle(const AGTriangle2 &amp;t) const;
+    bool outCircle(const AGTriangle2 &amp;t) const;
+    bool inCircle(const AGVector2 &amp;v) const;
+    bool outCircle(const AGVector2 &amp;v) const;
 
-  AGVector2 getPos() const;
-  float getRadius() const;
+    AGVector2 getPos() const;
+    float getRadius() const;
 
-  std::list&lt;AGVector2&gt; collide(const AGLine2 &amp;pLine) const;
+    std::list&lt;AGVector2&gt; collide(const AGLine2 &amp;pLine) const;
   };
 
 class AGVector4;
 class AGEXPORT AGTriangle3
   {
     AGVector3 p[3];
-public:
-  AGTriangle3(const AGVector3 &amp;v0,const AGVector3 &amp;v1,const AGVector3 &amp;v2);
+  public:
+    AGTriangle3(const AGVector3 &amp;v0,const AGVector3 &amp;v1,const AGVector3 &amp;v2);
 
-  // (x,y,z,0) for no collision 
-  // (x,y,z,1) for collision in point (x,y,z)
-  AGVector4 collide(const AGLine3 &amp;pLine) const;
+    // (x,y,z,0) for no collision 
+    // (x,y,z,1) for collision in point (x,y,z)
+    AGVector4 collide(const AGLine3 &amp;pLine) const;
 
-  AGString toString() const;
+    AGString toString() const;
 
-  AGVector3 operator[](int index) const;
+    AGVector3 operator[](int index) const;
   };
 
 class AGEXPORT AGRect2
   {
     AGVector2 v0,v1;
-public:
-  AGRect2();
-  AGRect2(const AGVector2 &amp;pv0,const AGVector2 &amp;pv1);
-  AGRect2(float x,float y,float w,float h);
-  AGRect2(const AGString &amp;ps);
-  AGRect2(const SDL_Rect &amp;r);
+  public:
+    AGRect2();
+    AGRect2(const AGVector2 &amp;pv0,const AGVector2 &amp;pv1);
+    AGRect2(float x,float y,float w,float h);
+    AGRect2(const AGString &amp;ps);
+    AGRect2(const SDL_Rect &amp;r);
 
-  bool collide(const AGRect2 &amp;r) const;
+    bool collide(const AGRect2 &amp;r) const;
 
-  void include(const AGVector2 &amp;v);
+    void include(const AGVector2 &amp;v);
 
-  AGRect2 operator+(const AGVector2 &amp;v) const;
-  AGRect2 operator-(const AGVector2 &amp;v) const;
-  AGRect2 &amp;operator+=(const AGVector2 &amp;v);
-  AGRect2 &amp;operator-=(const AGVector2 &amp;v);
+    AGRect2 operator+(const AGVector2 &amp;v) const;
+    AGRect2 operator-(const AGVector2 &amp;v) const;
+    AGRect2 &amp;operator+=(const AGVector2 &amp;v);
+    AGRect2 &amp;operator-=(const AGVector2 &amp;v);
 
-  AGRect2&amp; operator+=(const AGRect2 &amp;r);
+    AGRect2&amp; operator+=(const AGRect2 &amp;r);
 
-  bool contains(const AGVector2 &amp;v) const;
-  bool contains(const AGRect2 &amp;v) const;
+    bool contains(const AGVector2 &amp;v) const;
+    bool contains(const AGRect2 &amp;v) const;
 
-  std::list&lt;AGRect2&gt; split() const;
+    std::list&lt;AGRect2&gt; split() const;
 
-  AGVector2 operator[](size_t i) const;
-  AGVector2 &amp;operator[](size_t i);
+    AGVector2 operator[](size_t i) const;
+    AGVector2 &amp;operator[](size_t i);
 
-  AGVector2 getV0() const;
-  AGVector2 getV1() const;
-  AGVector2 getV01() const;
-  AGVector2 getV10() const;
+    AGVector2 getV0() const;
+    AGVector2 getV1() const;
+    AGVector2 getV01() const;
+    AGVector2 getV10() const;
 
-  AGVector2 getMiddle() const;
+    AGVector2 getMiddle() const;
 
-  AGRect2 shrink(float f) const;
-  AGRect2 shrinkToTopLeft(float w,float h) const;
-  AGRect2 grow(float f) const;
+    AGRect2 shrink(float f) const;
+    AGRect2 shrinkToTopLeft(float w,float h) const;
+    AGRect2 grow(float f) const;
 
-  void setX(float p);
-  void setY(float p);
+    void setX(float p);
+    void setY(float p);
 
-  void setLeft(float p); // attention - modifies right, too
-  void setTop(float p);  // attention - modifies bottom, too
+    void setLeft(float p); // attention - modifies right, too
+    void setTop(float p);  // attention - modifies bottom, too
 
-  void setRight(float p);
-  void setBottom(float p);
+    void setRight(float p);
+    void setBottom(float p);
 
-  float setWidth(float w);
-  float setHeight(float w);
+    float setWidth(float w);
+    float setHeight(float w);
 
-  float x() const;
-  float y() const;
-  float w() const;
-  float h() const;
+    float x() const;
+    float y() const;
+    float w() const;
+    float h() const;
 
-  float width() const;
-  float height() const;
+    float width() const;
+    float height() const;
 
-  float x0() const;
-  float y0() const;
-  float x1() const;
-  float y1() const;
+    float x0() const;
+    float y0() const;
+    float x1() const;
+    float y1() const;
 
-  AGVector2 clip(const AGVector2 &amp;v) const;
+    AGVector2 clip(const AGVector2 &amp;v) const;
 
-  AGRect2 origin() const;
+    AGRect2 origin() const;
 
-  AGRect2 intersect(const AGRect2 &amp;r) const;
+    AGRect2 intersect(const AGRect2 &amp;r) const;
 
-  //result=this-r
-  std::vector&lt;AGRect2&gt; difference(const AGRect2 &amp;r) const;
+    //result=this-r
+    std::vector&lt;AGRect2&gt; difference(const AGRect2 &amp;r) const;
 
-  SDL_Rect sdl() const;
+    SDL_Rect sdl() const;
 
-  bool operator==(const AGRect2 &amp;r) const;
-  bool operator!=(const AGRect2 &amp;r) const;
+    bool operator==(const AGRect2 &amp;r) const;
+    bool operator!=(const AGRect2 &amp;r) const;
 
-  void check() const;
+    void check() const;
 
-  AGRect2 alignGrid() const; // align to integer grid
+    AGRect2 alignGrid() const; // align to integer grid
 
-  float content() const;
+    float content() const;
 
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
   };
 
 
 class AGEXPORT AGVector4
   {
-public:
-  float v[4];
+  public:
+    float v[4];
 
-  AGVector4(float pX,float pY,float pZ,float pW=1.0f);
-  AGVector4(const AGVector4 &amp;a);
-  AGVector4(const AGVector3 &amp;a,float h);
-  AGVector4();
+    AGVector4(float pX,float pY,float pZ,float pW=1.0f);
+    AGVector4(const AGVector4 &amp;a);
+    AGVector4(const AGVector3 &amp;a,float h);
+    AGVector4();
 
-  void setX(float pX);
-  void setY(float pY);
-  void setZ(float pZ);
-  void setW(float pW);
+    void setX(float pX);
+    void setY(float pY);
+    void setZ(float pZ);
+    void setW(float pW);
 
 
 #ifdef SWIG
-  %rename(x) getX() const;
-  %rename(y) getY() const;
-  %rename(z) getZ() const;
-  %rename(w) getW() const;
+    %rename(x) getX() const;
+    %rename(y) getY() const;
+    %rename(z) getZ() const;
+    %rename(w) getW() const;
 #endif
-  float getX() const;
-  float getY() const;
-  float getZ() const;
-  float getW() const;
+    float getX() const;
+    float getY() const;
+    float getZ() const;
+    float getW() const;
 
-  AGVector4 operator-(const AGVector4 &amp;p) const;
-  AGVector4 operator+(const AGVector4 &amp;p) const;
+    AGVector4 operator-(const AGVector4 &amp;p) const;
+    AGVector4 operator+(const AGVector4 &amp;p) const;
 #ifdef SWIG
-  %rename(add) operator+=(const AGVector4 &amp;p);
-  %rename(sub) operator-=(const AGVector4 &amp;p);
+    %rename(add) operator+=(const AGVector4 &amp;p);
+    %rename(sub) operator-=(const AGVector4 &amp;p);
 #endif
-  AGVector4 &amp;operator+=(const AGVector4 &amp;p);
-  AGVector4 &amp;operator-=(const AGVector4 &amp;p);
+    AGVector4 &amp;operator+=(const AGVector4 &amp;p);
+    AGVector4 &amp;operator-=(const AGVector4 &amp;p);
 
-  float operator*(const AGVector4 &amp;p) const;
-  AGVector4 &amp;operator*=(float f);
-  AGVector4 &amp;operator/=(float f);
-  AGVector4 operator*(float f) const;
-  AGVector4 operator/(float f) const;
-  AGVector4 operator-() const;
+    float operator*(const AGVector4 &amp;p) const;
+    AGVector4 &amp;operator*=(float f);
+    AGVector4 &amp;operator/=(float f);
+    AGVector4 operator*(float f) const;
+    AGVector4 operator/(float f) const;
+    AGVector4 operator-() const;
 
-  bool operator==(const AGVector4 &amp;a) const;
-  bool operator!=(const AGVector4 &amp;a) const;
+    bool operator==(const AGVector4 &amp;a) const;
+    bool operator!=(const AGVector4 &amp;a) const;
 
-  float length() const;
-  // length^2
-  float length2() const;
+    float length() const;
+    // length^2
+    float length2() const;
 
-  // length 3-dim vector
-  float length3() const;
+    // length 3-dim vector
+    float length3() const;
 
 
-  AGVector4 normalized() const;
-  void normalize();
+    AGVector4 normalized() const;
+    void normalize();
 
-  // 3-dimensional
-  AGVector4 normalized3() const;
-  void normalize3();
+    // 3-dimensional
+    AGVector4 normalized3() const;
+    void normalize3();
 
 
-  float operator[](int index) const;
-  float &amp;operator[](int index);
+    float operator[](int index) const;
+    float &amp;operator[](int index);
 
-  bool nonZero() const;
+    bool nonZero() const;
 
-  // vector-cross-product
-  // ignores 4th coordinate
-  AGVector4 operator%(const AGVector4 &amp;a) const;
-  AGVector4 cross(const AGVector4 &amp;a) const
-  {
-    return operator%(a);
-  }
+    // vector-cross-product
+    // ignores 4th coordinate
+    AGVector4 operator%(const AGVector4 &amp;a) const;
+    AGVector4 cross(const AGVector4 &amp;a) const
+    {
+      return operator%(a);
+    }
 
 
-  AGVector3 dim3() const;
-  AGVector2 dim2() const;
+    AGVector3 dim3() const;
+    AGVector2 dim2() const;
 
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
 
 #ifndef SWIG
-  (operator float*)();
-  (operator const float*)() const;
+    (operator float*)();
+    (operator const float*)() const;
 #endif
   };
 
 class AGEXPORT AGMatrix4
   {
     float a[16];
-public:
-  struct MRow
-    {
-      AGMatrix4 *matrix;
-      int y;
-
-      float &amp;operator[](size_t x)
+  public:
+    struct MRow
       {
-        return matrix-&gt;get(x,y);
-      }
-      float operator[](size_t x) const
-      {
-        return matrix-&gt;get(x,y);
-      }
-    };
+        AGMatrix4 *matrix;
+        int y;
 
-  AGMatrix4();
-  AGMatrix4(float v[16]);
-  AGMatrix4(float angle,const AGVector3 &amp;d);
-  AGMatrix4(const AGVector4 &amp;a);
-  void set(size_t x,size_t y,float f);
-  float get(size_t x,size_t y) const;
-  float &amp;get(size_t x,size_t y);
+        float &amp;operator[](size_t x)
+        {
+          return matrix-&gt;get(x,y);
+        }
+        float operator[](size_t x) const
+        {
+          return matrix-&gt;get(x,y);
+        }
+      };
 
-  AGMatrix4 operator*(const AGMatrix4 &amp;m) const;
-  AGMatrix4 &amp;operator*=(const AGMatrix4 &amp;m);
-  AGMatrix4 &amp;operator+=(const AGMatrix4 &amp;m);
+    AGMatrix4();
+    AGMatrix4(float v[16]);
+    AGMatrix4(float angle,const AGVector3 &amp;d);
+    AGMatrix4(const AGVector4 &amp;a);
+    void set(size_t x,size_t y,float f);
+    float get(size_t x,size_t y) const;
+    float &amp;get(size_t x,size_t y);
 
-  AGMatrix3 get3x3(size_t x,size_t y) const;
+    AGMatrix4 operator*(const AGMatrix4 &amp;m) const;
+    AGMatrix4 &amp;operator*=(const AGMatrix4 &amp;m);
+    AGMatrix4 &amp;operator+=(const AGMatrix4 &amp;m);
 
-  AGVector4 operator*(const AGVector4 &amp;v) const;
+    AGMatrix3 get3x3(size_t x,size_t y) const;
 
-  float operator()(size_t x,size_t y) const;
-  float &amp;operator()(size_t x,size_t y);
+    AGVector4 operator*(const AGVector4 &amp;v) const;
 
-  AGMatrix4 inverted() const;
-  AGMatrix4 transposed() const;
+    float operator()(size_t x,size_t y) const;
+    float &amp;operator()(size_t x,size_t y);
 
-  MRow operator[](size_t y);
-  //  const Row operator[](size_t y) const;
+    AGMatrix4 inverted() const;
+    AGMatrix4 transposed() const;
 
-  void swapRows(size_t a,size_t b);
-  void swapCols(size_t a,size_t b);
+    MRow operator[](size_t y);
+    //  const Row operator[](size_t y) const;
 
+    void swapRows(size_t a,size_t b);
+    void swapCols(size_t a,size_t b);
+
 #ifdef SWIG
-  %rename(to_s) toString() const;
+    %rename(to_s) toString() const;
 #endif
-  AGString toString() const;
+    AGString toString() const;
 
 #ifndef SWIG
-  (operator float*)();
-  (operator const float*)() const;
-  //  (operator const double*)() const;
+    (operator float*)();
+    (operator const float*)() const;
+    //  (operator const double*)() const;
 #endif
 
-  AGVector4 getRow(size_t i) const;
+    AGVector4 getRow(size_t i) const;
   };
 
 // axis-aligned
 class AGEXPORT AGRect3
   {
     AGVector3 base,dir;
-public:
-  AGRect3(const AGVector3 &amp;pBase,const AGVector3 &amp;pDir);
+  public:
+    AGRect3(const AGVector3 &amp;pBase,const AGVector3 &amp;pDir);
 
-  bool collides(const AGLine3&amp;pLine) const;
+    bool collides(const AGLine3&amp;pLine) const;
 
-  AGString toString() const;
+    AGString toString() const;
   };
 
 // axis-aligned
 class AGEXPORT AGBox3
   {
-public:
-  AGVector3 base,dir;
+  public:
+    AGVector3 base,dir;
 
-  AGBox3();
-  AGBox3(const AGVector3 &amp;pBase,const AGVector3 &amp;pDir);
+    AGBox3();
+    AGBox3(const AGVector3 &amp;pBase,const AGVector3 &amp;pDir);
 
-  void include(const AGVector3&amp;p);
-  bool includes(const AGBox3 &amp;b);
-  bool collides(const AGVector3&amp;p) const;
+    void include(const AGVector3&amp;p);
+    bool includes(const AGBox3 &amp;b);
+    bool collides(const AGVector3&amp;p) const;
 
-  bool collides(const AGLine3&amp;p) const;
-  bool collides(const AGBox3 &amp;b) const;
+    bool collides(const AGLine3&amp;p) const;
+    bool collides(const AGBox3 &amp;b) const;
 
-  bool contains(const AGTriangle3 &amp;t) const;
+    bool contains(const AGTriangle3 &amp;t) const;
 
-  std::vector&lt;AGRect3&gt; getSides() const;
+    std::vector&lt;AGRect3&gt; getSides() const;
 
-  AGString toString() const;
+    AGString toString() const;
 
-  std::vector&lt;AGBox3&gt; split() const;
+    std::vector&lt;AGBox3&gt; split() const;
 
-  bool collides(const AGMatrix4 &amp;frustum) const;
+    bool collides(const AGMatrix4 &amp;frustum) const;
 
-  std::vector&lt;AGVector3&gt; getVertices() const;
-  void calcVertices(std::vector&lt;AGVector3&gt; &amp;vs) const;
+    std::vector&lt;AGVector3&gt; getVertices() const;
+    void calcVertices(std::vector&lt;AGVector3&gt; &amp;vs) const;
 
-  AGBox3 operator+(const AGVector3 &amp;v) const;
-  AGBox3 operator-(const AGVector3 &amp;v) const;
+    AGBox3 operator+(const AGVector3 &amp;v) const;
+    AGBox3 operator-(const AGVector3 &amp;v) const;
 
-  bool valid() const;
+    bool valid() const;
 
-private:
-  bool mValid;
+  private:
+    bool mValid;
   };
 
 #ifndef SWIG
@@ -711,6 +729,9 @@
 AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGVector4&amp;v);
 AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGRect2&amp;v);
 AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGBox3&amp;v);
+
+AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGMatrix3&amp;v);
+AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGMatrix4&amp;v);
 #endif
 
 #include &quot;ag_geometry_inline.cc&quot;

Modified: antargis/trunk/ext/basic/ag_messageobject.cc
===================================================================
--- antargis/trunk/ext/basic/ag_messageobject.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/basic/ag_messageobject.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -29,6 +29,7 @@
 AGEvent::AGEvent(AGListener *pCaller,const AGString &amp;pName,const SDL_Event &amp;e):mCaller(pCaller),mName(pName),mEvent(e),
   mMousePosition(0),mRelMousePosition(0)
   {
+    mClipped=false;
   }
 AGEvent::~AGEvent()
   {
@@ -38,7 +39,23 @@
       delete mRelMousePosition;
   }
 
+bool AGEvent::isMouseEvent() const
+{
+  return (mEvent.type==SDL_MOUSEMOTION||mEvent.type==SDL_MOUSEBUTTONUP||mEvent.type==SDL_MOUSEBUTTONDOWN);
+}
 
+
+bool AGEvent::isClipped() const
+{
+  return mClipped; 
+}
+void AGEvent::setClipped(bool f)
+  {
+    mClipped=f;
+  }
+
+
+
 void AGEvent::setVector(const AGVector2 &amp;v)
   {
     mVector=v;

Modified: antargis/trunk/ext/basic/ag_messageobject.h
===================================================================
--- antargis/trunk/ext/basic/ag_messageobject.h	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/basic/ag_messageobject.h	2008-06-05 19:24:45 UTC (rev 1263)
@@ -85,7 +85,12 @@
 
   void setVector(const AGVector2 &amp;v);
   AGVector2 getVector() const;
+  
+  bool isClipped() const;
+  void setClipped(bool f);
 
+  bool isMouseEvent() const;
+  
  private:
   AGListener *mCaller;
   AGString mName;
@@ -95,6 +100,8 @@
   AGVector2 mVector;
   AGVector2 *mMousePosition;
   AGVector2 *mRelMousePosition;
+  
+  bool mClipped;
 
  protected:
   static SDL_Event NullEvent;
@@ -166,8 +173,6 @@
 class AGEXPORT AGSignal
 {
  public:
-  //AGSignal();
-  //AGSignal(AGMessageObject *pCaller);
   AGSignal(AGMessageObject *pCaller,const AGString &amp;pName);
 
   virtual ~AGSignal();

Modified: antargis/trunk/ext/gui/ag_button.cc
===================================================================
--- antargis/trunk/ext/gui/ag_button.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/gui/ag_button.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -114,7 +114,6 @@
 void AGButton::draw(AGPainter &amp;p)
   {
     assert(mTextW);
-//    cdebug(mTextW-&gt;getText());
     p.pushMatrix();
     p.transform(AGRect2(0,0,width(),height()).shrink(borderWidth));
     AGRect2 pr=getRect().origin();

Modified: antargis/trunk/ext/gui/ag_widget.cc
===================================================================
--- antargis/trunk/ext/gui/ag_widget.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/gui/ag_widget.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -34,7 +34,9 @@
 #include &quot;ag_config.h&quot;
 #include &quot;ag_clip.h&quot;
 #include &quot;ag_painter.h&quot;
+#include &quot;ag_algebra.h&quot; // FIXME: remove this ASAP
 
+
 #define FOCUS_BY_SORT
 
 
@@ -166,7 +168,9 @@
       {
         p.pushMatrix();
 
-        p.transform(getRect());
+        p.clip(getRect());
+        //p.transform(getRect());
+        p.transform(innerToOuter().getMatrix());
 
         if(!mChildrenDrawFirst)
           draw(p);
@@ -187,7 +191,7 @@
   }
 
 void AGWidget::drawChild(AGPainter &amp;p,AGWidget *pWidget)
-  {
+  {/*
     if(mUseClientRect)
       {
         p.pushMatrix();
@@ -195,8 +199,8 @@
         pWidget-&gt;drawAll(p);
         p.popMatrix();
       }
-    else
-      pWidget-&gt;drawAll(p);
+    else*/
+    pWidget-&gt;drawAll(p);
   }
 
 AGProjection2D AGWidget::getClientProjection() const
@@ -226,6 +230,7 @@
   {
     mClientWorld=pWorld;
     mClientProj=pProjection;
+    assert(isInvertable(mClientProj.getMatrix()));
     mUseClientRect=true;
   }
 
@@ -265,14 +270,21 @@
   {
     bool retValue;
     AGVector2 old=event-&gt;getRelMousePosition();
-    AGVector2 newP;
+    AGVector2 newP=outerToInner().project(old);
+    /*
     if(mUseClientRect)
-      newP=mClientProj.inverse().project(old);
+      newP=mClientProj.inverse().project(old-mRect.getV0()); //FIXME - mRect must influence this, too (????)
     else
       newP=old-getRect().getV0();
+     */
     event-&gt;setRelMousePosition(newP);
+    bool wasClipped=event-&gt;isClipped();
+    
+    event-&gt;setClipped(wasClipped || (!getRect().contains(old)));
 
     retValue=pChild-&gt;processEvent(event);
+    
+    event-&gt;setClipped(wasClipped);
     event-&gt;setRelMousePosition(old);
 
     return retValue;
@@ -321,7 +333,8 @@
 
     if(e-&gt;isSDLEvent())
       {
-        if(getRect().contains(e-&gt;getRelMousePosition()))
+        //cdebug(e-&gt;isFocusTaken()&lt;&lt;&quot;::&quot;&lt;&lt;getName());
+        if(getRect().contains(e-&gt;getRelMousePosition()) &amp;&amp; !e-&gt;isClipped())
           {
             if(!mMouseIn)
               {
@@ -639,21 +652,57 @@
   return getScreenRect().getV0();
 }
 
-
+/**
+ * returns the extends of this widget wrt. to the screen-coordinates
+ */
 AGRect2 AGWidget::getScreenRect() const
 {
+  //return toScreen(getRect());
   AGRect2 r=getRect();
   if(mParent)
-    r+=mParent-&gt;getScreenPosition();
+    {
+      return mParent-&gt;toScreen(getRect());
+    }
   return r;
 }
 
+AGRect2 AGWidget::toScreen(const AGRect2&amp;p) const
+{
+  AGRect2 r=innerToOuter(p);
+  if(mParent)
+    r=mParent-&gt;toScreen(r);
+  return r;
+}
+
+AGVector2 AGWidget::toScreen(const AGVector2&amp;p) const
+{
+  AGVector2 r=innerToOuter(p);
+  if(mParent)
+    r=mParent-&gt;toScreen(r);
+  return r;
+}
+
+
+AGRect2 AGWidget::fromScreen(const AGRect2 &amp;p) const
+{
+  AGRect2 r=outerToInner(p);
+  if(mParent)
+    r=mParent-&gt;toScreen(r);
+  return r;
+}
+
+
+
 AGVector2 AGWidget::fromScreen(const AGVector2 &amp;p) const
 {
-  if(!mParent)
+  AGVector2 r=outerToInner(p);
+  if(mParent)
+    r=mParent-&gt;toScreen(r);
+  return r;
+  /*  if(!mParent)
     return p;
   AGRect2 r(mParent-&gt;getScreenRect());
-  return p-r[0];
+  return p-r[0];*/
 }
 
 bool AGWidget::canFocus() const
@@ -1201,3 +1250,51 @@
     mOldMousePos=startVector;
     mButtonDown=value;
   }
+
+AGProjection2D AGWidget::innerToOuter() const
+{
+  AGRect2 u(0,0,1,1);
+  return AGProjection2D(u,innerToOuter(u));
+}
+AGProjection2D AGWidget::outerToInner() const
+{
+  AGRect2 u(0,0,1,1);
+  return AGProjection2D(u,outerToInner(u));
+}
+
+AGRect2 AGWidget::innerToOuter(const AGRect2 &amp;p) const
+{
+  AGRect2 m=p;
+
+  if(mUseClientRect)
+    m=mClientProj.project(m);
+  return m+getRect().getV0();
+}
+AGVector2 AGWidget::innerToOuter(const AGVector2 &amp;p) const
+{
+  AGVector2 m=p;
+
+  if(mUseClientRect)
+    m=mClientProj.project(m);
+  return m+getRect().getV0();
+}
+AGRect2 AGWidget::outerToInner(const AGRect2 &amp;p) const
+{
+  AGRect2 m=p;
+
+  if(mUseClientRect)
+    {
+      cdebug(mClientProj.getMatrix());
+      m=mClientProj.inverse().project(m);
+    }
+  return m-getRect().getV0();
+}
+AGVector2 AGWidget::outerToInner(const AGVector2 &amp;p) const
+{
+  AGVector2 m=p;
+
+  if(mUseClientRect)
+    m=mClientProj.inverse().project(m);
+  return m-getRect().getV0();
+}
+

Modified: antargis/trunk/ext/gui/ag_widget.h
===================================================================
--- antargis/trunk/ext/gui/ag_widget.h	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/gui/ag_widget.h	2008-06-05 19:24:45 UTC (rev 1263)
@@ -180,15 +180,31 @@
   // to prevent this, use this function to &quot;use&quot; them in each frame
   virtual void useTextures(); // when caching
   void useTexturesRecursive(); // when caching
+  
+  
+  
+  
+  // geometry calculation
+  AGRect2 innerToOuter(const AGRect2 &amp;pRect) const;
+  AGVector2 innerToOuter(const AGVector2 &amp;pRect) const;
+  AGRect2 outerToInner(const AGRect2 &amp;pRect) const;
+  AGVector2 outerToInner(const AGVector2 &amp;pRect) const;
 
 
   // clear children
   void clear();
 
   AGRect2 getScreenRect() const;
+  AGRect2 toScreen(const AGRect2&amp;p) const;
+  AGVector2 toScreen(const AGVector2&amp;p) const;
+  AGRect2 fromScreen(const AGRect2 &amp;p) const;
+  AGVector2 fromScreen(const AGVector2 &amp;p) const;
+
+  AGProjection2D innerToOuter() const;
+  AGProjection2D outerToInner() const;
+  
   AGVector2 getScreenPosition() const;
   
-  AGVector2 fromScreen(const AGVector2 &amp;p) const;
 
   // focus
 
@@ -237,6 +253,8 @@
   virtual bool eventMouseMotionClipped(AGEvent *pEvent,const AGVector2 &amp;pPosition);
 
   void addChildRef(AGWidget *pWidget);
+ 
+  
 protected:
   virtual bool letChildProcess(AGWidget *pChild,AGEvent *event);
 

Modified: antargis/trunk/ext/video/ag_gltexture.cc
===================================================================
--- antargis/trunk/ext/video/ag_gltexture.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/video/ag_gltexture.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -63,7 +63,7 @@
 
 AGGLTexture::AGGLTexture(size_t W,size_t H,GLint format):w(W),h(H),d(1),m3d(false),mRectTex(false),mTarget(GL_TEXTURE_2D)
   {
-    cdebug(&quot;HUPE&quot;);
+    //cdebug(&quot;HUPE&quot;);
     initDMABuffer();
     assertGL;
     getSurfaceManager()-&gt;registerMe(this);
@@ -73,10 +73,10 @@
     bool inited=false;
     mTarget=GL_TEXTURE_2D;
 
-    cdebug(w&lt;&lt;&quot;:&quot;&lt;&lt;h);
+    //cdebug(w&lt;&lt;&quot;:&quot;&lt;&lt;h);
     if(!(isPowerOf2(w) &amp;&amp; isPowerOf2(h)))
       {
-        cdebug(&quot;not power of 2&quot;);
+        //cdebug(&quot;not power of 2&quot;);
         if(GLEE_ARB_texture_rectangle &amp;&amp; false)
           {
             mTarget=GL_TEXTURE_RECTANGLE_ARB;
@@ -86,9 +86,9 @@
             h=w=nextPowerOf2(std::max(w,h));
           }
       }
-    cdebug(&quot;1&quot;);
+    //cdebug(&quot;1&quot;);
     glEnable(mTarget);
-    cdebug(&quot;2&quot;);
+    //cdebug(&quot;2&quot;);
     glBindTexture( mTarget,mID);
     assertGL;
 
@@ -104,6 +104,7 @@
     cdebug(&quot;3&quot;);
     if(buffer)
       memset(buffer,0,bufSize);
+    /*
     cdebug(&quot;5&quot;);
     cdebug(mTarget);
     cdebug(format);
@@ -114,17 +115,18 @@
     cdebug(&quot;w:&quot;&lt;&lt;w&lt;&lt;&quot; h:&quot;&lt;&lt;h);
     cdebug(&quot;texmem:&quot;&lt;&lt;gUsedTexMemory);
     cdebug((void*)buffer);
+    */
     assertGL;
     glTexImage2D(mTarget, 0, format, w, h, 0, GL_RGBA,
         GL_UNSIGNED_BYTE, buffer);
     assertGL;
-    cdebug(&quot;6&quot;);
+    //cdebug(&quot;6&quot;);
 
     if(buffer)
       delete [] buffer;
 
-    cdebug(&quot;7&quot;);
-    cdebug(&quot;W:&quot;&lt;&lt;w&lt;&lt;&quot; h:&quot;&lt;&lt;h);
+    //cdebug(&quot;7&quot;);
+    //cdebug(&quot;W:&quot;&lt;&lt;w&lt;&lt;&quot; h:&quot;&lt;&lt;h);
     assertGL;
     gUsedTexMemory+=w*h*4;
 

Modified: antargis/trunk/ext/video/ag_painter.cc
===================================================================
--- antargis/trunk/ext/video/ag_painter.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/video/ag_painter.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -27,6 +27,7 @@
 #include &lt;ag_sdlsurface.h&gt;
 #include &lt;ag_texture.h&gt;
 #include &lt;math.h&gt;
+#include &lt;ag_geometry.h&gt;
 
 #include &lt;stdexcept&gt;
 
@@ -38,30 +39,30 @@
 
 
 AGPaintProjection::AGPaintProjection(const AGRect2 &amp;pClip):clip(pClip)
-{
-  a.set(0,0,1);
-  a.set(0,1,0);
-  a.set(0,2,0);
-  a.set(1,0,0);
-  a.set(1,1,1);
-  a.set(1,2,0);
-  a.set(2,0,0);
-  a.set(2,1,0);
-  a.set(2,2,0);
-}
+  {
+    a.set(0,0,1);
+    a.set(0,1,0);
+    a.set(0,2,0);
+    a.set(1,0,0);
+    a.set(1,1,1);
+    a.set(1,2,0);
+    a.set(2,0,0);
+    a.set(2,1,0);
+    a.set(2,2,0);
+  }
 
 AGPaintProjection::AGPaintProjection(const AGClipping &amp;pClip):advancedClipping(pClip)
-{
-  a.set(0,0,1);
-  a.set(0,1,0);
-  a.set(0,2,0);
-  a.set(1,0,0);
-  a.set(1,1,1);
-  a.set(1,2,0);
-  a.set(2,0,0);
-  a.set(2,1,0);
-  a.set(2,2,0);
-}
+  {
+    a.set(0,0,1);
+    a.set(0,1,0);
+    a.set(0,2,0);
+    a.set(1,0,0);
+    a.set(1,1,1);
+    a.set(1,2,0);
+    a.set(2,0,0);
+    a.set(2,1,0);
+    a.set(2,2,0);
+  }
 
 
 AGVector2 AGPaintProjection::project(const AGVector2 &amp;p) const
@@ -217,19 +218,19 @@
 /////////////////////////////////////////////////////////////////////////////////
 
 AGPainter::AGPainter():mCurrent(getScreen().getRect()),mTarget(&amp;getScreen())
-{
-  mTarget-&gt;beginPaint();
-}
+  {
+    mTarget-&gt;beginPaint();
+  }
 
 AGPainter::AGPainter(const AGPainter &amp;p):ps(p.ps),mCurrent(p.mCurrent),mTarget(p.mTarget)
-{
-  mTarget-&gt;beginPaint();
-}
+  {
+    mTarget-&gt;beginPaint();
+  }
 
 AGPainter::AGPainter(AGPaintTarget &amp;pTarget):mCurrent(pTarget.getRect()),mTarget(&amp;pTarget)
-{
-  mTarget-&gt;beginPaint();
-}
+  {
+    mTarget-&gt;beginPaint();
+  }
 
 
 AGPainter::~AGPainter()
@@ -476,22 +477,22 @@
 void AGPainter::fillPoly(const std::vector&lt;AGVector2&gt; &amp;pPoly,const AGColor &amp;c)
   {
     //FIXME: add clipping for none-GL (?) - for performance ?
-    
+
     std::vector&lt;AGVector2&gt; projected;
     for(std::vector&lt;AGVector2&gt;::const_iterator i=pPoly.begin();i!=pPoly.end();i++)
       projected.push_back(mCurrent.project(*i));
-     
+
     mTarget-&gt;fillPoly(projected,c);
   }
 
 void AGPainter::drawPoly(const std::vector&lt;AGVector2&gt; &amp;pPoly,const AGColor &amp;c)
   {
     //FIXME: add clipping for none-GL (?) - for performance ?
-    
+
     std::vector&lt;AGVector2&gt; projected;
     for(std::vector&lt;AGVector2&gt;::const_iterator i=pPoly.begin();i!=pPoly.end();i++)
       projected.push_back(mCurrent.project(*i));
-     
+
     mTarget-&gt;drawPoly(projected,c);
   }
 
@@ -626,3 +627,9 @@
     return mTarget.getPtr();
   }
 
+
+void AGPainter::debugOutput()
+  {
+    cdebug(mCurrent.a);
+    cdebug(mCurrent.clip);
+  }

Modified: antargis/trunk/ext/video/ag_painter.h
===================================================================
--- antargis/trunk/ext/video/ag_painter.h	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/video/ag_painter.h	2008-06-05 19:24:45 UTC (rev 1263)
@@ -131,6 +131,8 @@
   bool pointOk(const AGVector2 &amp;p) const;
 
   AGPaintTarget *getTarget();
+  
+  void debugOutput();
 
  private:
   std::list&lt;AGPaintProjection&gt; ps;

Modified: antargis/trunk/ext/video/ag_projection.cc
===================================================================
--- antargis/trunk/ext/video/ag_projection.cc	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/video/ag_projection.cc	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,10 +7,15 @@
   {
   }
 
-AGProjection2D::AGProjection2D(const AGMatrix3 &amp;pMatrix) :
+AGProjection2D::AGProjection2D(const AGMatrix3 &amp;pMatrix) throw (GeometryException) :
   mInited(true), m(pMatrix)
   {
-    assert(isInvertable(m));
+    bool invertable=isInvertable(m);
+    if(!invertable)
+      {
+        throw GeometryException(AGString(&quot;Matrix &quot;)+m.toString()+&quot; is not invertible&quot;);
+      }
+    assert(invertable);
   }
 
 AGProjection2D::AGProjection2D(const AGProjection2D &amp;p) :
@@ -30,20 +35,20 @@
     AGMatrix3 m3(to.getV0());
 
     m=m3*m2*m1;
-    
+
     assert(isInvertable(m));
   }
 
 AGRect2 AGProjection2D::project(const AGRect2 &amp;r) const
-  {
-    assert(mInited);
-    return AGRect2((m*r.getV0()).dim2(), (m*r.getV1()).dim2());
-  }
+{
+  assert(mInited);
+  return AGRect2((m*r.getV0()).dim2(), (m*r.getV1()).dim2());
+}
 AGVector2 AGProjection2D::project(const AGVector2 &amp;p) const
-  {
-    assert(mInited);
-    return (m*p).dim2();
-  }
+{
+  assert(mInited);
+  return (m*p).dim2();
+}
 
 void AGProjection2D::pushProjection(const AGProjection2D &amp;p)
   {
@@ -51,15 +56,20 @@
     m*=p.m;
   }
 
-AGProjection2D AGProjection2D::inverse() const
+AGProjection2D AGProjection2D::inverse() const throw (GeometryException)
   {
     CTRACE;
-    assert(isInvertable(m));
-    cdebug(&quot;1&quot;);
-    return AGProjection2D(m.inverted());
+    bool invertable=isInvertable(m);
+    if(!invertable)
+      {
+        cdebug(&quot;Matrix:&quot;&lt;&lt;m);
+        throw GeometryException(AGString(&quot;Matrix &quot;)+m.toString()+&quot; is not invertible&quot;);
+      }
+    AGMatrix3 inv=m.inverted();
+    return AGProjection2D(inv);
   }
 
 AGMatrix3 AGProjection2D::getMatrix() const
-  {
-    return m;
-  }
+{
+  return m;
+}

Modified: antargis/trunk/ext/video/ag_projection.h
===================================================================
--- antargis/trunk/ext/video/ag_projection.h	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ext/video/ag_projection.h	2008-06-05 19:24:45 UTC (rev 1263)
@@ -13,12 +13,12 @@
   AGProjection2D();
   AGProjection2D(const AGProjection2D &amp;p);
   AGProjection2D(const AGRect2 &amp;from, const AGRect2 &amp;to);
-  AGProjection2D(const AGMatrix3 &amp;pMatrix);
+  AGProjection2D(const AGMatrix3 &amp;pMatrix) throw (GeometryException);
 
   AGRect2 project(const AGRect2 &amp;r) const;
   AGVector2 project(const AGVector2 &amp;p) const;
   
-  AGProjection2D inverse() const;
+  AGProjection2D inverse() const throw (GeometryException);
 
   void pushProjection(const AGProjection2D &amp;p);
   

Modified: antargis/trunk/rookey/tasks.rb
===================================================================
--- antargis/trunk/rookey/tasks.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/rookey/tasks.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -110,7 +110,7 @@
     linker=Rookey::Compiler.new(config)
     
     target=linker.dllName(name)
-    
+    #pp target
     desc &quot;Link DLL #{name}&quot;
     task target=&gt;files do |t|
       linker.linkDLL(t)

Modified: antargis/trunk/ruby/editor/campaign/drag_grid.rb
===================================================================
--- antargis/trunk/ruby/editor/campaign/drag_grid.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/editor/campaign/drag_grid.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -101,6 +101,7 @@
       getChildren.map{|child|[child]+child.getAllDescendants}.flatten
     end
     def moveToContext(to)
+      
       o=getScreenRect
       p=getParent
       p.removeChild(self)

Modified: antargis/trunk/ruby/entities/ant_wolf.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_wolf.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/entities/ant_wolf.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -30,225 +30,223 @@
 # the whole pack moves on to find some food (sheep or men)
 
 class AntWolf&lt;AntAnimal
-	attr_accessor :leader,:mypack
+  attr_accessor :leader,:mypack
 
-	def initialize(map)
-		super
-		setProvide(&quot;wolf&quot;,true)
-		setProvide(&quot;wolf_leader&quot;,true)
-		setSpeed 3
-		@lastBirth=0
-		@foodAdd=0
-		@mypack=[]
-		@leader=nil
-		
-		setMesh
+  def initialize(map)
+    super
+    setProvide(&quot;wolf&quot;,true)
+    setProvide(&quot;wolf_leader&quot;,true)
+    setSpeed 3
+    @lastBirth=0
+    @foodAdd=0
+    @mypack=[]
+    @leader=nil
+    
+    setMesh
 
-		resource.set(&quot;food&quot;,1)
-		@job=:resting
-		setHunger(0.01)
-		setMode(&quot;resting&quot;)
-	end
-	def eventNoJob
-		eventJobFinished
-	end
-	def eventJobFinished
-		super
+    resource.set(&quot;food&quot;,1)
+    @job=:resting
+    setHunger(0.01)
+    setMode(&quot;resting&quot;)
+  end
+  def eventNoJob
+    eventJobFinished
+  end
+  def eventJobFinished
+    super
 
-		if @dead
-			newRestJob(30)
-			if @alreadyDead
-				getMap.removeEntity(self)
-			end
-			@alreadyDead=true
-	
-			return
-		end
+    if @dead
+      newRestJob(30)
+      if @alreadyDead
+        getMap.removeEntity(self)
+      end
+      @alreadyDead=true
+  
+      return
+    end
 
-		if getFood&lt;=0
-			eventDie
-			return
-		end
+    if getFood&lt;=0
+      eventDie
+      return
+    end
 
-		# BIRTHRATE is here:
-		if @lastBirth&gt;40 then
-			# make child
-			puts &quot;A WOLF IS BORN&quot;
-			wolf=AntWolf.new
-			wolf.setPos(getPos2D)
-			getMap.insertEntity(wolf)
-			#getMap.endChange
-			newRestJob(2)
-			@lastBirth=-getRand*10
-		else
-			checkPackMerge
-			if @leader
-				assignJob(self)
-			else
-				decideWhatsToDo
-			end
-		end
+    # BIRTHRATE is here:
+    if @lastBirth&gt;40 then
+      # make child
+      puts &quot;A WOLF IS BORN&quot;
+      wolf=AntWolf.new
+      wolf.setPos(getPos2D)
+      getMap.insertEntity(wolf)
+      #getMap.endChange
+      newRestJob(2)
+      @lastBirth=-getRand*10
+    else
+      checkPackMerge
+      if @leader
+        assignJob(self)
+      else
+        decideWhatsToDo
+      end
+    end
 # 
-# 		elsif rand&lt;0.5 then
-# 			newMoveJob(0,getTargetPos,0)
-# 			setMeshState(&quot;go&quot;)
-# 		else
-# 			newRestJob(3)
-# 			setMeshState(&quot;eat&quot;)
-# 			playSound(&quot;wolf&quot;)
-# 		end
+#       newMoveJob(0,getTargetPos,0)
+#       setMeshState(&quot;go&quot;)
+#     else
+#       newRestJob(3)
+#       setMeshState(&quot;eat&quot;)
+#       playSound(&quot;wolf&quot;)
+#     end
+    @foodAdd+=1
+    #puts &quot;FOOOOOD #{@foodAdd}&quot;
+    if @foodAdd&gt;3 and resource.get(&quot;food&quot;)&lt;10
+      #puts &quot;RESOURCE: #{resource.get(&quot;food&quot;)}&quot;
+      resource.add(&quot;food&quot;,1)
+      #puts &quot;RESOURCE: #{resource.get(&quot;food&quot;)}&quot;
+      @foodAdd=0
+    end
 
-		@foodAdd+=1
-		#puts &quot;FOOOOOD #{@foodAdd}&quot;
-		if @foodAdd&gt;3 and resource.get(&quot;food&quot;)&lt;10
-			#puts &quot;RESOURCE: #{resource.get(&quot;food&quot;)}&quot;
-			resource.add(&quot;food&quot;,1)
-			#puts &quot;RESOURCE: #{resource.get(&quot;food&quot;)}&quot;
-			@foodAdd=0
-		end
+    @lastBirth+=1
+  end
 
-		@lastBirth+=1
-	end
+  def checkPackMerge
+    # find next leader
+    setProvide(&quot;wolf_leader&quot;,false)
 
-	def checkPackMerge
-		# find next leader
-		setProvide(&quot;wolf_leader&quot;,false)
+    tent=getMap.getNext(self,&quot;wolf_leader&quot;)
+    if tent
+      if (tent.getPos2D-getPos2D).length&lt;10
+        if not tent.inPack(self)
+          # simple take me as leader
+          tent.setLeader(self)
+        end
+      end
+    end
+  end
 
-		tent=getMap.getNext(self,&quot;wolf_leader&quot;)
-		if tent
-			if (tent.getPos2D-getPos2D).length&lt;10
-				if not tent.inPack(self)
-					# simple take me as leader
-					tent.setLeader(self)
-				end
-			end
-		end
-	end
+  def assignLeader(pack)
+    oldpack=@mypack.dup
+    @mypack+=pack
+    @mypack.uniq!
+    @leader=nil
+    @mypack.delete(self)
+    if @mypack.length!=oldpack.length
+      @mypack.each{|w|w.setLeaderDirect(self)}
+    end
+    setProvide(&quot;wolf_leader&quot;,true)
+  end
 
-	def assignLeader(pack)
-		oldpack=@mypack.dup
-		@mypack+=pack
-		@mypack.uniq!
-		@leader=nil
-		@mypack.delete(self)
-		if @mypack.length!=oldpack.length
-			@mypack.each{|w|w.setLeaderDirect(self)}
-		end
-		setProvide(&quot;wolf_leader&quot;,true)
-	end
+  def inPack(wolf)
+    @mypack.member?(wolf)
+  end
+    
 
-	def inPack(wolf)
-		@mypack.member?(wolf)
-	end
-		
+  def setLeader(leader)
+    leader.assignLeader(@mypack+[self])
+    setLeaderDirect(leader)
+  end
 
-	def setLeader(leader)
-		leader.assignLeader(@mypack+[self])
-		setLeaderDirect(leader)
-	end
+  def setLeaderDirect(leader)
+    @mypack=[]
+    @leader=leader
+    setProvide(&quot;wolf_leader&quot;,false)
+  end
+  
+  def decideWhatsToDo
+    if @job==:resting
+      if getFood&gt;0.5
+        @job=:resting
+      else
+        puts &quot;GETTING NEW SHEEP&quot;
+        @sheep=getMap.getNext(self,&quot;sheep&quot;)
+        if @sheep
+          @job=:killsheep
+        else
+          @job=:resting
+        end
+      end
+    
+      assignJobToAll
+    else
+      assignJob(self)
+    end
+  end
 
-	def setLeaderDirect(leader)
-		@mypack=[]
-		@leader=leader
-		setProvide(&quot;wolf_leader&quot;,false)
-	end
-	
-	def decideWhatsToDo
-		if @job==:resting
-			if getFood&gt;0.5
-				@job=:resting
-			else
-				puts &quot;GETTING NEW SHEEP&quot;
-				@sheep=getMap.getNext(self,&quot;sheep&quot;)
-				if @sheep
-					@job=:killsheep
-				else
-					@job=:resting
-				end
-			end
-		
-			assignJobToAll
-		else
-			assignJob(self)
-		end
-	end
+  def assignJobToAll
+    all=@mypack+[self]
+    all.each{|w|assignJob(w)}
+  end
 
-	def assignJobToAll
-		all=@mypack+[self]
-		all.each{|w|assignJob(w)}
-	end
+  def assignJob(wolf)
+    case @job
+      when :resting
+        wolf.newRestJob(4)
+        wolf.setMode(&quot;resting&quot;)
+      when :killsheep
+        if @sheep
+          puts &quot;KILLSHEEP #{@sheep} #{self}&quot;
+          if (@sheep.getPos2D-wolf.getPos2D).length&gt;0.5
+            wolf.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at sheep.getPos2D</A>,0)
+          else
+            @sheep.eventDie  
+            if @leader
+              @leader.shareFood
+            else
+              shareFood
+            end
+          end
+        end
+    end
+  end
 
-	def assignJob(wolf)
-		case @job
-			when :resting
-				wolf.newRestJob(4)
-				wolf.setMode(&quot;resting&quot;)
-			when :killsheep
-				if @sheep
-					puts &quot;KILLSHEEP #{@sheep} #{self}&quot;
-					if (@sheep.getPos2D-wolf.getPos2D).length&gt;0.5
-						wolf.newMoveJob(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0, at sheep.getPos2D</A>,0)
-					else
-						@sheep.eventDie	
-						if @leader
-							@leader.shareFood
-						else
-							shareFood
-						end
-					end
-				end
-		end
-	end
+  def shareFood
+    ([self]<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">+ at mypack</A>).each{|w|w.incFood(1.5)}
+    @job=:resting
+    decideWhatsToDo
+  end
+  
+  def getTargetPos
+    p=getPos2D
+    t=p
+    ok=true
+    radius=4
+    # assure that sheep doesn't walk into water
+    while getMap.getHeight(t.x,t.y)&lt;0.1 or ok do
+      d=AGVector2.new(getRand-0.5,getRand-0.5).normalized*radius
+      t=p+d
+      t=getMap.truncPos(t)
+      ok=false
+    end 
+    return t
+  end
+  def getMen
+    (@mypack+[self]).uniq.dup
+  end
+  def menCount
+    getMen.length
+  end
+  def setMeshState(s)
+    #getFirstMesh.setAnimation(s)
+  end
+  def getName
+    return &quot;Corpse&quot; if @dead
+    return &quot;Wolfleader2&quot; if provides(&quot;wolf_leader&quot;)
+    return &quot;Wolfleader&quot; if @leader.nil?
+    &quot;Wolf&quot;
+  end
+  def eventDie
+    setMesh(:rip)
+    #setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/rip.ant2&quot;,0.3,&quot;data/textures/models/rip.png&quot;),AGVector4.new(0,0,0,0),0))
+    @dead=true
+    
+    newRestJob(1)
 
-	def shareFood
-		([self]<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">+ at mypack</A>).each{|w|w.incFood(1.5)}
-		@job=:resting
-		decideWhatsToDo
-	end
-	
-	def getTargetPos
-		p=getPos2D
-		t=p
-		ok=true
-		radius=4
-		# assure that sheep doesn't walk into water
-		while getMap.getHeight(t.x,t.y)&lt;0.1 or ok do
-			d=AGVector2.new(getRand-0.5,getRand-0.5).normalized*radius
-			t=p+d
-			t=getMap.truncPos(t)
-			ok=false
-		end 
-		return t
-	end
-	def getMen
-		(@mypack+[self]).uniq.dup
-	end
-	def menCount
-		getMen.length
-	end
-	def setMeshState(s)
-		#getFirstMesh.setAnimation(s)
-	end
-	def getName
-		return &quot;Corpse&quot; if @dead
-		return &quot;Wolfleader2&quot; if provides(&quot;wolf_leader&quot;)
-		return &quot;Wolfleader&quot; if @leader.nil?
-		&quot;Wolf&quot;
-	end
-	def eventDie
-		setMesh(:rip)
-		#setMesh(Mesh.new(getMap.getScene,getMeshData(&quot;data/models/rip.ant2&quot;,0.3,&quot;data/textures/models/rip.png&quot;),AGVector4.new(0,0,0,0),0))
-		@dead=true
-		
-		newRestJob(1)
-
-		if @leader.nil?
-			# choose new leader
-			if @mypack.length&gt;0
-				l=@mypack[0]
-				l.assignLeader(@mypack[1..-1])
-				@mypack=[]
-			end
-		end
-	end
+    if @leader.nil?
+      # choose new leader
+      if @mypack.length&gt;0
+        l=@mypack[0]
+        l.assignLeader(@mypack[1..-1])
+        @mypack=[]
+      end
+    end
+  end
 end

Modified: antargis/trunk/ruby/entities/ant_workshop.rb
===================================================================
--- antargis/trunk/ruby/entities/ant_workshop.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/entities/ant_workshop.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,100 +1,100 @@
 # This is a workshop. Residents will produce tools and fetch needed resources
 # which are wood and stone. Apart from this they'll try to gather food so they won't starve
 class AntWorkshop&lt;AntHouse
-	def initialize(map)
-		super
-		setProvide(&quot;workshop&quot;,true)
-		setProvide(&quot;tool&quot;,true)
-		@lastBirth=0
-		setDirection(-50)
-		@smoke=0
-	end
+  def initialize(map)
+    super
+    setProvide(&quot;workshop&quot;,true)
+    setProvide(&quot;tool&quot;,true)
+    @lastBirth=0
+    setDirection(-50)
+    @smoke=0
+  end
 
-	# increase smoke by one
-	def incSmoke
-		@smoke+=1
-		checkSmoke
-	end
-	def decSmoke
-		@smoke-=1
-		checkSmoke
-	end
+  # increase smoke by one
+  def incSmoke
+    @smoke+=1
+    checkSmoke
+  end
+  def decSmoke
+    @smoke-=1
+    checkSmoke
+  end
 
-	# assign my men a job.
-	# this is simple tool-production in case there is no defend-job
-	# * e - entity (= one of my men)
-	def assignJob(e)
-		if e.getMode==&quot;invent&quot;
-			produceOneTool
-			e.setMode(&quot;any&quot;)
-			decSmoke
-		end
-		if not @job
-			if allThereForTool &amp;&amp; notEnoughTools &amp;&amp; atHome(e)
-				e.setMode(&quot;invent&quot;)
-				e.newRestJob(10)
-				startToolProduction
-				return
-			end
-		end
-		super(e)
-	end
-	# sets up the mesh and adds a smoke-particle engine, which is disabled at first
-	def setupMesh
-		return if getScene.nil?
-		setMesh
-		p=AGVector3.new(-1.3,-1.2,2.2)
-		if opengl
-			addMesh(@smokeMesh=AntParticle.new(getMap.getScene,5),p)
-			checkSmoke
-		end
-	end
+  # assign my men a job.
+  # this is simple tool-production in case there is no defend-job
+  # * e - entity (= one of my men)
+  def assignJob(e)
+    if e.getMode==&quot;invent&quot;
+      produceOneTool
+      e.setMode(&quot;any&quot;)
+      decSmoke
+    end
+    if not @job
+      if allThereForTool &amp;&amp; notEnoughTools &amp;&amp; atHome(e)
+        e.setMode(&quot;invent&quot;)
+        e.newRestJob(10)
+        startToolProduction
+        return
+      end
+    end
+    super(e)
+  end
+  # sets up the mesh and adds a smoke-particle engine, which is disabled at first
+  def setupMesh
+    return if getScene.nil?
+    setMesh
+    p=AGVector3.new(-1.3,-1.2,2.2)
+    if opengl
+      addMesh(@smokeMesh=AntParticle.new(getMap.getScene,5),p)
+      checkSmoke
+    end
+  end
 protected
-	
-	# start tool production (=remove 1 wood and 1 stone)
-	def startToolProduction
-		resource.sub(&quot;wood&quot;,1)
-		resource.sub(&quot;stone&quot;,1)
-		playSound(&quot;construct&quot;)
-		incSmoke
-	end
-	
+  
+  # start tool production (=remove 1 wood and 1 stone)
+  def startToolProduction
+    resource.sub(&quot;wood&quot;,1)
+    resource.sub(&quot;stone&quot;,1)
+    playSound(&quot;construct&quot;)
+    incSmoke
+  end
+  
 
-	# produce one tool
-	def produceOneTool
-		resource.add(&quot;tool&quot;,1)
-	end
-	
-	# check if there are enough resources to build a tool (wood&gt;=1 &amp;&amp; stone=&gt;1)
-	def allThereForTool
-		resource.get(&quot;wood&quot;)&gt;=1 &amp;&amp; resource.get(&quot;stone&quot;)&gt;=1
-	end
-	
-	# check if there are enough tools (10)
-	def notEnoughTools
-		resource.get(&quot;tool&quot;)&lt;10
-	end
+  # produce one tool
+  def produceOneTool
+    resource.add(&quot;tool&quot;,1)
+  end
+  
+  # check if there are enough resources to build a tool (wood&gt;=1 &amp;&amp; stone=&gt;1)
+  def allThereForTool
+    resource.get(&quot;wood&quot;)&gt;=1 &amp;&amp; resource.get(&quot;stone&quot;)&gt;=1
+  end
+  
+  # check if there are enough tools (10)
+  def notEnoughTools
+    resource.get(&quot;tool&quot;)&lt;10
+  end
 
-	# returns my name &quot;workshop&quot;
-	def houseType
-		&quot;workshop&quot;
-	end
+  # returns my name &quot;workshop&quot;
+  def houseType
+    &quot;workshop&quot;
+  end
 
-	def neededStock
-		{&quot;wood&quot;=&gt;10,&quot;stone&quot;=&gt;10,&quot;food&quot;=&gt;10}
-	end
-	
+  def neededStock
+    {&quot;wood&quot;=&gt;10,&quot;stone&quot;=&gt;10,&quot;food&quot;=&gt;10}
+  end
+  
 
 private
-	# checks if smoke should be displayed
-	def checkSmoke
-		return if getScene.nil?
-		if @smokeMesh
-			if @smoke
-				@smokeMesh.setEnabled((@smoke&gt;0))
-			else
-				@smokeMesh.setEnabled(false)
-			end
-		end
-	end
-end
\ No newline at end of file
+  # checks if smoke should be displayed
+  def checkSmoke
+    return if getScene.nil?
+    if @smokeMesh
+      if @smoke
+        @smokeMesh.setEnabled((@smoke&gt;0))
+      else
+        @smokeMesh.setEnabled(false)
+      end
+    end
+  end
+end

Modified: antargis/trunk/ruby/entities/entity.rb
===================================================================
--- antargis/trunk/ruby/entities/entity.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/entities/entity.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,312 +7,312 @@
 # AntRubyEntity slighty enhances the functionality already provided by AntEntity.
 # This should be used for all the entity-types.
 class AntRubyEntity&lt;AntEntity
-	attr_accessor :birthday
-	attr_reader :uid, :selected
+  attr_accessor :birthday
+  attr_reader :uid, :selected
 
-	# get the 3d-scene-object out of the Map-object
-	def getScene
-		getMap.getScene
-	end
+  # get the 3d-scene-object out of the Map-object
+  def getScene
+    getMap.getScene
+  end
 
-	# create a new entity at the position *p*
-	# set some default settings
-	# get a unique ID
-	# loading must be done externally in loadXML !
-	def initialize(map)
-		@hovered=@selected=false
-		assert{map.is_a?(AntMap)}
-		super(map)
-		@xmlProps={}
-		@birthday=getMap.getTime
-		@mode=&quot;&quot;
-		@handlers={}
-		self.learnAmount=0.05
-	
-		@uid=getMap.getUniqueID
-		setHunger(0) # general entities have no hunger
-	end
+  # create a new entity at the position *p*
+  # set some default settings
+  # get a unique ID
+  # loading must be done externally in loadXML !
+  def initialize(map)
+    @hovered=@selected=false
+    assert{map.is_a?(AntMap)}
+    super(map)
+    @xmlProps={}
+    @birthday=getMap.getTime
+    @mode=&quot;&quot;
+    @handlers={}
+    self.learnAmount=0.05
+  
+    @uid=getMap.getUniqueID
+    setHunger(0) # general entities have no hunger
+  end
 
 
-	# play a sound identified by +name+. Sounds of this type shouldn't called when they were only called
-	# +minDiff+ (or less) seconds before. Note that the sound is played at the place where this entity is placed.
-	# So it's not hearable far away from it.
-	def playSound(name,minDiff=0.5)
-		scene=getScene
-		d=((scene.getCamera.dim2-getPos2D).length-INNER_VOL_SIZE)
-		vol=1
-		if d&gt;0
-			vol=[(OUTER_VOL_SIZE-d)/OUTER_VOL_SIZE,0].max
-		end
-		AntSound.playSoundGlobal(name,vol,minDiff)
-	end
+  # play a sound identified by +name+. Sounds of this type shouldn't called when they were only called
+  # +minDiff+ (or less) seconds before. Note that the sound is played at the place where this entity is placed.
+  # So it's not hearable far away from it.
+  def playSound(name,minDiff=0.5)
+    scene=getScene
+    d=((scene.getCamera.dim2-getPos2D).length-INNER_VOL_SIZE)
+    vol=1
+    if d&gt;0
+      vol=[(OUTER_VOL_SIZE-d)/OUTER_VOL_SIZE,0].max
+    end
+    AntSound.playSoundGlobal(name,vol,minDiff)
+  end
 
-	
-	# :section: Editing
+  
+  # :section: Editing
 
-	# Within the editor you can change additional properties, e.g. count of men for a hero. This functions are used for this.
-	def setXMLProp(n,v)
-		@xmlProps[n]=v
-	end
-	def getXMLProp(n)
-		if @xmlProps[n]==nil
-			return &quot;&quot;
-		else
-			return @xmlProps[n]
-		end
-	end
+  # Within the editor you can change additional properties, e.g. count of men for a hero. This functions are used for this.
+  def setXMLProp(n,v)
+    @xmlProps[n]=v
+  end
+  def getXMLProp(n)
+    if @xmlProps[n]==nil
+      return &quot;&quot;
+    else
+      return @xmlProps[n]
+    end
+  end
 
-	# :section: XML loading/saving
+  # :section: XML loading/saving
 
-	def preloadXML(node)
-		if node.get(&quot;birthday&quot;)!=&quot;&quot;
-			@birthday=node.get(&quot;birthday&quot;).to_f
-		end
-		@mode=node.get(&quot;mode&quot;)
-		if node.get(&quot;uid&quot;)!=&quot;&quot;
-			@uid=node.get(&quot;uid&quot;).to_i
-			getMap.checkUID(@uid)
-		end
-		setName(node.get(&quot;name&quot;))
-	end
+  def preloadXML(node)
+    if node.get(&quot;birthday&quot;)!=&quot;&quot;
+      @birthday=node.get(&quot;birthday&quot;).to_f
+    end
+    @mode=node.get(&quot;mode&quot;)
+    if node.get(&quot;uid&quot;)!=&quot;&quot;
+      @uid=node.get(&quot;uid&quot;).to_i
+      getMap.checkUID(@uid)
+    end
+    setName(node.get(&quot;name&quot;))
+  end
 
-	def loadXML(node)
-		super
-	end
-	def saveXML(node)
-		super(node)
-		@xmlProps.each{|n,v|
-			node.set(n,v)
-		}
-		if @birthday
-			node.set(&quot;birthday&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at birthday.to_s</A>)
-		end
-		node.set(&quot;mode&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at mode</A>)
-		node.set(&quot;uid&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at uid.to_s</A>)
-	end
-	def getDescription
-		_(&quot;This is an entity - no more info here.&quot;)
-	end
+  def loadXML(node)
+    super
+  end
+  def saveXML(node)
+    super(node)
+    @xmlProps.each{|n,v|
+      node.set(n,v)
+    }
+    if @birthday
+      node.set(&quot;birthday&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at birthday.to_s</A>)
+    end
+    node.set(&quot;mode&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at mode</A>)
+    node.set(&quot;uid&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at uid.to_s</A>)
+  end
+  def getDescription
+    _(&quot;This is an entity - no more info here.&quot;)
+  end
 
-	# :section: miscellanous
+  # :section: miscellanous
 
-	# simple comparison operator, so that ents can be distinguished
-	# for what is this needed ???
-	def &lt;=&gt;(e)
-		to_s&lt;=&gt;e.to_s
-	end
+  # simple comparison operator, so that ents can be distinguished
+  # for what is this needed ???
+  def &lt;=&gt;(e)
+    to_s&lt;=&gt;e.to_s
+  end
 
-	def menCount
-		0
-	end
-	def getPlayer
-		nil
-	end
-	def fightTarget
-		@fightTarget
-	end
-	def getRand
-		if false
-			# FIXME - implement me (network code)
-			#rand
-			@mrand||=AGRandomizer.new(&quot;&quot;)
-			val=@mrand.randFloat(1)
-	
-			return val
-		end
-		agRand(1.0)
-	end
+  def menCount
+    0
+  end
+  def getPlayer
+    nil
+  end
+  def fightTarget
+    @fightTarget
+  end
+  def getRand
+    if false
+      # FIXME - implement me (network code)
+      #rand
+      @mrand||=AGRandomizer.new(&quot;&quot;)
+      val=@mrand.randFloat(1)
+  
+      return val
+    end
+    agRand(1.0)
+  end
 
-	def setStrength(v)
-		super
-		setMoraleStrength(v*2)
-	end
+  def setStrength(v)
+    super
+    setMoraleStrength(v*2)
+  end
 
-	# get the age of this entity - computed from @birthday
-	def age
-		((<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">getMap.getTime- at birthday</A>).to_f/YEAR).to_i
-	end
-	# @birthday will be set according to the current date (get it by calling getMap.getTime)
-	def age=(years)
-		@birthday=getMap.getTime-years*YEAR
-	end
-	def getMen
-		[]
-	end
+  # get the age of this entity - computed from @birthday
+  def age
+    ((<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">getMap.getTime- at birthday</A>).to_f/YEAR).to_i
+  end
+  # @birthday will be set according to the current date (get it by calling getMap.getTime)
+  def age=(years)
+    @birthday=getMap.getTime-years*YEAR
+  end
+  def getMen
+    []
+  end
 
-	
-	def setMode(mode)
-		@mode=mode
-	end
-	def getMode
-		@mode
-	end
+  
+  def setMode(mode)
+    @mode=mode
+  end
+  def getMode
+    @mode
+  end
 
 
 
-	def isOnOpenWater(p=nil)
-		if (not p)
-			p=getPos2D
-		end
-		if (not p.is_a?(AGVector2))
-			p=p.getPos2D
-		end
-		assert{p.is_a?(AGVector2)}
-		getMap.getPos(p).z&lt;-0.2
-	end
-	def isOnWater
-		getMap.getPos(getPos2D).z&lt;0
-	end
+  def isOnOpenWater(p=nil)
+    if (not p)
+      p=getPos2D
+    end
+    if (not p.is_a?(AGVector2))
+      p=p.getPos2D
+    end
+    assert{p.is_a?(AGVector2)}
+    getMap.getPos(p).z&lt;-0.2
+  end
+  def isOnWater
+    getMap.getPos(getPos2D).z&lt;0
+  end
 
-	# give name under which this entity is stored in xml. It's generated from the classname. The first character is downcased.
-	# The rest is camel-case as usual.
-	# For instace: AntShop =&gt; antShop
-	def xmlName
-		xml=self.class.to_s
-		xml=xml[0..0].downcase+xml[1..1000]
-		return xml
-	end
+  # give name under which this entity is stored in xml. It's generated from the classname. The first character is downcased.
+  # The rest is camel-case as usual.
+  # For instace: AntShop =&gt; antShop
+  def xmlName
+    xml=self.class.to_s
+    xml=xml[0..0].downcase+xml[1..1000]
+    return xml
+  end
 
-	def addHandler(eventName,&amp;block)
-		@handlers[eventName]||=[]
-		@handlers[eventName].push(block)
-	end
+  def addHandler(eventName,&amp;block)
+    @handlers[eventName]||=[]
+    @handlers[eventName].push(block)
+  end
 
-	def doEvent(name)
-		if @handlers[name]
-			@handlers[name].each{|b|
-				b.call
-			}
-		end
-	end
+  def doEvent(name)
+    if @handlers[name]
+      @handlers[name].each{|b|
+        b.call
+      }
+    end
+  end
 
-	# :section: job-handling
-	# These functions add support for event-Handling within Entities' jobs. This is (will be) used for
-	# scripting and AI.
-	#	
-	# FIXME: THis should be moved somewhere else (?)
-	#
-	# For more information on scripting link:files/ruby/scripting/README.html
+  # :section: job-handling
+  # These functions add support for event-Handling within Entities' jobs. This is (will be) used for
+  # scripting and AI.
+  #  
+  # FIXME: THis should be moved somewhere else (?)
+  #
+  # For more information on scripting link:files/ruby/scripting/README.html
 
-	def newFightJob(p,target,distance)
-		@fightTarget=target
-		super
-		doEvent(:eventNewFightJob)
-	end
-	def newRestJob(t,working=false)
-		super
-		doEvent(:eventNewRestJob)
-	end
+  def newFightJob(p,target,distance)
+    @fightTarget=target
+    super
+    doEvent(:eventNewFightJob)
+  end
+  def newRestJob(t,working=false)
+    super
+    doEvent(:eventNewRestJob)
+  end
 
-	# :section eventHandling
-	def eventNoJob
-		super
-		doEvent(:eventNoJob)
-	end
-	def eventJobFinished
-		super
-		doEvent(:eventJobFinished)
-	end
+  # :section eventHandling
+  def eventNoJob
+    super
+    doEvent(:eventNoJob)
+  end
+  def eventJobFinished
+    super
+    doEvent(:eventJobFinished)
+  end
 
-	def experienceFull
-		super
-		self.experience=1
-	end
+  def experienceFull
+    super
+    self.experience=1
+  end
 
 
-	# :section: status-information
+  # :section: status-information
 
-	# an event-handler for resources being changed. In this case a possible view on the inventory is updated
-	def resourceChanged	
-		super
-		begin
-			AntInventory.update(self)
-		rescue NameError
-		end
-	end
+  # an event-handler for resources being changed. In this case a possible view on the inventory is updated
+  def resourceChanged  
+    super
+    begin
+      AntInventory.update(self)
+    rescue NameError
+    end
+  end
 
-	# is this entity under attack - here this is always false, because it doesn't make sense for all entities
-	def underAttack
-		false
-	end
+  # is this entity under attack - here this is always false, because it doesn't make sense for all entities
+  def underAttack
+    false
+  end
 
-	# :section: state-changes
+  # :section: state-changes
 
-	# set a mesh for this entity - have a look at AntModels for more information on how this works
-	# * normally you give a subtype or nothing at all to this function and AntModels will take care of the right
-	#   mesh. *sym* override the current entities type.
-	# * you can pipe in a SceneNode-based object through *subtype* though this is no good !
-	def setMesh(subtype=&quot;&quot;,sym=nil)
-		return if getMap.getScene.nil?
-		if subtype.is_a?(SceneNode)
-			raise  &quot;THIS SHOULD NOT BE USED ANY LONGER: setMesh(realMesh) !!!!!!!!!!!!&quot;
-			super(subtype) # wrapper
-			setupRing
-			return subtype
-		end
-		@map={:AntSack=&gt;:sack}
-		t=self.class.to_s
-		t=t.gsub(&quot;Ant&quot;,&quot;&quot;).downcase
-		t=t.to_sym
-		if sym
-			t=sym
-		end
+  # set a mesh for this entity - have a look at AntModels for more information on how this works
+  # * normally you give a subtype or nothing at all to this function and AntModels will take care of the right
+  #   mesh. *sym* override the current entities type.
+  # * you can pipe in a SceneNode-based object through *subtype* though this is no good !
+  def setMesh(subtype=&quot;&quot;,sym=nil)
+    return if getMap.getScene.nil?
+    if subtype.is_a?(SceneNode)
+      raise  &quot;THIS SHOULD NOT BE USED ANY LONGER: setMesh(realMesh) !!!!!!!!!!!!&quot;
+      super(subtype) # wrapper
+      setupRing
+      return subtype
+    end
+    @map={:AntSack=&gt;:sack}
+    t=self.class.to_s
+    t=t.gsub(&quot;Ant&quot;,&quot;&quot;).downcase
+    t=t.to_sym
+    if sym
+      t=sym
+    end
     mesh=AntModels.createModel(self,t,subtype)
     #print &quot;MESH for #{self}:#{mesh} &quot;
     #pp mesh
-		super(mesh)
+    super(mesh)
     #pp getMesh.class,getMesh
-		setupRing
-		return mesh
-	end
+    setupRing
+    return mesh
+  end
 
 
 
-	# :section: hovering/selection display with ring
-	def hovered=(s)
-		@hovered=s
-		updateRingColor
-	end
-	def selected=(s)
-		@selected=s
-		updateRingColor
-	end
+  # :section: hovering/selection display with ring
+  def hovered=(s)
+    @hovered=s
+    updateRingColor
+  end
+  def selected=(s)
+    @selected=s
+    updateRingColor
+  end
 
-	def getRing
-		makeRingMesh
-	end
+  def getRing
+    makeRingMesh
+  end
 
-	def setupRing
-		@ring=getRing
-		return if @ring.nil?
-		if @selected
-			#f6c108
-			@ring.setRingColor(AGVector4.new(1,0.7,0.1,0.8))
-		else
-			@ring.setRingColor(AGVector4.new(0.7,0.7,1,0.8))
-		end
-		addMesh(@ring,AGVector3.new(0,0,0))
-		#@ring.setVisible(false)
-		updateRingColor
-	end
+  def setupRing
+    @ring=getRing
+    return if @ring.nil?
+    if @selected
+      #f6c108
+      @ring.setRingColor(AGVector4.new(1,0.7,0.1,0.8))
+    else
+      @ring.setRingColor(AGVector4.new(0.7,0.7,1,0.8))
+    end
+    addMesh(@ring,AGVector3.new(0,0,0))
+    #@ring.setVisible(false)
+    updateRingColor
+  end
 
 private
-	def updateRingColor
-		setupRing if @ring.nil?
-		@ring.setVisible((@hovered or @selected))
-		if @hovered and not @selected
-			@ring.setRingColor(AGVector4.new(0.7,0.7,1,0.8))
-		elsif @selected
-			@ring.setRingColor(AGVector4.new(1,0.7,0.1,0.8))
-		end
-	end
+  def updateRingColor
+    setupRing if @ring.nil?
+    @ring.setVisible((@hovered or @selected))
+    if @hovered and not @selected
+      @ring.setRingColor(AGVector4.new(0.7,0.7,1,0.8))
+    elsif @selected
+      @ring.setRingColor(AGVector4.new(1,0.7,0.1,0.8))
+    end
+  end
 public
 
-	# :section: deprecated
+  # :section: deprecated
 
 
-	# FIXME: remove this - this is a backward-compability function 
-	def get
-		self
-	end
+  # FIXME: remove this - this is a backward-compability function 
+  def get
+    self
+  end
 end

Modified: antargis/trunk/ruby/entities/spec/entities.rb
===================================================================
--- antargis/trunk/ruby/entities/spec/entities.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/entities/spec/entities.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -4,26 +4,26 @@
 require 'ruby/map.rb'
 
 class AntRubyEntity
-	alias :resourceChangedOld :resourceChanged
-	def resourceChanged
-		$ok=true
-	end
+  alias :resourceChangedOld :resourceChanged
+  def resourceChanged
+    $ok=true
+  end
 end
 
 (AntRubyEntity.descendants-[AntRubyEntity]).each{|aClass|
-	describe aClass do
-		it &quot;(#{aClass}) should call AntRubyEntity.resourceChanged when resourceChanges is called on a descendant&quot; do
-			#puts &quot;TESTING #{aClass}&quot;
-			$ok=false
-			app=GLApp.new(800,600)
-			scene=app.getScene
-			map=AntRubyMap.new(app,scene,32,32)
-			object=aClass.new(map)
-			object.setPos(AGVector2.new(1,1))
-			object.resourceChanged
-			$ok.should == true
-			
-		end
-		it &quot;should run without a scene-object defined&quot;
-	end
-}
\ No newline at end of file
+  describe aClass do
+    it &quot;(#{aClass}) should call AntRubyEntity.resourceChanged when resourceChanges is called on a descendant&quot; do
+      #puts &quot;TESTING #{aClass}&quot;
+      $ok=false
+      app=GLApp.new(800,600)
+      scene=app.getScene
+      map=AntRubyMap.new(app,scene,32,32)
+      object=aClass.new(map)
+      object.setPos(AGVector2.new(1,1))
+      object.resourceChanged
+      $ok.should == true
+      
+    end
+    it &quot;should run without a scene-object defined&quot;
+  end
+}

Modified: antargis/trunk/ruby/game_result.rb
===================================================================
--- antargis/trunk/ruby/game_result.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/game_result.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,6 +1,6 @@
 class GameResult
-	attr_reader :won
-	def initialize(pWon=&quot;canceled&quot;)
-		@won=pWon
-	end
-end
\ No newline at end of file
+  attr_reader :won
+  def initialize(pWon=&quot;canceled&quot;)
+    @won=pWon
+  end
+end

Modified: antargis/trunk/ruby/gen_tree.rb
===================================================================
--- antargis/trunk/ruby/gen_tree.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/gen_tree.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,67 +1,67 @@
 
 def genTree
-	f=loadFile(&quot;data/models/tree4.ant2&quot;)
-	opt=loadFromText(f,true,0.5)
-	
-		r=4
-		y0=11
-		y1=12
-		stepy=0.7
-		for k in 0..9
-			r=[1.3,1.3,1.5,2,2.5,3,3.5,4,4.3,4.5,4.5][k]
-			if k&lt;3
-				stepy=0.5
-			else
-				stepy=1
-			end
-		
-			segs=8
-			for i in 0..(segs-1)
-				a0=2*Math::PI/segs*i
-				a1=2*Math::PI/segs*(i+1)
-			
-				mv0=MeshVertex.new
-				mv1=MeshVertex.new
-				mv2=MeshVertex.new
-			
-				mv0.c=AGVector4.new(1,1,1,1)
-				mv1.c=AGVector4.new(1,1,1,1)
-				mv2.c=AGVector4.new(1,1,1,1)
-				
-				mv0.v=AGVector4.new(Math::cos(a0)*r,Math::sin(a0)*r,y0,1)
-				mv1.v=AGVector4.new(Math::cos(a1)*r,Math::sin(a1)*r,y0,1)
-				mv2.v=AGVector4.new(0,0,y1,1)
-				
-				n=(mv0.v-mv1.v)%(mv2.v-mv1.v)
-			
-				n=n.dim3
-				n=-n.normalized	
-			
-				mv0.n=n
-				mv1.n=n
-				mv2.n=n
-				
-				middle=AGVector2.new(0.5,0.75)
-				
-				mv0.t=AGVector2.new(Math::cos(a0+k),Math::sin(a0+k)*0.5)*0.5+middle
-				mv1.t=AGVector2.new(Math::cos(a1+k),Math::sin(a1+k)*0.5)*0.5+middle
-				mv2.t=middle
-				
-				# front
-				opt.add(mv2)
-				opt.add(mv1)
-				opt.add(mv0)		
-			end
-			y0-=stepy
-			y1-=stepy
-		end
-	
-	va=opt.getArray
-	data=MeshData.new(va,&quot;data/textures/models/fir5.png&quot;,true)
-	data.setTransparent(true)
-	data.save(&quot;treetest2.ant2&quot;)
-	puts data.getTriangles
-	data
+  f=loadFile(&quot;data/models/tree4.ant2&quot;)
+  opt=loadFromText(f,true,0.5)
+  
+    r=4
+    y0=11
+    y1=12
+    stepy=0.7
+    for k in 0..9
+      r=[1.3,1.3,1.5,2,2.5,3,3.5,4,4.3,4.5,4.5][k]
+      if k&lt;3
+        stepy=0.5
+      else
+        stepy=1
+      end
+    
+      segs=8
+      for i in 0..(segs-1)
+        a0=2*Math::PI/segs*i
+        a1=2*Math::PI/segs*(i+1)
+      
+        mv0=MeshVertex.new
+        mv1=MeshVertex.new
+        mv2=MeshVertex.new
+      
+        mv0.c=AGVector4.new(1,1,1,1)
+        mv1.c=AGVector4.new(1,1,1,1)
+        mv2.c=AGVector4.new(1,1,1,1)
+        
+        mv0.v=AGVector4.new(Math::cos(a0)*r,Math::sin(a0)*r,y0,1)
+        mv1.v=AGVector4.new(Math::cos(a1)*r,Math::sin(a1)*r,y0,1)
+        mv2.v=AGVector4.new(0,0,y1,1)
+        
+        n=(mv0.v-mv1.v)%(mv2.v-mv1.v)
+      
+        n=n.dim3
+        n=-n.normalized  
+      
+        mv0.n=n
+        mv1.n=n
+        mv2.n=n
+        
+        middle=AGVector2.new(0.5,0.75)
+        
+        mv0.t=AGVector2.new(Math::cos(a0+k),Math::sin(a0+k)*0.5)*0.5+middle
+        mv1.t=AGVector2.new(Math::cos(a1+k),Math::sin(a1+k)*0.5)*0.5+middle
+        mv2.t=middle
+        
+        # front
+        opt.add(mv2)
+        opt.add(mv1)
+        opt.add(mv0)    
+      end
+      y0-=stepy
+      y1-=stepy
+    end
+  
+  va=opt.getArray
+  data=MeshData.new(va,&quot;data/textures/models/fir5.png&quot;,true)
+  data.setTransparent(true)
+  data.save(&quot;treetest2.ant2&quot;)
+  puts data.getTriangles
+  data
 end
 
 

Modified: antargis/trunk/ruby/gui/ag_tools.rb
===================================================================
--- antargis/trunk/ruby/gui/ag_tools.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/gui/ag_tools.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -36,140 +36,140 @@
 # and also include this module into each class in which you want to use this :-)
 # this is not needed if you're using an AGWidget or AGApplication object
 module AGHandler
-	# clear all handlers
-	def clearHandlers
-		@handlers={}
-	end
-	# add Event Handler - this function should go into AGRubyApp
-	def addHandler(object,event,func)
-		if not defined? @handlers then
-			@handlers={}
-		end
-		if object.nil? then
-			raise &quot;AGHandler.addHandler: object does not exist!&quot;
-		else
-			object.send(event).connect(self)
-			hname=makeHandlerName(object,event)
-			#hname=object.getName+&quot;:&quot;+event.to_s
-			@handlers[hname]||=[]
-			@handlers[hname].push(func)
-		end
-	end
-	# event dispatcher
-	def signal(e)
-		@handlers||={}
-		mcaller=e.getCaller
-		evName=makeHandlerName(mcaller,e.getName)
-		#callerName=e.getCaller.getName
-		#evName=callerName+&quot;:&quot;+e.getName
-		#puts &quot;#{callerName} #{evName}&quot;
-		if @handlers.has_key?(evName) then
-			value=false
-			@handlers[evName].each{|handler|
-				m=method(handler)
-				if m.arity==1 || m.arity==-1
-					# ok
-					if self.send(handler,e)
-						value=true
-					end
-				elsif m.arity==0
-					if self.send(handler)
-						value=true
-					end
-				else
-					puts &quot;AR:&quot;,m.arity
-					raise &quot;SLOT is invalid! event:&quot;+evName+&quot; slotname:&quot;+handler.to_s+&quot; in class:&quot;+(self.class).to_s
-				end
-			}
-			return value
-		end
-		return super(e)
-	end
+  # clear all handlers
+  def clearHandlers
+    @handlers={}
+  end
+  # add Event Handler - this function should go into AGRubyApp
+  def addHandler(object,event,func)
+    if not defined? @handlers then
+      @handlers={}
+    end
+    if object.nil? then
+      raise &quot;AGHandler.addHandler: object does not exist!&quot;
+    else
+      object.send(event).connect(self)
+      hname=makeHandlerName(object,event)
+      #hname=object.getName+&quot;:&quot;+event.to_s
+      @handlers[hname]||=[]
+      @handlers[hname].push(func)
+    end
+  end
+  # event dispatcher
+  def signal(e)
+    @handlers||={}
+    mcaller=e.getCaller
+    evName=makeHandlerName(mcaller,e.getName)
+    #callerName=e.getCaller.getName
+    #evName=callerName+&quot;:&quot;+e.getName
+    #puts &quot;#{callerName} #{evName}&quot;
+    if @handlers.has_key?(evName) then
+      value=false
+      @handlers[evName].each{|handler|
+        m=method(handler)
+        if m.arity==1 || m.arity==-1
+          # ok
+          if self.send(handler,e)
+            value=true
+          end
+        elsif m.arity==0
+          if self.send(handler)
+            value=true
+          end
+        else
+          puts &quot;AR:&quot;,m.arity
+          raise &quot;SLOT is invalid! event:&quot;+evName+&quot; slotname:&quot;+handler.to_s+&quot; in class:&quot;+(self.class).to_s
+        end
+      }
+      return value
+    end
+    return super(e)
+  end
 
-	private
-	def makeHandlerName(object,event)
-		#if object.respond_to?(:getName)
-		#	return object.getName+&quot;:&quot;+event.to_s
-		#else
-			return object.object_id.to_s+&quot;:&quot;+event.to_s
-		#end
-	end
+  private
+  def makeHandlerName(object,event)
+    #if object.respond_to?(:getName)
+    #  return object.getName+&quot;:&quot;+event.to_s
+    #else
+      return object.object_id.to_s+&quot;:&quot;+event.to_s
+    #end
+  end
 end
 
 # this function adds a signal to the current object
 # you can call this with signalName(e) afterwards
 def addSignal(name)
-	eval &lt;&lt;EOT
+  eval &lt;&lt;EOT
 class #{self.class}
-	def #{name}(e=nil)
-		if e
-			e.setCaller(self)
-			return @#{name}.signal(e)
-		else
-			return @#{name}
-		end
-	end
+  def #{name}(e=nil)
+    if e
+      e.setCaller(self)
+      return @#{name}.signal(e)
+    else
+      return @#{name}
+    end
+  end
 end
 EOT
-	eval(&quot;@#{name}=AGSignal.new(self,'#{name}')\n&quot;)
+  eval(&quot;@#{name}=AGSignal.new(self,'#{name}')\n&quot;)
 end
 
 module Antargis
-	class AGApplication
-		include AGHandler
-	end
-	class AGWidget
-		include AGHandler
-	end
+  class AGApplication
+    include AGHandler
+  end
+  class AGWidget
+    include AGHandler
+  end
 end
 
 class Array
-	# extend Array-class with a shuffle function
-	def shuffle
-		sort{0.5 &lt;=&gt; rand}
-	end
+  # extend Array-class with a shuffle function
+  def shuffle
+    sort{0.5 &lt;=&gt; rand}
+  end
 end
 # just in case it isn't defined
 class AGString
 end
 # class String
-# 	alias oldadd +
-# 	def +(p)
-# 		#puts &quot;puh&quot;
-# 		if p.is_a?(AGString)
-# 			p=p.to_s
-# 		end
-# 		oldadd(p)
-# 	end
+#   alias oldadd +
+#   def +(p)
+#     #puts &quot;puh&quot;
+#     if p.is_a?(AGString)
+#       p=p.to_s
+#     end
+#     oldadd(p)
+#   end
 # end
 
 module Antargis
-	class AGVector3
-		def x=(p)
-			setX(p)
-		end
-		def y=(p)
-			setY(p)
-		end
-		def z=(p)
-			setZ(p)
-		end
-	end
-	class AGVector2
-		def x=(p)
-			setX(p)
-		end
-		def y=(p)
-			setY(p)
-		end
-		def _dump(depth)
-			[x,y].pack(&quot;gg&quot;)
-		end
-		def AGVector2._load(s)
-			a,b=s.unpack(&quot;gg&quot;)
-			AGVector2.new(a,b)
-		end
-	end
+  class AGVector3
+    def x=(p)
+      setX(p)
+    end
+    def y=(p)
+      setY(p)
+    end
+    def z=(p)
+      setZ(p)
+    end
+  end
+  class AGVector2
+    def x=(p)
+      setX(p)
+    end
+    def y=(p)
+      setY(p)
+    end
+    def _dump(depth)
+      [x,y].pack(&quot;gg&quot;)
+    end
+    def AGVector2._load(s)
+      a,b=s.unpack(&quot;gg&quot;)
+      AGVector2.new(a,b)
+    end
+  end
   class AGRubyMessageObject&lt;AGMessageObject
     def initialize()
       super

Modified: antargis/trunk/ruby/gui/testing.rb
===================================================================
--- antargis/trunk/ruby/gui/testing.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/gui/testing.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,114 +1,114 @@
 require 'ruby/spec_helper.rb'
 module TestModule
-	attr_reader :quitCounter
-	def step
-		run
-		puts &quot;step end&quot;
-	end
-	def eventFrame(t)
-		super
-		puts &quot;FRAME - try Quit...&quot;
-		tryQuit
-		true
-	end
-	def tryQuit
-		super
-		@quitCounter||=0
-		@quitCounter+=1
-	end
+  attr_reader :quitCounter
+  def step
+    run
+    puts &quot;step end&quot;
+  end
+  def eventFrame(t)
+    super
+    puts &quot;FRAME - try Quit...&quot;
+    tryQuit
+    true
+  end
+  def tryQuit
+    super
+    @quitCounter||=0
+    @quitCounter+=1
+  end
 end
 
 def makeTestAppClass(pClass)
-	mClass=Class.new(pClass)
-	mClass.class_eval{||include TestModule}
-	mClass
+  mClass=Class.new(pClass)
+  mClass.class_eval{||include TestModule}
+  mClass
 end
 # class TestApp&lt;AntEditorApp
-# 	def step
-# 		run
-# 	end
-# 	def eventFrame(t)
-# 		puts &quot;FRAME&quot;
-# 		super
-# 		tryQuit
-# 		true
-# 	end
+#   def step
+#     run
+#   end
+#   def eventFrame(t)
+#     puts &quot;FRAME&quot;
+#     super
+#     tryQuit
+#     true
+#   end
 # end
 
 class TestWidget
-	attr_reader :widget
-	def initialize(widget)
-		@widget=widget
-	end
-	def click
-# 		r=@widget.getScreenRect
-# 		x=r.x+r.w/2
-# 		y=r.y+r.h/2
-# 		pp r,x,y
+  attr_reader :widget
+  def initialize(widget)
+    @widget=widget
+  end
+  def click
+#     r=@widget.getScreenRect
+#     x=r.x+r.w/2
+#     y=r.y+r.h/2
+#     pp r,x,y
 # 
-# 		sdlEvent=toSDLEvent(&quot;SDL_MOUSEBUTTONDOWN:0:1:1:#{x.to_i}:#{y.to_i}&quot;)
-# 		@widget.eventMouseButtonDown(newEvent(nil,&quot;&quot;,sdlEvent))
-# 		sdlEvent=toSDLEvent(&quot;SDL_MOUSEBUTTONUP:0:1:1:#{x.to_i}:#{y.to_i}&quot;)
-# 		event=newEvent(nil,&quot;&quot;,sdlEvent)
-# 		@widget.eventMouseButtonUp(event)
+#     sdlEvent=toSDLEvent(&quot;SDL_MOUSEBUTTONDOWN:0:1:1:#{x.to_i}:#{y.to_i}&quot;)
+#     @widget.eventMouseButtonDown(newEvent(nil,&quot;&quot;,sdlEvent))
+#     sdlEvent=toSDLEvent(&quot;SDL_MOUSEBUTTONUP:0:1:1:#{x.to_i}:#{y.to_i}&quot;)
+#     event=newEvent(nil,&quot;&quot;,sdlEvent)
+#     @widget.eventMouseButtonUp(event)
 
-# # 		@widget.eventMouseButtonDown(AGEvent.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">widget, at widget.getName</A>))
-# # 		@widget.eventMouseButtonDown(AGEvent.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">widget, at widget.getName</A>))
-# 		@widget.sigClick.signal(AGEvent.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">widget, at widget.getName</A>))
- 		@widget.doClick(AGEvent.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">widget, at widget.getName</A>))
-	end
-	def child(widgetName)
-		return TestWidget.new(nil) if @widget.nil?
-		TestWidget.new(@widget.getChild(widgetName))
-	end
-	def visible
-		return false if @widget.nil?
-		@widget.visible
-	end
-	def valid
-		(not @widget.nil?)
-	end
-	def is_a?(type)
-		@widget.is_a?(type)
-	end
-	def method_missing(*s)
-		@widget.send(*s)
-	end
-	def printVisible
-		widget=@widget
-		puts &quot;--&quot;
-		while widget
-			puts &quot;#{widget} #{widget.getName} #{widget.visible}&quot;
-			widget=widget.getParent
-		end
-		puts &quot;--&quot;
-	end
-	def kind_of?(type)
-		@widget.kind_of?(type)
-	end
-	def instance_of?(type)
-		@widget.instance_of?(type)
-	end
-	def visible?
-		@widget.visible
-	end
-	def nil?
-		@widget.nil?
-	end
-	def checked?
-		@widget.isChecked
-	end
+# #     @widget.eventMouseButtonDown(AGEvent.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">widget, at widget.getName</A>))
+# #     @widget.eventMouseButtonDown(AGEvent.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">widget, at widget.getName</A>))
+#     @widget.sigClick.signal(AGEvent.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">widget, at widget.getName</A>))
+     @widget.doClick(AGEvent.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">widget, at widget.getName</A>))
+  end
+  def child(widgetName)
+    return TestWidget.new(nil) if @widget.nil?
+    TestWidget.new(@widget.getChild(widgetName))
+  end
+  def visible
+    return false if @widget.nil?
+    @widget.visible
+  end
+  def valid
+    (not @widget.nil?)
+  end
+  def is_a?(type)
+    @widget.is_a?(type)
+  end
+  def method_missing(*s)
+    @widget.send(*s)
+  end
+  def printVisible
+    widget=@widget
+    puts &quot;--&quot;
+    while widget
+      puts &quot;#{widget} #{widget.getName} #{widget.visible}&quot;
+      widget=widget.getParent
+    end
+    puts &quot;--&quot;
+  end
+  def kind_of?(type)
+    @widget.kind_of?(type)
+  end
+  def instance_of?(type)
+    @widget.instance_of?(type)
+  end
+  def visible?
+    @widget.visible
+  end
+  def nil?
+    @widget.nil?
+  end
+  def checked?
+    @widget.isChecked
+  end
 end
 
 
 module GuiTest
 protected
-	def widget(widgetName)
-		TestWidget.new(@app.getMainWidget.getChild(widgetName))
-	end
-	def clickScreen(x,y)
-	  click(AGVector2.new(x,y))
-	end
+  def widget(widgetName)
+    TestWidget.new(@app.getMainWidget.getChild(widgetName))
+  end
+  def clickScreen(x,y)
+    click(AGVector2.new(x,y))
+  end
   
   def click(pos)
     mouseDown(pos)

Modified: antargis/trunk/ruby/intro.rb
===================================================================
--- antargis/trunk/ruby/intro.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/intro.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,24 +7,24 @@
 # draws a black rectangle with varying alpha-channel. This way you
 # can fade in and out pictures and text-displays.
 class BlackFade&lt;AGWidget
-	# alpha-value is set to 0 by default
-	def initialize(p,r)
-		super(p,r)
-		@r=r
-		@alpha=0.0
-	end
-	# set the alpha-value *a* in range from 0.0 to 1.0
-	# the default-value is 0
-	def setAlpha(a)
-		@alpha=a
-		queryRedraw
-	end
+  # alpha-value is set to 0 by default
+  def initialize(p,r)
+    super(p,r)
+    @r=r
+    @alpha=0.0
+  end
+  # set the alpha-value *a* in range from 0.0 to 1.0
+  # the default-value is 0
+  def setAlpha(a)
+    @alpha=a
+    queryRedraw
+  end
 
-	# draws the black rectangle with set pre-set alpha-value
-	def draw(painter)
-		#painter.fillRect(@r,AGColor.new(0,0,0,0x1F))
-		painter.fillRect(@r,AGColor.new(0,0,0,(0xFF*@alpha).to_i))
-	end
+  # draws the black rectangle with set pre-set alpha-value
+  def draw(painter)
+    #painter.fillRect(@r,AGColor.new(0,0,0,0x1F))
+    painter.fillRect(@r,AGColor.new(0,0,0,(0xFF*@alpha).to_i))
+  end
 end
 
 
@@ -32,127 +32,127 @@
 # It's able to display images and text-elements (that are drawn using the intro.font-Font from the theme)
 # Each image/text-element is faded-in and faded-out. While the intro runs some music-track is played
 class IntroApp&lt;AntApplication
-	include AGHandler
-	def initialize
-		puts &quot;introApp...&quot;
-		super
-		puts &quot;introApp!&quot;
-		
-		@pics=[&quot;data/gui/rough_lands.png&quot;,&quot;data/gui/strong_heroes.png&quot;,&quot;data/gui/logoGold.png&quot;,&quot;data/gui/your_mission.png&quot;,&quot;data/gui/unify_the_people.png&quot;,&quot;data/gui/castle_small.png&quot;]
+  include AGHandler
+  def initialize
+    puts &quot;introApp...&quot;
+    super
+    puts &quot;introApp!&quot;
+    
+    @pics=[&quot;data/gui/rough_lands.png&quot;,&quot;data/gui/strong_heroes.png&quot;,&quot;data/gui/logoGold.png&quot;,&quot;data/gui/your_mission.png&quot;,&quot;data/gui/unify_the_people.png&quot;,&quot;data/gui/castle_small.png&quot;]
 
-		@pics=[&quot;rough lands&quot;,&quot;strong heroes&quot;,&quot;data/gui/logoGold.png&quot;,&quot;your mission&quot;,&quot;unify the people&quot;,&quot;data/gui/castle_small.png&quot;]
+    @pics=[&quot;rough lands&quot;,&quot;strong heroes&quot;,&quot;data/gui/logoGold.png&quot;,&quot;your mission&quot;,&quot;unify the people&quot;,&quot;data/gui/castle_small.png&quot;]
 
-		font=getTheme.getFont(&quot;intro.font&quot;)
-		@surfaces=@pics.collect{|x|
-			r=nil
-			if x=~/\.png/ or x=~/\.jpg/
-				r=AGSurface.load(x)
-			else
-				r=getFontEngine.renderText(0,0,_(x),font)
-			end
-			r
-		}
-		@s=0
-		@img=AGImage.new(nil,AGRect.new(0,0,getScreen.getWidth,getScreen.getHeight)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at surfaces</A>[0],false)
-		@black=BlackFade.new(@img,AGRect.new(0,0,getScreen.getWidth,getScreen.getHeight))
-		@img.addChild(@black)
-		setMainWidget(@img)
-		@time=0
-		
-		@blendin=0.9
-		@blendout=0.6
-		@show=1.2
-		@hide=0.3
-		@phase=0
-		@phases=[2,2,2,1]
-		getSoundManager.playMp3(&quot;data/music/battle1.ogg&quot;)
-		
-		addHandler(getSoundManager,:sigMp3Finished,:musicEnd)
-	end
-	
+    font=getTheme.getFont(&quot;intro.font&quot;)
+    @surfaces=@pics.collect{|x|
+      r=nil
+      if x=~/\.png/ or x=~/\.jpg/
+        r=AGSurface.load(x)
+      else
+        r=getFontEngine.renderText(0,0,_(x),font)
+      end
+      r
+    }
+    @s=0
+    @img=AGImage.new(nil,AGRect.new(0,0,getScreen.getWidth,getScreen.getHeight)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at surfaces</A>[0],false)
+    @black=BlackFade.new(@img,AGRect.new(0,0,getScreen.getWidth,getScreen.getHeight))
+    @img.addChild(@black)
+    setMainWidget(@img)
+    @time=0
+    
+    @blendin=0.9
+    @blendout=0.6
+    @show=1.2
+    @hide=0.3
+    @phase=0
+    @phases=[2,2,2,1]
+    getSoundManager.playMp3(&quot;data/music/battle1.ogg&quot;)
+    
+    addHandler(getSoundManager,:sigMp3Finished,:musicEnd)
+  end
+  
 
-	# if a key was pressed, we cancel the intro playing
-	def eventKeyDown(e)
-		cancel
-		return super
-	end
-	
-	# cancel the intro
-	# resets the *@phases*
-	def cancel
-		@canceled=true
-		@phases=[0.2,0.2,2,10]
-	end	
+  # if a key was pressed, we cancel the intro playing
+  def eventKeyDown(e)
+    cancel
+    return super
+  end
+  
+  # cancel the intro
+  # resets the *@phases*
+  def cancel
+    @canceled=true
+    @phases=[0.2,0.2,2,10]
+  end  
 
-	# if the music has finished, we cancel the intro
-	def musicEnd
-		cancel
-	end
-	
+  # if the music has finished, we cancel the intro
+  def musicEnd
+    cancel
+  end
+  
 
-	# this function is called, when you press F10 to quit the application
-	# the first call cancels the intro (thus it will still fade out)
-	# the second call will quit the intro directly
-	def tryQuit
-		if @canceled
-			#getSoundManager.stopMp3
-			#getSoundManager.fadeOutMusic(1000)
-			super
-		else
-			cancel
-		end
-	end
+  # this function is called, when you press F10 to quit the application
+  # the first call cancels the intro (thus it will still fade out)
+  # the second call will quit the intro directly
+  def tryQuit
+    if @canceled
+      #getSoundManager.stopMp3
+      #getSoundManager.fadeOutMusic(1000)
+      super
+    else
+      cancel
+    end
+  end
 
-	# this function does:
-	# * increase the phase - set alpha for BlackFade-Widget
-	# * switch to newer textures/text-elements
-	# * quit the intro, when its finished
-	def checkPhase
-		#puts &quot;#{@time}&gt;#{@phases[@phase]}&quot;
-		if @time&gt;@phases[@phase]
-			@time-=@phases[@phase]
-			@phase+=1
-			if @phase==4
-				@phase=0
-			elsif @phase==3 # switch surface early, so there won't be a timing problem
-				@s=@s+1
-				if @s==@surfaces.length
-					@s=0
-					@canceled=true
-				end
-				if @surfaces[@s].is_a?(AGSurface)
-					@img.setSurface(@surfaces[@s])
-				else
-					@img.setTexture(@surfaces[@s])
-				end
-			end
-		end
-		case @phase
-			when 0
-				@black.setAlpha(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1- at time</A>/@phases[@phase])
-			when 2
-				@black.setAlpha(@time/@phases[@phase])
-			when 3
-				if @canceled
-					tryQuit
-				end
-		end
-		@img.redraw
-	end
-	
-	# gets called in each frame (and sets a delay of 10ms between frames)
-	def eventFrame(t)
-		@time+=t
-		checkPhase
-		delay(10)
-		return true
-	end
+  # this function does:
+  # * increase the phase - set alpha for BlackFade-Widget
+  # * switch to newer textures/text-elements
+  # * quit the intro, when its finished
+  def checkPhase
+    #puts &quot;#{@time}&gt;#{@phases[@phase]}&quot;
+    if @time&gt;@phases[@phase]
+      @time-=@phases[@phase]
+      @phase+=1
+      if @phase==4
+        @phase=0
+      elsif @phase==3 # switch surface early, so there won't be a timing problem
+        @s=@s+1
+        if @s==@surfaces.length
+          @s=0
+          @canceled=true
+        end
+        if @surfaces[@s].is_a?(AGSurface)
+          @img.setSurface(@surfaces[@s])
+        else
+          @img.setTexture(@surfaces[@s])
+        end
+      end
+    end
+    case @phase
+      when 0
+        @black.setAlpha(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1- at time</A>/@phases[@phase])
+      when 2
+        @black.setAlpha(@time/@phases[@phase])
+      when 3
+        if @canceled
+          tryQuit
+        end
+    end
+    @img.redraw
+  end
+  
+  # gets called in each frame (and sets a delay of 10ms between frames)
+  def eventFrame(t)
+    @time+=t
+    checkPhase
+    delay(10)
+    return true
+  end
 
-	# when a mouse-button is clicked the intro is canceled
-	def eventMouseButtonDown(e)
-	  puts &quot;HU&quot;
-		tryQuit
-		return super(e)
-	end
-	
+  # when a mouse-button is clicked the intro is canceled
+  def eventMouseButtonDown(e)
+    puts &quot;HU&quot;
+    tryQuit
+    return super(e)
+  end
+  
 end

Modified: antargis/trunk/ruby/jobs/ant_state_machine.rb
===================================================================
--- antargis/trunk/ruby/jobs/ant_state_machine.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/jobs/ant_state_machine.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,181 +1,181 @@
 class BaseState
   attr_reader :started
-	@@states={}
-	@@edges={}
-	@@endstates={}
-	@@startstate={}
-	def BaseState.state(p)
-	  @started=false
-		s=@@states[self]
-		s||={}
-		p.each{|k,v|s[k]=v}
-		@@states[self]=s
-	end
-	def BaseState.edge(v0,v1,f=nil)
-		@@edges[self]||=[]
-		@@edges[self]&lt;&lt;[v0,v1,f]
-	end
-	def BaseState.startState(s)
-		#puts &quot;setting startstate for #{self}:#{s}&quot;
-		@@startstate[self]=s
-	end
-	def BaseState.endState(s)
-		@@endstates[self]||=[]
-		@@endstates[self].push(s)
-	end
+  @@states={}
+  @@edges={}
+  @@endstates={}
+  @@startstate={}
+  def BaseState.state(p)
+    @started=false
+    s=@@states[self]
+    s||={}
+    p.each{|k,v|s[k]=v}
+    @@states[self]=s
+  end
+  def BaseState.edge(v0,v1,f=nil)
+    @@edges[self]||=[]
+    @@edges[self]&lt;&lt;[v0,v1,f]
+  end
+  def BaseState.startState(s)
+    #puts &quot;setting startstate for #{self}:#{s}&quot;
+    @@startstate[self]=s
+  end
+  def BaseState.endState(s)
+    @@endstates[self]||=[]
+    @@endstates[self].push(s)
+  end
 
-	def BaseState.inheritMachine
-		me=ancestors[0]
-		anc=ancestors[1]
-		@@states[me]=@@states[anc].dup
-		@@edges[me]=@@edges[anc].dup
-		@@endstates[me]=@@endstates[anc].dup
-		@@startstate[me]=@@startstate[anc]
-	end
-	
-	def initialize(startState=nil)
-		@states={}
-		@@states[self.class].each{|k,v|@states[k]=v.new;@states[k].machine=self}
-		@state=startState
-		@state||=@@startstate[self.class]
-		@firstRun=false
-	end
-	
-	def ready
-		return true if @state.nil?
-		if @@endstates[self.class]
-			if @@endstates[self.class].length&gt;0
-				return true if @@endstates[self.class].member?(@state)
-			end
-		end
-		return false
-	end		
+  def BaseState.inheritMachine
+    me=ancestors[0]
+    anc=ancestors[1]
+    @@states[me]=@@states[anc].dup
+    @@edges[me]=@@edges[anc].dup
+    @@endstates[me]=@@endstates[anc].dup
+    @@startstate[me]=@@startstate[anc]
+  end
+  
+  def initialize(startState=nil)
+    @states={}
+    @@states[self.class].each{|k,v|@states[k]=v.new;@states[k].machine=self}
+    @state=startState
+    @state||=@@startstate[self.class]
+    @firstRun=false
+  end
+  
+  def ready
+    return true if @state.nil?
+    if @@endstates[self.class]
+      if @@endstates[self.class].length&gt;0
+        return true if @@endstates[self.class].member?(@state)
+      end
+    end
+    return false
+  end    
 
-	def advance
-		if @states.length==0
-			puts &quot;no states here&quot;
-			return
-		end
-		if hasState
-			stepState
-		end
-	end
+  def advance
+    if @states.length==0
+      puts &quot;no states here&quot;
+      return
+    end
+    if hasState
+      stepState
+    end
+  end
 
-	def firstCall
-	  @started=true
-		enterRecursive
-	end
+  def firstCall
+    @started=true
+    enterRecursive
+  end
 
-	def hasState
-		if @state
-			return (not @states[@state].nil?)
-		end
-		false
-	end
+  def hasState
+    if @state
+      return (not @states[@state].nil?)
+    end
+    false
+  end
 
-	def state
-		if @state
-			if @states[@state]
-				return @states[@state]
-			end
-		end
-		raise &quot;no state defined!&quot;
-	end
-	
-	def stateName
-		@state
-	end
+  def state
+    if @state
+      if @states[@state]
+        return @states[@state]
+      end
+    end
+    raise &quot;no state defined!&quot;
+  end
+  
+  def stateName
+    @state
+  end
 
-	def stateCall(*s)
-		if @state
-			if @states[@state]
-				#puts &quot;(#{s})(#{s[0]})&quot;
-				if @states[@state].respond_to?(s[0])
-					@states[@state].send(*s) #(s[1..-1]))
-				end
-			end
-		end
-	end
+  def stateCall(*s)
+    if @state
+      if @states[@state]
+        #puts &quot;(#{s})(#{s[0]})&quot;
+        if @states[@state].respond_to?(s[0])
+          @states[@state].send(*s) #(s[1..-1]))
+        end
+      end
+    end
+  end
 
 protected
-	def enterRecursive(selftoo=true)
-		#puts &quot;#{self}:enterRecursive&quot;
+  def enterRecursive(selftoo=true)
+    #puts &quot;#{self}:enterRecursive&quot;
 
-		if self.respond_to?(&quot;enter&quot;) and selftoo
-			#puts &quot;#{self}:enterRecursive - enter...&quot;
-			enter
-			#puts &quot;#{self}:enterRecursive - enter.ok&quot;
-		end
+    if self.respond_to?(&quot;enter&quot;) and selftoo
+      #puts &quot;#{self}:enterRecursive - enter...&quot;
+      enter
+      #puts &quot;#{self}:enterRecursive - enter.ok&quot;
+    end
 
-		#puts &quot;#{self}:enterRecursive - hasState:#{hasState}&quot;
-		if hasState
-			#puts &quot;#{self}:enterRecursive - respond_to(enterRec):#{state.respond_to?(&quot;enterRecursive&quot;)}&quot;
-			#puts &quot;#{self}:enterRecursive - state:#{state}&quot;
-			if state.respond_to?(&quot;enterRecursive&quot;)
-				state.enterRecursive
-			else
-				#puts &quot;#{self}:enterRecursive - statecall-enter...&quot;
-				stateCall(&quot;enter&quot;)
-			end
-		end
-	end
+    #puts &quot;#{self}:enterRecursive - hasState:#{hasState}&quot;
+    if hasState
+      #puts &quot;#{self}:enterRecursive - respond_to(enterRec):#{state.respond_to?(&quot;enterRecursive&quot;)}&quot;
+      #puts &quot;#{self}:enterRecursive - state:#{state}&quot;
+      if state.respond_to?(&quot;enterRecursive&quot;)
+        state.enterRecursive
+      else
+        #puts &quot;#{self}:enterRecursive - statecall-enter...&quot;
+        stateCall(&quot;enter&quot;)
+      end
+    end
+  end
 
 private
-	def stepState
-		assert {hasState}
-		stateCall(&quot;advance&quot;)
-		if state.ready
-			toNextState
-		else
-			true
-		end
-	end
-	
-	def toNextState
-		#puts &quot;#{self} toNextState:#{@state}:#{state}&quot;
-		nstate=nil
-		@@edges[self.class].each{|e|
-			if e[0]==@state
-				ok=true
-				if not e[2].nil?
-					ok=self.send(e[2]) #.call
-				end
-				if ok
-					nstate=e[1]
-				end
-			end
-		}
-		if nstate
-			switch2(nstate)
-			return true
-		elsif @@endstates[self.class].member?(@state)
-			switch2(nil)
-		end
-		false
-	end
-	
-	def left
-		@firstRun=false
-	end
-		
-	def switch2(s)
-		stateCall(&quot;leave&quot;)
-		stateCall(&quot;left&quot;)
-		@state=s
-		#stateCall(&quot;enterRecursive&quot;)
-		enterRecursive(false)
-	end
+  def stepState
+    assert {hasState}
+    stateCall(&quot;advance&quot;)
+    if state.ready
+      toNextState
+    else
+      true
+    end
+  end
+  
+  def toNextState
+    #puts &quot;#{self} toNextState:#{@state}:#{state}&quot;
+    nstate=nil
+    @@edges[self.class].each{|e|
+      if e[0]==@state
+        ok=true
+        if not e[2].nil?
+          ok=self.send(e[2]) #.call
+        end
+        if ok
+          nstate=e[1]
+        end
+      end
+    }
+    if nstate
+      switch2(nstate)
+      return true
+    elsif @@endstates[self.class].member?(@state)
+      switch2(nil)
+    end
+    false
+  end
+  
+  def left
+    @firstRun=false
+  end
+    
+  def switch2(s)
+    stateCall(&quot;leave&quot;)
+    stateCall(&quot;left&quot;)
+    @state=s
+    #stateCall(&quot;enterRecursive&quot;)
+    enterRecursive(false)
+  end
 end
 
 class BaseMachine&lt;BaseState
-# 	def initialize(start=nil)
-# 		super(start)
-# 		if start.nil?
-# 			@state=@@startstate[self.class]
-# 			puts &quot;startstate: #{@@startstate[self.class]}&quot;
-# 		else
-# 			@state=start
-# 		end
-# 	end
+#   def initialize(start=nil)
+#     super(start)
+#     if start.nil?
+#       @state=@@startstate[self.class]
+#       puts &quot;startstate: #{@@startstate[self.class]}&quot;
+#     else
+#       @state=start
+#     end
+#   end
 end
 

Modified: antargis/trunk/ruby/jobs/spec/recruit.rb
===================================================================
--- antargis/trunk/ruby/jobs/spec/recruit.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/jobs/spec/recruit.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -4,57 +4,57 @@
 #require 'ruby/state_machine/ant_hl_job_states.rb'
 
 module Testing
-	@@testing=false
-	def Testing.initTesting
-		return if @@testing
-		@@testing=true
+  @@testing=false
+  def Testing.initTesting
+    return if @@testing
+    @@testing=true
 
-		@@app=AGApplication.new
-		@@scene=Scene.new(800,600)
-	end
+    @@app=AGApplication.new
+    @@scene=Scene.new(800,600)
+  end
 
-	def Testing.getTestMapFor(test)
-		initTesting
-		case test
-			when :recruit
-				#map=AntRubyMap.new(@@app,@@scene,800,600)
-				map=AntRubyMap.new(nil,nil,800,600)
-				map.loadMap(&quot;data/levels/tutorial/tutorial0.antlvl&quot;)
-				map
-		end
-	end
+  def Testing.getTestMapFor(test)
+    initTesting
+    case test
+      when :recruit
+        #map=AntRubyMap.new(@@app,@@scene,800,600)
+        map=AntRubyMap.new(nil,nil,800,600)
+        map.loadMap(&quot;data/levels/tutorial/tutorial0.antlvl&quot;)
+        map
+    end
+  end
 end
 
 describe AntHeroRecruitJob,&quot;Test-map for recruiting&quot; do
-	before(:all) do
-		@map=Testing.getTestMapFor(:recruit)
-	end
-	it &quot;should include a hero called 'Rowen'&quot; do
-		@map.getByName(&quot;Rowen&quot;).should is_a?(AntHero)
-	end
+  before(:all) do
+    @map=Testing.getTestMapFor(:recruit)
+  end
+  it &quot;should include a hero called 'Rowen'&quot; do
+    @map.getByName(&quot;Rowen&quot;).should is_a?(AntHero)
+  end
 end
 
 describe AntHeroRecruitJob,&quot;A hero recruit job&quot; do
-	before(:each) do
-		@map=Testing.getTestMapFor(:recruit)
+  before(:each) do
+    @map=Testing.getTestMapFor(:recruit)
 
-		@hero=@map.getByName(&quot;Rowen&quot;)
-	end
+    @hero=@map.getByName(&quot;Rowen&quot;)
+  end
 
-	it &quot;map should include Rowen&quot; do
-		@hero.should_not be_nil
-	end
+  it &quot;map should include Rowen&quot; do
+    @hero.should_not be_nil
+  end
 
 
-# 	it &quot;should at any time determine how strong the aggression of the hero is and thus should not start new ll-jobs to recruit people if there are already enough&quot;
-# 	it &quot;should take care when the aggression level is raised&quot;
-# 	it &quot;should assign a low-level job to the men - according to the amount of needed people&quot; 
-# 	it &quot;should return each man after recruiting of being recruited to the starting point&quot;
-# 	it &quot;should use sit-formation for the starting-point&quot;
-# 	it &quot;should let people sit, when they don't have anything to do&quot;
+#   it &quot;should at any time determine how strong the aggression of the hero is and thus should not start new ll-jobs to recruit people if there are already enough&quot;
+#   it &quot;should take care when the aggression level is raised&quot;
+#   it &quot;should assign a low-level job to the men - according to the amount of needed people&quot; 
+#   it &quot;should return each man after recruiting of being recruited to the starting point&quot;
+#   it &quot;should use sit-formation for the starting-point&quot;
+#   it &quot;should let people sit, when they don't have anything to do&quot;
 # 
-# 	it &quot;aggression of 3 implies all people&quot;		
-# 	
-# 	it &quot;aggression of 2 implies 2/3 of all people&quot;
-# 	it &quot;aggression of 1 implies 1/3 of all people&quot;
-end
\ No newline at end of file
+#   it &quot;aggression of 3 implies all people&quot;    
+#   
+#   it &quot;aggression of 2 implies 2/3 of all people&quot;
+#   it &quot;aggression of 1 implies 1/3 of all people&quot;
+end

Modified: antargis/trunk/ruby/level.rb
===================================================================
--- antargis/trunk/ruby/level.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/level.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,78 +1,78 @@
 
 class Level
-	def initialize(app)
-		@app=app
-	end
+  def initialize(app)
+    @app=app
+  end
 
-	def eventTrigger(hero,t)
-		return false
-	end
-	def eventOwnerChanged(ent)
-	end
-	def eventHeroDied(ent)
-	end
-	def eventHLJobFinished(hero,job)
-	end
-	def eventDismissed(hero)
-	end
-	def eventLevelStarted
-	end
+  def eventTrigger(hero,t)
+    return false
+  end
+  def eventOwnerChanged(ent)
+  end
+  def eventHeroDied(ent)
+  end
+  def eventHLJobFinished(hero,job)
+  end
+  def eventDismissed(hero)
+  end
+  def eventLevelStarted
+  end
 
-	def saveXML(node)
-		saveLocals(node)
-	end
-	def loadXML(node)
-		loadLocals(node)
-	end
+  def saveXML(node)
+    saveLocals(node)
+  end
+  def loadXML(node)
+    loadLocals(node)
+  end
 
-	# use this to end a level
-	def wonLevel
-		@app.setResult(GameResult.new(&quot;won&quot;))
-	end
-	def lostLevel
-		@app.setResult(GameResult.new(&quot;lost&quot;))
-	end
-	def endLevel
-		@app.tryQuit
-	end
-	def tellStory(flow)
-		@app.tellStory(flow)
-		@story=flow
-	end
+  # use this to end a level
+  def wonLevel
+    @app.setResult(GameResult.new(&quot;won&quot;))
+  end
+  def lostLevel
+    @app.setResult(GameResult.new(&quot;lost&quot;))
+  end
+  def endLevel
+    @app.tryQuit
+  end
+  def tellStory(flow)
+    @app.tellStory(flow)
+    @story=flow
+  end
 
 private
-	def getLocals
-		a={}
-		instance_variables.each{|v|
-			a[v]=instance_variable_get(v)
-		}
-		return a
-	end
-	def saveLocals(node)
-		getLocals.each{|n,v|
-			c=node.addChild(&quot;local&quot;)
-			c.set(&quot;name&quot;,n)
-			c.set(&quot;type&quot;,v.class.to_s)
-			c.set(&quot;value&quot;,v.to_s)
-		}
-	end
-	def loadLocals(node)
-		node.getChildren(&quot;local&quot;).each{|c|
-			n=c.get(&quot;name&quot;)
-			v=nil
-			case c.get(&quot;type&quot;)
-				when &quot;TrueClass&quot;
-					v=true
-				when &quot;FalseClass&quot;
-					v=false
-				when &quot;Fixnum&quot;,&quot;Bignum&quot;
-					v=c.get(&quot;value&quot;).to_i
-				when &quot;Float&quot;
-					v=c.get(&quot;value&quot;).to_f
-				when &quot;String&quot;
-					v=c.get(&quot;value&quot;)
-			end
-			instance_variable_set(n,v)
-		}
-	end
-end
\ No newline at end of file
+  def getLocals
+    a={}
+    instance_variables.each{|v|
+      a[v]=instance_variable_get(v)
+    }
+    return a
+  end
+  def saveLocals(node)
+    getLocals.each{|n,v|
+      c=node.addChild(&quot;local&quot;)
+      c.set(&quot;name&quot;,n)
+      c.set(&quot;type&quot;,v.class.to_s)
+      c.set(&quot;value&quot;,v.to_s)
+    }
+  end
+  def loadLocals(node)
+    node.getChildren(&quot;local&quot;).each{|c|
+      n=c.get(&quot;name&quot;)
+      v=nil
+      case c.get(&quot;type&quot;)
+        when &quot;TrueClass&quot;
+          v=true
+        when &quot;FalseClass&quot;
+          v=false
+        when &quot;Fixnum&quot;,&quot;Bignum&quot;
+          v=c.get(&quot;value&quot;).to_i
+        when &quot;Float&quot;
+          v=c.get(&quot;value&quot;).to_f
+        when &quot;String&quot;
+          v=c.get(&quot;value&quot;)
+      end
+      instance_variable_set(n,v)
+    }
+  end
+end

Modified: antargis/trunk/ruby/mainmenu.rb
===================================================================
--- antargis/trunk/ruby/mainmenu.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/mainmenu.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -43,448 +43,448 @@
 # not to name events the same!
 #
 class AntMenuApp &lt;AntApplication
-	include AGHandler
-	def initialize
-		super()
-		# init menues
-		@menues=[]
-		
-		# setup all the 
-		setupMain
-		setupCredits
-		setupCampaign
-		setupOptions
-		setupLoadMenu
-		setupSingle
-		@sound=true
+  include AGHandler
+  def initialize
+    super()
+    # init menues
+    @menues=[]
+    
+    # setup all the 
+    setupMain
+    setupCredits
+    setupCampaign
+    setupOptions
+    setupLoadMenu
+    setupSingle
+    @sound=true
 
-		# add handler for music finished, simply restart music
-		addHandler(getSoundManager,:sigMp3Finished,:eventMusicEnd)
-	end
+    # add handler for music finished, simply restart music
+    addHandler(getSoundManager,:sigMp3Finished,:eventMusicEnd)
+  end
 
 
-	# overrides AGWidget.setMainWidget, so that the given Widget *w* is
-	# embedded into an outer AGScreenWidget. The reason for this is
-	# redrawing AFAIK (?)
-	def setMainWidget(w)
-		if @myScreen.nil?
-			@myScreen||=AGScreenWidget.new
-			super(@myScreen)
-		end
-		@myScreen.removeChild(@curMainWidget)
-		@myScreen.addChild(w)
-		@curMainWidget=w
-	end
-	
+  # overrides AGWidget.setMainWidget, so that the given Widget *w* is
+  # embedded into an outer AGScreenWidget. The reason for this is
+  # redrawing AFAIK (?)
+  def setMainWidget(w)
+    if @myScreen.nil?
+      @myScreen||=AGScreenWidget.new
+      super(@myScreen)
+    end
+    @myScreen.removeChild(@curMainWidget)
+    @myScreen.addChild(w)
+    @curMainWidget=w
+  end
+  
 
 
-	# :section: set up the menus
+  # :section: set up the menus
 
 
-	# this function sets up the main-menu layout of out data/gui/layout/mainmenu.xml
-	# * event handlers are initialized
-	# * the MainWidget is set to this menu at startup
-	def setupMain()
-		@mainMenu=AGLayout.new(nil)
-		@mainMenu.loadXML(loadFile(&quot;data/gui/layout/mainmenu.xml&quot;))
-		@menues.push(@mainMenu)
-		setMainWidget(@mainMenu)
-		addHandler(@mainMenu.getChild(&quot;quit&quot;),:sigClick,:eventQuit)
-		addHandler(@mainMenu.getChild(&quot;credits&quot;),:sigClick,:eventCredits)
-		addHandler(@mainMenu.getChild(&quot;campaign&quot;),:sigClick,:eventCampaign)
-		addHandler(@mainMenu.getChild(&quot;single&quot;),:sigClick,:eventSingle)
-		addHandler(@mainMenu.getChild(&quot;tutorial&quot;),:sigClick,:eventTutorial)
-		addHandler(@mainMenu.getChild(&quot;load&quot;),:sigClick,:eventLoadGame)
-		addHandler(@mainMenu.getChild(&quot;options&quot;),:sigClick,:eventOptions)
-	end
+  # this function sets up the main-menu layout of out data/gui/layout/mainmenu.xml
+  # * event handlers are initialized
+  # * the MainWidget is set to this menu at startup
+  def setupMain()
+    @mainMenu=AGLayout.new(nil)
+    @mainMenu.loadXML(loadFile(&quot;data/gui/layout/mainmenu.xml&quot;))
+    @menues.push(@mainMenu)
+    setMainWidget(@mainMenu)
+    addHandler(@mainMenu.getChild(&quot;quit&quot;),:sigClick,:eventQuit)
+    addHandler(@mainMenu.getChild(&quot;credits&quot;),:sigClick,:eventCredits)
+    addHandler(@mainMenu.getChild(&quot;campaign&quot;),:sigClick,:eventCampaign)
+    addHandler(@mainMenu.getChild(&quot;single&quot;),:sigClick,:eventSingle)
+    addHandler(@mainMenu.getChild(&quot;tutorial&quot;),:sigClick,:eventTutorial)
+    addHandler(@mainMenu.getChild(&quot;load&quot;),:sigClick,:eventLoadGame)
+    addHandler(@mainMenu.getChild(&quot;options&quot;),:sigClick,:eventOptions)
+  end
 
 
 
-	# LOAD GAME MENU
-	def setupLoadMenu
-		@loadMenu=AGLayout.new(nil)
-		@loadMenu.loadXML(loadFile(&quot;data/gui/layout/loadmenu.xml&quot;))
-		@menues.push(@loadMenu)
-		addHandler(@loadMenu.getChild(&quot;exit&quot;),:sigClick,:eventExit)
-		addHandler(@loadMenu.getChild(&quot;list&quot;),:sigSelect,:eventLoadSelect)
-		addHandler(@loadMenu.getChild(&quot;doLoad&quot;),:sigClick,:eventLoad)
-		updateLoadMenu
-	end
+  # LOAD GAME MENU
+  def setupLoadMenu
+    @loadMenu=AGLayout.new(nil)
+    @loadMenu.loadXML(loadFile(&quot;data/gui/layout/loadmenu.xml&quot;))
+    @menues.push(@loadMenu)
+    addHandler(@loadMenu.getChild(&quot;exit&quot;),:sigClick,:eventExit)
+    addHandler(@loadMenu.getChild(&quot;list&quot;),:sigSelect,:eventLoadSelect)
+    addHandler(@loadMenu.getChild(&quot;doLoad&quot;),:sigClick,:eventLoad)
+    updateLoadMenu
+  end
 
-	def updateLoadMenu
-		fs=getDirectory(getWriteDir+&quot;/savegames&quot;).select{|f|f=~/\.antcmp/}.sort.uniq
-		l=@loadMenu.getChild(&quot;list&quot;)
-		l.clearList
-		fs.each{|f|
-			x=f.gsub(&quot;.antcmp&quot;,&quot;&quot;)
-			l.insertItem(f,AGStringUtf8.new(x))  # FIXME: _() ??
-		}
-		if fs.length&gt;0
-			fn=&quot;savegames/&quot;+fs[0].gsub(&quot;antcmp&quot;,&quot;png&quot;)
-			if findFile(fn)!=&quot;&quot;
-				@loadMenu.getChild(&quot;screenshot&quot;).setSurface(AGSurface.load(fn))
-			end
-		end
-	end
+  def updateLoadMenu
+    fs=getDirectory(getWriteDir+&quot;/savegames&quot;).select{|f|f=~/\.antcmp/}.sort.uniq
+    l=@loadMenu.getChild(&quot;list&quot;)
+    l.clearList
+    fs.each{|f|
+      x=f.gsub(&quot;.antcmp&quot;,&quot;&quot;)
+      l.insertItem(f,AGStringUtf8.new(x))  # FIXME: _() ??
+    }
+    if fs.length&gt;0
+      fn=&quot;savegames/&quot;+fs[0].gsub(&quot;antcmp&quot;,&quot;png&quot;)
+      if findFile(fn)!=&quot;&quot;
+        @loadMenu.getChild(&quot;screenshot&quot;).setSurface(AGSurface.load(fn))
+      end
+    end
+  end
 
-	def eventLoadSelect(e)
-		if @curMainWidget==@singleMenu
-			@singleMenu.getChild(&quot;desc&quot;).setText(AGStringUtf8.new(&quot;&quot;))
-			filename=id=@singleMenu.getChild(&quot;list&quot;).getSelectedID
-			fn=&quot;data/levels/&quot;+id.gsub(&quot;.antlvl&quot;,&quot;.png&quot;)
-			if findFile(fn)!=&quot;&quot;
-				s=AGSurface.load(fn)
-				if s.valid
-					@singleMenu.getChild(&quot;screenshot&quot;).setSurface(s)
-				end
-			else
-				puts &quot;Screenshot-file #{fn} not found!&quot;
-			end
-			doc=Document.new(&quot;data/levels/&quot;+filename)
-			d=doc.root.get(&quot;desc&quot;)
-			@singleMenu.getChild(&quot;desc&quot;).setText(AGStringUtf8.new(d))
-			return true
-		end
-		@loadMenu.getChild(&quot;desc&quot;).setText(AGStringUtf8.new(&quot;&quot;))
-		filename=id=@loadMenu.getChild(&quot;list&quot;).getSelectedID
-		fn=&quot;savegames/&quot;+id.gsub(&quot;.antcmp&quot;,&quot;.png&quot;)
-		if findFile(fn)!=&quot;&quot;
-			s=AGSurface.load(fn)
-			if s.valid
-				@loadMenu.getChild(&quot;screenshot&quot;).setSurface(s)
-			end
-		end
-		return true
-	end
-	def eventLoad(e)
-		id=@loadMenu.getChild(&quot;list&quot;).getSelectedID
-		if id!=&quot;&quot;
-			c=Campaign.new(getWriteDir+&quot;/savegames/&quot;+id)
-			continueCampaign(c)
-		end
-		setMainWidget(@mainMenu)
-		return true
-	end
+  def eventLoadSelect(e)
+    if @curMainWidget==@singleMenu
+      @singleMenu.getChild(&quot;desc&quot;).setText(AGStringUtf8.new(&quot;&quot;))
+      filename=id=@singleMenu.getChild(&quot;list&quot;).getSelectedID
+      fn=&quot;data/levels/&quot;+id.gsub(&quot;.antlvl&quot;,&quot;.png&quot;)
+      if findFile(fn)!=&quot;&quot;
+        s=AGSurface.load(fn)
+        if s.valid
+          @singleMenu.getChild(&quot;screenshot&quot;).setSurface(s)
+        end
+      else
+        puts &quot;Screenshot-file #{fn} not found!&quot;
+      end
+      doc=Document.new(&quot;data/levels/&quot;+filename)
+      d=doc.root.get(&quot;desc&quot;)
+      @singleMenu.getChild(&quot;desc&quot;).setText(AGStringUtf8.new(d))
+      return true
+    end
+    @loadMenu.getChild(&quot;desc&quot;).setText(AGStringUtf8.new(&quot;&quot;))
+    filename=id=@loadMenu.getChild(&quot;list&quot;).getSelectedID
+    fn=&quot;savegames/&quot;+id.gsub(&quot;.antcmp&quot;,&quot;.png&quot;)
+    if findFile(fn)!=&quot;&quot;
+      s=AGSurface.load(fn)
+      if s.valid
+        @loadMenu.getChild(&quot;screenshot&quot;).setSurface(s)
+      end
+    end
+    return true
+  end
+  def eventLoad(e)
+    id=@loadMenu.getChild(&quot;list&quot;).getSelectedID
+    if id!=&quot;&quot;
+      c=Campaign.new(getWriteDir+&quot;/savegames/&quot;+id)
+      continueCampaign(c)
+    end
+    setMainWidget(@mainMenu)
+    return true
+  end
 
 
-	# SINGLE GAME MENU
-	def updateSingleMenu
-		fs=getDirectory(&quot;./data/levels&quot;)
-		fs=fs.select{|f|f=~/\.antlvl/ and (not f=~/~/)}.sort.uniq
-		l=@singleMenu.getChild(&quot;list&quot;)
-		l.clearList
-		fs.each{|f|
-			x=f.gsub(&quot;.antlvl&quot;,&quot;&quot;)
-			l.insertItem(f,AGStringUtf8.new(x))
-		}
-		if fs.length&gt;0
-			fn=&quot;data/levels/&quot;+fs[0].gsub(&quot;antlvl&quot;,&quot;png&quot;)
-			if findFile(fn)!=&quot;&quot;
-				@singleMenu.getChild(&quot;screenshot&quot;).setSurface(AGSurface.load(fn))
-			end
-		end
-	end
-	def setupSingle
-		@singleMenu=AGLayout.new(nil)
-		@singleMenu.loadXML(loadFile(&quot;data/gui/layout/single.xml&quot;))
-		@menues.push(@singleMenu)
-		addHandler(@singleMenu.getChild(&quot;singleExit&quot;),:sigClick,:eventExit)
-		addHandler(@singleMenu.getChild(&quot;singleStart&quot;),:sigClick,:eventSingleStart)
-		addHandler(@singleMenu.getChild(&quot;list&quot;),:sigSelect,:eventLoadSelect)
-		updateSingleMenu
-	end
+  # SINGLE GAME MENU
+  def updateSingleMenu
+    fs=getDirectory(&quot;./data/levels&quot;)
+    fs=fs.select{|f|f=~/\.antlvl/ and (not f=~/~/)}.sort.uniq
+    l=@singleMenu.getChild(&quot;list&quot;)
+    l.clearList
+    fs.each{|f|
+      x=f.gsub(&quot;.antlvl&quot;,&quot;&quot;)
+      l.insertItem(f,AGStringUtf8.new(x))
+    }
+    if fs.length&gt;0
+      fn=&quot;data/levels/&quot;+fs[0].gsub(&quot;antlvl&quot;,&quot;png&quot;)
+      if findFile(fn)!=&quot;&quot;
+        @singleMenu.getChild(&quot;screenshot&quot;).setSurface(AGSurface.load(fn))
+      end
+    end
+  end
+  def setupSingle
+    @singleMenu=AGLayout.new(nil)
+    @singleMenu.loadXML(loadFile(&quot;data/gui/layout/single.xml&quot;))
+    @menues.push(@singleMenu)
+    addHandler(@singleMenu.getChild(&quot;singleExit&quot;),:sigClick,:eventExit)
+    addHandler(@singleMenu.getChild(&quot;singleStart&quot;),:sigClick,:eventSingleStart)
+    addHandler(@singleMenu.getChild(&quot;list&quot;),:sigSelect,:eventLoadSelect)
+    updateSingleMenu
+  end
 
-	# OPTIONS MENU
-	def setupOptions
-		@optionsMenu=AGLayout.new(nil)
-		@optionSubMenus=[&quot;VideoOptionsMenu&quot;,&quot;AudioOptionsMenu&quot;,&quot;GameOptionsMenu&quot;]
-		@optionsMenu.loadXML(loadFile(&quot;data/gui/layout/options.xml&quot;))
-		@menues.push(@optionsMenu)
-		addHandler(@optionsMenu.getChild(&quot;exit&quot;),:sigClick,:eventExit)
-		
-		addHandler(@optionsMenu.getChild(&quot;fullscreen&quot;),:sigClick,:eventFullscreen)
-		[&quot;640&quot;,&quot;800&quot;,&quot;1024&quot;,&quot;1280&quot;,&quot;1400&quot;].each{|n|
-			addHandler(@optionsMenu.getChild(n),:sigClick,:eventResChange)
-		}
-		#addHandler(@optionsMenu.getChild(&quot;1280&quot;),:sigClick,:eventResChange)
-		addHandler(@optionsMenu.getChild(&quot;1400&quot;),:sigClick,:eventResChange)
+  # OPTIONS MENU
+  def setupOptions
+    @optionsMenu=AGLayout.new(nil)
+    @optionSubMenus=[&quot;VideoOptionsMenu&quot;,&quot;AudioOptionsMenu&quot;,&quot;GameOptionsMenu&quot;]
+    @optionsMenu.loadXML(loadFile(&quot;data/gui/layout/options.xml&quot;))
+    @menues.push(@optionsMenu)
+    addHandler(@optionsMenu.getChild(&quot;exit&quot;),:sigClick,:eventExit)
+    
+    addHandler(@optionsMenu.getChild(&quot;fullscreen&quot;),:sigClick,:eventFullscreen)
+    [&quot;640&quot;,&quot;800&quot;,&quot;1024&quot;,&quot;1280&quot;,&quot;1400&quot;].each{|n|
+      addHandler(@optionsMenu.getChild(n),:sigClick,:eventResChange)
+    }
+    #addHandler(@optionsMenu.getChild(&quot;1280&quot;),:sigClick,:eventResChange)
+    addHandler(@optionsMenu.getChild(&quot;1400&quot;),:sigClick,:eventResChange)
 
-		addHandler(@optionsMenu.getChild(&quot;gameOptions&quot;),:sigClick,:eventGameOptions)
-		addHandler(@optionsMenu.getChild(&quot;videoOptions&quot;),:sigClick,:eventVideoOptions)
+    addHandler(@optionsMenu.getChild(&quot;gameOptions&quot;),:sigClick,:eventGameOptions)
+    addHandler(@optionsMenu.getChild(&quot;videoOptions&quot;),:sigClick,:eventVideoOptions)
 
-		addHandler(@optionsMenu.getChild(&quot;optionIntro&quot;),:sigClick,:eventOptionsChanged)
+    addHandler(@optionsMenu.getChild(&quot;optionIntro&quot;),:sigClick,:eventOptionsChanged)
 
-		@optionsMenu.getChild(&quot;optionIntro&quot;).setChecked(getConfig.get(&quot;intro&quot;)!=&quot;false&quot;)
+    @optionsMenu.getChild(&quot;optionIntro&quot;).setChecked(getConfig.get(&quot;intro&quot;)!=&quot;false&quot;)
 
-		# texture quality
-		texQ=@optionsMenu.getChild(&quot;textureQuality&quot;)
-		texQ.setSelected({&quot;1&quot;=&gt;&quot;high&quot;,&quot;2&quot;=&gt;&quot;medium&quot;,&quot;3&quot;=&gt;&quot;low&quot;,nil=&gt;&quot;high&quot;,&quot;&quot;=&gt;&quot;high&quot;}[getConfig.get(&quot;terrainDownScaleExp&quot;)])
-		addHandler(texQ,:sigSelect,:eventTextureQuality)
+    # texture quality
+    texQ=@optionsMenu.getChild(&quot;textureQuality&quot;)
+    texQ.setSelected({&quot;1&quot;=&gt;&quot;high&quot;,&quot;2&quot;=&gt;&quot;medium&quot;,&quot;3&quot;=&gt;&quot;low&quot;,nil=&gt;&quot;high&quot;,&quot;&quot;=&gt;&quot;high&quot;}[getConfig.get(&quot;terrainDownScaleExp&quot;)])
+    addHandler(texQ,:sigSelect,:eventTextureQuality)
 
-		# FBO
-		@optionsMenu.getChild(&quot;UseFBO&quot;).setChecked(getConfig.get(&quot;useFBO&quot;)==&quot;true&quot;)
-		addHandler(@optionsMenu.getChild(&quot;UseFBO&quot;),:sigClick,:eventOptionsChanged)
-		
-		# Anim
-		@optionsMenu.getChild(&quot;UseAnim&quot;).setChecked(getConfig.get(&quot;animationType&quot;)==&quot;true&quot;)
-		addHandler(@optionsMenu.getChild(&quot;UseAnim&quot;),:sigClick,:eventOptionsChanged)
+    # FBO
+    @optionsMenu.getChild(&quot;UseFBO&quot;).setChecked(getConfig.get(&quot;useFBO&quot;)==&quot;true&quot;)
+    addHandler(@optionsMenu.getChild(&quot;UseFBO&quot;),:sigClick,:eventOptionsChanged)
+    
+    # Anim
+    @optionsMenu.getChild(&quot;UseAnim&quot;).setChecked(getConfig.get(&quot;animationType&quot;)==&quot;true&quot;)
+    addHandler(@optionsMenu.getChild(&quot;UseAnim&quot;),:sigClick,:eventOptionsChanged)
 
-		# particle
-		@optionsMenu.getChild(&quot;UseParticle&quot;).setChecked(getConfig.get(&quot;particleEffects&quot;)==&quot;true&quot;)
-		addHandler(@optionsMenu.getChild(&quot;UseParticle&quot;),:sigClick,:eventOptionsChanged)
-	end
+    # particle
+    @optionsMenu.getChild(&quot;UseParticle&quot;).setChecked(getConfig.get(&quot;particleEffects&quot;)==&quot;true&quot;)
+    addHandler(@optionsMenu.getChild(&quot;UseParticle&quot;),:sigClick,:eventOptionsChanged)
+  end
 
 
-	
-	def eventSingleStart(e)
+  
+  def eventSingleStart(e)
 
-		id=@singleMenu.getChild(&quot;list&quot;).getSelectedID
-		if id!=&quot;&quot;
-			soundOff
-			#c=Campaign.new(getWriteDir+&quot;/savegames/&quot;+id)
-			startGame(&quot;data/levels/&quot;+id) #ampaign(c)
-			soundOn
-		end
-		setMainWidget(@mainMenu)
-		return true
+    id=@singleMenu.getChild(&quot;list&quot;).getSelectedID
+    if id!=&quot;&quot;
+      soundOff
+      #c=Campaign.new(getWriteDir+&quot;/savegames/&quot;+id)
+      startGame(&quot;data/levels/&quot;+id) #ampaign(c)
+      soundOn
+    end
+    setMainWidget(@mainMenu)
+    return true
 
-	end
+  end
 
 
 
 
-	# CREDITS MENU
-	def setupCredits
-		@creditsMenu=AGLayout.new(nil)
-		@creditsMenu.loadXML(loadFile(&quot;data/gui/layout/credits.xml&quot;))
-		@menues.push(@creditsMenu)
-		addHandler(@creditsMenu.getChild(&quot;exit&quot;),:sigClick,:eventExit)
+  # CREDITS MENU
+  def setupCredits
+    @creditsMenu=AGLayout.new(nil)
+    @creditsMenu.loadXML(loadFile(&quot;data/gui/layout/credits.xml&quot;))
+    @menues.push(@creditsMenu)
+    addHandler(@creditsMenu.getChild(&quot;exit&quot;),:sigClick,:eventExit)
 
-		@creditsMenu.getChild(&quot;ticker&quot;).menuapp=self
-	end
+    @creditsMenu.getChild(&quot;ticker&quot;).menuapp=self
+  end
 
-	# CAMPAIGN MENU	
-	def setupCampaign
-		@campaignMenu=AGLayout.new(nil)
-		@campaignMenu.loadXML(loadFile(&quot;data/gui/layout/campaign.xml&quot;))
-		@menues.push(@campaignMenu)
-		addHandler(@campaignMenu.getChild(&quot;exit&quot;),:sigClick,:eventExit)
-		addHandler(@campaignMenu.getChild(&quot;start&quot;),:sigClick,:eventStart)
-		
-		@campaigns=getCampaigns
-		
-		buttonCount=6
-		campaignButtons=(0..(buttonCount-1)).to_a.collect{|c|&quot;campaign#{c}&quot;}
-		i=0
-		campaignButtons.each{|b|
-			c=@campaignMenu.getChild(b)
-			addHandler(c,:sigClick,:eventMission)
-			if @campaigns.length&gt;i
-				c.setCaption(_(@campaigns[i].name))
-			else
-				c.hide
-			end
-			i+=1
-		}
-	end
+  # CAMPAIGN MENU  
+  def setupCampaign
+    @campaignMenu=AGLayout.new(nil)
+    @campaignMenu.loadXML(loadFile(&quot;data/gui/layout/campaign.xml&quot;))
+    @menues.push(@campaignMenu)
+    addHandler(@campaignMenu.getChild(&quot;exit&quot;),:sigClick,:eventExit)
+    addHandler(@campaignMenu.getChild(&quot;start&quot;),:sigClick,:eventStart)
+    
+    @campaigns=getCampaigns
+    
+    buttonCount=6
+    campaignButtons=(0..(buttonCount-1)).to_a.collect{|c|&quot;campaign#{c}&quot;}
+    i=0
+    campaignButtons.each{|b|
+      c=@campaignMenu.getChild(b)
+      addHandler(c,:sigClick,:eventMission)
+      if @campaigns.length&gt;i
+        c.setCaption(_(@campaigns[i].name))
+      else
+        c.hide
+      end
+      i+=1
+    }
+  end
 
-	# :section: Campaign Menu Event Handlers
+  # :section: Campaign Menu Event Handlers
 
-	def eventMission(e)
-		callerName=e.getCaller.getName
-		number=callerName[8..12].to_i
-		@selCampaign=@campaigns[number]
-		@campaignMenu.getChild(&quot;campaignImage&quot;).setTexture(@selCampaign.texture)
-		@campaignMenu.getChild(&quot;campaignDescription&quot;).setText(_(@selCampaign.description))
-		return true
-	end
-	
-	def eventStart(e)
-		if @selCampaign
-			soundOff
-			#startGame(@selCampaign)
-			startCampaign(@selCampaign)
-			soundOn
-		end
-		return true
-	end
-	
-	# :section: Options Menu Event handlers
-	
-	def eventTextureQuality(e)
-		scale={&quot;low&quot;=&gt;3,&quot;medium&quot;=&gt;2,&quot;high&quot;=&gt;1}[@optionsMenu.getChild(&quot;textureQuality&quot;).getSelected]
-		getConfig.set(&quot;terrainDownScaleExp&quot;,scale.to_s)
-		getConfig.set(&quot;meshDownScaleExp&quot;,scale.to_s)
-		return true
-	end
+  def eventMission(e)
+    callerName=e.getCaller.getName
+    number=callerName[8..12].to_i
+    @selCampaign=@campaigns[number]
+    @campaignMenu.getChild(&quot;campaignImage&quot;).setTexture(@selCampaign.texture)
+    @campaignMenu.getChild(&quot;campaignDescription&quot;).setText(_(@selCampaign.description))
+    return true
+  end
+  
+  def eventStart(e)
+    if @selCampaign
+      soundOff
+      #startGame(@selCampaign)
+      startCampaign(@selCampaign)
+      soundOn
+    end
+    return true
+  end
+  
+  # :section: Options Menu Event handlers
+  
+  def eventTextureQuality(e)
+    scale={&quot;low&quot;=&gt;3,&quot;medium&quot;=&gt;2,&quot;high&quot;=&gt;1}[@optionsMenu.getChild(&quot;textureQuality&quot;).getSelected]
+    getConfig.set(&quot;terrainDownScaleExp&quot;,scale.to_s)
+    getConfig.set(&quot;meshDownScaleExp&quot;,scale.to_s)
+    return true
+  end
 
-	def eventOptionsChanged(e)
-		case e.getCaller.getName
-			when &quot;optionIntro&quot;
-				getConfig.set(&quot;intro&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at optionsMenu.getChild</A>(&quot;optionIntro&quot;).isChecked.to_s)
-				#getScreen.screenshot.save(&quot;muh76.png&quot;)
-			when &quot;UseFBO&quot;
-				getConfig.set(&quot;useFBO&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at optionsMenu.getChild</A>(&quot;UseFBO&quot;).isChecked.to_s)
-			when &quot;UseAnim&quot;
-				getConfig.set(&quot;animationType&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at optionsMenu.getChild</A>(&quot;UseAnim&quot;).isChecked.to_s)
-			when &quot;UseParticle&quot;
-				getConfig.set(&quot;particleEffects&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at optionsMenu.getChild</A>(&quot;UseParticle&quot;).isChecked.to_s)
-		end
-	end
+  def eventOptionsChanged(e)
+    case e.getCaller.getName
+      when &quot;optionIntro&quot;
+        getConfig.set(&quot;intro&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at optionsMenu.getChild</A>(&quot;optionIntro&quot;).isChecked.to_s)
+        #getScreen.screenshot.save(&quot;muh76.png&quot;)
+      when &quot;UseFBO&quot;
+        getConfig.set(&quot;useFBO&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at optionsMenu.getChild</A>(&quot;UseFBO&quot;).isChecked.to_s)
+      when &quot;UseAnim&quot;
+        getConfig.set(&quot;animationType&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at optionsMenu.getChild</A>(&quot;UseAnim&quot;).isChecked.to_s)
+      when &quot;UseParticle&quot;
+        getConfig.set(&quot;particleEffects&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at optionsMenu.getChild</A>(&quot;UseParticle&quot;).isChecked.to_s)
+    end
+  end
 
-	def eventVideoOptions
-		@optionSubMenus.each{|m|@optionsMenu.getChild(m).hide}
-		@optionsMenu.getChild(&quot;VideoOptionsMenu&quot;).show
-	end
-	def eventGameOptions
-		@optionSubMenus.each{|m|@optionsMenu.getChild(m).hide}
-		@optionsMenu.getChild(&quot;GameOptionsMenu&quot;).show
-	end
+  def eventVideoOptions
+    @optionSubMenus.each{|m|@optionsMenu.getChild(m).hide}
+    @optionsMenu.getChild(&quot;VideoOptionsMenu&quot;).show
+  end
+  def eventGameOptions
+    @optionSubMenus.each{|m|@optionsMenu.getChild(m).hide}
+    @optionsMenu.getChild(&quot;GameOptionsMenu&quot;).show
+  end
 
-	def eventFullscreen
-		getMain.getVideo.initVideo(getMain.getVideo.realWidth,getMain.getVideo.realHeight,32,(not getMain.getVideo.fullscreen),true,1024,768)
-		getConfig.set(&quot;fullscreen&quot;,getMain.getVideo.fullscreen.to_s)
-		return true
-	end
+  def eventFullscreen
+    getMain.getVideo.initVideo(getMain.getVideo.realWidth,getMain.getVideo.realHeight,32,(not getMain.getVideo.fullscreen),true,1024,768)
+    getConfig.set(&quot;fullscreen&quot;,getMain.getVideo.fullscreen.to_s)
+    return true
+  end
 
-	def eventResChange(e)
-		case e.getCaller.getName
-			when &quot;640&quot;
-				setRes(640,480)
-			when &quot;800&quot;
-				setRes(800,600)
-			when &quot;1024&quot;
-				setRes(1024,768)
-			when &quot;1280&quot;
-				setRes(1280,1024)
-			when &quot;1400&quot;
-				setRes(1400,1050)
-		end
-		return true
-	end
+  def eventResChange(e)
+    case e.getCaller.getName
+      when &quot;640&quot;
+        setRes(640,480)
+      when &quot;800&quot;
+        setRes(800,600)
+      when &quot;1024&quot;
+        setRes(1024,768)
+      when &quot;1280&quot;
+        setRes(1280,1024)
+      when &quot;1400&quot;
+        setRes(1400,1050)
+    end
+    return true
+  end
 
-	
+  
 
 
-	# :section: Global Event Handlers
+  # :section: Global Event Handlers
 
-	# simple frame-event-handler - only counts how much FPS we have
-	# and displays this on CLI
-	def eventFrame(t)
-		delay(5)
-		@frameTime||=0
-		@frames||=0
-		@frameTime+=t
-		@frames+=1
-		if @frames&gt;100
-			log &quot;FPS:#{100.0/@frameTime}&quot;
-			@frameTime=0
-			@frames=0
-		end
-		return true
-	end
-	# idle-event - sets a delay of 20ms
-	def eventIdle
-		delay(20)
-		return true
-	end
+  # simple frame-event-handler - only counts how much FPS we have
+  # and displays this on CLI
+  def eventFrame(t)
+    delay(5)
+    @frameTime||=0
+    @frames||=0
+    @frameTime+=t
+    @frames+=1
+    if @frames&gt;100
+      log &quot;FPS:#{100.0/@frameTime}&quot;
+      @frameTime=0
+      @frames=0
+    end
+    return true
+  end
+  # idle-event - sets a delay of 20ms
+  def eventIdle
+    delay(20)
+    return true
+  end
 
-	# quits the application (is called by the Quit-button in the main-menu
-	# current you won't be asked if this is ok.
-	def eventQuit(e)
-		tryQuit
-		return true
-	end
+  # quits the application (is called by the Quit-button in the main-menu
+  # current you won't be asked if this is ok.
+  def eventQuit(e)
+    tryQuit
+    return true
+  end
 
 
-	# event-handler for end of music-playing
-	# start another track (a different one)
-	def eventMusicEnd
-		if @sound
-			getSoundManager.playMp3(&quot;data/music/calm1.ogg&quot;)
-		end
-		return true
-	end
+  # event-handler for end of music-playing
+  # start another track (a different one)
+  def eventMusicEnd
+    if @sound
+      getSoundManager.playMp3(&quot;data/music/calm1.ogg&quot;)
+    end
+    return true
+  end
 
-	# -------------------------------
-	# :section: Menu Event Handlers
-	# -------------------------------
+  # -------------------------------
+  # :section: Menu Event Handlers
+  # -------------------------------
 
-	# called by exit-button in submenus and always exits to mainmenu	
-	def eventExit(e)
-		setMainWidget(@mainMenu)
-		return true
-	end
+  # called by exit-button in submenus and always exits to mainmenu  
+  def eventExit(e)
+    setMainWidget(@mainMenu)
+    return true
+  end
 
-	# -------------------------------
-	# :section: Main Menu Event Handlers
-	# -------------------------------
-	
-	# open the credits screen
-	def eventCredits(e)
-		setMainWidget(@creditsMenu)
-		return true
-	end
-	# go to the single-game selection screen
-	def eventSingle(e)
-		setMainWidget(@singleMenu)
-		return true
-	end
-	# start the tutorial-campaign directly for new users, so
-	# they won't have to deal with &quot;campaigning&quot;, where tutorial can be found, too
-	def eventTutorial(e)
-		tutCampaign=Campaign.new(&quot;data/campaigns/tutorial.xml&quot;)
-		soundOff
-		startCampaign(tutCampaign)
-		soundOn
-		return true
-	end
-	# go to the campaign-selection screen
-	def eventCampaign(e)
-		setMainWidget(@campaignMenu)
-		return true
-	end
-	# loading a game-screen will follow after this event
-	def eventLoadGame(e)
-		updateLoadMenu
-		setMainWidget(@loadMenu)
-		return true
-	end
-	# go to the options-screen
-	def eventOptions(e)
-		setMainWidget(@optionsMenu)
-		return true
-	end
+  # -------------------------------
+  # :section: Main Menu Event Handlers
+  # -------------------------------
+  
+  # open the credits screen
+  def eventCredits(e)
+    setMainWidget(@creditsMenu)
+    return true
+  end
+  # go to the single-game selection screen
+  def eventSingle(e)
+    setMainWidget(@singleMenu)
+    return true
+  end
+  # start the tutorial-campaign directly for new users, so
+  # they won't have to deal with &quot;campaigning&quot;, where tutorial can be found, too
+  def eventTutorial(e)
+    tutCampaign=Campaign.new(&quot;data/campaigns/tutorial.xml&quot;)
+    soundOff
+    startCampaign(tutCampaign)
+    soundOn
+    return true
+  end
+  # go to the campaign-selection screen
+  def eventCampaign(e)
+    setMainWidget(@campaignMenu)
+    return true
+  end
+  # loading a game-screen will follow after this event
+  def eventLoadGame(e)
+    updateLoadMenu
+    setMainWidget(@loadMenu)
+    return true
+  end
+  # go to the options-screen
+  def eventOptions(e)
+    setMainWidget(@optionsMenu)
+    return true
+  end
 
 
-	
+  
 protected
-	# -------------------------------
-	# :section: changing settings
-	# -------------------------------
+  # -------------------------------
+  # :section: changing settings
+  # -------------------------------
 
-	# fades the sound out
-	def soundOff
-		@sound=false
-		getSoundManager.fadeOutMusic(1000)
-	end
+  # fades the sound out
+  def soundOff
+    @sound=false
+    getSoundManager.fadeOutMusic(1000)
+  end
 
-	# if there is music running it gets stopped
-	# and eventMusicEnd is called, so that a new track is started
-	def soundOn
-		@sound=true
-		getSoundManager.stopMp3
-		eventMusicEnd
-	end	
+  # if there is music running it gets stopped
+  # and eventMusicEnd is called, so that a new track is started
+  def soundOn
+    @sound=true
+    getSoundManager.stopMp3
+    eventMusicEnd
+  end  
 
-	# switch to the video-resolution with pixel-width *w* and height *h*
-	def setRes(w,h)
-		getMain.getVideo.initVideo(w,h,32,true,true,1024,768) #getMain.fullscreen,true)
-		getConfig.set(&quot;xRes&quot;,getMain.getVideo.realWidth.to_s)
-		getConfig.set(&quot;yRes&quot;,getMain.getVideo.realHeight.to_s)
-		#puts getSurfaceManager.getUsedTexMem
-		#raise 1
-	end
+  # switch to the video-resolution with pixel-width *w* and height *h*
+  def setRes(w,h)
+    getMain.getVideo.initVideo(w,h,32,true,true,1024,768) #getMain.fullscreen,true)
+    getConfig.set(&quot;xRes&quot;,getMain.getVideo.realWidth.to_s)
+    getConfig.set(&quot;yRes&quot;,getMain.getVideo.realHeight.to_s)
+    #puts getSurfaceManager.getUsedTexMem
+    #raise 1
+  end
 
 end
 

Modified: antargis/trunk/ruby/map_generator.rb
===================================================================
--- antargis/trunk/ruby/map_generator.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/map_generator.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -19,220 +19,220 @@
 #
 
 class GeneratorParameters
-	attr_accessor :size,:water,:hills,:population,:enemies
-	attr_reader :params
-	def initialize
-		@params=[:size,:water,:hills,:population,:enemies]
-		@size=128
-		@water=0.4
-		@hills=1
-		@population=40
-		@enemies=2
-	end
-	def readFromDialog(d)
-		@params.each{|p|
-			v=d.edits[p].getText.to_s
-			case p	
-				when :water
-					v=v.to_f
-				else
-					v=v.to_i
-			end
-			eval(&quot;self.#{p}=v&quot;)
-		}
-	end
+  attr_accessor :size,:water,:hills,:population,:enemies
+  attr_reader :params
+  def initialize
+    @params=[:size,:water,:hills,:population,:enemies]
+    @size=128
+    @water=0.4
+    @hills=1
+    @population=40
+    @enemies=2
+  end
+  def readFromDialog(d)
+    @params.each{|p|
+      v=d.edits[p].getText.to_s
+      case p  
+        when :water
+          v=v.to_f
+        else
+          v=v.to_i
+      end
+      eval(&quot;self.#{p}=v&quot;)
+    }
+  end
 end
 
 def addFlatOnMap(map,x,y,amount,size)
-	w=map.getW
-	h=map.getH
-	s2=size/2
-	x0=[0,w-1,x-s2].sort[1].to_i
-	x1=[0,w-1,x+s2].sort[1].to_i
-	y0=[0,w-1,y-s2].sort[1].to_i
-	y1=[0,w-1,y+s2].sort[1].to_i
-	(x0..x1).each{|mx|
-		(y0..y1).each{|my|
-			if (mx-x)**2+(my-y)**2&lt;s2**2
-				h=map.get(mx,my)
-				a=[amount+h,rand*2+6].min # not too high
-				map.set(mx,my,a)
-			end
-		}
-	}
+  w=map.getW
+  h=map.getH
+  s2=size/2
+  x0=[0,w-1,x-s2].sort[1].to_i
+  x1=[0,w-1,x+s2].sort[1].to_i
+  y0=[0,w-1,y-s2].sort[1].to_i
+  y1=[0,w-1,y+s2].sort[1].to_i
+  (x0..x1).each{|mx|
+    (y0..y1).each{|my|
+      if (mx-x)**2+(my-y)**2&lt;s2**2
+        h=map.get(mx,my)
+        a=[amount+h,rand*2+6].min # not too high
+        map.set(mx,my,a)
+      end
+    }
+  }
 end
 
 def addFlatOnMapTerrain(map,x,y,amount,size,tt)
-	w=map.getW
-	h=map.getH
-	s2=size/2
-	x0=[0,w-1,x-s2].sort[1].to_i
-	x1=[0,w-1,x+s2].sort[1].to_i
-	y0=[0,w-1,y-s2].sort[1].to_i
-	y1=[0,w-1,y+s2].sort[1].to_i
-	(x0..x1).each{|mx|
-		(y0..y1).each{|my|
-			if (mx-x)**2+(my-y)**2&lt;s2**2
-				h=map.getTerrain(mx,my,tt)
-				a=[amount+h,rand*2+6].min # not too high
-				map.setTerrain(mx,my,tt,a)
-			end
-		}
-	}
+  w=map.getW
+  h=map.getH
+  s2=size/2
+  x0=[0,w-1,x-s2].sort[1].to_i
+  x1=[0,w-1,x+s2].sort[1].to_i
+  y0=[0,w-1,y-s2].sort[1].to_i
+  y1=[0,w-1,y+s2].sort[1].to_i
+  (x0..x1).each{|mx|
+    (y0..y1).each{|my|
+      if (mx-x)**2+(my-y)**2&lt;s2**2
+        h=map.getTerrain(mx,my,tt)
+        a=[amount+h,rand*2+6].min # not too high
+        map.setTerrain(mx,my,tt,a)
+      end
+    }
+  }
 end
 
 def blurMap(map)
-	vps=[[0,0],[1,0],[0,1],[1,1]]
-	(0..(map.getW-2)).each{|x|
-		(0..(map.getH-2)).each{|y|
-			c=0
-			vps.each{|v|
-				c+=map.get(x+v[0],y+v[1])
-			}
-			c/=vps.length
-			map.set(x,y,c)
-		}
-	}
+  vps=[[0,0],[1,0],[0,1],[1,1]]
+  (0..(map.getW-2)).each{|x|
+    (0..(map.getH-2)).each{|y|
+      c=0
+      vps.each{|v|
+        c+=map.get(x+v[0],y+v[1])
+      }
+      c/=vps.length
+      map.set(x,y,c)
+    }
+  }
 end
 
 # ensure that beaches are steep enough, so that water doesn't run too far
 def checkBeachSteepness(map)
-	thres=0.1
-	(0..(map.getW-1)).each{|x|
-		(0..(map.getH-1)).each{|y|
-			h=map.get(x,y)
-			if h&gt;-thres and h&lt;0
-				h=-thres
-			elsif h&gt;=0 and h&lt;thres
-				h=thres
-			end
-			map.set(x,y,h)
-		}
-	}
+  thres=0.1
+  (0..(map.getW-1)).each{|x|
+    (0..(map.getH-1)).each{|y|
+      h=map.get(x,y)
+      if h&gt;-thres and h&lt;0
+        h=-thres
+      elsif h&gt;=0 and h&lt;thres
+        h=thres
+      end
+      map.set(x,y,h)
+    }
+  }
 end
 
 def addWaterTerrain(map)
-	tt=WATER
-	(0..(map.getW-1)).each{|x|
-		(0..(map.getH-1)).each{|y|
-			if map.get(x,y)&lt;0
-				map.setTerrain(x,y,tt,0.7)
-			end
-		}
-	}
+  tt=WATER
+  (0..(map.getW-1)).each{|x|
+    (0..(map.getH-1)).each{|y|
+      if map.get(x,y)&lt;0
+        map.setTerrain(x,y,tt,0.7)
+      end
+    }
+  }
 end
 
 def blurTerrain(map,tt)
-	vps=[[0,0],[1,0],[0,1],[1,1]]
-	(0..(map.getW-2)).each{|x|
-		(0..(map.getH-2)).each{|y|
-			c=0
-			vps.each{|v|
-				c+=map.getTerrain(x+v[0],y+v[1],tt)
-			}
-			c/=vps.length
-			map.setTerrain(x,y,tt,c)
-		}
-	}
+  vps=[[0,0],[1,0],[0,1],[1,1]]
+  (0..(map.getW-2)).each{|x|
+    (0..(map.getH-2)).each{|y|
+      c=0
+      vps.each{|v|
+        c+=map.getTerrain(x+v[0],y+v[1],tt)
+      }
+      c/=vps.length
+      map.setTerrain(x,y,tt,c)
+    }
+  }
 end
 
 def addGrass(map)
-	tt=GRASS
-	thres=0.3
-	(0..(map.getW-1)).each{|x|
-		(0..(map.getH-1)).each{|y|
-			if map.get(x,y)&gt;thres
-				map.setTerrain(x,y,tt,rand)
-			end
-		}
-	}
-	
-	tt=GRASS2
-	thres=1.3
-	(0..(map.getW-1)).each{|x|
-		(0..(map.getH-1)).each{|y|
-			if map.get(x,y)&gt;thres
-#				map.setTerrain(x,y,tt,rand)
-				r=rand
-				map.setTerrain(x,y,tt,r)
-				if r&gt;0.97
-					# add tree
-					t=AntGrass.new(map)
-					t.setPos(AGVector2.new(x,y))
-					map.insertEntity(t)
-				end
-			end
-		}
-	}
+  tt=GRASS
+  thres=0.3
+  (0..(map.getW-1)).each{|x|
+    (0..(map.getH-1)).each{|y|
+      if map.get(x,y)&gt;thres
+        map.setTerrain(x,y,tt,rand)
+      end
+    }
+  }
+  
+  tt=GRASS2
+  thres=1.3
+  (0..(map.getW-1)).each{|x|
+    (0..(map.getH-1)).each{|y|
+      if map.get(x,y)&gt;thres
+#        map.setTerrain(x,y,tt,rand)
+        r=rand
+        map.setTerrain(x,y,tt,r)
+        if r&gt;0.97
+          # add tree
+          t=AntGrass.new(map)
+          t.setPos(AGVector2.new(x,y))
+          map.insertEntity(t)
+        end
+      end
+    }
+  }
 end
 
 def addRock(map)
-	w=map.getW
-	h=map.getH
-	flat=[[5,10],[4,10],[3,20],[2,20]]
-	flat.each{|add|
-		for i in 1..add[1]
-			rad=add[0]
-			x=rand*(w-2*rad)+rad
-			y=rand*(h-2*rad)+rad
-			#map.addFlat(x,y,30,rad)
-			if map.get(x.to_i,y.to_i)&gt;1
-				addFlatOnMapTerrain(map,x,y,1,rad,ROCK)
-			end
-		end
-	}
+  w=map.getW
+  h=map.getH
+  flat=[[5,10],[4,10],[3,20],[2,20]]
+  flat.each{|add|
+    for i in 1..add[1]
+      rad=add[0]
+      x=rand*(w-2*rad)+rad
+      y=rand*(h-2*rad)+rad
+      #map.addFlat(x,y,30,rad)
+      if map.get(x.to_i,y.to_i)&gt;1
+        addFlatOnMapTerrain(map,x,y,1,rad,ROCK)
+      end
+    end
+  }
 end
 
 def addForest(map)
-	tt=FOREST
-	thres=1.0
-	(0..(map.getW-1)).each{|x|
-		(0..(map.getH-1)).each{|y|
-			if map.get(x,y)&gt;thres
-				r=rand
-				map.setTerrain(x,y,tt,r)
-				if r&gt;0.97 and map.getTerrain(x,y,ROCK)&lt;0.3
-					# add tree
-					t=AntTree.new(map)
-					t.setPos(AGVector2.new(x,y))
-					map.insertEntity(t)
-				end
-			end
-		}
-	}
+  tt=FOREST
+  thres=1.0
+  (0..(map.getW-1)).each{|x|
+    (0..(map.getH-1)).each{|y|
+      if map.get(x,y)&gt;thres
+        r=rand
+        map.setTerrain(x,y,tt,r)
+        if r&gt;0.97 and map.getTerrain(x,y,ROCK)&lt;0.3
+          # add tree
+          t=AntTree.new(map)
+          t.setPos(AGVector2.new(x,y))
+          map.insertEntity(t)
+        end
+      end
+    }
+  }
 end
 
 
 def generateMap(map,params)
-	w=params.size
-	h=params.size
+  w=params.size
+  h=params.size
 
-	map.newMap(w,h)
-	getMap.setHeight(2) # everything deep water
+  map.newMap(w,h)
+  getMap.setHeight(2) # everything deep water
 
- 		flat=[[30,10],[15,20],[10,8],[5,40],[4,10],[3,20],[2,20],[1,70]]
- 		flat.each{|add|
- 			for i in 1..add[1]
- 				rad=add[0]
- 				x=rand*(w-2*rad)+rad
- 				y=rand*(h-2*rad)+rad
- 				#map.addFlat(x,y,30,rad)
-				addFlatOnMap(map,x,y,2,rad)
- 			end
- 		}
+     flat=[[30,10],[15,20],[10,8],[5,40],[4,10],[3,20],[2,20],[1,70]]
+     flat.each{|add|
+       for i in 1..add[1]
+         rad=add[0]
+         x=rand*(w-2*rad)+rad
+         y=rand*(h-2*rad)+rad
+         #map.addFlat(x,y,30,rad)
+        addFlatOnMap(map,x,y,2,rad)
+       end
+     }
 
-	blurMap(map)
-	blurMap(map)
-	blurMap(map)
-	
-	checkBeachSteepness(map)
+  blurMap(map)
+  blurMap(map)
+  blurMap(map)
+  
+  checkBeachSteepness(map)
 
-	addWaterTerrain(map)
-	blurTerrain(map,WATER)
+  addWaterTerrain(map)
+  blurTerrain(map,WATER)
 
-	addGrass(map)
-	addRock(map)
-	addForest(map)
+  addGrass(map)
+  addRock(map)
+  addForest(map)
 
-	map.mapChanged
-end
\ No newline at end of file
+  map.mapChanged
+end

Modified: antargis/trunk/ruby/map_generator2.rb
===================================================================
--- antargis/trunk/ruby/map_generator2.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/map_generator2.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -3,519 +3,519 @@
 require 'ruby/antargislib.rb'
 
 class Array
-	def cross(p)
-		n=[]
-		self.each{|x|
-			p.each{|y|
-				n&lt;&lt;=[x,y]
-			}
-		}
-		n
-	end
+  def cross(p)
+    n=[]
+    self.each{|x|
+      p.each{|y|
+        n&lt;&lt;=[x,y]
+      }
+    }
+    n
+  end
 end
 
 
 class MyBaseMap
-	attr_reader :w,:h
-	def initialize(pw,ph)
-		@w=pw
-		@h=ph
-		@a=[]
-		(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
-			(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
-				set(x,y,:undefined)
-			}
-		}
-	end
-	def set(x,y,v)
-		@a[<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at w</A>*y]=v
-	end
-	def get(x,y)
-		return :undefined unless x&gt;0 and x&lt;=@w and y&gt;0 and y&lt;=@h
-		@a[<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at w</A>*y]
-	end
-	def to_surface
-		i=AGSurface.new(w,h)
-		
-		begin
-			p=AGPainter.new(i)
-			(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
-				(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
-					c=getColor(x,y)
-					p.putPixel(AGVector2.new(x-1,y-1),c)
-				}
-			}
-		end
-		i
-	end
-	def getColor(x,y)
-		t=get(x,y)
-		c=toColor(t)
-	end
+  attr_reader :w,:h
+  def initialize(pw,ph)
+    @w=pw
+    @h=ph
+    @a=[]
+    (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
+      (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
+        set(x,y,:undefined)
+      }
+    }
+  end
+  def set(x,y,v)
+    @a[<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at w</A>*y]=v
+  end
+  def get(x,y)
+    return :undefined unless x&gt;0 and x&lt;=@w and y&gt;0 and y&lt;=@h
+    @a[<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at w</A>*y]
+  end
+  def to_surface
+    i=AGSurface.new(w,h)
+    
+    begin
+      p=AGPainter.new(i)
+      (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
+        (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
+          c=getColor(x,y)
+          p.putPixel(AGVector2.new(x-1,y-1),c)
+        }
+      }
+    end
+    i
+  end
+  def getColor(x,y)
+    t=get(x,y)
+    c=toColor(t)
+  end
 
-	def toColor(t)
-		case t
-			when :undefined
-				return AGColor.new(0xFF,0x70,0)
-			when :water
-				return AGColor.new(0,0,0x70)
-			when :green
-				return AGColor.new(0,0xFF,0)
-			when :wood
-				return AGColor.new(0,0x7F,0)
-			when :rock
-				return AGColor.new(0x7f,0x7F,0x7f)
-		end
-		return AGColor.new(0,0,0)
-	end
+  def toColor(t)
+    case t
+      when :undefined
+        return AGColor.new(0xFF,0x70,0)
+      when :water
+        return AGColor.new(0,0,0x70)
+      when :green
+        return AGColor.new(0,0xFF,0)
+      when :wood
+        return AGColor.new(0,0x7F,0)
+      when :rock
+        return AGColor.new(0x7f,0x7F,0x7f)
+    end
+    return AGColor.new(0,0,0)
+  end
 end
 
 class MyMap&lt;MyBaseMap
-	def initialize(w,h)
-		super
-		initRandom
-	end
+  def initialize(w,h)
+    super
+    initRandom
+  end
 
 
-	def putAtRandPos(v)
-		x=rand*@w.to_i+1
-		y=rand*@h.to_i+1
-		set(x,y,v)
-	end
+  def putAtRandPos(v)
+    x=rand*@w.to_i+1
+    y=rand*@h.to_i+1
+    set(x,y,v)
+  end
 
-	def someX(amount,what)
-		(1..amount).each{|v|
-			putAtRandPos(what)
-		}
-	end
+  def someX(amount,what)
+    (1..amount).each{|v|
+      putAtRandPos(what)
+    }
+  end
 
-	def blurAt(x,y)
-		cv=get(x,y)
-		return nil unless cv==:undefined
-		what={}
-		(-1..1).each{|dx|
-			(-1..1).each{|dy|
-				t=get(x+dx,y+dy)
-				what[t]||=0
-				what[t]+=1
-			}
-		}
-		what[:undefined]=0
-		ps=[]
-		what.each{|k,v|
-			ps.push([k,v])
-		}
-		ps=ps.shuffle.sort{|a,b|b[1]&lt;=&gt;a[1]}
-		#puts ps[0][0]
-		ps[0][0]
-	end
+  def blurAt(x,y)
+    cv=get(x,y)
+    return nil unless cv==:undefined
+    what={}
+    (-1..1).each{|dx|
+      (-1..1).each{|dy|
+        t=get(x+dx,y+dy)
+        what[t]||=0
+        what[t]+=1
+      }
+    }
+    what[:undefined]=0
+    ps=[]
+    what.each{|k,v|
+      ps.push([k,v])
+    }
+    ps=ps.shuffle.sort{|a,b|b[1]&lt;=&gt;a[1]}
+    #puts ps[0][0]
+    ps[0][0]
+  end
 
 
-	def initRandom
-		@cs=[]
-		(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
-			(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
-				@cs&lt;&lt;[x,y]
-			}
-		}
-		
-		@cs=@cs.shuffle
-	end
+  def initRandom
+    @cs=[]
+    (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
+      (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
+        @cs&lt;&lt;[x,y]
+      }
+    }
+    
+    @cs=@cs.shuffle
+  end
 
-	def blur
-		modified=false
-		@cs.each{|p|
-			x,y=p
-			v=blurAt(x,y)
-			if v.nil?
-				#modified=true
-			elsif v!=:undefined
-				set(x,y,v)
-				modified=true
-			end
-		}
-		modified
-	end
+  def blur
+    modified=false
+    @cs.each{|p|
+      x,y=p
+      v=blurAt(x,y)
+      if v.nil?
+        #modified=true
+      elsif v!=:undefined
+        set(x,y,v)
+        modified=true
+      end
+    }
+    modified
+  end
 
-	def blurAll
-		modified=true
-		tries=0
-		while modified and tries&lt;1000
-			modified=blur
-			tries+=1
-		end
-	end
+  def blurAll
+    modified=true
+    tries=0
+    while modified and tries&lt;1000
+      modified=blur
+      tries+=1
+    end
+  end
 end
 
 class MyHeightMap&lt;MyMap
-	def initialize(pw,ph)
-		super
-		@hs=[]
-		@hschange=[]
-		@dist=[]
-		@ndist=[]
-		(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
-			(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
-				setHeight(x,y,0)
-			}
-		}
-		applyHeightChanges
-	end
-	def setHeight(x,y,v)
-		@hschange[<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at w</A>*y]=v
-	end
-	def applyHeightChanges
-		@hs=@hschange.clone
-	end
-	def getHeight(x,y)
-		return 0 unless x&gt;0 and x&lt;=@w and y&gt;0 and y&lt;=@h
-		@hs[<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at w</A>*y]
-	end
+  def initialize(pw,ph)
+    super
+    @hs=[]
+    @hschange=[]
+    @dist=[]
+    @ndist=[]
+    (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
+      (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
+        setHeight(x,y,0)
+      }
+    }
+    applyHeightChanges
+  end
+  def setHeight(x,y,v)
+    @hschange[<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at w</A>*y]=v
+  end
+  def applyHeightChanges
+    @hs=@hschange.clone
+  end
+  def getHeight(x,y)
+    return 0 unless x&gt;0 and x&lt;=@w and y&gt;0 and y&lt;=@h
+    @hs[<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at w</A>*y]
+  end
 
 
-	def computeHeights(type)
-		puts &quot;computing height #{type}&quot;
-		(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
-			(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
-				addRandomHeight(x,y,type)
-			}
-		}
-		applyHeightChanges
-	end
+  def computeHeights(type)
+    puts &quot;computing height #{type}&quot;
+    (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
+      (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
+        addRandomHeight(x,y,type)
+      }
+    }
+    applyHeightChanges
+  end
 
-	def blurHeights(w)
-		a=filterMatrix(w)
-# 		a=[1,2,1]
-# 		case w
-# 			when 5
-# 				a=[1,6,15,20,15,6,1]
-# 			when 4
-# 				a=[1,5,10,10,5,1]
-# 			when 3
-# 				a=[1,4,6,4,1]
-# 			when 2
-# 				a=[1,3,3,1]
-# 		end
-		n=crossProductVecVec(a,a)
-		arr=toIndexMap(n)
+  def blurHeights(w)
+    a=filterMatrix(w)
+#     a=[1,2,1]
+#     case w
+#       when 5
+#         a=[1,6,15,20,15,6,1]
+#       when 4
+#         a=[1,5,10,10,5,1]
+#       when 3
+#         a=[1,4,6,4,1]
+#       when 2
+#         a=[1,3,3,1]
+#     end
+    n=crossProductVecVec(a,a)
+    arr=toIndexMap(n)
 
-		f=arr.inject(0){|a,b|a+b[2]}
-	
-		(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
-			(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
-				v=0
-				arr.each{|p|
-					v+=getHeight(x+p[0],y+p[1])*p[2]
-				}
-				v/=f
-					
-				setHeight(x,y,v)
-			}
-		}
-		applyHeightChanges
-	end
+    f=arr.inject(0){|a,b|a+b[2]}
+  
+    (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
+      (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
+        v=0
+        arr.each{|p|
+          v+=getHeight(x+p[0],y+p[1])*p[2]
+        }
+        v/=f
+          
+        setHeight(x,y,v)
+      }
+    }
+    applyHeightChanges
+  end
 
-	def addRandomHeight(x,y,type)
-		v=get(x,y)
-		r=range(v,type)
-		h=r[0]+(r[1]-r[0])*rand
-		setHeight(x,y,getHeight(x,y)+h)
-	end
+  def addRandomHeight(x,y,type)
+    v=get(x,y)
+    r=range(v,type)
+    h=r[0]+(r[1]-r[0])*rand
+    setHeight(x,y,getHeight(x,y)+h)
+  end
 
-	def getShadow(x,y)
-		a=[[-1,0,-1],
-				[0,-1,-1],
-				[1,0,1],
-				[0,1,1]]
-		v=0
-		a.each{|t|
-			v+=getHeight(x+t[0],y+t[1])*t[2]
-		}
-		v=[-0.5,v,0.5].sort[1]
-		#puts v
-		0.5+v
-	end
+  def getShadow(x,y)
+    a=[[-1,0,-1],
+        [0,-1,-1],
+        [1,0,1],
+        [0,1,1]]
+    v=0
+    a.each{|t|
+      v+=getHeight(x+t[0],y+t[1])*t[2]
+    }
+    v=[-0.5,v,0.5].sort[1]
+    #puts v
+    0.5+v
+  end
 
-	def getColor(x,y)
-		#AGColor.new(0xFF,0xFF,0xFF)*getShadow(x,y)
-		super*getShadow(x,y)
-	end
+  def getColor(x,y)
+    #AGColor.new(0xFF,0xFF,0xFF)*getShadow(x,y)
+    super*getShadow(x,y)
+  end
 
 
-	def range(v,type)
-		case type
-			when :veryrough
-				case v
-					when :undefined
-						return [0,0]
-					when :green
-						return [0.3,6]
-					when :water
-						return [0,1]
-					when :wood
-						return [0.3,8]
-					when :rock
-						return [0.4,15]
-				end
-			when :rough
-				case v
-					when :undefined
-						return [0,0]
-					when :green
-						return [0.3,0.6]
-					when :water
-						return [0,0.1]
-					when :wood
-						return [0.3,0.8]
-					when :rock
-						return [0.4,1.5]
-				end
-			else
-				case v
-					when :undefined
-						return [0,0]
-					when :green
-						return [0,0.2]
-					when :water
-						return [0,0.1]
-					when :wood
-						return [0,0.1]
-					when :rock
-						return [0,0.4]
-					else
-						return [0,0]
-				end
-		end
-	end
+  def range(v,type)
+    case type
+      when :veryrough
+        case v
+          when :undefined
+            return [0,0]
+          when :green
+            return [0.3,6]
+          when :water
+            return [0,1]
+          when :wood
+            return [0.3,8]
+          when :rock
+            return [0.4,15]
+        end
+      when :rough
+        case v
+          when :undefined
+            return [0,0]
+          when :green
+            return [0.3,0.6]
+          when :water
+            return [0,0.1]
+          when :wood
+            return [0.3,0.8]
+          when :rock
+            return [0.4,1.5]
+        end
+      else
+        case v
+          when :undefined
+            return [0,0]
+          when :green
+            return [0,0.2]
+          when :water
+            return [0,0.1]
+          when :wood
+            return [0,0.1]
+          when :rock
+            return [0,0.4]
+          else
+            return [0,0]
+        end
+    end
+  end
 
-	def rockIncreaseAbove(level,types,inc)
-		#a=[1,6,15,20,15,6,1]
-		a=[1,5,10,10,5,1]
-		n=crossProductVecVec(a,a)
-		arr=toIndexMap(n)
+  def rockIncreaseAbove(level,types,inc)
+    #a=[1,6,15,20,15,6,1]
+    a=[1,5,10,10,5,1]
+    n=crossProductVecVec(a,a)
+    arr=toIndexMap(n)
 
-		f=arr.inject(0){|a,b|a+b[2]}
+    f=arr.inject(0){|a,b|a+b[2]}
 
-		increased=0
-		checked=0
-		#a=[-1,0,1]
-		#a=a.cross(a)
-		(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
-			(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
-				if types.member?(get(x,y))
-					checked+=1
-					v=0
-					arr.each{|p|
-						cx=x+p[0]
-						cy=y+p[1]
-						#if types.member?(get(cx,cy))
-							v+=getHeight(cx,cy)*p[2]
-						#end						
-					}
-					v/=f
-					#puts &quot;#{v} #{v*f} #{f} #{level}&quot;
-					if v&gt;level
-						setHeight(x,y,getHeight(x,y)+inc)
-						increased+=1
-					end
-				end
-			}
-		}
-		puts &quot;INCREASED:#{increased} CHECKED:#{checked} on level #{level}&quot;
-		applyHeightChanges
-	end
+    increased=0
+    checked=0
+    #a=[-1,0,1]
+    #a=a.cross(a)
+    (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
+      (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
+        if types.member?(get(x,y))
+          checked+=1
+          v=0
+          arr.each{|p|
+            cx=x+p[0]
+            cy=y+p[1]
+            #if types.member?(get(cx,cy))
+              v+=getHeight(cx,cy)*p[2]
+            #end            
+          }
+          v/=f
+          #puts &quot;#{v} #{v*f} #{f} #{level}&quot;
+          if v&gt;level
+            setHeight(x,y,getHeight(x,y)+inc)
+            increased+=1
+          end
+        end
+      }
+    }
+    puts &quot;INCREASED:#{increased} CHECKED:#{checked} on level #{level}&quot;
+    applyHeightChanges
+  end
 
-	def erode(terrainTypes,amount=0.3)
-		eroded=0
-		(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
-			(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
-				if terrainTypes.member?(get(x,y))
-					vs=[]
-					(-1..1).each{|dy|
-						(-1..1).each{|dx|	
-							vs.push(getHeight(x+dx,y+dy))
-						}
-					}
-					ch=getHeight(x,y)
-					if ch&lt;vs.sort[4]
-						setHeight(x,y,ch-amount)
-						eroded+=1
-					end
-				end
-			}
-		}		
-		puts &quot;ERODED: #{eroded}&quot;
-		applyHeightChanges
-	end
+  def erode(terrainTypes,amount=0.3)
+    eroded=0
+    (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
+      (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
+        if terrainTypes.member?(get(x,y))
+          vs=[]
+          (-1..1).each{|dy|
+            (-1..1).each{|dx|  
+              vs.push(getHeight(x+dx,y+dy))
+            }
+          }
+          ch=getHeight(x,y)
+          if ch&lt;vs.sort[4]
+            setHeight(x,y,ch-amount)
+            eroded+=1
+          end
+        end
+      }
+    }    
+    puts &quot;ERODED: #{eroded}&quot;
+    applyHeightChanges
+  end
 
-	def rockIncrease
-		h=0.6
-		while h&lt;3
-			#rockIncreaseAbove(h,[:rock,:wood],0.3)
-			rockIncreaseAbove(h,[:rock],0.15)
-			h+=0.3
-		end
-		#}
-	end
+  def rockIncrease
+    h=0.6
+    while h&lt;3
+      #rockIncreaseAbove(h,[:rock,:wood],0.3)
+      rockIncreaseAbove(h,[:rock],0.15)
+      h+=0.3
+    end
+    #}
+  end
 
-	def getDistance(x,y)
-		return 0 unless x&gt;0 and x&lt;=@w and y&gt;0 and y&lt;=@h
-		d=@dist[<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at w</A>*y]
-		if d
-			return d
-		end
-		return 0
-	end
+  def getDistance(x,y)
+    return 0 unless x&gt;0 and x&lt;=@w and y&gt;0 and y&lt;=@h
+    d=@dist[<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at w</A>*y]
+    if d
+      return d
+    end
+    return 0
+  end
 
-	def applyDistChanges
-		@dist=@ndist.clone
-	end
+  def applyDistChanges
+    @dist=@ndist.clone
+  end
 
-	def setDistance(x,y,d)
-		@ndist[<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at w</A>*y]=d
-	end
+  def setDistance(x,y,d)
+    @ndist[<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x+ at w</A>*y]=d
+  end
 
-	def computeDistances(myTerrain)
-		ar=[]
-		(-1..1).each{|x|
-			(-1..1).each{|y|
-				ar.push([x,y,Math::sqrt(x*x+y*y)])
-			}
-		}
+  def computeDistances(myTerrain)
+    ar=[]
+    (-1..1).each{|x|
+      (-1..1).each{|y|
+        ar.push([x,y,Math::sqrt(x*x+y*y)])
+      }
+    }
 
-		found=0
-		nfound=0
-		# initial run
-		(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
-			(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
-				if get(x,y)==myTerrain
-					test=0
-					ar.each{|p|
-						dx=x+p[0]
-						dy=y+p[1]
-						if get(dx,dy)!=myTerrain
-							setDistance(x,y,p[2]+rand)
-							found+=1
-							test+=1
-							break
-						end
-					}
-					if test==0
-						nfound+=1
-					end
-				end
-			}
-		}
+    found=0
+    nfound=0
+    # initial run
+    (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
+      (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
+        if get(x,y)==myTerrain
+          test=0
+          ar.each{|p|
+            dx=x+p[0]
+            dy=y+p[1]
+            if get(dx,dy)!=myTerrain
+              setDistance(x,y,p[2]+rand)
+              found+=1
+              test+=1
+              break
+            end
+          }
+          if test==0
+            nfound+=1
+          end
+        end
+      }
+    }
 
-		applyDistChanges
-		# fill in random valleys
-		(1..20).each{|i|
-			ok=true
-			while ok
-				x=(rand*@w).to_i+1
-				y=(rand*@h).to_i+1
-				if get(x,y)==myTerrain and getDistance(x,y)==0
-					setDistance(x,y,1+rand)
-					found+=1
-					ok=false
-				end
-			end
-		}
+    applyDistChanges
+    # fill in random valleys
+    (1..20).each{|i|
+      ok=true
+      while ok
+        x=(rand*@w).to_i+1
+        y=(rand*@h).to_i+1
+        if get(x,y)==myTerrain and getDistance(x,y)==0
+          setDistance(x,y,1+rand)
+          found+=1
+          ok=false
+        end
+      end
+    }
 
 
 
-		applyDistChanges
-		puts &quot;FOUND #{found} NFOUND #{nfound}&quot;
-		
-		modified=true
-		try=0
-		while modified
-			modified=false
-			try+=1
-			puts &quot;TRY #{try}&quot;
-			if try&gt;20
-				break
-			end
+    applyDistChanges
+    puts &quot;FOUND #{found} NFOUND #{nfound}&quot;
+    
+    modified=true
+    try=0
+    while modified
+      modified=false
+      try+=1
+      puts &quot;TRY #{try}&quot;
+      if try&gt;20
+        break
+      end
 
-			# do loop and increase distances where distance==0
-			(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
-				(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
-					if get(x,y)==myTerrain and getDistance(x,y)==0
-						ar.each{|p|
-							dx=x+p[0]
-							dy=y+p[1]
-							r=rand+p[2]
-							cd=getDistance(dx,dy)
-							if cd&gt;0 and (cd+r&lt;getDistance(x,y) or getDistance(x,y)==0)
-								found+=1
-								setDistance(x,y,cd+r)
-								setHeight(x,y,getHeight(x,y)+(cd+r)*0.1)
-								modified=true
-							end
-						}			
-					end
-				}
-			}
-			puts &quot;FOUND #{found}&quot;
-			applyDistChanges
-		end
-		applyHeightChanges
-	end
+      # do loop and increase distances where distance==0
+      (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at w</A>).each{|x|
+        (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1.. at h</A>).each{|y|
+          if get(x,y)==myTerrain and getDistance(x,y)==0
+            ar.each{|p|
+              dx=x+p[0]
+              dy=y+p[1]
+              r=rand+p[2]
+              cd=getDistance(dx,dy)
+              if cd&gt;0 and (cd+r&lt;getDistance(x,y) or getDistance(x,y)==0)
+                found+=1
+                setDistance(x,y,cd+r)
+                setHeight(x,y,getHeight(x,y)+(cd+r)*0.1)
+                modified=true
+              end
+            }      
+          end
+        }
+      }
+      puts &quot;FOUND #{found}&quot;
+      applyDistChanges
+    end
+    applyHeightChanges
+  end
 
 private
-	def computeNextFilter(a)
-		n=[]
-		l=0
-		a.each{|c|
-			n.push(l+c)
-			l=c
-		}
-		n.push(l)
-		n
-	end
-	def filterMatrix(n)
-		m=[1,1]
-		while n&gt;1
-			m=computeNextFilter(m)
-			n-=1
-		end
-		m
-	end
-	
-	def crossProductVecVec(a,b)
-		n=[]
-		a.each{|x|
-			l=[]
-			b.each{|y|
-				l.push(x*y)
-			}
-			n.push(l)
-		}
-		n
-	end
-	
-	def toIndexMap(a)
-		n=[]
-		y=0
-		h=a.length
-		w=a[0].length
-		dy=h/2
-		dx=w/2
-		a.each{|r|
-			x=0
-			r.each{|v|
-				n.push([x-dx,y-dy,v])
-				x+=1
-			}
-			y+=1
-		}
-		n
-	end
+  def computeNextFilter(a)
+    n=[]
+    l=0
+    a.each{|c|
+      n.push(l+c)
+      l=c
+    }
+    n.push(l)
+    n
+  end
+  def filterMatrix(n)
+    m=[1,1]
+    while n&gt;1
+      m=computeNextFilter(m)
+      n-=1
+    end
+    m
+  end
+  
+  def crossProductVecVec(a,b)
+    n=[]
+    a.each{|x|
+      l=[]
+      b.each{|y|
+        l.push(x*y)
+      }
+      n.push(l)
+    }
+    n
+  end
+  
+  def toIndexMap(a)
+    n=[]
+    y=0
+    h=a.length
+    w=a[0].length
+    dy=h/2
+    dx=w/2
+    a.each{|r|
+      x=0
+      r.each{|v|
+        n.push([x-dx,y-dy,v])
+        x+=1
+      }
+      y+=1
+    }
+    n
+  end
 
 
 end
 
-	
+  
 
 w=h=128
 
@@ -528,26 +528,26 @@
 myMap.blurAll
 myMap.to_surface.save(&quot;mapgen0.png&quot;)
 if false
-	myMap.computeHeights(:rough)
-	myMap.blurHeights(5)
-	myMap.computeHeights(:medium)
-	myMap.blurHeights(2)
-	myMap.computeHeights(:fine)
-	myMap.blurHeights(1)
-	myMap.to_surface.save(&quot;mapgen1.png&quot;)
-	myMap.rockIncrease
-	myMap.to_surface.save(&quot;mapgen2.png&quot;)
-	myMap.blurHeights(1)
-	myMap.erode([:rock])
-	myMap.erode([:rock])
+  myMap.computeHeights(:rough)
+  myMap.blurHeights(5)
+  myMap.computeHeights(:medium)
+  myMap.blurHeights(2)
+  myMap.computeHeights(:fine)
+  myMap.blurHeights(1)
+  myMap.to_surface.save(&quot;mapgen1.png&quot;)
+  myMap.rockIncrease
+  myMap.to_surface.save(&quot;mapgen2.png&quot;)
+  myMap.blurHeights(1)
+  myMap.erode([:rock])
+  myMap.erode([:rock])
 else
-	myMap.computeHeights(:veryrough)
-	myMap.blurHeights(10)
-	myMap.computeHeights(:rough)
-	myMap.blurHeights(5)
-	myMap.computeDistances(:rock)
-	myMap.computeHeights(:fine)
-	myMap.blurHeights(1)
+  myMap.computeHeights(:veryrough)
+  myMap.blurHeights(10)
+  myMap.computeHeights(:rough)
+  myMap.blurHeights(5)
+  myMap.computeDistances(:rock)
+  myMap.computeHeights(:fine)
+  myMap.blurHeights(1)
 end
 myMap.to_surface.save(&quot;mapgen3.png&quot;)
 app=AGApplication.new

Modified: antargis/trunk/ruby/mesh_view.rb
===================================================================
--- antargis/trunk/ruby/mesh_view.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/mesh_view.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -3,52 +3,52 @@
 require 'ruby/antargislib.rb'
 
 class App&lt;GLApp
-	def initialize(w,h,file,tex,zoom=0.1)
-		super(w,h)
-		@anim=false
-		if file==nil
-			require 'gen_tree.rb'
-			data=genTree
-			@n=Mesh.new(getScene,data,AGVector4.new(0,0,0),-30)
-		elsif file=~/.*anim/
-			data=AnimMeshData.new(&quot;data/models/sheep.anim&quot;)
-			data.setTransform(AGMatrix4.new(Math::PI,AGVector3.new(0,0,1))*AGMatrix4.new(Math::PI/2,AGVector3.new(1,0,0)))
-		
-			puts &quot;YAY&quot;
-			@n=AnimMesh.new(getScene,data)
-			@anim=true
-		else
-			zoom||=0.1
-			zoom=zoom.to_f
-			data=MeshData.new(file,zoom,tex)
-			@n=Mesh.new(getScene,data,AGVector4.new(0,0,0),-30)
-		end
-			
-		if @anim
-			@n.setAnimation(&quot;go&quot;)
-		end
-		getScene.addNode(@n)
-		@rot=0.0
-	end
-	
-	def eventFrame(s)
-		super(s)
-		delay(10)
-		if not @anim
-			return
-		end
-		@rot+=2
-		@n.setRotation(AGVector3.new(0,0,1)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at rot</A>)
-		if @rot&gt;180
-			@n.setAnimation(&quot;eat&quot;)
-		end
-	end
+  def initialize(w,h,file,tex,zoom=0.1)
+    super(w,h)
+    @anim=false
+    if file==nil
+      require 'gen_tree.rb'
+      data=genTree
+      @n=Mesh.new(getScene,data,AGVector4.new(0,0,0),-30)
+    elsif file=~/.*anim/
+      data=AnimMeshData.new(&quot;data/models/sheep.anim&quot;)
+      data.setTransform(AGMatrix4.new(Math::PI,AGVector3.new(0,0,1))*AGMatrix4.new(Math::PI/2,AGVector3.new(1,0,0)))
+    
+      puts &quot;YAY&quot;
+      @n=AnimMesh.new(getScene,data)
+      @anim=true
+    else
+      zoom||=0.1
+      zoom=zoom.to_f
+      data=MeshData.new(file,zoom,tex)
+      @n=Mesh.new(getScene,data,AGVector4.new(0,0,0),-30)
+    end
+      
+    if @anim
+      @n.setAnimation(&quot;go&quot;)
+    end
+    getScene.addNode(@n)
+    @rot=0.0
+  end
+  
+  def eventFrame(s)
+    super(s)
+    delay(10)
+    if not @anim
+      return
+    end
+    @rot+=2
+    @n.setRotation(AGVector3.new(0,0,1)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at rot</A>)
+    if @rot&gt;180
+      @n.setAnimation(&quot;eat&quot;)
+    end
+  end
 end
 
 a=nil
 if ARGV.length&lt;2
-	a=App.new(800,600,nil,nil)
+  a=App.new(800,600,nil,nil)
 else
-	a=App.new(800,600,ARGV[0],ARGV[1],ARGV[2])
+  a=App.new(800,600,ARGV[0],ARGV[1],ARGV[2])
 end
-a.run
\ No newline at end of file
+a.run

Modified: antargis/trunk/ruby/meshes/grass.rb
===================================================================
--- antargis/trunk/ruby/meshes/grass.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/meshes/grass.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,173 +1,173 @@
 def getGrassMeshData(size,many=4,texture=nil,bush=false)
-	size=(size*10).to_i/10.0
+  size=(size*10).to_i/10.0
 
-	$grassdata||={}
- 	if $grassdata[size]
-		return $grassdata[size]
-	end
-	
-	opt=MeshOptimizer.new
-	mv0=MeshVertex.new
-	mv1=MeshVertex.new
-	mv2=MeshVertex.new
-	mv3=MeshVertex.new
-	
-	for i in 1..many
-	
-	mv0.c=AGVector4.new(1,1,1,1)
-	mv1.c=AGVector4.new(1,1,1,1)
-	mv2.c=AGVector4.new(1,1,1,1)
-	mv3.c=AGVector4.new(1,1,1,1)
-	
-	if bush
-		mv0.t=AGVector2.new(0,1-0)
-		mv1.t=AGVector2.new(1,1-0)
-		mv2.t=AGVector2.new(1,1-0.5)
-		mv3.t=AGVector2.new(0,1-0.5)
-	else
-		mv0.t=AGVector2.new(0,1-0)
-		mv1.t=AGVector2.new(1,1-0)
-		mv2.t=AGVector2.new(1,1-1)
-		mv3.t=AGVector2.new(0,1-1)
-	end
-	
-	w=size
-	h=w
-	
-	if bush
-		h*=0.6
-	end
+  $grassdata||={}
+   if $grassdata[size]
+    return $grassdata[size]
+  end
+  
+  opt=MeshOptimizer.new
+  mv0=MeshVertex.new
+  mv1=MeshVertex.new
+  mv2=MeshVertex.new
+  mv3=MeshVertex.new
+  
+  for i in 1..many
+  
+  mv0.c=AGVector4.new(1,1,1,1)
+  mv1.c=AGVector4.new(1,1,1,1)
+  mv2.c=AGVector4.new(1,1,1,1)
+  mv3.c=AGVector4.new(1,1,1,1)
+  
+  if bush
+    mv0.t=AGVector2.new(0,1-0)
+    mv1.t=AGVector2.new(1,1-0)
+    mv2.t=AGVector2.new(1,1-0.5)
+    mv3.t=AGVector2.new(0,1-0.5)
+  else
+    mv0.t=AGVector2.new(0,1-0)
+    mv1.t=AGVector2.new(1,1-0)
+    mv2.t=AGVector2.new(1,1-1)
+    mv3.t=AGVector2.new(0,1-1)
+  end
+  
+  w=size
+  h=w
+  
+  if bush
+    h*=0.6
+  end
 
-	v0=AGVector4.new(-w,0,0)
-	v1=AGVector4.new(w,0,0)
-	v2=AGVector4.new(w,0,h*2)
-	v3=AGVector4.new(-w,0,h*2)
-	
-	if i==1
-		vadd=AGVector4.new(0,0,0,0)
-	else
-		vadd=AGVector4.new(agRand(1.0)*2,agRand(1.0)*2,0,0)
-	end
-	
-	mv0.v=v0+vadd
-	mv1.v=v1+vadd
-	mv2.v=v2+vadd
-	mv3.v=v3+vadd
-	
-	mv0.n=AGVector3.new(0,-1,0)
-	mv1.n=AGVector3.new(0,-1,0)
-	mv2.n=AGVector3.new(0,-1,0)
-	mv3.n=AGVector3.new(0,-1,0)
-	
-	opt.add(mv0)
-	opt.add(mv1)
-	opt.add(mv2)
-	
-	opt.add(mv0)
-	opt.add(mv2)
-	opt.add(mv3)
-	
-	turn=AGMatrix4.new(Math::PI/3,AGVector3.new(0,0,1))
-	
-	mv0.v=turn*v0+vadd
-	mv1.v=turn*v1+vadd
-	mv2.v=turn*v2+vadd
-	mv3.v=turn*v3+vadd
-	
- 	opt.add(mv0)
- 	opt.add(mv1)
- 	opt.add(mv2)
-# 	
- 	opt.add(mv0)
- 	opt.add(mv2)
- 	opt.add(mv3)
-	
-	turn=AGMatrix4.new(-1*Math::PI/3,AGVector3.new(0,0,1))
-	
-	mv0.v=turn*v0+vadd
-	mv1.v=turn*v1+vadd
-	mv2.v=turn*v2+vadd
-	mv3.v=turn*v3+vadd
-	
- 	opt.add(mv0)
- 	opt.add(mv1)
- 	opt.add(mv2)
-# 	
- 	opt.add(mv0)
- 	opt.add(mv2)
- 	opt.add(mv3)
-	
-	if bush
-		mv0.t=AGVector2.new(0,1-0.5)
-		mv1.t=AGVector2.new(1,1-0.5)
-		mv2.t=AGVector2.new(1,1-1)
-		mv3.t=AGVector2.new(0,1-1)
-		mv0.n=AGVector3.new(0,0,1)
-		mv1.n=AGVector3.new(0,0,1)
-		mv2.n=AGVector3.new(0,0,1)
-		mv3.n=AGVector3.new(0,0,1)
-		mv0.v=AGVector4.new(-w,-w,h/3)
-		mv1.v=AGVector4.new( w,-w,h/3)
-		mv2.v=AGVector4.new( w, w,h/3)
-		mv3.v=AGVector4.new(-w, w,h/3)
-		opt.add(mv0)
-		opt.add(mv1)
-		opt.add(mv2)
-		
-		opt.add(mv0)
-		opt.add(mv2)
-		opt.add(mv3)
-		mv0.v=AGVector4.new(-w*0.7,-w*0.7,h*0.7)
-		mv1.v=AGVector4.new( w*0.7,-w*0.7,h*0.7)
-		mv2.v=AGVector4.new( w*0.7, w*0.7,h*0.7)
-		mv3.v=AGVector4.new(-w*0.7, w*0.7,h*0.7)
-		opt.add(mv0)
-		opt.add(mv1)
-		opt.add(mv2)
-		
-		opt.add(mv0)
-		opt.add(mv2)
-		opt.add(mv3)
-		
-		mv0.v=AGVector4.new(-w/2,-w/2,h/2*3)
-		mv1.v=AGVector4.new( w/2,-w/2,h/2*3)
-		mv2.v=AGVector4.new( w/2, w/2,h/2*3)
-		mv3.v=AGVector4.new(-w/2, w/2,h/2*3)
- 		opt.add(mv0)
- 		opt.add(mv1)
- 		opt.add(mv2)
- 		
- 		opt.add(mv0)
- 		opt.add(mv2)
- 		opt.add(mv3)
-	end
-	
-	
-	end
-	
-	#$grassdata[size]=MeshData.new(opt.getArray,&quot;data/textures/models/high_grass2.png&quot;,true) #false)
-	$grassdata[size]=MeshData.new(opt.getArray,texture,true) #false) # last is shadow
-	$grassdata[size].setTransparent(true)
-	
-	if nil
-		$grassdata[size]=MeshData.new(opt.getArray,&quot;data/textures/terrain/reed.png&quot;,true) #false)
-		$grassdata[size].setLighting(false)
-		#$grassdata[size].setOverdraw(true)
-		$grassdata[size].setTransparent(true)
-	end
-	#$grassdata[size]=MeshData.new(opt.getArray,&quot;data/textures/models/flower1.png&quot;,false)
-	
-	return $grassdata[size]
+  v0=AGVector4.new(-w,0,0)
+  v1=AGVector4.new(w,0,0)
+  v2=AGVector4.new(w,0,h*2)
+  v3=AGVector4.new(-w,0,h*2)
+  
+  if i==1
+    vadd=AGVector4.new(0,0,0,0)
+  else
+    vadd=AGVector4.new(agRand(1.0)*2,agRand(1.0)*2,0,0)
+  end
+  
+  mv0.v=v0+vadd
+  mv1.v=v1+vadd
+  mv2.v=v2+vadd
+  mv3.v=v3+vadd
+  
+  mv0.n=AGVector3.new(0,-1,0)
+  mv1.n=AGVector3.new(0,-1,0)
+  mv2.n=AGVector3.new(0,-1,0)
+  mv3.n=AGVector3.new(0,-1,0)
+  
+  opt.add(mv0)
+  opt.add(mv1)
+  opt.add(mv2)
+  
+  opt.add(mv0)
+  opt.add(mv2)
+  opt.add(mv3)
+  
+  turn=AGMatrix4.new(Math::PI/3,AGVector3.new(0,0,1))
+  
+  mv0.v=turn*v0+vadd
+  mv1.v=turn*v1+vadd
+  mv2.v=turn*v2+vadd
+  mv3.v=turn*v3+vadd
+  
+   opt.add(mv0)
+   opt.add(mv1)
+   opt.add(mv2)
+#   
+   opt.add(mv0)
+   opt.add(mv2)
+   opt.add(mv3)
+  
+  turn=AGMatrix4.new(-1*Math::PI/3,AGVector3.new(0,0,1))
+  
+  mv0.v=turn*v0+vadd
+  mv1.v=turn*v1+vadd
+  mv2.v=turn*v2+vadd
+  mv3.v=turn*v3+vadd
+  
+   opt.add(mv0)
+   opt.add(mv1)
+   opt.add(mv2)
+#   
+   opt.add(mv0)
+   opt.add(mv2)
+   opt.add(mv3)
+  
+  if bush
+    mv0.t=AGVector2.new(0,1-0.5)
+    mv1.t=AGVector2.new(1,1-0.5)
+    mv2.t=AGVector2.new(1,1-1)
+    mv3.t=AGVector2.new(0,1-1)
+    mv0.n=AGVector3.new(0,0,1)
+    mv1.n=AGVector3.new(0,0,1)
+    mv2.n=AGVector3.new(0,0,1)
+    mv3.n=AGVector3.new(0,0,1)
+    mv0.v=AGVector4.new(-w,-w,h/3)
+    mv1.v=AGVector4.new( w,-w,h/3)
+    mv2.v=AGVector4.new( w, w,h/3)
+    mv3.v=AGVector4.new(-w, w,h/3)
+    opt.add(mv0)
+    opt.add(mv1)
+    opt.add(mv2)
+    
+    opt.add(mv0)
+    opt.add(mv2)
+    opt.add(mv3)
+    mv0.v=AGVector4.new(-w*0.7,-w*0.7,h*0.7)
+    mv1.v=AGVector4.new( w*0.7,-w*0.7,h*0.7)
+    mv2.v=AGVector4.new( w*0.7, w*0.7,h*0.7)
+    mv3.v=AGVector4.new(-w*0.7, w*0.7,h*0.7)
+    opt.add(mv0)
+    opt.add(mv1)
+    opt.add(mv2)
+    
+    opt.add(mv0)
+    opt.add(mv2)
+    opt.add(mv3)
+    
+    mv0.v=AGVector4.new(-w/2,-w/2,h/2*3)
+    mv1.v=AGVector4.new( w/2,-w/2,h/2*3)
+    mv2.v=AGVector4.new( w/2, w/2,h/2*3)
+    mv3.v=AGVector4.new(-w/2, w/2,h/2*3)
+     opt.add(mv0)
+     opt.add(mv1)
+     opt.add(mv2)
+     
+     opt.add(mv0)
+     opt.add(mv2)
+     opt.add(mv3)
+  end
+  
+  
+  end
+  
+  #$grassdata[size]=MeshData.new(opt.getArray,&quot;data/textures/models/high_grass2.png&quot;,true) #false)
+  $grassdata[size]=MeshData.new(opt.getArray,texture,true) #false) # last is shadow
+  $grassdata[size].setTransparent(true)
+  
+  if nil
+    $grassdata[size]=MeshData.new(opt.getArray,&quot;data/textures/terrain/reed.png&quot;,true) #false)
+    $grassdata[size].setLighting(false)
+    #$grassdata[size].setOverdraw(true)
+    $grassdata[size].setTransparent(true)
+  end
+  #$grassdata[size]=MeshData.new(opt.getArray,&quot;data/textures/models/flower1.png&quot;,false)
+  
+  return $grassdata[size]
 end
 
 def makeGrassMesh(scene,size=0.4)
-	return nil if scene.nil?
-	return Mesh.new(scene,getGrassMeshData(size,4,&quot;data/textures/models/high_grass2.png&quot;),AGVector4.new(0,0,0,0),0)
+  return nil if scene.nil?
+  return Mesh.new(scene,getGrassMeshData(size,4,&quot;data/textures/models/high_grass2.png&quot;),AGVector4.new(0,0,0,0),0)
 end
 
 def makeBushMesh(scene,size=0.4)
-	return nil if scene.nil?
-	assert{scene.is_a?(Scene)}
-	assert{size.is_a?(Numeric)}
-	return Mesh.new(scene,getGrassMeshData(size,1,&quot;data/textures/models/bush5.png&quot;,true),AGVector4.new(0,0,0,0),0)
+  return nil if scene.nil?
+  assert{scene.is_a?(Scene)}
+  assert{size.is_a?(Numeric)}
+  return Mesh.new(scene,getGrassMeshData(size,1,&quot;data/textures/models/bush5.png&quot;,true),AGVector4.new(0,0,0,0),0)
 end

Modified: antargis/trunk/ruby/mpmap.rb
===================================================================
--- antargis/trunk/ruby/mpmap.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/mpmap.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,45 +7,45 @@
 require 'map.rb'
 
 class AntMpMap&lt;AntRubyMap
-	def initialize(c,app,pScene,w,h,playerName=&quot;Rowen&quot;)
-		super(app,pScene,w,h,playerName)
-		@connection=c
-	end
+  def initialize(c,app,pScene,w,h,playerName=&quot;Rowen&quot;)
+    super(app,pScene,w,h,playerName)
+    @connection=c
+  end
 
-	def processMessage(message)
-		case message
-			when RestMessage
-				getByUID(message.hero).newHLRestJob(message.time)
-			when MoveMessage
-				getByUID(message.hero).newHLMoveJob(0,message.pos,message.dist)
-			when FightMessage
-				if message.defend
-					getByUID(message.hero).newHLFightJob(getByUID(message.target))
-				else
-					getByUID(message.hero).newHLFightJob(getByUID(message.target))
-				end
-			when NewPlayerMessage
-				h=AntHero.new
-				puts &quot;C:#{message.pos.class}&quot;
-				h.setPos(message.pos)
-				h.setName(message.name)
-				insertEntity(h)
-		end
+  def processMessage(message)
+    case message
+      when RestMessage
+        getByUID(message.hero).newHLRestJob(message.time)
+      when MoveMessage
+        getByUID(message.hero).newHLMoveJob(0,message.pos,message.dist)
+      when FightMessage
+        if message.defend
+          getByUID(message.hero).newHLFightJob(getByUID(message.target))
+        else
+          getByUID(message.hero).newHLFightJob(getByUID(message.target))
+        end
+      when NewPlayerMessage
+        h=AntHero.new
+        puts &quot;C:#{message.pos.class}&quot;
+        h.setPos(message.pos)
+        h.setName(message.name)
+        insertEntity(h)
+    end
 
-	end
+  end
 
-	def eventNewJobAssignedToBoss(boss)
-		if @connection
-			if boss.getPlayer==getPlayer
-				puts &quot;====================================================&quot;
-				puts boss.getJob
-				puts &quot;====================================================&quot;
-				m=boss.getJob.makeMessage(boss.uid)
-				@connection.sendMessage(m)
-				puts m
-				puts &quot;message sent?????&quot;
-			end
-		end
-	end
+  def eventNewJobAssignedToBoss(boss)
+    if @connection
+      if boss.getPlayer==getPlayer
+        puts &quot;====================================================&quot;
+        puts boss.getJob
+        puts &quot;====================================================&quot;
+        m=boss.getJob.makeMessage(boss.uid)
+        @connection.sendMessage(m)
+        puts m
+        puts &quot;message sent?????&quot;
+      end
+    end
+  end
 
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/obj_import.rb
===================================================================
--- antargis/trunk/ruby/obj_import.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/obj_import.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -10,9 +10,9 @@
 $swap=false
 
 if File.exists?(&quot;antargislib.rb&quot;)
-	require &quot;antargislib.rb&quot;
+  require &quot;antargislib.rb&quot;
 else
-	require &quot;ruby/antargislib.rb&quot;
+  require &quot;ruby/antargislib.rb&quot;
 end
 
 $vs=[]
@@ -21,62 +21,62 @@
 $fs=[]
 
 if ARGV.length&lt;2
-	puts &quot;ARGS: ./obj_import.rb aaa.obj bbb.ant2&quot;
-	exit
+  puts &quot;ARGS: ./obj_import.rb aaa.obj bbb.ant2&quot;
+  exit
 end
 infile=ARGV[0]
 outfile=ARGV[1]
 
 if File.exists?(outfile) and not (ARGV.length&gt;2 and ARGV[2]==&quot;-f&quot;)
-	throw &quot;File already exists&quot;
+  throw &quot;File already exists&quot;
 end
 
 File.open(infile).each_line{|line|
-	#puts &quot;line:&quot;+line
-	if line=~/#.*/ then
-		# ignore - it's a comment
-	elsif line=~/^v .*/ then
-		x,y,z=line.gsub(&quot;v &quot;,&quot;&quot;).split(&quot; &quot;).collect{|a|a.to_f}
-		if $swap
-			z,y=y,z
-		end
-		$vs.push([x,y,z])
-	elsif line=~/^vt .*/ then
-		x,y=line.gsub(&quot;vt &quot;,&quot;&quot;).split(&quot; &quot;).collect{|a|a.to_f}
-		$ts.push([x,y])
-	elsif line=~/^vn .*/ then
-		a,x,y,z=line.gsub(&quot;vt &quot;,&quot;&quot;).split(&quot; &quot;).collect{|a|a.to_f}
-		printf &quot;%f,%f,%f\n&quot;,x,y,z
-		$ns.push([x,y,z])
-	elsif line=~/^f .*/ then
-		vs=line.gsub(&quot;f &quot;,&quot;&quot;).split(&quot; &quot;)
-		faces=[]
-		vs.each{|v|
-			v,t,n=v.split(&quot;/&quot;).collect{|a|a.to_i-1}
-			faces.push([v,t,n])
-		}
-		$fs.push(faces)
-	else	
-		puts &quot;ignored:&quot;+line
-	end
+  #puts &quot;line:&quot;+line
+  if line=~/#.*/ then
+    # ignore - it's a comment
+  elsif line=~/^v .*/ then
+    x,y,z=line.gsub(&quot;v &quot;,&quot;&quot;).split(&quot; &quot;).collect{|a|a.to_f}
+    if $swap
+      z,y=y,z
+    end
+    $vs.push([x,y,z])
+  elsif line=~/^vt .*/ then
+    x,y=line.gsub(&quot;vt &quot;,&quot;&quot;).split(&quot; &quot;).collect{|a|a.to_f}
+    $ts.push([x,y])
+  elsif line=~/^vn .*/ then
+    a,x,y,z=line.gsub(&quot;vt &quot;,&quot;&quot;).split(&quot; &quot;).collect{|a|a.to_f}
+    printf &quot;%f,%f,%f\n&quot;,x,y,z
+    $ns.push([x,y,z])
+  elsif line=~/^f .*/ then
+    vs=line.gsub(&quot;f &quot;,&quot;&quot;).split(&quot; &quot;)
+    faces=[]
+    vs.each{|v|
+      v,t,n=v.split(&quot;/&quot;).collect{|a|a.to_i-1}
+      faces.push([v,t,n])
+    }
+    $fs.push(faces)
+  else  
+    puts &quot;ignored:&quot;+line
+  end
 }
 
 file=File.new(outfile,&quot;wb&quot;)
 file.print([1].pack(&quot;v&quot;))
 file.print([$fs.length].pack(&quot;v&quot;))
 $fs.each{|face|
-	file.print([face.length].pack(&quot;v&quot;))
-	face.each{|mv|
-		file.print($vs[mv[0]].pack(&quot;eee&quot;))
-		file.print($ns[mv[2]].pack(&quot;eee&quot;))
-		file.print([1,1,1].pack(&quot;eee&quot;))
-		if $ts[mv[1]]
-			file.print($ts[mv[1]].pack(&quot;ee&quot;))
-		else
-			file.print([0,0].pack(&quot;ee&quot;))
-		end
-	}
+  file.print([face.length].pack(&quot;v&quot;))
+  face.each{|mv|
+    file.print($vs[mv[0]].pack(&quot;eee&quot;))
+    file.print($ns[mv[2]].pack(&quot;eee&quot;))
+    file.print([1,1,1].pack(&quot;eee&quot;))
+    if $ts[mv[1]]
+      file.print($ts[mv[1]].pack(&quot;ee&quot;))
+    else
+      file.print([0,0].pack(&quot;ee&quot;))
+    end
+  }
 }
 
 
-file.close
\ No newline at end of file
+file.close

Modified: antargis/trunk/ruby/runtests.rb
===================================================================
--- antargis/trunk/ruby/runtests.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/runtests.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -4,14 +4,14 @@
 #
 
 def runScript(s)
-	r=`ruby #{s} 2&gt;/dev/null`	
-	status=$?
-	#puts r
-	#puts status
-	if status!=0
-		#raise &quot;sth wrong&quot;
-	end
-	status==0
+  r=`ruby #{s} 2&gt;/dev/null`  
+  status=$?
+  #puts r
+  #puts status
+  if status!=0
+    #raise &quot;sth wrong&quot;
+  end
+  status==0
 end
 
 tests=Dir[&quot;ruby/tests/*.rb&quot;]
@@ -19,17 +19,17 @@
 failed=[]
 
 tests.each{|t|
-	s=&quot; &quot;*(40-t.length)
-	print &quot;Running: &quot;+t+s
-	if not runScript(t)
-		failed.push(t)
-		puts &quot;FAILED&quot;
-	else
-		puts &quot;OK&quot;
-	end
+  s=&quot; &quot;*(40-t.length)
+  print &quot;Running: &quot;+t+s
+  if not runScript(t)
+    failed.push(t)
+    puts &quot;FAILED&quot;
+  else
+    puts &quot;OK&quot;
+  end
 
 }
 
 puts
 puts &quot;Successfully completed: #{tests.length-failed.length}&quot;
-puts &quot;Failed tests          : #{failed.length}&quot;
\ No newline at end of file
+puts &quot;Failed tests          : #{failed.length}&quot;

Modified: antargis/trunk/ruby/spec/level_testing.rb
===================================================================
--- antargis/trunk/ruby/spec/level_testing.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/level_testing.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -3,54 +3,54 @@
 require 'ruby/ant_application.rb'
 
 module LevelTesting
-	class TestEntity
-		class ClickNode
-			attr_accessor :node
-		end
+  class TestEntity
+    class ClickNode
+      attr_accessor :node
+    end
 
-		def initialize(entity,app)
-			@entity=entity
-			@app=app
-		end
-		def click(button=1)
-			n=ClickNode.new
-			n.node=@entity.getMesh[0]
-			@app.eventEntitiesClicked([n],button)
-		end
-		def method_missing(*s)
-			@entity.send(*s)
-		end
-	end
-	
-	def entities(type)
-		map.getByType(type).collect{|e|TestEntity.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">e, at app</A>)}
-	end
-	
-	include GuiTest
-	def getTestApp(testLevelName)
-		case testLevelName
-			when :tutorial0
-				file=&quot;data/levels/tutorial/tutorial0.antlvl&quot;
-			when :tutorial3
-				file=&quot;data/levels/tutorial/tutorial3.antlvl&quot;
-	    end
-	    clientConnection=nil
-	    @app=makeTestAppClass(AntGameApp).new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
-	end
-	
-	def runUntilLowLevelJobToFinish(entity)
-		observe(entity,:eventJobFinished) do |observer|
-			while observer.isNotCalled
-				advance
-			end
-		end
-	end
-	
+    def initialize(entity,app)
+      @entity=entity
+      @app=app
+    end
+    def click(button=1)
+      n=ClickNode.new
+      n.node=@entity.getMesh[0]
+      @app.eventEntitiesClicked([n],button)
+    end
+    def method_missing(*s)
+      @entity.send(*s)
+    end
+  end
+  
+  def entities(type)
+    map.getByType(type).collect{|e|TestEntity.new(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">e, at app</A>)}
+  end
+  
+  include GuiTest
+  def getTestApp(testLevelName)
+    case testLevelName
+      when :tutorial0
+        file=&quot;data/levels/tutorial/tutorial0.antlvl&quot;
+      when :tutorial3
+        file=&quot;data/levels/tutorial/tutorial3.antlvl&quot;
+      end
+      clientConnection=nil
+      @app=makeTestAppClass(AntGameApp).new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
+  end
+  
+  def runUntilLowLevelJobToFinish(entity)
+    observe(entity,:eventJobFinished) do |observer|
+      while observer.isNotCalled
+        advance
+      end
+    end
+  end
+  
   def clickAwayStory
-	  telltaleWidget=widget(&quot;TellTale&quot;)
-		raise if telltaleWidget.nil?
+    telltaleWidget=widget(&quot;TellTale&quot;)
+    raise if telltaleWidget.nil?
     return if telltaleWidget.nil?
-	
+  
     telltaleWidget.should_not be_nil
     telltaleWidget.should be_visible
     okButton=telltaleWidget.child(&quot;ok&quot;)
@@ -65,44 +65,44 @@
       trials.should &lt;10
     end
   end
-	
-	
-	def advance(time=nil)
-		step=0.3
-		time||=0
-		begin
-			@app.getMap.move(step)
-			@app.step
-			time-=step
-		end while time&gt;step
-	end	
+  
+  
+  def advance(time=nil)
+    step=0.3
+    time||=0
+    begin
+      @app.getMap.move(step)
+      @app.step
+      time-=step
+    end while time&gt;step
+  end  
 
   def hero(name)
-  	h=map.getByName(name)
-		h.should_not be_nil
-		h.should be_a_kind_of(AntHero)
-		h
+    h=map.getByName(name)
+    h.should_not be_nil
+    h.should be_a_kind_of(AntHero)
+    h
   end
-	def building(name)
-		b=map.getByName(name)
-		b.should_not be_nil
-		b.should be_a_kind_of(AntHouse)
-		b
-	end
-	def map
-		@app.getMap
-	end
-	
-	def clickMap(pos2d,button=1)
-		@app.eventMapClicked(pos2d,button)
-	end
-	
-	def waitForStory
-	  while not storyIsDisplayed
-			advance
-		 end
-	end
+  def building(name)
+    b=map.getByName(name)
+    b.should_not be_nil
+    b.should be_a_kind_of(AntHouse)
+    b
+  end
+  def map
+    @app.getMap
+  end
+  
+  def clickMap(pos2d,button=1)
+    @app.eventMapClicked(pos2d,button)
+  end
+  
+  def waitForStory
+    while not storyIsDisplayed
+      advance
+     end
+  end
   def storyIsDisplayed
     widget(&quot;TellTale&quot;).valid and widget(&quot;TellTale&quot;).visible?
   end  
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/spec/spec_basic.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_basic.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_basic.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -2,13 +2,13 @@
 require 'ruby/gui/ag_tools.rb'
 
 describe &quot;Array.shuffle&quot; do
-	it &quot;should really shuffle an array (in a 100 trials)&quot; do
-		tries=100
-		a=[1,2,3,4,5]
-		while tries&gt;0
-			break if a!=a.shuffle
-			tries-=1
-		end
-		tries.should &gt;0
-	end
-end
\ No newline at end of file
+  it &quot;should really shuffle an array (in a 100 trials)&quot; do
+    tries=100
+    a=[1,2,3,4,5]
+    while tries&gt;0
+      break if a!=a.shuffle
+      tries-=1
+    end
+    tries.should &gt;0
+  end
+end

Modified: antargis/trunk/ruby/spec/spec_call.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_call.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_call.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -17,26 +17,26 @@
       end
     end
     a=A.new
-		a.y.should == &quot;hi&quot;
+    a.y.should == &quot;hi&quot;
     lambda{a.y.should be_nil}.should cross(a,:y)
-		a.y.should == &quot;hi&quot;
+    a.y.should == &quot;hi&quot;
   end
-	it &quot;should work with should_not&quot; do
-		lambda{}.should_not cross(:globalTestFunction)
-	end
+  it &quot;should work with should_not&quot; do
+    lambda{}.should_not cross(:globalTestFunction)
+  end
 
-	it &quot;should work with new method&quot; do
-		class A
-			attr_reader :a
-			def initialize
-				@a=10
-			end
-		end
-		
-		lambda{A.new}.should cross(A,:initialize)
-		lambda{}.should_not cross(A,:initialize)
-		lambda{a=A.new}.should cross(A,:initialize)
-	end
+  it &quot;should work with new method&quot; do
+    class A
+      attr_reader :a
+      def initialize
+        @a=10
+      end
+    end
+    
+    lambda{A.new}.should cross(A,:initialize)
+    lambda{}.should_not cross(A,:initialize)
+    lambda{a=A.new}.should cross(A,:initialize)
+  end
 
 end
 
@@ -72,7 +72,7 @@
   
   it &quot;should work for class-methods&quot; do
     lambda{Test.test2}.should cross(Test,:test2)
-		Test.test2.should equal(:test_2)
+    Test.test2.should equal(:test_2)
   end
   
   it &quot;should work for object-methods&quot; do
@@ -86,12 +86,12 @@
     lambda{Test.new}.should cross(Test,:initialize)
   end
 
-	it &quot;failure measure&quot; do
-		Cross.new(&quot;A&quot;,&quot;B&quot;).failure_message.should =~/expected .* to call A.B.*/
-	end
-	it &quot;negative failure measure&quot; do
-		Cross.new(&quot;A&quot;,&quot;B&quot;).negative_failure_message.should =~/expected .* not to call A.B.*/
-	end
+  it &quot;failure measure&quot; do
+    Cross.new(&quot;A&quot;,&quot;B&quot;).failure_message.should =~/expected .* to call A.B.*/
+  end
+  it &quot;negative failure measure&quot; do
+    Cross.new(&quot;A&quot;,&quot;B&quot;).negative_failure_message.should =~/expected .* not to call A.B.*/
+  end
   
   it &quot;should work with local classes&quot; do
     class A

Modified: antargis/trunk/ruby/spec/spec_campaign.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_campaign.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_campaign.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -2,68 +2,68 @@
 require 'ruby/campaign.rb'
 
 describe Campaign do
-	before(:all) do
-		@campaigns=getCampaigns
-		@tutorial=@campaigns[0]
- 		@birth=@campaigns[1]
-	end
-	it &quot;getCampaigns should return at least 2&quot; do
-		@campaigns.length.should &gt;=2
- 	end
-	it &quot;first campaign is tutorial&quot; do
-		@tutorial.name.should == &quot;Tutorial&quot;
-	end
-	
-	it &quot;tutorial has lower order than birth-campaign&quot; do
-		tut=@campaigns.find{|c|c.name==&quot;Tutorial&quot;}
-		tut.should_not be_nil
-		birth=@campaigns.find{|c|c.name==&quot;A hero is born.&quot;}
-		birth.should_not be_nil
-		tut.order.should &lt; birth.order
-	end
+  before(:all) do
+    @campaigns=getCampaigns
+    @tutorial=@campaigns[0]
+     @birth=@campaigns[1]
+  end
+  it &quot;getCampaigns should return at least 2&quot; do
+    @campaigns.length.should &gt;=2
+   end
+  it &quot;first campaign is tutorial&quot; do
+    @tutorial.name.should == &quot;Tutorial&quot;
+  end
+  
+  it &quot;tutorial has lower order than birth-campaign&quot; do
+    tut=@campaigns.find{|c|c.name==&quot;Tutorial&quot;}
+    tut.should_not be_nil
+    birth=@campaigns.find{|c|c.name==&quot;A hero is born.&quot;}
+    birth.should_not be_nil
+    tut.order.should &lt; birth.order
+  end
 
-	it &quot;tutorial starts with level&quot; do
-		@tutorial.getCurrentPart.should be_a_kind_of(CampaignLevel)
-	end
+  it &quot;tutorial starts with level&quot; do
+    @tutorial.getCurrentPart.should be_a_kind_of(CampaignLevel)
+  end
 
- 	it &quot;birth campaign is second campaign&quot; do
- 		#pp @birth.name
- 		@birth.name.should == &quot;A hero is born.&quot;
- 	end
+   it &quot;birth campaign is second campaign&quot; do
+     #pp @birth.name
+     @birth.name.should == &quot;A hero is born.&quot;
+   end
 
-	it &quot;birth campaign starts with cutscene&quot; do
-		@birth.getCurrentPart.should be_a_kind_of(CutScene)
-	end
- 	it &quot;should run a story fine&quot; do
-		OldDisplay=CutSceneDisplay.clone
-		class CutSceneDisplay
-			@@ok=false
-			@@calls={}
-			
-			# remove all methods
-			self.instance_methods.each{|m|undef_method(m) unless m=~/__.*__/}
-			def initialize
-				@@ok=true
-			end
-			def CutSceneDisplay.initok
-				@@ok 
-			end
-			def CutSceneDisplay.callCount(name)
-				@@calls[name]
-			end
-			def method_missing(name,*s)
-				@@calls[name]||=0
-				@@calls[name]+=1
-			end
-		end
- 		cutscene=@birth.getCurrentPart
- 		lambda {cutscene.play}.should cross(CutSceneDisplay,:initialize)
-		CutSceneDisplay.initok.should be_false # because it wasn't hit due to &quot;should cross&quot;
-		CutSceneDisplay.callCount(:setImage).should &gt;0
-		CutSceneDisplay.callCount(:setImage).should equal(CutSceneDisplay.callCount(:setText))
-		CutSceneDisplay.callCount(:setImage).should equal(CutSceneDisplay.callCount(:run))
- 		CutSceneDisplay=OldDisplay
- 	end
+  it &quot;birth campaign starts with cutscene&quot; do
+    @birth.getCurrentPart.should be_a_kind_of(CutScene)
+  end
+   it &quot;should run a story fine&quot; do
+    OldDisplay=CutSceneDisplay.clone
+    class CutSceneDisplay
+      @@ok=false
+      @@calls={}
+      
+      # remove all methods
+      self.instance_methods.each{|m|undef_method(m) unless m=~/__.*__/}
+      def initialize
+        @@ok=true
+      end
+      def CutSceneDisplay.initok
+        @@ok 
+      end
+      def CutSceneDisplay.callCount(name)
+        @@calls[name]
+      end
+      def method_missing(name,*s)
+        @@calls[name]||=0
+        @@calls[name]+=1
+      end
+    end
+     cutscene=@birth.getCurrentPart
+     lambda {cutscene.play}.should cross(CutSceneDisplay,:initialize)
+    CutSceneDisplay.initok.should be_false # because it wasn't hit due to &quot;should cross&quot;
+    CutSceneDisplay.callCount(:setImage).should &gt;0
+    CutSceneDisplay.callCount(:setImage).should equal(CutSceneDisplay.callCount(:setText))
+    CutSceneDisplay.callCount(:setImage).should equal(CutSceneDisplay.callCount(:run))
+     CutSceneDisplay=OldDisplay
+   end
 
 
 end

Added: antargis/trunk/ruby/spec/spec_drawing.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_drawing.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_drawing.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -0,0 +1,6 @@
+require 'ruby/gui/testing.rb'
+
+describe &quot;Drawing Widgets&quot; do
+  it &quot;should work on positioned widgets&quot; do
+  end
+end
\ No newline at end of file

Modified: antargis/trunk/ruby/spec/spec_formation.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_formation.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_formation.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,68 +1,68 @@
 require 'ruby/spec/level_testing.rb'
 
 class MockResource
-	def get(*s)
-		0
-	end
+  def get(*s)
+    0
+  end
 end
 
 class MockMan
     def initialize(pos)
         @pos=pos
     end
-	def getPos2D
-		@pos
-	end
-	def resource
-		MockResource.new
-	end
+  def getPos2D
+    @pos
+  end
+  def resource
+    MockResource.new
+  end
 end
 
 class MockHero&lt;MockMan
-	def initialize(pos)
-		super
-		@men=[]
-	end
-	def add(man)
-		@men &lt;&lt; man
-	end
-	def getMen
-		@men+[self]
-	end
+  def initialize(pos)
+    super
+    @men=[]
+  end
+  def add(man)
+    @men &lt;&lt; man
+  end
+  def getMen
+    @men+[self]
+  end
 end
 
 
 describe 'SitFormation' do
-	it &quot;should center on heroes position with hero only&quot; do
-		hero=MockHero.new(AGVector2.new(0,0))
-		AntFormationRest.new(hero).getPosition(hero,hero.getPos2D).should == hero.getPos2D
-	end
-	
-	(2..25).step(3){|count|
-		it &quot;should center on heroes with #{count} men in range of 1&quot; do
-			middle=AGVector2.new(0,0)
-			some=AGVector2.new(100,100)
-			hero=MockHero.new(middle)
-			null=AGVector2.new(0,0)
-			(1...count).each{|i|
-				hero.add(MockMan.new(some))
-			}
-			formation=AntFormationRest.new(hero)
-			poss=hero.getMen.collect{|man|
-				pos=formation.getPosition(man,hero.getPos2D)
-				puts pos
-				pos
-			}
-			sum=poss.inject(null){|a,b|a+b}
-			(sum/poss.length-middle).length.should &lt; 1
-		end
-	}
+  it &quot;should center on heroes position with hero only&quot; do
+    hero=MockHero.new(AGVector2.new(0,0))
+    AntFormationRest.new(hero).getPosition(hero,hero.getPos2D).should == hero.getPos2D
+  end
+  
+  (2..25).step(3){|count|
+    it &quot;should center on heroes with #{count} men in range of 1&quot; do
+      middle=AGVector2.new(0,0)
+      some=AGVector2.new(100,100)
+      hero=MockHero.new(middle)
+      null=AGVector2.new(0,0)
+      (1...count).each{|i|
+        hero.add(MockMan.new(some))
+      }
+      formation=AntFormationRest.new(hero)
+      poss=hero.getMen.collect{|man|
+        pos=formation.getPosition(man,hero.getPos2D)
+        puts pos
+        pos
+      }
+      sum=poss.inject(null){|a,b|a+b}
+      (sum/poss.length-middle).length.should &lt; 1
+    end
+  }
 end
 
 describe 'WalkFormation' do
-	it &quot;should work correctly with only the hero&quot;
-	it &quot;should work correctly with a single trooper&quot;
-	it &quot;should work correctly with 5 troopers&quot;
+  it &quot;should work correctly with only the hero&quot;
+  it &quot;should work correctly with a single trooper&quot;
+  it &quot;should work correctly with 5 troopers&quot;
     it &quot;should work correctly with 15 troopers&quot;
     it &quot;should work correctly with 35 troopers&quot;
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/spec/spec_gc.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_gc.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_gc.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -6,30 +6,30 @@
 
 
 def doapp
-	address=nil
-	Module.new.module_eval{
-		app=AGApplication.new #AGMessageObject.new #(nil,AGRect2.new(0,0,100,100)) #AGApplication.new
-		address=getAddressOfRubyObject(app)
-		app=nil
-	}
+  address=nil
+  Module.new.module_eval{
+    app=AGApplication.new #AGMessageObject.new #(nil,AGRect2.new(0,0,100,100)) #AGApplication.new
+    address=getAddressOfRubyObject(app)
+    app=nil
+  }
     address
-	#nil
+  #nil
 end
 
 describe &quot;Garbage Collection&quot; do
-	it &quot;should handle AGApplication (alone) correctly&quot; do
-		#setDebugLevel(0)
-		address=0
-		begin
-			address=doapp
-		end
-		GC.enable
-	    # allocate much mem (200 MB)
-		text=&quot;a&quot;*1000*1000*300
-		GC.start
-		rubyObjectExists(address).should be_false
-		rubyObjectExists(getAddressOfRubyObject(getMain)).should be_true
-	end
+  it &quot;should handle AGApplication (alone) correctly&quot; do
+    #setDebugLevel(0)
+    address=0
+    begin
+      address=doapp
+    end
+    GC.enable
+      # allocate much mem (200 MB)
+    text=&quot;a&quot;*1000*1000*300
+    GC.start
+    rubyObjectExists(address).should be_false
+    rubyObjectExists(getAddressOfRubyObject(getMain)).should be_true
+  end
 end
 
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/spec/spec_geometry.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_geometry.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_geometry.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -2,28 +2,28 @@
 require 'pp'
 
 describe AGCircle2,&quot;a radius 2 circle around (10,10)&quot; do
-	before(:each) do
-		@circleMiddle=AGVector2.new(10,10)
-		@radius=2
-		@circle=AGCircle2.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">circleMiddle, at radius</A>)
-	end
+  before(:each) do
+    @circleMiddle=AGVector2.new(10,10)
+    @radius=2
+    @circle=AGCircle2.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">circleMiddle, at radius</A>)
+  end
 
-	it &quot;should hit an intersection line (9,0)-(9,20)&quot; do
-		line=AGLine2.new(AGVector2.new(9,0),AGVector2.new(9,20))
-		list=@circle.collide(line)
-		list.length.should == 2
-		list.each{|p|(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p- at circleMiddle</A>).length.should == @radius}
+  it &quot;should hit an intersection line (9,0)-(9,20)&quot; do
+    line=AGLine2.new(AGVector2.new(9,0),AGVector2.new(9,20))
+    list=@circle.collide(line)
+    list.length.should == 2
+    list.each{|p|(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">p- at circleMiddle</A>).length.should == @radius}
 
-		# should lie on line
-		list.each{|p|p.x.should ==9}
+    # should lie on line
+    list.each{|p|p.x.should ==9}
 
-	end
-	it &quot;should not hit an line at (9,0)-(119,0)&quot; do
-		l2=AGLine2.new(AGVector2.new(9,0),AGVector2.new(119,0))
-		list=@circle.collide(l2)
-		list.length.should ==0
+  end
+  it &quot;should not hit an line at (9,0)-(119,0)&quot; do
+    l2=AGLine2.new(AGVector2.new(9,0),AGVector2.new(119,0))
+    list=@circle.collide(l2)
+    list.length.should ==0
 
-	end
+  end
   
 end
 
@@ -78,4 +78,4 @@
     v=AGVector2.new(10,10)
     @r.clip(v).should == v
   end
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/spec/spec_hljob_saving.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_hljob_saving.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_hljob_saving.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -46,12 +46,12 @@
     checkRowenRest
     #advance
     lambda {
-	    @app.load
-	    dialog=widget(&quot;LoadDialog&quot;)
-	    files=dialog.getChild(&quot;Files&quot;)
-	    filename=files.getValues.keys.select{|f|f=~/#{file}/}[0]
-	    files.selectItem(filename)
-	    click(dialog.getChild(&quot;ok&quot;).getScreenRect.getMiddle)
+      @app.load
+      dialog=widget(&quot;LoadDialog&quot;)
+      files=dialog.getChild(&quot;Files&quot;)
+      filename=files.getValues.keys.select{|f|f=~/#{file}/}[0]
+      files.selectItem(filename)
+      click(dialog.getChild(&quot;ok&quot;).getScreenRect.getMiddle)
     }.should_not cross(AntEntity,:newMoveJob) #AntNewHLJob,:check)
     checkRowenRest
   end
@@ -61,4 +61,4 @@
     pp file
     loadFile(file)
   end
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/spec/spec_map.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_map.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_map.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,11 +1,11 @@
 require &quot;ruby/spec/level_testing.rb&quot;
 
 describe AntRubyMap,&quot;A BoA-Ruby-map&quot; do
-	it &quot;should run without UI at all&quot; do
-		map=AntRubyMap.new(nil,nil,64,64)
-		map.move(1)
-	end
+  it &quot;should run without UI at all&quot; do
+    map=AntRubyMap.new(nil,nil,64,64)
+    map.move(1)
+  end
   it &quot;should not include ant_mock.rb when calling without GUI&quot;
 
-	it &quot;should be possible to create two maps concurrently (low prio)&quot;
+  it &quot;should be possible to create two maps concurrently (low prio)&quot;
 end

Modified: antargis/trunk/ruby/spec/spec_math.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_math.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_math.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,5 +1,25 @@
 require 'ruby/spec_helper.rb'
 
+class AGMatrix3
+  def toString
+    (0..2).map{|y|&quot;(&quot;+(0..2).map{|x|get(x,y).to_s}.join(&quot;;&quot;)+&quot;)&quot;}.join(&quot;,&quot;)
+  end
+end
+
+def singleMatrix
+  m=AGMatrix3.new
+  m.set(0,0,1)
+  m.set(1,0,0)
+  m.set(2,0,0)
+  m.set(0,1,0)
+  m.set(1,1,1)
+  m.set(2,1,0)
+  m.set(0,2,0)
+  m.set(1,2,0)
+  m.set(2,2,1)
+  m 
+end
+
 describe &quot;Determinant&quot; do
   def makeQuadMatrix(*s)
     len=s.length
@@ -41,6 +61,38 @@
   end
 end
 
+describe &quot;Gauss should work correctly&quot; do
+  def makeMatrix(str)
+    y=0
+    m=AGMatrix3.new
+    str.gsub(&quot;(&quot;,&quot;&quot;).gsub(&quot;)&quot;,&quot;&quot;).split(&quot;,&quot;).each{|a|
+      x=0
+      a.split(&quot;;&quot;).each{|v|
+        puts &quot;#{x},#{y}:#{v}&quot;
+        m.set(x,y,v.to_f)
+        x+=1
+      }
+      y+=1
+      
+    }
+    m
+  end
+  def self.check(s)
+    it &quot;should work on #{s}&quot; do
+      m=makeMatrix(s)
+      pp s
+      pp m.toString
+      i=m.inverted
+      pp i.toString
+      (m*i).should==singleMatrix
+    end
+  end
+  
+  check(&quot;((1;0;-9),(0;1;0),(0;0;1),)&quot;)
+#  check(&quot;(1;0;-2),(0;1;0),(0;0;1)&quot;)
+end
+
+
 describe &quot;AGMatrix3D(one with 0s on the main axis)&quot; do
   it &quot;should be invertable&quot; do
     m=AGMatrix3.new
@@ -55,17 +107,4 @@
     m.set(2,2,0)
     (m.inverted*m).should == singleMatrix 
   end
-  def singleMatrix
-    m=AGMatrix3.new
-    m.set(0,0,1)
-    m.set(1,0,0)
-    m.set(2,0,0)
-    m.set(0,1,0)
-    m.set(1,1,1)
-    m.set(2,1,0)
-    m.set(0,2,0)
-    m.set(1,2,0)
-    m.set(2,2,1)
-    m 
-  end
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/spec/spec_menu.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_menu.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_menu.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,66 +7,66 @@
 require 'ruby/mainmenu.rb'
 
 describe 'Main-Menu' do
-	include GuiTest
-	before(:each) do
-		@app=makeTestAppClass(AntMenuApp).new
-		@app.step
-	end
-	it &quot;should display credits&quot; do
- 		widget(&quot;ticker&quot;).should be_nil
-		credits=widget(&quot;credits&quot;)
-		credits.should be_a_kind_of(AGButton)
-		credits.click
-		widget(&quot;ticker&quot;).should be_a_kind_of(AntTicker)
-		widget(&quot;exit&quot;).click
-		widget(&quot;credits&quot;).should be_a_kind_of(AGButton)
- 		widget(&quot;ticker&quot;).should be_nil
-	end
-	it &quot;should end when clicking on quit&quot; do
-		quit=widget(&quot;quit&quot;)
-		quit.should be_an_instance_of(AGButton)
-		@app.step
-		lambda {quit.click}.should change(@app,:quitCounter).by(1)
-	end
-	it &quot;should be possible to select tutorial and this will start this one&quot; do
-		tutorialButton=widget(&quot;tutorial&quot;)
-		tutorialButton.should be_an_instance_of(AGButton)
-		lambda {tutorialButton.click}.should cross(:startCampaign)
-	end
-	it &quot;should be possible to select the tutorial in the campaign section and start it&quot; do
-		playCampaign(0)
-	end
-	it &quot;should be possible to select the birth-campaign and start it&quot; do
-		playCampaign(1)
-	end
-	it &quot;should be possible to flip fullscreen&quot; do
-		optionsButton=widget(&quot;options&quot;)
-		optionsButton.should be_an_instance_of(AGButton)
-		optionsButton.click
-		optionsMenu=widget(&quot;OptionsMenu&quot;)
-		optionsMenu.should be_a_kind_of(AGWidget)
-		optionsMenu.should be_visible
-		fullscreenButton=optionsMenu.child(&quot;fullscreen&quot;)
-		fullscreenButton.should be_an_instance_of(AGButton)
-		lambda {fullscreenButton.click}.should change(getVideo,:fullscreen).from(false).to(true)
-		lambda {fullscreenButton.click}.should change(getVideo,:fullscreen).from(true).to(false)
-	end
-	private
-	def playCampaign(number)
-		campaignButton=widget(&quot;campaign&quot;)
-		campaignButton.should_not be_nil
-		campaignButton.click
-		menu=widget(&quot;CampaignMenu&quot;)
-		menu.should be_a_kind_of(AGLayout)
-		campaignRadio=menu.child(&quot;campaign#{number}&quot;)
-		campaignRadio.should be_a_kind_of(AGRadio)
-		campaignRadio.should_not be_checked
-		campaignRadio.click
-		campaignRadio.should be_checked
-		startButton=menu.child(&quot;start&quot;)
-		startButton.should be_a_kind_of(AGButton)
-		lambda {startButton.click}.should cross(:startCampaign)
-	end
+  include GuiTest
+  before(:each) do
+    @app=makeTestAppClass(AntMenuApp).new
+    @app.step
+  end
+  it &quot;should display credits&quot; do
+     widget(&quot;ticker&quot;).should be_nil
+    credits=widget(&quot;credits&quot;)
+    credits.should be_a_kind_of(AGButton)
+    credits.click
+    widget(&quot;ticker&quot;).should be_a_kind_of(AntTicker)
+    widget(&quot;exit&quot;).click
+    widget(&quot;credits&quot;).should be_a_kind_of(AGButton)
+     widget(&quot;ticker&quot;).should be_nil
+  end
+  it &quot;should end when clicking on quit&quot; do
+    quit=widget(&quot;quit&quot;)
+    quit.should be_an_instance_of(AGButton)
+    @app.step
+    lambda {quit.click}.should change(@app,:quitCounter).by(1)
+  end
+  it &quot;should be possible to select tutorial and this will start this one&quot; do
+    tutorialButton=widget(&quot;tutorial&quot;)
+    tutorialButton.should be_an_instance_of(AGButton)
+    lambda {tutorialButton.click}.should cross(:startCampaign)
+  end
+  it &quot;should be possible to select the tutorial in the campaign section and start it&quot; do
+    playCampaign(0)
+  end
+  it &quot;should be possible to select the birth-campaign and start it&quot; do
+    playCampaign(1)
+  end
+  it &quot;should be possible to flip fullscreen&quot; do
+    optionsButton=widget(&quot;options&quot;)
+    optionsButton.should be_an_instance_of(AGButton)
+    optionsButton.click
+    optionsMenu=widget(&quot;OptionsMenu&quot;)
+    optionsMenu.should be_a_kind_of(AGWidget)
+    optionsMenu.should be_visible
+    fullscreenButton=optionsMenu.child(&quot;fullscreen&quot;)
+    fullscreenButton.should be_an_instance_of(AGButton)
+    lambda {fullscreenButton.click}.should change(getVideo,:fullscreen).from(false).to(true)
+    lambda {fullscreenButton.click}.should change(getVideo,:fullscreen).from(true).to(false)
+  end
+  private
+  def playCampaign(number)
+    campaignButton=widget(&quot;campaign&quot;)
+    campaignButton.should_not be_nil
+    campaignButton.click
+    menu=widget(&quot;CampaignMenu&quot;)
+    menu.should be_a_kind_of(AGLayout)
+    campaignRadio=menu.child(&quot;campaign#{number}&quot;)
+    campaignRadio.should be_a_kind_of(AGRadio)
+    campaignRadio.should_not be_checked
+    campaignRadio.click
+    campaignRadio.should be_checked
+    startButton=menu.child(&quot;start&quot;)
+    startButton.should be_a_kind_of(AGButton)
+    lambda {startButton.click}.should cross(:startCampaign)
+  end
 end
 
-#end
\ No newline at end of file
+#end

Modified: antargis/trunk/ruby/spec/spec_minimap.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_minimap.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_minimap.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,3 +1,3 @@
 describe &quot;MiniMap&quot; do
-	it &quot;should move the main map when clicked into&quot;
-end
\ No newline at end of file
+  it &quot;should move the main map when clicked into&quot;
+end

Modified: antargis/trunk/ruby/spec/spec_run_tutorial.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_run_tutorial.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_run_tutorial.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,29 +7,29 @@
 # TODO: redesign spec for different runs
 
 describe 'Tutorial campaign' do
-	describe '- First level' do
-	  include LevelTesting
+  describe '- First level' do
+    include LevelTesting
     describe &quot;- disjoint tests&quot; do
-			before do
-				@app=getTestApp(:tutorial0)
-		    @app.step
-				
-			end
-			it &quot;should start off with a story telling dialog&quot; do
-				telltaleWidget=widget(&quot;TellTale&quot;)
-				telltaleWidget.should_not be_nil
-				telltaleWidget.should be_visible
-				textWidget=telltaleWidget.child(&quot;text&quot;)
-				textWidget.should_not be_nil
-				text=textWidget.getText.to_s
-				okButton=telltaleWidget.child(&quot;ok&quot;)
-				okButton.should_not be_nil
-				okButton.click
-				text.should_not ==(textWidget.getText.to_s)
-				@app.step
-				clickAwayStory
-				
-			end
+      before do
+        @app=getTestApp(:tutorial0)
+        @app.step
+        
+      end
+      it &quot;should start off with a story telling dialog&quot; do
+        telltaleWidget=widget(&quot;TellTale&quot;)
+        telltaleWidget.should_not be_nil
+        telltaleWidget.should be_visible
+        textWidget=telltaleWidget.child(&quot;text&quot;)
+        textWidget.should_not be_nil
+        text=textWidget.getText.to_s
+        okButton=telltaleWidget.child(&quot;ok&quot;)
+        okButton.should_not be_nil
+        okButton.click
+        text.should_not ==(textWidget.getText.to_s)
+        @app.step
+        clickAwayStory
+        
+      end
 
       it &quot;should be no problem to recruit only a few men at the beginning when aggression is low&quot; do
         storyIsDisplayed.should be_true
@@ -48,37 +48,37 @@
         rowen.getMen.length.should &lt; menCount
         keep.getMen.length.should &gt; 0
       end      
-      	    
-	    it &quot;should be no problem to set aggression to maximum at the beginning&quot; do
-	      storyIsDisplayed.should be_true
-	      clickAwayStory
-	      rowen=hero(&quot;Rowen&quot;)
-	      keep=building(&quot;Keep&quot;)
-	      rowen.getMen.length.should == 1
-	      menCount=(rowen.getMen+keep.getMen).length
-	      rowen.getAggression.should == 1
-	      rowen.setAggression(3.0)
-	      rowen.newHLRecruitJob(keep)
-	      while rowen.hasHLJob
-	        advance
-	      end
-	      rowen.getAggression.should == 3
-	      rowen.hasHLJob.should be_false
-	      rowen.getMen.length.should == menCount
-	      keep.getMen.length.should == 0
-	    end
+            
+      it &quot;should be no problem to set aggression to maximum at the beginning&quot; do
+        storyIsDisplayed.should be_true
+        clickAwayStory
+        rowen=hero(&quot;Rowen&quot;)
+        keep=building(&quot;Keep&quot;)
+        rowen.getMen.length.should == 1
+        menCount=(rowen.getMen+keep.getMen).length
+        rowen.getAggression.should == 1
+        rowen.setAggression(3.0)
+        rowen.newHLRecruitJob(keep)
+        while rowen.hasHLJob
+          advance
+        end
+        rowen.getAggression.should == 3
+        rowen.hasHLJob.should be_false
+        rowen.getMen.length.should == menCount
+        keep.getMen.length.should == 0
+      end
     end    
     
-		describe '- State at the beginning' do
-		  before(:all) do
-	      @app=getTestApp(:tutorial0)
-			  @map=@app.getMap
-			  @map.should be_a_kind_of(AntRubyMap)
-			  #clickAwayStory
-			  @enemy=nil
-			  @hero=nil
+    describe '- State at the beginning' do
+      before(:all) do
+        @app=getTestApp(:tutorial0)
+        @map=@app.getMap
+        @map.should be_a_kind_of(AntRubyMap)
+        #clickAwayStory
+        @enemy=nil
+        @hero=nil
         advance
-		  end
+      end
       it &quot;should display a story-telling&quot; do
         storyIsDisplayed.should be_true
         clickAwayStory
@@ -90,36 +90,36 @@
         hero(&quot;Rowen&quot;).getAggression.should == 1
       end
 
-			            	
-		  it &quot;should include Rowen and an enemy&quot; do
-		    heroes=@map.getOwnHeroes
-				enemies=@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">map.getHeroes- at map.getOwnHeroes</A>
-				heroes.length.should == 1
-				enemies.length.should == 1
-				@hero=heroes[0]
-				@enemy=enemies[0]
-		  end
-		  it &quot;should have a single enemy with a few troopers&quot; do
-		  	getEnemy.getMen.length.should &gt;2
-		  end
+                    
+      it &quot;should include Rowen and an enemy&quot; do
+        heroes=@map.getOwnHeroes
+        enemies=@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">map.getHeroes- at map.getOwnHeroes</A>
+        heroes.length.should == 1
+        enemies.length.should == 1
+        @hero=heroes[0]
+        @enemy=enemies[0]
+      end
+      it &quot;should have a single enemy with a few troopers&quot; do
+        getEnemy.getMen.length.should &gt;2
+      end
 
-		  it &quot;should have Rowen with no followers yet&quot; do
-		  	getHero.getMen.length ==1
-		  end
+      it &quot;should have Rowen with no followers yet&quot; do
+        getHero.getMen.length ==1
+      end
 
-		  it &quot;should have a tower with a few men&quot; do
-		  	towers=@map.getBuildings
-				towers.length.should == 1
-				@tower=towers[0]
-				@tower.should be_a_kind_of(AntTower)
-				@tower.getMen.length&gt;2
-		  end
-		  it &quot;should include more men in tower than enemy has&quot; do
-		  	tower=@map.getBuildings[0]
-				tower.getMen.length.should &gt; getEnemy.getMen.length
-		  end
-		  
-		end
+      it &quot;should have a tower with a few men&quot; do
+        towers=@map.getBuildings
+        towers.length.should == 1
+        @tower=towers[0]
+        @tower.should be_a_kind_of(AntTower)
+        @tower.getMen.length&gt;2
+      end
+      it &quot;should include more men in tower than enemy has&quot; do
+        tower=@map.getBuildings[0]
+        tower.getMen.length.should &gt; getEnemy.getMen.length
+      end
+      
+    end
     
     describe &quot;- normal run&quot; do
       before(:all) do
@@ -129,89 +129,89 @@
         clickAwayStory
       end
     
-			it &quot;should be possible to recruit some men (not all)&quot; do
-				# do a recruit job
-				@map=@app.getMap
-				hero=getHero
-	      hero.getAggression.should == 1
-				building=getBuilding
-				hero.newHLRecruitJob(building)
-				while hero.hasHLJob
-					advance
-				end
-				hero.getJob.should_not be_a_kind_of(AntHeroRecruitJob)
-				widget(&quot;TellTale&quot;).should be_visible
-				building.getMen.length.should &gt; 0
-				hero.getMen.length.should &gt;= 2
-			end
-	    it &quot;should display a story part&quot; do
-	      storyIsDisplayed.should be_true
-	      clickAwayStory
-	    end
-	
-	    it &quot;should be possible to recruit the remaining men&quot; do
-	      rowen=hero(&quot;Rowen&quot;)
-	      keep=building(&quot;Keep&quot;)
-	      rowen.setAggression(3)
-	      rowen.newHLRecruitJob(keep)
-	      menCount=rowen.getMen.length+keep.getMen.length
-	      while rowen.hasHLJob ; advance; end
-	      rowen.getMen.length.should == menCount
-	      keep.getMen.length.should == 0
-	      rowen.getMen.length.should &gt; getEnemy.getMen.length
-	    end
-	    
-			it &quot;should be possible to defeat enemy with low aggression&quot; do
-			  
-				hero=getHero
-				enemy=getEnemy
-	      hero.setAggression(1)
-				hero.newHLFightJob(enemy)
-				hero.getJob.should be_a_kind_of(AntHeroFightJob)
-				enemy.hasHLJob.should be_false
-	      trials=300
-				while hero.hasHLJob
-					puts hero.getJob
-					advance
-	        break if storyIsDisplayed
-	        trials.should &gt; 0
-	        trials-=1
-				end
-	      storyIsDisplayed.should be_true
-				clickAwayStory
-				advance
-		    @app.result.won.should == &quot;won&quot;
-	      map.getOwnHeroes.length.should == 2
-			end
-			
-			
-			it &quot;should be possible to dismiss some people&quot; do
-				hero=getHero
-				hero.setAggression(1)
-				oldMenCount=hero.getMen.length
-				oldMenCount.should &gt; 1
-				hero.newHLDismissJob
-				while hero.hasHLJob
-					advance
-				end
-				menCount=hero.getMen.length
-				menCount.should &lt; oldMenCount
-			end
-    end			
-		
-	
-		def getEnemies
-			enemies=map.getHeroes-map.getOwnHeroes
-			enemies
-		end
-		def getEnemy
-		  getEnemies[0]
-		end
-		def getHero
-		  @app.getMap.getOwnHeroes[0]
-		end
-		def getBuilding
-			@app.getMap.getBuildings[0]
-		end
-	end
-end
\ No newline at end of file
+      it &quot;should be possible to recruit some men (not all)&quot; do
+        # do a recruit job
+        @map=@app.getMap
+        hero=getHero
+        hero.getAggression.should == 1
+        building=getBuilding
+        hero.newHLRecruitJob(building)
+        while hero.hasHLJob
+          advance
+        end
+        hero.getJob.should_not be_a_kind_of(AntHeroRecruitJob)
+        widget(&quot;TellTale&quot;).should be_visible
+        building.getMen.length.should &gt; 0
+        hero.getMen.length.should &gt;= 2
+      end
+      it &quot;should display a story part&quot; do
+        storyIsDisplayed.should be_true
+        clickAwayStory
+      end
+  
+      it &quot;should be possible to recruit the remaining men&quot; do
+        rowen=hero(&quot;Rowen&quot;)
+        keep=building(&quot;Keep&quot;)
+        rowen.setAggression(3)
+        rowen.newHLRecruitJob(keep)
+        menCount=rowen.getMen.length+keep.getMen.length
+        while rowen.hasHLJob ; advance; end
+        rowen.getMen.length.should == menCount
+        keep.getMen.length.should == 0
+        rowen.getMen.length.should &gt; getEnemy.getMen.length
+      end
+      
+      it &quot;should be possible to defeat enemy with low aggression&quot; do
+        
+        hero=getHero
+        enemy=getEnemy
+        hero.setAggression(1)
+        hero.newHLFightJob(enemy)
+        hero.getJob.should be_a_kind_of(AntHeroFightJob)
+        enemy.hasHLJob.should be_false
+        trials=300
+        while hero.hasHLJob
+          puts hero.getJob
+          advance
+          break if storyIsDisplayed
+          trials.should &gt; 0
+          trials-=1
+        end
+        storyIsDisplayed.should be_true
+        clickAwayStory
+        advance
+        @app.result.won.should == &quot;won&quot;
+        map.getOwnHeroes.length.should == 2
+      end
+      
+      
+      it &quot;should be possible to dismiss some people&quot; do
+        hero=getHero
+        hero.setAggression(1)
+        oldMenCount=hero.getMen.length
+        oldMenCount.should &gt; 1
+        hero.newHLDismissJob
+        while hero.hasHLJob
+          advance
+        end
+        menCount=hero.getMen.length
+        menCount.should &lt; oldMenCount
+      end
+    end      
+    
+  
+    def getEnemies
+      enemies=map.getHeroes-map.getOwnHeroes
+      enemies
+    end
+    def getEnemy
+      getEnemies[0]
+    end
+    def getHero
+      @app.getMap.getOwnHeroes[0]
+    end
+    def getBuilding
+      @app.getMap.getBuildings[0]
+    end
+  end
+end

Modified: antargis/trunk/ruby/spec/spec_screenshot.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_screenshot.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_screenshot.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -18,9 +18,9 @@
     checkSurface(surface, @red).should be_true
   end
   it &quot;should be possible to grab back-buffer screenshot with readpixels&quot; do
-	  fill(@blue)
-	  flip
-	  fill(@red)
+    fill(@blue)
+    flip
+    fill(@red)
     surface=@s.screenshotSurface(false)
     checkSurface(surface, @red).should be_true
   end
@@ -68,4 +68,4 @@
     equal
   end
 end
-end
\ No newline at end of file
+end

Modified: antargis/trunk/ruby/spec/spec_scrollingwidget.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_scrollingwidget.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_scrollingwidget.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -36,16 +36,16 @@
   end
   
   def makeScreenshot
-  	@makeScreenshot=true
+    @makeScreenshot=true
   end
   
   protected
   def grabScreenshot(e)
-  	if @makeScreenshot
-  	  @screenshot=getScreen.screenshotSurface(false)
-	  @makeScreenshot=nil
-  	end
-  	true
+    if @makeScreenshot
+      @screenshot=getScreen.screenshotSurface(false)
+    @makeScreenshot=nil
+    end
+    true
   end
   
   private

Deleted: antargis/trunk/ruby/spec/spec_translation.rb
===================================================================
--- antargis/trunk/ruby/spec/spec_translation.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/spec/spec_translation.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,15 +0,0 @@
-require 'ruby/spec/level_testing.rb'
-
-describe &quot;Checking translation&quot; do
-  
-  include LevelTesting
-  
-  before(:all) do
-    getTestApp(:tutorial0)
-    advance
-  end
-  
-  it &quot;should diplay normal text and special chars like backslashes&quot; do
-    1.should == 0
-  end
-end
\ No newline at end of file

Modified: antargis/trunk/ruby/state_machine/ant_hl_job_states.rb
===================================================================
--- antargis/trunk/ruby/state_machine/ant_hl_job_states.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/state_machine/ant_hl_job_states.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,61 +1,61 @@
 require 'ruby/state_machine/state_machine.rb'
 
 class HLJob_New_BaseState&lt;StateMachineNode
-	def hero
-		dict[:hero]
-	end
-	def allMen
-		dict[:hero].getMen
-	end
-	def getTime
-		getMap.getTime
-	end
+  def hero
+    dict[:hero]
+  end
+  def allMen
+    dict[:hero].getMen
+  end
+  def getTime
+    getMap.getTime
+  end
 end
 
 class HLJob_DirState&lt;HLJob_New_BaseState
-	def formatDir
-		(targetPos-hero.getPos2D).normalized
-	end
-	def targetPos
-		dict[:targetPos]
-	end
+  def formatDir
+    (targetPos-hero.getPos2D).normalized
+  end
+  def targetPos
+    dict[:targetPos]
+  end
 end
 
 class HLJob_FormatWalk_State&lt;HLJob_DirState
-	# needed: getTime
+  # needed: getTime
 
-	# wait 5 seconds at max for formatting
-	FORMAT_MAX_TIME=5
+  # wait 5 seconds at max for formatting
+  FORMAT_MAX_TIME=5
 
-	def eventEnter
-		hero.formation=AntFormationBlock.new(hero,formatDir)
-		heroPos=hero.getPos2D
-		allMen.each{|man|
-			pos=hero.getFormation(man,heroPos)
-			man.walkTo(pos)
-			man.hlJobMode[:formatting]=true
-		}
-		@formatStart=getTime
-	end
+  def eventEnter
+    hero.formation=AntFormationBlock.new(hero,formatDir)
+    heroPos=hero.getPos2D
+    allMen.each{|man|
+      pos=hero.getFormation(man,heroPos)
+      man.walkTo(pos)
+      man.hlJobMode[:formatting]=true
+    }
+    @formatStart=getTime
+  end
 
-	def assign(man)
-		#raise 1
-		man.setDirection(180-(targetPos-hero.getPos2D).normalized.getAngle.angle*180.0/Math::PI)
-		man.standStill
-		man.hlJobMode.delete(:formatting)
-	end
+  def assign(man)
+    #raise 1
+    man.setDirection(180-(targetPos-hero.getPos2D).normalized.getAngle.angle*180.0/Math::PI)
+    man.standStill
+    man.hlJobMode.delete(:formatting)
+  end
 
-	def ready
-		if <A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">getTime- at formatStart</A>&gt;FORMAT_MAX_TIME
-			puts &quot;MUST BE READY&quot;
-			return true
-		end
-		allMen.each{|man|
-			puts &quot;formatting:#{man}:#{man.hlJobMode[:formatting]}&quot;
-			if man.hlJobMode[:formatting]
-				return false
-			end
-		}
-		return true
-	end
-end
\ No newline at end of file
+  def ready
+    if <A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">getTime- at formatStart</A>&gt;FORMAT_MAX_TIME
+      puts &quot;MUST BE READY&quot;
+      return true
+    end
+    allMen.each{|man|
+      puts &quot;formatting:#{man}:#{man.hlJobMode[:formatting]}&quot;
+      if man.hlJobMode[:formatting]
+        return false
+      end
+    }
+    return true
+  end
+end

Modified: antargis/trunk/ruby/state_machine/spec/job_states.rb
===================================================================
--- antargis/trunk/ruby/state_machine/spec/job_states.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/state_machine/spec/job_states.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -6,79 +6,79 @@
 require 'ruby/state_machine/ant_hl_job_states.rb'
 
 # class MockEnt
-# 	def setPos(p)
-# 		@p=p
-# 	end
+#   def setPos(p)
+#     @p=p
+#   end
 # end
 # 
 # class AntHero&lt;MockEnt
-# 	def initialize
-# 		@men=[]
-# 	end
-# 	def addMan(m)
-# 		@men &lt;&lt; m
-# 	end
+#   def initialize
+#     @men=[]
+#   end
+#   def addMan(m)
+#     @men &lt;&lt; m
+#   end
 # end
 # class AntMan&lt;MockEnt
-# 	def setBoss(b)
-# 		@boss=b
-# 		@boss.addMan(self)
-# 	end
+#   def setBoss(b)
+#     @boss=b
+#     @boss.addMan(self)
+#   end
 # end
 
 class JobTestingSuite
-	attr_reader :hero, :entities, :men
-	def initialize
-		app=AGApplication.new
-		scene=Scene.new(800,600)
-		@map=AntRubyMap.new(app,scene,800,600)
-		@hero=AntHero.new
-		@hero.setPos(AGVector2.new(2,2))
-		@men=[]
-		vecs=[[2,1],[1,1]]
-		vecs.each{|v|
-			man=AntMan.new
-			man.setPos(AGVector2.new(v[0],v[1]))
-			man.setBoss(@hero)
-			@men &lt;&lt; man
-		}
-		@entities=@men+[@hero]
-	end
+  attr_reader :hero, :entities, :men
+  def initialize
+    app=AGApplication.new
+    scene=Scene.new(800,600)
+    @map=AntRubyMap.new(app,scene,800,600)
+    @hero=AntHero.new
+    @hero.setPos(AGVector2.new(2,2))
+    @men=[]
+    vecs=[[2,1],[1,1]]
+    vecs.each{|v|
+      man=AntMan.new
+      man.setPos(AGVector2.new(v[0],v[1]))
+      man.setBoss(@hero)
+      @men &lt;&lt; man
+    }
+    @entities=@men+[@hero]
+  end
 end
 
 describe HLJob_FormatWalk_State, &quot;Formatting state&quot; do
-	# initialize a state-machine-def
-	before(:all) do
-		@def=StateMachineDefinition.new
-		@def.startNode=@def.addNode(HLJob_FormatWalk_State,:format)
-		@suite=JobTestingSuite.new		
-	end
-	before(:each) do
-		@m=@def.createMachine
-		@m.debug=true
-		@m.dict[:hero]=@suite.hero
-		@m.dict[:targetPos]=AGVector2.new(4,4)
-	end
+  # initialize a state-machine-def
+  before(:all) do
+    @def=StateMachineDefinition.new
+    @def.startNode=@def.addNode(HLJob_FormatWalk_State,:format)
+    @suite=JobTestingSuite.new    
+  end
+  before(:each) do
+    @m=@def.createMachine
+    @m.debug=true
+    @m.dict[:hero]=@suite.hero
+    @m.dict[:targetPos]=AGVector2.new(4,4)
+  end
 
-	it &quot;should assign a job to each man&quot; do
-		@suite.entities.each{|e|e.hasJob.should == false }
-		@m.tick(0.001)
-		@suite.entities.each{|e|e.hasJob.should == true }
-	end
+  it &quot;should assign a job to each man&quot; do
+    @suite.entities.each{|e|e.hasJob.should == false }
+    @m.tick(0.001)
+    @suite.entities.each{|e|e.hasJob.should == true }
+  end
 
-	it &quot;should format men to the given formation&quot; do
-		while not @m.finished do
-			@m.tick(1)
-			@suite.entities.each{|e|e.move(0.2)}
-		end
-		@suite.entities.each{|e|
-			e.getPos2D.should == @suite.hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">e, at suite.hero.getPos2D</A>)
-		}
-	end
-	
-	it &quot;should finish in a decent time.&quot;
+  it &quot;should format men to the given formation&quot; do
+    while not @m.finished do
+      @m.tick(1)
+      @suite.entities.each{|e|e.move(0.2)}
+    end
+    @suite.entities.each{|e|
+      e.getPos2D.should == @suite.hero.getFormation(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">e, at suite.hero.getPos2D</A>)
+    }
+  end
+  
+  it &quot;should finish in a decent time.&quot;
 
-	it &quot;should assign even if old jobs are assigned.&quot;
+  it &quot;should assign even if old jobs are assigned.&quot;
 end
 
 

Modified: antargis/trunk/ruby/state_machine/spec/state_machine.rb
===================================================================
--- antargis/trunk/ruby/state_machine/spec/state_machine.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/state_machine/spec/state_machine.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -2,235 +2,235 @@
 require 'ruby/state_machine/state_machine.rb'
 
 describe StateMachineNode do
-	before(:each) do
+  before(:each) do
     @node = StateMachineNode.new(:id)
   end
 
-	it &quot;should have id :id&quot; do
-		@node.id.should == :id
-	end
+  it &quot;should have id :id&quot; do
+    @node.id.should == :id
+  end
 
-	it &quot;should have a function dict, which is the state-machines dictionary&quot; do
-		@node.methods.member?(&quot;dict&quot;).should == true
-	end
+  it &quot;should have a function dict, which is the state-machines dictionary&quot; do
+    @node.methods.member?(&quot;dict&quot;).should == true
+  end
 
-	it &quot;accessing the dictionary when the node is not attached to a machine will raise an exception&quot; do
-		lambda {@node.dict}.should raise_error(AntargisException)
-	end
+  it &quot;accessing the dictionary when the node is not attached to a machine will raise an exception&quot; do
+    lambda {@node.dict}.should raise_error(AntargisException)
+  end
 end
 
 describe StateMachineEdge do
   before(:each) do
-		@e = StateMachineEdge.new(:a,:b,:name)
+    @e = StateMachineEdge.new(:a,:b,:name)
   end
 
-	it &quot;should have from node :a&quot; do
-		@e.from.should == :a
-	end
-	it &quot;should have to node :b&quot; do
-		@e.to.should == :b
-	end
-	it &quot;should have name :name&quot; do
-		@e.name.should == :name
-	end
+  it &quot;should have from node :a&quot; do
+    @e.from.should == :a
+  end
+  it &quot;should have to node :b&quot; do
+    @e.to.should == :b
+  end
+  it &quot;should have name :name&quot; do
+    @e.name.should == :name
+  end
 end
 
 describe StateMachineDefinition, &quot;with no node&quot; do
-	before(:each) do
-		@d=StateMachineDefinition.new
-	end
-	it &quot;creating a machine should raise an error&quot; do
-		lambda {@d.createMachine}.should raise_error(AntargisException) #(&quot;startnode not set&quot;)
-	end
+  before(:each) do
+    @d=StateMachineDefinition.new
+  end
+  it &quot;creating a machine should raise an error&quot; do
+    lambda {@d.createMachine}.should raise_error(AntargisException) #(&quot;startnode not set&quot;)
+  end
 end
 
 describe StateMachineDefinition, &quot;with a single node&quot; do
   before(:each) do
-		@d = StateMachineDefinition.new
-		@d.addNode(StateMachineNode,:startNode)
-		@d.startNode=:startNode
+    @d = StateMachineDefinition.new
+    @d.addNode(StateMachineNode,:startNode)
+    @d.startNode=:startNode
   end
-	it &quot;should have node count 1&quot; do
-		@d.nodeCount.should == 1
-	end
+  it &quot;should have node count 1&quot; do
+    @d.nodeCount.should == 1
+  end
 
-	it &quot;should be finished when run&quot; do
-		m=@d.createMachine
-		m.tick(1)
-		m.finished.should == true
-	end
+  it &quot;should be finished when run&quot; do
+    m=@d.createMachine
+    m.tick(1)
+    m.finished.should == true
+  end
 
 end
 
 # a mockstate that can be set to finished externally
 class MockState&lt;StateMachineNode
-	attr_accessor :dummyVar
+  attr_accessor :dummyVar
 
-	def initialize(pid)
-		super(pid)	
-		@finished=true
+  def initialize(pid)
+    super(pid)  
+    @finished=true
 
-	end
-	def finished=(f)
-		@finished=f
-	end
-	def ready
-		@finished
-	end
+  end
+  def finished=(f)
+    @finished=f
+  end
+  def ready
+    @finished
+  end
 
-	def eventEnter
-		logEvent(&quot;eventEnter&quot;)
-	end
-	def eventLeave
-		logEvent(&quot;eventLeave&quot;)
-	end
-	def eventFrame(t)
-		logEvent(&quot;eventFrame&quot;)
-		t
-	end
+  def eventEnter
+    logEvent(&quot;eventEnter&quot;)
+  end
+  def eventLeave
+    logEvent(&quot;eventLeave&quot;)
+  end
+  def eventFrame(t)
+    logEvent(&quot;eventFrame&quot;)
+    t
+  end
 
 private
-	def logEvent(name)
-		dict[&quot;events&quot;]||=[]
-		dict[&quot;events&quot;] &lt;&lt; id.to_s+&quot; &quot;+name
-	end
-	
+  def logEvent(name)
+    dict[&quot;events&quot;]||=[]
+    dict[&quot;events&quot;] &lt;&lt; id.to_s+&quot; &quot;+name
+  end
+  
 end
 
 describe StateMachine, &quot; with 2 mock-states &quot; do
-	before(:all) do 
-		@d=StateMachineDefinition.new
-		@n1=@d.startNode=@d.addNode(MockState,:start)
-		@n2=@d.addNode(MockState,:end)
-		@d.addEdge(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">n1, at n2</A>)
-	end
-	it &quot;should not touch another machine with same definition in their states&quot; do
-		m1=@d.createMachine
-		m2=@d.createMachine
+  before(:all) do 
+    @d=StateMachineDefinition.new
+    @n1=@d.startNode=@d.addNode(MockState,:start)
+    @n2=@d.addNode(MockState,:end)
+    @d.addEdge(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">n1, at n2</A>)
+  end
+  it &quot;should not touch another machine with same definition in their states&quot; do
+    m1=@d.createMachine
+    m2=@d.createMachine
 
-		m1.state.dummyVar=20
-		m2.state.dummyVar.should == nil
-	end
+    m1.state.dummyVar=20
+    m2.state.dummyVar.should == nil
+  end
 
-	before(:each) do
-		@m=@d.createMachine
-	end
-	
-	it &quot;should call eventEnter on startNode before calling eventFrame&quot; do
-		@m.tick(1)
-		events=@m.dict[&quot;events&quot;]
-		events.length.should == 5
-		events[0].should == &quot;start eventEnter&quot;
-		events[1].should == &quot;start eventFrame&quot;
-		events[2].should == &quot;start eventLeave&quot;
-		events[3].should == &quot;end eventEnter&quot;
-		events[4].should == &quot;end eventFrame&quot;
-	end
+  before(:each) do
+    @m=@d.createMachine
+  end
+  
+  it &quot;should call eventEnter on startNode before calling eventFrame&quot; do
+    @m.tick(1)
+    events=@m.dict[&quot;events&quot;]
+    events.length.should == 5
+    events[0].should == &quot;start eventEnter&quot;
+    events[1].should == &quot;start eventFrame&quot;
+    events[2].should == &quot;start eventLeave&quot;
+    events[3].should == &quot;end eventEnter&quot;
+    events[4].should == &quot;end eventFrame&quot;
+  end
 
-	it &quot;should not be finished without being started/tick called&quot; do
-		@m.finished.should == false
-	end
-	it &quot;should be finished when tick was called&quot; do
-		@m.tick(1)
-		@m.finished.should == true
-	end
-	it &quot;- rest-time should be equal to initial time when calling tick&quot; do
-		time=1
-		restTime=@m.tick(time)
-		time.should restTime
-	end
-	it &quot;should only process first node and stay there, when tick-time is 0&quot; do
-		@m.tick(0)
-		@m.state.id.should == @n1
-	end
-	it &quot;should end in @n2 and be finished, when tick-time is 1&quot; do
-		@m.tick(1)
-		@m.state.id.should == @n2
-		@m.finished.should == true
-	end
-	it &quot;should return a node when calling state&quot; do
-		@m.state.should is_a?(StateMachineNode)
-	end
+  it &quot;should not be finished without being started/tick called&quot; do
+    @m.finished.should == false
+  end
+  it &quot;should be finished when tick was called&quot; do
+    @m.tick(1)
+    @m.finished.should == true
+  end
+  it &quot;- rest-time should be equal to initial time when calling tick&quot; do
+    time=1
+    restTime=@m.tick(time)
+    time.should restTime
+  end
+  it &quot;should only process first node and stay there, when tick-time is 0&quot; do
+    @m.tick(0)
+    @m.state.id.should == @n1
+  end
+  it &quot;should end in @n2 and be finished, when tick-time is 1&quot; do
+    @m.tick(1)
+    @m.state.id.should == @n2
+    @m.finished.should == true
+  end
+  it &quot;should return a node when calling state&quot; do
+    @m.state.should is_a?(StateMachineNode)
+  end
 
-	it &quot;should have a dictionary&quot; do
-		@m.dict.should is_a?(Hash)
-	end
+  it &quot;should have a dictionary&quot; do
+    @m.dict.should is_a?(Hash)
+  end
 
-	it &quot;should be able to pass on information from one state to another&quot; do	
-		@m.dict[&quot;test&quot;]=10
-		@m.tick(1)
-		@m.state.id.should == @n2
-		@m.dict[&quot;test&quot;].should == 10
-	end
+  it &quot;should be able to pass on information from one state to another&quot; do  
+    @m.dict[&quot;test&quot;]=10
+    @m.tick(1)
+    @m.state.id.should == @n2
+    @m.dict[&quot;test&quot;].should == 10
+  end
 
-	it &quot;should be able to pass on information from one state to another - saved and restored within state&quot; do	
-		@m.state.dict[&quot;test&quot;]=10
-		@m.tick(1)
-		@m.state.id.should == @n2
-		@m.state.dict[&quot;test&quot;].should == 10
-	end
+  it &quot;should be able to pass on information from one state to another - saved and restored within state&quot; do  
+    @m.state.dict[&quot;test&quot;]=10
+    @m.tick(1)
+    @m.state.id.should == @n2
+    @m.state.dict[&quot;test&quot;].should == 10
+  end
 
-	it &quot;- states have link up to machine&quot; do
-		@m.state.machine.should == @m
-	end	
+  it &quot;- states have link up to machine&quot; do
+    @m.state.machine.should == @m
+  end  
 
-	it &quot;should return the state, when giving the correct name&quot; do
-		s1=@m.getState(:start)
-		s1.should is_a?(StateMachineNode)
-		s1.id.should == @n1
-		s2=@m.getState(:end)
-		s2.should is_a?(StateMachineNode)
-		s2.id.should == @n2
-	end
+  it &quot;should return the state, when giving the correct name&quot; do
+    s1=@m.getState(:start)
+    s1.should is_a?(StateMachineNode)
+    s1.id.should == @n1
+    s2=@m.getState(:end)
+    s2.should is_a?(StateMachineNode)
+    s2.id.should == @n2
+  end
 end
 
 class DelayState&lt;StateMachineNode
-	def eventEnter
-		@time=1
-	end
-	def eventFrame(t)
-		d=[1,t].min
-		@time-=d
-		t-=d
-		t
-	end
-	def ready
-		@time&lt;=0
-	end
+  def eventEnter
+    @time=1
+  end
+  def eventFrame(t)
+    d=[1,t].min
+    @time-=d
+    t-=d
+    t
+  end
+  def ready
+    @time&lt;=0
+  end
 end
 
 describe StateMachine, &quot; with 2 mock-states and a decision-node&quot; do
-	before(:all) do
-		@d=StateMachineDefinition.new
-		@n1=@d.addNode(DelayState,:start)
-		@n2=@d.addNode(DecisionNode, :decision) do |node|(node.dict[:continue] ? :continue : :return) end
-		@n3=@d.addNode(DelayState,:end)
-		@d.addEdge(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">n1, at n2</A>)
-		@d.addEdge(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">n2, at n3</A>,:continue)
-		@d.addEdge(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">n2, at n1</A>,:return)
-		@d.startNode=@n1
-	end
-	before(:each) do
-		@m=@d.createMachine
-	end
-	it &quot;should return again and again when continue is false&quot; do
-		@m.state.id.should == @n1
-		@m.tick(0.5)
-		@m.state.id.should == @n1
-		@m.tick(0.5)
-		@m.state.id.should == @n2
-		@m.tick(0.5)
-		@m.state.id.should == @n1
-	end
-	it &quot;should finish when continue is true&quot; do
-		@m.dict[:continue]=true
-		@m.state.id.should == @n1
-		@m.tick(0.5)
-		@m.state.id.should == @n1
-		@m.tick(0.5)
-		@m.state.id.should == @n2
-		@m.tick(0.5)
-		@m.state.id.should == @n3
-	end
+  before(:all) do
+    @d=StateMachineDefinition.new
+    @n1=@d.addNode(DelayState,:start)
+    @n2=@d.addNode(DecisionNode, :decision) do |node|(node.dict[:continue] ? :continue : :return) end
+    @n3=@d.addNode(DelayState,:end)
+    @d.addEdge(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">n1, at n2</A>)
+    @d.addEdge(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">n2, at n3</A>,:continue)
+    @d.addEdge(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">n2, at n1</A>,:return)
+    @d.startNode=@n1
+  end
+  before(:each) do
+    @m=@d.createMachine
+  end
+  it &quot;should return again and again when continue is false&quot; do
+    @m.state.id.should == @n1
+    @m.tick(0.5)
+    @m.state.id.should == @n1
+    @m.tick(0.5)
+    @m.state.id.should == @n2
+    @m.tick(0.5)
+    @m.state.id.should == @n1
+  end
+  it &quot;should finish when continue is true&quot; do
+    @m.dict[:continue]=true
+    @m.state.id.should == @n1
+    @m.tick(0.5)
+    @m.state.id.should == @n1
+    @m.tick(0.5)
+    @m.state.id.should == @n2
+    @m.tick(0.5)
+    @m.state.id.should == @n3
+  end
 end
 

Modified: antargis/trunk/ruby/state_machine/state_machine.rb
===================================================================
--- antargis/trunk/ruby/state_machine/state_machine.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/state_machine/state_machine.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,209 +1,209 @@
 require 'ruby/ant_tools.rb'
 
 class StateMachineBase
-	attr_accessor :dict
+  attr_accessor :dict
 end
 
 class StateMachineNode
-	attr_reader :id
-	attr_accessor :machine
+  attr_reader :id
+  attr_accessor :machine
 
-	def initialize(pid)
-		assert{pid.is_a?(Symbol)}
+  def initialize(pid)
+    assert{pid.is_a?(Symbol)}
 
-		@id=pid
-	end
+    @id=pid
+  end
 
-	def eventEnter
-	end
-	def eventLeave
-	end
-	def eventFrame(t)
-		#raise &quot;should not be used!&quot;
-		t-0.5
-	end
+  def eventEnter
+  end
+  def eventLeave
+  end
+  def eventFrame(t)
+    #raise &quot;should not be used!&quot;
+    t-0.5
+  end
 
-	def assign(entity)
-	end
+  def assign(entity)
+  end
 
-	def ready
-		true
-	end
+  def ready
+    true
+  end
 
-	def output
-		nil
-	end
+  def output
+    nil
+  end
 
-	def dict
-		assert{@machine.is_a?(StateMachine)}
-		@machine.dict
-	end
+  def dict
+    assert{@machine.is_a?(StateMachine)}
+    @machine.dict
+  end
 end
 
 class StateMachineEdge
-	attr_reader :from, :to, :name
-	def initialize(from,to,name)
-		assert{from.is_a?(Symbol)}
-		assert{to.is_a?(Symbol)}
-		assert{name.is_a?(Symbol)}
-		@from=from
-		@to=to
-		@name=name
-	end
+  attr_reader :from, :to, :name
+  def initialize(from,to,name)
+    assert{from.is_a?(Symbol)}
+    assert{to.is_a?(Symbol)}
+    assert{name.is_a?(Symbol)}
+    @from=from
+    @to=to
+    @name=name
+  end
 end
 
 class StateMachineDefinition
-	attr_reader :startNode
-	def initialize
-		@nodes={}
-		@edges={}
-		@blocks={}
-		@startNode=nil
-	end
+  attr_reader :startNode
+  def initialize
+    @nodes={}
+    @edges={}
+    @blocks={}
+    @startNode=nil
+  end
 
-	def startNode=(name)
-		assert(&quot;startNode is already a member node&quot;) {not @nodes[name].nil?}
-		@startNode=name
-	end
+  def startNode=(name)
+    assert(&quot;startNode is already a member node&quot;) {not @nodes[name].nil?}
+    @startNode=name
+  end
 
-	def addNode(nodeClass,name,&amp;block)
-		assert {nodeClass.ancestors.member?(StateMachineNode)}
-		assert {@nodes[name].nil?}
-		@nodes[name]=nodeClass
-		@blocks[name]=block
-		name
-	end
-	def addEdge(node1,node2,name=nil)
-		assert {hasNode(node1)}
-		assert {hasNode(node2)}
-		assert {name.is_a?(Symbol) || name.nil?}
-		name||=:default
-		edge=StateMachineEdge.new(node1,node2,name)
-		@edges[edge.from]||=[]
-		@edges[edge.from] &lt;&lt; edge
-	end
+  def addNode(nodeClass,name,&amp;block)
+    assert {nodeClass.ancestors.member?(StateMachineNode)}
+    assert {@nodes[name].nil?}
+    @nodes[name]=nodeClass
+    @blocks[name]=block
+    name
+  end
+  def addEdge(node1,node2,name=nil)
+    assert {hasNode(node1)}
+    assert {hasNode(node2)}
+    assert {name.is_a?(Symbol) || name.nil?}
+    name||=:default
+    edge=StateMachineEdge.new(node1,node2,name)
+    @edges[edge.from]||=[]
+    @edges[edge.from] &lt;&lt; edge
+  end
 
-	def nodeCount
-		@nodes.length
-	end
+  def nodeCount
+    @nodes.length
+  end
 
-	def ready?
-		(not @startNode.nil?)
-	end
+  def ready?
+    (not @startNode.nil?)
+  end
 
-	def getNextNode(nodeName,output)
-		output||=:default
-		return nil if @edges[nodeName].nil?
-		#puts &quot;ok&quot;
-		@edges[nodeName].each{|edge|
-			#puts &quot;#{edge.name} #{output}&quot;
-			if edge.name==output
-				return edge.to
-			end
-		}
-		nil
-	end
-	def hasNode(nodeName)
-		(not @nodes[nodeName].nil?)
-	end
-	
+  def getNextNode(nodeName,output)
+    output||=:default
+    return nil if @edges[nodeName].nil?
+    #puts &quot;ok&quot;
+    @edges[nodeName].each{|edge|
+      #puts &quot;#{edge.name} #{output}&quot;
+      if edge.name==output
+        return edge.to
+      end
+    }
+    nil
+  end
+  def hasNode(nodeName)
+    (not @nodes[nodeName].nil?)
+  end
+  
 
-	def getNodeClass(nodeName)
-		assert(&quot;getNodeClass checks if has node '#{nodeName}'&quot;) {hasNode(nodeName)}
-		@nodes[nodeName]
-	end
+  def getNodeClass(nodeName)
+    assert(&quot;getNodeClass checks if has node '#{nodeName}'&quot;) {hasNode(nodeName)}
+    @nodes[nodeName]
+  end
 
-	def createMachine
-		StateMachine.new(self)
-	end
+  def createMachine
+    StateMachine.new(self)
+  end
 
-	def getBlock(nodeName)
-		@blocks[nodeName]
-	end
+  def getBlock(nodeName)
+    @blocks[nodeName]
+  end
 end
 
 
 class StateMachine
-	MAX_LOOPS=20
-	attr_reader :finished
-	attr_accessor :dict
-	attr_accessor :debug
+  MAX_LOOPS=20
+  attr_reader :finished
+  attr_accessor :dict
+  attr_accessor :debug
 
-	def initialize(definition)
-		assert{definition.is_a?(StateMachineDefinition)}
-		assert(&quot;startnode not set!&quot;) {definition.ready?}
-		@definition=definition
-		@nodes={}
-		@dict={}
-		@currentNode=getNode(@definition.startNode)
-		@finished=false
-		@started=false
-	end
+  def initialize(definition)
+    assert{definition.is_a?(StateMachineDefinition)}
+    assert(&quot;startnode not set!&quot;) {definition.ready?}
+    @definition=definition
+    @nodes={}
+    @dict={}
+    @currentNode=getNode(@definition.startNode)
+    @finished=false
+    @started=false
+  end
 
-	def tick(timeFrame)
-		restTime=timeFrame
-		loops=0
-		while restTime&gt;0 and loops&lt;MAX_LOOPS
-			if not @started
-				@started=true
-				puts &quot;#{@currentNode.id}.eventEnter&quot; if @debug
-				@currentNode.eventEnter
-			end
-			restTime=@currentNode.eventFrame(restTime)
-			assert{restTime.is_a?(Numeric)}
-			if @currentNode.ready
-				output=@currentNode.output
-				nextNodeName=@definition.getNextNode(@currentNode.id,output)
-				#sputs &quot;FROM #{@currentNode.id} TO #{nextNodeName}&quot;
-				if nextNodeName.nil?
-					setFinished
-					return eventFinished
-				end
-				nextNode=getNode(nextNodeName)
-				@currentNode.eventLeave
-				@currentNode=nextNode
-				nextNode.eventEnter
-			end
-			loops+=1
-		end
-		raise &quot;Too many loops in StateMachine.tick(.) restFrame:#{restTime}&quot; if loops&gt;=MAX_LOOPS
-	end
+  def tick(timeFrame)
+    restTime=timeFrame
+    loops=0
+    while restTime&gt;0 and loops&lt;MAX_LOOPS
+      if not @started
+        @started=true
+        puts &quot;#{@currentNode.id}.eventEnter&quot; if @debug
+        @currentNode.eventEnter
+      end
+      restTime=@currentNode.eventFrame(restTime)
+      assert{restTime.is_a?(Numeric)}
+      if @currentNode.ready
+        output=@currentNode.output
+        nextNodeName=@definition.getNextNode(@currentNode.id,output)
+        #sputs &quot;FROM #{@currentNode.id} TO #{nextNodeName}&quot;
+        if nextNodeName.nil?
+          setFinished
+          return eventFinished
+        end
+        nextNode=getNode(nextNodeName)
+        @currentNode.eventLeave
+        @currentNode=nextNode
+        nextNode.eventEnter
+      end
+      loops+=1
+    end
+    raise &quot;Too many loops in StateMachine.tick(.) restFrame:#{restTime}&quot; if loops&gt;=MAX_LOOPS
+  end
 
-	def eventFinished
-	end
+  def eventFinished
+  end
 
-	def state
-		@currentNode
-	end
+  def state
+    @currentNode
+  end
 
-	def getState(state)
-		getNode(state)
-	end
+  def getState(state)
+    getNode(state)
+  end
 
-	private
-	def setFinished
-		@finished=true
-	end
+  private
+  def setFinished
+    @finished=true
+  end
 
-	def getNode(nodeName)
-		block=@definition.getBlock(nodeName)
-		if block
-			@nodes[nodeName]||=@definition.getNodeClass(nodeName).new(nodeName,block)
-		else
-			@nodes[nodeName]||=@definition.getNodeClass(nodeName).new(nodeName)
-		end
-		@nodes[nodeName].machine=self
-		@nodes[nodeName]
-	end
+  def getNode(nodeName)
+    block=@definition.getBlock(nodeName)
+    if block
+      @nodes[nodeName]||=@definition.getNodeClass(nodeName).new(nodeName,block)
+    else
+      @nodes[nodeName]||=@definition.getNodeClass(nodeName).new(nodeName)
+    end
+    @nodes[nodeName].machine=self
+    @nodes[nodeName]
+  end
 end
 
 class DecisionNode &lt; StateMachineNode
-	def initialize(id,block)
-		super(id)
-		@block=block
-	end
-	def output
-		@block.call(self)
-	end	
+  def initialize(id,block)
+    super(id)
+    @block=block
+  end
+  def output
+    @block.call(self)
+  end  
 end
 

Modified: antargis/trunk/ruby/state_machine/tests/state_machine_test.rb
===================================================================
--- antargis/trunk/ruby/state_machine/tests/state_machine_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/state_machine/tests/state_machine_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -2,57 +2,57 @@
 require 'test/unit'
 
 class MockState&lt;StateMachineNode
-	attr_accessor :dummyVar
-	def initialize(pid)
-		super(pid)	
-		@finished=true
-	end
-	def finished=(f)
-		@finished=f
-	end
-	def isFinished?
-		@finished
-	end
-	
+  attr_accessor :dummyVar
+  def initialize(pid)
+    super(pid)  
+    @finished=true
+  end
+  def finished=(f)
+    @finished=f
+  end
+  def isFinished?
+    @finished
+  end
+  
 end
 
 
 class SinglNodeTest &lt; Test::Unit::TestCase
-	def setup
-		d=StateMachineDefinition.new
-		
-		n=StateMachineNode.new(:start)
+  def setup
+    d=StateMachineDefinition.new
+    
+    n=StateMachineNode.new(:start)
 
-		d.addNode(n)
+    d.addNode(n)
 
-		d.startNode=(n)
+    d.startNode=(n)
 
-		@m=StateMachine.new(d)
-	end
+    @m=StateMachine.new(d)
+  end
 
-	def test_notFinishedWhenNotStarted
-		assert((not @m.finished),&quot;@m should not be finished when not yet started!&quot;)
-	end
+  def test_notFinishedWhenNotStarted
+    assert((not @m.finished),&quot;@m should not be finished when not yet started!&quot;)
+  end
 
-	def test_simplerun
-		@m.tick(10)
-		assert(@m.finished,&quot;@m should be finished!&quot;)
-	end
+  def test_simplerun
+    @m.tick(10)
+    assert(@m.finished,&quot;@m should be finished!&quot;)
+  end
 end
 
 class TwoMachinesSeparate &lt; Test::Unit::TestCase
-	def setup
-		d=StateMachineDefinition.new
-		n=MockState.new(:p0)
-		d &lt;&lt; (n)
-		d.startNode=n
-		@m1=StateMachine.new(d)
-		@m2=StateMachine.new(d)
-	end
+  def setup
+    d=StateMachineDefinition.new
+    n=MockState.new(:p0)
+    d &lt;&lt; (n)
+    d.startNode=n
+    @m1=StateMachine.new(d)
+    @m2=StateMachine.new(d)
+  end
 
-	def test_notSync
-		@m1.state.dummyVar=10
-		assert(@m2.state.dummyVar.nil?,&quot;@m2.state.dummyVar shouldn't be influenced by @m1.state.dummyVar&quot;)
-	end
+  def test_notSync
+    @m1.state.dummyVar=10
+    assert(@m2.state.dummyVar.nil?,&quot;@m2.state.dummyVar shouldn't be influenced by @m1.state.dummyVar&quot;)
+  end
 end
 

Modified: antargis/trunk/ruby/storyflow.rb
===================================================================
--- antargis/trunk/ruby/storyflow.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/storyflow.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -27,51 +27,51 @@
 #   * themselves are spoken by a person
 #
 # a simple example on how to create a story-flow:
-#			start=StoryFlow.new(&quot;recruit&quot;)
-#			start.push(&quot;Tutorial&quot;,&quot;Ok, you have recruited some men.&quot;)
-#			start.push(&quot;Tutorial&quot;,&quot;If you want to recruit all men select the button with the three swords. ....&quot;)
-#			start.push(&quot;Tutorial&quot;,&quot;When you're done with this go north and defeat your enemies. You .......&quot;)
-#			tellStory(start)
+#      start=StoryFlow.new(&quot;recruit&quot;)
+#      start.push(&quot;Tutorial&quot;,&quot;Ok, you have recruited some men.&quot;)
+#      start.push(&quot;Tutorial&quot;,&quot;If you want to recruit all men select the button with the three swords. ....&quot;)
+#      start.push(&quot;Tutorial&quot;,&quot;When you're done with this go north and defeat your enemies. You .......&quot;)
+#      tellStory(start)
 #
 class StoryFlow
-	attr_reader :name, :s
+  attr_reader :name, :s
 
-	# create a story-flow with identification &quot;name&quot;
-	def initialize(name)
-		@s=[]
-		@pos=0
-		@name=name
-	end
+  # create a story-flow with identification &quot;name&quot;
+  def initialize(name)
+    @s=[]
+    @pos=0
+    @name=name
+  end
 
-	# push a text with title &quot;name&quot; into the story-flow
-	def push(name,text)
-		@s.push([name,text])
-	end
+  # push a text with title &quot;name&quot; into the story-flow
+  def push(name,text)
+    @s.push([name,text])
+  end
 
-	# return current text
-	def getCurrent
-		return nil if @s.length&lt;=@pos
-		c=@s[@pos]
-		return c
-	end
-		
+  # return current text
+  def getCurrent
+    return nil if @s.length&lt;=@pos
+    c=@s[@pos]
+    return c
+  end
+    
 
-	# you won't need this unless you're implementing within the actual application-object
-	def get
-		return nil if @s.length&lt;=@pos
-		c=@s[@pos]
-		@pos+=1
-		return c
-	end
-	# you won't need this unless you're implementing within the actual application-object
-	def append(flow)
-		@s+=flow.s
-		@name=flow.name
-	end
-	# you won't need this unless you're implementing within the actual application-object
-	def back
-		if @pos&gt;0
-			@pos-=1
-		end
-	end	
-end
\ No newline at end of file
+  # you won't need this unless you're implementing within the actual application-object
+  def get
+    return nil if @s.length&lt;=@pos
+    c=@s[@pos]
+    @pos+=1
+    return c
+  end
+  # you won't need this unless you're implementing within the actual application-object
+  def append(flow)
+    @s+=flow.s
+    @name=flow.name
+  end
+  # you won't need this unless you're implementing within the actual application-object
+  def back
+    if @pos&gt;0
+      @pos-=1
+    end
+  end  
+end

Modified: antargis/trunk/ruby/terrain_2d.rb
===================================================================
--- antargis/trunk/ruby/terrain_2d.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/terrain_2d.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -2,42 +2,42 @@
 end
 
 class Terrain2D&lt;TerrainBase
-	def initialize(scene,map)
-		super
-		@scene=scene
-		@map=map
-		createTiles
-	end
+  def initialize(scene,map)
+    super
+    @scene=scene
+    @map=map
+    createTiles
+  end
 
-	def createTiles
-		@textures={
-			:grass=&gt;AGTexture.new(AGSurface.load(&quot;data/textures/2d/terrain/full_grass.png&quot;)),
-			:grass2=&gt;AGTexture.new(AGSurface.load(&quot;data/textures/2d/terrain/full_grass2.png&quot;)),
-			:water=&gt;AGTexture.new(AGSurface.load(&quot;data/textures/2d/terrain/full_water.png&quot;))
-		}
-		@meshdata={}
-		@textures.each{|k,v|
-			@meshdata[k]=Mesh2DData.new(v)
-		}
+  def createTiles
+    @textures={
+      :grass=&gt;AGTexture.new(AGSurface.load(&quot;data/textures/2d/terrain/full_grass.png&quot;)),
+      :grass2=&gt;AGTexture.new(AGSurface.load(&quot;data/textures/2d/terrain/full_grass2.png&quot;)),
+      :water=&gt;AGTexture.new(AGSurface.load(&quot;data/textures/2d/terrain/full_water.png&quot;))
+    }
+    @meshdata={}
+    @textures.each{|k,v|
+      @meshdata[k]=Mesh2DData.new(v)
+    }
 
-		(0..(@map.getW/4-2)).each{|x|
-			(0..(@map.getH/2-1)).each{|y|
-				ix=x
-				iy=y
-				ix*=4
-				iy*=2
-				v=AGVector4.new(ix,iy,0,1)
-				t=:grass
-				if @map.getHeight(ix+2,iy+1)&lt;0
-					t=:water
-				end
-# 				if x+y&gt;5
-# 					t=:grass2
-# 				end
-				mesh=Terrain2DTile.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">scene, at meshdata</A>[t],v,0)
-				@scene.addNode(mesh)
-				mesh.setOrder(TERRAIN_Z)
-			}
-		}
-	end
+    (0..(@map.getW/4-2)).each{|x|
+      (0..(@map.getH/2-1)).each{|y|
+        ix=x
+        iy=y
+        ix*=4
+        iy*=2
+        v=AGVector4.new(ix,iy,0,1)
+        t=:grass
+        if @map.getHeight(ix+2,iy+1)&lt;0
+          t=:water
+        end
+#         if x+y&gt;5
+#           t=:grass2
+#         end
+        mesh=Terrain2DTile.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">scene, at meshdata</A>[t],v,0)
+        @scene.addNode(mesh)
+        mesh.setOrder(TERRAIN_Z)
+      }
+    }
+  end
 end

Modified: antargis/trunk/ruby/test_ant3.rb
===================================================================
--- antargis/trunk/ruby/test_ant3.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/test_ant3.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -5,29 +5,29 @@
 require 'ruby/antargislib.rb'
 
 class App&lt;GLApp
-	def initialize(w,h)
-		super
-		
-		data=AnimMeshData.new(&quot;data/models/sheep.anim&quot;)
-		data.setTransform(AGMatrix4.new(Math::PI,AGVector3.new(0,0,1))*AGMatrix4.new(Math::PI/2,AGVector3.new(1,0,0)))
-		
-		puts &quot;YAY&quot;
-		@n=AnimMesh.new(getScene,data)
-		
-		@n.setAnimation(&quot;go&quot;)
-		getScene.addNode(@n)
-		@rot=0.0
-	end
-	
-	def eventFrame(s)
-		super(s)
-		@rot+=1
-		@n.setRotation(AGVector3.new(0,0,1)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at rot</A>)
-		if @rot&gt;180
-			@n.setAnimation(&quot;eat&quot;)
-		end
-	end
+  def initialize(w,h)
+    super
+    
+    data=AnimMeshData.new(&quot;data/models/sheep.anim&quot;)
+    data.setTransform(AGMatrix4.new(Math::PI,AGVector3.new(0,0,1))*AGMatrix4.new(Math::PI/2,AGVector3.new(1,0,0)))
+    
+    puts &quot;YAY&quot;
+    @n=AnimMesh.new(getScene,data)
+    
+    @n.setAnimation(&quot;go&quot;)
+    getScene.addNode(@n)
+    @rot=0.0
+  end
+  
+  def eventFrame(s)
+    super(s)
+    @rot+=1
+    @n.setRotation(AGVector3.new(0,0,1)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at rot</A>)
+    if @rot&gt;180
+      @n.setAnimation(&quot;eat&quot;)
+    end
+  end
 end
 
 a=App.new(800,600)
-a.run
\ No newline at end of file
+a.run

Modified: antargis/trunk/ruby/tests/3d_engine/wireframe.rb
===================================================================
--- antargis/trunk/ruby/tests/3d_engine/wireframe.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/3d_engine/wireframe.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -14,26 +14,26 @@
 
 
 class MWidget&lt;AGGLWidget
-	def initialize(p,r)
-		super
-		@scene=Scene.new(r.width.to_i,r.height.to_i)
+  def initialize(p,r)
+    super
+    @scene=Scene.new(r.width.to_i,r.height.to_i)
 
-		wireframe=Boa3dWireframe.new(@scene)
+    wireframe=Boa3dWireframe.new(@scene)
 
-		a=AGVector3.new(0,0,0)
-		b=AGVector3.new(10,0,0)
-		white=AGVector4.new(1,1,1,1)
+    a=AGVector3.new(0,0,0)
+    b=AGVector3.new(10,0,0)
+    white=AGVector4.new(1,1,1,1)
 
-		wireframe.addLine(a,b,white)
+    wireframe.addLine(a,b,white)
 
-		@scene.addNode(wireframe)
+    @scene.addNode(wireframe)
 
-	end
-	def drawGL
-		@scene.draw
-	end
+  end
+  def drawGL
+    @scene.draw
+  end
 
-	
+  
 end
 
 widget=MWidget.new(nil,AGRect2.new(0,0,640,480))

Modified: antargis/trunk/ruby/tests/algebra_test.rb
===================================================================
--- antargis/trunk/ruby/tests/algebra_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/algebra_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,62 +7,62 @@
 setDebugLevel(0)
 
 def inverseTest
-	m=AGMatrixN.new(4,4)
-	
-	a=
-	[[1,-1,0,0],
-	[0,1,-1,0],
-	[0,0,1,-1],
-	[1,0,0,1]]
-	
-	(0..3).each{|x|
-		(0..3).each{|y|
-			m.set(x,y,a[y][x])
-		}
-	}
-	puts &quot;M:&quot;
-	m.output
-	
-	x=m.inverse
-	
-	y=m*x
-	puts &quot;Y:&quot;
-	y.output
+  m=AGMatrixN.new(4,4)
+  
+  a=
+  [[1,-1,0,0],
+  [0,1,-1,0],
+  [0,0,1,-1],
+  [1,0,0,1]]
+  
+  (0..3).each{|x|
+    (0..3).each{|y|
+      m.set(x,y,a[y][x])
+    }
+  }
+  puts &quot;M:&quot;
+  m.output
+  
+  x=m.inverse
+  
+  y=m*x
+  puts &quot;Y:&quot;
+  y.output
 end
 
 def multTest
-	a=AGMatrixN.new(2,2)
-	b=AGMatrixN.new(2,2)
-	a.makeUnitMatrix
-	b.makeUnitMatrix
-	a.set(0,1,10)
-	b.set(0,1,10)
-	puts &quot;a:&quot;	
-	a.output
-	puts &quot;b:&quot;	
-	b.output
-	c=a*b
-	puts &quot;c:&quot;	
-	c.output
+  a=AGMatrixN.new(2,2)
+  b=AGMatrixN.new(2,2)
+  a.makeUnitMatrix
+  b.makeUnitMatrix
+  a.set(0,1,10)
+  b.set(0,1,10)
+  puts &quot;a:&quot;  
+  a.output
+  puts &quot;b:&quot;  
+  b.output
+  c=a*b
+  puts &quot;c:&quot;  
+  c.output
 end
 
 def invTest2
-	a=AGMatrixN.new(3,3)
-	a.set(0,0,1)
-	a.set(0,1,1)
-	a.set(1,0,1)
-	a.set(2,2,2)
-	puts &quot;a:&quot;
-	a.output
-	i=a.inverse
-	puts &quot;i:&quot;
-	i.output
+  a=AGMatrixN.new(3,3)
+  a.set(0,0,1)
+  a.set(0,1,1)
+  a.set(1,0,1)
+  a.set(2,2,2)
+  puts &quot;a:&quot;
+  a.output
+  i=a.inverse
+  puts &quot;i:&quot;
+  i.output
 
-	t=a*i
-	puts &quot;t:&quot;
-	t.output
+  t=a*i
+  puts &quot;t:&quot;
+  t.output
 end
 
 #multTest
 #invTest2
-inverseTest
\ No newline at end of file
+inverseTest

Modified: antargis/trunk/ruby/tests/basis_test.rb
===================================================================
--- antargis/trunk/ruby/tests/basis_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/basis_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -5,50 +5,50 @@
 setDebugLevel(0)
 
 def makeBasis
-	m=AGMatrixN.new(2,8)
-	
-	a=[
-	[1,1,1,1],
-	[1,1,-1,-1],
-	[1,-1,0,0],
-	[0,0,1,-1],
-	]
+  m=AGMatrixN.new(2,8)
+  
+  a=[
+  [1,1,1,1],
+  [1,1,-1,-1],
+  [1,-1,0,0],
+  [0,0,1,-1],
+  ]
 
-	a=[
-	[1,1,1,1,1,1,1,1],
-	[1,1,1,1,-1,-1,-1,-1],
-	[1,1,-1,-1,0,0,0,0],
-	[0,0,0,0,1,1,-1,-1],
-	[-1,1,0,0,0,0,0,0],
-	[0,0,-1,1,0,0,0,0],
-	[0,0,0,0,-1,1,0,0],
-	]
+  a=[
+  [1,1,1,1,1,1,1,1],
+  [1,1,1,1,-1,-1,-1,-1],
+  [1,1,-1,-1,0,0,0,0],
+  [0,0,0,0,1,1,-1,-1],
+  [-1,1,0,0,0,0,0,0],
+  [0,0,-1,1,0,0,0,0],
+  [0,0,0,0,-1,1,0,0],
+  ]
 
-	
-	(0..7).each{|x|
-		(0..1).each{|y|
-			m.set(y,x,a[y][x])
-		}
-	}
-	m
+  
+  (0..7).each{|x|
+    (0..1).each{|y|
+      m.set(y,x,a[y][x])
+    }
+  }
+  m
 end
 
 def makeSample(w)
-	v=AGMatrixN.new(1,w)
-	(0..(w-1)).each{|c|
-		v.set(0,c,rand)
-	}
-	v
+  v=AGMatrixN.new(1,w)
+  (0..(w-1)).each{|c|
+    v.set(0,c,rand)
+  }
+  v
 end
 
 def encode(basePair,v)
-	inv=basePair[1]
-	inv*v
+  inv=basePair[1]
+  inv*v
 end
 
 def decode(basePair,encodedV)
-	m=basePair[0]
-	m*encodedV
+  m=basePair[0]
+  m*encodedV
 end
 
 basis=makeBasis
@@ -84,15 +84,15 @@
 err2=0
 count=10000
 (0..count).each{|i|
-	sample=makeSample(8)
-	sample2=makeSample(8)
-	err2+=(sample-sample2).scalar
-	enc=encode(basePair,sample)
-	dec=decode(basePair,enc)
-	c=(dec-sample).scalar
-	#puts c
-	err+=c
-	
+  sample=makeSample(8)
+  sample2=makeSample(8)
+  err2+=(sample-sample2).scalar
+  enc=encode(basePair,sample)
+  dec=decode(basePair,enc)
+  c=(dec-sample).scalar
+  #puts c
+  err+=c
+  
 }
 
 puts err/count

Modified: antargis/trunk/ruby/tests/clip_test.rb
===================================================================
--- antargis/trunk/ruby/tests/clip_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/clip_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -5,33 +5,33 @@
 r=AGRect2.new(0,0,20,20)
 
 class MyWidget&lt;AGWidget
-	def initialize(p,r)
-		super
-		@a=AGClipping.new
-		@a.exclude(AGRect2.new(0,0,500,500))
-		@a.include(AGRect2.new(100,100,200,200))
-		@a.exclude(AGRect2.new(150,150,50,50))
-	end
-	def draw(p)
-		rs=@a.clip(AGRect2.new(0,0,400,400))
-		rs.each{|r|
-			p.fillRect(r,AGColor.new(
-				(rand*0xFF).to_i,
-				(rand*0xFF).to_i,
-				(rand*0xFF).to_i))
-		}
-	end
+  def initialize(p,r)
+    super
+    @a=AGClipping.new
+    @a.exclude(AGRect2.new(0,0,500,500))
+    @a.include(AGRect2.new(100,100,200,200))
+    @a.exclude(AGRect2.new(150,150,50,50))
+  end
+  def draw(p)
+    rs=@a.clip(AGRect2.new(0,0,400,400))
+    rs.each{|r|
+      p.fillRect(r,AGColor.new(
+        (rand*0xFF).to_i,
+        (rand*0xFF).to_i,
+        (rand*0xFF).to_i))
+    }
+  end
 end
 
 class MyApp&lt;AGApplication
-	def initialize
-		super
-		setMainWidget(MyWidget.new(nil,AGRect2.new(0,0,640,480)))
-	end
-	def eventFrame(t)	
-		delay(100)
-		true
-	end
+  def initialize
+    super
+    setMainWidget(MyWidget.new(nil,AGRect2.new(0,0,640,480)))
+  end
+  def eventFrame(t)  
+    delay(100)
+    true
+  end
 end
 app=MyApp.new
-app.run
\ No newline at end of file
+app.run

Modified: antargis/trunk/ruby/tests/clip_widget_test.rb
===================================================================
--- antargis/trunk/ruby/tests/clip_widget_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/clip_widget_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,65 +7,65 @@
 setDebugLevel(0)
 
 class MyWidget&lt;AGWidget
-	def initialize(p,r)
-		super
-	end
-	def draw(p)
-		c=AGColor.new(0xFF,0,0)#(rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
-		p.fillRect(getRect.origin,c)
-	end
+  def initialize(p,r)
+    super
+  end
+  def draw(p)
+    c=AGColor.new(0xFF,0,0)#(rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
+    p.fillRect(getRect.origin,c)
+  end
 end
 
 class MyWidget2&lt;AGWidget
-	def initialize(p,r)
-		super
-		@x=@y=0
-		eventFrame(0)
-		queryRedraw
-	end
-	def draw(p)
-		c=AGColor.new((rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
-		#c=AGColor.new(0,0,0)
-		p.fillRect(getRect.origin,c) #AGColor.new(0,0,0))
-		c=AGColor.new(0,0xFF,0) #(rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
-		#p.fillRect(@r,c)
-	end
-	def eventFrame(t)
-		if @inited
-		else
-			pushChangeRect(getRect.origin) #queryRedraw
-			@inited=true
-		end
-		@x+=1
-		@y+=3
-		@x%=width
-		@y%=height
-		@r=AGRect2.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x, at y</A>,10,10)
-		pushChangeRect(@r.grow(3))
-		#queryRedraw
-		true
-	end
+  def initialize(p,r)
+    super
+    @x=@y=0
+    eventFrame(0)
+    queryRedraw
+  end
+  def draw(p)
+    c=AGColor.new((rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
+    #c=AGColor.new(0,0,0)
+    p.fillRect(getRect.origin,c) #AGColor.new(0,0,0))
+    c=AGColor.new(0,0xFF,0) #(rand*0xFF).to_i,(rand*0xFF).to_i,(rand*0xFF).to_i)
+    #p.fillRect(@r,c)
+  end
+  def eventFrame(t)
+    if @inited
+    else
+      pushChangeRect(getRect.origin) #queryRedraw
+      @inited=true
+    end
+    @x+=1
+    @y+=3
+    @x%=width
+    @y%=height
+    @r=AGRect2.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x, at y</A>,10,10)
+    pushChangeRect(@r.grow(3))
+    #queryRedraw
+    true
+  end
 end
 
 class MyApp&lt;AGApplication
-	def initialize
-		super
-		@ws=[]
-		@m=MyWidget2.new(nil,AGRect2.new(50,50,200,200))
-		setMainWidget(@m)
-		@ws &lt;&lt; MyWidget.new(@m,AGRect2.new(5,5,110,70))
-		@ws &lt;&lt; AGButton.new(@m,AGRect2.new(10,10,100,50),AGStringUtf8.new(&quot;halo&quot;))
-		puts &quot;adddd...&quot;
-		#@ws.each{|w|@m.addChild(w)}
-		
+  def initialize
+    super
+    @ws=[]
+    @m=MyWidget2.new(nil,AGRect2.new(50,50,200,200))
+    setMainWidget(@m)
+    @ws &lt;&lt; MyWidget.new(@m,AGRect2.new(5,5,110,70))
+    @ws &lt;&lt; AGButton.new(@m,AGRect2.new(10,10,100,50),AGStringUtf8.new(&quot;halo&quot;))
+    puts &quot;adddd...&quot;
+    #@ws.each{|w|@m.addChild(w)}
+    
 
-	end
-	def eventFrame(t)
-		delay(10)
-		@m.eventFrame(t)
-		true
-	end
+  end
+  def eventFrame(t)
+    delay(10)
+    @m.eventFrame(t)
+    true
+  end
 end
 
 a=MyApp.new
-a.run
\ No newline at end of file
+a.run

Modified: antargis/trunk/ruby/tests/dirty_rects.rb
===================================================================
--- antargis/trunk/ruby/tests/dirty_rects.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/dirty_rects.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -6,39 +6,39 @@
 
 
 class MyWidget&lt;AGWidget
-	def initialize(p,r)
-		super
-		@x=0
-		@y=0
-	end
-	def prepareDraw
-	end
-	def draw(p)
-		#p.fillRect(AGRect2.new(0,0,300,300),AGColor.new(0,0,0))
-		p.fillRect(AGRect2.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x, at y</A>,10,10),AGColor.new(0xFF,0,0))
-	end
-	def eventFrame(t)
-		@x+=2
-		@y+=1
-		@x%=207
-		@y%=293
-		#queryRedraw
-		pushChangeRect(AGRect2.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x-2, at y-2</A>,12,12))
-	end
+  def initialize(p,r)
+    super
+    @x=0
+    @y=0
+  end
+  def prepareDraw
+  end
+  def draw(p)
+    #p.fillRect(AGRect2.new(0,0,300,300),AGColor.new(0,0,0))
+    p.fillRect(AGRect2.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x, at y</A>,10,10),AGColor.new(0xFF,0,0))
+  end
+  def eventFrame(t)
+    @x+=2
+    @y+=1
+    @x%=207
+    @y%=293
+    #queryRedraw
+    pushChangeRect(AGRect2.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">x-2, at y-2</A>,12,12))
+  end
 end
 
 class MyApp&lt;AGApplication
-	def initialize
-		super
-		@imw=MyWidget.new(nil,AGRect2.new(0,0,800,600))
-		setMainWidget(@imw)
-	end
-	def eventFrame(t)
-		@imw.eventFrame(t)
-		delay(5)
-		true
-	end
+  def initialize
+    super
+    @imw=MyWidget.new(nil,AGRect2.new(0,0,800,600))
+    setMainWidget(@imw)
+  end
+  def eventFrame(t)
+    @imw.eventFrame(t)
+    delay(5)
+    true
+  end
 end
 
 app=MyApp.new
-app.run
\ No newline at end of file
+app.run

Modified: antargis/trunk/ruby/tests/graph_test.rb
===================================================================
--- antargis/trunk/ruby/tests/graph_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/graph_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -3,10 +3,10 @@
 require 'ruby/antargislib.rb'
 
 #@mweighter=MapPathWeighter.new(self)
-#		@sgraph=makeGraph(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">self, at mweighter</A>,4)
-#		@dgraph=DecimatedGraph.new(@sgraph)
-#		@dgraph.decimate(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0.2, at mweighter</A>)
-#		@heuristic=computeHeuristic(@dgraph)
+#    @sgraph=makeGraph(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">self, at mweighter</A>,4)
+#    @dgraph=DecimatedGraph.new(@sgraph)
+#    @dgraph.decimate(<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">0.2, at mweighter</A>)
+#    @heuristic=computeHeuristic(@dgraph)
 
 
 

Modified: antargis/trunk/ruby/tests/gui_tests.rb
===================================================================
--- antargis/trunk/ruby/tests/gui_tests.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/gui_tests.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -3,13 +3,13 @@
 require 'ruby/antargislib.rb'
 
 class AGApplication
-	alias getNewEventOld getNewEvent
-	def getNewEvent
-		@eventDebugging||=File.open(&quot;events.txt&quot;,&quot;r&quot;)
-		if @eventDebugging.eof
-			return nil
-		end
-		s=@eventDebugging.readline
-		return toSDLEvent(s)
-	end 
-end
\ No newline at end of file
+  alias getNewEventOld getNewEvent
+  def getNewEvent
+    @eventDebugging||=File.open(&quot;events.txt&quot;,&quot;r&quot;)
+    if @eventDebugging.eof
+      return nil
+    end
+    s=@eventDebugging.readline
+    return toSDLEvent(s)
+  end 
+end

Modified: antargis/trunk/ruby/tests/impostor.rb
===================================================================
--- antargis/trunk/ruby/tests/impostor.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/impostor.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -5,33 +5,33 @@
 
 
 class MyApp&lt;GLApp
-	def initialize(w,h)
-		super
-		#node=Mesh.new(getScene,getMeshData(&quot;data/models/sack.ant2&quot;,0.3,&quot;data/textures/models/sack.png&quot;),AGVector4.new(0,0,0),0)
-		node=Mesh.new(getScene,getMeshData(&quot;data/models/workshop.ant2&quot;,0.18,&quot;data/textures/models/workshop.png&quot;),AGVector4.new(0,0,0),-50)
+  def initialize(w,h)
+    super
+    #node=Mesh.new(getScene,getMeshData(&quot;data/models/sack.ant2&quot;,0.3,&quot;data/textures/models/sack.png&quot;),AGVector4.new(0,0,0),0)
+    node=Mesh.new(getScene,getMeshData(&quot;data/models/workshop.ant2&quot;,0.18,&quot;data/textures/models/workshop.png&quot;),AGVector4.new(0,0,0),-50)
 
-		getScene.addNode(node)
+    getScene.addNode(node)
 
-		imp=AntImpostorData.new(node)
+    imp=AntImpostorData.new(node)
 
-		tex=imp.getTexture
-			
-		image=AGImage.new(nil,AGRect2.new(0,0,tex.width,tex.height),tex,false)
-		setMainWidget(image)
-		
-		getScene.removeNode(node)
-	end
+    tex=imp.getTexture
+      
+    image=AGImage.new(nil,AGRect2.new(0,0,tex.width,tex.height),tex,false)
+    setMainWidget(image)
+    
+    getScene.removeNode(node)
+  end
 
-	def eventFrame(t)
-		#imp=
-		delay(100)
-	puts t
-		return true
-	end
+  def eventFrame(t)
+    #imp=
+    delay(100)
+  puts t
+    return true
+  end
 
-#  	def draw(p)
-#  		p.blit(imp.getTexture)
-#  	end
+#    def draw(p)
+#      p.blit(imp.getTexture)
+#    end
 end
 
 #app=MyApp.new(128,128) #800,600)

Modified: antargis/trunk/ruby/tests/path/fields_test.rb
===================================================================
--- antargis/trunk/ruby/tests/path/fields_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/path/fields_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -19,9 +19,9 @@
 heightMap=HeightMap.new(nil,w,h)
 
 (0..w).each{|x|
-	(0..h).each{|y|
-		heightMap.set(x,y,rand)
-	}
+  (0..h).each{|y|
+    heightMap.set(x,y,rand)
+  }
 }
 
 
@@ -46,27 +46,27 @@
 image=AGSurface.new(w*fsize,h*fsize)
 
 def getColor(i)
-	j=i%8
-	j+=1
-	#puts &quot;J:#{j}&quot;
-	AGColor.new((j % 2)*255, ((j /2)%2)*255, (j / 4).to_i*255) #*(255.0-(i*2)/255.0)
+  j=i%8
+  j+=1
+  #puts &quot;J:#{j}&quot;
+  AGColor.new((j % 2)*255, ((j /2)%2)*255, (j / 4).to_i*255) #*(255.0-(i*2)/255.0)
 end
 
 
 (0..(w-1)).each{|x|
-	(0..(h-1)).each{|y|
-		fieldnum=pathData.getField(AGVector2.new(x,y))
-		if fieldnum&lt;20000
-			puts &quot;field:#{fieldnum}&quot;
-			color=getColor(fieldnum)
-			puts &quot;COLOR:#{color}&quot;
-			(0..(fsize-1)).each{|dx|
-				(0..(fsize-1)).each{|dy|
-					image.putPixel(x*fsize+dx,y*fsize+dy,color)
-				}
-			}
-		end
-	}
+  (0..(h-1)).each{|y|
+    fieldnum=pathData.getField(AGVector2.new(x,y))
+    if fieldnum&lt;20000
+      puts &quot;field:#{fieldnum}&quot;
+      color=getColor(fieldnum)
+      puts &quot;COLOR:#{color}&quot;
+      (0..(fsize-1)).each{|dx|
+        (0..(fsize-1)).each{|dy|
+          image.putPixel(x*fsize+dx,y*fsize+dy,color)
+        }
+      }
+    end
+  }
 }
 
 

Modified: antargis/trunk/ruby/tests/path/fields_test2.rb
===================================================================
--- antargis/trunk/ruby/tests/path/fields_test2.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/path/fields_test2.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -19,9 +19,9 @@
 heightMap=HeightMap.new(nil,w,h)
 
 (0..w).each{|x|
-	(0..h).each{|y|
-		heightMap.set(x,y,rand)
-	}
+  (0..h).each{|y|
+    heightMap.set(x,y,rand)
+  }
 }
 
 
@@ -59,41 +59,41 @@
 image=AGSurface.new(w*fsize,h*fsize)
 
 def getColor(i)
-	j=i%8
-	j+=1
-	AGColor.new((j % 2)*255, ((j /2)%2)*255, (j / 4).to_i*255) #*(255.0-(i*2)/255.0)
+  j=i%8
+  j+=1
+  AGColor.new((j % 2)*255, ((j /2)%2)*255, (j / 4).to_i*255) #*(255.0-(i*2)/255.0)
 end
 
 
 def displayFieldAssign(fieldCollection,image,w,h,fsize)
-	puts &quot;DISPLAYING DATA&quot;
-	(0..(w-1)).each{|x|
-		(0..(h-1)).each{|y|
-			fieldnum=fieldCollection.getFieldId(AGVector2.new(x,y))
-			if fieldnum&lt;20000
-				color=getColor(fieldnum)
-				(0..(fsize-1)).each{|dx|
-					(0..(fsize-1)).each{|dy|
-						image.putPixel(x*fsize+dx,y*fsize+dy,color)
-					}
-				}
-			end
-		}
-	}
+  puts &quot;DISPLAYING DATA&quot;
+  (0..(w-1)).each{|x|
+    (0..(h-1)).each{|y|
+      fieldnum=fieldCollection.getFieldId(AGVector2.new(x,y))
+      if fieldnum&lt;20000
+        color=getColor(fieldnum)
+        (0..(fsize-1)).each{|dx|
+          (0..(fsize-1)).each{|dy|
+            image.putPixel(x*fsize+dx,y*fsize+dy,color)
+          }
+        }
+      end
+    }
+  }
 end
 
 def displayDistanceData(field,image)
-	m=field.getMiddle
-	field.getVectors.each{|v|
-		
-		image.putPixel(v.x.to_i,v.y.to_i,AGColor.new(0xFF,0xFF,0xFF)*(1-(v-m).length*0.3))
-	}
+  m=field.getMiddle
+  field.getVectors.each{|v|
+    
+    image.putPixel(v.x.to_i,v.y.to_i,AGColor.new(0xFF,0xFF,0xFF)*(1-(v-m).length*0.3))
+  }
 end
 
 def displayNeighbors(field,image)
-	field.getNeighbors.each{|v|
-		image.putPixel(v.x.to_i,v.y.to_i,AGColor.new(0xFF,0,0))
-	}
+  field.getNeighbors.each{|v|
+    image.putPixel(v.x.to_i,v.y.to_i,AGColor.new(0xFF,0,0))
+  }
 end
 puts &quot;COMPUTE  DISTACNES:&quot;
 fieldCollection.computeDistances(distComputer)
@@ -101,10 +101,10 @@
 
 #displayFieldAssign(fieldCollection,image,w,h,fsize)
 (0..(fieldCollection.getFieldCount-1)).each{|num|
-	field=fieldCollection.getField(num)
-	#field.init
-	displayDistanceData(field,image)
-	#displayNeighbors(field,image)
+  field=fieldCollection.getField(num)
+  #field.init
+  displayDistanceData(field,image)
+  #displayNeighbors(field,image)
 }
 
 

Modified: antargis/trunk/ruby/tests/path/heuristic_test.rb
===================================================================
--- antargis/trunk/ruby/tests/path/heuristic_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/path/heuristic_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -13,13 +13,13 @@
 c=AGVector2.new(2,2)
 
 values=[
-	[a,b,3],
-	[b,c,4],
-	[c,a,5]
+  [a,b,3],
+  [b,c,4],
+  [c,a,5]
 ]
 
 values.each{|a|
-	f.store(a[0],a[1],a[2])
+  f.store(a[0],a[1],a[2])
 }
 
 stream=BinaryStringOut.new
@@ -32,7 +32,7 @@
 f2=StoredHeuristicFunction.new(stream)
 
 values.each{|a|
-	raise &quot;error within #{a}&quot; unless f2.get(a[0],a[1])==a[2] 
+  raise &quot;error within #{a}&quot; unless f2.get(a[0],a[1])==a[2] 
 }
 
-puts &quot;ok&quot;
\ No newline at end of file
+puts &quot;ok&quot;

Modified: antargis/trunk/ruby/tests/rect_test.rb
===================================================================
--- antargis/trunk/ruby/tests/rect_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/rect_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,24 +7,24 @@
 r=AGRect2.new(0,0,20,20)
 
 def checkPair(a,b)
-	l=a.difference(b)
-	l.each{|r|
-		puts &quot;ERROR: #{r} not in #{a}!&quot; unless a.contains(r)
-		puts &quot;ERROR: #{r} is in #{b}!&quot; if b.contains(r)
-	}
-	puts &quot;size:#{l.length}&quot;
-	#puts l
+  l=a.difference(b)
+  l.each{|r|
+    puts &quot;ERROR: #{r} not in #{a}!&quot; unless a.contains(r)
+    puts &quot;ERROR: #{r} is in #{b}!&quot; if b.contains(r)
+  }
+  puts &quot;size:#{l.length}&quot;
+  #puts l
 end
 
 [5,10].each{|w|
-	[5,10].each{|h|
-		[-20,-10,-5,0,5,10,20,30].each{|x|
-			[-20,-10,-5,0,5,10,20,30].each{|y|
-				a=AGRect2.new(x,y,w,h)
-				checkPair(r,a)
-			}
-		}
-	}
+  [5,10].each{|h|
+    [-20,-10,-5,0,5,10,20,30].each{|x|
+      [-20,-10,-5,0,5,10,20,30].each{|y|
+        a=AGRect2.new(x,y,w,h)
+        checkPair(r,a)
+      }
+    }
+  }
 }
 
-puts &quot;seems ok&quot;
\ No newline at end of file
+puts &quot;seems ok&quot;

Modified: antargis/trunk/ruby/tests/scene_2d.rb
===================================================================
--- antargis/trunk/ruby/tests/scene_2d.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/scene_2d.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -5,108 +5,108 @@
 getMain.initVideo(800,600,32,false,false)
 
 def makeExampleMesh(scene,type)
-	t=AGTexture.new(AGSurface.load(&quot;data/textures/2d/#{type}.png&quot;))
-	data=Mesh2DData.new(t)
-	mesh=Mesh2D.new(scene,data,AGVector4.new(0,0,0,1),0)
-	mesh.setOrder(TREE_Z)
-	mesh
+  t=AGTexture.new(AGSurface.load(&quot;data/textures/2d/#{type}.png&quot;))
+  data=Mesh2DData.new(t)
+  mesh=Mesh2D.new(scene,data,AGVector4.new(0,0,0,1),0)
+  mesh.setOrder(TREE_Z)
+  mesh
 end
 
 class MyTerrain #&lt;TerrainBase
-	def initialize(scene,map)
-		#super
-		@scene=scene
+  def initialize(scene,map)
+    #super
+    @scene=scene
 
-		createTiles
-	end
+    createTiles
+  end
 
-	def createTiles
-		@textures={
-			:grass=&gt;AGTexture.new(AGSurface.load(&quot;data/textures/2d/terrain/basic_grass.png&quot;)),
-			:grass2=&gt;AGTexture.new(AGSurface.load(&quot;data/textures/2d/terrain/basic_grass2.png&quot;))
-		}
-		@meshdata={}
-		@textures.each{|k,v|
-			@meshdata[k]=Mesh2DData.new(v)
-		}
+  def createTiles
+    @textures={
+      :grass=&gt;AGTexture.new(AGSurface.load(&quot;data/textures/2d/terrain/basic_grass.png&quot;)),
+      :grass2=&gt;AGTexture.new(AGSurface.load(&quot;data/textures/2d/terrain/basic_grass2.png&quot;))
+    }
+    @meshdata={}
+    @textures.each{|k,v|
+      @meshdata[k]=Mesh2DData.new(v)
+    }
 
-		(0..10).each{|x|
-			(0..100).each{|y|
-				ix=x*2+(y % 2)
-				iy=y
-				ix*=64
-				iy*=32
-				v=AGVector4.new(ix,iy,0,1)
-				t=:grass
-				if x+y&gt;5
-					t=:grass2
-				end
-				mesh=Mesh2D.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">scene, at meshdata</A>[t],v,0)
-				@scene.addNode(mesh)
-				mesh.setOrder(TERRAIN_Z)
-			}
-		}
-	end
+    (0..10).each{|x|
+      (0..100).each{|y|
+        ix=x*2+(y % 2)
+        iy=y
+        ix*=64
+        iy*=32
+        v=AGVector4.new(ix,iy,0,1)
+        t=:grass
+        if x+y&gt;5
+          t=:grass2
+        end
+        mesh=Mesh2D.new(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">scene, at meshdata</A>[t],v,0)
+        @scene.addNode(mesh)
+        mesh.setOrder(TERRAIN_Z)
+      }
+    }
+  end
 end
 
 
 class My2dWidget&lt;AGWidget
-	def initialize(p,r)
-		super
-		@scene=Scene2D.new(r.width.to_i,r.height.to_i)
-		mesh=makeExampleMesh(@scene,:farm)
-		mesh.setPos(AGVector3.new(130,50,0))
-		@scene.addNode(mesh)
-		mesh=makeExampleMesh(@scene,:tree)
-		mesh.setPos(AGVector3.new(300,50,0))
-		@scene.addNode(mesh)
+  def initialize(p,r)
+    super
+    @scene=Scene2D.new(r.width.to_i,r.height.to_i)
+    mesh=makeExampleMesh(@scene,:farm)
+    mesh.setPos(AGVector3.new(130,50,0))
+    @scene.addNode(mesh)
+    mesh=makeExampleMesh(@scene,:tree)
+    mesh.setPos(AGVector3.new(300,50,0))
+    @scene.addNode(mesh)
 
-		@terrain=MyTerrain.new(@scene,nil)
-	end
-	def draw(p)
-		@scene.setPainter(p)
-		@scene.draw
-		@scene.discardPainter
-	end
+    @terrain=MyTerrain.new(@scene,nil)
+  end
+  def draw(p)
+    @scene.setPainter(p)
+    @scene.draw
+    @scene.discardPainter
+  end
 
-	def eventMouseButtonDown(e)
-		#raise 1
-		@mousePos=e.getMousePosition
-		super
-	end
-	def eventMouseButtonUp(e)
-		@mousePos=nil
-		super
-	end
-	def eventMouseMotion(e)
-		if @mousePos
-			diff=<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">e.getMousePosition- at mousePos</A>
-			@mousePos=e.getMousePosition
-			p=@scene.getCamera.dim2+AGVector2.new(-diff[0],diff[1])
-			@scene.setCamera(AGVector4.new(p[0],p[1],0,1))
-			queryRedraw
-		end
-		super
-	end
+  def eventMouseButtonDown(e)
+    #raise 1
+    @mousePos=e.getMousePosition
+    super
+  end
+  def eventMouseButtonUp(e)
+    @mousePos=nil
+    super
+  end
+  def eventMouseMotion(e)
+    if @mousePos
+      diff=<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">e.getMousePosition- at mousePos</A>
+      @mousePos=e.getMousePosition
+      p=@scene.getCamera.dim2+AGVector2.new(-diff[0],diff[1])
+      @scene.setCamera(AGVector4.new(p[0],p[1],0,1))
+      queryRedraw
+    end
+    super
+  end
 
-# 	def prepareDraw
-# 		queryRedraw
-# 	end
+#   def prepareDraw
+#     queryRedraw
+#   end
 
 end
 
 class My2dTest&lt;AGApplication
-	def initialize
-		super
-		setMainWidget(My2dWidget.new(nil,AGRect2.new(0,0,getMain.width,getMain.height)))
-	end
-	def eventFrame(t)
-		
-		delay(20)
-		super
-	end
+  def initialize
+    super
+    setMainWidget(My2dWidget.new(nil,AGRect2.new(0,0,getMain.width,getMain.height)))
+  end
+  def eventFrame(t)
+    
+    delay(20)
+    super
+  end
 end
 
 app=My2dTest.new
 
-app.run
\ No newline at end of file
+app.run

Modified: antargis/trunk/ruby/tests/scissor_test.rb
===================================================================
--- antargis/trunk/ruby/tests/scissor_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/scissor_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -4,24 +4,24 @@
 require 'ruby/antargislib.rb'
 
 class MyWidget&lt;AGWidget
-	def draw(p)
-		super
-		p.fillRect(AGRect2.new(-10,-10,30,30),AGColor.new(0,0xFF,0xFF))
-		p.fillRect(AGRect2.new(1,1,2,2),AGColor.new(0xFF,0xFF,0xFF))
-	end
+  def draw(p)
+    super
+    p.fillRect(AGRect2.new(-10,-10,30,30),AGColor.new(0,0xFF,0xFF))
+    p.fillRect(AGRect2.new(1,1,2,2),AGColor.new(0xFF,0xFF,0xFF))
+  end
 end
 
 class MyApp&lt;AGApplication
-	def initialize
-		super
-		setMainWidget(MyWidget.new(nil,AGRect2.new(0,0,4,4)))
-	end
-	def eventFrame(t)
-		#puts &quot;eventFram&quot;
-		#delay(20)
-		tryQuit
-		return true
-	end
+  def initialize
+    super
+    setMainWidget(MyWidget.new(nil,AGRect2.new(0,0,4,4)))
+  end
+  def eventFrame(t)
+    #puts &quot;eventFram&quot;
+    #delay(20)
+    tryQuit
+    return true
+  end
 
 end
 

Modified: antargis/trunk/ruby/tests/sdl_texture.rb
===================================================================
--- antargis/trunk/ruby/tests/sdl_texture.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/sdl_texture.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -7,8 +7,8 @@
 
 
 class MyWidget&lt;AGWidget
-	def initialize(p,r)
-		super
+  def initialize(p,r)
+    super
 
 a=AGSurface.new(64,64)
 p=AGPainter.new(a)
@@ -16,7 +16,7 @@
 p.fillRect(AGRect2.new(10,10,10,10),AGColor.new(0xFF,0,0))
 p=nil
 a.save(&quot;test0.png&quot;)
-	@t1=AGTexture.new(a)
+  @t1=AGTexture.new(a)
 
 
 t=AGTexture.new(64,64)
@@ -28,23 +28,23 @@
 s.save(&quot;test1.png&quot;)
 
 
-	@t2=AGTexture.new(s)
+  @t2=AGTexture.new(s)
 
-		@t3=AGTexture.new(64,64)
-		@t3.beginPaint
-		@t3.blit(@t2,AGRect2.new(0,0,64,64),AGRect2.new(0,0,64,64))
-		@t3.endPaint
+    @t3=AGTexture.new(64,64)
+    @t3.beginPaint
+    @t3.blit(@t2,AGRect2.new(0,0,64,64),AGRect2.new(0,0,64,64))
+    @t3.endPaint
 s=AGSurface.new(@t3.sdlTexture)
 s.save(&quot;test2.png&quot;)
 
-	end
-	def draw(p)
-		#p.
-		p.fillRect(AGRect2.new(0,0,256,256),AGColor.new(0,0xFF,0))
-		p.blit(@t1,AGRect2.new(0,0,64,64))
-		p.blit(@t2,AGRect2.new(64,0,64,64))
-		p.blit(@t3,AGRect2.new(128,0,64,64))
-	end
+  end
+  def draw(p)
+    #p.
+    p.fillRect(AGRect2.new(0,0,256,256),AGColor.new(0,0xFF,0))
+    p.blit(@t1,AGRect2.new(0,0,64,64))
+    p.blit(@t2,AGRect2.new(64,0,64,64))
+    p.blit(@t3,AGRect2.new(128,0,64,64))
+  end
 end
 
 
@@ -54,4 +54,4 @@
 imw=MyWidget.new(nil,AGRect2.new(0,0,800,600))
 
 app.setMainWidget(imw)
-app.run
\ No newline at end of file
+app.run

Modified: antargis/trunk/ruby/tests/swig_derivation_test.rb
===================================================================
--- antargis/trunk/ruby/tests/swig_derivation_test.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/swig_derivation_test.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -12,29 +12,29 @@
 puts &quot;C:&quot;
 puts l,l.object_id,l.class
 l.each{|i|
-	puts i,i.object_id,i.class
+  puts i,i.object_id,i.class
 }
 
 l=s.getCurrentNodes
 
 l.each{|i|
-	puts i,i.object_id
+  puts i,i.object_id
 }
 
 l.each{|i|
-	puts i,i.object_id
+  puts i,i.object_id
 }
 
 l.each{|i|
-	puts i,i.object_id
+  puts i,i.object_id
 }
 
 l.each{|i|
-	puts i,i.object_id
+  puts i,i.object_id
 }
 
 l=s.getCurrentNodes
 
 l.each{|i|
-	puts i,i.object_id
+  puts i,i.object_id
 }

Modified: antargis/trunk/ruby/tests/test_path.rb
===================================================================
--- antargis/trunk/ruby/tests/test_path.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tests/test_path.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -35,7 +35,7 @@
 heuristic=computeHeuristic(dg)
 
 # class MyHeu&lt;HeuristicFunction
-# 	def distance(
+#   def distance(
 # end
 # 
 # heuristic
@@ -53,25 +53,25 @@
 
 $i=0
 class MDebug&lt;PathDebugging
-	def debugPath(p,h)
-		$i+=1
-		#ms=AGSurface.new(800,600)
-		t=getScreen
-		$dg.paintNode(t.getRect,t,$startVec,AGColor.new(0xFF,0,0xFF))
-		$dg.paintNode(t.getRect,t,$endVec,AGColor.new(0,0,0xFF))
-		$dg.paint(t.getRect,t,$heuristic)
-		p.paint(t.getRect,t,$dg.width)
-		
-		#t=AGTexture.new(ms)
-		#getScreen.blit(t,ms.getRect,ms.getRect)
-		p=AGPainter.new(getScreen)
-		p.renderText(h.to_s,AGVector2.new(80,0),AGFont.new)
-		p=nil
+  def debugPath(p,h)
+    $i+=1
+    #ms=AGSurface.new(800,600)
+    t=getScreen
+    $dg.paintNode(t.getRect,t,$startVec,AGColor.new(0xFF,0,0xFF))
+    $dg.paintNode(t.getRect,t,$endVec,AGColor.new(0,0,0xFF))
+    $dg.paint(t.getRect,t,$heuristic)
+    p.paint(t.getRect,t,$dg.width)
+    
+    #t=AGTexture.new(ms)
+    #getScreen.blit(t,ms.getRect,ms.getRect)
+    p=AGPainter.new(getScreen)
+    p.renderText(h.to_s,AGVector2.new(80,0),AGFont.new)
+    p=nil
 
 
-		getScreen.flip
-		$app.delay(500)
-	end
+    getScreen.flip
+    $app.delay(500)
+  end
 end
 
 d=MDebug.new

Modified: antargis/trunk/ruby/tools/anim_import.rb
===================================================================
--- antargis/trunk/ruby/tools/anim_import.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tools/anim_import.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -13,8 +13,8 @@
 require 'antargisgui.rb'
 
 if ARGV == nil or ARGV.length&lt;2
-	puts &quot;call: anim_import.rb mesh.txt mesh.ant3&quot;
-	exit
+  puts &quot;call: anim_import.rb mesh.txt mesh.ant3&quot;
+  exit
 end
 infilename=ARGV[0]
 outfilename=ARGV[1]
@@ -22,109 +22,109 @@
 $infile=File.open(infilename)
 
 def getline
-	if $infile.eof
-		throw &quot;getline reached eof&quot;
-	end
-	line=$infile.readline
-	if line=~/\/\/.*/ or line==&quot;\n&quot;
-		return getline
-	else
-		return line.gsub(&quot;\n&quot;,&quot;&quot;)
-	end
-		
+  if $infile.eof
+    throw &quot;getline reached eof&quot;
+  end
+  line=$infile.readline
+  if line=~/\/\/.*/ or line==&quot;\n&quot;
+    return getline
+  else
+    return line.gsub(&quot;\n&quot;,&quot;&quot;)
+  end
+    
 end
 
 def assert(cond)
-	if not cond
-		throw &quot;assertion failed&quot;
-	end
+  if not cond
+    throw &quot;assertion failed&quot;
+  end
 end
 
 class Vertex
-	def initialize(pos,tex,b)
-		@pos=pos
-		@tex=tex
-		@bone=b
-	end
-	def x
-		@pos.x
-	end
-	def y
-		@pos.y
-	end
-	def z
-		@pos.z
-	end
-	def tx
-		@tex.x
-	end
-	def ty
-		<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1- at tex.y</A>
-	end
-	def bone
-		@bone
-	end
+  def initialize(pos,tex,b)
+    @pos=pos
+    @tex=tex
+    @bone=b
+  end
+  def x
+    @pos.x
+  end
+  def y
+    @pos.y
+  end
+  def z
+    @pos.z
+  end
+  def tx
+    @tex.x
+  end
+  def ty
+    <A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1- at tex.y</A>
+  end
+  def bone
+    @bone
+  end
 end
 
 class Triangle
-	def initialize(v0,v1,v2,n0,n1,n2,g)
-		@group=g
-		@v0=v0
-		@v1=v1
-		@v2=v2
-		@n0=n0
-		@n1=n1
-		@n2=n2
-	end
-	def fvertices
-		[f0,f1,f2]
-	end
-	def f0
-		[$vertices[@v0],$normals[@n0]]
-	end
-	def f1
-		[$vertices[@v1],$normals[@n1]]
-	end
-	def f2
-		[$vertices[@v2],$normals[@n2]]
-	end
+  def initialize(v0,v1,v2,n0,n1,n2,g)
+    @group=g
+    @v0=v0
+    @v1=v1
+    @v2=v2
+    @n0=n0
+    @n1=n1
+    @n2=n2
+  end
+  def fvertices
+    [f0,f1,f2]
+  end
+  def f0
+    [$vertices[@v0],$normals[@n0]]
+  end
+  def f1
+    [$vertices[@v1],$normals[@n1]]
+  end
+  def f2
+    [$vertices[@v2],$normals[@n2]]
+  end
 end
 
 class Frame
-	def initialize(t,p,r)
-		@time=t
-		@pos=p
-		@rot=r
-	end
-	attr_reader :time, :rot, :pos
+  def initialize(t,p,r)
+    @time=t
+    @pos=p
+    @rot=r
+  end
+  attr_reader :time, :rot, :pos
 end
 
 class Bone
-	def initialize(p,r,par)
-		@pos=p
-		@rot=r
-		@frames=[]
-		if par
-			@parent=par
-		else
-			@parent=-1
-		end
-	end
-	def addFrame(f)
-		@frames.push(f)
-	end
-	def getFrame(t)
-		@frames.each{|f|
-			if f.time==t
-				return f
-			end
-		}
-		e= &quot;Frame &quot;+t.to_s+&quot; not Found!&quot;
-		puts e
-		#throw e
-		return Frame.new(t,AGVector3.new(0,0,0),AGVector3.new(0,0,0))
-	end
-	attr_reader :pos, :rot, :frames, :parent
+  def initialize(p,r,par)
+    @pos=p
+    @rot=r
+    @frames=[]
+    if par
+      @parent=par
+    else
+      @parent=-1
+    end
+  end
+  def addFrame(f)
+    @frames.push(f)
+  end
+  def getFrame(t)
+    @frames.each{|f|
+      if f.time==t
+        return f
+      end
+    }
+    e= &quot;Frame &quot;+t.to_s+&quot; not Found!&quot;
+    puts e
+    #throw e
+    return Frame.new(t,AGVector3.new(0,0,0),AGVector3.new(0,0,0))
+  end
+  attr_reader :pos, :rot, :frames, :parent
 end
 
 # read frames
@@ -151,37 +151,37 @@
 $nstart=0
 for mesh in 0..($meshes-1)
 
-	line=getline
-	$meshname,flags,$material=line.split(&quot; &quot;)
-	$meshname.gsub!(&quot;\&quot;&quot;,&quot;&quot;)
-	
-	# read vertices
-	line=getline
-	$numvertices=line.to_i
-	for i in 0..($numvertices-1)
-		line=getline
-		flags,x,y,z,u,v,bone=line.split(&quot; &quot;).collect{|x|x.to_f}
-		bone=bone.to_i
-		$vertices.push(Vertex.new(AGVector3.new(x,y,z),AGVector2.new(u,v),bone))
-	end
-	
-	#read normals
-	$numnormals=getline.to_i
-	for i in 0..($numnormals-1)
-		line=getline
-		x,y,z=line.split(&quot; &quot;).collect{|x|x.to_f}
-		$normals.push(AGVector3.new(x,y,z))
-	end
-	
-	#read triangles
-	$numtris=getline.to_i
-	for i in 0..($numtris-1)
-		line=getline
-		flag,i0,i1,i2,n0,n1,n2,g=line.split(&quot; &quot;).collect{|x|x.to_i}
-		$tris.push(Triangle.new(i0+$vstart, i1+$vstart, i2+$vstart, n0+$nstart, n1+$nstart, n2+$nstart ,g))
-	end
-	$vstart=$vertices.length
-	$nstart=$normals.length
+  line=getline
+  $meshname,flags,$material=line.split(&quot; &quot;)
+  $meshname.gsub!(&quot;\&quot;&quot;,&quot;&quot;)
+  
+  # read vertices
+  line=getline
+  $numvertices=line.to_i
+  for i in 0..($numvertices-1)
+    line=getline
+    flags,x,y,z,u,v,bone=line.split(&quot; &quot;).collect{|x|x.to_f}
+    bone=bone.to_i
+    $vertices.push(Vertex.new(AGVector3.new(x,y,z),AGVector2.new(u,v),bone))
+  end
+  
+  #read normals
+  $numnormals=getline.to_i
+  for i in 0..($numnormals-1)
+    line=getline
+    x,y,z=line.split(&quot; &quot;).collect{|x|x.to_f}
+    $normals.push(AGVector3.new(x,y,z))
+  end
+  
+  #read triangles
+  $numtris=getline.to_i
+  for i in 0..($numtris-1)
+    line=getline
+    flag,i0,i1,i2,n0,n1,n2,g=line.split(&quot; &quot;).collect{|x|x.to_i}
+    $tris.push(Triangle.new(i0+$vstart, i1+$vstart, i2+$vstart, n0+$nstart, n1+$nstart, n2+$nstart ,g))
+  end
+  $vstart=$vertices.length
+  $nstart=$normals.length
 end
 # read materials =1  !!!
 line=getline
@@ -189,35 +189,35 @@
 line.gsub!(&quot;Materials: &quot;,&quot;&quot;)
 $mats=line.to_i
 for mat in 1..$mats
-	#assert(line==&quot;Materials: 1&quot;)
-	line=getline
-	assert(line=~/&quot;.*&quot;/)
-	
-	# ambient
-	line=getline
-	r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
-	$ambient=AGVector4.new(r,g,b,a)
-	
-	# diffuse
-	line=getline
-	r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
-	$diffuse=AGVector4.new(r,g,b,a)
-	
-	# specular
-	line=getline
-	r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
-	$specular=AGVector4.new(r,g,b,a)
-	
-	# emissive
-	line=getline
-	r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
-	$emissive=AGVector4.new(r,g,b,a)
-	
-	$shininess=getline
-	$transparency=getline
-	
-	$colortex=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
-	$alphatex=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
+  #assert(line==&quot;Materials: 1&quot;)
+  line=getline
+  assert(line=~/&quot;.*&quot;/)
+  
+  # ambient
+  line=getline
+  r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
+  $ambient=AGVector4.new(r,g,b,a)
+  
+  # diffuse
+  line=getline
+  r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
+  $diffuse=AGVector4.new(r,g,b,a)
+  
+  # specular
+  line=getline
+  r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
+  $specular=AGVector4.new(r,g,b,a)
+  
+  # emissive
+  line=getline
+  r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
+  $emissive=AGVector4.new(r,g,b,a)
+  
+  $shininess=getline
+  $transparency=getline
+  
+  $colortex=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
+  $alphatex=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
 end
 line=getline
 puts line
@@ -228,44 +228,44 @@
 $bones=[]
 $bonenames={}
 for i in 0..($numbones-1)
-	name=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
-	parent=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
-	$bonenames[name]=i
-	flags,x,y,z,rx,ry,rz=getline.split(&quot; &quot;).collect{|a|a.to_f}
-	bone=Bone.new(AGVector3.new(x,y,z),AGVector3.new(rx,ry,rz),$bonenames[parent])
-	
-	poskeys=getline.to_i
-	pkeys={}
-	rkeys={}
-	for j in 1..poskeys
-		t,x,y,z = getline.split(&quot; &quot;).collect{|a|a.to_f}
-		pkeys[t]=AGVector3.new(x,y,z)
-	end
-	rotkeys=getline.to_i
-	for j in 1..rotkeys
-		t,x,y,z = getline.split(&quot; &quot;).collect{|a|a.to_f}
-		rkeys[t]=AGVector3.new(x,y,z)
-	end
-	
-	(rkeys.keys+pkeys.keys).sort.uniq.each{|t|
-		p=pkeys[t]
-		r=rkeys[t]
-		if not p
-			p=AGVector3.new(0,0,0)
-		end
-		if not r
-			r=AGVector3.new(0,0,0)
-		end
-		bone.addFrame(Frame.new(t,p,r))
-	}
-	$bones.push(bone)
+  name=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
+  parent=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
+  $bonenames[name]=i
+  flags,x,y,z,rx,ry,rz=getline.split(&quot; &quot;).collect{|a|a.to_f}
+  bone=Bone.new(AGVector3.new(x,y,z),AGVector3.new(rx,ry,rz),$bonenames[parent])
+  
+  poskeys=getline.to_i
+  pkeys={}
+  rkeys={}
+  for j in 1..poskeys
+    t,x,y,z = getline.split(&quot; &quot;).collect{|a|a.to_f}
+    pkeys[t]=AGVector3.new(x,y,z)
+  end
+  rotkeys=getline.to_i
+  for j in 1..rotkeys
+    t,x,y,z = getline.split(&quot; &quot;).collect{|a|a.to_f}
+    rkeys[t]=AGVector3.new(x,y,z)
+  end
+  
+  (rkeys.keys+pkeys.keys).sort.uniq.each{|t|
+    p=pkeys[t]
+    r=rkeys[t]
+    if not p
+      p=AGVector3.new(0,0,0)
+    end
+    if not r
+      r=AGVector3.new(0,0,0)
+    end
+    bone.addFrame(Frame.new(t,p,r))
+  }
+  $bones.push(bone)
 end
 
 begin
-	f=File.open(ARGV[1],&quot;r&quot;)
-	puts &quot;File '&quot;+ARGV[1]+&quot;' already exists!&quot;
-	puts &quot;Please give an other name!&quot;
-	exit
+  f=File.open(ARGV[1],&quot;r&quot;)
+  puts &quot;File '&quot;+ARGV[1]+&quot;' already exists!&quot;
+  puts &quot;Please give an other name!&quot;
+  exit
 rescue
 end
 
@@ -274,7 +274,7 @@
 fvertices=[]
 
 $tris.each{|t|
-	fvertices+=t.fvertices
+  fvertices+=t.fvertices
 }
 fvertices.uniq!
 puts &quot;distinct verts:&quot;+$vertices.length.to_s
@@ -284,34 +284,34 @@
 file.print [fvertices.length].pack(&quot;i&quot;)
 
 fvertices.each{|f|
-	a=[f[0].x,f[0].y,f[0].z,f[0].tx,f[0].ty,f[0].bone,f[1].x,f[1].y,f[1].z]
-	s=a.pack(&quot;fffffifff&quot;)
-	file.print s
+  a=[f[0].x,f[0].y,f[0].z,f[0].tx,f[0].ty,f[0].bone,f[1].x,f[1].y,f[1].z]
+  s=a.pack(&quot;fffffifff&quot;)
+  file.print s
 }
 
 file.print [$tris.length].pack(&quot;i&quot;)
 
 $tris.each{|t|
-	a=[]
-	t.fvertices.each{|v|
-		i=fvertices.index(v)
-		a.push(i)
-	}
-	file.print a.pack(&quot;iii&quot;)
+  a=[]
+  t.fvertices.each{|v|
+    i=fvertices.index(v)
+    a.push(i)
+  }
+  file.print a.pack(&quot;iii&quot;)
 }
 
 file.print [$bones.length].pack(&quot;i&quot;)
 $bones.each{|b|
-	a=[b.pos.x,b.pos.y,b.pos.z, b.rot.x,b.rot.y,b.rot.z,b.parent]
-	file.print a.pack(&quot;ffffffi&quot;)
+  a=[b.pos.x,b.pos.y,b.pos.z, b.rot.x,b.rot.y,b.rot.z,b.parent]
+  file.print a.pack(&quot;ffffffi&quot;)
 }
 
 keys=[]
 $bones.each{|b|
-	b.frames.each{|f|
-		keys.push(f.time)
-	}
-	keys.uniq!
+  b.frames.each{|f|
+    keys.push(f.time)
+  }
+  keys.uniq!
 }
 puts keys.collect{|x|x.to_s}.join(&quot; - &quot;)
 
@@ -319,11 +319,11 @@
 file.print [keys.length].pack(&quot;i&quot;)
 
 keys.each{|k|
-	file.print [k].pack(&quot;f&quot;)
-	$bones.each{|b|
-		f=b.getFrame(k)
-		file.print [f.pos.x,f.pos.y,f.pos.z,f.rot.x,f.rot.y,f.rot.z].pack(&quot;ffffff&quot;)
-	}
+  file.print [k].pack(&quot;f&quot;)
+  $bones.each{|b|
+    f=b.getFrame(k)
+    file.print [f.pos.x,f.pos.y,f.pos.z,f.rot.x,f.rot.y,f.rot.z].pack(&quot;ffffff&quot;)
+  }
 }
 
 file.close

Modified: antargis/trunk/ruby/tools/anim_import4.rb
===================================================================
--- antargis/trunk/ruby/tools/anim_import4.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tools/anim_import4.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -8,8 +8,8 @@
 require 'antargisgui.rb'
 
 if ARGV == nil or ARGV.length&lt;2
-	puts &quot;call: anim_import.rb mesh.txt mesh.ant4&quot;
-	exit
+  puts &quot;call: anim_import.rb mesh.txt mesh.ant4&quot;
+  exit
 end
 infilename=ARGV[0]
 outfilename=ARGV[1]
@@ -17,101 +17,101 @@
 $infile=File.open(infilename)
 
 def getline
-	if $infile.eof
-		throw &quot;getline reached eof&quot;
-	end
-	line=$infile.readline
-	if line=~/\/\/.*/ or line==&quot;\n&quot;
-		return getline
-	else
-		return line.gsub(&quot;\n&quot;,&quot;&quot;)
-	end
-		
+  if $infile.eof
+    throw &quot;getline reached eof&quot;
+  end
+  line=$infile.readline
+  if line=~/\/\/.*/ or line==&quot;\n&quot;
+    return getline
+  else
+    return line.gsub(&quot;\n&quot;,&quot;&quot;)
+  end
+    
 end
 
 def assert(cond)
-	if not cond
-		throw &quot;assertion failed&quot;
-	end
+  if not cond
+    throw &quot;assertion failed&quot;
+  end
 end
 
 class Vertex
-	def initialize(pos,tex,b)
-		@pos=pos
-		@tex=tex
-		@bone=b
-	end
-	def x
-		@pos.x
-	end
-	def y
-		@pos.y
-	end
-	def z
-		@pos.z
-	end
-	def tx
-		@tex.x
-	end
-	def ty
-		<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1- at tex.y</A>
-	end
-	def bone
-		@bone
-	end
+  def initialize(pos,tex,b)
+    @pos=pos
+    @tex=tex
+    @bone=b
+  end
+  def x
+    @pos.x
+  end
+  def y
+    @pos.y
+  end
+  def z
+    @pos.z
+  end
+  def tx
+    @tex.x
+  end
+  def ty
+    <A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">1- at tex.y</A>
+  end
+  def bone
+    @bone
+  end
 end
 
 class Triangle
-	def initialize(v0,v1,v2,n0,n1,n2,g)
-		@group=g
-		@v0=v0
-		@v1=v1
-		@v2=v2
-		@n0=n0
-		@n1=n1
-		@n2=n2
-	end
-	def fvertices
-		[f0,f1,f2]
-	end
-	def f0
-		[$vertices[@v0],$normals[@n0]]
-	end
-	def f1
-		[$vertices[@v1],$normals[@n1]]
-	end
-	def f2
-		[$vertices[@v2],$normals[@n2]]
-	end
+  def initialize(v0,v1,v2,n0,n1,n2,g)
+    @group=g
+    @v0=v0
+    @v1=v1
+    @v2=v2
+    @n0=n0
+    @n1=n1
+    @n2=n2
+  end
+  def fvertices
+    [f0,f1,f2]
+  end
+  def f0
+    [$vertices[@v0],$normals[@n0]]
+  end
+  def f1
+    [$vertices[@v1],$normals[@n1]]
+  end
+  def f2
+    [$vertices[@v2],$normals[@n2]]
+  end
 end
 
 class Frame
-	def initialize(t,pv)
-		@time=t
-		@v=pv
-	end
-	attr_reader :time, :v
+  def initialize(t,pv)
+    @time=t
+    @v=pv
+  end
+  attr_reader :time, :v
 end
 
 class Bone
-	def initialize(p,r,par)
-		@pos=p
-		@rot=r
-		@rframes=[]
-		@tframes=[]
-		if par
-			@parent=par
-		else
-			@parent=-1
-		end
-	end
-	def addRFrame(f)
-		@rframes.push(f)
-	end
-	def addTFrame(f)
-		@tframes.push(f)
-	end
-	attr_reader :pos, :rot, :rframes, :parent, :tframes
+  def initialize(p,r,par)
+    @pos=p
+    @rot=r
+    @rframes=[]
+    @tframes=[]
+    if par
+      @parent=par
+    else
+      @parent=-1
+    end
+  end
+  def addRFrame(f)
+    @rframes.push(f)
+  end
+  def addTFrame(f)
+    @tframes.push(f)
+  end
+  attr_reader :pos, :rot, :rframes, :parent, :tframes
 end
 
 # read frames
@@ -138,37 +138,37 @@
 $nstart=0
 for mesh in 0..($meshes-1)
 
-	line=getline
-	$meshname,flags,$material=line.split(&quot; &quot;)
-	$meshname.gsub!(&quot;\&quot;&quot;,&quot;&quot;)
-	
-	# read vertices
-	line=getline
-	$numvertices=line.to_i
-	for i in 0..($numvertices-1)
-		line=getline
-		flags,x,y,z,u,v,bone=line.split(&quot; &quot;).collect{|x|x.to_f}
-		bone=bone.to_i
-		$vertices.push(Vertex.new(AGVector3.new(x,y,z),AGVector2.new(u,v),bone))
-	end
-	
-	#read normals
-	$numnormals=getline.to_i
-	for i in 0..($numnormals-1)
-		line=getline
-		x,y,z=line.split(&quot; &quot;).collect{|x|x.to_f}
-		$normals.push(AGVector3.new(x,y,z))
-	end
-	
-	#read triangles
-	$numtris=getline.to_i
-	for i in 0..($numtris-1)
-		line=getline
-		flag,i0,i1,i2,n0,n1,n2,g=line.split(&quot; &quot;).collect{|x|x.to_i}
-		$tris.push(Triangle.new(i0+$vstart, i1+$vstart, i2+$vstart, n0+$nstart, n1+$nstart, n2+$nstart ,g))
-	end
-	$vstart=$vertices.length
-	$nstart=$normals.length
+  line=getline
+  $meshname,flags,$material=line.split(&quot; &quot;)
+  $meshname.gsub!(&quot;\&quot;&quot;,&quot;&quot;)
+  
+  # read vertices
+  line=getline
+  $numvertices=line.to_i
+  for i in 0..($numvertices-1)
+    line=getline
+    flags,x,y,z,u,v,bone=line.split(&quot; &quot;).collect{|x|x.to_f}
+    bone=bone.to_i
+    $vertices.push(Vertex.new(AGVector3.new(x,y,z),AGVector2.new(u,v),bone))
+  end
+  
+  #read normals
+  $numnormals=getline.to_i
+  for i in 0..($numnormals-1)
+    line=getline
+    x,y,z=line.split(&quot; &quot;).collect{|x|x.to_f}
+    $normals.push(AGVector3.new(x,y,z))
+  end
+  
+  #read triangles
+  $numtris=getline.to_i
+  for i in 0..($numtris-1)
+    line=getline
+    flag,i0,i1,i2,n0,n1,n2,g=line.split(&quot; &quot;).collect{|x|x.to_i}
+    $tris.push(Triangle.new(i0+$vstart, i1+$vstart, i2+$vstart, n0+$nstart, n1+$nstart, n2+$nstart ,g))
+  end
+  $vstart=$vertices.length
+  $nstart=$normals.length
 end
 # read materials =1  !!!
 line=getline
@@ -176,35 +176,35 @@
 line.gsub!(&quot;Materials: &quot;,&quot;&quot;)
 $mats=line.to_i
 for mat in 1..$mats
-	#assert(line==&quot;Materials: 1&quot;)
-	line=getline
-	assert(line=~/&quot;.*&quot;/)
-	
-	# ambient
-	line=getline
-	r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
-	$ambient=AGVector4.new(r,g,b,a)
-	
-	# diffuse
-	line=getline
-	r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
-	$diffuse=AGVector4.new(r,g,b,a)
-	
-	# specular
-	line=getline
-	r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
-	$specular=AGVector4.new(r,g,b,a)
-	
-	# emissive
-	line=getline
-	r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
-	$emissive=AGVector4.new(r,g,b,a)
-	
-	$shininess=getline
-	$transparency=getline
-	
-	$colortex=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
-	$alphatex=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
+  #assert(line==&quot;Materials: 1&quot;)
+  line=getline
+  assert(line=~/&quot;.*&quot;/)
+  
+  # ambient
+  line=getline
+  r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
+  $ambient=AGVector4.new(r,g,b,a)
+  
+  # diffuse
+  line=getline
+  r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
+  $diffuse=AGVector4.new(r,g,b,a)
+  
+  # specular
+  line=getline
+  r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
+  $specular=AGVector4.new(r,g,b,a)
+  
+  # emissive
+  line=getline
+  r,g,b,a=line.split(&quot; &quot;).collect{|x|x.to_f}
+  $emissive=AGVector4.new(r,g,b,a)
+  
+  $shininess=getline
+  $transparency=getline
+  
+  $colortex=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
+  $alphatex=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
 end
 line=getline
 puts line
@@ -215,33 +215,33 @@
 $bones=[]
 $bonenames={}
 for i in 0..($numbones-1)
-	name=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
-	parent=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
-	$bonenames[name]=i
-	flags,x,y,z,rx,ry,rz=getline.split(&quot; &quot;).collect{|a|a.to_f}
-	bone=Bone.new(AGVector3.new(x,y,z),AGVector3.new(rx,ry,rz),$bonenames[parent])
-	
-	poskeys=getline.to_i
-	pkeys={}
-	rkeys={}
-	for j in 1..poskeys
-		t,x,y,z = getline.split(&quot; &quot;).collect{|a|a.to_f}
-		bone.addTFrame(Frame.new(t,AGVector3.new(x,y,z)))
-	end
-	rotkeys=getline.to_i
-	for j in 1..rotkeys
-		t,x,y,z = getline.split(&quot; &quot;).collect{|a|a.to_f}
-		bone.addRFrame(Frame.new(t,AGVector3.new(x,y,z)))
-	end
-	
-	$bones.push(bone)
+  name=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
+  parent=getline.gsub(&quot;\&quot;&quot;,&quot;&quot;)
+  $bonenames[name]=i
+  flags,x,y,z,rx,ry,rz=getline.split(&quot; &quot;).collect{|a|a.to_f}
+  bone=Bone.new(AGVector3.new(x,y,z),AGVector3.new(rx,ry,rz),$bonenames[parent])
+  
+  poskeys=getline.to_i
+  pkeys={}
+  rkeys={}
+  for j in 1..poskeys
+    t,x,y,z = getline.split(&quot; &quot;).collect{|a|a.to_f}
+    bone.addTFrame(Frame.new(t,AGVector3.new(x,y,z)))
+  end
+  rotkeys=getline.to_i
+  for j in 1..rotkeys
+    t,x,y,z = getline.split(&quot; &quot;).collect{|a|a.to_f}
+    bone.addRFrame(Frame.new(t,AGVector3.new(x,y,z)))
+  end
+  
+  $bones.push(bone)
 end
 
 begin
-	f=File.open(ARGV[1],&quot;r&quot;)
-	puts &quot;File '&quot;+ARGV[1]+&quot;' already exists!&quot;
-	puts &quot;Please give an other name!&quot;
-	exit
+  f=File.open(ARGV[1],&quot;r&quot;)
+  puts &quot;File '&quot;+ARGV[1]+&quot;' already exists!&quot;
+  puts &quot;Please give an other name!&quot;
+  exit
 rescue
 end
 
@@ -250,7 +250,7 @@
 fvertices=[]
 
 $tris.each{|t|
-	fvertices+=t.fvertices
+  fvertices+=t.fvertices
 }
 fvertices.uniq!
 puts &quot;distinct verts:&quot;+$vertices.length.to_s
@@ -260,40 +260,40 @@
 file.print [fvertices.length].pack(&quot;i&quot;)
 
 fvertices.each{|f|
-	a=[f[0].x,f[0].y,f[0].z,f[0].tx,f[0].ty,f[0].bone,f[1].x,f[1].y,f[1].z]
-	s=a.pack(&quot;fffffifff&quot;)
-	file.print s
+  a=[f[0].x,f[0].y,f[0].z,f[0].tx,f[0].ty,f[0].bone,f[1].x,f[1].y,f[1].z]
+  s=a.pack(&quot;fffffifff&quot;)
+  file.print s
 }
 
 file.print [$tris.length].pack(&quot;i&quot;)
 
 $tris.each{|t|
-	a=[]
-	t.fvertices.each{|v|
-		i=fvertices.index(v)
-		a.push(i)
-	}
-	file.print a.pack(&quot;iii&quot;)
+  a=[]
+  t.fvertices.each{|v|
+    i=fvertices.index(v)
+    a.push(i)
+  }
+  file.print a.pack(&quot;iii&quot;)
 }
 
 file.print [$frames,$bones.length].pack(&quot;ii&quot;)
 $bones.each{|b|
-	a=[b.pos.x,b.pos.y,b.pos.z, b.rot.x,b.rot.y,b.rot.z,b.parent]
-	file.print a.pack(&quot;ffffffi&quot;)
-	
-	# rot frames
-	fs=b.rframes
-	file.print [fs.length].pack(&quot;i&quot;)
-	fs.each{|f|
-		file.print [f.time,f.v.x, f.v.y, f.v.z].pack(&quot;ffff&quot;)
-	}
-	
-	# translation frames
-	fs=b.tframes
-	file.print [fs.length].pack(&quot;i&quot;)
-	fs.each{|f|
-		file.print [f.time,f.v.x, f.v.y, f.v.z].pack(&quot;ffff&quot;)
-	}
+  a=[b.pos.x,b.pos.y,b.pos.z, b.rot.x,b.rot.y,b.rot.z,b.parent]
+  file.print a.pack(&quot;ffffffi&quot;)
+  
+  # rot frames
+  fs=b.rframes
+  file.print [fs.length].pack(&quot;i&quot;)
+  fs.each{|f|
+    file.print [f.time,f.v.x, f.v.y, f.v.z].pack(&quot;ffff&quot;)
+  }
+  
+  # translation frames
+  fs=b.tframes
+  file.print [fs.length].pack(&quot;i&quot;)
+  fs.each{|f|
+    file.print [f.time,f.v.x, f.v.y, f.v.z].pack(&quot;ffff&quot;)
+  }
 }
 
 file.close

Modified: antargis/trunk/ruby/tools/ant2obj.rb
===================================================================
--- antargis/trunk/ruby/tools/ant2obj.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/tools/ant2obj.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -8,27 +8,27 @@
 infile=ARGV[0]
 
 class Reader
-	def initialize(c)
-		@c=c
-		@pos=0
-		@vlen=[1].pack(&quot;v&quot;).length
-		@elen=[1].pack(&quot;e&quot;).length
-	end
-	def readV
-		v=@c[@pos..(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">pos+ at vlen</A>)].unpack(&quot;v&quot;)
-		@pos+=@vlen
-		return v[0]
-	end
-	def readE
-		v=@c[@pos..(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">pos+ at elen</A>)].unpack(&quot;e&quot;)
-		@pos+=@elen
-		return v[0]
-	end
+  def initialize(c)
+    @c=c
+    @pos=0
+    @vlen=[1].pack(&quot;v&quot;).length
+    @elen=[1].pack(&quot;e&quot;).length
+  end
+  def readV
+    v=@c[@pos..(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">pos+ at vlen</A>)].unpack(&quot;v&quot;)
+    @pos+=@vlen
+    return v[0]
+  end
+  def readE
+    v=@c[@pos..(@<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">pos+ at elen</A>)].unpack(&quot;e&quot;)
+    @pos+=@elen
+    return v[0]
+  end
 end
 
 def mreadv(c)
-	l=[1].pack(&quot;v&quot;).length
-	c=c[l..c.length]
+  l=[1].pack(&quot;v&quot;).length
+  c=c[l..c.length]
 end
 
 puts infile
@@ -41,13 +41,13 @@
 puts faces
 puts faces.class
 (1..faces).each{|x|
-	fsize=r.readV
-	puts fsize
-	(1..fsize).each{|v|
-		vertex=[r.readE,r.readE,r.readE]
-		normal=[r.readE,r.readE,r.readE]
-		color=[r.readE,r.readE,r.readE]
-		tex=[r.readE,r.readE]
-		puts vertex.join(&quot;/&quot;)
-	}
+  fsize=r.readV
+  puts fsize
+  (1..fsize).each{|v|
+    vertex=[r.readE,r.readE,r.readE]
+    normal=[r.readE,r.readE,r.readE]
+    color=[r.readE,r.readE,r.readE]
+    tex=[r.readE,r.readE]
+    puts vertex.join(&quot;/&quot;)
+  }
 }

Modified: antargis/trunk/ruby/two_d_app.rb
===================================================================
--- antargis/trunk/ruby/two_d_app.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/two_d_app.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -1,166 +1,166 @@
 require 'terrain_2d.rb'
 
 class Scene2D
-	def getPickTriangles
-		0
-	end
-	def getTriangles
-		0
-	end
-	def getDrawnMeshes
-		0
-	end
+  def getPickTriangles
+    0
+  end
+  def getTriangles
+    0
+  end
+  def getDrawnMeshes
+    0
+  end
 end
 
 class AntBaseMapViewWidget&lt;AGWidget
-	def initialize(p,r,scene)
-		super(p,r)
-		@scene=scene
-	end
+  def initialize(p,r,scene)
+    super(p,r)
+    @scene=scene
+  end
 
-	def draw(p)
-		@frame||=0
-		@frame+=1
+  def draw(p)
+    @frame||=0
+    @frame+=1
 
-		#if (@frame%2)==0
-			#p=AGPainter.new
-			@scene.setPainter(p)
-			@scene.draw
-			@scene.discardPainter
-			#p=nil
-			#GC.start
-		#end
-		super
-	end
-	def prepareDraw
-		queryRedraw
-		return
-		currentNodes=@scene.getCurrentNodes
-		puts &quot;currentNodes:#{currentNodes}(#{currentNodes.class})!&quot;
-		currentNodes.each{|n|
-			r=n.getLastDrawingRect
-			r2=n.getDrawingRect
-			if r!=r2
-				pushChangeRect(r)
-				pushChangeRect(r2)
-			end
-		}
+    #if (@frame%2)==0
+      #p=AGPainter.new
+      @scene.setPainter(p)
+      @scene.draw
+      @scene.discardPainter
+      #p=nil
+      #GC.start
+    #end
+    super
+  end
+  def prepareDraw
+    queryRedraw
+    return
+    currentNodes=@scene.getCurrentNodes
+    puts &quot;currentNodes:#{currentNodes}(#{currentNodes.class})!&quot;
+    currentNodes.each{|n|
+      r=n.getLastDrawingRect
+      r2=n.getDrawingRect
+      if r!=r2
+        pushChangeRect(r)
+        pushChangeRect(r2)
+      end
+    }
 
-	end
+  end
 end
 
 class AntBaseMapView&lt;AGApplication
-	def initialize(w,h)
-		super()
-		@scene=Scene2D.new(w,h)
-		@submain=nil
-		@mainWidget=nil
-		setMainWidget(@realMainWidget=AntBaseMapViewWidget.new(nil,AGRect2.new(0,0,w,h)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at scene</A>))
-	end
+  def initialize(w,h)
+    super()
+    @scene=Scene2D.new(w,h)
+    @submain=nil
+    @mainWidget=nil
+    setMainWidget(@realMainWidget=AntBaseMapViewWidget.new(nil,AGRect2.new(0,0,w,h)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at scene</A>))
+  end
 
- 	def setMainWidget(w)
- 		if w.is_a?(AntBaseMapViewWidget)
- 			super(w)
- 		else
- 			@realMainWidget.removeChild(@mainWidget) if @mainWidget
- 			@mainWidget=w
- 			@realMainWidget.addChild(w)
- 		end
- 	end
+   def setMainWidget(w)
+     if w.is_a?(AntBaseMapViewWidget)
+       super(w)
+     else
+       @realMainWidget.removeChild(@mainWidget) if @mainWidget
+       @mainWidget=w
+       @realMainWidget.addChild(w)
+     end
+   end
  
- 	def getMainWidget
- 		@mainWidget
- 	end
-# 	def draw()
-# 		super()
-# 	end
+   def getMainWidget
+     @mainWidget
+   end
+#   def draw()
+#     super()
+#   end
 
 
-	def getScene
-		@scene
-	end
-	def setCamera(p)
-		@scene.setCamera(AGVector4.new(p.x,p.y,0))
-	end
-	def eventFrame(t)
-	end
+  def getScene
+    @scene
+  end
+  def setCamera(p)
+    @scene.setCamera(AGVector4.new(p.x,p.y,0))
+  end
+  def eventFrame(t)
+  end
 
-# 	def eventKeyDown(e)
-# 		super
-# 	end
+#   def eventKeyDown(e)
+#     super
+#   end
 
-	def eventMouseButtonDown(e)
-		#raise 1
-		case e.getButton
-			when 1
-				@mousePos=e.getMousePosition
-		end
-		@mayclick=true
-		super
-	end
-	def eventMouseButtonUp(e)
-		case e.getButton
-			when 1
-				@mousePos=nil
-		end
-		if @mayclick
-			nodes=tryClick(e.getMousePosition)
-			nodes.each{|n|
+  def eventMouseButtonDown(e)
+    #raise 1
+    case e.getButton
+      when 1
+        @mousePos=e.getMousePosition
+    end
+    @mayclick=true
+    super
+  end
+  def eventMouseButtonUp(e)
+    case e.getButton
+      when 1
+        @mousePos=nil
+    end
+    if @mayclick
+      nodes=tryClick(e.getMousePosition)
+      nodes.each{|n|
         puts &quot;NODE: #{n}(#{n.class})&quot;
         puts &quot;NODE:&quot;+(getMap.getEntity(n.node).to_s)
-			}
-			eventClick(nodes,e.getButton)
-		end
-		super
-	end
-	def eventMouseMotion(e)
-		@mayclick=false
-		if @mousePos
-			diff=<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">e.getMousePosition- at mousePos</A>
-			diff=diff*0.03
-			@mousePos=e.getMousePosition
-			p=@scene.getCamera.dim2+AGVector2.new(-diff[0],diff[1])
-			@scene.setCamera(AGVector4.new(p[0],p[1],0,1))
-			#queryRedraw
-		end
-		super
-	end
-	private
-	def tryClick(pos)
-		nodes=@scene.pick(pos.x,pos.y,1,1)	
-	end
+      }
+      eventClick(nodes,e.getButton)
+    end
+    super
+  end
+  def eventMouseMotion(e)
+    @mayclick=false
+    if @mousePos
+      diff=<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">e.getMousePosition- at mousePos</A>
+      diff=diff*0.03
+      @mousePos=e.getMousePosition
+      p=@scene.getCamera.dim2+AGVector2.new(-diff[0],diff[1])
+      @scene.setCamera(AGVector4.new(p[0],p[1],0,1))
+      #queryRedraw
+    end
+    super
+  end
+  private
+  def tryClick(pos)
+    nodes=@scene.pick(pos.x,pos.y,1,1)  
+  end
 end
 
 require 'map.rb'
 
 class AntRubyMap
-	def initTerrainMesh
-		setTerrain(Terrain2D.new(getScene,self))
-	end
+  def initTerrainMesh
+    setTerrain(Terrain2D.new(getScene,self))
+  end
 end
 
 
 require 'ant_models.rb'
 
 module AntModels
-	def AntModels.createModel(entityType,subType=nil,angle=nil)
-		type=entityType.to_s
-		if subType.to_s!=&quot;&quot;
-			type+=&quot;_&quot;+subType.to_s
-		end
-		t=AGTexture.new(AGSurface.load(&quot;data/textures/2d/#{type}.png&quot;))
-		data=Mesh2DData.new(t)
-		mesh=Mesh2D.new(getMap.getScene,data,AGVector4.new(0,0,0,1),0)
-		mesh.setOrder(TREE_Z)
-		mesh
-	end
+  def AntModels.createModel(entityType,subType=nil,angle=nil)
+    type=entityType.to_s
+    if subType.to_s!=&quot;&quot;
+      type+=&quot;_&quot;+subType.to_s
+    end
+    t=AGTexture.new(AGSurface.load(&quot;data/textures/2d/#{type}.png&quot;))
+    data=Mesh2DData.new(t)
+    mesh=Mesh2D.new(getMap.getScene,data,AGVector4.new(0,0,0,1),0)
+    mesh.setOrder(TREE_Z)
+    mesh
+  end
 end
 
 
 # some hacks
 class Mesh2D
-	def setRingColor(c)
-	end
-	def setAnimation(a)
-	end
-end
\ No newline at end of file
+  def setRingColor(c)
+  end
+  def setAnimation(a)
+  end
+end

Modified: antargis/trunk/ruby/widgets/ant_buttonpanel.rb
===================================================================
--- antargis/trunk/ruby/widgets/ant_buttonpanel.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/widgets/ant_buttonpanel.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -14,118 +14,118 @@
 # * sigJobChanged
 # You can attach your listeners to these to receive events when the aggression or a job is changed.
 class AntButtonPanel&lt;AGWidget
-	attr_reader :job
-	
+  attr_reader :job
+  
 
-	def initialize(p,r)
-		super(p,r)
-		setName(&quot;ButtonPanel&quot;)
-		clearHandlers
-		@jobButtons=[&quot;doRest&quot;,&quot;doDismiss&quot;,&quot;doDropFood&quot;,&quot;doDropWeapon&quot;,&quot;doBuild&quot;]
-		@aggButtons={&quot;doAgg0&quot;=&gt;1,&quot;doAgg1&quot;=&gt;2,&quot;doAgg2&quot;=&gt;3}
-		@inited=false
-		@agg=1
+  def initialize(p,r)
+    super(p,r)
+    setName(&quot;ButtonPanel&quot;)
+    clearHandlers
+    @jobButtons=[&quot;doRest&quot;,&quot;doDismiss&quot;,&quot;doDropFood&quot;,&quot;doDropWeapon&quot;,&quot;doBuild&quot;]
+    @aggButtons={&quot;doAgg0&quot;=&gt;1,&quot;doAgg1&quot;=&gt;2,&quot;doAgg2&quot;=&gt;3}
+    @inited=false
+    @agg=1
 
-		addSignal(&quot;sigAggressionChanged&quot;)
-		addSignal(&quot;sigJobChanged&quot;)
+    addSignal(&quot;sigAggressionChanged&quot;)
+    addSignal(&quot;sigJobChanged&quot;)
 
-		@hero=nil
-	end
+    @hero=nil
+  end
 
-	# set the current hero *h* of class AntHero
-	def setHero(h)
-		assert{h.is_a?(AntHero) || h.nil?}
-		@hero=h
-		if @hero
-			setName(@hero.getName)
-		else
-			setName(_(&quot;no hero&quot;))
-		end
-	end
+  # set the current hero *h* of class AntHero
+  def setHero(h)
+    assert{h.is_a?(AntHero) || h.nil?}
+    @hero=h
+    if @hero
+      setName(@hero.getName)
+    else
+      setName(_(&quot;no hero&quot;))
+    end
+  end
 
 
-	# event-handlers can't be initialized in the constructor initialize, because
-	# possible children are not yet created.
-	# *initHandlers* initializes event-handlers for the job- and aggression-selection buttons.
-	# FIXME: this function should only be called once ! may be check this
-	def initHandlers
-		getChild(&quot;doAgg0&quot;).setChecked(true)
-		@job=&quot;doRest&quot;
-		@jobButtons.each {|b|
-			c=getChild(b)
-			addHandler(c,:sigClick,:eventJobSelected)
-		}
-		@aggButtons.each {|b,a|
-			c=getChild(b)
-			addHandler(c,:sigClick,:eventAggSelected)
-		}
-	end
+  # event-handlers can't be initialized in the constructor initialize, because
+  # possible children are not yet created.
+  # *initHandlers* initializes event-handlers for the job- and aggression-selection buttons.
+  # FIXME: this function should only be called once ! may be check this
+  def initHandlers
+    getChild(&quot;doAgg0&quot;).setChecked(true)
+    @job=&quot;doRest&quot;
+    @jobButtons.each {|b|
+      c=getChild(b)
+      addHandler(c,:sigClick,:eventJobSelected)
+    }
+    @aggButtons.each {|b,a|
+      c=getChild(b)
+      addHandler(c,:sigClick,:eventAggSelected)
+    }
+  end
 
-	# checks if the view has to be updated
-	def prepareDraw
-		updateJobView
-		super
-	end
+  # checks if the view has to be updated
+  def prepareDraw
+    updateJobView
+    super
+  end
 
-	
-	def eventJobSelected(e)
-		@job=e.getCaller.getName
-		sigJobChanged(e)
-		return true
-	end
+  
+  def eventJobSelected(e)
+    @job=e.getCaller.getName
+    sigJobChanged(e)
+    return true
+  end
 
-	# another aggression was selected, so put it forward to this signal *sigAggressionChanged*
-	def eventAggSelected(e)
-		@agg=@aggButtons[e.getCaller.getName]
-		sigAggressionChanged(e)
-		return true
-	end
-	
-	# force setting an aggresion 
-	# FIXME: which aggressions are ok ??? Check this in here!
-	def setAggression(l)
-		l=l.to_i
-		@aggButtons.each{|n,b|
-			getChild(n).setChecked((b==l))
-		}
-		@agg=l
-	end
+  # another aggression was selected, so put it forward to this signal *sigAggressionChanged*
+  def eventAggSelected(e)
+    @agg=@aggButtons[e.getCaller.getName]
+    sigAggressionChanged(e)
+    return true
+  end
+  
+  # force setting an aggresion 
+  # FIXME: which aggressions are ok ??? Check this in here!
+  def setAggression(l)
+    l=l.to_i
+    @aggButtons.each{|n,b|
+      getChild(n).setChecked((b==l))
+    }
+    @agg=l
+  end
 
-	# get the current aggression
-	def getAggression
-		@agg
-	end
-	def setPointing
-		@job=&quot;doPoint&quot;
-		getChild(&quot;doFight&quot;).setChecked(true)
-	end
+  # get the current aggression
+  def getAggression
+    @agg
+  end
+  def setPointing
+    @job=&quot;doPoint&quot;
+    getChild(&quot;doFight&quot;).setChecked(true)
+  end
 private
-	def updateJobView
-		return if @hero.nil?
-		if @hero.getJob
-			i=@hero.getJob.image
-		else
-			i=&quot;data/gui/bed.png&quot;
-		end
-		if @job!=i
-			@job=i
-			getChild(&quot;jobView&quot;).setTexture(getTextureCache.get(i))
-		end
-	end
+  def updateJobView
+    return if @hero.nil?
+    if @hero.getJob
+      i=@hero.getJob.image
+    else
+      i=&quot;data/gui/bed.png&quot;
+    end
+    if @job!=i
+      @job=i
+      getChild(&quot;jobView&quot;).setTexture(getTextureCache.get(i))
+    end
+  end
 
-	# set another name for the hero-name-display
-	def setName(n)
-		if getChild(&quot;heroName&quot;)
-			getChild(&quot;heroName&quot;).setText(_(n))
-		end
-	end
+  # set another name for the hero-name-display
+  def setName(n)
+    if getChild(&quot;heroName&quot;)
+      getChild(&quot;heroName&quot;).setText(_(n))
+    end
+  end
 
 end
 
 # factory for buttonpanel-widget
 class AntButtonPanelCreator&lt;AGLayoutCreator
-	def create(p,r,n)
-		setResult AntButtonPanel.new(p,r)
-	end
+  def create(p,r,n)
+    setResult AntButtonPanel.new(p,r)
+  end
 end
 getLayoutFactory.addCreator(&quot;antButtonPanel&quot;,AntButtonPanelCreator.new)

Modified: antargis/trunk/ruby/widgets/ant_name_display.rb
===================================================================
--- antargis/trunk/ruby/widgets/ant_name_display.rb	2008-05-31 13:24:27 UTC (rev 1262)
+++ antargis/trunk/ruby/widgets/ant_name_display.rb	2008-06-05 19:24:45 UTC (rev 1263)
@@ -5,52 +5,52 @@
 # Enemy heroes' names are displayed in red - your own heroes are display in yellow.
 # the position on the screen must be given from outside (from the application e.g.)
 class AntNameDisplay&lt;AGWidget
-	@@fontChangeCount=0
+  @@fontChangeCount=0
 
-	# p - the parent widget
-	# r - the surrounding rectangle
-	# hero - the inspected hero
-	# map - the containing map-object
-	def initialize(p,r,hero,map)
-		super(p,r)
-		@map=map
-		@hero=hero
-		@font=getTheme.getFont(&quot;heroName.font&quot;)
-		@oldfont=@font
-		@name=@hero.getName
-		addChild(@mb=AGButton.new(self,AGRect.new(0,0,width,height),_(&quot;&quot;)))
-		
-		# disable button - so it can't be clicked anymore (no hovering either)
-		@mb.setEnabled(false)
-		addChild(@textWidget=AGText.new(self,AGRect.new(0,0,width,height),AGStringUtf8.new(@hero.getName)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at font</A>))
-		
-		# assign font-types
-		@fonts={true=&gt;getTheme.getFont(&quot;heroName.font&quot;),false=&gt;getTheme.getFont(&quot;enemyHero.font&quot;)}
-		
-		# enable caching of widget texture - this improves drawing performance (slightly)
-		setCaching(true)
-	end
+  # p - the parent widget
+  # r - the surrounding rectangle
+  # hero - the inspected hero
+  # map - the containing map-object
+  def initialize(p,r,hero,map)
+    super(p,r)
+    @map=map
+    @hero=hero
+    @font=getTheme.getFont(&quot;heroName.font&quot;)
+    @oldfont=@font
+    @name=@hero.getName
+    addChild(@mb=AGButton.new(self,AGRect.new(0,0,width,height),_(&quot;&quot;)))
+    
+    # disable button - so it can't be clicked anymore (no hovering either)
+    @mb.setEnabled(false)
+    addChild(@textWidget=AGText.new(self,AGRect.new(0,0,width,height),AGStringUtf8.new(@hero.getName)<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">, at font</A>))
+    
+    # assign font-types
+    @fonts={true=&gt;getTheme.getFont(&quot;heroName.font&quot;),false=&gt;getTheme.getFont(&quot;enemyHero.font&quot;)}
+    
+    # enable caching of widget texture - this improves drawing performance (slightly)
+    setCaching(true)
+  end
 
-	# enforce integer position	
-	# 
-	def setRect(r)
-		super(AGRect.new(r.x.to_i,r.y.to_i,r.w.to_i,r.h.to_i))
-	end
-	
-	def getText
-		@name
-	end
+  # enforce integer position  
+  # 
+  def setRect(r)
+    super(AGRect.new(r.x.to_i,r.y.to_i,r.w.to_i,r.h.to_i))
+  end
+  
+  def getText
+    @name
+  end
 
-	def prepareDraw
-		# check if @hero's player changed
-		@font=@fonts[@hero.getPlayer==@map.getPlayer]
-		if @font!=@oldfont
-			# this is the case - so assign new font to textWidget
-			@oldfont=@font
-			@textWidget.setFont(@font)
-			# query redraw of (possibly) cached widget texture
-			queryRedraw
-		end
-		super
-	end
+  def prepareDraw
+    # check if @hero's player changed
+    @font=@fonts[@hero.getPlayer==@map.getPlayer]
+    if @font!=@oldfont
+      # this is the case - so assign new font to textWidget
+      @oldfont=@font
+      @textWidget.setFont(@font)
+      # query redraw of (possibly) cached widget texture
+      queryRedraw
+    end
+    super
+  end
 end


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000220.html">[Antargis-svn] r1264 - in antargis/trunk: ext/basic main ruby	ruby/spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#219">[ date ]</a>
              <a href="thread.html#219">[ thread ]</a>
              <a href="subject.html#219">[ subject ]</a>
              <a href="author.html#219">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/antargis-svn">More information about the Antargis-svn
mailing list</a><br>
</body></html>
