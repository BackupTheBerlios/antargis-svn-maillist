<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Antargis-svn] r1146 - antargis/branches/rant/ext/basic
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/antargis-svn/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1146%20-%20antargis/branches/rant/ext/basic&In-Reply-To=%3C200707210744.l6L7iekL015563%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000102.html">
   <LINK REL="Next"  HREF="000104.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Antargis-svn] r1146 - antargis/branches/rant/ext/basic</H1>
    <B>davidkamphausen at BerliOS</B> 
    <A HREF="mailto:antargis-svn%40lists.berlios.de?Subject=Re%3A%20%5BAntargis-svn%5D%20r1146%20-%20antargis/branches/rant/ext/basic&In-Reply-To=%3C200707210744.l6L7iekL015563%40sheep.berlios.de%3E"
       TITLE="[Antargis-svn] r1146 - antargis/branches/rant/ext/basic">davidkamphausen at mail.berlios.de
       </A><BR>
    <I>Sat Jul 21 09:44:40 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000102.html">[Antargis-svn] r1145 - in contrib: . binary oldsources
</A></li>
        <LI>Next message: <A HREF="000104.html">[Antargis-svn] r1147 - in antargis/branches/rant: . build/configs	ext/3dengine ext/basic ext/external ext/game ext/gui ext/math	ext/sound ext/video
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#103">[ date ]</a>
              <a href="thread.html#103">[ thread ]</a>
              <a href="subject.html#103">[ subject ]</a>
              <a href="author.html#103">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: davidkamphausen
Date: 2007-07-21 09:44:39 +0200 (Sat, 21 Jul 2007)
New Revision: 1146

Added:
   antargis/branches/rant/ext/basic/ag_geometry.cc
   antargis/branches/rant/ext/basic/ag_geometry.h
   antargis/branches/rant/ext/basic/ag_video_base.cc
Log:
*added missing files

Added: antargis/branches/rant/ext/basic/ag_geometry.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_geometry.cc	2007-07-16 18:48:58 UTC (rev 1145)
+++ antargis/branches/rant/ext/basic/ag_geometry.cc	2007-07-21 07:44:39 UTC (rev 1146)
@@ -0,0 +1,2591 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_triangle.cc
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include &lt;ag_geometry.h&gt;
+#include &lt;ag_tools.h&gt;
+#include &lt;ag_debug.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;cmath&gt;
+#include &lt;map&gt;
+#include &lt;list&gt;
+#include &lt;ag_tools.h&gt;
+#include &lt;ag_xml.h&gt;
+#include &lt;ag_debug.h&gt;
+#include &lt;ag_stringstream.h&gt;
+#include &lt;ag_gauss.h&gt;
+
+#include &lt;ruby.h&gt;
+
+#define MAXF 100000.0f
+
+AGVector2 invalidVec2;
+
+bool collide1d(float a1,float a2,float b1,float b2, bool normal=true)
+{
+  float amin=std::min(a1,a2);
+  float amax=std::max(a1,a2);
+  float bmin=std::min(b1,b2);
+  float bmax=std::max(b1,b2);
+
+  if(normal &amp;&amp; (amax==bmin || bmax==amin))
+    return false;
+
+  return (amin&gt;=bmin &amp;&amp; amin&lt;=bmax) || (amax&gt;=bmin &amp;&amp; amax&lt;=bmax) || (bmin&gt;=amin &amp;&amp; bmin&lt;=amax) || (bmax&gt;=amin &amp;&amp; bmax&lt;=amin);
+}
+
+struct AGSweepResult
+{
+  enum CollisionState { COL_AT, COL_ALWAYS, COL_NEVER };
+  CollisionState state;
+  float t0;
+  float t1;
+
+  AGSweepResult()
+  {
+    state=COL_ALWAYS;
+  }
+
+  void combine(const AGSweepResult &amp;r)
+  {
+    if(state==COL_AT)
+      {
+	if(r.state==COL_NEVER)
+	  state=COL_NEVER;
+	else if(r.state!=COL_ALWAYS) // ALWAYS has no effect
+	  {
+	    t0=std::max(t0,r.t0);
+	    t1=std::min(t1,r.t1);
+	  }
+      }
+    else if(state==COL_ALWAYS)
+      {
+	if(r.state==COL_NEVER)
+	  state=COL_NEVER;
+	else if(r.state!=COL_ALWAYS) // ALWAYS has no effect
+	  {
+	    state=COL_AT;
+	    t0=r.t0;
+	    t1=r.t1;
+	  }
+	
+      }
+    // COL_NEVER cannot be changed
+  }
+
+  bool collision(float delta) const
+  {
+    return state==COL_ALWAYS || (state==COL_AT &amp;&amp; t1&gt;0 &amp;&amp; t0&lt;delta);
+  }
+
+  float begin(float delta) const
+  {
+    if(state==COL_ALWAYS || state==COL_NEVER)
+      return MAXF;
+
+    if(t0&gt;=0.0f &amp;&amp; t0&lt;delta)
+      return t0;
+    else
+      return MAXF;
+  }
+
+  bool always() const
+  {
+    return state == COL_ALWAYS;
+  }
+};
+
+AGSweepResult collide1d(float pa1,float pa2,float pb1,float pb2,float v)
+{
+  float a1=std::min(pa1,pa2);
+  float a2=std::max(pa1,pa2);
+  float b1=std::min(pb1,pb2);
+  float b2=std::max(pb1,pb2);
+  AGSweepResult r;
+
+  if(v&gt;0)
+    {
+      r.t0=(b1-a2)/v;
+      r.t1=(b2-a1)/v;
+      r.state = AGSweepResult::COL_AT;
+
+      assert(r.t0 &lt;= r.t1);
+    }
+  else if(v&lt;0)
+    {
+      r.t0=(b2-a1)/v;
+      r.t1=(b1-a2)/v;
+      r.state = AGSweepResult::COL_AT;
+
+      assert(r.t0 &lt;= r.t1);
+    }
+  else
+    {
+      if (a2 &lt; b1 || a1 &gt; b2)
+        r.state = AGSweepResult::COL_NEVER;
+      else
+        r.state = AGSweepResult::COL_ALWAYS;
+    }
+  return r;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// AGAngle
+/////////////////////////////////////////////////////////////////////////////
+
+AGAngle::AGAngle(float p):angle(p)
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// AGVector2
+/////////////////////////////////////////////////////////////////////////////
+
+AGVector2::AGVector2(const AGString &amp;s)
+{
+  assert(s.length()&gt;=5);
+  assert(s[0]=='(');
+  assert(s[s.length()-1]==')');
+  AGString p=s.substr(1,s.length()-2);
+  size_t i=p.find(&quot;,&quot;);
+  assert(i!=p.npos);
+  v[0]=p.substr(0,i).toFloat();
+  v[1]=p.substr(i+1,p.length()-i-1).toFloat();
+}
+
+
+AGVector2::AGVector2(float pX,float pY)
+{
+  v[0]=pX;
+  v[1]=pY;
+}
+AGVector2::AGVector2(const AGVector2 &amp;a)
+{
+  v[0]=a.v[0];
+  v[1]=a.v[1];
+}
+AGVector2::AGVector2(const AGAngle &amp;a)
+{
+  v[0]=sin(a.angle);
+  v[1]=-cos(a.angle);
+}
+
+AGVector2::AGVector2()
+{
+  v[0]=v[1]=0;
+}
+
+void AGVector2::saveXML(Node &amp;node) const
+{
+  node.set(&quot;x&quot;,AGString(v[0]));
+  node.set(&quot;y&quot;,AGString(v[1]));
+}
+void AGVector2::loadXML(const Node &amp;node)
+{
+  v[0]=node.get(&quot;x&quot;).toFloat();
+  v[1]=node.get(&quot;y&quot;).toFloat();
+}
+
+AGVector2 AGVector2::operator-() const
+{
+  return AGVector2(-v[0],-v[1]);
+}
+
+
+float getArcInternal(float x,float y)
+{
+  if(y==0.0)
+    {
+      if(x&lt;0.0)
+	return -M_PI/2.0;
+      else
+	return M_PI/2.0;
+    }
+  else if(y&lt;0.0)
+    {
+      float a=M_PI+atan(x/y);
+      if(a&gt;M_PI)
+	a-=M_PI*2.0;
+      return a;
+    }
+  else
+    return atan(x/y);
+}
+
+
+AGAngle AGVector2::getAngle() const
+{
+  return AGAngle(getArcInternal(v[0],v[1]));
+}
+
+
+bool AGVector2::operator==(const AGVector2 &amp;a) const
+{
+  return v[0]==a.v[0] &amp;&amp; v[1]==a.v[1] &amp;&amp; v[2]==a.v[2];
+}
+bool AGVector2::operator!=(const AGVector2 &amp;a) const
+{
+  return !operator==(a);
+}
+
+AGString AGVector2::toString() const
+{
+  std::ostringstream os;
+  os&lt;&lt;&quot;(&quot;&lt;&lt;v[0]&lt;&lt;&quot;,&quot;&lt;&lt;v[1]&lt;&lt;&quot;)&quot;;
+  return AGString(os.str());
+}
+
+float AGVector2::length2() const
+{
+  return v[0]*v[0]+v[1]*v[1];
+}
+
+AGVector2 AGVector2::dim2() const
+{
+  return *this;
+}
+
+
+bool AGVector2::nonZero() const
+{
+  return length2()!=0.0f;
+}
+
+AGVector2 AGVector2::normal() const
+{
+  return AGVector2(-v[1],v[0]);
+}
+
+void AGVector2::setX(float pX)
+{
+  v[0]=pX;
+}
+void AGVector2::setY(float pY)
+{
+  v[1]=pY;
+}
+
+float AGVector2::getX() const
+{
+  return v[0];
+}
+float AGVector2::getY() const
+{
+  return v[1];
+}
+
+(AGVector2::operator float*)()
+{
+  return v;
+}
+(AGVector2::operator const float*)() const
+{
+  return v;
+}
+
+AGVector2 AGVector2::operator-(const AGVector2 &amp;p) const
+{
+  return AGVector2(v[0]-p.v[0],v[1]-p.v[1]);
+}
+AGVector2 AGVector2::operator+(const AGVector2 &amp;p) const
+{
+  return AGVector2(v[0]+p.v[0],v[1]+p.v[1]);
+}
+AGVector2 &amp;AGVector2::operator+=(const AGVector2 &amp;p)
+{
+  v[0]+=p.v[0];
+  v[1]+=p.v[1];
+  return *this;
+}
+AGVector2 &amp;AGVector2::operator-=(const AGVector2 &amp;p)
+{
+  v[0]-=p.v[0];
+  v[1]-=p.v[1];
+  return *this;
+}
+
+float AGVector2::operator*(const AGVector2 &amp;p) const
+{
+  return v[0]*p.v[0]+v[1]*p.v[1];
+}
+AGVector2 &amp;AGVector2::operator*=(float f)
+{
+  v[0]*=f;
+  v[1]*=f;
+  return *this;
+}
+AGVector2 &amp;AGVector2::operator/=(float f)
+{
+  v[0]/=f;
+  v[1]/=f;
+  return *this;
+}
+AGVector2 AGVector2::operator*(float f) const
+{
+  return AGVector2(v[0]*f,v[1]*f);
+}
+AGVector2 AGVector2::operator/(float f) const
+{
+  f=1.0/f;
+  return AGVector2(v[0]*f,v[1]*f);
+}
+
+float AGVector2::length() const
+{
+  return sqrt(v[0]*v[0]+v[1]*v[1]);
+}
+
+AGVector2 AGVector2::normalized() const
+{
+  if(length2()!=0.0f)
+    return *this/length();
+  else
+    return *this;
+}
+void AGVector2::normalize()
+{
+  if(length2()!=0.0f)
+    operator/=(length());
+}
+
+float AGVector2::operator[](int index) const
+{
+  assert(index&gt;=0 &amp;&amp; index&lt;2);
+  return v[index];
+}
+float &amp;AGVector2::operator[](int index)
+{
+  assert(index&gt;=0 &amp;&amp; index&lt;2);
+  return v[index];
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// AGVector3
+/////////////////////////////////////////////////////////////////////////////
+
+AGVector3::AGVector3(const AGVector2 &amp;p,float h)
+{
+  v[0]=p[0];
+  v[1]=p[1];
+  v[2]=h;
+}
+
+AGVector3::AGVector3(float pX,float pY,float pZ)
+{
+  v[0]=pX;
+  v[1]=pY;
+  v[2]=pZ;
+}
+AGVector3::AGVector3(const AGVector3 &amp;a)
+{
+  v[0]=a.v[0];
+  v[1]=a.v[1];
+  v[2]=a.v[2];
+}
+AGVector3::AGVector3(const AGAngle &amp;a)
+{
+  v[0]=sin(a.angle);
+  v[1]=-cos(a.angle);
+  v[2]=0.0f;
+}
+
+AGVector3::AGVector3()
+{
+  v[0]=v[1]=0;
+  v[2]=0.0f;
+}
+
+AGVector2 AGVector3::dim2() const
+{
+  return AGVector2(v[0],v[1]);
+}
+
+
+AGVector3 AGVector3::operator-() const
+{
+  return AGVector3(-v[0],-v[1],-v[2]);
+}
+
+
+void AGVector3::saveXML(Node &amp;node) const
+{
+  node.set(&quot;x&quot;,AGString(v[0]));
+  node.set(&quot;y&quot;,AGString(v[1]));
+  node.set(&quot;z&quot;,AGString(v[2]));
+}
+void AGVector3::loadXML(const Node &amp;node)
+{
+  v[0]=node.get(&quot;x&quot;).toFloat();
+  v[1]=node.get(&quot;y&quot;).toFloat();
+  v[2]=node.get(&quot;z&quot;).toFloat();
+}
+
+
+
+
+/*
+float getArcInternal(float x,float y)
+{
+  if(y==0.0)
+    {
+      if(x&lt;0.0)
+	return -M_PI/2.0;
+      else
+	return M_PI/2.0;
+    }
+  else if(y&lt;0.0)
+    {
+      float a=M_PI+atan(x/y);
+      if(a&gt;M_PI)
+	a-=M_PI*2.0;
+      return a;
+    }
+  else
+    return atan(x/y);
+}
+*/
+
+AGAngle AGVector3::getAngle() const
+{
+  return AGAngle(getArcInternal(v[0],v[1]));
+}
+
+
+bool AGVector3::operator==(const AGVector3 &amp;a) const
+{
+  float m=std::max(v[0],std::max(v[1],v[2]));
+  
+  m*=0.0001;
+  return fabs(v[0]-a.v[0])&lt;m &amp;&amp; fabs(v[1]-a.v[1])&lt;m &amp;&amp; fabs(v[2]-a.v[2])&lt;m;
+}
+bool AGVector3::operator!=(const AGVector3 &amp;a) const
+{
+  return !operator==(a);
+}
+
+AGString AGVector3::toString() const
+{
+  std::ostringstream os;
+  os&lt;&lt;&quot;(&quot;&lt;&lt;v[0]&lt;&lt;&quot;,&quot;&lt;&lt;v[1]&lt;&lt;&quot;,&quot;&lt;&lt;v[2]&lt;&lt;&quot;)&quot;;
+  return AGString(os.str());
+}
+
+float AGVector3::length2() const
+{
+  return v[0]*v[0]+v[1]*v[1]+v[2]*v[2];
+}
+
+
+bool AGVector3::nonZero() const
+{
+  return length2()!=0.0f;
+}
+
+AGVector3 AGVector3::normal() const
+{
+  return AGVector3(-v[1],v[0],v[2]);
+}
+
+void AGVector3::setX(float pX)
+{
+  v[0]=pX;
+}
+void AGVector3::setY(float pY)
+{
+  v[1]=pY;
+}
+void AGVector3::setZ(float pZ)
+{
+  v[2]=pZ;
+}
+
+float AGVector3::getX() const
+{
+  return v[0];
+}
+float AGVector3::getY() const
+{
+  return v[1];
+}
+
+float AGVector3::getZ() const
+{
+  return v[2];
+}
+
+(AGVector3::operator float*)()
+{
+  return v;
+}
+AGVector3 AGVector3::operator%(const AGVector3 &amp;a) const
+{
+  return AGVector3(v[1] * a.v[2] - v[2] * a.v[1],
+		   v[2] * a.v[0] - v[0] * a.v[2],
+		   v[0] * a.v[1] - v[1] * a.v[0]);
+}
+
+
+AGVector3 AGVector3::operator-(const AGVector3 &amp;p) const
+{
+  return AGVector3(v[0]-p.v[0],v[1]-p.v[1],v[2]-p.v[2]);
+}
+AGVector3 AGVector3::operator+(const AGVector3 &amp;p) const
+{
+  return AGVector3(v[0]+p.v[0],v[1]+p.v[1],v[2]+p.v[2]);
+}
+AGVector3 &amp;AGVector3::operator+=(const AGVector3 &amp;p)
+{
+  v[0]+=p.v[0];
+  v[1]+=p.v[1];
+  v[2]+=p.v[2];
+  return *this;
+}
+AGVector3 &amp;AGVector3::operator-=(const AGVector3 &amp;p)
+{
+  v[0]+=p.v[0];
+  v[1]+=p.v[1];
+  v[2]+=p.v[2];
+  return *this;
+}
+
+AGVector3 &amp;AGVector3::operator*=(float f)
+{
+  v[0]*=f;
+  v[1]*=f;
+  v[2]*=f;
+  return *this;
+}
+AGVector3 &amp;AGVector3::operator/=(float f)
+{
+  v[0]/=f;
+  v[1]/=f;
+  v[2]/=f;
+  return *this;
+}
+AGVector3 AGVector3::operator*(float f) const
+{
+  return AGVector3(v[0]*f,v[1]*f,v[2]*f);
+}
+AGVector3 AGVector3::operator/(float f) const
+{
+  f=1.0/f;
+  return AGVector3(v[0]*f,v[1]*f,v[2]*f);
+}
+
+float AGVector3::length() const
+{
+  return sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
+}
+
+AGVector3 AGVector3::normalized() const
+{
+  if(length2()!=0.0f)
+    return *this/length();
+  else
+    return *this;
+}
+void AGVector3::normalize()
+{
+  if(length2()!=0.0f)
+    operator/=(length());
+}
+
+float AGVector3::operator[](int index) const
+{
+  assert(index&gt;=0 &amp;&amp; index&lt;3);
+  return v[index];
+}
+float &amp;AGVector3::operator[](int index)
+{
+  assert(index&gt;=0 &amp;&amp; index&lt;3);
+  return v[index];
+}
+
+
+////////////////////////////////////////////////////////////////////////////
+// AGMatrix
+/////////////////////////////////////////////////////////////////////////////
+
+AGMatrix3::AGMatrix3()
+{
+  a[0][1]=a[0][2]=
+    a[1][0]=a[1][2]=
+    a[2][0]=a[2][1]=0.0f;
+
+  a[0][0]=a[1][1]=a[2][2]=1.0f;
+}
+
+AGMatrix3::AGMatrix3(const AGAngle &amp;n)
+{
+  a[0][0]=cos(n.angle);
+  a[1][0]=sin(n.angle);
+  a[0][1]=-sin(n.angle);
+  a[1][1]=cos(n.angle);
+  a[2][0]=a[2][1]=a[0][2]=a[1][2]=0.0f;
+  a[2][2]=1.0f;
+}
+
+AGMatrix3::AGMatrix3(const AGVector3 &amp;n)
+{
+  a[0][0]=a[1][1]=a[2][2]=1.0f;
+  a[0][1]=a[0][2]=
+    a[1][0]=a[1][2]=
+    a[2][0]=a[2][1]=0.0f;
+  a[2][0]=n[0];
+  a[2][1]=n[1];
+}
+
+AGMatrix3::AGMatrix3(float x,float y)
+{
+  a[0][0]=x;
+  a[1][1]=y;
+  a[2][2]=1.0f;
+  a[0][1]=a[0][2]=
+    a[1][0]=a[1][2]=
+    a[2][0]=a[2][1]=0.0f;
+  a[2][0]=0.0f;
+  a[2][1]=0.0f;
+  
+}
+
+AGMatrix3 AGMatrix3::transposed() const
+{
+  AGMatrix3 a;
+  for(size_t x=0;x&lt;3;x++)
+    for(size_t y=0;y&lt;3;y++)
+      a.set(x,y,get(y,x));
+  return a;
+}
+
+
+AGMatrix3 AGMatrix3::inverted() const
+{
+  // gauss-alg.
+  AGMatrix3 a;
+  AGMatrix3 b(*this);
+
+  gauss(a,b,3);
+  return a;
+}
+
+void AGMatrix3::swapRows(size_t a,size_t b)
+{
+  if(a==b)
+    return;
+  assert(a&lt;3);
+  assert(b&lt;3);
+  for(size_t x=0;x&lt;3;x++)
+    {
+      float t=get(x,a);
+      set(x,a,get(x,b));
+      set(x,b,t);
+    }
+}
+
+void AGMatrix3::swapCols(size_t a,size_t b)
+{
+  if(a==b)
+    return;
+  assert(a&lt;3);
+  assert(b&lt;3);
+  for(size_t y=0;y&lt;3;y++)
+    {
+      float t=get(a,y);
+      set(a,y,get(b,y));
+      set(b,y,t);
+    }
+}
+
+
+void AGMatrix3::set(size_t x,size_t y,float f)
+{
+  assert(x&gt;=0 &amp;&amp; x&lt;3);
+  assert(y&gt;=0 &amp;&amp; y&lt;3);
+  a[x][y]=f;
+}
+float AGMatrix3::get(size_t x,size_t y) const
+{
+  assert(x&gt;=0 &amp;&amp; x&lt;3);
+  assert(y&gt;=0 &amp;&amp; y&lt;3);
+  return a[x][y];
+}
+
+float &amp;AGMatrix3::get(size_t x,size_t y)
+{
+  assert(x&gt;=0 &amp;&amp; x&lt;3);
+  assert(y&gt;=0 &amp;&amp; y&lt;3);
+  return a[x][y];
+}
+
+AGMatrix3::Row AGMatrix3::operator[](size_t y)
+{
+  Row r;
+  r.matrix=this;
+  r.y=y;
+  return r;
+}
+const AGMatrix3::Row AGMatrix3::operator[](size_t y) const
+{
+  Row r;
+  r.matrix=const_cast&lt;AGMatrix3*&gt;(this);
+  r.y=y;
+  return r;
+}
+
+AGMatrix3 AGMatrix3::operator-() const
+{
+  AGMatrix3 n;
+  for(size_t x=0;x&lt;3;x++)
+    for(size_t y=0;y&lt;3;y++)
+      n[x][y]=-(*this)[x][y];
+  return n;
+}
+
+
+
+AGMatrix3 AGMatrix3::operator*(const AGMatrix3 &amp;m) const
+{
+  AGMatrix3 n;
+  size_t x,y;
+  for(x=0;x&lt;3;x++)
+    for(y=0;y&lt;3;y++)
+      n.a[x][y]=a[0][y]*m.a[x][0]+
+	a[1][y]*m.a[x][1]+
+	a[2][y]*m.a[x][2];
+  return n;
+}
+AGMatrix3 &amp;AGMatrix3::operator*=(const AGMatrix3 &amp;m)
+{
+  *this=(*this)*m;
+  return *this;
+}
+
+AGVector3 AGMatrix3::operator*(const AGVector3 &amp;v) const
+{
+  return AGVector3(a[0][0]*v[0]+a[1][0]*v[1]+a[2][0]*v[2],
+		   a[0][1]*v[0]+a[1][1]*v[1]+a[2][1]*v[2],
+		   a[0][2]*v[0]+a[1][2]*v[1]+a[2][2]*v[2]);
+}
+
+AGString AGMatrix3::toString() const
+{
+  std::ostringstream os;
+  os&lt;&lt;&quot;(&quot;&lt;&lt;a[0][0]&lt;&lt;&quot;,&quot;&lt;&lt;a[1][0]&lt;&lt;&quot;,&quot;&lt;&lt;a[2][0]&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;
+  os&lt;&lt;&quot;(&quot;&lt;&lt;a[0][1]&lt;&lt;&quot;,&quot;&lt;&lt;a[1][1]&lt;&lt;&quot;,&quot;&lt;&lt;a[2][1]&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;
+  os&lt;&lt;&quot;(&quot;&lt;&lt;a[0][2]&lt;&lt;&quot;,&quot;&lt;&lt;a[1][2]&lt;&lt;&quot;,&quot;&lt;&lt;a[2][2]&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;
+  return AGString(os.str());
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// AGTriangle2
+/////////////////////////////////////////////////////////////////////////////
+
+AGTriangle2::AGTriangle2(const AGVector2 &amp;v0,const AGVector2 &amp;v1,const AGVector2 &amp;v2)
+{
+  p[0]=v0;
+  p[1]=v1;
+  p[2]=v2;
+}
+
+AGRect2 AGTriangle2::getBBox() const
+{
+  float minx=std::min(p[0].getX(),std::min(p[1].getX(),p[2].getX()));
+  float maxx=std::max(p[0].getX(),std::max(p[1].getX(),p[2].getX()));
+  float miny=std::min(p[0].getY(),std::min(p[1].getY(),p[2].getY()));
+  float maxy=std::max(p[0].getY(),std::max(p[1].getY(),p[2].getY()));
+
+  return AGRect2(minx,miny,maxx-minx,maxy-miny);
+}
+
+
+void AGTriangle2::apply(const AGMatrix3 &amp;m)
+{
+  p[0]=(m*AGVector3(p[0],1)).dim2();
+  p[1]=(m*AGVector3(p[1],1)).dim2();
+  p[2]=(m*AGVector3(p[2],1)).dim2();
+}
+
+/* FIXME: this will be some sweep-base collision detection,
+   HOWEVER there's the angular-velocity still missing :-(
+
+AGCollisionData AGTriangle2::collide(const AGTriangle2 &amp;t,const AGVector &amp;v0,const AGVector &amp;v1) const
+{
+  AGCollisionData data;
+
+  AGVector v=v1-v0;
+
+  float t0,t1;
+
+  std::vector&lt;AGVector&gt; v=getNormals();
+  append(v,t.getNormals());
+  std::vector&lt;AGVector&gt;::iterator i=v.begin();
+  for(;i!=v.end();i++)
+    {
+      float min1,min2,max1,max2;
+      size_t j;
+      for(j=0;j&lt;3;j++)
+	{
+	  if(j==0)
+	    {
+	      min1=max1=(*i)*p[j];
+	      min2=max2=(*i)*t.p[j];
+	    }
+	  else
+	    {
+	      float v0=(*i)*p[j];
+	      float v1=(*i)*t.p[j];
+	      min1=std::min(min1,v0);
+	      max1=std::max(max1,v0);
+	      min2=std::min(min2,v1);
+	      max2=std::max(max2,v1);
+	    }
+	}
+      
+      float a1=
+    }
+}
+*/
+
+std::vector&lt;AGVector2&gt; AGTriangle2::collisionPoints(const AGLine2 &amp;l) const
+{
+  std::vector&lt;AGVector2&gt; ps;
+  std::vector&lt;AGLine2&gt; lines=getLines();
+  std::vector&lt;AGLine2&gt;::iterator i=lines.begin();
+  AGVector2 p;
+  //  cdebug(toString());
+  for(;i!=lines.end();i++)
+    {
+      p=i-&gt;collisionPoint(l);
+      if(p!=invalidVec2)
+	ps.push_back(p);
+    }
+  return ps;
+}
+
+AGTriangle2 AGTriangle2::applied(const AGMatrix3 &amp;m) const
+{
+  return AGTriangle2((m*AGVector3(p[0],1)).dim2(),
+		     (m*AGVector3(p[1],1)).dim2(),
+		     (m*AGVector3(p[2],1)).dim2());
+}
+
+AGString AGTriangle2::toString() const
+{
+  std::ostringstream os;
+  os&lt;&lt;&quot;[&quot;&lt;&lt;p[0].toString()&lt;&lt;&quot; &quot;&lt;&lt;p[1].toString()&lt;&lt;&quot; &quot;&lt;&lt;p[2].toString()&lt;&lt;&quot;]&quot;;
+  return AGString(os.str());
+}
+
+AGVector2 AGTriangle2::get(int index) const
+{
+  return p[index];
+}
+
+
+AGVector2 AGTriangle2::operator[](int index) const
+{
+  return p[index];
+}
+
+bool AGTriangle2::collide(const AGTriangle2 &amp;t) const
+{
+  std::vector&lt;AGVector2&gt; v=getNormals();
+  append(v,t.getNormals());
+  std::vector&lt;AGVector2&gt;::iterator i=v.begin();
+
+  for(;i!=v.end();i++)
+    {
+      float min1,min2,max1,max2;
+      size_t j;
+      for(j=0;j&lt;3;j++)
+	{
+	  if(j==0)
+	    {
+	      min1=max1=(*i)*p[j];
+	      min2=max2=(*i)*t.p[j];
+	    }
+	  else
+	    {
+	      float v0=(*i)*p[j];
+	      float v1=(*i)*t.p[j];
+	      min1=std::min(min1,v0);
+	      max1=std::max(max1,v0);
+	      min2=std::min(min2,v1);
+	      max2=std::max(max2,v1);
+	    }
+	}
+      if(!collide1d(min1,max1,min2,max2))
+	return false;
+    }
+  return true;
+}
+
+std::vector&lt;AGVector2&gt; AGTriangle2::getNormals() const
+{
+  std::vector&lt;AGVector2&gt; l;
+  l.push_back((p[1]-p[0]).normalized().normal());
+  l.push_back((p[2]-p[1]).normalized().normal());
+  l.push_back((p[0]-p[2]).normalized().normal());
+  return l;
+}
+
+std::vector&lt;AGLine2&gt; AGTriangle2::getLines() const
+{
+  std::vector&lt;AGLine2&gt; v;
+  v.push_back(AGLine2(p[0],p[1]));
+  v.push_back(AGLine2(p[1],p[2]));
+  v.push_back(AGLine2(p[2],p[0]));
+  return v;
+}
+
+bool AGTriangle2::contains(const AGVector2 &amp;pp) const
+{
+  std::vector&lt;AGVector2&gt; l=getNormals(); // BEWARE: dont' change the order in getNormals!!!
+
+  if(AGsign((pp-p[0])*l[0])==AGsign((p[2]-p[0])*l[0]))
+    if(AGsign((pp-p[1])*l[1])==AGsign((p[0]-p[1])*l[1]))
+      if(AGsign((pp-p[2])*l[2])==AGsign((p[1]-p[2])*l[2]))
+	return true;
+  return false;
+}
+
+
+AGVector2 AGTriangle2::touchPoint(const AGTriangle2 &amp;t) const
+{
+  // assume that one point of a triangle is contained in the other and return this point
+  size_t i;
+  for(i=0;i&lt;3;i++)
+    {
+      if(contains(t[i]))
+	return t[i];
+      else if(t.contains((*this)[i]))
+	return (*this)[i];
+    }
+  return invalidVec2;
+}
+
+AGVector2 AGTriangle2::touchVector(const AGTriangle2 &amp;t) const
+{
+  //#ifdef OLD_TOUCH_APPROXIMATION
+  // try to get line, which has two intersections with other triangle's lines
+
+  std::vector&lt;AGLine2&gt; l0=getLines();
+  std::vector&lt;AGLine2&gt; l1=t.getLines();
+
+  std::vector&lt;AGLine2&gt;::iterator i,j;
+
+  std::map&lt;AGLine2*,int&gt; sum;
+
+  for(i=l0.begin();i!=l0.end();i++)
+    for(j=l1.begin();j!=l1.end();j++)
+      {
+	if(i-&gt;collide(*j))
+	  {
+	    sum[&amp;(*i)]++;
+	    sum[&amp;(*j)]++;
+	  }
+      }
+  std::map&lt;AGLine2*,int&gt;::iterator k=sum.begin();
+  for(;k!=sum.end();k++)
+    {
+      if(k-&gt;second==2)
+	return k-&gt;first-&gt;normal();
+    }
+
+  // FIXME: not found - find other approximation
+
+  //#else
+  {
+  size_t i;
+  for(i=0;i&lt;3;i++)
+    {
+      if(contains(t[i]))
+	return nearestLine(t[i]).normal();
+      else if(t.contains((*this)[i]))
+	return t.nearestLine((*this)[i]).normal();
+    }
+  return invalidVec2;
+  }
+  //#endif
+}
+
+AGLine2 AGTriangle2::nearestLine(const AGVector2 &amp;v) const
+{
+  std::vector&lt;AGLine2&gt; l=getLines();
+  std::vector&lt;AGLine2&gt;::iterator i;
+  std::map&lt;float,AGLine2&gt; dist;
+  for(i=l.begin();i!=l.end();i++)
+    {
+      dist[i-&gt;distance(v)]=*i;
+      //      cdebug(i-&gt;distance(v)&lt;&lt;i-&gt;toString());
+    }
+  return dist.begin()-&gt;second;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// AGCircle2
+/////////////////////////////////////////////////////////////////////////////
+
+AGCircle2::AGCircle2(const AGVector3 &amp;v,float rad):p(v),radius(rad)
+{
+}
+
+bool AGCircle2::inCircle(const AGVector3 &amp;v) const
+{
+  return (v-p).length2()&lt;radius*radius;
+}
+bool AGCircle2::outCircle(const AGVector3 &amp;v) const
+{
+  return (v-p).length2()&gt;radius*radius;
+}
+
+bool AGCircle2::inCircle(const AGTriangle2 &amp;t) const
+{
+  return inCircle(t.get(0)) &amp;&amp; inCircle(t.get(1)) &amp;&amp; inCircle(t.get(2));
+}
+bool AGCircle2::outCircle(const AGTriangle2 &amp;t) const
+{
+  return outCircle(t.get(0)) &amp;&amp; outCircle(t.get(1)) &amp;&amp; outCircle(t.get(2));
+}
+
+AGVector3 AGCircle2::getPos() const
+{
+  return p;
+}
+float AGCircle2::getRadius() const
+{
+  return radius;
+}
+
+
+
+/////////////////////////////////////////////////////////////////////////////
+// AGTriangle3
+/////////////////////////////////////////////////////////////////////////////
+AGTriangle3::AGTriangle3(const AGVector3 &amp;v0,const AGVector3 &amp;v1,const AGVector3 &amp;v2)
+{
+  p[0]=v0;
+  p[1]=v1;
+  p[2]=v2;
+}
+
+AGVector4 AGTriangle3::collide(const AGLine3 &amp;pLine) const
+{
+  AGVector3 normal=(p[1]-p[0])%(p[2]-p[0]);
+  AGVector4 mfalse(0,0,0,0);
+  if(normal.length2()==0)
+    return mfalse; // bad triangle
+  normal.normalize();
+  float v0=(pLine.getV0()-p[0])*normal;
+  float v1=(pLine.getV1()-p[0])*normal;
+  float vall=v0-v1;
+  float v=v0/vall;
+
+  if(v&lt;0 || v&gt;1)
+    return mfalse; // line doesn't intersect triangle's plane
+
+  AGVector3 ip=pLine.getV1()*v+pLine.getV0()*(1-v);
+
+  assert(fabs((ip-p[0])*normal)&lt;0.00001);
+  // check if point is on triangle (already checked that point is in plane)
+  AGVector3 n0=(p[2]-p[1])%normal;
+  AGVector3 n1=(p[2]-p[0])%normal;
+  AGVector3 n2=(p[0]-p[1])%normal;
+  n0.normalize();
+  n1.normalize();
+  n2.normalize();
+
+  if(n0==n1 || n0==n2 || n1==n2)
+    return mfalse;
+
+  assert(fabs(n0*normal)&lt;0.0001);
+  assert(fabs(n1*normal)&lt;0.0001);
+  assert(fabs(n2*normal)&lt;0.0001);
+
+  assert(fabs((p[2]-p[1])*n0)&lt;0.0001);
+  assert(fabs((p[2]-p[0])*n1)&lt;0.0001);
+  assert(fabs((p[0]-p[1])*n2)&lt;0.0001);
+
+  if(AGsign((p[0]-p[1])*n0)!=AGsign((ip-p[1])*n0))
+    return mfalse;
+  if(AGsign((p[1]-p[2])*n1)!=AGsign((ip-p[2])*n1))
+    return mfalse;
+  if(AGsign((p[2]-p[1])*n2)!=AGsign((ip-p[1])*n2))
+    return mfalse;
+
+
+  return AGVector4(ip,1);
+}
+
+
+AGString AGTriangle3::toString() const
+{
+  std::ostringstream os;
+  os&lt;&lt;&quot;[&quot;&lt;&lt;p[0].toString()&lt;&lt;&quot;;&quot;&lt;&lt;p[1].toString()&lt;&lt;&quot;;&quot;&lt;&lt;p[2].toString()&lt;&lt;&quot;]&quot;;
+  return AGString(os.str());
+}
+
+AGVector3 AGTriangle3::operator[](int index) const
+{
+  assert(index&gt;=0);
+  assert(index&lt;3);
+  return p[index];
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// AGRect2F
+/////////////////////////////////////////////////////////////////////////////
+
+AGRect2::AGRect2(const SDL_Rect &amp;r)
+{
+  v0=AGVector2(r.x,r.y);
+  v1=AGVector2(r.x+r.w,r.y+r.h);
+}
+
+
+AGRect2::AGRect2(const AGString &amp;ps)
+{
+  std::istringstream is;
+  char c;
+  float x,y,w,h;
+  is.str(ps);
+  is&gt;&gt;c;
+  is&gt;&gt;x;
+  is&gt;&gt;c;
+  is&gt;&gt;y;
+  is&gt;&gt;c;
+  is&gt;&gt;w;
+  is&gt;&gt;c;
+  is&gt;&gt;h;
+  is&gt;&gt;c;
+  v0=AGVector2(x,y);
+  v1=AGVector2(x+w,y+h);
+}
+
+
+AGRect2::AGRect2()
+{
+}
+
+AGRect2::AGRect2(const AGVector2 &amp;pv0,const AGVector2 &amp;pv1):
+  v0(pv0),v1(pv1)
+{
+}
+
+AGRect2::AGRect2(float x,float y,float w,float h):
+  v0(x,y),v1(x+w,y+h)
+{
+}
+
+AGRect2 AGRect2::alignGrid() const
+{
+  return AGRect2((int)x(),
+		 (int)y(),
+		 (int)w(),
+		 (int)h());
+}
+
+
+void AGRect2::check() const
+{
+  float mx0=std::min(x0(),x1());
+  float my0=std::min(y0(),y1());
+  float mx1=std::max(x0(),x1());
+  float my1=std::max(y0(),y1());
+
+  AGRect2 *p=const_cast&lt;AGRect2*&gt;(this);
+  p-&gt;v0[0]=mx0;
+  p-&gt;v0[1]=my0;
+  p-&gt;v1[0]=mx1;
+  p-&gt;v1[1]=my1;
+}
+
+AGRect2&amp; AGRect2::operator+=(const AGRect2 &amp;r)
+{
+  if(width()==0 || height()==0)
+    *this=r;
+  else
+    {
+      include(r[0]);
+      include(r[1]);
+    }
+  return *this;
+}
+
+
+
+AGRect2 AGRect2::intersect(const AGRect2 &amp;r) const
+{
+  check();
+  r.check();
+
+  float mx0=std::max(x0(),r.x0());
+  float my0=std::max(y0(),r.y0());
+  float mx1=std::min(x1(),r.x1());
+  float my1=std::min(y1(),r.y1());
+
+  if(mx0&gt;mx1)
+    mx0=mx1;
+  if(my0&gt;my1)
+    my0=my1;
+
+  return AGRect2(AGVector2(mx0,my0),
+		 AGVector2(mx1,my1));
+}
+
+std::vector&lt;AGRect2&gt; AGRect2::difference(const AGRect2 &amp;r) const
+{
+  std::vector&lt;AGRect2&gt; l;
+  for(int i=0;i&lt;3;i++)
+    for(int j=0;j&lt;3;j++)
+      {
+	
+	float nx,ny,nw,nh;
+	
+	switch(i)
+	  {
+	  case 0:
+	    nx=x0();
+	    nw=r.x0()-x0();
+	    break;
+	  case 1:
+	    nx=r.x0();
+	    nw=r.x1()-r.x0();
+	    break;
+	  case 2:
+	    nx=r.x1();
+	    nw=x1()-r.x1();
+	    break;
+	  };
+	switch(j)
+	  {
+	  case 0:
+	    ny=y0();
+	    nh=r.y0()-y0();
+	    break;
+	  case 1:
+	    ny=r.y0();
+	    nh=r.y1()-r.y0();
+	    break;
+	  case 2:
+	    ny=r.y1();
+	    nh=y1()-r.y1();
+	    break;
+	  };
+	if(nw&gt;0 &amp;&amp; nh&gt;0)
+	  {
+	    AGRect2 n=intersect(AGRect2(nx,ny,nw,nh));
+	    if(n.w()&gt;0 &amp;&amp; n.h()&gt;0)
+	      if(!r.contains(n))
+		l.push_back(n);
+	  }
+      }
+  return l;
+}
+
+
+
+AGVector2 AGRect2::operator[](size_t i) const
+{
+  switch(i)
+    {
+    case 0:
+      return v0;
+    case 1:
+      return v1;
+    default:
+      throw AGString(&quot;invalid index in AGRect2::operator[]&quot;);
+    }
+  return v0;
+}
+AGVector2 &amp;AGRect2::operator[](size_t i)
+{
+  switch(i)
+    {
+    case 0:
+      return v0;
+    case 1:
+      return v1;
+    default:
+      throw AGString(&quot;invalid index in AGRect2::operator[]&quot;);
+    }
+  return v0;
+}
+
+AGRect2 AGRect2::shrink(float f) const
+{
+  AGVector2 d(f,f);
+  return AGRect2(v0+d,v1-d);
+}
+
+AGRect2 AGRect2::grow(float f) const
+{
+  AGVector2 d(f,f);
+  return AGRect2(v0-d,v1+d);
+}
+
+
+bool AGRect2::operator==(const AGRect2 &amp;r) const
+{
+  return v0==r.v0 &amp;&amp; v1==r.v1;
+}
+bool AGRect2::operator!=(const AGRect2 &amp;r) const
+{
+  return v0!=r.v0 || v1!=r.v1;
+}
+
+
+
+SDL_Rect AGRect2::sdl() const
+{
+  SDL_Rect r;
+  r.x=int(v0[0]);
+  r.y=int(v0[1]);
+  r.w=int(v1[0]-v0[0]+0.1); // prevent shitty rounding error !
+  r.h=int(v1[1]-v0[1]+0.1);
+
+  return r;
+}
+
+float AGRect2::setWidth(float w)
+{
+  v1[0]=v0[0]+w;
+  return w;
+}
+float AGRect2::setHeight(float h)
+{
+  v1[1]=v0[1]+h;
+  return h;
+}
+
+float AGRect2::x0() const
+{
+  return v0[0];
+}
+float AGRect2::y0() const
+{
+  return v0[1];
+}
+float AGRect2::x1() const
+{
+  return v1[0];
+}
+float AGRect2::y1() const
+{
+  return v1[1];
+}
+
+AGRect2 AGRect2::origin() const
+{
+  return AGRect2(0,0,w(),h());
+}
+
+float AGRect2::content() const
+{
+  return (v1[0]-v0[0])*(v1[1]-v0[1]);
+}
+
+
+void AGRect2::include(const AGVector2 &amp;v)
+{
+  v0[0]=std::min(v0[0],v[0]);
+  v0[1]=std::min(v0[1],v[1]);
+  v1[0]=std::max(v1[0],v[0]);
+  v1[1]=std::max(v1[1],v[1]);
+}
+
+
+std::list&lt;AGRect2&gt; AGRect2::split() const
+{
+  std::list&lt;AGRect2&gt; l;
+  float hw=(v1[0]-v0[0])/2;
+  float hh=(v1[1]-v0[1])/2;
+  l.push_back(AGRect2(v0[0]   ,v0[1]   ,hw,hh));
+  l.push_back(AGRect2(v0[0]+hw,v0[1]   ,hw,hh));
+  l.push_back(AGRect2(v0[0]   ,v0[1]+hh,hw,hh));
+  l.push_back(AGRect2(v0[0]+hw,v0[1]+hh,hw,hh));
+
+  return l;
+}
+
+
+bool AGRect2::contains(const AGRect2 &amp;v) const
+{
+  return contains(v.getV0()) &amp;&amp; contains(v.getV1()) &amp;&amp; contains(v.getV01()) &amp;&amp; contains(v.getV10());
+}
+AGVector2 AGRect2::getV0() const
+{
+  return v0;
+}
+AGVector2 AGRect2::getV1() const
+{
+  return v1;
+}
+AGVector2 AGRect2::getV01() const
+{
+  return AGVector2(v0[0],v1[1]);
+}
+AGVector2 AGRect2::getV10() const
+{
+  return AGVector2(v1[0],v0[1]);
+}
+
+
+bool AGRect2::contains(const AGVector2 &amp;v) const
+{
+  return (v.getX()&gt;= v0.getX() &amp;&amp; v.getY()&gt;=v0.getY() &amp;&amp; v.getX()&lt;=v1.getX() &amp;&amp; v.getY()&lt;=v1.getY());
+}
+
+AGString AGRect2::toString() const
+{
+  return v0.toString()+&quot;:&quot;+v1.toString();
+}
+
+
+void AGRect2::setX(float p)
+{
+  float mw=w();
+  v0.setX(p);
+  v1.setX(p+mw);
+}
+void AGRect2::setY(float p)
+{
+  float mh=h();
+  v0.setY(p);
+  v1.setY(p+mh);
+}
+
+void AGRect2::setLeft(float p)
+{
+  float mw=w();
+  v0.setX(p);
+  v1.setX(p+mw);
+}
+void AGRect2::setTop(float p)
+{
+  float mh=h();
+  v0.setY(p);
+  v1.setY(p+mh);
+}
+
+void AGRect2::setRight(float p)
+{
+  v1.setX(p);
+}
+void AGRect2::setBottom(float p)
+{
+  v1.setY(p);
+}
+
+
+
+bool AGRect2::collide(const AGRect2 &amp;r) const
+{
+  return collide1d(v0.getX(),v1.getX(),r.v0.getX(),r.v1.getX()) &amp;&amp; collide1d(v0.getY(),v1.getY(),r.v0.getY(),r.v1.getY());
+}
+
+AGRect2 AGRect2::operator+(const AGVector2 &amp;v) const
+{
+  return AGRect2(v0+v,v1+v);
+}
+AGRect2 &amp;AGRect2::operator+=(const AGVector2 &amp;v)
+{
+  v0+=v;
+  v1+=v;
+  return *this;
+}
+
+AGRect2 &amp;AGRect2::operator-=(const AGVector2 &amp;v)
+{
+  v0-=v;
+  v1-=v;
+  return *this;
+}
+
+float AGRect2::x() const
+{
+  return v0.getX();
+}
+float AGRect2::y() const
+{
+  return v0.getY();
+}
+float AGRect2::w() const
+{
+  return v1.getX()-v0.getX();
+}
+float AGRect2::h() const
+{
+  return v1.getY()-v0.getY();
+}
+
+float AGRect2::width() const
+{
+  return v1.getX()-v0.getX();
+}
+float AGRect2::height() const
+{
+  return v1.getY()-v0.getY();
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// AGLine
+/////////////////////////////////////////////////////////////////////////////
+
+AGLine2::AGLine2()
+{
+}
+
+AGLine2::AGLine2(const AGVector2 &amp;pv0,const AGVector2 &amp;pv1):
+  v0(pv0),v1(pv1)
+{
+}
+
+AGVector2 &amp;AGLine2::operator[](size_t i)
+{
+  switch(i)
+    {
+    case 0:
+      return v0;
+    case 1:
+      return v1;
+    default:
+      throw AGString(&quot;wrong index in AGLine::op[]&quot;);
+    }
+  return v0;
+}
+AGVector2 AGLine2::operator[](size_t i) const
+{
+  switch(i)
+    {
+    case 0:
+      return v0;
+    case 1:
+      return v1;
+    default:
+      throw AGString(&quot;wrong index in AGLine::op[]&quot;);
+    }
+  return v0;
+}
+
+  
+AGVector2 AGLine2::getV0() const
+{
+  return v0;
+}
+AGVector2 AGLine2::getV1() const
+{
+  return v1;
+}
+
+bool AGLine2::has(const AGVector2 &amp;v) const
+{
+  return v0==v || v1==v;
+}
+
+AGVector2 AGLine2::collisionPointNI(const AGLine2 &amp;l) const
+{
+  float dx, dy;
+  float ldx, ldy;
+  dx = v1.getX() - v0.getX();
+  dy = v1.getY() - v0.getY();
+  ldx = l.v1.getX() - l.v0.getX();
+  ldy = l.v1.getY() - l.v0.getY();
+
+  AGVector2 p;
+  
+  if(dx==0.0f)
+    {
+      if(ldx==0.0f)
+	return invalidVec2; // invalid
+      
+      // ldy!=0 !!
+      float lm = ldy/ldx;
+      float lb = l.v0.getY() - lm * l.v0.getX();
+
+      //      cdebug(lm);
+      //      cdebug(lb);
+      
+      assert(lm!=0.0f);
+      p=AGVector2(v0.getX(),lm*v0.getX()+lb);
+    }
+  else if(ldx==0.0f)
+    {
+      p=l.collisionPointNI(*this);
+    }
+  else
+    {
+      // ldy!=0 &amp;&amp; dy!=0
+      float m =dy/dx;
+      float lm =ldy/ldx;
+      float b = v0.getY() - m * v0.getX();
+      float lb=l.v0.getY() - lm * l.v0.getX();
+
+      if(m == lm)
+	return AGVector2(0,0); // parallel
+      float x=(lb-b)/(m-lm); 
+      p=AGVector2(x,m*x+b);
+    }
+  return p;
+}
+AGVector2 AGLine2::collisionPoint(const AGLine2 &amp;l) const
+{
+  AGVector2 p=collisionPointNI(l);
+  if(p==invalidVec2)
+    return p;
+  // check for inclusion
+  if(includes(p) &amp;&amp; l.includes(p))
+    {
+    assert(distance(p)&lt;0.01);
+    assert(l.distance(p)&lt;0.01);
+    return p;
+  }
+  else
+    return invalidVec2;
+}
+
+bool AGLine2::includes(const AGVector2 &amp;v) const
+{
+  float f=(v-v0)*((v1-v0).normalized());
+  if(f&gt;=0 &amp;&amp; f&lt;(v1-v0).length())
+  {
+    /*    cdebug(v0.toString()&lt;&lt;&quot;  &quot;&lt;&lt;v1.toString()&lt;&lt;&quot;  &quot;&lt;&lt;v.toString());
+    cdebug((v-v0).toString()&lt;&lt;&quot;   &quot;&lt;&lt;(v1-v0).toString()&lt;&lt;&quot;   &quot;&lt;&lt;(v1-v0).normalized().toString()&lt;&lt;&quot;   &quot;&lt;&lt;(v1-v0).length());
+    cdebug(f);*/
+    return true;
+  }
+  return false;
+}
+
+AGRect2 AGLine2::getBBox() const
+{
+  return AGRect2(std::min(v0.getX(),v1.getX()),std::min(v0.getY(),v1.getY()),fabs(v0.getX()-v1.getX()),fabs(v1.getY()-v0.getY()));
+}
+
+bool AGLine2::collide(const AGLine2 &amp;l) const
+{
+  AGVector2 d0,d1;
+  AGVector2 n0,n1;
+
+  d0=direction();
+  d1=l.direction();
+  n0=normal();
+  n1=l.normal();
+  
+  bool t0=collide1d(v0*d0,v1*d0,l.v0*d0,l.v1*d0,false);
+  bool t1=collide1d(v0*d1,v1*d1,l.v0*d1,l.v1*d1,false);
+
+  bool t2=collide1d(v0*n0,v1*n0,l.v0*n0,l.v1*n0,false);
+  bool t3=collide1d(v0*n1,v1*n1,l.v0*n1,l.v1*n1,false);
+
+  return t0 &amp;&amp; t1 &amp;&amp; t2 &amp;&amp; t3;
+}
+
+AGVector2 AGLine2::normal() const
+{
+  return (v1-v0).normalized().normal();
+}
+
+AGVector2 AGLine2::direction() const
+{
+  return v1-v0;
+}
+
+
+
+AGString AGLine2::toString() const
+{
+  std::ostringstream os;
+  os&lt;&lt;&quot;(&quot;&lt;&lt;v0.toString()&lt;&lt;&quot;-&quot;&lt;&lt;v1.toString()&lt;&lt;&quot;)&quot;;
+  return AGString(os.str());
+}
+
+float AGLine2::distance(const AGVector2 &amp;v) const
+{
+  return fabs(normal()*(v-v0));
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// AGLine3
+/////////////////////////////////////////////////////////////////////////////
+
+AGLine3::AGLine3()
+{
+}
+
+AGLine3::AGLine3(const AGVector3 &amp;pv0,const AGVector3 &amp;pv1):
+  v0(pv0),v1(pv1)
+{
+}
+
+float AGLine3::distance(const AGVector3 &amp;p) const
+{
+  AGVector3 dir=direction();
+  AGVector3 diff=p-v0;
+  AGVector3 normal1=dir%diff;
+  AGVector3 plane_normal=dir%normal1;
+  plane_normal.normalize();
+  return fabs(diff*plane_normal);
+}
+
+  
+AGVector3 AGLine3::getV0() const
+{
+  return v0;
+}
+AGVector3 AGLine3::getV1() const
+{
+  return v1;
+}
+
+bool AGLine3::has(const AGVector3 &amp;v) const
+{
+  return v0==v || v1==v;
+}
+
+AGVector3 AGLine3::direction() const
+{
+  return v1-v0;
+}
+
+
+AGString AGLine3::toString() const
+{
+  AGStringStream os;
+  os&lt;&lt;&quot;(&quot;&lt;&lt;v0.toString()&lt;&lt;&quot;-&quot;&lt;&lt;v1.toString()&lt;&lt;&quot;)&quot;;
+  return os.str();
+}
+/*
+float AGLine3::distance(const AGVector3 &amp;v) const
+{
+  return fabs(normal()*(v-v0));
+  }*/
+
+
+
+///////////////////////////////////////////////////////////////
+// AGVector4
+///////////////////////////////////////////////////////////////
+
+
+AGVector4::AGVector4(float pX,float pY,float pZ,float pW)
+{
+  v[0]=pX;
+  v[1]=pY;
+  v[2]=pZ;
+  v[3]=pW;
+}
+AGVector4::AGVector4(const AGVector4 &amp;a)
+{
+  v[0]=a.v[0];
+  v[1]=a.v[1];
+  v[2]=a.v[2];
+  v[3]=a.v[3];
+}
+AGVector4::AGVector4(const AGVector3 &amp;a,float h)
+{
+  v[0]=a.v[0];
+  v[1]=a.v[1];
+  v[2]=a.v[2];
+  v[3]=h;
+}
+
+AGVector3 AGVector4::dim3() const
+{
+  return AGVector3(v[0],v[1],v[2]);
+}
+AGVector2 AGVector4::dim2() const
+{
+  return AGVector2(v[0],v[1]);
+}
+
+
+AGVector4::AGVector4()
+{
+  v[0]=v[1]=v[2]=0.0f;
+  v[3]=1.0f;
+}
+
+AGVector4 AGVector4::operator-() const
+{
+  return AGVector4(-v[0],-v[1],-v[2],-v[3]);
+}
+
+
+void AGVector4::setX(float pX)
+{
+  v[0]=pX;
+}
+void AGVector4::setY(float pY)
+{
+  v[1]=pY;
+}
+void AGVector4::setZ(float pZ)
+{
+  v[2]=pZ;
+}
+void AGVector4::setW(float pW)
+{
+  v[3]=pW;
+}
+
+float AGVector4::getX() const
+{
+  return v[0];
+}
+float AGVector4::getY() const
+{
+  return v[1];
+}
+float AGVector4::getZ() const
+{
+  return v[2];
+}
+float AGVector4::getW() const
+{
+  return v[3];
+}
+
+AGVector4 AGVector4::operator-(const AGVector4 &amp;p) const
+{
+  return AGVector4(v[0]-p.v[0],
+		   v[1]-p.v[1],
+		   v[2]-p.v[2],
+		   v[3]-p.v[3]);
+}
+AGVector4 AGVector4::operator+(const AGVector4 &amp;p) const
+{
+  return AGVector4(v[0]+p.v[0],
+		   v[1]+p.v[1],
+		   v[2]+p.v[2],
+		   v[3]+p.v[3]);
+}
+AGVector4 &amp;AGVector4::operator+=(const AGVector4 &amp;p)
+{
+  v[0]+=p.v[0];
+  v[1]+=p.v[1];
+  v[2]+=p.v[2];
+  v[3]+=p.v[3];
+  return *this;
+}
+AGVector4 &amp;AGVector4::operator-=(const AGVector4 &amp;p)
+{
+  v[0]-=p.v[0];
+  v[1]-=p.v[1];
+  v[2]-=p.v[2];
+  v[3]-=p.v[3];
+  return *this;
+}
+
+float AGVector4::operator*(const AGVector4 &amp;p) const
+{
+  return v[0]*p.v[0]+
+    v[1]*p.v[1]+
+    v[2]*p.v[2]+
+    v[3]*p.v[3];
+}
+AGVector4 &amp;AGVector4::operator*=(float f)
+{
+  v[0]*=f;
+  v[1]*=f;
+  v[2]*=f;
+  v[3]*=f;
+  return *this;
+}
+AGVector4 &amp;AGVector4::operator/=(float f)
+{
+  v[0]/=f;
+  v[1]/=f;
+  v[2]/=f;
+  v[3]/=f;
+  return *this;
+}
+AGVector4 AGVector4::operator*(float f) const
+{
+  return AGVector4(v[0]*f,v[1]*f,v[2]*f,v[3]*f);
+}
+AGVector4 AGVector4::operator/(float f) const
+{
+  return AGVector4(v[0]/f,v[1]/f,v[2]/f,v[3]/f);
+}
+
+bool AGVector4::operator==(const AGVector4 &amp;a) const
+{
+  return v[0]==a.v[0] &amp;&amp;
+    v[1]==a.v[1] &amp;&amp;
+    v[2]==a.v[2] &amp;&amp;
+    v[3]==a.v[3];
+}
+bool AGVector4::operator!=(const AGVector4 &amp;a) const
+{
+  return !operator==(a);
+}
+
+float AGVector4::length() const
+{
+  return sqrt(length2());
+}
+float AGVector4::length2() const
+{
+  return v[0]*v[0]+
+    v[1]*v[1]+
+    v[2]*v[2]+
+    v[3]*v[3];
+}
+
+float AGVector4::length3() const
+{
+  return sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
+}
+
+AGVector4 AGVector4::normalized() const
+{
+  return *this*(1.0f/length());
+}
+void AGVector4::normalize()
+{
+  operator*=(1.0f/length());
+}
+
+AGVector4 AGVector4::normalized3() const
+{
+  return *this*(1.0f/length3());
+}
+void AGVector4::normalize3()
+{
+  operator*=(1.0f/length3());
+}
+
+float &amp;AGVector4::operator[](int index)
+{
+  assert(index&gt;=0 &amp;&amp; index&lt;4);
+  return v[index];
+}
+
+float AGVector4::operator[](int index) const
+{
+  assert(index&gt;=0 &amp;&amp; index&lt;4);
+  return v[index];
+}
+
+bool AGVector4::nonZero() const
+{
+  return v[0]!=0 ||
+    v[1]!=0 ||
+    v[2]!=0 ||
+    v[3]!=0;
+}
+
+AGString AGVector4::toString() const
+{
+  AGStringStream os;
+  os&lt;&lt;&quot;(&quot;&lt;&lt;v[0]&lt;&lt;&quot;,&quot;&lt;&lt;v[1]&lt;&lt;&quot;,&quot;&lt;&lt;v[2]&lt;&lt;&quot;,&quot;&lt;&lt;v[3]&lt;&lt;&quot;)&quot;;
+  return os.str();
+}
+
+(AGVector4::operator float*)()
+{
+  return v;
+}
+
+(AGVector4::operator const float*)() const
+{
+  return v;
+}
+
+AGVector4 AGVector4::operator%(const AGVector4 &amp;a) const
+{
+  return AGVector4(v[1] * a.v[2] - v[2] * a.v[1],
+		   v[2] * a.v[0] - v[0] * a.v[2],
+		   v[0] * a.v[1] - v[1] * a.v[0]);
+}
+
+///////////////////////////////////////////////////////////////
+// AGMatrix4
+///////////////////////////////////////////////////////////////
+
+AGMatrix4::AGMatrix4(float v[16])
+{
+  for(size_t i=0;i&lt;16;i++)
+    a[i]=v[i];
+}
+AGMatrix4::AGMatrix4(float angle,const AGVector3&amp;d)
+{
+  float co=cos(angle);
+  float si=sin(angle);
+  /*
+  set(0,0,co + d[0]*d[0]*(1-co));
+  set(0,1,d[0]*d[1]*(1-co)-d[2]*si);
+  set(0,2,d[0]*d[2]*(1-co)+d[1]*si);
+
+  set(1,0,d[1]*d[0]*(1-co)+d[2]*si);
+  set(1,1,co+d[1]*d[1]*(1-co));
+  set(1,2,d[1]*d[2]*(1-co)-d[0]*si);
+
+  set(2,0,d[2]*d[0]*(1-co)-d[1]*si);
+  set(2,1,d[2]*d[1]*(1-co)+d[0]*si);
+  set(2,2,co + d[2]*d[2]*(1-co));
+  */
+    set(0,0,co + d[0]*d[0]*(1-co));
+  set(1,0,d[0]*d[1]*(1-co)-d[2]*si);
+  set(2,0,d[0]*d[2]*(1-co)+d[1]*si);
+
+  set(0,1,d[1]*d[0]*(1-co)+d[2]*si);
+  set(1,1,co+d[1]*d[1]*(1-co));
+  set(2,1,d[1]*d[2]*(1-co)-d[0]*si);
+
+  set(0,2,d[2]*d[0]*(1-co)-d[1]*si);
+  set(1,2,d[2]*d[1]*(1-co)+d[0]*si);
+  set(2,2,co + d[2]*d[2]*(1-co));
+  
+  set(3,0,0);
+  set(3,1,0);
+  set(3,2,0);
+
+  set(0,3,0);
+  set(1,3,0);
+  set(2,3,0);
+
+  set(3,3,1);
+}
+
+
+AGMatrix4::AGMatrix4()
+{
+  get(0,1)=get(0,2)=get(0,3)=
+    get(1,0)=get(1,2)=get(1,3)=
+    get(2,0)=get(2,1)=get(2,3)=
+    get(3,0)=get(3,1)=get(3,2)=0.0f;
+
+  get(0,0)=get(1,1)=get(2,2)=get(3,3)=1.0f;
+}
+
+/*AGMatrix3::AGMatrix4(const AGAngle &amp;n)
+{
+  a[0][0]=cos(n.angle);
+  a[1][0]=sin(n.angle);
+  a[0][1]=-sin(n.angle);
+  a[1][1]=cos(n.angle);
+  a[2][0]=a[2][1]=a[0][2]=a[1][2]=0.0f;
+  a[2][2]=1.0f;
+  }*/
+
+AGMatrix4::AGMatrix4(const AGVector4 &amp;n)
+{
+  get(0,0)=get(1,1)=get(2,2)=get(3,3)=1.0f;
+  get(0,1)=get(0,2)=get(0,3)=
+    get(1,0)=get(1,2)=get(1,3)=
+    get(2,0)=get(2,1)=get(2,3)=0.0f;
+  get(3,0)=n[0];
+  get(3,1)=n[1];
+  get(3,2)=n[2];
+}
+
+AGMatrix4 &amp;AGMatrix4::operator+=(const AGMatrix4 &amp;m)
+{
+  for(size_t x=0;x&lt;4;x++)
+    for(size_t y=0;y&lt;4;y++)
+      get(x,y)+=m.get(x,y);
+  return *this;
+}
+
+AGMatrix4 AGMatrix4::transposed() const
+{
+  AGMatrix4 a;
+  for(size_t x=0;x&lt;4;x++)
+    for(size_t y=0;y&lt;4;y++)
+      a.get(x,y)=get(y,x);
+  return a;
+}
+
+
+
+AGMatrix4 AGMatrix4::inverted() const
+{
+  // gauss-alg.
+  AGMatrix4 a;
+  AGMatrix4 b(*this);
+
+  gauss(a,b,4);
+  return a;
+}
+
+void AGMatrix4::swapRows(size_t a,size_t b)
+{
+  if(a==b)
+    return;
+  assert(a&lt;4);
+  assert(b&lt;4);
+  for(size_t x=0;x&lt;4;x++)
+    {
+      float t=get(x,a);
+      set(x,a,get(x,b));
+      set(x,b,t);
+    }
+}
+
+void AGMatrix4::swapCols(size_t a,size_t b)
+{
+  if(a==b)
+    return;
+  assert(a&lt;4);
+  assert(b&lt;4);
+  for(size_t y=0;y&lt;4;y++)
+    {
+      float t=get(a,y);
+      set(a,y,get(b,y));
+      set(b,y,t);
+    }
+}
+
+
+AGMatrix3 AGMatrix4::get3x3(size_t x,size_t y) const
+{
+  AGMatrix3 m;
+  assert(x&lt;2);
+  assert(y&lt;2);
+  for(size_t i=0;i&lt;3;i++)
+    for(size_t j=0;j&lt;3;j++)
+      m.set(i,j,get(i+x,j+y));
+  return m;
+}
+
+
+void AGMatrix4::set(size_t x,size_t y,float f)
+{
+  assert(x&gt;=0 &amp;&amp; x&lt;4);
+  assert(y&gt;=0 &amp;&amp; y&lt;4);
+  a[x*4+y]=f;
+}
+float AGMatrix4::get(size_t x,size_t y) const
+{
+  assert(x&gt;=0 &amp;&amp; x&lt;4);
+  assert(y&gt;=0 &amp;&amp; y&lt;4);
+  return a[4*x+y];
+}
+
+float &amp;AGMatrix4::get(size_t x,size_t y)
+{
+  assert(x&gt;=0 &amp;&amp; x&lt;4);
+  assert(y&gt;=0 &amp;&amp; y&lt;4);
+  return a[4*x+y];
+}
+
+AGMatrix4 AGMatrix4::operator*(const AGMatrix4 &amp;m) const
+{
+  AGMatrix4 n;
+  size_t x,y;
+  for(x=0;x&lt;4;x++)
+    for(y=0;y&lt;4;y++)
+      n(x,y)=get(0,y)*m(x,0)+
+	get(1,y)*m(x,1)+
+	get(2,y)*m(x,2)+
+	get(3,y)*m(x,3);
+  return n;
+}
+AGMatrix4 &amp;AGMatrix4::operator*=(const AGMatrix4 &amp;m)
+{
+  *this=(*this)*m;
+  return *this;
+}
+
+AGVector4 AGMatrix4::operator*(const AGVector4 &amp;v) const
+{
+  return AGVector4(get(0,0)*v[0]+get(1,0)*v[1]+get(2,0)*v[2]+get(3,0)*v[3],
+		   get(0,1)*v[0]+get(1,1)*v[1]+get(2,1)*v[2]+get(3,1)*v[3],
+		   get(0,2)*v[0]+get(1,2)*v[1]+get(2,2)*v[2]+get(3,2)*v[3],
+		   get(0,3)*v[0]+get(1,3)*v[1]+get(2,3)*v[2]+get(3,3)*v[3]);
+}
+
+AGString AGMatrix4::toString() const
+{
+  std::ostringstream os;
+  os&lt;&lt;&quot;(&quot;&lt;&lt;get(0,0)&lt;&lt;&quot;,&quot;&lt;&lt;get(1,0)&lt;&lt;&quot;,&quot;&lt;&lt;get(2,0)&lt;&lt;&quot;,&quot;&lt;&lt;get(3,0)&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;
+  os&lt;&lt;&quot;(&quot;&lt;&lt;get(0,1)&lt;&lt;&quot;,&quot;&lt;&lt;get(1,1)&lt;&lt;&quot;,&quot;&lt;&lt;get(2,1)&lt;&lt;&quot;,&quot;&lt;&lt;get(3,1)&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;
+  os&lt;&lt;&quot;(&quot;&lt;&lt;get(0,2)&lt;&lt;&quot;,&quot;&lt;&lt;get(1,2)&lt;&lt;&quot;,&quot;&lt;&lt;get(2,2)&lt;&lt;&quot;,&quot;&lt;&lt;get(3,2)&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;
+  os&lt;&lt;&quot;(&quot;&lt;&lt;get(0,3)&lt;&lt;&quot;,&quot;&lt;&lt;get(1,3)&lt;&lt;&quot;,&quot;&lt;&lt;get(2,3)&lt;&lt;&quot;,&quot;&lt;&lt;get(3,3)&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;
+  return AGString(os.str());
+}
+
+(AGMatrix4::operator float*)()
+{
+  return a;
+}
+
+(AGMatrix4::operator const float*)() const
+{
+  return a;
+}
+
+/*
+double gMatrixDoubleBuf[16];
+(AGMatrix4::operator const double*)() const
+{
+  for(int i=0;i&lt;16;i++)
+    gMatrixDoubleBuf[i]=a[i];
+  return gMatrixDoubleBuf;
+  }*/
+
+float AGMatrix4::operator()(size_t x,size_t y) const
+{
+  return get(x,y);
+}
+float &amp;AGMatrix4::operator()(size_t x,size_t y)
+{
+  return get(x,y);
+}
+
+AGVector4 AGMatrix4::getRow(size_t i) const
+{
+  //  return AGVector4(get(i,0),get(i,1),get(i,2),get(i,3));
+  return AGVector4(get(0,i),get(1,i),get(2,i),get(3,i));
+}
+
+
+AGMatrix4::MRow AGMatrix4::operator[](size_t y)
+{
+  MRow r;
+  r.matrix=this;
+  r.y=y;
+  return r;
+}
+/*
+const AGMatrix4::Row AGMatrix4::operator[](size_t y) const
+{
+  Row r;
+  r.matrix=const_cast&lt;AGMatrix4*&gt;(this);
+  r.y=y;
+  return r;
+  }*/
+
+
+///////////////////////////////////////////////////////////////
+// AGBox3
+///////////////////////////////////////////////////////////////
+
+AGBox3::AGBox3(const AGVector3 &amp;pBase,const AGVector3 &amp;pDir):
+  base(pBase),dir(pDir)
+{
+  // assert that pDir[i]&gt;0
+  for(size_t i=0;i&lt;3;i++)
+    if(dir[i]&lt;0)
+      {
+	base[i]+=dir[i];
+	dir[i]=-dir[i];
+      }
+  mValid=true;
+}
+
+
+
+AGBox3::AGBox3():base(AGVector3(0,0,0)),dir(AGVector3(0,0,0))
+{
+  mValid=false;
+}
+
+bool AGBox3::valid() const
+{
+  return mValid;
+}
+
+
+bool AGBox3::collides(const AGMatrix4 &amp;frustum) const
+{
+  std::vector&lt;AGVector3&gt; a=getVertices();
+  float minx,miny,minz;
+  float maxx,maxy,maxz;
+
+  minx=miny=minz=10000;
+  maxx=maxy=maxz=-10000;
+  // simply check, if any of the box's vertices lie inside the frustum
+  for(std::vector&lt;AGVector3&gt;::iterator i=a.begin();i!=a.end();i++)
+    {
+      AGVector4 p(frustum*AGVector4(*i,1));
+      p/=p[3];
+      if(p[0]&gt;=-1 &amp;&amp; p[0]&lt;=1 &amp;&amp;
+	 p[1]&gt;=-1 &amp;&amp; p[1]&lt;=1 &amp;&amp;
+	 p[2]&gt;=-1 &amp;&amp; p[2]&lt;=1)
+	return true;
+
+      minx=std::min(minx,p[0]);
+      miny=std::min(miny,p[1]);
+      minz=std::min(minz,p[2]);
+
+      maxx=std::max(maxx,p[0]);
+      maxy=std::max(maxy,p[1]);
+      maxz=std::max(maxz,p[2]);
+	
+    }
+
+  return AGBox3(AGVector3(-1,-1,-1),AGVector3(2,2,2)).collides(AGBox3(AGVector3(minx,miny,minz),AGVector3(maxx-minx,maxy-miny,maxz-minz)));
+}
+
+bool AGBox3::collides(const AGBox3 &amp;box) const
+{
+  AGVector3 a=base+dir;
+  AGVector3 b=box.base+box.dir;
+
+  /*  cdebug(base.toString()&lt;&lt;&quot;   &quot;&lt;&lt;a.toString());
+  cdebug(box.base.toString()&lt;&lt;&quot;   &quot;&lt;&lt;b.toString());
+
+  cdebug(collide1d(base[0],a[0],box.base[0],b[0]));
+  cdebug(collide1d(base[1],a[1],box.base[1],b[1]));
+  cdebug(collide1d(base[2],a[2],box.base[2],b[2]));
+  */
+
+  return collide1d(base[0],a[0],box.base[0],b[0]) &amp;&amp;
+    collide1d(base[1],a[1],box.base[1],b[1]) &amp;&amp;
+    collide1d(base[2],a[2],box.base[2],b[2]);
+}
+
+
+
+std::vector&lt;AGVector3&gt; AGBox3::getVertices() const
+{
+  std::vector&lt;AGVector3&gt; a;
+  a.push_back(base+AGVector3(0,0,0));
+  a.push_back(base+AGVector3(dir[0],0,0));
+  a.push_back(base+AGVector3(0,dir[1],0));
+  a.push_back(base+AGVector3(0,0,dir[2]));
+
+  a.push_back(base+AGVector3(dir[0],dir[1],0));
+  a.push_back(base+AGVector3(dir[0],0,dir[2]));
+  a.push_back(base+AGVector3(0,dir[1],dir[2]));
+  a.push_back(base+AGVector3(dir[0],dir[1],dir[2]));
+  return a;
+}
+
+AGBox3 AGBox3::operator-(const AGVector3 &amp;v) const
+{
+  if(valid())
+    return AGBox3(base-v,dir);
+  else
+    return AGBox3();
+}
+AGBox3 AGBox3::operator+(const AGVector3 &amp;v) const
+{
+  if(valid())
+    return AGBox3(base+v,dir);
+  else
+    return AGBox3();
+}
+
+
+
+void AGBox3::include(const AGVector3&amp;p)
+{
+  if(!mValid)
+    {
+      base=p;
+      dir=AGVector3(0,0,0);
+      mValid=true;
+      return;
+    }
+  AGVector3 b=base,b2=base+dir;
+
+  base[0]=std::min(b[0],p[0]);
+  base[1]=std::min(b[1],p[1]);
+  base[2]=std::min(b[2],p[2]);
+  AGVector3 n;
+  n[0]=std::max(b2[0],p[0]);
+  n[1]=std::max(b2[1],p[1]);
+  n[2]=std::max(b2[2],p[2]);
+  dir[0]=n[0]-base[0];
+  dir[1]=n[1]-base[1];
+  dir[2]=n[2]-base[2];
+}
+
+bool AGBox3::collides(const AGVector3&amp;p) const
+{
+  return p[0]&gt;=base[0] &amp;&amp; p[1]&gt;=base[1] &amp;&amp; p[2]&gt;=base[2] &amp;&amp;
+    p[0]&lt;base[0]+dir[0] &amp;&amp; p[1]&lt;base[1]+dir[1] &amp;&amp; p[2]&lt;base[2]+dir[2];
+}
+bool AGBox3::collides(const AGLine3&amp;p) const
+{
+  // FIXME: implement like this:<A HREF="http://www.garagegames.com/index.php?sec=mg&amp;mod=resource&amp;page=view&amp;qid=309">http://www.garagegames.com/index.php?sec=mg&amp;mod=resource&amp;page=view&amp;qid=309</A>
+
+  std::vector&lt;AGRect3&gt; sides=getSides();
+  for(std::vector&lt;AGRect3&gt;::iterator i=sides.begin();i!=sides.end();++i)
+    {
+      if((*i).collides(p))
+	return true;
+    }
+  return false;
+}
+
+bool AGBox3::contains(const AGTriangle3 &amp;t) const
+{
+  for(size_t i=0;i&lt;3;i++)
+    if(!collides(t[i]))
+      return false;
+  return true;
+}
+
+
+std::vector&lt;AGRect3&gt; AGBox3::getSides() const
+{
+  AGVector3 b2=base+dir;
+  std::vector&lt;AGRect3&gt; s;
+  s.push_back(AGRect3(base,AGVector3(dir[0],dir[1],0)));
+  s.push_back(AGRect3(base,AGVector3(dir[0],0,dir[2])));
+  s.push_back(AGRect3(base,AGVector3(0,dir[1],dir[2])));
+  s.push_back(AGRect3(b2,AGVector3(-dir[0],-dir[1],0)));
+  s.push_back(AGRect3(b2,AGVector3(-dir[0],0,-dir[2])));
+  s.push_back(AGRect3(b2,AGVector3(0,-dir[1],-dir[2])));
+  return s;
+}
+
+bool AGBox3::includes(const AGBox3 &amp;b)
+{
+  AGVector3 u0=base+dir;
+  AGVector3 u1=b.base+b.dir;
+  return (b.base[0]&gt;=base[0] &amp;&amp; b.base[1]&gt;=base[1] &amp;&amp; b.base[2]&gt;=base[2] &amp;&amp;
+	  u1[0]&lt;=u0[0] &amp;&amp; u1[1]&lt;=u0[1] &amp;&amp; u1[2]&lt;=u0[2]);
+}
+
+AGString AGBox3::toString() const
+{
+  std::ostringstream os;
+  os&lt;&lt;&quot;[&quot;&lt;&lt;base.toString()&lt;&lt;&quot;;&quot;&lt;&lt;dir.toString()&lt;&lt;&quot;]&quot;;
+  return AGString(os.str());
+}
+
+std::vector&lt;AGBox3&gt; AGBox3::split() const
+{
+  std::vector&lt;AGBox3&gt; r;
+  AGVector3 d=dir*0.5;
+  AGVector3 x(dir[0],0,0);
+  AGVector3 y(0,dir[1],0);
+  AGVector3 z(0,0,dir[2]);
+  r.push_back(AGBox3(base      ,d));
+  r.push_back(AGBox3(base+x    ,d));
+  r.push_back(AGBox3(base  +y  ,d));
+  r.push_back(AGBox3(base+x+y  ,d));
+  r.push_back(AGBox3(base    +z,d));
+  r.push_back(AGBox3(base+x  +z,d));
+  r.push_back(AGBox3(base  +y+z,d));
+  r.push_back(AGBox3(base+x+y+z,d));
+  return r;
+}
+
+///////////////////////////////////////////////////////////////
+// AGRect3
+///////////////////////////////////////////////////////////////
+
+AGRect3::AGRect3(const AGVector3 &amp;pBase,const AGVector3 &amp;pDir):
+  base(pBase),dir(pDir)
+{
+  // assert that dir[i]&gt;=0
+  for(size_t i=0;i&lt;3;i++)
+    if(dir[i]&lt;0)
+      {
+	base[i]+=dir[i];
+	dir[i]=-dir[i];
+      }
+}
+
+bool AGRect3::collides(const AGLine3&amp;pLine) const
+{
+  AGVector3 d0,d1; // directions of rect's sides
+  if(dir[0]==0)
+    {
+      d0=AGVector3(0,dir[1],0);
+      d1=AGVector3(0,0,dir[2]);
+    }
+  else if(dir[1]==0)
+    {
+      d0=AGVector3(dir[0],0,0);
+      d1=AGVector3(0,0,dir[2]);
+    }
+  else
+    {
+      d0=AGVector3(dir[0],0,0);
+      d1=AGVector3(0,dir[1],0);
+    }
+
+  AGVector3 normal=d0%d1;
+
+  float v0=(pLine.getV0()-base)*normal;
+  float v1=(pLine.getV1()-base)*normal;
+  if(AGsign(v0)==AGsign(v1))
+    return false;
+
+  float vall=v1-v0;
+  float v=-v0/vall;
+  AGVector3 ip=pLine.getV1()*v+pLine.getV0()*(1-v);
+
+  //  cdebug(&quot;ip:&quot;&lt;&lt;ip.toString());
+  //  cdebug(&quot;dist:&quot;&lt;&lt;(ip-base)*normal);
+  
+  for(size_t i=0;i&lt;3;i++)
+    {
+      if(fabs(dir[i])&lt;0.0001)
+	continue;
+      if(ip[i]&lt;base[i] || ip[i]&gt;base[i]+dir[i])
+	{
+	  //	  cdebug(&quot;fail:&quot;&lt;&lt;i);
+	  return false;
+	}
+    }
+  return true;
+}
+
+AGString AGRect3::toString() const
+{
+  std::ostringstream os;
+  os&lt;&lt;&quot;[&quot;&lt;&lt;base.toString()&lt;&lt;&quot;;&quot;&lt;&lt;dir.toString()&lt;&lt;&quot;]&quot;;
+  return AGString(os.str());
+}
+
+
+
+
+std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGVector2&amp;v)
+{
+  o&lt;&lt;v.toString();
+  return o;
+}
+
+std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGVector3&amp;v)
+{
+  o&lt;&lt;v.toString();
+  return o;
+}
+
+std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGVector4&amp;v)
+{
+  o&lt;&lt;v.toString();
+  return o;
+}
+
+std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGRect2&amp;v)
+{
+  o&lt;&lt;v.toString();
+  return o;
+}
+
+std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGBox3&amp;v)
+{
+  o&lt;&lt;&quot;(&quot;&lt;&lt;v.base&lt;&lt;&quot; &quot;&lt;&lt;v.dir&lt;&lt;&quot;/&quot;&lt;&lt;v.valid()&lt;&lt;&quot;)&quot;;
+  return o;
+}

Added: antargis/branches/rant/ext/basic/ag_geometry.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_geometry.h	2007-07-16 18:48:58 UTC (rev 1145)
+++ antargis/branches/rant/ext/basic/ag_geometry.h	2007-07-21 07:44:39 UTC (rev 1146)
@@ -0,0 +1,706 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_geometry.h
+ * by David Kamphausen (<A HREF="https://lists.berlios.de/mailman/listinfo/antargis-svn">david.kamphausen at web.de</A>)
+ *
+ * The &quot;Antargis&quot; project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_TRIANGLE_H
+#define AG_TRIANGLE_H
+
+#include &lt;SDL.h&gt;
+#include &lt;iostream&gt;
+#include &lt;list&gt;
+#include &lt;vector&gt;
+#include &lt;ag_base.h&gt;
+#include &lt;ag_string.h&gt;
+
+/* There are following classes:
+
+   We do NOT use templates here, because of SWIG-problems.
+
+   - AGVector2 - 2d vector
+   - AGVector3 - is homogenous 2d and inhom 3d
+   - AGVector4 - hom. 3d
+   - AGMatrix3 - 3x3 Matrix
+   - AGMatrix4 - 4x4 Matrix
+
+   - AGLine2     - 2d Line (eats AGVector3)
+   - AGTriangle2 - 2d triangle (eats AGVector3)
+
+   ATTENTION: the classes may NOT be virtual, as they're possibly used in an array, where then the size is NOT sizeof(v[x]) !!!
+*/
+
+
+class AGRect2;
+class AGBox3;
+class Node;
+
+/** \brief Simple structure holding an angle in degrees
+ */
+struct AGEXPORT AGAngle
+{
+  float angle;
+  
+  /// @param an angle in degrees
+  explicit AGAngle(float a);
+};
+
+class AGEXPORT AGVector2
+{
+ public:
+  float v[2];
+
+  AGVector2(const AGString &amp;s);
+  AGVector2(float pX,float pY);
+  AGVector2(const AGAngle &amp;a);
+  AGVector2(const AGVector2 &amp;a);
+  AGVector2();
+
+  void setX(float pX);
+  void setY(float pY);
+
+  AGVector2 dim2() const;
+
+  
+#ifdef SWIG
+  %rename(x) getX() const;
+  %rename(y) getY() const;
+#endif
+  float getX() const;
+  float getY() const;
+
+  AGAngle getAngle() const;
+
+  AGVector2 operator-() const;
+  AGVector2 operator-(const AGVector2 &amp;p) const;
+  AGVector2 operator+(const AGVector2 &amp;p) const;
+  AGVector2 &amp;operator+=(const AGVector2 &amp;p);
+  AGVector2 &amp;operator-=(const AGVector2 &amp;p);
+
+  float operator*(const AGVector2 &amp;p) const;
+  AGVector2 &amp;operator*=(float f);
+  AGVector2 &amp;operator/=(float f);
+  AGVector2 operator*(float f) const;
+  AGVector2 operator/(float f) const;
+
+  bool operator==(const AGVector2 &amp;a) const;
+  bool operator!=(const AGVector2 &amp;a) const;
+
+  float length() const;
+  float length2() const;
+
+  AGVector2 normalized() const;
+  void normalize();
+
+  AGVector2 normal() const;
+
+#ifdef SWIG
+  %rename(__getitem__) operator[](int index) const;
+#endif
+  float operator[](int index) const;
+  float &amp;operator[](int index);
+
+  bool nonZero() const;
+
+  void saveXML(Node &amp;node) const;
+  void loadXML(const Node &amp;node);
+
+#ifdef SWIG
+  %rename(to_s) toString() const;
+#endif
+  AGString toString() const;
+
+#ifndef SWIG
+  (operator float*)();
+  (operator const float*)() const;
+#endif
+};
+
+// 2-dim homogenous vector
+class AGEXPORT AGVector3
+{
+ public:
+  float v[3];
+
+  AGVector3(const AGVector2 &amp;p,float h=1.0f);
+  AGVector3(float pX,float pY,float pZ=0.0f);
+  AGVector3(const AGAngle &amp;a);
+  AGVector3(const AGVector3 &amp;a);
+  AGVector3();
+
+  void setX(float pX);
+  void setY(float pY);
+  void setZ(float pZ);
+
+  
+#ifdef SWIG
+  %rename(x) getX() const;
+  %rename(y) getY() const;
+  %rename(z) getZ() const;
+#endif
+  float getX() const;
+  float getY() const;
+  float getZ() const;
+
+  AGAngle getAngle() const;
+
+  AGVector3 operator-() const;
+
+  AGVector3 operator-(const AGVector3 &amp;p) const;
+  AGVector3 operator+(const AGVector3 &amp;p) const;
+#ifdef SWIG
+%rename(add) operator+=(const AGVector3 &amp;p);
+%rename(sub) operator-=(const AGVector3 &amp;p);
+#endif
+  AGVector3 &amp;operator+=(const AGVector3 &amp;p);
+  AGVector3 &amp;operator-=(const AGVector3 &amp;p);
+
+  float operator*(const AGVector3 &amp;p) const;
+  AGVector3 &amp;operator*=(float f);
+  AGVector3 &amp;operator/=(float f);
+  AGVector3 operator*(float f) const;
+  AGVector3 operator/(float f) const;
+  AGVector3 operator%(const AGVector3 &amp;a) const;
+
+  bool operator==(const AGVector3 &amp;a) const;
+  bool operator!=(const AGVector3 &amp;a) const;
+
+  float length() const;
+  float length2() const;
+
+  AGVector3 normalized() const;
+  void normalize();
+
+  AGVector3 normal() const;
+
+  float operator[](int index) const;
+  float &amp;operator[](int index);
+
+  bool nonZero() const;
+
+  void saveXML(Node &amp;node) const;
+  void loadXML(const Node &amp;node);
+
+  AGVector2 dim2() const;
+
+#ifdef SWIG
+  %rename(to_s) toString() const;
+#endif
+  AGString toString() const;
+
+#ifndef SWIG
+  (operator float*)();
+#endif
+};
+
+
+class AGEXPORT AGMatrix3
+{
+  float a[3][3];
+ public:
+  struct Row
+  {
+    AGMatrix3 *matrix;
+    int y;
+
+    float &amp;operator[](size_t x)
+    {
+      return matrix-&gt;get(x,y);
+    }
+    float operator[](size_t x) const
+    {
+      return matrix-&gt;get(x,y);
+    }
+  };
+
+  AGMatrix3();
+  AGMatrix3(const AGAngle &amp;a); // rotate
+  AGMatrix3(const AGVector3 &amp;a); // transpose
+  AGMatrix3(float x,float y); // scale
+  void set(size_t x,size_t y,float f);
+  float get(size_t x,size_t y) const;
+  float &amp;get(size_t x,size_t y);
+
+  AGMatrix3 operator*(const AGMatrix3 &amp;m) const;
+  AGMatrix3 &amp;operator*=(const AGMatrix3 &amp;m);
+
+  AGVector3 operator*(const AGVector3 &amp;v) const;
+  //  AGVector2 operator*(const AGVector2 &amp;v) const;
+
+  AGMatrix3 operator-() const;
+
+  AGMatrix3 inverted() const;
+  AGMatrix3 transposed() const;
+
+  Row operator[](size_t y);
+  const Row operator[](size_t y) const;
+
+  void swapRows(size_t a,size_t b);
+  void swapCols(size_t a,size_t b);
+  
+
+#ifdef SWIG
+  %rename(to_s) toString() const;
+#endif
+  AGString toString() const;
+};
+
+class AGEXPORT AGLine2
+{
+  AGVector2 v0,v1;
+ public:
+  AGLine2();
+  AGLine2(const AGVector2 &amp;pv0,const AGVector2 &amp;pv1);
+  
+  AGVector2 getV0() const;
+  AGVector2 getV1() const;
+
+  bool has(const AGVector2 &amp;v) const;
+
+  bool collide(const AGLine2 &amp;l) const;
+  AGVector2 collisionPoint(const AGLine2 &amp;l) const;
+  AGVector2 collisionPointNI(const AGLine2 &amp;l) const; // no inclusion test
+  bool includes(const AGVector2 &amp;v) const;
+
+  AGRect2 getBBox() const;
+
+  AGVector2 normal() const;
+  AGVector2 direction() const;
+
+  float distance(const AGVector2 &amp;v) const;
+
+  AGVector2 &amp;operator[](size_t i);
+  AGVector2 operator[](size_t i) const;
+
+#ifdef SWIG
+  %rename(to_s) toString() const;
+#endif
+  AGString toString() const;
+};
+
+class AGEXPORT AGLine3
+{
+  AGVector3 v0,v1;
+ public:
+  AGLine3();
+  AGLine3(const AGVector3 &amp;pv0,const AGVector3 &amp;pv1);
+  
+  AGVector3 getV0() const;
+  AGVector3 getV1() const;
+
+  bool has(const AGVector3 &amp;v) const;
+  /*
+  bool collide(const AGLine3 &amp;l) const;
+  AGVector3 collisionPoint(const AGLine3 &amp;l) const;
+  AGVector3 collisionPointNI(const AGLine3 &amp;l) const; // no inclusion test
+  bool includes(const AGVector3 &amp;v) const;
+  */
+  //  AGBox3 getBBox() const;
+
+  //  AGVector3 normal() const;
+  AGVector3 direction() const;
+
+  float distance(const AGVector3 &amp;p) const;
+
+  //  float distance(const AGVector3 &amp;v) const;
+
+#ifdef SWIG
+  %rename(to_s) toString() const;
+#endif
+  AGString toString() const;
+};
+
+class AGEXPORT AGCollisionData
+{
+};
+
+class AGRect2;
+
+class AGEXPORT AGTriangle2
+{
+  AGVector2 p[3];
+ public:
+  AGTriangle2(const AGVector2 &amp;v0,const AGVector2 &amp;v1,const AGVector2 &amp;v2);
+
+  AGVector2 operator[](int index) const;
+
+  AGVector2 get(int index) const;
+
+  bool collide(const AGTriangle2 &amp;t) const;
+
+  // FIXME: sweep-based test
+  //  AGCollisionData collide(const AGTriangle &amp;t,const AGVector &amp;v0,const AGVector &amp;v1) const;
+
+  std::vector&lt;AGVector2&gt; getNormals() const;
+
+  void apply(const AGMatrix3 &amp;m);
+  AGTriangle2 applied(const AGMatrix3 &amp;m) const;
+
+  // estimate touching point (or middle of touching area)
+  AGVector2 touchPoint(const AGTriangle2 &amp;t) const;
+  AGVector2 touchVector(const AGTriangle2 &amp;t) const;
+
+  std::vector&lt;AGVector2&gt; collisionPoints(const AGLine2 &amp;l) const;
+
+  bool contains(const AGVector2 &amp;p) const;
+
+  AGRect2 getBBox() const;
+
+  AGLine2 nearestLine(const AGVector2 &amp;v) const;
+
+  std::vector&lt;AGLine2&gt; getLines() const;
+#ifdef SWIG
+  %rename(to_s) toString() const;
+#endif
+  AGString toString() const;
+};
+
+class AGEXPORT AGCircle2
+{
+  AGVector3 p;
+  float radius;
+ public:
+  AGCircle2(const AGVector3 &amp;v,float rad);
+
+  bool inCircle(const AGTriangle2 &amp;t) const;
+  bool outCircle(const AGTriangle2 &amp;t) const;
+  bool inCircle(const AGVector3 &amp;v) const;
+  bool outCircle(const AGVector3 &amp;v) const;
+
+  AGVector3 getPos() const;
+  float getRadius() const;
+
+};
+
+class AGVector4;
+class AGEXPORT AGTriangle3
+{
+  AGVector3 p[3];
+ public:
+  AGTriangle3(const AGVector3 &amp;v0,const AGVector3 &amp;v1,const AGVector3 &amp;v2);
+  
+  // (x,y,z,0) for no collision 
+  // (x,y,z,1) for collision in point (x,y,z)
+  AGVector4 collide(const AGLine3 &amp;pLine) const;
+
+  AGString toString() const;
+
+  AGVector3 operator[](int index) const;
+};
+
+class AGEXPORT AGRect2
+{
+  AGVector2 v0,v1;
+ public:
+  AGRect2();
+  AGRect2(const AGVector2 &amp;pv0,const AGVector2 &amp;pv1);
+  AGRect2(float x,float y,float w,float h);
+  AGRect2(const AGString &amp;ps);
+  AGRect2(const SDL_Rect &amp;r);
+
+  bool collide(const AGRect2 &amp;r) const;
+
+  void include(const AGVector2 &amp;v);
+
+  AGRect2 operator+(const AGVector2 &amp;v) const;
+  AGRect2 &amp;operator+=(const AGVector2 &amp;v);
+  AGRect2 &amp;operator-=(const AGVector2 &amp;v);
+
+  AGRect2&amp; operator+=(const AGRect2 &amp;r);
+
+  bool contains(const AGVector2 &amp;v) const;
+  bool contains(const AGRect2 &amp;v) const;
+
+  std::list&lt;AGRect2&gt; split() const;
+
+  AGVector2 operator[](size_t i) const;
+  AGVector2 &amp;operator[](size_t i);
+
+  AGVector2 getV0() const;
+  AGVector2 getV1() const;
+  AGVector2 getV01() const;
+  AGVector2 getV10() const;
+
+  AGRect2 shrink(float f) const;
+  AGRect2 grow(float f) const;
+
+  void setX(float p);
+  void setY(float p);
+
+  void setLeft(float p); // attention - modifies right, too
+  void setTop(float p);  // attention - modifies bottom, too
+
+  void setRight(float p);
+  void setBottom(float p);
+
+  float setWidth(float w);
+  float setHeight(float w);
+
+  float x() const;
+  float y() const;
+  float w() const;
+  float h() const;
+
+  float width() const;
+  float height() const;
+
+  float x0() const;
+  float y0() const;
+  float x1() const;
+  float y1() const;
+
+  AGRect2 origin() const;
+
+  AGRect2 intersect(const AGRect2 &amp;r) const;
+
+  //result=this-r
+  std::vector&lt;AGRect2&gt; difference(const AGRect2 &amp;r) const;
+
+  SDL_Rect sdl() const;
+
+  bool operator==(const AGRect2 &amp;r) const;
+  bool operator!=(const AGRect2 &amp;r) const;
+
+  void check() const;
+
+  AGRect2 alignGrid() const; // align to integer grid
+
+  float content() const;
+
+#ifdef SWIG
+  %rename(to_s) toString() const;
+#endif
+  AGString toString() const;
+};
+
+
+class AGEXPORT AGVector4
+{
+ public:
+  float v[4];
+
+  AGVector4(float pX,float pY,float pZ,float pW=1.0f);
+  AGVector4(const AGVector4 &amp;a);
+  AGVector4(const AGVector3 &amp;a,float h);
+  AGVector4();
+
+  void setX(float pX);
+  void setY(float pY);
+  void setZ(float pZ);
+  void setW(float pW);
+
+  
+#ifdef SWIG
+  %rename(x) getX() const;
+  %rename(y) getY() const;
+  %rename(z) getZ() const;
+  %rename(w) getW() const;
+#endif
+  float getX() const;
+  float getY() const;
+  float getZ() const;
+  float getW() const;
+
+  AGVector4 operator-(const AGVector4 &amp;p) const;
+  AGVector4 operator+(const AGVector4 &amp;p) const;
+#ifdef SWIG
+%rename(add) operator+=(const AGVector4 &amp;p);
+%rename(sub) operator-=(const AGVector4 &amp;p);
+#endif
+  AGVector4 &amp;operator+=(const AGVector4 &amp;p);
+  AGVector4 &amp;operator-=(const AGVector4 &amp;p);
+
+  float operator*(const AGVector4 &amp;p) const;
+  AGVector4 &amp;operator*=(float f);
+  AGVector4 &amp;operator/=(float f);
+  AGVector4 operator*(float f) const;
+  AGVector4 operator/(float f) const;
+  AGVector4 operator-() const;
+
+  bool operator==(const AGVector4 &amp;a) const;
+  bool operator!=(const AGVector4 &amp;a) const;
+
+  float length() const;
+  // length^2
+  float length2() const;
+
+  // length 3-dim vector
+  float length3() const;
+
+
+  AGVector4 normalized() const;
+  void normalize();
+
+  // 3-dimensional
+  AGVector4 normalized3() const;
+  void normalize3();
+
+
+  float operator[](int index) const;
+  float &amp;operator[](int index);
+
+  bool nonZero() const;
+
+  // vector-cross-product
+  // ignores 4th coordinate
+  AGVector4 operator%(const AGVector4 &amp;a) const;
+  AGVector4 cross(const AGVector4 &amp;a) const
+  {
+    return operator%(a);
+  }
+
+
+  AGVector3 dim3() const;
+  AGVector2 dim2() const;
+
+#ifdef SWIG
+  %rename(to_s) toString() const;
+#endif
+  AGString toString() const;
+
+#ifndef SWIG
+  (operator float*)();
+  (operator const float*)() const;
+#endif
+};
+
+class AGEXPORT AGMatrix4
+{
+  float a[16];
+ public:
+  struct MRow
+  {
+    AGMatrix4 *matrix;
+    int y;
+
+    float &amp;operator[](size_t x)
+    {
+      return matrix-&gt;get(x,y);
+    }
+    float operator[](size_t x) const
+    {
+      return matrix-&gt;get(x,y);
+    }
+  };
+
+  AGMatrix4();
+  AGMatrix4(float v[16]);
+  AGMatrix4(float angle,const AGVector3 &amp;d);
+  // FIXME: add quaternion
+  //  AGMatrix4(const AGAngle &amp;a);
+  AGMatrix4(const AGVector4 &amp;a);
+  void set(size_t x,size_t y,float f);
+  float get(size_t x,size_t y) const;
+  float &amp;get(size_t x,size_t y);
+
+  AGMatrix4 operator*(const AGMatrix4 &amp;m) const;
+  AGMatrix4 &amp;operator*=(const AGMatrix4 &amp;m);
+  AGMatrix4 &amp;operator+=(const AGMatrix4 &amp;m);
+
+  AGMatrix3 get3x3(size_t x,size_t y) const;
+
+  AGVector4 operator*(const AGVector4 &amp;v) const;
+
+  float operator()(size_t x,size_t y) const;
+  float &amp;operator()(size_t x,size_t y);
+
+  AGMatrix4 inverted() const;
+  AGMatrix4 transposed() const;
+
+  MRow operator[](size_t y);
+  //  const Row operator[](size_t y) const;
+
+  void swapRows(size_t a,size_t b);
+  void swapCols(size_t a,size_t b);
+
+#ifdef SWIG
+  %rename(to_s) toString() const;
+#endif
+  AGString toString() const;
+
+#ifndef SWIG
+  (operator float*)();
+  (operator const float*)() const;
+  //  (operator const double*)() const;
+#endif
+
+  AGVector4 getRow(size_t i) const;
+};
+
+// axis-aligned
+class AGEXPORT AGRect3
+{
+  AGVector3 base,dir;
+ public:
+  AGRect3(const AGVector3 &amp;pBase,const AGVector3 &amp;pDir);
+
+  bool collides(const AGLine3&amp;pLine) const;
+
+  AGString toString() const;
+};
+
+// axis-aligned
+class AGEXPORT AGBox3
+{
+ public:
+  AGVector3 base,dir;
+
+  AGBox3();
+  AGBox3(const AGVector3 &amp;pBase,const AGVector3 &amp;pDir);
+
+  void include(const AGVector3&amp;p);
+  bool includes(const AGBox3 &amp;b);
+  bool collides(const AGVector3&amp;p) const;
+
+  bool collides(const AGLine3&amp;p) const;
+  bool collides(const AGBox3 &amp;b) const;
+
+  bool contains(const AGTriangle3 &amp;t) const;
+
+  std::vector&lt;AGRect3&gt; getSides() const;
+
+  AGString toString() const;
+
+  std::vector&lt;AGBox3&gt; split() const;
+
+  bool collides(const AGMatrix4 &amp;frustum) const;
+
+  std::vector&lt;AGVector3&gt; getVertices() const;
+  void calcVertices(std::vector&lt;AGVector3&gt; &amp;vs) const;
+
+  AGBox3 operator+(const AGVector3 &amp;v) const;
+  AGBox3 operator-(const AGVector3 &amp;v) const;
+
+  bool valid() const;
+
+ private:
+  bool mValid;
+};
+
+AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGVector2&amp;v);
+AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGVector3&amp;v);
+AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGVector4&amp;v);
+AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGRect2&amp;v);
+AGEXPORT std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const AGBox3&amp;v);
+
+#include &quot;ag_geometry_inline.cc&quot;
+
+#include &lt;ag_serial_vec.h&gt;
+
+#endif

Added: antargis/branches/rant/ext/basic/ag_video_base.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_video_base.cc	2007-07-16 18:48:58 UTC (rev 1145)
+++ antargis/branches/rant/ext/basic/ag_video_base.cc	2007-07-21 07:44:39 UTC (rev 1146)
@@ -0,0 +1,26 @@
+#include &lt;ag_video_base.h&gt;
+
+AGVideoBase::~AGVideoBase()
+{
+}
+
+
+int AGVideoBase::width() const
+{
+    return 1;
+}
+
+int AGVideoBase::height() const
+{
+    return 1;
+}
+
+int AGVideoBase::realWidth() const
+{
+    return 1;
+}
+int AGVideoBase::realHeight() const
+{
+    return 1;
+}
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000102.html">[Antargis-svn] r1145 - in contrib: . binary oldsources
</A></li>
	<LI>Next message: <A HREF="000104.html">[Antargis-svn] r1147 - in antargis/branches/rant: . build/configs	ext/3dengine ext/basic ext/external ext/game ext/gui ext/math	ext/sound ext/video
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#103">[ date ]</a>
              <a href="thread.html#103">[ thread ]</a>
              <a href="subject.html#103">[ subject ]</a>
              <a href="author.html#103">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/antargis-svn">More information about the Antargis-svn
mailing list</a><br>
</body></html>
