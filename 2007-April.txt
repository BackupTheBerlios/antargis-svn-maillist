From davidkamphausen at mail.berlios.de  Tue Apr  3 21:07:10 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Tue, 3 Apr 2007 21:07:10 +0200
Subject: [Antargis-svn] r1070 - in antargis/trunk: . data/levels/tutorial
	ruby src
Message-ID: <200704031907.l33J7AFs004543@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-04-03 21:07:09 +0200 (Tue, 03 Apr 2007)
New Revision: 1070

Modified:
   antargis/trunk/TODO
   antargis/trunk/data/levels/tutorial/tutorial2.antlvl
   antargis/trunk/data/levels/tutorial/tutorial2.rb
   antargis/trunk/ruby/ant_buildjob.rb
   antargis/trunk/ruby/ant_hero.rb
   antargis/trunk/ruby/ant_hljob_base.rb
   antargis/trunk/ruby/ant_hljob_states.rb
   antargis/trunk/ruby/ant_hljobs.rb
   antargis/trunk/ruby/map.rb
   antargis/trunk/src/height_map.cc
   antargis/trunk/src/map.cc
   antargis/trunk/src/map.h
Log:
* next try for 0.2-release


Modified: antargis/trunk/TODO
===================================================================
--- antargis/trunk/TODO	2007-03-26 19:28:15 UTC (rev 1069)
+++ antargis/trunk/TODO	2007-04-03 19:07:09 UTC (rev 1070)
@@ -1,5 +1,6 @@
+* check if reachable before fetching !!! (in house) - or even better use heuristic for estimating distance in getNear(...)
+* saving of new hljobs
 * Translation tut3
-* Fighting tut2 - problems men belong to more than one buildign ???
 * fix jobs some more
 * what's wrong with pathfinding-test ???
 

Modified: antargis/trunk/data/levels/tutorial/tutorial2.antlvl
===================================================================
--- antargis/trunk/data/levels/tutorial/tutorial2.antlvl	2007-03-26 19:28:15 UTC (rev 1069)
+++ antargis/trunk/data/levels/tutorial/tutorial2.antlvl	2007-04-03 19:07:09 UTC (rev 1070)
@@ -3,7 +3,7 @@
     <position x="59.2397" y="71.2682" z="1.5455"/>
     <resource wood="100" stone="100" food="200"/>
   </antTower>
-  <antWorkshop aggression="1" birthday="0.0" energy="1" food="1" healSpeed="0.1" id="0" mode="" morale="1" name="0.737592943267599" onGround="true" men="1">
+  <antWorkshop aggression="1" birthday="0.0" energy="1" food="1" healSpeed="0.1" id="0" mode="" morale="1" name="0.737592943267599" onGround="true" men="1" village="small Village">
     <position x="42.8217" y="21.9856" z="1.96389"/>
     <resource/>
   </antWorkshop>

Modified: antargis/trunk/data/levels/tutorial/tutorial2.rb
===================================================================
--- antargis/trunk/data/levels/tutorial/tutorial2.rb	2007-03-26 19:28:15 UTC (rev 1069)
+++ antargis/trunk/data/levels/tutorial/tutorial2.rb	2007-04-03 19:07:09 UTC (rev 1070)
@@ -14,15 +14,15 @@
 		if hero.getName!="Rowen"
 			return
 		end
-		if job.class==AntHeroFightJob
-			if job.target.class==AntWorkshop
+		if job.is_a?(AntHeroFightJob)
+			if job.target.is_a?(AntWorkshop)
 				@defeat=true
 				start=StoryFlow.new("sheep")
 				start.push("Tutorial","Press the construct button. But beware that your men do rest enough.")
 				start.push("Tutorial","When you have enough weopons and armour you can take it all up by pressing the 'take weapon' button.")
 				tellStory(start)
 			else
-				if hero.getPlayer==getMap.getPlayer
+				if hero.getName=="Rowen"
 					wonLevel
 				else
 					lostLevel

Modified: antargis/trunk/ruby/ant_buildjob.rb
===================================================================
--- antargis/trunk/ruby/ant_buildjob.rb	2007-03-26 19:28:15 UTC (rev 1069)
+++ antargis/trunk/ruby/ant_buildjob.rb	2007-04-03 19:07:09 UTC (rev 1070)
@@ -1,4 +1,6 @@
 class AntHeroBuildJob<AntHeroMoveJob
+	FARTHEST_AWAY=40
+
 	attr_reader :finished
 	def initialize(hero,targetpos,building)
 
@@ -51,7 +53,7 @@
 						puts "resource not found! #{res}"
 						man.newRestJob(5)
 					else
-						if (nearest.getPos2D- at target.getPos2D).length<20
+						if (nearest.getPos2D- at target.getPos2D).length<FARTHEST_AWAY
 							man.newMoveJob(0,nearest.getPos2D,0.5) # near but not actually there
 							man.setMode("harvest")
 						else

Modified: antargis/trunk/ruby/ant_hero.rb
===================================================================
--- antargis/trunk/ruby/ant_hero.rb	2007-03-26 19:28:15 UTC (rev 1069)
+++ antargis/trunk/ruby/ant_hero.rb	2007-04-03 19:07:09 UTC (rev 1070)
@@ -101,6 +101,7 @@
 	end
 	
 	def newHLRestJob(time)
+		@job.stopJob if @job
 		@job=nil
 		setFire(true)
 		super(time)
@@ -125,40 +126,49 @@
 	
 	
 	def newHLMoveJob(prio,pos,dist)
+		@job.stopJob if @job
 		@job=AntHeroMoveJob.new(self,prio,pos,dist)
 		assignJob2All
 	end
 	def newHLRecruitJob(target)
+		@job.stopJob if @job
 		@job=AntHeroRecruitJob.new(self,target)
 		assignJob2All
 	end
 	def newHLConstructJob(target)
+		@job.stopJob if @job
 		@job=AntHeroConstructJob.new(self,target)
 		assignJob2All
 	end
 	def newHLTakeFoodJob(target)
+		@job.stopJob if @job
 		puts "take food job #{self} #{target}"
 		@job=AntHeroTakeJob.new(self,target,"food")
 		assignJob2All
 	end
 	def newHLTakeWeaponJob(target)
+		@job.stopJob if @job
 		@job=AntHeroTakeJob.new(self,target,"weapon")
 		assignJob2All
 	end
 	def newHLFightJob(target)
+		@job.stopJob if @job
 		@job=AntHeroFightJob.new(self,target)
 		assignJob2All
 	end
 	def newHLFightAnimalJob(target)
+		@job.stopJob if @job
 		@job=AntHeroFightAnimalJob.new(self,target)
 		assignJob2All
 	end
 	def newHLBuildJob(pos,type)
+		@job.stopJob if @job
 		@job=AntHeroBuildJob.new(self,pos,type)
 		assignJob2All
 	end
 	
 	def newHLDismissJob()
+		@job.stopJob if @job
 		@job=nil
 		agg=getAggression
 		men=@men.select{|m|not m.is_a?(AntHero)} # exclude hero

Modified: antargis/trunk/ruby/ant_hljob_base.rb
===================================================================
--- antargis/trunk/ruby/ant_hljob_base.rb	2007-03-26 19:28:15 UTC (rev 1069)
+++ antargis/trunk/ruby/ant_hljob_base.rb	2007-04-03 19:07:09 UTC (rev 1070)
@@ -1,5 +1,5 @@
 class AntNewHLJob
-	attr_reader :finished
+	attr_reader :finished, :stopped
 	# some magic here
 	def initialize(hero)
 		@hero=hero
@@ -22,6 +22,13 @@
 		@hero
 	end
 
+	def stopJob
+		@stopped=true
+		if @state
+			call(@state,"leave")
+		end
+	end
+
 	def check(man)
 		return if @state.nil?
 		call2(@state,"assign",man)
@@ -57,7 +64,7 @@
 
 	def call(state,event)
 		m=methodName(state,event)
-		print "CALL #{state} #{event} #{m}  #{getTime} -- "
+		print "CALL #{hero.getName} #{state} #{event} #{m}  #{getTime} -- "
 		if self.class.method_defined?(m)
 			v=send(m)
 			puts v
@@ -73,7 +80,7 @@
 
 	def call2(state,event,man)
 		m=methodName(state,event)
-		print "CALL2 #{state} #{event} #{m} #{man} #{getTime} -- "
+		print "CALL2 #{hero.getName} #{state} #{event} #{m} #{man} #{getTime} -- "
 		if self.class.method_defined?(m)
 			v=send(m,man)
 			puts v

Modified: antargis/trunk/ruby/ant_hljob_states.rb
===================================================================
--- antargis/trunk/ruby/ant_hljob_states.rb	2007-03-26 19:28:15 UTC (rev 1069)
+++ antargis/trunk/ruby/ant_hljob_states.rb	2007-04-03 19:07:09 UTC (rev 1070)
@@ -215,15 +215,18 @@
 module HLJob_GetResource
 	# needed: resources return array of resource-strings
 	def getResource_enter
-		allMen.each{|man|
-			resources.each{|r|
-				a=target.resource.get(r)
-				if a>1
-					man.resource.add(r,1)
-					target.resource.sub(r,1)
-				end
+		for i in 1..hero.getAggression
+			allMen.each{|man|
+				resources.each{|r|
+					a=target.resource.get(r)
+					if a>1
+						man.resource.add(r,1)
+						target.resource.sub(r,1)
+					end
+				}
 			}
-		}
+		end
+		allMen.each{|m|m.resourceChanged}
 	end
 	def getResource_ready
 		return true
@@ -234,6 +237,7 @@
 	def killAnimal_enter
 		target.eventDie
 		hero.resource.takeAll(target.resource)
+		allMen.each{|m|m.resourceChanged}
 	end
 end
 
@@ -311,6 +315,8 @@
 		for i in 1..food
 			allMen[i-1].resource.add("food",1)
 		end
+
+		allMen.each{|m|m.resourceChanged}
 	end
 	
 end
@@ -329,12 +335,14 @@
 		reshuffle
 	end
 
+	# this called if (and only if) the hero has won or is fleeing (and thus aborting the fight)
 	def remove(fightJob)
 		@parties[fightJob.fightType].delete(fightJob)
 		@oldparties[fightJob.fightType].delete(fightJob)
 		reshuffle
 	end
 
+	# this called if (and only if) the hero has lost
 	def removeLost(fightJob)
 		@parties[fightJob.fightType].delete(fightJob)
 		reshuffle
@@ -369,25 +377,6 @@
 		end
 	end
 
-# 	def eventWon(whichType)
-# 		trace
-# 		
-# 
-# 		# FIXME: should be parted !!!
-# 		owners=@oldparties[whichType].collect{|j|j.hero}
-# 		i=0
-# 		puts "whichType:#{whichType}"
-# 		assert{owners.length>0}
-# 		@oldparties[otherType(whichType)].each{|p|
-# 			newOwner=owners[i]
-# 			p.hero.setOwner(newOwner)
-# 			i+=1
-# 			i%=owners.length
-# 		}
-# 	end
-# 	def eventLost(type)
-# 		eventWon(otherType(type))
-# 	end
 	private
 
 	def otherType(my)
@@ -398,11 +387,14 @@
 		# reinit and assign
 
 		menGroup={}
+		leave=false
 		@parties.each{|type,jobs|
 			puts "parties: #{type}:#{jobs}"
 			menGroup[type]=jobs.collect{|job|job.undefeatedMen}.flatten.uniq
-			return if @inited and menGroup[type].length==0 # a fightjob is leaving
+			menGroup[type].each{|man|man.delJob}
+			leave=true if @inited and menGroup[type].length==0 # a fightjob is leaving
 		}
+		return if leave
 	
 		# check that each group has more than 0 members
 		assert{menGroup.select{|k,v|v.length==0}.length==0}
@@ -456,7 +448,6 @@
 			puts "NOT YET INITED #{self} hero:#{hero} target:#{target}"
 			target.newHLDefendJob(hero)
 		end
-		#@fightData.init
 		assignAllJobs
 	end
 
@@ -556,7 +547,15 @@
 			man.hlJobMode[:fighting]=true
 		}
 	end
+end
 
-
+module HLJob_Recruit
+	def recruit_enter
+	end
+	
+	private
+	def recruitGetMen
+		
+	end
 end
 

Modified: antargis/trunk/ruby/ant_hljobs.rb
===================================================================
--- antargis/trunk/ruby/ant_hljobs.rb	2007-03-26 19:28:15 UTC (rev 1069)
+++ antargis/trunk/ruby/ant_hljobs.rb	2007-04-03 19:07:09 UTC (rev 1070)
@@ -41,6 +41,9 @@
 	def xmlName
 		self.class.to_s
 	end
+	def stopJob
+	end
+
 	def saveXML(n)
 		puts "SAVEXML"
 		puts self

Modified: antargis/trunk/ruby/map.rb
===================================================================
--- antargis/trunk/ruby/map.rb	2007-03-26 19:28:15 UTC (rev 1069)
+++ antargis/trunk/ruby/map.rb	2007-04-03 19:07:09 UTC (rev 1070)
@@ -44,13 +44,7 @@
 end
 
 
-# class MyHeuristicFunction<HeuristicFunction
-# 	def distance(a,b)
-# 		(b-a).length*1.4
-# 	end
-# end
 
-
 # AntRubyMap is not only the "map", but manages the moving and the actions of all the
 # entities around. Apart from that it contains the Players. So it might be better to call it "World"
 class AntRubyMap<AntMap
@@ -333,7 +327,9 @@
 		@heuristic=computeHeuristic(@dgraph)
 		#exit
 
-		#@mheuristic=MyHeuristicFunction.new
+		# FIXME: readd this when heuristics are better!!!
+		#setHeuristic(@heuristic)
+
 		@path=Pathfinder.new(@dgraph, at heuristic)
 
 

Modified: antargis/trunk/src/height_map.cc
===================================================================
--- antargis/trunk/src/height_map.cc	2007-03-26 19:28:15 UTC (rev 1069)
+++ antargis/trunk/src/height_map.cc	2007-04-03 19:07:09 UTC (rev 1070)
@@ -458,14 +458,14 @@
 
 AGVector2 HeightMap::truncPos(const AGVector2 &p) const
 {
-  AGVector2 maxPos(mW+1,mH+1);
+  AGVector2 maxPos(mW+0.5,mH+0.5);
   return AGVector2(std::max(0.0f,std::min(maxPos[0],p[0])),
 		   std::max(0.0f,std::min(maxPos[1],p[1])));
 }
 
 AGVector3 HeightMap::truncPos(const AGVector3 &p) const
 {
-  AGVector2 maxPos(mW+1,mH+1);
+  AGVector2 maxPos(mW+0.5,mH+0.5);
   return AGVector3(std::max(0.0f,std::min(maxPos[0],p[0])),
 		   std::max(0.0f,std::min(maxPos[1],p[1])),
 		   p[2]);

Modified: antargis/trunk/src/map.cc
===================================================================
--- antargis/trunk/src/map.cc	2007-03-26 19:28:15 UTC (rev 1069)
+++ antargis/trunk/src/map.cc	2007-04-03 19:07:09 UTC (rev 1070)
@@ -46,7 +46,8 @@
 
 AntMap::AntMap(Scene *pScene,int w,int h):
   HeightMap(pScene,w,h),
-  mEntQuad(new QuadTree<AntEntity>(AGRect2(0,0,w,h)))
+  mEntQuad(new QuadTree<AntEntity>(AGRect2(0,0,w,h))),
+  mHeuristicFunction(0)
 {
   myAntargisMap=this;
   maxID=0;
@@ -233,6 +234,8 @@
 
 std::vector<AntEntityPtr> AntMap::getNextList(AntEntity *me,const AGString &pType,size_t atLeast)
 {
+  //  assert(mHeuristicFunction);
+
   // FIXME: optimize this - use quadtree
 
   std::multimap<float,AntEntity*> ents;
@@ -247,8 +250,14 @@
         {
           if((*i)->provides(pType) && (*i)->resource.get(pType)>=atLeast)
             {
+	      /*
               AGVector2 p2=(*i)->getPos2D()-p;
-              float norm=p2.length2();
+              float norm=p2.length2();*/
+	      float norm;
+	      if(mHeuristicFunction)
+		norm=(*mHeuristicFunction)(std::make_pair((*i)->getPos2D(),p));
+	      else
+		norm=((*i)->getPos2D()-p).length2();
               ents.insert(std::make_pair(norm,*i));
             }
         }
@@ -275,6 +284,7 @@
 
 AntEntity *AntMap::getNext(AntEntity *me,const AGString &pType,size_t atLeast)
 {
+  //  assert(mHeuristicFunction);
   // FIXME: optimize this - use quadtree
 
   std::multimap<float,AntEntity*> ents;
@@ -290,8 +300,15 @@
         {
           if((*i)->provides(pType) && (*i)->resource.get(pType)>=atLeast)
             {
-              AGVector2 p2=(*i)->getPos2D()-p;
-              float norm=p2.length2();
+	      //              AGVector2 p2=(*i)->getPos2D()-p;
+	      float norm;
+
+	      if(mHeuristicFunction)
+	        norm=(*mHeuristicFunction)(std::make_pair((*i)->getPos2D(),p));
+	      else
+		norm=((*i)->getPos2D()-p).length2();
+	      cdebug("norm:"<<norm<<" i:"<<*i<<" name:"<<(*i)->getName());
+	      //              float norm=p2.length2();
               ents.insert(std::make_pair(norm,*i));
             }
         }
@@ -319,6 +336,13 @@
 
   return e;
 }
+
+void AntMap::setHeuristic(HeuristicFunction *pFunction)
+{
+  mHeuristicFunction=pFunction;
+}
+
+
 AntEntity *AntMap::getByName(const AGString &pName)
 {
   EntityList::iterator i=mEntities.begin();

Modified: antargis/trunk/src/map.h
===================================================================
--- antargis/trunk/src/map.h	2007-03-26 19:28:15 UTC (rev 1069)
+++ antargis/trunk/src/map.h	2007-04-03 19:07:09 UTC (rev 1070)
@@ -22,6 +22,7 @@
 #define __MAP_H__
 
 #include "height_map.h"
+#include "heuristic.h"
 
 /**
  * \defgroup GameEngine BoA Game-Engine
@@ -67,6 +68,8 @@
   AntEntity *getNext(AntEntity *me,const AGString &pType,size_t atLeast=0);
   std::vector<AntEntityPtr> getNextList(AntEntity *me,const AGString &pType,size_t atLeast=0);
 
+  void setHeuristic(HeuristicFunction *pFunction);
+
   virtual void processXMLNode(const Node &node);
 
   void saveXML(Node &node) const;
@@ -101,7 +104,9 @@
 
   int maxID;
 
+  HeuristicFunction *mHeuristicFunction;
 
+
 };
 
 AntMap *getMap();



From davidkamphausen at mail.berlios.de  Tue Apr  3 21:08:45 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Tue, 3 Apr 2007 21:08:45 +0200
Subject: [Antargis-svn] r1071 - antargis/tags
Message-ID: <200704031908.l33J8jiF004925@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-04-03 21:08:44 +0200 (Tue, 03 Apr 2007)
New Revision: 1071

Added:
   antargis/tags/0.2-pre_b/
Log:
A    svn+ssh://davidkamphausen at svn.berlios.de/svnroot/repos/antargis/antargis/tags/0.2-pre_b


Copied: antargis/tags/0.2-pre_b (from rev 1070, antargis/trunk)



From davidkamphausen at mail.berlios.de  Mon Apr  9 12:50:23 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Mon, 9 Apr 2007 12:50:23 +0200
Subject: [Antargis-svn] r1072 - in antargis/trunk: . data data/gui/layout
	gui/src ruby src
Message-ID: <200704091050.l39AoN4N004326@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-04-09 12:50:13 +0200 (Mon, 09 Apr 2007)
New Revision: 1072

Added:
   antargis/trunk/ruby/ant_models.rb
   antargis/trunk/src/impostor.cc
   antargis/trunk/src/impostor.h
Modified:
   antargis/trunk/Rakefile
   antargis/trunk/TODO
   antargis/trunk/data/gui/layout/mainmenu.xml
   antargis/trunk/data/theme.xml
   antargis/trunk/gui/src/ag_application.cc
   antargis/trunk/gui/src/ag_glscreen.cc
   antargis/trunk/gui/src/ag_glscreen.h
   antargis/trunk/gui/src/ag_layoutcreators.cc
   antargis/trunk/gui/src/ag_main.cc
   antargis/trunk/gui/src/ag_screen.cc
   antargis/trunk/gui/src/ag_screen.h
   antargis/trunk/gui/src/ag_screenwidget.cc
   antargis/trunk/gui/src/ag_sdlsurface.cc
   antargis/trunk/gui/src/ag_sdlsurface.h
   antargis/trunk/ruby/ant_local.rb
   antargis/trunk/ruby/ant_sack.rb
   antargis/trunk/ruby/ant_tree.rb
   antargis/trunk/ruby/antargislib.rb
   antargis/trunk/ruby/credits.rb
   antargis/trunk/ruby/intro.rb
   antargis/trunk/ruby/mainmenu.rb
   antargis/trunk/src/antargisgui.h
   antargis/trunk/src/nantmarker.hh
   antargis/trunk/src/scene.h
   antargis/trunk/src/vertex_array.cc
   antargis/trunk/src/vertex_array.h
Log:
* some bug-fixes, esp. for windows
* started some things for impostor-implementation
* fixed translations a little


Modified: antargis/trunk/Rakefile
===================================================================
--- antargis/trunk/Rakefile	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/Rakefile	2007-04-09 10:50:13 UTC (rev 1072)
@@ -33,7 +33,7 @@
 
 
 interfaceHeadersSRC=["ant_frustum.h","ant_projection.h","ant_camera.h",
-"scenenode.h","anim_mesh.h","anim_mesh_data.h","ant_app.h","entity.h","entptr.h","glsl.h","height_map.h","map.h","mesh_data.h","mesh.h","mesh_optimizer.h","minimap.h","new_decal.h","ant_renderer.h","resource.h","scene.h","smoke.h","terrain.h","vertex_array.h","water.h","path.h"]
+"scenenode.h","anim_mesh.h","anim_mesh_data.h","ant_app.h","entity.h","entptr.h","glsl.h","height_map.h","map.h","mesh_data.h","mesh.h","mesh_optimizer.h","minimap.h","new_decal.h","ant_renderer.h","resource.h","scene.h","smoke.h","terrain.h","vertex_array.h","water.h","path.h","impostor.h"]
 interfaceHeadersGUI=[
 "ag_rubyobj.h","ag_messageobject.h","ag_serial.h","ag_aes.h","ag_singleton.h",
  "ag_geometry.h","ag_font.h","ag_color.h","ag_local.h","ag_config.h","ag_string.h","ag_string_utf8.h",
@@ -225,7 +225,7 @@
 
 task :clean do
 	msh "rm -rf clean.rb"
-	["src",$GUISRC,"gui/src/plugins","gui/src/sge"].each{|dir|
+	["src",$GUISRC,"gui/src/plugins","gui/src/sge","gui/src/mtwist"].each{|dir|
 		["*.o","*.oo"].each{|ext|
 			msh "rm -rf #{dir}/#{ext}"
 		}

Modified: antargis/trunk/TODO
===================================================================
--- antargis/trunk/TODO	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/TODO	2007-04-09 10:50:13 UTC (rev 1072)
@@ -1,14 +1,11 @@
+* List of project-parts and progress bar
+
 * check if reachable before fetching !!! (in house) - or even better use heuristic for estimating distance in getNear(...)
 * saving of new hljobs
-* Translation tut3
 * fix jobs some more
 * what's wrong with pathfinding-test ???
 
 
-
-
-
-
 ==========
 
 

Modified: antargis/trunk/data/gui/layout/mainmenu.xml
===================================================================
--- antargis/trunk/data/gui/layout/mainmenu.xml	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/data/gui/layout/mainmenu.xml	2007-04-09 10:50:13 UTC (rev 1072)
@@ -1,5 +1,6 @@
 <?xml version="1.0"?>
 <layout name="MainMenu">
+	<!--<screenWidget theme="no"/>-->
 	<table cols="1" rows="4">
 		<colsize col="0" relative="1"/>
 		<rowsize row="0" fixed="200"/>

Modified: antargis/trunk/data/theme.xml
===================================================================
--- antargis/trunk/data/theme.xml	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/data/theme.xml	2007-04-09 10:50:13 UTC (rev 1072)
@@ -191,13 +191,13 @@
 		</background>
 		<font name="font" file="FreeSans.ttf" size="14" color="#000000"/>
 	</edit>
-
+<!--
 	<screen>
 		<background>
 			<image name="image" file="data/gui/bigbg_tile.png"/>
 		</background>
 	</screen>
-	
+	-->
 	<window>
 		<border>
 			<image name="image" file="data/gui/buttontest3.png" file2="win_border.png"/>

Modified: antargis/trunk/gui/src/ag_application.cc
===================================================================
--- antargis/trunk/gui/src/ag_application.cc	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/gui/src/ag_application.cc	2007-04-09 10:50:13 UTC (rev 1072)
@@ -75,6 +75,8 @@
 {
   mainWidget=w;
   setOverlay(0);
+  if(w)
+    w->redraw();
 }
 
 AGWidget *AGApplication::getMainWidget()
@@ -325,6 +327,9 @@
 void AGApplication::redraw()
 {
   pLastDrawn=0;
+
+  if(mainWidget)
+    mainWidget->redraw();
 }
 
 /**

Modified: antargis/trunk/gui/src/ag_glscreen.cc
===================================================================
--- antargis/trunk/gui/src/ag_glscreen.cc	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/gui/src/ag_glscreen.cc	2007-04-09 10:50:13 UTC (rev 1072)
@@ -162,15 +162,19 @@
 { 
 }
 
-AGSurface AGGLScreen::screenshot()
+AGSurface AGGLScreen::screenshot(bool frontBuffer)
 {
   AGSurface s(getWidth(),getHeight());
 
   //  SDL_Surface *surface=s.surface()->surface;
 
   unsigned char *buffer=new unsigned char[getWidth()*getHeight()*4];
-  glReadBuffer(GL_FRONT);
 
+  if(frontBuffer)
+    glReadBuffer(GL_FRONT);
+  else
+    glReadBuffer(GL_BACK);
+
   cdebug(s.surface());
   cdebug(s.surface()->surface);
 

Modified: antargis/trunk/gui/src/ag_glscreen.h
===================================================================
--- antargis/trunk/gui/src/ag_glscreen.h	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/gui/src/ag_glscreen.h	2007-04-09 10:50:13 UTC (rev 1072)
@@ -77,7 +77,7 @@
 
   virtual void begin(); // call before start drawing
 
-  AGSurface screenshot();
+  AGSurface screenshot(bool frontBuffer=true);
 
   void flip();
   bool inScreen(const AGRect2 &r) const;

Modified: antargis/trunk/gui/src/ag_layoutcreators.cc
===================================================================
--- antargis/trunk/gui/src/ag_layoutcreators.cc	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/gui/src/ag_layoutcreators.cc	2007-04-09 10:50:13 UTC (rev 1072)
@@ -12,6 +12,7 @@
 #include <ag_table.h>
 #include <ag_theme.h>
 #include <ag_window.h>
+#include <ag_screenwidget.h>
 
 #include <minimap.h>
 
@@ -494,6 +495,20 @@
 IMPLEMENT_COMPONENT_FACTORY(MiniMap);
 
 
+class AGScreenWidgetLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(ScreenWidget,"screenWidget")
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    CTRACE;
+    setResult(new AGScreenWidget());
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(ScreenWidget);
+
+
 void AGLayout::registerLayouts()
 {
   getLayoutFactory()->addCreator("checkBox",new AGCheckBoxLayoutCreator);
@@ -512,5 +527,6 @@
   getLayoutFactory()->addCreator("radioGroup",new AGRadioGroupLayoutCreator);
   getLayoutFactory()->addCreator("radio",new AGRadioLayoutCreator);
   getLayoutFactory()->addCreator("miniMap",new AGMiniMapLayoutCreator);
+  getLayoutFactory()->addCreator("screenWidget",new AGScreenWidgetLayoutCreator);
 
 }

Modified: antargis/trunk/gui/src/ag_main.cc
===================================================================
--- antargis/trunk/gui/src/ag_main.cc	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/gui/src/ag_main.cc	2007-04-09 10:50:13 UTC (rev 1072)
@@ -176,6 +176,12 @@
   if(mScreen)
     {
       getSurfaceManager()->clear();
+      getSurfaceManager()->clear();
+
+      AGGLScreen *ms=dynamic_cast<AGGLScreen*>(mScreen);
+      if(ms)
+	ms->screenDown();
+
     }
 
   lastGL=gl;
@@ -206,6 +212,8 @@
   if(fs)
     videoFlags|=SDL_FULLSCREEN;
 
+
+
   // set video mode
   SDL_Init(SDL_INIT_VIDEO);
   SDL_Surface *ms=SDL_SetVideoMode(w,h,videoInfo->vfmt->BitsPerPixel,videoFlags);
@@ -219,9 +227,6 @@
 
   if(mScreen)
     {
-      AGGLScreen *ms=dynamic_cast<AGGLScreen*>(mScreen);
-      if(ms)
-	ms->screenDown();
       delete mScreen;
     }
 

Modified: antargis/trunk/gui/src/ag_screen.cc
===================================================================
--- antargis/trunk/gui/src/ag_screen.cc	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/gui/src/ag_screen.cc	2007-04-09 10:50:13 UTC (rev 1072)
@@ -43,7 +43,7 @@
 }
 
 
-AGSurface AGScreen::screenshot()
+AGSurface AGScreen::screenshot(bool frontBuffer)
 {
   cdebug("NOT YET IMPLEMENTED");
   return AGSurface(0,0);

Modified: antargis/trunk/gui/src/ag_screen.h
===================================================================
--- antargis/trunk/gui/src/ag_screen.h	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/gui/src/ag_screen.h	2007-04-09 10:50:13 UTC (rev 1072)
@@ -37,7 +37,7 @@
   virtual size_t getWidth() const;
   virtual size_t getHeight() const;
 
-  virtual AGSurface screenshot();
+  virtual AGSurface screenshot(bool frontBuffer=true);
 };
 
 AGScreen & AGEXPORT getScreen();

Modified: antargis/trunk/gui/src/ag_screenwidget.cc
===================================================================
--- antargis/trunk/gui/src/ag_screenwidget.cc	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/gui/src/ag_screenwidget.cc	2007-04-09 10:50:13 UTC (rev 1072)
@@ -28,7 +28,7 @@
 AGScreenWidget::AGScreenWidget():
   AGWidget(0,getScreen().getRect())
 {
-  mTexture=AGTexture(getTheme()->getSurface("screen.background.image"));
+  //  mTexture=AGTexture(getTheme()->getSurface("screen.background.image"));
 }
 AGScreenWidget::~AGScreenWidget()
 {
@@ -37,5 +37,6 @@
 void AGScreenWidget::draw(AGPainter &p)
 {
   //  p.clip(AGRect2(10,10,50,50));
-  p.tile(mTexture);
+  //p.tile(mTexture);
+  p.fillRect(p.getRect().origin(),AGColor(0,0,0));
 }

Modified: antargis/trunk/gui/src/ag_sdlsurface.cc
===================================================================
--- antargis/trunk/gui/src/ag_sdlsurface.cc	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/gui/src/ag_sdlsurface.cc	2007-04-09 10:50:13 UTC (rev 1072)
@@ -48,9 +48,20 @@
 
 void AGSDLScreen::fillRect(const AGRect2 &pRect,const AGColor &c)
 {
-  for(int x=(int)pRect.x0();x<(int)pRect.x1();x++)
-    for(int y=(int)pRect.y0();y<(int)pRect.y1();y++)
-      putPixel(x,y,c);
+  if(c.a<0xFF)
+    {
+      for(int x=(int)pRect.x0();x<(int)pRect.x1();x++)
+	for(int y=(int)pRect.y0();y<(int)pRect.y1();y++)
+	  {
+	    putPixel(x,y,c);
+	  }
+    }
+  else
+    {
+      for(int x=(int)pRect.x0();x<(int)pRect.x1();x++)
+	for(int y=(int)pRect.y0();y<(int)pRect.y1();y++)
+	  putPixel(x,y,c);
+    }
   return;
   sge_FilledRectAlpha(s,
 		      (int)pRect.x(),
@@ -212,7 +223,7 @@
   SDL_SetClipRect(s,&sr);
 }
 
-AGSurface AGSDLScreen::screenshot()
+AGSurface AGSDLScreen::screenshot(bool frontBuffer)
 {
   AGInternalSurface *surface=new AGInternalSurface;
   surface->surface=s;

Modified: antargis/trunk/gui/src/ag_sdlsurface.h
===================================================================
--- antargis/trunk/gui/src/ag_sdlsurface.h	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/gui/src/ag_sdlsurface.h	2007-04-09 10:50:13 UTC (rev 1072)
@@ -58,7 +58,7 @@
   virtual void clip(const AGRect2 &r);
   virtual void unclip();
 
-  AGSurface screenshot();
+  AGSurface screenshot(bool frontBuffer=true);
 
  private:
   SDL_Surface *s;

Modified: antargis/trunk/ruby/ant_local.rb
===================================================================
--- antargis/trunk/ruby/ant_local.rb	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/ruby/ant_local.rb	2007-04-09 10:50:13 UTC (rev 1072)
@@ -52,6 +52,7 @@
 		read
 	end
 	def process(x)
+		x=x.gsub("\n","\\n")
 		r=myprocess(x)
 		#puts "TRANSLATE: #{x} #{r.class}"
 		return r

Added: antargis/trunk/ruby/ant_models.rb
===================================================================
--- antargis/trunk/ruby/ant_models.rb	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/ruby/ant_models.rb	2007-04-09 10:50:13 UTC (rev 1072)
@@ -0,0 +1,100 @@
+
+$useImpostors=false
+
+def getStaticModelRotation(name)
+	rot={
+	}
+
+	if rot.member?(name)
+		return rot[name]
+	end
+	return 0
+end
+
+def getStaticModelScaling(name)
+	scales={
+		"sack"=>0.3,
+		"stub"=>0.04,
+	}
+
+	if scales.member?(name)
+		return scales[name]
+	end
+	return 1
+end
+
+def createModel(entityType,subType=nil,angle=nil)
+	mesh=nil
+
+	animMeshes={
+		:man=>{
+			["wood"]=>"data/models/man_e_wood.anim",
+			["stone","flour","corn"]=>"data/models/man_e_stones.anim",
+			["walk","sitdown","sit"]=>"data/models/man_e_walk.anim",
+			["fight_dagger"]=>"data/models/man_e_dagger.anim",
+			["fight_shield"]=>"data/models/man_e_shield.anim",
+			["fight_sword"]=>"data/models/man_e_sword.anim",
+			["fight_bow"]=>"data/models/man_e_bow.anim"
+		},
+		:sack=>{
+			[]=>"sack"
+		},
+		:tree=>{
+			["stub"]=>"stub",
+			[0]=>["data/models/fir2.ant2",0.45,"data/textures/models/fir5.png",false],
+			[1]=>["data/models/fir2.ant2",0.45,"data/textures/models/fir7.png",false],
+			[2]=>["data/models/tree5.ant2",0.45,"data/textures/models/tree3.png",false],
+			[3]=>["data/models/tree5.ant2",0.45,"data/textures/models/tree5.png",false],
+			[4]=>["data/models/tree5.ant2",0.45,"data/textures/models/tree9.png",false],
+			[5]=>["data/models/tree6.ant2",0.45,"data/textures/models/tree5.png",false],
+			[6]=>["data/models/tree5.ant2",0.45,"data/textures/models/tree10.png",false],
+			[7]=>["data/models/tree_simple1.ant2",0.3,"data/textures/models/tree_simple1.png"],
+			[8]=>["data/models/tree_simple2.ant2",0.3,"data/textures/models/tree_simple1.png"],
+			[9]=>["data/models/tree_simple5.ant2",0.3,"data/textures/models/tree_simple5.png"]
+		}
+
+	}
+
+	map=animMeshes[entityType]
+
+	map.each{|k,v|
+		if k.member?(subType) or k.length==0
+			mesh=v
+		end
+	}
+	scenenode=nil
+	if mesh
+		if mesh.is_a?(Array)
+			ant2name=mesh[0]
+			scale=mesh[1]
+			pngname=mesh[2]
+			culling=true
+			if mesh.length>3
+				culling=mesh[3]
+			end
+			data=getMeshData(ant2name,scale,pngname)
+			data.setCulling(culling)
+			data.setTransparent(true)
+			angle||=getStaticModelRotation(name)
+			scenenode=Mesh.new(getMap.getScene,data,AGVector4.new(0,0,0),angle)
+					
+		elsif mesh=~/anim$/
+			scenenode=AnimMesh.new(getMap.getScene,getAnimMeshData(mesh))
+		else
+			ant2name="data/models/"+mesh+".ant2"
+			pngname="data/textures/models/"+mesh+".png"
+			name=mesh
+			angle||=getStaticModelRotation(name)
+			scenenode=Mesh.new(getMap.getScene,getMeshData(ant2name,getStaticModelScaling(name),pngname),AGVector4.new(0,0,0),angle)
+		end
+	end
+
+	if $useImpostors
+		# FIXME:replace by impostor
+		if entityType!=:sack
+			return createModel(:sack)
+		end
+	end
+
+	return scenenode
+end
\ No newline at end of file

Modified: antargis/trunk/ruby/ant_sack.rb
===================================================================
--- antargis/trunk/ruby/ant_sack.rb	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/ruby/ant_sack.rb	2007-04-09 10:50:13 UTC (rev 1072)
@@ -1,10 +1,9 @@
+require 'ant_models.rb'
+
 class AntSack<AntAnimal
 	def initialize(p=AGVector2.new(0,0))
 		super
-		mp=AGVector3.new(0,0,0)
-		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/sack.ant2",0.3,"data/textures/models/sack.png"),AGVector4.new(0,0,0),0)
-		setMesh(mesh)
-		#setPos(AGVector2.new(p.x,p.y))
+		setMesh(createModel(:sack))
 		@enabled=true
 		@storeGood=["food","tool","corn","stone","wood"]
 	end

Modified: antargis/trunk/ruby/ant_tree.rb
===================================================================
--- antargis/trunk/ruby/ant_tree.rb	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/ruby/ant_tree.rb	2007-04-09 10:50:13 UTC (rev 1072)
@@ -108,7 +108,12 @@
 	
 	private
 	def setupMesh
-		setMesh(Mesh.new(getMap.getScene,getTreeMeshByType(@typeID),AGVector4.new(0,0,0,0), at angle))
+		#setMesh(Mesh.new(getMap.getScene,getTreeMeshByType(@typeID),AGVector4.new(0,0,0,0), at angle))
+		typeId="stub"
+		if @typeID>=0
+			typeId=@typeID%10
+		end
+		setMesh(createModel(:tree,typeId, at angle))
 	end
 
 	# an old function for display apples - this is too costly

Modified: antargis/trunk/ruby/antargislib.rb
===================================================================
--- antargis/trunk/ruby/antargislib.rb	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/ruby/antargislib.rb	2007-04-09 10:50:13 UTC (rev 1072)
@@ -100,6 +100,7 @@
 		@@antargislibinited=true
 		@@fullscreen=false
 		@@antProfiling=false
+		@@opengl=true
 
 		setDebugLevel(1000)
 	
@@ -131,6 +132,8 @@
 					when /debug-level/
 						level=a.split("=")[1].to_i
 						setDebugLevel(level)
+					when "nogl"
+						@@opengl=false
 					when "demo"
 						$demoMode=true
 					when "gui-test"
@@ -157,6 +160,8 @@
 	--demo         enable demo mode - reading events from events.txt
 
 	--debug-level=x
+
+	--nogl         disable GL-mode (3d-acceleration) - THIS IS NOT YET FULLY SUPPORTED!!
 	"
 	
 						exit
@@ -190,7 +195,7 @@
 		if @@noVideo.nil?
 			#if xres!=1024 || yres!=768 || $fullscreen
 			dputs @@fullscreen
-			@@main.initVideo(xres,yres,32,@@fullscreen,true,1024,768)
+			@@main.initVideo(xres,yres,32,@@fullscreen,@@opengl,1024,768)
 			#end
 		
 			getConfig.set("xRes",xres.to_s)

Modified: antargis/trunk/ruby/credits.rb
===================================================================
--- antargis/trunk/ruby/credits.rb	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/ruby/credits.rb	2007-04-09 10:50:13 UTC (rev 1072)
@@ -23,6 +23,9 @@
 	def setCFont(f)
 		@cfont=f
 	end
+	def prepareDraw
+		queryRedraw
+	end
 	def draw(p)
 		now=@menuapp.getTicks
 		if @starttime>0

Modified: antargis/trunk/ruby/intro.rb
===================================================================
--- antargis/trunk/ruby/intro.rb	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/ruby/intro.rb	2007-04-09 10:50:13 UTC (rev 1072)
@@ -11,8 +11,10 @@
 	end
 	def setAlpha(a)
 		@alpha=a
+		queryRedraw
 	end
 	def draw(painter)
+		#painter.fillRect(@r,AGColor.new(0,0,0,0x1F))
 		painter.fillRect(@r,AGColor.new(0,0,0,(0xFF*@alpha).to_i))
 	end
 end
@@ -107,6 +109,7 @@
 					tryQuit
 				end
 		end
+		@img.redraw
 	end
 	
 	def eventFrame(t)

Modified: antargis/trunk/ruby/mainmenu.rb
===================================================================
--- antargis/trunk/ruby/mainmenu.rb	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/ruby/mainmenu.rb	2007-04-09 10:50:13 UTC (rev 1072)
@@ -54,6 +54,16 @@
 		# add handler for music finished, simply restart music
 		addHandler(getSoundManager,:sigMp3Finished,:eventMusicEnd)
 	end
+
+	def setMainWidget(w)
+		if @myScreen.nil?
+			@myScreen||=AGScreenWidget.new
+			super(@myScreen)
+		end
+		@myScreen.removeChild(@curMainWidget)
+		@myScreen.addChild(w)
+		@curMainWidget=w
+	end
 	
 	def eventMusicEnd
 		if @sound
@@ -145,7 +155,7 @@
 
 	def eventLoadSelect(e)
 		if getMainWidget==@singleMenu
-			@singleMenu.getChild("desc").setText("")
+			@singleMenu.getChild("desc").setText(AGStringUtf8.new(""))
 			filename=id=@singleMenu.getChild("list").getSelectedID
 			fn="data/levels/"+id.gsub(".antlvl",".png")
 			if findFile(fn)!=""
@@ -156,12 +166,12 @@
 			end
 			doc=Document.new("data/levels/"+filename)
 			d=doc.root.get("desc")
-			@singleMenu.getChild("desc").setText(d)
+			@singleMenu.getChild("desc").setText(AGStringUtf8.new(d))
 			return true
 		end
 		puts "MUH"
 		#raise 1
-		@loadMenu.getChild("desc").setText("")
+		@loadMenu.getChild("desc").setText(AGStringUtf8.new(""))
 		filename=id=@loadMenu.getChild("list").getSelectedID
 		fn="savegames/"+id.gsub(".antcmp",".png")
 		if findFile(fn)!=""

Modified: antargis/trunk/src/antargisgui.h
===================================================================
--- antargis/trunk/src/antargisgui.h	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/src/antargisgui.h	2007-04-09 10:50:13 UTC (rev 1072)
@@ -84,6 +84,7 @@
 #include "../src/vertex_array.h"
 #include "../src/water.h"
 #include "../src/path.h"
+#include "../src/impostor.h"
 #include <SDL_keysym.h>
 #ifdef SWIG
 %include "../gui/src/ag_rubyobj.h"
@@ -170,6 +171,7 @@
 %include "../src/vertex_array.h"
 %include "../src/water.h"
 %include "../src/path.h"
+%include "../src/impostor.h"
 %include "/usr/include/SDL/SDL_keysym.h"
 #endif
 #endif

Added: antargis/trunk/src/impostor.cc
===================================================================
--- antargis/trunk/src/impostor.cc	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/src/impostor.cc	2007-04-09 10:50:13 UTC (rev 1072)
@@ -0,0 +1,107 @@
+#include "impostor.h"
+#include <ag_debug.h>
+#include <ag_screen.h>
+#include <ag_rendercontext.h>
+
+AntImpostorData::AntImpostorData(SceneNode *pNode):mTexture(512,512)
+{
+  glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT); // clear screen and depth buffer
+
+  mTexture.beginPaint();
+  glEnable(GL_DEPTH_TEST); // enable depth test
+  glDepthMask(true);
+
+  assertGL;
+
+  AGRenderContext c;
+  c.begin(); // reset gl-state
+
+
+  assert(pNode);
+  Scene *pScene=pNode->getScene();
+  assert(pScene);
+
+  pScene->initScene();
+
+  /*
+  AntCamera camera=pScene->getCameraObject();
+
+
+  // init smaller Projection-matrix
+  glMatrixMode(GL_PROJECTION);
+  glLoadIdentity();
+
+  int x=0,y=0,h=mTexture.width(),w=mTexture.height();
+
+  gluPickMatrix(x,camera.getHeight()-y,h,w,pScene->getViewport());
+
+  // add cameras-projection-matrix
+  glMultMatrixf(camera.getProjection());
+
+  glMatrixMode(GL_MODELVIEW);
+  */
+  int sw=getScreen().getWidth(),sh=getScreen().getHeight();
+  int w=mTexture.width(),h=mTexture.height();
+  
+  
+
+  glViewport(-sw/2+w/2,-sh/2+h/2,sw,sh);
+
+  pNode->draw();
+
+
+
+  //  mTexture.endPaint();
+
+  AGSurface s=getScreen().screenshot(false);
+  s.save("impostor.png");
+
+
+  mTexture.endPaint();
+
+  AGSurface subs=s.getSubSurface(AGRect2(0,sh-h,w,h));
+  subs.save("impostor3.png");
+
+  //  mTexture.save("impostor.png");
+}
+
+AGTexture &AntImpostorData::getTexture()
+{
+  return mTexture;
+}
+
+void AntImpostorData::mark()
+{
+  markObject(&mTexture);
+  AGRubyObject::mark();
+}
+
+
+
+void AntImpostorData::create()
+{
+}
+
+
+/////////////////////////////////////////////////////////////////
+// AntImpostor
+/////////////////////////////////////////////////////////////////
+
+AntImpostor::AntImpostor(Scene *pScene,AntImpostorData *pData,const AGVector4 &pPos,float pRot):
+  SceneNode(pScene,pPos,AGBox3())
+{
+}
+
+void AntImpostor::draw()
+{
+}
+void AntImpostor::drawDepth()
+{
+}
+void AntImpostor::drawShadow()
+{
+}
+void AntImpostor::drawPick()
+{
+}
+

Added: antargis/trunk/src/impostor.h
===================================================================
--- antargis/trunk/src/impostor.h	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/src/impostor.h	2007-04-09 10:50:13 UTC (rev 1072)
@@ -0,0 +1,38 @@
+#ifndef IMPOSTOR_H
+#define IMPOSTOR_H
+
+#include <ag_texture.h>
+#include <scene.h>
+
+class AntImpostorData:public AGRubyObject
+{
+  AGTexture mTexture;
+  
+ public:
+  // create impostor from a scene-node - to make it as simple as possible
+  AntImpostorData(SceneNode *pNode);
+
+  AGTexture &getTexture();
+
+  void mark();
+
+ private:
+  void create();
+};
+
+class AntImpostor:public SceneNode
+{
+  AntImpostorData *mData;
+ public:
+  AntImpostor(Scene *pScene,AntImpostorData *pData,const AGVector4 &pPos,float pRot);
+
+  void draw();
+  void drawDepth();
+  void drawShadow();
+  void drawPick();
+
+ private:
+  
+};
+
+#endif

Modified: antargis/trunk/src/nantmarker.hh
===================================================================
--- antargis/trunk/src/nantmarker.hh	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/src/nantmarker.hh	2007-04-09 10:50:13 UTC (rev 1072)
@@ -278,6 +278,16 @@
 	result->mRubyObject=true;
 }
 %markfunc AGCaption "general_markfunc"
+%exception AntImpostorData::AntImpostorData {
+	$action
+	result->mRUBY=self;
+#ifdef GCDEBUG
+     result->mObjName=typeid(*result).name();
+     printf("%lx   %s\n",self,typeid(*result).name());
+#endif
+	result->mRubyObject=true;
+}
+%markfunc AntImpostorData "general_markfunc"
 %exception AGRadioGroup::AGRadioGroup {
 	$action
 	result->mRUBY=self;
@@ -408,6 +418,16 @@
 	result->mRubyObject=true;
 }
 %markfunc AGLayoutCreator "general_markfunc"
+%exception AntImpostor::AntImpostor {
+	$action
+	result->mRUBY=self;
+#ifdef GCDEBUG
+     result->mObjName=typeid(*result).name();
+     printf("%lx   %s\n",self,typeid(*result).name());
+#endif
+	result->mRubyObject=true;
+}
+%markfunc AntImpostor "general_markfunc"
 %exception AGRandomizer::AGRandomizer {
 	$action
 	result->mRUBY=self;
@@ -1578,6 +1598,34 @@
  }
  else $input=Qnil;
 }
+%typemap(out) AntImpostorData*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $result=$1->mRUBY;
+  else
+   {
+     if(false);
+   else
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntImpostorData,0);
+   }
+ }
+ else vresult=Qnil;
+}
+%typemap(directorin) AntImpostorData*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $input=$1->mRUBY;
+  else
+   {
+     if(false);
+   else
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntImpostorData,0);
+   }
+ }
+ else $input=Qnil;
+}
 %typemap(out) AGRadioGroup*{
  if($1)
  {
@@ -1694,7 +1742,7 @@
  }
  else $input=Qnil;
 }
-%typemap(out) AntMap*{
+%typemap(out) PathWeighter*{
  if($1)
  {
   if($1->mRubyObject)
@@ -1702,13 +1750,15 @@
   else
    {
      if(false);
+else if(dynamic_cast<MapPathWeighter*>(result))
+  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MapPathWeighter,0);
    else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntMap,0);
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PathWeighter,0);
    }
  }
  else vresult=Qnil;
 }
-%typemap(directorin) AntMap*{
+%typemap(directorin) PathWeighter*{
  if($1)
  {
   if($1->mRubyObject)
@@ -1716,13 +1766,15 @@
   else
    {
      if(false);
+else if(dynamic_cast<MapPathWeighter*>($1))
+  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MapPathWeighter,0);
    else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntMap,0);
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_PathWeighter,0);
    }
  }
  else $input=Qnil;
 }
-%typemap(out) AGMenu*{
+%typemap(out) AntMap*{
  if($1)
  {
   if($1->mRubyObject)
@@ -1731,12 +1783,12 @@
    {
      if(false);
    else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntMap,0);
    }
  }
  else vresult=Qnil;
 }
-%typemap(directorin) AGMenu*{
+%typemap(directorin) AntMap*{
  if($1)
  {
   if($1->mRubyObject)
@@ -1745,12 +1797,12 @@
    {
      if(false);
    else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenu,0);
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntMap,0);
    }
  }
  else $input=Qnil;
 }
-%typemap(out) MiniMap*{
+%typemap(out) AGMenu*{
  if($1)
  {
   if($1->mRubyObject)
@@ -1759,12 +1811,12 @@
    {
      if(false);
    else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGMenu,0);
    }
  }
  else vresult=Qnil;
 }
-%typemap(directorin) MiniMap*{
+%typemap(directorin) AGMenu*{
  if($1)
  {
   if($1->mRubyObject)
@@ -1773,12 +1825,12 @@
    {
      if(false);
    else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MiniMap,0);
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGMenu,0);
    }
  }
  else $input=Qnil;
 }
-%typemap(out) AGColorButton*{
+%typemap(out) MiniMap*{
  if($1)
  {
   if($1->mRubyObject)
@@ -1787,12 +1839,12 @@
    {
      if(false);
    else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MiniMap,0);
    }
  }
  else vresult=Qnil;
 }
-%typemap(directorin) AGColorButton*{
+%typemap(directorin) MiniMap*{
  if($1)
  {
   if($1->mRubyObject)
@@ -1801,12 +1853,12 @@
    {
      if(false);
    else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGColorButton,0);
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MiniMap,0);
    }
  }
  else $input=Qnil;
 }
-%typemap(out) AGImage*{
+%typemap(out) AGColorButton*{
  if($1)
  {
   if($1->mRubyObject)
@@ -1815,12 +1867,12 @@
    {
      if(false);
    else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGColorButton,0);
    }
  }
  else vresult=Qnil;
 }
-%typemap(directorin) AGImage*{
+%typemap(directorin) AGColorButton*{
  if($1)
  {
   if($1->mRubyObject)
@@ -1829,12 +1881,12 @@
    {
      if(false);
    else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGImage,0);
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGColorButton,0);
    }
  }
  else $input=Qnil;
 }
-%typemap(out) PathWeighter*{
+%typemap(out) AGImage*{
  if($1)
  {
   if($1->mRubyObject)
@@ -1842,15 +1894,13 @@
   else
    {
      if(false);
-else if(dynamic_cast<MapPathWeighter*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MapPathWeighter,0);
    else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PathWeighter,0);
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGImage,0);
    }
  }
  else vresult=Qnil;
 }
-%typemap(directorin) PathWeighter*{
+%typemap(directorin) AGImage*{
  if($1)
  {
   if($1->mRubyObject)
@@ -1858,10 +1908,8 @@
   else
    {
      if(false);
-else if(dynamic_cast<MapPathWeighter*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_MapPathWeighter,0);
    else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_PathWeighter,0);
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGImage,0);
    }
  }
  else $input=Qnil;
@@ -1906,6 +1954,8 @@
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AnimMesh,0);
 else if(dynamic_cast<WaterPiece*>(result))
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_WaterPiece,0);
+else if(dynamic_cast<AntImpostor*>(result))
+  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntImpostor,0);
 else if(dynamic_cast<Smoke*>(result))
   vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Smoke,0);
 else if(dynamic_cast<Mesh*>(result))
@@ -1932,6 +1982,8 @@
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AnimMesh,0);
 else if(dynamic_cast<WaterPiece*>($1))
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_WaterPiece,0);
+else if(dynamic_cast<AntImpostor*>($1))
+  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntImpostor,0);
 else if(dynamic_cast<Smoke*>($1))
   $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Smoke,0);
 else if(dynamic_cast<Mesh*>($1))
@@ -1974,6 +2026,34 @@
  }
  else $input=Qnil;
 }
+%typemap(out) AntImpostor*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $result=$1->mRUBY;
+  else
+   {
+     if(false);
+   else
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AntImpostor,0);
+   }
+ }
+ else vresult=Qnil;
+}
+%typemap(directorin) AntImpostor*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $input=$1->mRUBY;
+  else
+   {
+     if(false);
+   else
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AntImpostor,0);
+   }
+ }
+ else $input=Qnil;
+}
 %typemap(out) AGRandomizer*{
  if($1)
  {
@@ -3062,6 +3142,16 @@
  Data_Get_Struct($input,AntFrustum,b);
  $result=*b;
 }
+%typemap(directorout) AntImpostor {
+ AntImpostor *b;
+ Data_Get_Struct($input,AntImpostor,b);
+ $result=*b;
+}
+%typemap(directorout) AntImpostorData {
+ AntImpostorData *b;
+ Data_Get_Struct($input,AntImpostorData,b);
+ $result=*b;
+}
 %typemap(directorout) AntMap {
  AntMap *b;
  Data_Get_Struct($input,AntMap,b);

Modified: antargis/trunk/src/scene.h
===================================================================
--- antargis/trunk/src/scene.h	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/src/scene.h	2007-04-09 10:50:13 UTC (rev 1072)
@@ -158,6 +158,8 @@
   std::map<GLuint,SceneNode*> pickNames;
 
   bool mEnabled;
+
+  friend class AntImpostorData;
 };
 
 

Modified: antargis/trunk/src/vertex_array.cc
===================================================================
--- antargis/trunk/src/vertex_array.cc	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/src/vertex_array.cc	2007-04-09 10:50:13 UTC (rev 1072)
@@ -518,8 +518,34 @@
 }
 
 
+void VertexArray::onScreenUp()
+{
+    init();
+}
 
+void VertexArray::onScreenDown()
+{
+  if(mBuffers && mVertexBuffer!=0) //mChanged==false)
+    {
+      glDeleteBuffersARB( 1, &mVertexBuffer );
+      glDeleteBuffersARB( 1, &mColorBuffer );
+      glDeleteBuffersARB( 1, &mNormalBuffer );
+      glDeleteBuffersARB( 1, &mTexBuffer );
+      if(!mDynamic)
+	glDeleteBuffersARB( 1, &mIndexBuffer );
+    }
+  mVertexBuffer=mColorBuffer=mNormalBuffer=mTexBuffer=mIndexBuffer=0;
+}
 
+
+
+
+////////////////////////////////////////////////////////////////////
+// VertexArrayShader
+////////////////////////////////////////////////////////////////////
+
+
+
 VertexArrayShader::VertexArrayShader(AntShaderProgram *_p):p(_p)
 {
   aInited=false;

Modified: antargis/trunk/src/vertex_array.h
===================================================================
--- antargis/trunk/src/vertex_array.h	2007-04-03 19:08:44 UTC (rev 1071)
+++ antargis/trunk/src/vertex_array.h	2007-04-09 10:50:13 UTC (rev 1072)
@@ -23,7 +23,7 @@
    if you have to do special drawing like picking, use the corresp. functions (drawDepth,drawPick)
 */
 
-class VertexArray
+class VertexArray:public AGGLObject
 {
   std::vector<AGVector4> mVertices,mColors;
   std::vector<AGVector3> mNormals;
@@ -83,6 +83,9 @@
   bool useVertexArrays() const;
   friend VertexArray *makeInstances(const VertexArray &va,const std::vector<AGMatrix4> &ts);
 
+  void onScreenUp();
+  void onScreenDown();
+
 };
 
 /**



From davidkamphausen at mail.berlios.de  Tue Apr 10 20:38:34 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Tue, 10 Apr 2007 20:38:34 +0200
Subject: [Antargis-svn] r1073 - antargis/tags
Message-ID: <200704101838.l3AIcY9a012036@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-04-10 20:38:33 +0200 (Tue, 10 Apr 2007)
New Revision: 1073

Added:
   antargis/tags/0.2/
Log:
A    svn+ssh://davidkamphausen at svn.berlios.de/svnroot/repos/antargis/antargis/tags/0.2


Copied: antargis/tags/0.2 (from rev 1072, antargis/trunk)



From davidkamphausen at mail.berlios.de  Mon Apr 23 20:01:29 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Mon, 23 Apr 2007 20:01:29 +0200
Subject: [Antargis-svn] r1074 - antargis/branches
Message-ID: <200704231801.l3NI1TgU004867@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-04-23 20:01:28 +0200 (Mon, 23 Apr 2007)
New Revision: 1074

Added:
   antargis/branches/new_hl_jobs/
Log:
A    svn+ssh://davidkamphausen at svn.berlios.de/svnroot/repos/antargis/antargis/branches/new_hl_jobs


Copied: antargis/branches/new_hl_jobs (from rev 1073, antargis/trunk)



From davidkamphausen at mail.berlios.de  Sun Apr 29 19:39:49 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 29 Apr 2007 19:39:49 +0200
Subject: [Antargis-svn] r1075 - in antargis/branches/new_hl_jobs: .
	data/gui/layout data/levels/tutorial gui/src ruby src
Message-ID: <200704291739.l3THdnlv019686@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-04-29 19:39:46 +0200 (Sun, 29 Apr 2007)
New Revision: 1075

Modified:
   antargis/branches/new_hl_jobs/Rakefile
   antargis/branches/new_hl_jobs/antargis.iss
   antargis/branches/new_hl_jobs/data/gui/layout/ant_layout.xml
   antargis/branches/new_hl_jobs/data/levels/tutorial/tutorial0.rb
   antargis/branches/new_hl_jobs/gui/src/ag_debug.h
   antargis/branches/new_hl_jobs/gui/src/ag_main.h
   antargis/branches/new_hl_jobs/ruby/ant_boss.rb
   antargis/branches/new_hl_jobs/ruby/ant_hero.rb
   antargis/branches/new_hl_jobs/ruby/ant_hljob_base.rb
   antargis/branches/new_hl_jobs/ruby/ant_hljob_states.rb
   antargis/branches/new_hl_jobs/ruby/ant_hljobs.rb
   antargis/branches/new_hl_jobs/ruby/ant_local.rb
   antargis/branches/new_hl_jobs/ruby/ant_man.rb
   antargis/branches/new_hl_jobs/ruby/ant_manbase.rb
   antargis/branches/new_hl_jobs/ruby/ant_new_hljobs.rb
   antargis/branches/new_hl_jobs/ruby/antargislib.rb
   antargis/branches/new_hl_jobs/src/entity.cc
   antargis/branches/new_hl_jobs/src/jobs.cc
   antargis/branches/new_hl_jobs/src/terrain.cc
   antargis/branches/new_hl_jobs/src/vertex_array.cc
Log:
* improvements on hl-jobs


Modified: antargis/branches/new_hl_jobs/Rakefile
===================================================================
--- antargis/branches/new_hl_jobs/Rakefile	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/Rakefile	2007-04-29 17:39:46 UTC (rev 1075)
@@ -358,11 +358,13 @@
 			msh "cp #{f} #{distdir}"
 		}
 		msh "cp libantargis.so #{distdir}"
-		msh "rm -rf #{distdir}/autopackage #{distdir}/contrib #{distdir}/mkmf.log"
+		msh "rm -rf #{distdir}/autopackage #{distdir}/contrib #{distdir}/mkmf.log #{distdir}/*.txt #{distdir}/FIXME #{distdir}/*TODO #{distdir}/*.html"
 	
 		# FIXME: maybe del this
 		msh "cp #{distdir}/libpng13.dll #{distdir}/libpng12.dll"
 		msh "cp #{distdir}/libtiff3.dll #{distdir}/tiff.dll"
+	else
+		msh "rm -rf #{distdir}/autopackage #{distdir}/contrib #{distdir}/mkmf.log #{distdir}/*.txt #{distdir}/FIXME #{distdir}/*TODO #{distdir}/*.html #{distdir}/debian #{distdir}/test"
 	end
 	
 

Modified: antargis/branches/new_hl_jobs/antargis.iss
===================================================================
--- antargis/branches/new_hl_jobs/antargis.iss	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/antargis.iss	2007-04-29 17:39:46 UTC (rev 1075)
@@ -5,21 +5,21 @@
 
 [Setup]
 AppName=Antargis
-AppVerName=Antargis 0.1.9
+AppVerName=Antargis 0.2
 DefaultDirName={pf}\Antargis
 DefaultGroupName=Antargis
 UninstallDisplayIcon={app}\Antargis.exe
 Compression=lzma/fast
 SolidCompression=yes
 ;InfoAfterFile=c:\Antargis\readme.txt
-OutputBaseFilename=Antargis-0.1.9-setup
+OutputBaseFilename=Antargis-0.2-setup
 AppPublisher=Antargis-Team
 AppPublisherURL=antargis.berlios.de
-AppVersion=0.1.9
+AppVersion=0.2
 
 
 [Files]
-Source: "z:\home\david\projects\antargis\ant\antargis-0.1.9\*"; DestDir: "{app}"; Flags:recursesubdirs
+Source: "z:\home\david\projects\antargis\ant\antargis-0.2\*"; DestDir: "{app}"; Flags:recursesubdirs
 
 [Icons]
 Name: "{group}\Antargis"; Filename: "{app}\Antargis.lnk" ; WorkingDir: "{app}"

Modified: antargis/branches/new_hl_jobs/data/gui/layout/ant_layout.xml
===================================================================
--- antargis/branches/new_hl_jobs/data/gui/layout/ant_layout.xml	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/data/gui/layout/ant_layout.xml	2007-04-29 17:39:46 UTC (rev 1075)
@@ -233,6 +233,6 @@
 	<table cols="2" rows="2">
 		<colsize col="1" fixed="216"/>
 		<rowsize row="1" fixed="30"/>
-		<text name="statusBar" col="0" row="1" caption="FPS:0" cache="true"/>
+		<text name="statusBar" col="0" row="1" caption="FPS:0" cache="false"/>
 	</table>
 </layout>

Modified: antargis/branches/new_hl_jobs/data/levels/tutorial/tutorial0.rb
===================================================================
--- antargis/branches/new_hl_jobs/data/levels/tutorial/tutorial0.rb	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/data/levels/tutorial/tutorial0.rb	2007-04-29 17:39:46 UTC (rev 1075)
@@ -44,6 +44,7 @@
 		return false #ignore
 	end
 	def eventHeroDied(ent)
+		puts "eventHeroDied(#{ent}) - #{ent.getName}"
 		case ent.getName	
 			when "Rowen"
 				lostLevel
@@ -72,6 +73,7 @@
 	end
 	def wonLevel
 		puts "INTERFACE:", at interface,self
+		#raise 1
 		@interface.wonLevel
 		@won=true
 		start=StoryFlow.new("recruit")

Modified: antargis/branches/new_hl_jobs/gui/src/ag_debug.h
===================================================================
--- antargis/branches/new_hl_jobs/gui/src/ag_debug.h	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/gui/src/ag_debug.h	2007-04-29 17:39:46 UTC (rev 1075)
@@ -99,10 +99,12 @@
 void agRaise(const std::string &s);
 
 #ifndef __WIN32__
-//#undef assert
-//#define assert(x) {if(!(x)) agRaise((::toString("assert failed ")+LINEINFO(__STRING(x))).c_str()); }
+#undef assert
+#define assert(x) {if(!(x)) agRaise((::toString("assert failed ")+LINEINFO(__STRING(x))).c_str()); }
 #endif
 
+//#undef assert
+
 #define Assert(x) assert(x)
 
 #define STUB cdebug("STUB in File "<<__FILE__<<" line:"<<__LINE__<<" function:"<<__PRETTY_FUNCTION__)

Modified: antargis/branches/new_hl_jobs/gui/src/ag_main.h
===================================================================
--- antargis/branches/new_hl_jobs/gui/src/ag_main.h	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/gui/src/ag_main.h	2007-04-29 17:39:46 UTC (rev 1075)
@@ -97,6 +97,7 @@
 // from ag_debug
 size_t getDebugLevel();
 void setDebugLevel(size_t t);
+void setRubyRaising(bool flag);
 
 
 #endif

Modified: antargis/branches/new_hl_jobs/ruby/ant_boss.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_boss.rb	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/ruby/ant_boss.rb	2007-04-29 17:39:46 UTC (rev 1075)
@@ -94,6 +94,7 @@
 	end
 	
 	def eventNoJob
+		#return if @meshState!="dead"
 # 		dputs "eventNoJob "+self.class.to_s+" "+ at job.to_s
 # 		dputs caller.join("\n")
 		checkHLJobEnd(self)
@@ -150,7 +151,10 @@
 	end
 	
 	def removeMan(man)
-		@men.delete(man)
+		if @men.member?(man)
+			@men.delete(man)
+			man.setBoss(nil)
+		end
 		if @job
 			@job.delete(man)
 		end
@@ -174,11 +178,11 @@
 # 		return
 # 	end
 
-	def eventAttacked(by)
-		ret=newHLDefendJob(by)
-		AntInventory.update(self)
-		ret
-	end
+# 	def eventAttacked(by)
+# 		ret=newHLDefendJob(by)
+# 		AntInventory.update(self)
+# 		ret
+# 	end
 	
 	def eventManDefeated(man)
 		dputs "AntBoss:eventManDefeated: #{man} #{man.getName}"
@@ -224,20 +228,20 @@
 	end
 	
 	def assignJob2All
-		if getMap
-			getMap.eventNewJobAssignedToBoss(self)
-		end
-
-		begin
-		# discard reassigning in this case
-		return if ObjectSpace.const_get(:AntNewHLJob)
-		rescue
-		end
-
-		@men.each{|man|
-			man.delJob
-			assignJob(man)
-		}
+# 		if getMap
+# 			getMap.eventNewJobAssignedToBoss(self)
+# 		end
+# 
+# 		begin
+# 		# discard reassigning in this case
+# 		return if ObjectSpace.const_get(:AntNewHLJob)
+# 		rescue
+# 		end
+# 
+# 		@men.each{|man|
+# 			man.delJob
+# 			assignJob(man)
+# 		}
 	end
 	def killAllJobs
 		@men.each{|man|man.delJob}

Modified: antargis/branches/new_hl_jobs/ruby/ant_hero.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_hero.rb	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/ruby/ant_hero.rb	2007-04-29 17:39:46 UTC (rev 1075)
@@ -64,6 +64,7 @@
 	
 	def noHLJob
 		puts "noHLJob #{self}"
+		assert{getEnergy>0}
 		if @player
 			@player.assignJob(self)
 			#stopFireSound
@@ -74,6 +75,7 @@
 	end
 	
 	def startFireSound
+		assert{getEnergy>0}
 		if not @fireSound
 			dputs "STARTING FIRE"
 			@fireSound=AntSound.playLoopSoundGlobal(self,"fire",getPos2D,0.4)
@@ -94,6 +96,7 @@
 	end
 
 	def newFightJob(d,ptarget)
+		assert{ptarget.canFight}
 		checkResources
 		super
 		@moving=true
@@ -109,6 +112,7 @@
 	end
 	
 	def assignJob(man)
+		puts "#{self}:#{getName}:assignJob(#{man}:#{man.getName}"
 		checkHLJobEnd(man)
 	end	
 	def moveHome(man)
@@ -131,32 +135,38 @@
 		assignJob2All
 	end
 	def newHLRecruitJob(target)
+		assert{target.is_a?(AntBoss)}
 		@job.stopJob if @job
 		@job=AntHeroRecruitJob.new(self,target)
 		assignJob2All
 	end
 	def newHLConstructJob(target)
+		assert{target.is_a?(AntWorkshop)}
 		@job.stopJob if @job
 		@job=AntHeroConstructJob.new(self,target)
 		assignJob2All
 	end
 	def newHLTakeFoodJob(target)
+		assert{target.is_a?(AntHouse)}
 		@job.stopJob if @job
 		puts "take food job #{self} #{target}"
 		@job=AntHeroTakeJob.new(self,target,"food")
 		assignJob2All
 	end
 	def newHLTakeWeaponJob(target)
+		assert{target.is_a?(AntBoss)}
 		@job.stopJob if @job
 		@job=AntHeroTakeJob.new(self,target,"weapon")
 		assignJob2All
 	end
 	def newHLFightJob(target)
+		assert{target.is_a?(AntBoss) and target.canFight}
 		@job.stopJob if @job
 		@job=AntHeroFightJob.new(self,target)
 		assignJob2All
 	end
 	def newHLFightAnimalJob(target)
+		assert{target.is_a?(AntAnimal)}
 		@job.stopJob if @job
 		@job=AntHeroFightAnimalJob.new(self,target)
 		assignJob2All
@@ -234,20 +244,20 @@
 		end
 	end
 
-	def eventAttacked(by)
-		puts "eventAttacked #{by}"
-		super
-	end
+# 	def eventAttacked(by)
+# 		puts "eventAttacked #{by}"
+# 		super
+# 	end
 	
 	def assignJob2All
 		super
-		puts "ASSIGN JOB 2 All #{self}"
-		puts "---"
+# 		puts "ASSIGN JOB 2 All #{self}"
+# 		puts "---"
 		if @job.class!=AntHeroRestJob
 			setFire(false)
 		end
-		doEvent(:newJobAssigned)
-		puts "ASSIGN JOB ready."
+ 		doEvent(:newJobAssigned)
+# 		puts "ASSIGN JOB ready."
 	end
 
 	def setMeshState(name)
@@ -331,13 +341,33 @@
 	end
 
 	def eventDie
+		puts "ENERGY:#{self} #{self.getEnergy}"
 		super
-		@job=nil
+		puts "ENERGY:#{self} #{self.getEnergy}"
+		puts "hero #{self} died.(#{getName})"
+		# release all men
+		puts "# men:#{@men.length}"
+		@men.each{|man|
+			puts "myMen:#{man}:#{man.getName}"
+			if man.is_a?(AntMan)
+				puts "#{man} #{man.getName}:setBoss(nil)"
+				man.setBoss(nil)
+				@men.delete(man)
+			end
+		}
+
+		killJob
 		if @player
 			@player.remove(self)
 		end
 		getMap.eventHeroDied(self)
 	end
 
+
+	def killJob
+		@job.kill if @job
+		@job=nil
+	
+	end
 end
 

Modified: antargis/branches/new_hl_jobs/ruby/ant_hljob_base.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_hljob_base.rb	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/ruby/ant_hljob_base.rb	2007-04-29 17:39:46 UTC (rev 1075)
@@ -1,16 +1,23 @@
-class AntNewHLJob
+require 'ant_state_machine.rb'
+
+class AntNewHLJob<BaseMachine
 	attr_reader :finished, :stopped
 	# some magic here
-	def initialize(hero)
+	def initialize(hero,startState=nil)
+		super(startState)
 		@hero=hero
+		assert{not @hero.nil?}
 
 		@finished=false
 
 		firstCall
 	end
+
 	def getTime
+		puts "getTime"
 		@hero.getMap.getTime
 	end
+
 	def allMen
 		if @hero.is_a?(AntHero)
 			@hero.getMen
@@ -18,86 +25,47 @@
 			@hero.getMen-[@hero]
 		end
 	end
+
 	def hero
 		@hero
 	end
 
 	def stopJob
 		@stopped=true
-		if @state
-			call(@state,"leave")
-		end
+		stateCall("leave")
 	end
 
 	def check(man)
-		return if @state.nil?
-		call2(@state,"assign",man)
-		while call(@state,"ready")
-			call(@state,"leave")
-			goToNextState
-			break if @state.nil? or @finished
+		#raise 1
+		if @state.nil?
+			@finished=true
+			return
 		end
-		puts "FINISHED: #{@finished}"
+		#raise 1
+		stateCall("assign",man)
+		advance
+		@finished=ready
 	end
 
-	# override this one
-	def goToNextState
-		@workflow.each{|p|
-			if p[0]==@state
-				@state=p[1]
-				call(@state,"enter")
-				return
-			end
-		}
-		@finished=true
+	def delete(man)
+		puts "IGNORING AntNewHLJob::delete(#{man})"
+		if man==@hero
+			puts "STOPPING JOB - because hero died"
+			@finished=true
+			@state=nil
+		end
 	end
 
-	def switchToState(state)
-		call(@state,"leave")
-		@state=state
-		call(@state,"enter")
-	end
 
-	def firstCall
-		call(@state,"enter")
-	end
-
-	def call(state,event)
-		m=methodName(state,event)
-		print "CALL #{hero.getName} #{state} #{event} #{m}  #{getTime} -- "
-		if self.class.method_defined?(m)
-			v=send(m)
-			puts v
-			return v
+	def trace
+		if @hero.nil?
+			puts "TRACE #{caller[0]} #{self}"
 		else
-			puts "UNKNOWN"
-			true
+			puts "TRACE #{caller[0]} #{self} #{hero} #{getTime}"
 		end
 	end
-	def xmlName
-		self.class.to_s
-	end
 
-	def call2(state,event,man)
-		m=methodName(state,event)
-		print "CALL2 #{hero.getName} #{state} #{event} #{m} #{man} #{getTime} -- "
-		if self.class.method_defined?(m)
-			v=send(m,man)
-			puts v
-			return v
-		else
-			puts "UNKNOWN"
-			true
-		end
-	end
-
-	def methodName(state,event)
-		m=state.to_s+"_"+event
-		m=m[0..0].downcase+m[1..-1]
-	end
-
-	def trace
-		puts "TRACE #{caller[0]} #{getTime}"
-	end
-		
+	def kill
+		stateCall("kill")
+	end		
 end

Modified: antargis/branches/new_hl_jobs/ruby/ant_hljob_states.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_hljob_states.rb	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/ruby/ant_hljob_states.rb	2007-04-29 17:39:46 UTC (rev 1075)
@@ -1,35 +1,74 @@
 # Does the walk-formation
 # 
 #
-module HLJob_FormatWalk
+require 'ant_state_machine.rb'
+
+class Module
+	def wrap(objectName,methodName,objectMethodName=nil)
+		objectMethodName||=methodName
+		ts="*s"
+		ts="s" if methodName=~/.*=$/
+		s="def #{methodName}(#{ts})\n#{objectName}.#{objectMethodName}(#{ts})\nend\n"
+		puts s
+		module_eval s
+	end
+end
+
+
+module HLJob_Additions
+	attr_accessor :machine
+	#include AntWrapper
+	["hero","allMen","getTime","targetPos","targetPos=","formatDir","formatDir=","target"].each{|n|wrap "machine",n}
+end
+
+class HLJob_BaseState
+	include HLJob_Additions
+
+	def trace
+		if @hero.nil?
+			puts "TRACE #{caller[0]} #{self}"
+		else
+			puts "TRACE #{caller[0]} #{self} #{hero} #{getTime}"
+		end
+	end
+end
+
+class HLJob_DummyState<HLJob_BaseState
+end
+
+class HLJob_FormatWalk<HLJob_BaseState
 	# needed: getTime
 
 	# wait 5 seconds at max for formatting
 	FORMAT_MAX_TIME=5
 
-	def formatWalk_enter
+	def enter
+		puts "#{self}:enter"
 		trace
-		hero.formation=AntFormationBlock.new(@hero,formatDir)
-		heroPos=@hero.getPos2D
+		hero.formation=AntFormationBlock.new(hero,formatDir)
+		heroPos=hero.getPos2D
 		allMen.each{|man|
-			pos=@hero.getFormation(man,heroPos)
+			pos=hero.getFormation(man,heroPos)
 			man.walkTo(pos)
 			man.hlJobMode[:formatting]=true
 		}
 		@formatStart=getTime
 	end
 
-	def formatWalk_assign(man)
+	def assign(man)
+		#raise 1
 		man.setDirection(180-(targetPos-hero.getPos2D).normalized.getAngle.angle*180.0/Math::PI)
 		man.standStill
 		man.hlJobMode.delete(:formatting)
 	end
 
-	def formatWalk_ready
+	def ready
 		if getTime- at formatStart>FORMAT_MAX_TIME
+			puts "MUST BE READY"
 			return true
 		end
 		allMen.each{|man|
+			puts "formatting:#{man}:#{man.hlJobMode[:formatting]}"
 			if man.hlJobMode[:formatting]
 				return false
 			end
@@ -38,44 +77,41 @@
 	end
 
 private
-	def formatDir
-		(targetPos-hero.getPos2D).normalized
-	end
 
 end
 
-module HLJob_FormatSit
+class HLJob_FormatSit<HLJob_BaseState
 	# needed: getTime
 
 	# wait 5 seconds at max for formatting
 	FORMAT_MAX_TIME=15
 
-	def formatSit_enter
+	def enter
+		#raise 1
 		trace
-		hero.formation=AntFormationRest.new(@hero)
-		heroPos=@hero.getPos2D
+		hero.formation=AntFormationRest.new(hero)
+		heroPos=hero.getPos2D
 		allMen.each{|man|
-			pos=@hero.getFormation(man,heroPos)
+			pos=hero.getFormation(man,heroPos)
 			man.walkTo(pos)
 			man.hlJobMode[:formatting]=true
-			#puts "formatSit_enter: #{man} to #{pos}  (heroPos:#{heroPos})"
 		}
 		@formatStart=getTime
 	end
 
-	def formatSit_assign(man)
+	def assign(man)
 		man.setDirection(180-(hero.getPos2D-man.getPos2D).normalized.getAngle.angle*180.0/Math::PI)
 		man.standStill
 		man.hlJobMode.delete(:formatting)
 	end
 
-	def formatSit_ready
+	def ready
+		puts "#{self}:ready"
 		if getTime- at formatStart>FORMAT_MAX_TIME
 			# FIXME:rest deserts
 			return true
 		end
 		allMen.each{|man|
-			#puts "formatSit_ready: #{man}:#{man.hlJobMode[:formatting]}"
 			if man.hlJobMode[:formatting]
 				return false
 			end
@@ -84,29 +120,34 @@
 	end
 end
 
-module HLJob_MoveToNextWayPoint
+class HLJob_MoveToNextWayPoint<HLJob_BaseState
 	# needed: hero,allMen,targetPos, near
-	def near
-		0
+
+	attr_accessor :near
+
+	def initialize
+		super
+		@near=0
 	end
 
-	def moveToNextWayPoint_enter
-		hero.formation=AntFormationBlock.new(@hero,formatDir)
+	def enter
+		puts "#{self}:enter"
+		hero.formation=AntFormationBlock.new(hero,formatDir)
 		allMen.each{|man|
-			pos=@hero.getFormation(man,targetPos)
+			pos=hero.getFormation(man,targetPos)
 			man.newMoveJob(0,pos,near)
 			man.hlJobMode[:walking]=true
 		}
 	end
 
-	def moveToNextWayPoint_assign(man)
+	def assign(man)
 		man.standStill
 		man.hlJobMode.delete(:walking)
 
 		# FIXME: maybe let him desert if this is called too often ?
 	end
 
-	def moveToNextWayPoint_ready
+	def ready
 		allMen.each{|man|
 			if man.hlJobMode[:walking]
 				return false
@@ -117,8 +158,83 @@
 
 end
 
-module HLJob_SitDown
-	def sitDown_enter
+class HLJob_MoveComplete<BaseState
+	include HLJob_Additions
+	state :moveToNextPoint=>HLJob_MoveToNextWayPoint
+	state :formatWalk=>HLJob_FormatWalk
+	state :endState=>HLJob_DummyState
+
+	startState :formatWalk
+	endState :endState
+	
+	edge :moveToNextPoint, :formatWalk, :stillHasWaypoints
+	edge :formatWalk, :moveToNextPoint
+	edge :moveToNextPoint, :endState, :noMoreWaypoints
+
+	def enter
+		puts "#{self}:enter"
+		if @waypoints.nil?
+			initWaypoints
+		end
+	end
+
+	def stillHasWaypoints
+		puts state
+		if @waypoints.length>0
+			self.targetPos=@waypoints.shift
+			puts "targetPos:#{targetPos}"
+			return true
+		end
+		false
+	end
+
+	def near=(n)
+		@states[:moveToNextPoint].near=n
+	end
+
+	def noMoreWaypoints
+		@waypoints.length==0
+	end
+
+	def moveDirectly
+		@state=:moveToNextPoint
+	end
+
+	def assign(man)
+		#raise 1
+		state.assign(man)
+	end
+
+	def hero
+		machine.hero
+	end
+	def formatDir
+		(targetPos-hero.getPos2D).normalized
+	end
+
+	private
+
+	def initWaypoints
+		if getMap.path
+			@waypoints=[hero.getPos2D]+getMap.path.computePath(hero.getPos2D,targetPos)+[targetPos]
+			# remove waypoints in between - if they're not necessary - origin must be given, too
+			@waypoints=getMap.path.refinePath(@waypoints,MapPathWeighter.new(getMap))
+			# remove origin for waypoint-list
+			assert{@waypoints.length>=2}
+			@waypoints.shift
+			
+			@waypoints+=[targetPos]
+
+		else
+			@waypoints=[targetPos]
+		end
+		@completeTargetPos=targetPos
+		self.targetPos=@waypoints.shift
+	end
+end
+
+class HLJob_SitDown<HLJob_BaseState
+	def enter
 		allMen.each{|man|
 			man.setDirection(180-(hero.getPos2D-man.getPos2D).normalized.getAngle.angle*180.0/Math::PI)
 			man.sitDown
@@ -126,12 +242,12 @@
 		}
 	end
 
-	def sitDown_assign(man)
+	def assign(man)
 		man.sitStill
 		man.hlJobMode.delete(:sitting)
 	end
 
-	def sitDown_ready
+	def ready
 		allMen.each{|man|
 			if man.hlJobMode[:sitting]
 				return false
@@ -141,32 +257,32 @@
 	end
 end
 
-module HLJob_JustSit
-	def justSit_enter
+class HLJob_JustSit<HLJob_BaseState
+	def enter
 		allMen.each{|man|
 			man.sitStill
 		}
 	end
-	def justSit_assign(man)
+	def assign(man)
 		man.sitStill # and rest
 	end
 
-	def justSit_ready
+	def ready
 		return false
 	end
 end
 
-module HLJob_JustSitOnce
-	def justSitOnce_enter
+class HLJob_JustSitOnce<HLJob_BaseState
+	def enter
 		allMen.each{|man|
 			man.sitStill
 			man.hlJobMode[:justSitting]=true
 		}
 	end
-	def justSitOnce_assign(man)
+	def assign(man)
 		man.hlJobMode.delete(:justSitting)
 	end
-	def justSitOnce_ready
+	def ready
 		allMen.each{|man|
 			if man.hlJobMode[:justSitting]
 				return false
@@ -178,11 +294,11 @@
 end
 	
 
-module HLJob_FetchStart
+class HLJob_FetchStart<HLJob_BaseState
 	# needed a target-entity
-	def fetchStart_enter
+	def enter
 		trace
-		fetchPoint=target.getPos2D
+		fetchPoint=machine.target.getPos2D
 		puts "fetchPoint:#{fetchPoint}  heroPos:#{hero.getPos2D}"
 		allMen.each{|man|
 			man.walkTo(fetchPoint)
@@ -192,13 +308,13 @@
 		
 	end
 
-	def fetchStart_assign(man)
+	def assign(man)
 		trace
 		man.standStill
 		man.hlJobMode.delete(:fetching)
 	end
 
-	def fetchStart_ready
+	def ready
 		trace
 		allMen.each{|man|
 			puts "fetchStart_ready check: #{man} : #{man.hlJobMode[:fetching]}"
@@ -212,13 +328,19 @@
 	end
 end
 
-module HLJob_GetResource
+class HLJob_GetResource<HLJob_BaseState
 	# needed: resources return array of resource-strings
-	def getResource_enter
+	attr_accessor :resources
+
+	def initialize
+		@resources=[]
+	end
+
+	def enter
 		for i in 1..hero.getAggression
 			allMen.each{|man|
 				resources.each{|r|
-					a=target.resource.get(r)
+					a=machine.target.resource.get(r)
 					if a>1
 						man.resource.add(r,1)
 						target.resource.sub(r,1)
@@ -228,13 +350,13 @@
 		end
 		allMen.each{|m|m.resourceChanged}
 	end
-	def getResource_ready
+	def ready
 		return true
 	end
 end
 
-module HLJob_KillAnimal
-	def killAnimal_enter
+class HLJob_KillAnimal<HLJob_BaseState
+	def enter
 		target.eventDie
 		hero.resource.takeAll(target.resource)
 		allMen.each{|m|m.resourceChanged}
@@ -242,10 +364,10 @@
 end
 
 # spread things among team-members
-module HLJob_SpreadThings
+class HLJob_SpreadThings<HLJob_BaseState
 	RESOURCES_TO_SPREAD=["sword","shield","bow","boat"]
 
-	def spreadThings_enter
+	def enter
 		allMen.each{|man|
 			man.walkTo(hero.getPos2D)
 			man.hlJobMode[:gatherToSpread]=true
@@ -253,7 +375,7 @@
 		@alreadySpread=false
 	end
 
-	def spreadThings_assign(man)
+	def assign(man)
 		man.standStillShort
 		if man.hlJobMode[:gatherToSpread]
 			man.hlJobMode.delete(:gatherToSpread)
@@ -265,7 +387,7 @@
 		end
 	end
 
-	def spreadThings_ready
+	def ready
 		return true if @alreadySpread		
 		allMen.each{|man|
 			return false if man.hlJobMode[:gatherToSpread] or man.hlJobMode[:waitForSpread]
@@ -321,7 +443,7 @@
 	
 end
 
-class HLJob_FightData
+class HLJob_FightData<HLJob_BaseState
 
 	attr_reader :inited
 	# only attacker creates fightData
@@ -357,9 +479,12 @@
 	end
 
 	def getNewOpponent(man,fightJob)
+		assert{man.canFight}
 		assert{man.is_a?(AntHero) or man.is_a?(AntMan)}
 		assert{man.getHero==fightJob.hero}
 	
+		checkForUpdate
+
 		# for a start: get next opponent
 		# (maybe take next free opponent ??)
 		# (maybe: find weakest friend and help him ???)
@@ -373,17 +498,45 @@
 			#eventWon(myType)
 			return nil
 		else
+			assert{opponent.canFight}
 			return opponent
 		end
 	end
 
+	def checkForUpdate
+
+		#raise "FIXME"
+		# check, if heroes are still able to fight, else reshuffle - let hero lose or sth else
+
+		nparties={}
+		oldparties=@parties
+		@parties.each{|type,jobs|
+			njobs=jobs.select{|job|job.hero.canFight}
+			nparties[type]=njobs
+		}
+		@parties=nparties
+
+		if @parties!=oldparties
+			reshuffle
+		end
+
+	end
+
 	private
 
 	def otherType(my)
 		{:attacker=>:defender,:defender=>:attacker}[my]
 	end
 
+	def getAllJobs
+		@parties.collect{|type,jobs|jobs}.flatten
+	end
+	def getAllHeroes
+		getAllJobs.collect{|job|job.hero}
+	end
+
 	def reshuffle
+		trace
 		# reinit and assign
 
 		menGroup={}
@@ -433,12 +586,13 @@
 
 end
 
-module HLJob_Fight
+class HLJob_Fight<HLJob_BaseState
 	# needed: hero,target, undefeatedMen
 
 	attr_reader :fightType, :fightData, :won
 
-	def fight_enter
+	def enter
+		trace
 
 		targetHadFightData=target.hlJobMode[:fightData].nil?
 		
@@ -448,15 +602,22 @@
 			puts "NOT YET INITED #{self} hero:#{hero} target:#{target}"
 			target.newHLDefendJob(hero)
 		end
+		trace
 		assignAllJobs
 	end
 
-	def fight_assign(man)
+	def assign(man)
 		if man.is_a?(AntHouse)
 			man.newRestJob(20)
 			return
 		end
 
+		if @won or @lost
+			man.newRestJob(20)
+			return
+		end
+
+
 		if man.hlJobMode[:defeated]
 			# FIXME:send away
 			# FIXME: maybe flee ?
@@ -473,18 +634,22 @@
 			man.hlJobMode[:defeated]=true
 			man.hlJobMode.delete(:fighting)
 		else
+			puts ".canFight:#{man.canFight} #{man.getEnergy} #{man.getMorale}"
+			assert{man.canFight}
+
 			opponent=@fightData.getNewOpponent(man,self)
 			if opponent.nil?
 				# won
 				@won=true
 			else
+				assert{man.canFight and opponent.canFight}
 				man.hlJobMode[:fightTarget]=opponent
 				man.newFightJob(0,man.hlJobMode[:fightTarget])
 			end
 		end
 	end
 
-	def fight_leave
+	def leave
 		if lost
 			@fightData.removeLost(self)
 		else
@@ -502,15 +667,18 @@
 		}
 	end
 
-	def fight_ready
+	def ready
+		return true if @ready
 		if won 
-			eventWon(target)
-			return true
+			@won=true
+			machine.eventWon(target)
+			@ready=true
 		elsif lost
-			eventLost(target)
-			return true
+			@lost=true
+			machine.eventLost(target)
+			@ready=true
 		end
-		return false
+		return @ready
 	end
 
 	def lost
@@ -518,18 +686,22 @@
 	end
 
 	def undefeatedMen
-		allMen.select{|man|man.hlJobMode[:defeated].nil?}
+		allMen.select{|man|man.hlJobMode[:defeated].nil? && man.canFight}
 	end
 
 	private
 	# return true if fightData already exists
 	def checkForFightData
+		trace
+		puts "TARGET #{target}"
 		if target.hlJobMode[:fightData]
+			trace
 			@fightData=target.hlJobMode[:fightData]
 			@fightData.add(self)
 			@fightType=@fightData.getFightType(self)
 			return true
 		else
+			trace
 			@fightData=HLJob_FightData.new(self)
 			@fightType=:attacker
 		end
@@ -538,6 +710,7 @@
 	end
 	def assignAllJobs
 		# FIXME:assign a fight-job to every member (undefeatedMen)
+		trace
 
 		undefeatedMen.each{|man|
 			assert{not man.hlJobMode[:fightTarget].nil?}
@@ -549,8 +722,8 @@
 	end
 end
 
-module HLJob_Recruit
-	def recruit_enter
+class HLJob_Recruit<HLJob_BaseState
+	def enter
 	end
 	
 	private

Modified: antargis/branches/new_hl_jobs/ruby/ant_hljobs.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_hljobs.rb	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/ruby/ant_hljobs.rb	2007-04-29 17:39:46 UTC (rev 1075)
@@ -825,6 +825,7 @@
 	attr_reader :finished
 	def initialize(hero,target)
 		super(hero,0,target.getPos2D,4)
+		assert{target.is_a?(AntWorkshop)}
 		@target=target
 		@usedmen=0
 		@restype={}
@@ -1120,5 +1121,5 @@
 	return false
 end
 
-#require 'ant_new_hljobs.rb'
+require 'ant_new_hljobs.rb'
 

Modified: antargis/branches/new_hl_jobs/ruby/ant_local.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_local.rb	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/ruby/ant_local.rb	2007-04-29 17:39:46 UTC (rev 1075)
@@ -52,7 +52,11 @@
 		read
 	end
 	def process(x)
-		x=x.gsub("\n","\\n")
+		if x.is_a?(AGStringUtf8)
+			x=x.replace(AGStringUtf8.new("\n"),AGStringUtf8.new("\\n"))
+		else
+			x=x.gsub("\n","\\n")
+		end
 		r=myprocess(x)
 		#puts "TRANSLATE: #{x} #{r.class}"
 		return r

Modified: antargis/branches/new_hl_jobs/ruby/ant_man.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_man.rb	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/ruby/ant_man.rb	2007-04-29 17:39:46 UTC (rev 1075)
@@ -110,6 +110,7 @@
 			@signed=true
 		end
 		if @boss
+			assert{@boss.getEnergy>0}
 			@boss.assignJob(self)
 		end
 	end	

Modified: antargis/branches/new_hl_jobs/ruby/ant_manbase.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_manbase.rb	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/ruby/ant_manbase.rb	2007-04-29 17:39:46 UTC (rev 1075)
@@ -111,11 +111,13 @@
 	def eventNoJob
 		if @meshState=="dead"
 			getMap.removeEntity(self)
+			return
 		end
 		super
 	end
 
 	def eventDie
+		assert{@dead!=true}
 		simDeath
 		#eventDefeated
 		newRestJob(20)

Modified: antargis/branches/new_hl_jobs/ruby/ant_new_hljobs.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_new_hljobs.rb	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/ruby/ant_new_hljobs.rb	2007-04-29 17:39:46 UTC (rev 1075)
@@ -18,10 +18,6 @@
 	return true
 end
 
-# 
-# FIXME: * add path-finding to moving
-#        * do FIXME s ;-)
-
 module HLJob
 	def hero
 		@hero
@@ -36,16 +32,21 @@
 
 
 class AntNewHLRestJob<AntNewHLJob
-	include HLJob_FormatSit
-	include HLJob_SitDown
-	include HLJob_JustSitOnce
-	include HLJob_SpreadThings
+	state :formatSit=>HLJob_FormatSit
+	state :sitDown=>HLJob_SitDown
+	state :justSitOnce=>HLJob_JustSitOnce
+	state :spreadThings=>HLJob_SpreadThings
 
+	startState :formatSit
+	edge :formatSit, :sitDown
+	edge :sitDown,:justSitOnce
+	edge :justSitOnce,:spreadThings,:checkSpread
+	edge :justSitOnce,:justSitOnce,:notCheckSpread
+	edge :spreadThings,:formatSit,:lastSpread
+
 	SPREAD_CHECK_TIME=10 # all 10 seconds spread things
 
 	def initialize(hero,time)
-		@state=:FormatSit
-		@workflow=[[:FormatSit,:SitDown],[:SitDown,:CheckSpread],[:SpreadThings,:FormatSit],[:JustSitOnce,:CheckSpread]] #JustSit],[:JustSit]
 		super(hero)
 	end
 	def image
@@ -56,50 +57,48 @@
 		RestMessage.new(boss, at time)
 	end
 
-	def sitDown_leave
-		if @spreadOnce.nil?
-			@spreadTime=getTime-SPREAD_CHECK_TIME
-			@spreadOnce=true
-		else
-			@spreadTime=getTime
-		end
+	def lastSpread
+		@spreadTime=getTime
+		true
 	end
-	
 
-	def checkSpread_enter
+	def checkSpread
 		curTime=getTime
+		puts "SPREADTIME: #{@spreadTime}   getTime:#{curTime}"
+		return true if @spreadTime.nil?
 		puts "#{curTime- at spreadTime}>#{SPREAD_CHECK_TIME}"
-		if curTime- at spreadTime>SPREAD_CHECK_TIME
-			switchToState(:SpreadThings)
-		else
-			switchToState(:JustSitOnce)
-		end
+		return curTime- at spreadTime>SPREAD_CHECK_TIME
 	end
+
+	def notCheckSpread
+		not checkSpread
+	end
+		
 end
 
+AntHeroRestJobOld=AntHeroRestJob
+AntHeroRestJob=AntNewHLRestJob
+
+
+
 class AntNewHLMoveJob<AntNewHLJob
-	include HLJob_FormatWalk
-	include HLJob_MoveToNextWayPoint
-	include HLJob_FormatSit
-	include HLJob_SitDown
-	# FIXME: time is irrelevant here!
-	#def initialize(hero,time)
+	state :moveComplete=>	HLJob_MoveComplete
+	state :endState => HLJob_DummyState
 
-	attr_reader :targetPos
+	startState :moveComplete
+	endState :endState
 
+	edge :moveComplete,:endState
+
+	attr_accessor :targetPos
+	attr_accessor :formatDir
+
 	def initialize(hero,prio,pos,dist,doFormat=true)
 		@targetPos=pos.dim2
-		if doFormat
-			@state=:FormatWalk
-		else
-			@state=:MoveToNextWayPoint
+		super(hero)
+		if not doFormat
+			state.moveDirectly			
 		end
-		@workflow=[
-			[:FormatWalk,:MoveToNextWayPoint],
-# 			[:MoveToNextWayPoint,:FormatSit],
-# 			[:FormatSit,:SitDown]
-		]
-		super(hero)
 	end
 	# FIXME: move this to a config-file !
 	def image
@@ -112,30 +111,37 @@
 
 end
 
+AntHeroMoveJobOld=AntHeroMoveJob
+AntHeroMoveJob=AntNewHLMoveJob
 
+
+
+
+
 class AntNewHLTakeJob<AntNewHLJob
-	include HLJob_FormatWalk
-	include HLJob_FetchStart
-	include HLJob_GetResource
-	include HLJob_MoveToNextWayPoint
+	state :fetchStart => HLJob_FetchStart
+	state :getResource => HLJob_GetResource
+	state :move =>HLJob_MoveComplete
+	state :moveBack => HLJob_MoveComplete
+	state :endState => HLJob_DummyState
 
-	attr_reader :resources, :targetPos, :near, :target
+	startState :move
+	endState :endState
 
+	edge :move,:fetchStart,:fetchStart
+	edge :fetchStart,:getResource,:gettingResource
+	edge :getResource, :moveBack
+	edge :moveBack, :endState
+
+	attr_accessor :targetPos, :near, :target
+
 	def initialize(phero,target,what="food")
-		@resources={"food"=>["food"],"weapon"=>["sword","bow","boat","shield"]}[what]
 
-		@state=:FormatWalk
-		@workflow=[
-			[:FormatWalk,:MoveToNextWayPoint],
-			[:MoveToNextWayPoint,:MyStore],
-			[:MyStore,:FetchStart],
-			[:FetchStart,:GetResource],
-			[:GetResource,:MoveToNextWayPoint]
-		]
 		@targetPos=target.getPos2D
 		@target=target
-		@near=4
 		super(phero)
+		@states[:move].near=4
+		@states[:getResource].resources={"food"=>["food"],"weapon"=>["sword","bow","boat","shield"]}[what]
 	end
 
 	def image
@@ -146,37 +152,32 @@
 		end
 	end
 
-
-	def myStore_enter
-		trace
-		if @taken
-			@finished=true
-			return 
-		end
+	def fetchStart
 		@targetPos=hero.getPos2D
-		puts "#{@targetPos} #{hero.getPos2D}"
-		@near=0
-		@taken=true
+		true
 	end
+	def gettingResource
+		true
+	end
 end
 
+AntHeroTakeJobOld=AntHeroTakeJob
+AntHeroTakeJob=AntNewHLTakeJob
+
+
+
+
 class AntNewHLKillAnimal<AntNewHLTakeJob
-	def fetchStart_leave
+	inheritMachine
+
+	def gettingResource
 		# kill animal
 		playSound
 		killAnimal
+		super
 	end
 
 	
-	def myStore_enter
-		if @taken
-			@finished=true
-			return 
-		end
-		# no need to return to separate position
-		@taken=true
-	end
-
 	private
 	def playSound
 		# FIXME: play eat sound
@@ -186,30 +187,41 @@
 		hero.resource.takeAll(target.resource)
 	end
 end
+AntHeroFightAnimalJobOld=AntHeroFightAnimalJob
+AntHeroFightAnimalJob=AntNewHLKillAnimal
 
+
+
 class AntNewHLFight<AntNewHLJob
-	include HLJob_FormatWalk
-	include HLJob_MoveToNextWayPoint
-	include HLJob_Fight
+	state :move=>HLJob_MoveComplete
+	state :fight=>HLJob_Fight
+	state :endState=>HLJob_DummyState
 
-	attr_reader :targetPos,:near,:target
+	edge :move,:fight
+	edge :fight,:endState
 
+	startState :move
+	endState :endState
+
+	attr_accessor :targetPos,:near,:target
+
 	def initialize(hero,target,defend=false)
+		@targetPos=target.getPos2D
 		@target=target
+		puts "DEFEND #{defend}"
 		if defend
-			@state=:Fight
-			@workflow=[]
-			#trace
+			trace
+			super(hero,:fight)
+			trace
 		else
-			@state=:FormatWalk
-			@targetPos=target.getPos2D
-			@near=10
-			@workflow=[
-				[:FormatWalk,:MoveToNextWayPoint],
-				[:MoveToNextWayPoint,:Fight]
-			]
+			trace
+			super(hero)
+			trace
 		end
-		super(hero)
+		assert{@state==:fight || defend==false}
+		@states[:move].near=10
+
+		puts "STATE #{state}"
 	end
 
 	def image
@@ -219,8 +231,7 @@
 	def eventWon(opponent)
 	end
 	def eventLost(opponent)
-		@finished=true
-		hero.setOwner(opponent) #.getPlayer)
+		hero.setOwner(opponent)
 	end
 
 
@@ -228,17 +239,15 @@
 
 # rename and replace old hl-jobs
 
-AntHeroRestJobOld=AntHeroRestJob
-AntHeroRestJob=AntNewHLRestJob
 
-AntHeroMoveJobOld=AntHeroMoveJob
-AntHeroMoveJob=AntNewHLMoveJob
 
-AntHeroTakeJobOld=AntHeroTakeJob
-AntHeroTakeJob=AntNewHLTakeJob
 
-AntHeroFightAnimalJobOld=AntHeroFightAnimalJob
-AntHeroFightAnimalJob=AntNewHLKillAnimal
+# AntHeroFightAnimalJobOld=AntHeroFightAnimalJob
+# AntHeroFightAnimalJob=AntNewHLKillAnimal
+# 
+AntHeroFightJobOld=AntHeroFightJob
+AntHeroFightJob=AntNewHLFight
 
-AntHeroFightJobOld=AntHeroFightJob
-AntHeroFightJob=AntNewHLFight
\ No newline at end of file
+if false
+
+end
\ No newline at end of file

Modified: antargis/branches/new_hl_jobs/ruby/antargislib.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/antargislib.rb	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/ruby/antargislib.rb	2007-04-29 17:39:46 UTC (rev 1075)
@@ -136,6 +136,8 @@
 						@@opengl=false
 					when "demo"
 						$demoMode=true
+					when "ruby-raise"
+						setRubyRaising(true)
 					when "gui-test"
 						require 'ruby/tests/gui_tests.rb'
 						@@cursorEnabled=true
@@ -162,6 +164,8 @@
 	--debug-level=x
 
 	--nogl         disable GL-mode (3d-acceleration) - THIS IS NOT YET FULLY SUPPORTED!!
+
+	--ruby-raise   raises ruby-exception when assertions fail
 	"
 	
 						exit

Modified: antargis/branches/new_hl_jobs/src/entity.cc
===================================================================
--- antargis/branches/new_hl_jobs/src/entity.cc	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/src/entity.cc	2007-04-29 17:39:46 UTC (rev 1075)
@@ -339,6 +339,7 @@
 {
   if(!isStarving())
     {
+      assert(mEnergy>0);
       mEnergy+=pTime*getHealSpeed()*0.8; // only rest til 1.0
       if(mEnergy>1.0)
 	mEnergy=1.0;
@@ -469,31 +470,40 @@
 }
 void AntEntity::newFetchJob(int p,AGVector2 &pTarget,const AGString &what)
 {
+  assert(getEnergy()>0);
   setJob(new FetchJob(p,pTarget,what));
 }
 void AntEntity::newFetchJob(int p,AntEntity *pTarget,const AGString &what)
 {
+  assert(getEnergy()>0);
   setJob(new FetchJob(p,pTarget,what));
 }
 void AntEntity::newMoveJob(int p,const AGVector2 &pTarget,float pnear)
 {
+  assert(getEnergy()>0);
   setJob(new MoveJob(p,pTarget,pnear));
 }
 void AntEntity::newMoveJob(int p,const AGVector3 &pTarget,float pnear)
 {
+  assert(getEnergy()>0);
   setJob(new MoveJob(p,pTarget,pnear));
 }
 
 void AntEntity::newMoveJob(int p,AntEntity *pTarget,float pnear)
 {
+  assert(getEnergy()>0);
   setJob(new MoveJob(p,pTarget,pnear));
 }
 
 
 void AntEntity::newFightJob(int p,AntEntity *target,float distance)
 {
+  assert(target);
+  assert(target->canFight());
+  assert(canFight());
   if(!canFight())
     return;
+
   if(mJob)
     {
       FightJob *f=dynamic_cast<FightJob*>(mJob);
@@ -531,6 +541,7 @@
 
 void AntEntity::decEnergy(float amount)
 {
+  assert(mEnergy>0);
   mEnergy-=amount;
   if(mEnergy<0.0)
     {

Modified: antargis/branches/new_hl_jobs/src/jobs.cc
===================================================================
--- antargis/branches/new_hl_jobs/src/jobs.cc	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/src/jobs.cc	2007-04-29 17:39:46 UTC (rev 1075)
@@ -459,8 +459,11 @@
 }
 void RestJob::move(AntEntity *e,float ptime)
 {
-  e->incMorale(std::min(ptime,mTime));
-  e->heal(std::min(ptime,mTime));
+  if(e->getEnergy()>0) // check if still alive
+    {
+      e->incMorale(std::min(ptime,mTime));
+      e->heal(std::min(ptime,mTime));
+    }
   mTime-=ptime;
   if(mTime<0)
     jobFinished(e);

Modified: antargis/branches/new_hl_jobs/src/terrain.cc
===================================================================
--- antargis/branches/new_hl_jobs/src/terrain.cc	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/src/terrain.cc	2007-04-29 17:39:46 UTC (rev 1075)
@@ -4,6 +4,12 @@
 #include <ag_profiler.h>
 #include <ag_config.h>
 
+bool use3dTextures()
+{
+  return false;
+}
+
+
 //////////////////////////////////////////////////////////////////////////
 // TerrainPiece
 //////////////////////////////////////////////////////////////////////////
@@ -70,10 +76,19 @@
 
 	n=mMap->getNormal(sx,sy);
 
-	float texHeight=mMap->getTerrainScale(sx,sy);
+	if(use3dTextures())
+	  {
+	    float texHeight=mMap->getTerrainScale(sx,sy);
+	    
+	    tp3=AGVector3(-v[0]*texFactor3w,-v[1]*texFactor3w,texHeight);
+	    m3dArray.addVertex(v,white,n,tp3);
+	  }
+	else
+	  {
+	    tp=AGVector2(-v[0]*texFactor3w,-v[1]*texFactor3w);
+	    m3dArray.addVertex(v,white,n,tp);
+	  }
 
-        tp3=AGVector3(-v[0]*texFactor3w,-v[1]*texFactor3w,texHeight);
-        m3dArray.addVertex(v,white,n,tp3);
 
 	bb.include(v.dim3());
       }
@@ -133,8 +148,13 @@
   STACKTRACE;
   AGRenderContext c;
   c.setLighting(true);
-  c.setTexture(mTerrain->get3dTexture()->glTexture());
-  mTerrain->get3dTexture()->setFilter(GL_LINEAR,GL_LINEAR);
+  if(use3dTextures())
+    {
+      c.setTexture(mTerrain->get3dTexture()->glTexture());
+      mTerrain->get3dTexture()->setFilter(GL_LINEAR,GL_LINEAR);
+    }
+  else
+    c.setTexture(mTerrain->getGrassTexture()->glTexture());
 
   c.begin();
 

Modified: antargis/branches/new_hl_jobs/src/vertex_array.cc
===================================================================
--- antargis/branches/new_hl_jobs/src/vertex_array.cc	2007-04-23 18:01:28 UTC (rev 1074)
+++ antargis/branches/new_hl_jobs/src/vertex_array.cc	2007-04-29 17:39:46 UTC (rev 1075)
@@ -37,8 +37,9 @@
   mBuffers=GLEE_ARB_vertex_buffer_object && useVBO();
   mArrays=GLEE_EXT_vertex_array && useVertexArrays();
 
-  if(videoInited())
-    assert(GLEE_EXT_vertex_array);
+  // vertex-arrays are standard from opengl 1.1 - so don't check
+  //  if(videoInited())
+  //    assert(GLEE_EXT_vertex_array);
 
   displayListInited=false;
 



From davidkamphausen at mail.berlios.de  Sun Apr 29 19:41:39 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 29 Apr 2007 19:41:39 +0200
Subject: [Antargis-svn] r1076 - in antargis/branches/new_hl_jobs/ruby: .
	tests
Message-ID: <200704291741.l3THfdTL019782@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-04-29 19:41:38 +0200 (Sun, 29 Apr 2007)
New Revision: 1076

Added:
   antargis/branches/new_hl_jobs/ruby/ant_state_machine.rb
   antargis/branches/new_hl_jobs/ruby/tests/impostor.rb
Log:
* added missing files


Added: antargis/branches/new_hl_jobs/ruby/ant_state_machine.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/ant_state_machine.rb	2007-04-29 17:39:46 UTC (rev 1075)
+++ antargis/branches/new_hl_jobs/ruby/ant_state_machine.rb	2007-04-29 17:41:38 UTC (rev 1076)
@@ -0,0 +1,174 @@
+class BaseState
+	@@states={}
+	@@edges={}
+	@@endstates={}
+	@@startstate={}
+	def BaseState.state(p)
+		s=@@states[self]
+		s||={}
+		p.each{|k,v|s[k]=v}
+		@@states[self]=s
+	end
+	def BaseState.edge(v0,v1,f=nil)
+		@@edges[self]||=[]
+		@@edges[self]<<[v0,v1,f]
+	end
+	def BaseState.startState(s)
+		puts "setting startstate for #{self}:#{s}"
+		@@startstate[self]=s
+	end
+	def BaseState.endState(s)
+		@@endstates[self]||=[]
+		@@endstates[self].push(s)
+	end
+
+	def BaseState.inheritMachine
+		me=ancestors[0]
+		anc=ancestors[1]
+		@@states[me]=@@states[anc].dup
+		@@edges[me]=@@edges[anc].dup
+		@@endstates[me]=@@endstates[anc].dup
+		@@startstate[me]=@@startstate[anc]
+	end
+	
+	def initialize(startState=nil)
+		@states={}
+		@@states[self.class].each{|k,v|@states[k]=v.new;@states[k].machine=self}
+		@state=startState
+		@state||=@@startstate[self.class]
+		@firstRun=false
+	end
+	
+	def ready
+		return true if @state.nil?
+		if @@endstates[self.class]
+			if @@endstates[self.class].length>0
+				return true if @@endstates[self.class].member?(@state)
+			end
+		end
+		return false
+	end		
+
+	def advance
+		if @states.length==0
+			puts "no states here"
+			return
+		end
+		if hasState
+			stepState
+		end
+	end
+
+	def firstCall
+		enterRecursive
+	end
+
+	def hasState
+		if @state
+			return (not @states[@state].nil?)
+		end
+		false
+	end
+
+	def state
+		if @state
+			if @states[@state]
+				return @states[@state]
+			end
+		end
+		raise "no state defined!"
+	end
+
+	def stateCall(*s)
+		if @state
+			if @states[@state]
+				puts "(#{s})(#{s[0]})"
+				if @states[@state].respond_to?(s[0])
+					@states[@state].send(*s) #(s[1..-1]))
+				end
+			end
+		end
+	end
+
+protected
+	def enterRecursive(selftoo=true)
+		puts "#{self}:enterRecursive"
+
+		if self.respond_to?("enter") and selftoo
+			puts "#{self}:enterRecursive - enter..."
+			enter
+			puts "#{self}:enterRecursive - enter.ok"
+		end
+
+		puts "#{self}:enterRecursive - hasState:#{hasState}"
+		if hasState
+			puts "#{self}:enterRecursive - respond_to(enterRec):#{state.respond_to?("enterRecursive")}"
+			puts "#{self}:enterRecursive - state:#{state}"
+			if state.respond_to?("enterRecursive")
+				state.enterRecursive
+			else
+				puts "#{self}:enterRecursive - statecall-enter..."
+				stateCall("enter")
+			end
+		end
+	end
+
+private
+	def stepState
+		assert {hasState}
+		stateCall("advance")
+		if state.ready
+			toNextState
+		else
+			true
+		end
+	end
+	
+	def toNextState
+		puts "#{self} toNextState:#{@state}:#{state}"
+		nstate=nil
+		@@edges[self.class].each{|e|
+			if e[0]==@state
+				ok=true
+				if not e[2].nil?
+					ok=self.send(e[2]) #.call
+				end
+				if ok
+					nstate=e[1]
+				end
+			end
+		}
+		if nstate
+			switch2(nstate)
+			return true
+		elsif @@endstates[self.class].member?(@state)
+			switch2(nil)
+		end
+		false
+	end
+	
+	def left
+		@firstRun=false
+	end
+		
+	def switch2(s)
+		stateCall("leave")
+		stateCall("left")
+		@state=s
+		#stateCall("enterRecursive")
+		enterRecursive(false)
+	end
+end
+
+class BaseMachine<BaseState
+# 	def initialize(start=nil)
+# 		super(start)
+# 		if start.nil?
+# 			@state=@@startstate[self.class]
+# 			puts "startstate: #{@@startstate[self.class]}"
+# 		else
+# 			@state=start
+# 		end
+# 	end
+end
+

Added: antargis/branches/new_hl_jobs/ruby/tests/impostor.rb
===================================================================
--- antargis/branches/new_hl_jobs/ruby/tests/impostor.rb	2007-04-29 17:39:46 UTC (rev 1075)
+++ antargis/branches/new_hl_jobs/ruby/tests/impostor.rb	2007-04-29 17:41:38 UTC (rev 1076)
@@ -0,0 +1,40 @@
+#!/usr/bin/env ruby
+
+require 'ruby/antargislib.rb'
+
+
+
+class MyApp<GLApp
+	def initialize(w,h)
+		super
+		#node=Mesh.new(getScene,getMeshData("data/models/sack.ant2",0.3,"data/textures/models/sack.png"),AGVector4.new(0,0,0),0)
+		node=Mesh.new(getScene,getMeshData("data/models/workshop.ant2",0.18,"data/textures/models/workshop.png"),AGVector4.new(0,0,0),-50)
+
+		getScene.addNode(node)
+
+		imp=AntImpostorData.new(node)
+
+		tex=imp.getTexture
+			
+		image=AGImage.new(nil,AGRect2.new(0,0,tex.width,tex.height),tex,false)
+		setMainWidget(image)
+		
+		getScene.removeNode(node)
+	end
+
+	def eventFrame(t)
+		#imp=
+		delay(100)
+	puts t
+		return true
+	end
+
+#  	def draw(p)
+#  		p.blit(imp.getTexture)
+#  	end
+end
+
+#app=MyApp.new(128,128) #800,600)
+app=MyApp.new(1024,768) #800,600)
+
+app.run



From davidkamphausen at mail.berlios.de  Sun Apr 29 20:10:26 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 29 Apr 2007 20:10:26 +0200
Subject: [Antargis-svn] r1077 - antargis/branches
Message-ID: <200704291810.l3TIAQoi021394@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-04-29 20:10:26 +0200 (Sun, 29 Apr 2007)
New Revision: 1077

Added:
   antargis/branches/branch_2d/
Log:
A    svn+ssh://davidkamphausen at svn.berlios.de/svnroot/repos/antargis/antargis/branches/branch_2d


Copied: antargis/branches/branch_2d (from rev 1076, antargis/trunk)



From davidkamphausen at mail.berlios.de  Sun Apr 29 20:31:00 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 29 Apr 2007 20:31:00 +0200
Subject: [Antargis-svn] r1078 - in antargis/branches/branch_2d: .
	data/textures/models ruby ruby/editor src
Message-ID: <200704291831.l3TIV0t1023266@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-04-29 20:30:58 +0200 (Sun, 29 Apr 2007)
New Revision: 1078

Added:
   antargis/branches/branch_2d/data/textures/models/mine2.png
   antargis/branches/branch_2d/data/textures/models/tower.png
Removed:
   antargis/branches/branch_2d/data/textures/models/mine.png
   antargis/branches/branch_2d/data/textures/models/tower_new.png
Modified:
   antargis/branches/branch_2d/Rakefile
   antargis/branches/branch_2d/editor.rb
   antargis/branches/branch_2d/ruby/ant_arrow.rb
   antargis/branches/branch_2d/ruby/ant_bakery.rb
   antargis/branches/branch_2d/ruby/ant_boat.rb
   antargis/branches/branch_2d/ruby/ant_buildingsite.rb
   antargis/branches/branch_2d/ruby/ant_decal.rb
   antargis/branches/branch_2d/ruby/ant_deco.rb
   antargis/branches/branch_2d/ruby/ant_druid.rb
   antargis/branches/branch_2d/ruby/ant_dwelling.rb
   antargis/branches/branch_2d/ruby/ant_fir.rb
   antargis/branches/branch_2d/ruby/ant_fish.rb
   antargis/branches/branch_2d/ruby/ant_mill.rb
   antargis/branches/branch_2d/ruby/ant_mine.rb
   antargis/branches/branch_2d/ruby/ant_models.rb
   antargis/branches/branch_2d/ruby/ant_sheep.rb
   antargis/branches/branch_2d/ruby/ant_sound.rb
   antargis/branches/branch_2d/ruby/ant_tower.rb
   antargis/branches/branch_2d/ruby/ant_townhall.rb
   antargis/branches/branch_2d/ruby/ant_tree.rb
   antargis/branches/branch_2d/ruby/ant_well.rb
   antargis/branches/branch_2d/ruby/ant_wolf.rb
   antargis/branches/branch_2d/ruby/ant_workshop.rb
   antargis/branches/branch_2d/ruby/editor/ent_list.rb
   antargis/branches/branch_2d/src/ant_app.cc
   antargis/branches/branch_2d/src/antargisgui.h
   antargis/branches/branch_2d/src/impostor.cc
   antargis/branches/branch_2d/src/nantmarker.hh
   antargis/branches/branch_2d/src/path.cc
   antargis/branches/branch_2d/src/path.h
   antargis/branches/branch_2d/src/scene.cc
   antargis/branches/branch_2d/src/scene.h
   antargis/branches/branch_2d/src/scenenode.cc
   antargis/branches/branch_2d/src/scenenode.h
Log:
* started 2d-branch


Modified: antargis/branches/branch_2d/Rakefile
===================================================================
--- antargis/branches/branch_2d/Rakefile	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/Rakefile	2007-04-29 18:30:58 UTC (rev 1078)
@@ -33,7 +33,7 @@
 
 
 interfaceHeadersSRC=["ant_frustum.h","ant_projection.h","ant_camera.h",
-"scenenode.h","anim_mesh.h","anim_mesh_data.h","ant_app.h","entity.h","entptr.h","glsl.h","height_map.h","map.h","mesh_data.h","mesh.h","mesh_optimizer.h","minimap.h","new_decal.h","ant_renderer.h","resource.h","scene.h","smoke.h","terrain.h","vertex_array.h","water.h","path.h","impostor.h"]
+"scenenode.h","anim_mesh.h","anim_mesh_data.h","ant_app.h","entity.h","entptr.h","glsl.h","height_map.h","map.h","mesh_data.h","mesh.h","mesh_optimizer.h","minimap.h","new_decal.h","ant_renderer.h","resource.h","scene_base.h","scene.h","smoke.h","terrain.h","vertex_array.h","water.h","path.h","impostor.h"]
 interfaceHeadersGUI=[
 "ag_rubyobj.h","ag_messageobject.h","ag_serial.h","ag_aes.h","ag_singleton.h",
  "ag_geometry.h","ag_font.h","ag_color.h","ag_local.h","ag_config.h","ag_string.h","ag_string_utf8.h",

Deleted: antargis/branches/branch_2d/data/textures/models/mine.png
===================================================================
(Binary files differ)

Copied: antargis/branches/branch_2d/data/textures/models/mine2.png (from rev 1077, antargis/branches/branch_2d/data/textures/models/mine.png)

Copied: antargis/branches/branch_2d/data/textures/models/tower.png (from rev 1077, antargis/branches/branch_2d/data/textures/models/tower_new.png)

Deleted: antargis/branches/branch_2d/data/textures/models/tower_new.png
===================================================================
(Binary files differ)

Modified: antargis/branches/branch_2d/editor.rb
===================================================================
--- antargis/branches/branch_2d/editor.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/editor.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -44,7 +44,7 @@
 	def initialize(sw,sh)
 		super(sw,sh,nil) #AntRubyMap.new(64,64))
 		$app=self	
-		$map=@map=AntRubyMap.new(getScene,128,128)
+		$map=@map=AntRubyMap.new(self,getScene,128,128)
 		$map.setHeight(-0.5)
 
 		addHandler(@layout.getChild("quit"),:sigClick,:eventQuit)

Modified: antargis/branches/branch_2d/ruby/ant_arrow.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_arrow.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_arrow.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -26,7 +26,8 @@
 	def initialize
 		super(AGVector2.new(0,0))
 		@typeID=(getRand*2).to_i
-		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/arrow.ant2",0.1,"data/textures/models/arrow.png"),AGVector4.new(0,0,0,0),getRand*360))
+		setMesh(createModel(:arrow))
+# 		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/arrow.ant2",0.1,"data/textures/models/arrow.png"),AGVector4.new(0,0,0,0),getRand*360))
 		setSpeed(10)
 	end
 	def eventNoJob

Modified: antargis/branches/branch_2d/ruby/ant_bakery.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_bakery.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_bakery.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -13,9 +13,10 @@
 	end
 	
 	def setupMesh
-		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/ant_bakery.ant2",3.2,"data/textures/models/ant_bakery.png"),AGVector4.new(0,0,0),-30)
+		setMesh(createModel(:bakery))
+		#		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/ant_bakery.ant2",3.2,"data/textures/models/ant_bakery.png"),AGVector4.new(0,0,0),-30)
 		#mesh=Mesh.new(getMap.getScene,getMeshData("data/models/townhall.ant2",3.2,"data/textures/models/townhall.png"),AGVector4.new(0,0,0),-30)
-		setMesh(mesh)
+		#setMesh(mesh)
 		p=AGVector3.new(0,1.6,2.2)
 		addMesh(@smokeMesh=Smoke.new(getMap.getScene,5),p)
 		checkSmoke

Modified: antargis/branches/branch_2d/ruby/ant_boat.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_boat.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_boat.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -10,7 +10,8 @@
 	end
 private
 	def setupMesh
-		mesh=Mesh.new(getMap.getScene,getBoatMeshData,AGVector4.new(0,0,0),0)
-		setMesh(mesh)
+# 		mesh=Mesh.new(getMap.getScene,getBoatMeshData,AGVector4.new(0,0,0),0)
+# 		setMesh(mesh)
+		setMesh(createModel(:boat))
 	end
 end
\ No newline at end of file

Modified: antargis/branches/branch_2d/ruby/ant_buildingsite.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_buildingsite.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_buildingsite.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -13,14 +13,14 @@
 	def incProgress(steps)
 		@steps=steps
 		o=@progress.to_i
-		@progress+=(1.0/steps)*(@@buildingSiteMeshes.length-1)
+		@progress+=(1.0/steps)*getMeshCount(:buildingsite) #(@@buildingSiteMeshes.length-1)
 		if o!=@progress.to_i
 			setupMesh
 		end
 		@doneSth=true
 	end
 	def ready
-		@progress>@@buildingSiteMeshes.length-1
+		@progress>getMeshCount(:buildingsite) #@@buildingSiteMeshes.length-1
 	end
 
 	# removes building site if nothing was done in some time
@@ -46,25 +46,27 @@
 
 	private
 	def setupMesh
+		setMesh(createModel(:buildingsite, at progress.to_i))
 		
-		mesh=Mesh.new(getMap.getScene,AntBuildingSite.getBuildingSiteMeshData(@progress),AGVector4.new(0,0,0),-10)
-		setMesh(mesh)
+# 		mesh=Mesh.new(getMap.getScene,AntBuildingSite.getBuildingSiteMeshData(@progress),AGVector4.new(0,0,0),-10)
+# 		setMesh(mesh)
 	end
 
-	@@buildingSiteMeshes=nil
-	def AntBuildingSite.getBuildingSiteMeshData(size)
-		if @@buildingSiteMeshes.nil?
-			@@buildingSiteMeshes=[
-				getMeshData("data/models/building_site0.ant2",1.7,"data/textures/models/building_site0.png"),
-				getMeshData("data/models/building_site1.ant2",1.7,"data/textures/models/building_site1.png"),
-				getMeshData("data/models/building_site2.ant2",1.7,"data/textures/models/building_site1.png"),
-				getMeshData("data/models/crop_high.ant2",2.2,"data/textures/models/crop_gold.png")
-				]
-			
-		end
-		size=[0,size.to_i,@@buildingSiteMeshes.length-1].sort[1]
-		@@buildingSiteMeshes[size]
-	end
+# 	@@buildingSiteMeshes=nil
+# 	def AntBuildingSite.getBuildingSiteMeshData(size)
+# 		
+# 		if @@buildingSiteMeshes.nil?
+# 			@@buildingSiteMeshes=[
+# 				getMeshData("data/models/building_site0.ant2",1.7,"data/textures/models/building_site0.png"),
+# 				getMeshData("data/models/building_site1.ant2",1.7,"data/textures/models/building_site1.png"),
+# 				getMeshData("data/models/building_site2.ant2",1.7,"data/textures/models/building_site1.png"),
+# 				getMeshData("data/models/crop_high.ant2",2.2,"data/textures/models/crop_gold.png")
+# 				]
+# 			
+# 		end
+# 		size=[0,size.to_i,@@buildingSiteMeshes.length-1].sort[1]
+# 		@@buildingSiteMeshes[size]
+# 	end
 
 
 end

Modified: antargis/branches/branch_2d/ruby/ant_decal.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_decal.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_decal.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -23,7 +23,8 @@
 		super(AGVector2.new(0,0))
 		@typeID=(getRand()*2).to_i
 		setProvide("decal",true)
-		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/floor.ant2",0.8,"data/textures/gravel4.png",false),AGVector4.new(0,0,0,0),0))
+# 		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/floor.ant2",0.8,"data/textures/gravel4.png",false),AGVector4.new(0,0,0,0),0))	
+		setMesh(createModel(:floor_gravel))
 	end
 	def setTreeType(t)
 		@typeID=t

Modified: antargis/branches/branch_2d/ruby/ant_deco.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_deco.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_deco.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -43,7 +43,8 @@
 			@decoType=a[r]
 		end
 		setProvide("deco",true)
-		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/floor.ant2",0.5,"data/textures/splats/stones1a.png",false),AGVector4.new(0,0,0,0),0))
+		setMesh(createModel(:floor_deco))
+		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/floor.ant2",0.5,"data/textures/splats/stones1a.png",false),AGVector4.new(0,0,0,0),0))
 	end
 	def setDecoType(t)
 		@typeID=t
@@ -64,7 +65,9 @@
 		super(AGVector2.new(0,0))
 		@typeID=(getRand()*2).to_i
 		#setType("twig")
-		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/twig.ant2",0.7),AGVector4.new(0,0,0,0),getRand*360))
+		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/twig.ant2",0.7),AGVector4.new(0,0,0,0),getRand*360))
+		setMesh(mesh=createModel(:twig))
+		mesh.setRotation(getRand*360)
 	end
 end
 
@@ -74,8 +77,9 @@
 		@name=name
 # 		case name
 # 			else
-				setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/ant_coach.ant2",0.08,"data/textures/models/ant_coach.png"),AGVector4.new(0,0,0,0),-50))
+				#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/ant_coach.ant2",0.08,"data/textures/models/ant_coach.png"),AGVector4.new(0,0,0,0),-50))
 # 		end
+		setMesh(createModel(:coach))
 	end
 	def saveXML(node)
 		super

Modified: antargis/branches/branch_2d/ruby/ant_druid.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_druid.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_druid.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -23,9 +23,11 @@
 	def setupMesh
 		case @npcType
 			when "smith"
-	 			setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/smith_lp.ant2",0.08,"data/textures/models/smith_lp.png"),AGVector4.new(0,0,0,0),0))
+				setMesh(createModel(:smith))
+	 			#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/smith_lp.ant2",0.08,"data/textures/models/smith_lp.png"),AGVector4.new(0,0,0,0),0))
 			else
-	 			setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/druid_lp.ant2",0.08,"data/textures/models/druid_lp.png"),AGVector4.new(0,0,0,0),0))
+				setMesh(createModel(:druid))
+	 			#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/druid_lp.ant2",0.08,"data/textures/models/druid_lp.png"),AGVector4.new(0,0,0,0),0))
 		end
 	end
 end

Modified: antargis/branches/branch_2d/ruby/ant_dwelling.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_dwelling.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_dwelling.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -18,8 +18,9 @@
 
 	# setup the mesh
 	def setupMesh
-		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/livinghouse.ant2",0.16,"data/textures/models/livinghouse.png"),AGVector4.new(0,0,0),-20)
-		setMesh(mesh)
+		setMesh(createModel(:dwelling))
+# 		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/livinghouse.ant2",0.16,"data/textures/models/livinghouse.png"),AGVector4.new(0,0,0),-20)
+# 		setMesh(mesh)
 	end
 
 protected

Modified: antargis/branches/branch_2d/ruby/ant_fir.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_fir.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_fir.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -56,19 +56,22 @@
 	def setupMesh
 		#if resource.get("wood")<=0
 		#	data=getMeshData("data/models/stub.ant2",0.04,"data/textures/models/stub.png")
-		setMesh(Mesh.new(getMap.getScene,meshData,AGVector4.new,0))
-	end
-private
-	def meshData
-		if resource.get("wood")<=0
-			data=getMeshData("data/models/stub.ant2",0.04,"data/textures/models/stub.png")
-		else
-			data=getMeshData("data/models/fir2.ant2",0.45,"data/textures/models/fir7.png")
+# 		setMesh(Mesh.new(getMap.getScene,meshData,AGVector4.new,0))
+# 	end
+# private
+# 	def meshData
+		typeId="stub"
+		if resource.get("wood")>0
+			typeId=1
+# 			data=getMeshData("data/models/stub.ant2",0.04,"data/textures/models/stub.png")
+# 		else
+# 			data=getMeshData("data/models/fir2.ant2",0.45,"data/textures/models/fir7.png")
 		end
-		data.setTransparent(true)
-		data.setCulling(false) # patch for old trees
+		setMesh(createModel(:tree,typeId))
+		#data.setTransparent(true)
+		#data.setCulling(false) # patch for old trees
 
-		return data
+# 		return data
 	end
 end
 

Modified: antargis/branches/branch_2d/ruby/ant_fish.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_fish.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_fish.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -35,8 +35,9 @@
 
 		puts "FISH:#{getPos3D}"
 		
-		mesh=Mesh.new(getMap.getScene,getFishMeshData,AGVector4.new(0,0,0),0)
-		setMesh(mesh)
+		setMesh(createModel(:fish))
+		#mesh=Mesh.new(getMap.getScene,getFishMeshData,AGVector4.new(0,0,0),0)
+		#setMesh(mesh)
 
 		resource.set("food",1)
 		puts "FISH:#{getPos3D}"

Modified: antargis/branches/branch_2d/ruby/ant_mill.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_mill.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_mill.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -10,8 +10,9 @@
 	end
 	
 	def setupMesh
-		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/ant_mill.ant2",3.2,"data/textures/models/ant_mill.png"),AGVector4.new(0,0,0),-30)
-		setMesh(mesh)
+		setMesh(createModel(:mill))
+#		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/ant_mill.ant2",3.2,"data/textures/models/ant_mill.png"),AGVector4.new(0,0,0),-30)
+#		setMesh(mesh)
 	end
 
 	def neededStock

Modified: antargis/branches/branch_2d/ruby/ant_mine.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_mine.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_mine.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -38,7 +38,8 @@
 	
 	private
 	def setupMesh
-		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/mine2.ant2",0.2,"data/textures/models/mine.png"),AGVector4.new(0,0,0),-40))
+		setMesh(createModel(:mine))
+		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/mine2.ant2",0.2,"data/textures/models/mine.png"),AGVector4.new(0,0,0),-40))
 	end
 end
 

Modified: antargis/branches/branch_2d/ruby/ant_models.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_models.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_models.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -3,6 +3,15 @@
 
 def getStaticModelRotation(name)
 	rot={
+		"tower"=>-30,
+		"ant_mill"=>-30,
+		"mine2"=>-40,
+		"workshop"=>-50,
+		"townhall_try2"=>-60,
+		"well"=>-30,
+		"ant_bakery"=>-30,
+		"ant_coach"=>-50,
+		"livinghouse"=>-20
 	}
 
 	if rot.member?(name)
@@ -15,6 +24,22 @@
 	scales={
 		"sack"=>0.3,
 		"stub"=>0.04,
+		"tower"=>3,
+		"ant_mill"=>3.2,
+		"mine2"=>0.2,
+		"workshop"=>0.18,
+		"townhall_try2"=>3.2,
+		"well"=>0.06,
+		"rip"=>0.3,
+		"fish"=>0.02,
+		"arrow"=>0.1,
+		"ant_bakery"=>3.0,
+		"boat_simple"=>0.12,
+		"twig"=>0.7,
+		"ant_coach"=>0.08,
+		"druid_lp"=>0.08,
+		"smith_lp"=>0.08,
+		"livinghouse"=>0.16,
 	}
 
 	if scales.member?(name)
@@ -23,9 +48,7 @@
 	return 1
 end
 
-def createModel(entityType,subType=nil,angle=nil)
-	mesh=nil
-
+def getMeshMap
 	animMeshes={
 		:man=>{
 			["wood"]=>"data/models/man_e_wood.anim",
@@ -51,10 +74,89 @@
 			[7]=>["data/models/tree_simple1.ant2",0.3,"data/textures/models/tree_simple1.png"],
 			[8]=>["data/models/tree_simple2.ant2",0.3,"data/textures/models/tree_simple1.png"],
 			[9]=>["data/models/tree_simple5.ant2",0.3,"data/textures/models/tree_simple5.png"]
-		}
-
+		},
+		:buildingsite=>{
+			[0]=>["data/models/building_site0.ant2",1.7,"data/textures/models/building_site0.png"],
+			[1]=>["data/models/building_site0.ant2",1.7,"data/textures/models/building_site1.png"],
+			[2]=>["data/models/building_site2.ant2",1.7,"data/textures/models/building_site1.png"],
+		},
+		:tower=>{
+			[]=>"tower"
+		},
+		:wolf=>{
+			[]=>"ant_wolf"
+		},
+		:mill=>{
+			[]=>"ant_mill"
+		},
+		:mine=>{
+			[]=>"mine2"
+		},
+		:workshop=>{
+			[]=>"workshop"
+		},
+		:townhall=>{
+			[]=>"townhall_try2"
+		},
+		:well=>{
+			[]=>"well"
+		},
+		:rip=>{
+			[]=>"rip"
+		},
+		:fish=>{
+			[]=>"fish"
+		},
+		:sheep=>{
+			[]=>"data/models/sheep.anim"
+		},
+		:arrow=>{
+			[]=>"arrow"
+		},
+		:bakery=>{
+			[]=>"ant_bakery"
+		},
+		:boat=>{
+			[]=>"boat_simple"
+		},
+		:floor_deco=>{
+			[]=>["data/models/floor.ant2",0.5,"data/textures/splats/stones1a.png"],
+		},
+		:twig=>{	
+			[]=>"twig"
+		},
+		:coach=>{
+			[]=>"ant_coach"
+		},
+		:floor_gravel=>
+		{
+			[]=>["data/models/floor.ant2",0.8,"data/textures/gravel4.png"],
+		},
+		:druid=>
+		{
+			[]=>"druid_lp"
+		},
+		:smith=>
+		{
+			[]=>"smith_lp"
+		},	
+		:dwelling=>
+		{
+			[]=>"livinghouse"
+		},
+	
 	}
+end
 
+def getMeshCount(entityType)
+	getMeshMap[entityType].length
+end
+
+def createModel(entityType,subType=nil,angle=nil)
+	mesh=nil
+
+	animMeshes=getMeshMap
+
 	map=animMeshes[entityType]
 
 	map.each{|k,v|
@@ -75,6 +177,7 @@
 			data=getMeshData(ant2name,scale,pngname)
 			data.setCulling(culling)
 			data.setTransparent(true)
+			name=mesh
 			angle||=getStaticModelRotation(name)
 			scenenode=Mesh.new(getMap.getScene,data,AGVector4.new(0,0,0),angle)
 					
@@ -85,6 +188,10 @@
 			pngname="data/textures/models/"+mesh+".png"
 			name=mesh
 			angle||=getStaticModelRotation(name)
+			if not fileExists(pngname)
+				pngname=""
+			end
+
 			scenenode=Mesh.new(getMap.getScene,getMeshData(ant2name,getStaticModelScaling(name),pngname),AGVector4.new(0,0,0),angle)
 		end
 	end

Modified: antargis/branches/branch_2d/ruby/ant_sheep.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_sheep.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_sheep.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -33,8 +33,9 @@
 		@lastBirth=0
 		@foodAdd=0
 		
-		data=getAnimMeshData("data/models/sheep.anim")
-		setMesh(AnimMesh.new(getMap.getScene,data))
+		setMesh(createModel(:sheep))
+# 		data=getAnimMeshData("data/models/sheep.anim")
+# 		setMesh(AnimMesh.new(getMap.getScene,data))
 
 		resource.set("food",1)
 	end
@@ -108,7 +109,8 @@
 		"Sheep"
 	end
 	def eventDie
-		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/rip.ant2",0.3,"data/textures/models/rip.png"),AGVector4.new(0,0,0,0),0))
+		setMesh(createModel(:rip))
+		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/rip.ant2",0.3,"data/textures/models/rip.png"),AGVector4.new(0,0,0,0),0))
 		setProvide("sheep",false)
 		@dead=true
 		newRestJob(1)

Modified: antargis/branches/branch_2d/ruby/ant_sound.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_sound.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_sound.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -3,6 +3,7 @@
 	@@soundInited=false
 	@@loopSounds={}
 	@@ambientSound=nil
+	@@app=nil
 
 	def AntSound.setApplication(app)
 		@@app=app

Modified: antargis/branches/branch_2d/ruby/ant_tower.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_tower.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_tower.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -9,8 +9,7 @@
 	end
 	
 	def setupMesh
-		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/tower.ant2",3,"data/textures/models/tower_new.png"),AGVector4.new(0,0,0),-30)
-		setMesh(mesh)
+		setMesh(createModel(:tower))
 	end	
 	
 

Modified: antargis/branches/branch_2d/ruby/ant_townhall.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_townhall.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_townhall.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -33,8 +33,7 @@
 	end
 	
 	def setupMesh
-		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/townhall_try2.ant2",3.2,"data/textures/models/townhall_try2.png"),AGVector4.new(0,0,0),-60)
-		setMesh(mesh)
+		setMesh(createModel(:townhall))
 	end
 
 	def resourceChanged

Modified: antargis/branches/branch_2d/ruby/ant_tree.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_tree.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_tree.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -23,49 +23,50 @@
 require 'ant_grass.rb'
 
 
-def getTreeStub
-	getMeshData("data/models/stub.ant2",0.04,"data/textures/models/stub.png")
-end
+# def getTreeStub
+# 	getMeshData("data/models/stub.ant2",0.04,"data/textures/models/stub.png")
+# end
+# 
+# def getTreeTypes
+# 	files=[
+# 		getMeshData("data/models/fir2.ant2",0.45,"data/textures/models/fir5.png"),
+# 		getMeshData("data/models/fir2.ant2",0.45,"data/textures/models/fir7.png"),
+# #		getMeshData("data/models/tree5.ant2",0.45,"data/textures/models/fir5.png"),
+# 		getMeshData("data/models/tree5.ant2",0.45,"data/textures/models/tree3.png"),
+# 		getMeshData("data/models/tree5.ant2",0.45,"data/textures/models/tree5.png"),
+# 		getMeshData("data/models/tree5.ant2",0.45,"data/textures/models/tree9.png"),
+# 		getMeshData("data/models/tree6.ant2",0.45,"data/textures/models/tree5.png"),
+# 		#getMeshData("data/models/tree1.ant2",1,"data/textures/models/fir_complete.png"),
+# 		#getMeshData("data/models/tree1.ant2",1,"data/textures/models/birch_complete.png"),
+# 		getMeshData("data/models/tree5.ant2",0.45,"data/textures/models/tree10.png"),
+# 	]
+# 	files.each{|f|f.setCulling(false)} # patch for old trees
+# 	files+=[
+# 		getMeshData("data/models/tree_simple1.ant2",0.3,"data/textures/models/tree_simple1.png"),
+# 		getMeshData("data/models/tree_simple2.ant2",0.3,"data/textures/models/tree_simple1.png"),
+# 		getMeshData("data/models/tree_simple5.ant2",0.3,"data/textures/models/tree_simple5.png")
+# 	]
+# 
+# end
+# 
+# def getTreeMeshByType(type)
+# 	if type<0
+# 		return getTreeStub
+# 	end
+# 	d=getTreeTypes[type]
+# 	d||=getTreeTypes[0]
+# 	
+# 	d.setTransparent(true)
+# 	#d.setCulling(true) #false)
+# 	return d
+# end
 
-def getTreeTypes
-	files=[
-		getMeshData("data/models/fir2.ant2",0.45,"data/textures/models/fir5.png"),
-		getMeshData("data/models/fir2.ant2",0.45,"data/textures/models/fir7.png"),
-#		getMeshData("data/models/tree5.ant2",0.45,"data/textures/models/fir5.png"),
-		getMeshData("data/models/tree5.ant2",0.45,"data/textures/models/tree3.png"),
-		getMeshData("data/models/tree5.ant2",0.45,"data/textures/models/tree5.png"),
-		getMeshData("data/models/tree5.ant2",0.45,"data/textures/models/tree9.png"),
-		getMeshData("data/models/tree6.ant2",0.45,"data/textures/models/tree5.png"),
-		#getMeshData("data/models/tree1.ant2",1,"data/textures/models/fir_complete.png"),
-		#getMeshData("data/models/tree1.ant2",1,"data/textures/models/birch_complete.png"),
-		getMeshData("data/models/tree5.ant2",0.45,"data/textures/models/tree10.png"),
-	]
-	files.each{|f|f.setCulling(false)} # patch for old trees
-	files+=[
-		getMeshData("data/models/tree_simple1.ant2",0.3,"data/textures/models/tree_simple1.png"),
-		getMeshData("data/models/tree_simple2.ant2",0.3,"data/textures/models/tree_simple1.png"),
-		getMeshData("data/models/tree_simple5.ant2",0.3,"data/textures/models/tree_simple5.png")
-	]
-
-end
-
-def getTreeMeshByType(type)
-	if type<0
-		return getTreeStub
-	end
-	d=getTreeTypes[type]
-	d||=getTreeTypes[0]
-	
-	d.setTransparent(true)
-	#d.setCulling(true) #false)
-	return d
-end
-
 class AntTree<AntRubyEntity
 	def initialize(typeID=nil)
 		super(AGVector2.new(0,0))
 		@typeID=typeID
-		@typeID||=(getRand*getTreeTypes.length).to_i
+		#@typeID||=(getRand*getTreeTypes.length).to_i
+		@typeID||=(getRand*(getMeshCount(:tree)-1)).to_i
 		setProvide("wood",true)
 		setProvide("fruit",true)
 		@angle=getRand*360
@@ -108,7 +109,6 @@
 	
 	private
 	def setupMesh
-		#setMesh(Mesh.new(getMap.getScene,getTreeMeshByType(@typeID),AGVector4.new(0,0,0,0), at angle))
 		typeId="stub"
 		if @typeID>=0
 			typeId=@typeID%10

Modified: antargis/branches/branch_2d/ruby/ant_well.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_well.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_well.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -14,9 +14,7 @@
 	end
 	
 	def setupMesh
-		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/well.ant2",0.06,"data/textures/models/well.png"),AGVector4.new(0,0,0),-30)
-		#mesh=Mesh.new(getMap.getScene,getMeshData("data/models/townhall.ant2",3.2,"data/textures/models/townhall.png"),AGVector4.new(0,0,0),-30)
-		setMesh(mesh)
+		setMesh(createModel(:well))
 	end
 
 

Modified: antargis/branches/branch_2d/ruby/ant_wolf.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_wolf.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_wolf.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -42,10 +42,7 @@
 		@mypack=[]
 		@leader=nil
 		
-		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/ant_wolf.ant2",1,"data/textures/models/ant_wolf.png"),AGVector4.new(0,0,0),-30)
-		setMesh(mesh)
-		# data=getAnimMeshData("data/models/sheep.anim")
-		# setMesh(AnimMesh.new(getMap.getScene,data))
+		setMesh(createModel(:wolf))
 
 		resource.set("food",1)
 		@job=:resting
@@ -239,7 +236,8 @@
 		"Wolf"
 	end
 	def eventDie
-		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/rip.ant2",0.3,"data/textures/models/rip.png"),AGVector4.new(0,0,0,0),0))
+		setMesh(createModel(:rip))
+		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/rip.ant2",0.3,"data/textures/models/rip.png"),AGVector4.new(0,0,0,0),0))
 		@dead=true
 		
 		newRestJob(1)

Modified: antargis/branches/branch_2d/ruby/ant_workshop.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_workshop.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/ant_workshop.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -41,8 +41,7 @@
 	end
 	# sets up the mesh and adds a smoke-particle engine, which is disabled at first
 	def setupMesh
-		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/workshop.ant2",0.18,"data/textures/models/workshop.png"),AGVector4.new(0,0,0),-50)
-		setMesh(mesh)
+		setMesh(createModel(:workshop))
 		p=AGVector3.new(-1.3,-1.2,2.2)
 		addMesh(@smokeMesh=Smoke.new(getMap.getScene,5),p)
 		checkSmoke

Modified: antargis/branches/branch_2d/ruby/editor/ent_list.rb
===================================================================
--- antargis/branches/branch_2d/ruby/editor/ent_list.rb	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/ruby/editor/ent_list.rb	2007-04-29 18:30:58 UTC (rev 1078)
@@ -92,17 +92,19 @@
 end
 
 class AntEntListCreator<AGLayoutCreator
-	def initialize()
-		super("antEntList")
-	end
+# 	def initialize()
+# 		super("antEntList")
+# 	end
 	def create(parent,rect,node)
 		e=AntEntListWidget.new(parent,rect)
 		e.setName(node.get("name"))
 		puts node.get("name")
+		setResult e
 		#raise 1
-		return e
+		#return e
 	end
 end
+getLayoutFactory.addCreator("antEntList",AntEntListCreator.new)
 
 
-$antEntListCreator=AntEntListCreator.new
+#$antEntListCreator=AntEntListCreator.new

Modified: antargis/branches/branch_2d/src/ant_app.cc
===================================================================
--- antargis/branches/branch_2d/src/ant_app.cc	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/src/ant_app.cc	2007-04-29 18:30:58 UTC (rev 1078)
@@ -98,6 +98,10 @@
 	    }
 	}
     }
+  else
+    {
+      cdebug("click failed");
+    }
   return AGApplication::eventMouseButtonUp(e);
 }
 

Modified: antargis/branches/branch_2d/src/antargisgui.h
===================================================================
--- antargis/branches/branch_2d/src/antargisgui.h	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/src/antargisgui.h	2007-04-29 18:30:58 UTC (rev 1078)
@@ -78,6 +78,7 @@
 #include "../src/new_decal.h"
 #include "../src/ant_renderer.h"
 #include "../src/resource.h"
+#include "../src/scene_base.h"
 #include "../src/scene.h"
 #include "../src/smoke.h"
 #include "../src/terrain.h"
@@ -165,6 +166,7 @@
 %include "../src/new_decal.h"
 %include "../src/ant_renderer.h"
 %include "../src/resource.h"
+%include "../src/scene_base.h"
 %include "../src/scene.h"
 %include "../src/smoke.h"
 %include "../src/terrain.h"

Modified: antargis/branches/branch_2d/src/impostor.cc
===================================================================
--- antargis/branches/branch_2d/src/impostor.cc	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/src/impostor.cc	2007-04-29 18:30:58 UTC (rev 1078)
@@ -18,7 +18,7 @@
 
 
   assert(pNode);
-  Scene *pScene=pNode->getScene();
+  Scene *pScene=dynamic_cast<Scene*>(pNode->getScene());
   assert(pScene);
 
   pScene->initScene();

Modified: antargis/branches/branch_2d/src/nantmarker.hh
===================================================================
--- antargis/branches/branch_2d/src/nantmarker.hh	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/src/nantmarker.hh	2007-04-29 18:30:58 UTC (rev 1078)
@@ -428,6 +428,16 @@
 	result->mRubyObject=true;
 }
 %markfunc AntImpostor "general_markfunc"
+%exception SceneBase::SceneBase {
+	$action
+	result->mRUBY=self;
+#ifdef GCDEBUG
+     result->mObjName=typeid(*result).name();
+     printf("%lx   %s\n",self,typeid(*result).name());
+#endif
+	result->mRubyObject=true;
+}
+%markfunc SceneBase "general_markfunc"
 %exception AGRandomizer::AGRandomizer {
 	$action
 	result->mRUBY=self;
@@ -822,7 +832,7 @@
  }
  else $input=Qnil;
 }
-%typemap(out) AGText*{
+%typemap(out) WaterPiece*{
  if($1)
  {
   if($1->mRubyObject)
@@ -830,15 +840,13 @@
   else
    {
      if(false);
-else if(dynamic_cast<AGCaption*>(result))
-  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
    else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_WaterPiece,0);
    }
  }
  else vresult=Qnil;
 }
-%typemap(directorin) AGText*{
+%typemap(directorin) WaterPiece*{
  if($1)
  {
   if($1->mRubyObject)
@@ -846,15 +854,13 @@
   else
    {
      if(false);
-else if(dynamic_cast<AGCaption*>($1))
-  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGCaption,0);
    else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGText,0);
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_WaterPiece,0);
    }
  }
  else $input=Qnil;
 }
-%typemap(out) WaterPiece*{
+%typemap(out) AGText*{
  if($1)
  {
   if($1->mRubyObject)
@@ -862,13 +868,15 @@
   else
    {
      if(false);
+else if(dynamic_cast<AGCaption*>(result))
+  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGCaption,0);
    else
-     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_WaterPiece,0);
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AGText,0);
    }
  }
  else vresult=Qnil;
 }
-%typemap(directorin) WaterPiece*{
+%typemap(directorin) AGText*{
  if($1)
  {
   if($1->mRubyObject)
@@ -876,8 +884,10 @@
   else
    {
      if(false);
+else if(dynamic_cast<AGCaption*>($1))
+  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGCaption,0);
    else
-     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_WaterPiece,0);
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_AGText,0);
    }
  }
  else $input=Qnil;
@@ -2110,6 +2120,38 @@
  }
  else $input=Qnil;
 }
+%typemap(out) SceneBase*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $result=$1->mRUBY;
+  else
+   {
+     if(false);
+else if(dynamic_cast<Scene*>(result))
+  vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Scene,0);
+   else
+     vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SceneBase,0);
+   }
+ }
+ else vresult=Qnil;
+}
+%typemap(directorin) SceneBase*{
+ if($1)
+ {
+  if($1->mRubyObject)
+    $input=$1->mRUBY;
+  else
+   {
+     if(false);
+else if(dynamic_cast<Scene*>($1))
+  $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_Scene,0);
+   else
+     $input = SWIG_NewPointerObj((void *)$1, SWIGTYPE_p_SceneBase,0);
+   }
+ }
+ else $input=Qnil;
+}
 %typemap(out) DecimatedGraph*{
  if($1)
  {
@@ -3332,6 +3374,11 @@
  Data_Get_Struct($input,Scene,b);
  $result=*b;
 }
+%typemap(directorout) SceneBase {
+ SceneBase *b;
+ Data_Get_Struct($input,SceneBase,b);
+ $result=*b;
+}
 %typemap(directorout) SceneNode {
  SceneNode *b;
  Data_Get_Struct($input,SceneNode,b);

Modified: antargis/branches/branch_2d/src/path.cc
===================================================================
--- antargis/branches/branch_2d/src/path.cc	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/src/path.cc	2007-04-29 18:30:58 UTC (rev 1078)
@@ -90,7 +90,7 @@
   return 0;
 }
 
-
+/*
 SimpleGraph::HalfEdge *SimpleGraph::Edge::getHalfEdgeFrom(Node *n)
 {
   HalfEdge *h;
@@ -124,7 +124,7 @@
       h->w=w1;
     }
   return h;
-}
+  }*/
 
 
 ///////////////////////////////////////////////////////////////////////

Modified: antargis/branches/branch_2d/src/path.h
===================================================================
--- antargis/branches/branch_2d/src/path.h	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/src/path.h	2007-04-29 18:30:58 UTC (rev 1078)
@@ -94,10 +94,11 @@
 
     Node *getOther(Node *n);
 
+    /*
     HalfEdge *getHalfEdgeFrom(Node *n);
 
     HalfEdge *getHalfEdgeTo(Node *n);
-
+    */
   };
 
   struct Node

Modified: antargis/branches/branch_2d/src/scene.cc
===================================================================
--- antargis/branches/branch_2d/src/scene.cc	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/src/scene.cc	2007-04-29 18:30:58 UTC (rev 1078)
@@ -55,8 +55,7 @@
 
 
 Scene::Scene(int w,int h):
-  mTree(new QuadTree<SceneNode>(AGRect2(AGVector2(),AGVector2(w,h)))),
-  mCamera(w,h)
+  SceneBase(w,h)
 {
   white=AGVector4(1,1,1,1);
   black=AGVector4(0,0,0,1);
@@ -76,13 +75,9 @@
 
 }
 
+
 Scene::~Scene()
 {
-  // tell nodes, that I'm no longer there :-)
-  for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
-    (*i)->resetScene(); 
-
-  delete mTree;
 }
 
 size_t Scene::getDrawnMeshes() const
@@ -147,87 +142,8 @@
 }
 
 
-void Scene::addNode(SceneNode *node)
-{
-  if(mNodeSet.find(node)==mNodeSet.end())
-    {
-      node->setScene(this);
 
-      mNodes.push_back(node);
-      mNodeSet.insert(node);
-      assert(node->getScene()==this);
-      mTree->insert(node);
-    }
-}
 
-void Scene::updatePos(SceneNode *node)
-{
-  if(mNodeSet.find(node)==mNodeSet.end())
-    throw std::string("Dont know about this!");
-  mTree->insert(node);
-}
-
-void Scene::prepareUpdate(SceneNode *node)
-{
-  if(mNodeSet.find(node)==mNodeSet.end())
-    throw std::string("Dont know about this!");
-  mTree->remove(node);
-}
-
-
-void Scene::removeNode(SceneNode *node)
-{
-  if(mNodeSet.find(node)!=mNodeSet.end())
-    {
-      Nodes::iterator i=std::find(mNodes.begin(),mNodes.end(),node);
-      mNodes.erase(i);
-      mNodeSet.erase(node);
-      assert(node->getScene()==this);
-      node->resetScene();
-      assert(mTree->remove(node));
-    }
-  else
-    {
-      throw std::runtime_error("Trying to remove unknown node");
-    }
-}
-
-void Scene::clear()
-{
-  for(std::vector<SceneNode*>::iterator i=mNodes.begin();i!=mNodes.end();i++)
-    {
-      assert((*i)->getScene()==this);
-      (*i)->resetScene();
-    }
-  TRACE;
-  mNodes.clear();
-  mNodeSet.clear();
-  mTree->clear();
-}
-
-  // (mx,my,0)
-void Scene::setCamera(AGVector4 v)
-{
-  mCamera.setPosition(v.dim3());
-}
-
-void Scene::advance(float time)
-{
-  STACKTRACE; 
-
-  if(!mEnabled)
-    return;
-  // advance only in view
-
-  NodeList l=getCurrentNodes();
-
-  for(NodeList::iterator i=l.begin();i!=l.end();i++)
-    {
-      if((*i)->visible())
-	(*i)->advance(time);
-    }
-}
-
 Scene::NodeList Scene::getCurrentNodes()
 {
   STACKTRACE;
@@ -604,25 +520,7 @@
 }
 
 
-float Scene::width() const
-{
-  return mCamera.getWidth();
-}
-float Scene::height() const
-{
-  return mCamera.getHeight();
-}
 
-void Scene::mark()
-{
-  Scene::Nodes::iterator i=mNodes.begin();
-
-  for(;i!=mNodes.end();i++)
-    {
-      markObject(*i);
-    }
-}
-
 AGMatrix4 Scene::getLightComplete() const
 {
   return mCamera.getLightComplete();
@@ -637,10 +535,6 @@
   return mCamera.getLightProjectionMatrix();
 }
 
-AGVector4 Scene::getCamera() const
-{
-  return AGVector4(mCamera.getPosition(),1);
-}
 
 AGVector2 Scene::getPosition(const AGVector4 &v) const
 {
@@ -664,7 +558,9 @@
   mEnabled=p;
 }
 
-AntCamera &Scene::getCameraObject()
+
+void Scene::advance(float time)
 {
-  return mCamera;
+  if(mEnabled)
+    SceneBase::advance(time);
 }

Modified: antargis/branches/branch_2d/src/scene.h
===================================================================
--- antargis/branches/branch_2d/src/scene.h	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/src/scene.h	2007-04-29 18:30:58 UTC (rev 1078)
@@ -12,6 +12,7 @@
 #include <map>
 
 #include "scenenode.h"
+#include "scene_base.h"
 #include "ant_camera.h"
 
 /**
@@ -23,26 +24,8 @@
 
 
 
-/**
-   some helper structure, which is used for storing
-   results when picking. it holds some information about:
-   * distance to camera (for sorting)
-   * the picked scene-node
-   * and the 3d-position, where the scene-node was touched
-   */
-struct PickNode
-{
-  AGVector4 pos;
-  SceneNode *node;
-  float camDist;
-  
-  bool operator<(const PickNode &n) const;
-};
 
-template<class T>
-class QuadTree;
 
-
 /** 
     \brief quad-tree based scene-manager
     \ingroup Engine3d
@@ -55,11 +38,11 @@
 
  */
 
-class Scene:public AGRubyObject
+class Scene:public SceneBase
 {
  public:
-  typedef std::vector<PickNode> PickResult;
-  typedef std::list<SceneNode*> NodeList;
+  ////  typedef std::vector<PickNode> PickResult;
+  ////  typedef std::list<SceneNode*> NodeList;
 
   Scene(int w,int h);
   virtual ~Scene();
@@ -73,49 +56,58 @@
 
   // ATTENTION: nodes are not owned by Scene afterwards - so they won't get deleted!
   //            You have to do this yourself in the Entities or let ruby's GC do it for you (which would be the normal case)
-  void addNode(SceneNode *node);
+  /*  void addNode(SceneNode *node);
   void removeNode(SceneNode *node);
   void prepareUpdate(SceneNode *node);
   void updatePos(SceneNode *node);
+  
 
-
   void clear();
 
   // (mx,my,0)
   void setCamera(AGVector4 v);
-  AGVector4 getCamera() const;
-  void advance(float time);
-
+  AGVector4 getCamera() const;*/
+  virtual void advance(float time);
+  
   /**
      picking is currently done with opengl. this uses software (at least on my box), which is
      pretty slow. Some new implementation using BSPs would be cool!
      VertexArray or MeshData should contain it's data in such a tree. rays can be transformed using
      inverse transformation-matrices. This way data can stay as is.
   */
+  
   PickResult pick(float x,float y,float w,float h);
-
+  /*
   AntCamera &getCameraObject();
-
+*/
   size_t getDrawnMeshes() const;
 
   size_t getTriangles() const;
   size_t getPickTriangles() const;
 
+
+  /**
+     get 2d-Position on screen for a 3dim vector in 3-space
+   */
+  AGVector2 getPosition(const AGVector4 &v) const;
+
   /// get camera-viewing-direction to some 3d-point - used for particles
   AGVector3 getCameraDirTo(const AGVector3 &p) const;
 
+  /*
   /// width and height of screen
   float width() const;
   float height() const;
 
   void mark();
-
+  */
   AGMatrix4 getLightComplete() const;
   AGMatrix4 getLightView() const;
   AGMatrix4 getLightProj() const;
 
+  /*
   AGVector2 getPosition(const AGVector4 &v) const;
-
+  */
   NodeList getCurrentNodes();
 
 
@@ -135,7 +127,7 @@
   int mShadow;
 
   AGMatrix4 cameraPickMatrix;
-  
+  /*
   typedef std::vector<SceneNode*> Nodes;
   typedef std::set<SceneNode*> NodeSet;
 
@@ -147,7 +139,7 @@
 
   Nodes mNodes;
   NodeSet mNodeSet;
-
+  */
   AGVector4 white,black;
 
   size_t mTriangles;

Modified: antargis/branches/branch_2d/src/scenenode.cc
===================================================================
--- antargis/branches/branch_2d/src/scenenode.cc	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/src/scenenode.cc	2007-04-29 18:30:58 UTC (rev 1078)
@@ -2,7 +2,7 @@
 #include "scene.h"
 #include "ag_debug.h"
 
-SceneNode::SceneNode(Scene *s,const AGVector4 &pPos,const AGBox3 &b):
+SceneNode::SceneNode(SceneBase *s,const AGVector4 &pPos,const AGBox3 &b):
   mPos(pPos),mBBox(b)
 {
   assert(s);
@@ -28,7 +28,7 @@
     mScene->removeNode(this);
 }
 
-void SceneNode::setScene(Scene *pScene)
+void SceneNode::setScene(SceneBase *pScene)
 {
   assert(mScene==0 || mScene==pScene);
   mScene=pScene;
@@ -113,7 +113,7 @@
 }
 
 
-Scene *SceneNode::getScene()
+SceneBase *SceneNode::getScene()
 {
   if(!mScene)
     throw std::runtime_error("scene==0");

Modified: antargis/branches/branch_2d/src/scenenode.h
===================================================================
--- antargis/branches/branch_2d/src/scenenode.h	2007-04-29 18:10:26 UTC (rev 1077)
+++ antargis/branches/branch_2d/src/scenenode.h	2007-04-29 18:30:58 UTC (rev 1078)
@@ -4,7 +4,7 @@
 #include <ag_geometry.h>
 #include <ag_rubyobj.h>
 
-class Scene;
+class SceneBase;
 
 /// these are the drawing orders, by which Scene::drawScene orders all the meshes
 /// 1 will be drawn first and so forth
@@ -30,7 +30,7 @@
 class SceneNode:public AGRubyObject
 {
  public:
-  SceneNode(Scene *s,const AGVector4 &pPos,const AGBox3 &pBox);
+  SceneNode(SceneBase *s,const AGVector4 &pPos,const AGBox3 &pBox);
   virtual ~SceneNode();
 
   /// reset my scene pointer - should not be called in "normal" code - only by the Scene-object
@@ -68,7 +68,7 @@
 
   virtual void clear();
 
-  Scene *getScene();
+  SceneBase *getScene();
   /// this checks, if the current object is inserted into a scene
   bool sceneValid() const;
 
@@ -80,17 +80,17 @@
   int getOrder() const;
   
  private:
-  void setScene(Scene *pScene);
+  void setScene(SceneBase *pScene);
 
   int mOrder;
 
-  Scene *mScene;
+  SceneBase *mScene;
   bool mVisible;
 
   AGVector4 mPos;
   AGBox3 mBBox;
 
-  friend class Scene;
+  friend class SceneBase;
 };
 
 typedef SceneNode *SceneNodePtr;



From davidkamphausen at mail.berlios.de  Sun Apr 29 21:26:46 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 29 Apr 2007 21:26:46 +0200
Subject: [Antargis-svn] r1079 - antargis/branches/branch_2d/ruby
Message-ID: <200704291926.l3TJQkQr027808@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-04-29 21:26:46 +0200 (Sun, 29 Apr 2007)
New Revision: 1079

Modified:
   antargis/branches/branch_2d/ruby/ant_farm.rb
   antargis/branches/branch_2d/ruby/ant_field.rb
   antargis/branches/branch_2d/ruby/ant_fire.rb
   antargis/branches/branch_2d/ruby/ant_fishing_hut.rb
   antargis/branches/branch_2d/ruby/ant_models.rb
   antargis/branches/branch_2d/ruby/ant_stone.rb
Log:
* more centralizing meshes


Modified: antargis/branches/branch_2d/ruby/ant_farm.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_farm.rb	2007-04-29 18:30:58 UTC (rev 1078)
+++ antargis/branches/branch_2d/ruby/ant_farm.rb	2007-04-29 19:26:46 UTC (rev 1079)
@@ -35,9 +35,7 @@
 	end
 	
 	def setupMesh
-		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/farm.ant2",0.2,"data/textures/models/farm.png"),AGVector4.new(0,0,0),-30)
-		#mesh=Mesh.new(getMap.getScene,getMeshData("data/models/townhall.ant2",3.2,"data/textures/models/townhall.png"),AGVector4.new(0,0,0),-30)
-		setMesh(mesh)
+		setMesh(createModel(:farm))
 	end
 
 	def neededStock

Modified: antargis/branches/branch_2d/ruby/ant_field.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_field.rb	2007-04-29 18:30:58 UTC (rev 1078)
+++ antargis/branches/branch_2d/ruby/ant_field.rb	2007-04-29 19:26:46 UTC (rev 1079)
@@ -5,8 +5,7 @@
 		setProvide("field",true)
 		@size=0
 		#init fieldMeshes-var
-		AntField.getFieldMeshData(0)
-		@max=@@fieldMeshes.length-1
+		@max=getMeshCount(:field)-1
 		setupMesh
 		@growTime=20
 		@begin=true
@@ -38,22 +37,6 @@
 	
 	private
 	def setupMesh
-		
-		mesh=Mesh.new(getMap.getScene,AntField.getFieldMeshData(@size),AGVector4.new(0,0,0),-30)
-		setMesh(mesh)
+		setMesh(createModel(:field, at size))		
 	end
-
-	@@fieldMeshes=nil
-
-	def AntField.getFieldMeshData(size)
-		if @@fieldMeshes.nil?
-			@@fieldMeshes=[
-				getMeshData("data/models/crop_tiny.ant2",2.2,"data/textures/models/crop_tiny.png"),
-				getMeshData("data/models/crop_small.ant2",2.2,"data/textures/models/crop_green.png"),
-				getMeshData("data/models/crop_med.ant2",2.2,"data/textures/models/crop_yellow.png"),
-				getMeshData("data/models/crop_high.ant2",2.2,"data/textures/models/crop_gold.png")]
-		end
-		@@fieldMeshes[size]
-	end
-
 end

Modified: antargis/branches/branch_2d/ruby/ant_fire.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_fire.rb	2007-04-29 18:30:58 UTC (rev 1078)
+++ antargis/branches/branch_2d/ruby/ant_fire.rb	2007-04-29 19:26:46 UTC (rev 1079)
@@ -2,8 +2,9 @@
 	def initialize(p=AGVector2.new(0,0))
 		super
 		mp=AGVector3.new(0,0,0)
-		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/fire.ant2",0.3,"data/textures/models/fire.png"),AGVector4.new(0,0,0),0)
-		setMesh(mesh)
+		setMesh(createModel(:fire,:on))
+# 		mesh=Mesh.new(getMap.getScene,getMeshData("data/models/fire.ant2",0.3,"data/textures/models/fire.png"),AGVector4.new(0,0,0),0)
+# 		setMesh(mesh)
 		@smokeMesh=Smoke.new(getMap.getScene,4)
 		addMesh(@smokeMesh,mp)
 		smoke=Smoke.new(getMap.getScene,40)
@@ -14,7 +15,8 @@
 		@enabled=true
 	end
 	def disable
-		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/fire.ant2",0.3,"data/textures/models/fire2.png"),AGVector4.new(0,0,0),0))
+		setMesh(createModel(:fire,:off))
+		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/fire.ant2",0.3,"data/textures/models/fire2.png"),AGVector4.new(0,0,0),0))
 		getMap.getScene.addNode(@smokeMesh) # FIXME: dirty hack - solve this another way!!!
 		addMesh(@smokeMesh,AGVector3.new(0,0,0))
 		@smokeMesh.setEnabled(false)

Modified: antargis/branches/branch_2d/ruby/ant_fishing_hut.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_fishing_hut.rb	2007-04-29 18:30:58 UTC (rev 1078)
+++ antargis/branches/branch_2d/ruby/ant_fishing_hut.rb	2007-04-29 19:26:46 UTC (rev 1079)
@@ -11,10 +11,13 @@
 	end
 	
 	def setupMesh
-		data=getMeshData("data/models/fishing_hut.ant2",3.2,"data/textures/models/fishing_hut.png")
-		data.setTransparent(true)
-		mesh=Mesh.new(getMap.getScene,data,AGVector4.new(0,0,0),-30)
-		setMesh(mesh)
+		setMesh(createModel(:fishing_hut))
+# 
+# 
+# 		data=getMeshData("data/models/fishing_hut.ant2",3.2,"data/textures/models/fishing_hut.png")
+# 		data.setTransparent(true)
+# 		mesh=Mesh.new(getMap.getScene,data,AGVector4.new(0,0,0),-30)
+# 		setMesh(mesh)
 	end
 
 	def neededStock

Modified: antargis/branches/branch_2d/ruby/ant_models.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_models.rb	2007-04-29 18:30:58 UTC (rev 1078)
+++ antargis/branches/branch_2d/ruby/ant_models.rb	2007-04-29 19:26:46 UTC (rev 1079)
@@ -11,7 +11,8 @@
 		"well"=>-30,
 		"ant_bakery"=>-30,
 		"ant_coach"=>-50,
-		"livinghouse"=>-20
+		"livinghouse"=>-20,
+		"farm"=>-30,
 	}
 
 	if rot.member?(name)
@@ -40,6 +41,9 @@
 		"druid_lp"=>0.08,
 		"smith_lp"=>0.08,
 		"livinghouse"=>0.16,
+		"farm"=>0.2,
+		"fire"=>0.3,
+		"big_stone"=>0.7,
 	}
 
 	if scales.member?(name)
@@ -80,6 +84,12 @@
 			[1]=>["data/models/building_site0.ant2",1.7,"data/textures/models/building_site1.png"],
 			[2]=>["data/models/building_site2.ant2",1.7,"data/textures/models/building_site1.png"],
 		},
+		:field=>{
+			[0]=>["data/models/crop_tiny.ant2",2.2,"data/textures/models/crop_tiny.png"],
+			[1]=>["data/models/crop_small.ant2",2.2,"data/textures/models/crop_green.png"],
+			[2]=>["data/models/crop_med.ant2",2.2,"data/textures/models/crop_yellow.png"],
+			[3]=>["data/models/crop_high.ant2",2.2,"data/textures/models/crop_gold.png"]
+		},
 		:tower=>{
 			[]=>"tower"
 		},
@@ -144,7 +154,23 @@
 		{
 			[]=>"livinghouse"
 		},
-	
+		:farm=>
+		{
+			[]=>"farm"
+		},	
+		:fire=>
+		{
+			[:on]=>["data/models/fire.ant2",0.3,"data/textures/models/fire.png"],
+			[:off]=>["data/models/fire.ant2",0.3,"data/textures/models/fire2.png"]
+		},
+		:fishing_hut=>
+		{
+			[]=>["data/models/fishing_hut.ant2",3.2,"data/textures/models/fishing_hut.png",false]
+		},
+		:stone=>
+		{
+			[]=>"big_stone"
+		},
 	}
 end
 

Modified: antargis/branches/branch_2d/ruby/ant_stone.rb
===================================================================
--- antargis/branches/branch_2d/ruby/ant_stone.rb	2007-04-29 18:30:58 UTC (rev 1078)
+++ antargis/branches/branch_2d/ruby/ant_stone.rb	2007-04-29 19:26:46 UTC (rev 1079)
@@ -23,12 +23,9 @@
 		super(AGVector2.new(0,0))
 		@typeID=(getRand*2).to_i
 		setProvide("stone",true)
-		#setMesh(Mesh.new(getMeshData("data/models/floor.ant2",1,"data/textures/splats/gravel_big2.png",false),AGVector4.new(0,0,0,0),0))
-		setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/big_stone.ant2",0.7,"data/textures/models/big_stone.png"),AGVector4.new(0,0,0,0),getRand*360))
-		
-#		setMesh(NewDecal.new(AGVector2.new(3,3),5.3,getMap,"data/textures/gravel.png"))
-#		setMesh(NewDecal.new(AGVector2.new(3,3),5.3,getMap,"data/textures/terrain/rough_dirt2.png"))
-#		setMesh(Mesh.new(
+		#setMesh(Mesh.new(getMap.getScene,getMeshData("data/models/big_stone.ant2",0.7,"data/textures/models/big_stone.png"),AGVector4.new(0,0,0,0),getRand*360))
+		setMesh(mesh=createModel(:stone))
+		mesh.setRotation(getRand*360)
 		resource.set("stone",500)
 	end
 	def setTreeType(t)



