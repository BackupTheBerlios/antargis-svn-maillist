From davidkamphausen at mail.berlios.de  Thu Jun 14 10:34:52 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Thu, 14 Jun 2007 10:34:52 +0200
Subject: [Antargis-svn] r1102 - antargis/branches
Message-ID: <200706140834.l5E8YqZQ016545@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-14 10:34:51 +0200 (Thu, 14 Jun 2007)
New Revision: 1102

Added:
   antargis/branches/rant/
Log:
A    svn+ssh://davidkamphausen at svn.berlios.de/svnroot/repos/antargis/antargis/branches/rant




From davidkamphausen at mail.berlios.de  Fri Jun 22 22:52:09 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Fri, 22 Jun 2007 22:52:09 +0200
Subject: [Antargis-svn] r1104 - in antargis/branches/rant: . build
	data/gui/layout ext/basic ext/game ext/gui ext/math ext/sound
	ext/video ruby ruby/entities ruby/gui ruby/tests
Message-ID: <200706222052.l5MKq9RC014429@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-22 22:52:07 +0200 (Fri, 22 Jun 2007)
New Revision: 1104

Added:
   antargis/branches/rant/ruby/entities/entities.rb
Removed:
   antargis/branches/rant/ruby/entities/ents.rb
Modified:
   antargis/branches/rant/Rantfile
   antargis/branches/rant/build/base_tools.rb
   antargis/branches/rant/build/common.i
   antargis/branches/rant/build/create_interface.rb
   antargis/branches/rant/build/interface_template.rb
   antargis/branches/rant/data/gui/layout/options.xml
   antargis/branches/rant/ext/basic/ag_collector.cc
   antargis/branches/rant/ext/basic/ag_collector.h
   antargis/branches/rant/ext/basic/ag_fs.cc
   antargis/branches/rant/ext/basic/ag_fs.h
   antargis/branches/rant/ext/basic/ag_main.cc
   antargis/branches/rant/ext/basic/ag_main.h
   antargis/branches/rant/ext/basic/ag_rand_base.h
   antargis/branches/rant/ext/basic/ag_rubyobj.cc
   antargis/branches/rant/ext/basic/ag_rubyobj.h
   antargis/branches/rant/ext/basic/ag_string.h
   antargis/branches/rant/ext/basic/ag_video_base.h
   antargis/branches/rant/ext/basic/ag_xml.h
   antargis/branches/rant/ext/basic/headers.hh
   antargis/branches/rant/ext/basic/init.cc
   antargis/branches/rant/ext/game/headers.hh
   antargis/branches/rant/ext/game/init.cc
   antargis/branches/rant/ext/gui/headers.hh
   antargis/branches/rant/ext/gui/init.cc
   antargis/branches/rant/ext/math/ag_gauss.h
   antargis/branches/rant/ext/math/headers.hh
   antargis/branches/rant/ext/sound/ag_sound.cc
   antargis/branches/rant/ext/sound/headers.hh
   antargis/branches/rant/ext/sound/init.cc
   antargis/branches/rant/ext/video/ag_color.h
   antargis/branches/rant/ext/video/ag_font.h
   antargis/branches/rant/ext/video/ag_fontengine.cc
   antargis/branches/rant/ext/video/ag_fontengine.h
   antargis/branches/rant/ext/video/ag_painttarget.h
   antargis/branches/rant/ext/video/ag_screen.h
   antargis/branches/rant/ext/video/ag_surface.h
   antargis/branches/rant/ext/video/ag_texture.h
   antargis/branches/rant/ext/video/ag_video.cc
   antargis/branches/rant/ext/video/ag_video.h
   antargis/branches/rant/ext/video/headers.hh
   antargis/branches/rant/ext/video/init.cc
   antargis/branches/rant/ruby/ant_hljobs.rb
   antargis/branches/rant/ruby/antargis.rb
   antargis/branches/rant/ruby/antargislib.rb
   antargis/branches/rant/ruby/campaign.rb
   antargis/branches/rant/ruby/editview.rb
   antargis/branches/rant/ruby/entities/ant_boss.rb
   antargis/branches/rant/ruby/entities/ant_hero.rb
   antargis/branches/rant/ruby/gui/ag_tools.rb
   antargis/branches/rant/ruby/mainmenu.rb
   antargis/branches/rant/ruby/tests/algebra_test.rb
   antargis/branches/rant/ruby/tests/basis_test.rb
   antargis/branches/rant/ruby/tests/clip_gradient_test.rb
   antargis/branches/rant/ruby/tests/clip_widget_test.rb
Log:
* many,many changes


Modified: antargis/branches/rant/Rantfile
===================================================================
--- antargis/branches/rant/Rantfile	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/Rantfile	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,25 +1,11 @@
-import "md5"
-import "autoclean"
-require 'mkmf'
+import "md5"                          # md5 is needed for automatic checksum-check for changes in files
+import "autoclean"                    # autoclean includes the a simple facility for a clean-make-target
 
 require 'build/base_tools.rb'
     
-#puts self
-#puts self.methods.sort.join("\n")
 
-
-def getConfig(s)
-  r=CONFIG[s]
-  return r if r.nil?
-  r.gsub(/\$\(([^\)]*)\)/) {|a|getConfig(a[2..-2])}
-end
-
 # sitearchdir - include in usr/local
 
-#CONFIG.each{|a,b|
-# puts "#{a} --  #{getConfig(a)}"
-#}
-#exit
 rubyIncDir=getConfig("archdir")
 
 sdlLibs=[`sdl-config --libs`]
@@ -29,11 +15,14 @@
 	["ext/basic",["ext/external"]+sdlLibs],
 	["ext/math",["ext/basic"]],
 	["ext/video",["ext/math","ext/basic","-lSDL_image","-lSDL_ttf","-lGL","-lGLU"]],
-	["ext/sound",["ext/basic"]],
-	["ext/gui",["ext/video"]],
-	["ext/game",["ext/basic","ext/gui"]],
+	["ext/gui",["ext/basic","ext/math","ext/video"]],
+	["ext/sound",["ext/basic","-lSDL_mixer"]], # FIXME: remove dependency from AGWidget somehow !
+	["ext/3dengine",["ext/basic"]],
+	["ext/game",["ext/basic","ext/math","ext/video","ext/gui","ext/3dengine"]],
 ]
 
+$sourceDeps=sourceDeps
+
 sourceDirs=sourceDeps.collect{|a|a[0]}
 
 # puts sourceDirs
@@ -44,7 +33,7 @@
 var :INCLUDES => sourceDirs+[rubyIncDir,"."] #.collect{|d|"-I#{d}"}.join(" ")+" "+externalIncludes+" "+rubyIncDir
 var :INCLUDESTR => var[:INCLUDES].collect{|d|"-I#{d}"}.join(" ")+" "+externalIncludes
 
-var :CFLAGS => var[:INCLUDESTR]
+var :CFLAGS => var[:INCLUDESTR]+" -g -O0 -DGCDEBUG"
     
 var.env %w(CC CFLAGS)
     
@@ -187,6 +176,15 @@
 #
 
 def importsForInterface(name)
+	
+	$sourceDeps.each{|t|
+		if name=~/#{t[0]}/
+			return t[1].select{|f|not f=~/-.*/}.collect{|f|f+"/interface.i"}.join(":")
+		end
+	}
+	return ""
+
+
 	case name
 		when /ext\/math/
 			"ext/basic/interface.i"
@@ -206,7 +204,7 @@
 	list
 }
 gen Rule, /^.*interface.i$/ => interfaceSrc do |t|
-	sys "ruby build/create_interface.rb -d=#{getDir(sys.expand_path(t.name))} -i=#{importsForInterface(t.name)}"
+	sys "ruby build/create_interface_new.rb -d=#{getDir(sys.expand_path(t.name))} -i=#{importsForInterface(t.name)}"
 end
 #
 ###########################################

Modified: antargis/branches/rant/build/base_tools.rb
===================================================================
--- antargis/branches/rant/build/base_tools.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/build/base_tools.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,3 +1,5 @@
+require 'mkmf'                        # mkmf holds information about the compiler-settings while compiling ruby (by the maintainer)
+
 class Dir
 	def Dir.separator
 		"/" # FIXME
@@ -12,4 +14,11 @@
 
 def makeLibName(dir)
 	"antargis"+dir.split(Dir.separator)[-1]
-end
\ No newline at end of file
+end
+
+# the getConfig function reads out compiler-information out of the mkmf-configuration variables - these are defined in a recursive manner
+def getConfig(s)
+  r=CONFIG[s]
+  return r if r.nil?
+  r.gsub(/\$\(([^\)]*)\)/) {|a|getConfig(a[2..-2])} # replace recursive values within this form: $(...)
+end

Modified: antargis/branches/rant/build/common.i
===================================================================
--- antargis/branches/rant/build/common.i	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/build/common.i	2007-06-22 20:52:07 UTC (rev 1104)
@@ -6,6 +6,9 @@
 %include "std_pair.i"
 %include "std_map.i"
 %include "std_list.i"
+//%include "ag_string.i"
+%include "ag_filename.i"
+%include "ag_data.i"
 
 %{
 #include <ag_rubyobj.h>
@@ -14,6 +17,7 @@
 AG_NewPointerObj(void *ptr, swig_type_info *type, int flags)
 {
 	AGRubyObject *o=(AGRubyObject*)ptr;
+	printf("AG_NewPointerObj o:0x%lx , ruby:0x%lx vl:0x%lx\n",o,o->mRubyObject,o->mRUBY);
 	if(o->mRubyObject)
 		return o->mRUBY;
 
@@ -21,6 +25,7 @@
 
 	o->mRubyObject=true;
 	o->mRUBY=SWIG_NewPointerObj((void *) o, t,flags);
+	printf("NEW AG_NewPointerObj o:0x%lx , ruby:0x%lx vl:0x%lx\n",o,o->mRubyObject,o->mRUBY);
 	return o->mRUBY;
 }
 

Modified: antargis/branches/rant/build/create_interface.rb
===================================================================
--- antargis/branches/rant/build/create_interface.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/build/create_interface.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -92,7 +92,7 @@
 
 moduleName="Libantargis"
 moduleName=makeLibName(outputDir)
-interfaceI.puts interface_template(moduleName,files,swigInput,addfiles)
+interfaceI.puts interface_template(moduleName,files,swigInput,addfiles,outputDir)
 
 interfaceI.close
 
@@ -130,10 +130,6 @@
 class2File={}
 
 
-
-
-#files=ARGV
-
 # take RubyObject as base for RubyObjects :-)
 # so simply search for classes deriveListd from this!
 
@@ -293,30 +289,3 @@
 
 
 }
-exit
-
-file.close
-
-# now generate antargis.h
-#filename="antargisgui.h"
-filename=outputDir+Dir.separator+"/headers.hh"
-file=File.open(filename,"w")
-
-file.puts "#ifndef __ANTARGIS_H__"
-file.puts "#define __ANTARGIS_H__"
-files.each{|f|
-	file.puts "#include \"#{f}\""
-}
-file.puts "#include <SDL_keysym.h>"
-file.puts "#ifdef SWIG"
-files.each{|f|
-	file.puts "%include \"#{f}\""
-}
-file.puts '%include "/usr/include/SDL/SDL_keysym.h"'
-file.puts "#endif"
-file.puts "#endif"
-
-
-file.close
-
-puts "created nantmarker.hh"

Modified: antargis/branches/rant/build/interface_template.rb
===================================================================
--- antargis/branches/rant/build/interface_template.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/build/interface_template.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,4 +1,7 @@
-def interface_template(moduleName,files,swigInput,addfiles=[])
+def interface_template(moduleName,files,swigInput,addfiles=[],outputDir="")
+	dirname=outputDir
+
+
 <<EOT
 %module(directors="1") #{moduleName}
 
@@ -16,13 +19,20 @@
 #{swigInput.collect{|i|"%import \"#{i}\""}.join("\n")}
 
 %{
+#include <string>
 #{addfiles.collect{|f|"#include \"#{f}\""}.join("\n")}
 #{files.collect{|f|"#include \"#{f}\""}.join("\n")}
 %}
+%include "std_string.i"
+%include "#{dirname}/marker.i"
+%include "ext/#{moduleName.gsub("antargis","")}/templates.i"
+
 #{files.collect{|f|"%include \"#{f}\""}.join("\n")}
 
 
 // FIXME: add templates !
+
+
 EOT
 end
 

Modified: antargis/branches/rant/data/gui/layout/options.xml
===================================================================
--- antargis/branches/rant/data/gui/layout/options.xml	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/data/gui/layout/options.xml	2007-06-22 20:52:07 UTC (rev 1104)
@@ -52,7 +52,7 @@
 								<text caption="Use frame buffer objects"/>
 							</cell>
 							<cell col="2" row="0">
-								<checkBox name="UseFBO" disabledImage="gui/data/box.png" enabledImage="gui/data/box_cross.png" theme="none"/>
+								<checkBox name="UseFBO" disabledImage="gui/images/basic/box.png" enabledImage="gui/images/basic/box_cross.png" theme="none"/>
 							</cell>
 						</table>
 					</cell>
@@ -63,7 +63,7 @@
 								<text caption="Use animations"/>
 							</cell>
 							<cell col="2" row="0">
-								<checkBox name="UseAnim" disabledImage="gui/data/box.png" enabledImage="gui/data/box_cross.png" theme="none"/>
+								<checkBox name="UseAnim" disabledImage="gui/images/basic/box.png" enabledImage="gui/images/basic/box_cross.png" theme="none"/>
 							</cell>
 						</table>
 					</cell>
@@ -74,7 +74,7 @@
 								<text caption="Use particle effects"/>
 							</cell>
 							<cell col="2" row="0">
-								<checkBox name="UseParticle" disabledImage="gui/data/box.png" enabledImage="gui/data/box_cross.png" theme="none"/>
+								<checkBox name="UseParticle" disabledImage="gui/images/basic/box.png" enabledImage="gui/images/basic/box_cross.png" theme="none"/>
 							</cell>
 						</table>
 					</cell>
@@ -84,7 +84,7 @@
 					<text col="1" row="0" caption="Play intro on start" valign="center"/>
 					<cell col="2" row="0">
 						<frame width="6">
-							<checkBox name="optionIntro" disabledImage="gui/data/box.png" enabledImage="gui/data/box_cross.png" theme="none"/>
+							<checkBox name="optionIntro" disabledImage="gui/images/basic/box.png" enabledImage="gui/images/basic/box_cross.png" theme="none"/>
 						</frame>
 					</cell>
 				</table>

Modified: antargis/branches/rant/ext/basic/ag_collector.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_collector.cc	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/basic/ag_collector.cc	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,18 +1,30 @@
 
 #include <ag_collector.h>
+#include <ag_debug.h>
+#include <ag_main.h>
 
 void AGCollector::insertGlobal(AGRubyObject *pObject)
 {
+  CTRACE;
   mGlobals.insert(pObject);
 }
 
 void AGCollector::removeGlobal(AGRubyObject *pObject)
 {
+  CTRACE;
   mGlobals.erase(pObject);
 }
 
 void AGCollector::mark()
 {
+  CTRACE;
   for(std::set<AGRubyObject*>::iterator i=mGlobals.begin();i!=mGlobals.end();i++)
     markObject(*i);
 }
+
+AGCollector *getCollector()
+{
+	if(getMain())
+		return getMain()->getCollector();
+	return 0;
+}

Modified: antargis/branches/rant/ext/basic/ag_collector.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_collector.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/basic/ag_collector.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -17,4 +17,7 @@
   
 };
 
+AGCollector *getCollector();
+
+
 #endif

Modified: antargis/branches/rant/ext/basic/ag_fs.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_fs.cc	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/basic/ag_fs.cc	2007-06-22 20:52:07 UTC (rev 1104)
@@ -39,9 +39,9 @@
 #include "ag_serial.h"
 #include <zlib.h>
 
-static std::list<std::string> mFsPaths;
+static std::list<AGFilename> mFsPaths;
 
-void addPath(const std::string &pName)
+void addPath(const AGFilename &pName)
 {
   mFsPaths.push_back(pName);
 #ifdef USE_PHYSFS
@@ -164,7 +164,7 @@
     }
 }
 
-std::string checkFileName(std::string s)
+AGFilename checkFileName(AGFilename s)
 {
 #ifdef WIN32
   if(s.length()>300)
@@ -197,11 +197,11 @@
   return r;
 }
 
-std::string findFile(const std::string &pName)
+AGFilename findFile(const AGFilename &pName)
 {
   if(fileExists(pName))
     return pName;
-  for(std::list<std::string>::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
+  for(std::list<AGFilename>::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
     {
       std::string n=*i+"/"+pName;
       n=checkFileName(n);
@@ -227,7 +227,7 @@
   if(r.length())
     return r;
 
-  for(std::list<std::string>::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
+  for(std::list<AGFilename>::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
     {
       r=directLoad(*i+"/"+pName);
       if(r.length())
@@ -237,7 +237,7 @@
   //  if(mFsPaths.size()==0)
   //    throw std::runtime_error("Not yet inited fs-paths!");
 
-  for(std::list<std::string>::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
+  for(std::list<AGFilename>::iterator i=mFsPaths.begin();i!=mFsPaths.end();i++)
     dbout(0,"path:"<<*i);
 
   dbout(0,"LOAD FAILED:"<<pName);
@@ -245,7 +245,7 @@
   return r;
 }
 
-std::string loadFile(const std::string &pName)
+AGData loadFile(const AGFilename &pName)
 {
   return loadFromPath(checkFileName(pName));
 #ifdef USE_PHYSFS
@@ -390,7 +390,7 @@
 
 #else
 
-std::string getDocumentsDir()
+AGFilename getDocumentsDir()
 {
   return getUserDir()+"/Desktop";
 }
@@ -399,12 +399,12 @@
 #endif
 
 
-std::string getWriteDir()
+AGFilename getWriteDir()
 {
   return getUserDir()+"/."+getAppName();
 }
 
-bool saveFile(const std::string &pName,const std::string &pContent)
+bool saveFile(const AGFilename &pName,const AGData &pContent)
 {
 #ifdef USE_PHYSFS
   TRACE;
@@ -437,7 +437,7 @@
   return true;
 }
 
-bool fileExists(const std::string &pName)
+bool fileExists(const AGFilename &pName)
 {
 #ifdef WIN32
   if(GetFileAttributes(pName.c_str()) == INVALID_FILE_ATTRIBUTES)
@@ -458,7 +458,7 @@
 #endif
 }
 
-std::vector<std::string> getDirectoryInternal(const std::string &pDir)
+std::vector<AGFilename> getDirectoryInternal(const AGFilename &pDir)
 {
 #ifdef USE_PHYSFS
   TRACE;
@@ -477,7 +477,7 @@
   return v;
 #else
 
-  std::vector<std::string> v;
+  std::vector<AGFilename> v;
 
 #ifdef WIN32
   WIN32_FIND_DATA ent;
@@ -524,18 +524,18 @@
 #endif
 }
 
-std::vector<std::string> getDirectory(const std::string &pDir)
+std::vector<AGFilename> getDirectory(const AGFilename &pDir)
 {
-  std::vector<std::string> v;
-  std::list<std::string> ps=mFsPaths;
+  std::vector<AGFilename> v;
+  std::list<AGFilename> ps=mFsPaths;
   ps.push_front(""); // add current dir
   ps.push_front("."); // add current dir
 
 
-  for(std::list<std::string>::iterator i=ps.begin();i!=ps.end();i++)
+  for(std::list<AGFilename>::iterator i=ps.begin();i!=ps.end();i++)
     {
       
-      std::vector<std::string> a=getDirectoryInternal(*i+"/"+pDir);
+      std::vector<AGFilename> a=getDirectoryInternal(*i+"/"+pDir);
       std::copy(a.begin(),a.end(),std::back_inserter(v));
     }
       
@@ -545,7 +545,7 @@
 
 
 
-std::string compress(const std::string &pString)
+AGData compress(const AGData &pString)
 {
   BinaryStringOut o;
   o<<(Uint32)pString.length();
@@ -559,7 +559,7 @@
   delete [] buf;
   return r;
 }
-std::string uncompress(const std::string &pString)
+AGData uncompress(const AGData &pString)
 {
   BinaryStringIn i(pString);
   uLongf orig;
@@ -576,7 +576,7 @@
   return r;
 }
 
-std::string getDirSep()
+AGFilename getDirSep()
 {
 #ifdef WIN32
   return "\\";

Modified: antargis/branches/rant/ext/basic/ag_fs.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_fs.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/basic/ag_fs.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -34,7 +34,7 @@
 
 bool AGEXPORT fileExists(const AGFilename &pName);
 
-std::vector<std::string> getDirectory(const AGFilename &pDir);
+std::vector<AGFilename> getDirectory(const AGFilename &pDir);
 
 AGFilename checkFileName(AGFilename s);
 AGFilename getWriteDir();

Modified: antargis/branches/rant/ext/basic/ag_main.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_main.cc	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/basic/ag_main.cc	2007-06-22 20:52:07 UTC (rev 1104)
@@ -173,3 +173,34 @@
 {
   return gAppName;
 }
+
+
+void AGMain::repeatedCalls()
+{
+  for(std::set<AGRepeatedCall*>::iterator i=mCalls.begin();i!=mCalls.end();i++)
+    {
+      (*i)->call();
+    }
+}
+
+void AGMain::setVideo(AGVideoBase *p)
+{
+  mVideo=p;
+}
+
+
+
+///   AGRepeatedCall
+AGRepeatedCall::AGRepeatedCall()
+{
+  assert(hasMain());
+  getMain()->mCalls.insert(this);
+}
+AGRepeatedCall::~AGRepeatedCall()
+{
+  if(hasMain())
+    getMain()->mCalls.erase(this);
+}
+void AGRepeatedCall::call()
+{
+}

Modified: antargis/branches/rant/ext/basic/ag_main.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_main.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/basic/ag_main.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -44,6 +44,17 @@
 class AGScreen;
 
 struct SDL_VideoInfo;
+
+// will be called repeatedely (by AGApplication - if available)
+// simply instantiate a subclass of this type - and it'll be registered within AGMain
+class AGRepeatedCall
+{
+ public:
+  AGRepeatedCall();
+  virtual ~AGRepeatedCall();
+  virtual void call();
+};
+
 class AGMain:public AGRubyObject
 {
  public:
@@ -57,8 +68,11 @@
 
   AGCollector *getCollector();
 
-	AGVideoBase *getVideo();
+  AGVideoBase *getVideo();
+  void setVideo(AGVideoBase *p);
 
+  void repeatedCalls();
+
  protected:
   virtual void mark();
 
@@ -69,6 +83,9 @@
   const SDL_VideoInfo *videoInfo;
 
   AGRandomizerBase *mRand;
+
+  std::set<AGRepeatedCall*> mCalls;
+  friend class AGRepeatedCall;
 };
 
 bool hasMain();

Modified: antargis/branches/rant/ext/basic/ag_rand_base.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_rand_base.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/basic/ag_rand_base.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,6 +1,8 @@
 #ifndef AG_RAND_BASE_H
 #define AG_RAND_BASE_H
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #include <ag_rubyobj.h>
 
 class AGRandomizerBase:public AGRubyObject

Modified: antargis/branches/rant/ext/basic/ag_rubyobj.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_rubyobj.cc	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/basic/ag_rubyobj.cc	2007-06-22 20:52:07 UTC (rev 1104)
@@ -50,15 +50,22 @@
   assert(o);
 
 #ifdef GCDEBUG
+	printf("marking : %lx\n",o);
   assert(gExistingRubies.find(o)!=gExistingRubies.end());
 #endif
 
   if(o->mRubyObject)
     {
+#ifdef GCDEBUG
+			printf("marking ruby : %lx\n",o->mRUBY);
+#endif
       rb_gc_mark(o->mRUBY);
     }
   if(recursive)
     o->mark(); // call this directly
+#ifdef GCDEBUG
+	printf("endmarking : %lx\n",o);
+#endif
 }
 
 void AGRubyObject::clear()

Modified: antargis/branches/rant/ext/basic/ag_rubyobj.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_rubyobj.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/basic/ag_rubyobj.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -33,6 +33,8 @@
    @see saveDelete(AGRubyObject *o)
 */
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #include <string>
 #include <set>
 #include <ag_base.h>

Modified: antargis/branches/rant/ext/basic/ag_string.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_string.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/basic/ag_string.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,14 +1,10 @@
 #ifndef AG_STRING
 #define AG_STRING
 
-// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
-
 #include <string>
 #include <vector>
 #include <SDL.h>
 
-typedef std::string AGFilename;
-typedef std::string AGData;
 
 /** A string class that natively supports UTF-8 */
 class AGString:public std::string
@@ -28,44 +24,25 @@
   AGString(const char*c);
   AGString(const char*c,size_t size);
   
-#ifndef SWIG
+#ifndef SWIiG
   AGString &operator=(const AGString &s);
 
   AGString &operator+=(const AGString &p);
 #endif
 
-  // size in UTF-8 characters
-  //  size_t length() const;
-
   // size in bytes
   size_t memory() const;
   
   AGString substr(size_t from,size_t len) const;
-  /*
-  char operator[](size_t i) const;
-  char &operator[](size_t i);*/
 
   std::vector<AGString> split(const AGString &p) const;
 
-  //  size_t find(const AGString &p,size_t pos=0) const;
-
   AGString replace(const AGString &what, const AGString &by) const;
   
   AGString operator+(const AGString &s) const;
   AGString operator+(const char *s) const;
   AGString operator+(const std::string &s) const;
 
-
-  /*  bool operator==(const AGString &p) const;
-  bool operator!=(const AGString &p) const;
-  bool operator<(const AGString &p) const;*/
-  /*
-#ifdef SWIG
-  %rename(to_s) toString() const;
-#endif
-  std::string toString() const;
-  std::string ascii() const;
-  */
   int toInt() const;
   long toLong() const;
   float toFloat() const;
@@ -77,20 +54,12 @@
   int parseHex() const;
 
   static AGString toHex(int i);
-
- private:
-
-  //  std::string get(size_t pos) const;
-  //  void set(size_t pos,const std::string &s);
-
-  //  std::string s;
-  //  mutable size_t mLength;
-
-  //  friend class AGChar;
-
 };
 
 //std::ostream &operator<<(std::ostream &o,const AGString &s);
 
+typedef AGString AGFilename;
+typedef	AGString AGData;
 
+
 #endif

Modified: antargis/branches/rant/ext/basic/ag_video_base.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_video_base.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/basic/ag_video_base.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,9 +1,11 @@
 #ifndef AG_VIDEO_BASE_H
 #define AG_VIDEO_BASE_H
 
-#include <ag_rubyobj.h>
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
 
-class AGVideoBase:public AGRubyObject
+#include <ag_singleton.h>
+
+class AGVideoBase:public AGSingleton
 {
 
 };

Modified: antargis/branches/rant/ext/basic/ag_xml.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_xml.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/basic/ag_xml.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -116,7 +116,7 @@
 
     Node &root();
 
-    std::string toString(bool forceIndent=false) const;
+    AGString toString(bool forceIndent=false) const;
 
     void parseMemory(const AGData &s);
   };
@@ -168,7 +168,7 @@
  public:
   virtual ~Parser();
 
-  void parse(const std::string &pData);
+  void parse(const AGData &pData);
   size_t getLine() const;
 
   virtual void simpleTag(const AGString &pName,const Node::Attributes &pAttributes);
@@ -191,9 +191,9 @@
   virtual void comment(const AGString &pText);
   virtual void header(const AGString &pText);
 
-  Document *parse(const std::string &pData);
+  Document *parse(const AGData &pData);
 
-  Document *parse(const std::string &pData,Document *d);
+  Document *parse(const AGData &pData,Document *d);
 };
   
 

Modified: antargis/branches/rant/ext/basic/headers.hh
===================================================================
--- antargis/branches/rant/ext/basic/headers.hh	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/basic/headers.hh	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,28 +1,37 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
-
+#include "ext/external/mtwist.h"
+#include "ext/external/randistrs.h"
+#include "ext/external/sge_config.h"
+#include "ext/external/sge_internal.h"
+#include "ext/external/sge_primitives.h"
+#include "ext/external/sge_surface.h"
+#include "/home/david/projects/antargis/rant/ext/basic/ag_rubyobj.h"
+#include "/home/david/projects/antargis/rant/ext/basic/ag_messageobject.h"
+#include "/home/david/projects/antargis/rant/ext/basic/ag_singleton.h"
+#include "/home/david/projects/antargis/rant/ext/basic/ag_rand_base.h"
+#include "/home/david/projects/antargis/rant/ext/basic/ag_main.h"
+#include "/home/david/projects/antargis/rant/ext/basic/ag_video_base.h"
+#include "/home/david/projects/antargis/rant/ext/basic/ag_serial.h"
 #include "/home/david/projects/antargis/rant/ext/basic/ag_config.h"
-#include "/home/david/projects/antargis/rant/ext/basic/ag_fs.h"
-#include "/home/david/projects/antargis/rant/ext/basic/ag_main.h"
-#include "/home/david/projects/antargis/rant/ext/basic/ag_rubyobj.h"
-#include "/home/david/projects/antargis/rant/ext/basic/ag_string.h"
+#include "/home/david/projects/antargis/rant/ext/basic/ag_xml.h"
 #include "/home/david/projects/antargis/rant/ext/basic/ag_string_utf8.h"
 #include "/home/david/projects/antargis/rant/ext/basic/ag_stringstream.h"
+#include "/home/david/projects/antargis/rant/ext/basic/ag_fs.h"
 #include "/home/david/projects/antargis/rant/ext/basic/ag_utf8.h"
-#include "/home/david/projects/antargis/rant/ext/basic/ag_xml.h"
-#include "/home/david/projects/antargis/rant/ext/basic/ag_singleton.h"
-#include "/home/david/projects/antargis/rant/ext/basic/ag_serial.h"
 #ifdef SWIG
+%include "/home/david/projects/antargis/rant/ext/basic/ag_rubyobj.h"
+%include "/home/david/projects/antargis/rant/ext/basic/ag_messageobject.h"
+%include "/home/david/projects/antargis/rant/ext/basic/ag_singleton.h"
+%include "/home/david/projects/antargis/rant/ext/basic/ag_rand_base.h"
+%include "/home/david/projects/antargis/rant/ext/basic/ag_main.h"
+%include "/home/david/projects/antargis/rant/ext/basic/ag_video_base.h"
+%include "/home/david/projects/antargis/rant/ext/basic/ag_serial.h"
 %include "/home/david/projects/antargis/rant/ext/basic/ag_config.h"
-%include "/home/david/projects/antargis/rant/ext/basic/ag_fs.h"
-%include "/home/david/projects/antargis/rant/ext/basic/ag_main.h"
-%include "/home/david/projects/antargis/rant/ext/basic/ag_rubyobj.h"
-%include "/home/david/projects/antargis/rant/ext/basic/ag_string.h"
+%include "/home/david/projects/antargis/rant/ext/basic/ag_xml.h"
 %include "/home/david/projects/antargis/rant/ext/basic/ag_string_utf8.h"
 %include "/home/david/projects/antargis/rant/ext/basic/ag_stringstream.h"
+%include "/home/david/projects/antargis/rant/ext/basic/ag_fs.h"
 %include "/home/david/projects/antargis/rant/ext/basic/ag_utf8.h"
-%include "/home/david/projects/antargis/rant/ext/basic/ag_xml.h"
-%include "/home/david/projects/antargis/rant/ext/basic/ag_singleton.h"
-%include "/home/david/projects/antargis/rant/ext/basic/ag_serial.h"
 #endif
 #endif

Modified: antargis/branches/rant/ext/basic/init.cc
===================================================================
--- antargis/branches/rant/ext/basic/init.cc	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/basic/init.cc	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,9 +1,22 @@
 #include <ag_main.h>
 #include <ag_debug.h>
 
+#include <list>
+#include <string>
+#include <map>
+
+//#include "antargisexternalswig.h"
+
+typedef struct swig_type_info;
+
+typedef swig_type_info*(*CastFunction)(void**);
+
+std::map<std::string,std::list<CastFunction> > agCastFunctions;
+
 void AG_Init_libantargisbasic()
 {
-	TRACE;
-	AGMain *main=new AGMain;
+  TRACE;
+  if(!hasMain())
+    AGMain *main=new AGMain;
 }
 

Modified: antargis/branches/rant/ext/game/headers.hh
===================================================================
--- antargis/branches/rant/ext/game/headers.hh	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/game/headers.hh	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,8 +1,118 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
-
-
+#include "ext/basic/ag_base.h"
+#include "ext/basic/ag_collector.h"
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_debug.h"
+#include "ext/basic/ag_exception.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_profiler.h"
+#include "ext/basic/ag_regex.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_string.h"
+#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_stringstream.h"
+#include "ext/basic/ag_tools.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_video_base.h"
+#include "ext/basic/ag_xml.h"
+#include "ext/basic/ag_plugin.h"
+#include "ext/basic/ag_singleton.h"
+#include "ext/basic/ag_kill.h"
+#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_mutex.h"
+#include "ext/math/ag_gauss.h"
+#include "ext/math/ag_geometry.h"
+#include "ext/math/ag_rand.h"
+#include "ext/math/ag_serial_vec.h"
+#include "ext/math/ant_frustum.h"
+#include "ext/math/ag_algebra.h"
+#include "ext/video/ag_screen.h"
+#include "ext/video/ag_video.h"
+#include "ext/video/GLee.h"
+#include "ext/video/ag_painttarget.h"
+#include "ext/video/ag_color.h"
+#include "ext/video/ag_fontengine.h"
+#include "ext/video/ag_font.h"
+#include "ext/video/ag_surfacemanager.h"
+#include "ext/video/ag_gltexture.h"
+#include "ext/video/ag_surface.h"
+#include "ext/video/ag_texture.h"
+#include "ext/video/ag_glscreen.h"
+#include "ext/video/ag_sdlscreen.h"
+#include "ext/video/ag_sgeexport.h"
+#include "ext/video/ag_draw.h"
+#include "ext/video/ag_png.h"
+#include "ext/video/ag_sdlpainter.h"
+#include "ext/video/ag_glpainter.h"
+#include "ext/video/ag_fbo.h"
+#include "ext/video/ag_vdebug.h"
+#include "ext/video/ag_rendercontext.h"
+#include "ext/video/ag_sdlsurface.h"
+#include "ext/video/ag_texturecache.h"
+#include "ext/video/ag_clip_painttarget.h"
+#include "ext/video/ag_clip.h"
+#include "ext/video/ag_projection.h"
+#include "ext/video/ag_painter.h"
+#include "ext/gui/ag_colorbutton.h"
+#include "ext/gui/ag_checkbox.h"
+#include "ext/gui/ag_application.h"
+#include "ext/gui/ag_widget.h"
+#include "ext/gui/ag_tooltip.h"
+#include "ext/gui/ag_radio.h"
+#include "ext/gui/ag_layout.h"
+#include "ext/gui/ag_menu.h"
+#include "ext/gui/ag_table.h"
+#include "ext/gui/ag_theme.h"
+#include "ext/gui/ag_edit.h"
+#include "ext/gui/ag_background.h"
+#include "ext/gui/ag_listbox.h"
+#include "ext/gui/ag_screenwidget.h"
+#include "ext/gui/ag_combo.h"
+#include "ext/gui/ag_image.h"
+#include "ext/gui/ag_frame.h"
+#include "ext/gui/ag_button.h"
+#include "ext/gui/ag_border.h"
+#include "ext/gui/ag_window.h"
+#include "ext/gui/ag_layoutfactory.h"
+#include "ext/gui/ag_local.h"
+#include "ext/gui/ag_text.h"
+#include "ext/gui/ag_menuitem.h"
+#include "ext/gui/ag_scroller.h"
+#include "ext/gui/ag_caption.h"
+#include "ext/gui/ag_radiogroup.h"
+#include "ext/3dengine/scene_base.h"
+#include "ext/3dengine/scene.h"
+#include "ext/3dengine/scenenode.h"
+#include "ext/3dengine/quadtree.h"
+#include "ext/3dengine/ant_camera.h"
+#include "ext/3dengine/mesh_sort.h"
+#include "ext/3dengine/ant_renderer.h"
+#include "ext/3dengine/mesh_data.h"
+#include "ext/3dengine/mesh.h"
+#include "ext/3dengine/vertex_array.h"
+#include "ext/3dengine/glsl.h"
+#include "ext/3dengine/mesh_optimizer.h"
+#include "ext/3dengine/anim_mesh.h"
+#include "ext/3dengine/anim_mesh_data.h"
+#include "ext/3dengine/mesh_2d.h"
+#include "ext/3dengine/scene_2d.h"
+#include "ext/3dengine/mesh_2d_data.h"
+#include "ext/3dengine/ant_projection.h"
+#include "ext/3dengine/ag_glsl.h"
+#include "/home/david/projects/antargis/rant/ext/game/terrain.h"
+#include "/home/david/projects/antargis/rant/ext/game/height_map.h"
+#include "/home/david/projects/antargis/rant/ext/game/ant_app.h"
+#include "/home/david/projects/antargis/rant/ext/game/map.h"
+#include "/home/david/projects/antargis/rant/ext/game/entity.h"
 #ifdef SWIG
-
+%include "/home/david/projects/antargis/rant/ext/game/terrain.h"
+%include "/home/david/projects/antargis/rant/ext/game/height_map.h"
+%include "/home/david/projects/antargis/rant/ext/game/ant_app.h"
+%include "/home/david/projects/antargis/rant/ext/game/map.h"
+%include "/home/david/projects/antargis/rant/ext/game/entity.h"
 #endif
 #endif

Modified: antargis/branches/rant/ext/game/init.cc
===================================================================
--- antargis/branches/rant/ext/game/init.cc	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/game/init.cc	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,7 +1,11 @@
 #include <ag_debug.h>
 
+#include <minimap.h>
+
 void AG_Init_libantargisgame()
 {
 	TRACE;
+
+	registerMinimapCreator();
 }
 

Modified: antargis/branches/rant/ext/gui/headers.hh
===================================================================
--- antargis/branches/rant/ext/gui/headers.hh	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/gui/headers.hh	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,8 +1,116 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
-
-
+#include "ext/basic/ag_base.h"
+#include "ext/basic/ag_collector.h"
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_debug.h"
+#include "ext/basic/ag_exception.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_profiler.h"
+#include "ext/basic/ag_regex.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_string.h"
+#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_stringstream.h"
+#include "ext/basic/ag_tools.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_video_base.h"
+#include "ext/basic/ag_xml.h"
+#include "ext/basic/ag_plugin.h"
+#include "ext/basic/ag_singleton.h"
+#include "ext/basic/ag_kill.h"
+#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_mutex.h"
+#include "ext/math/ag_gauss.h"
+#include "ext/math/ag_geometry.h"
+#include "ext/math/ag_rand.h"
+#include "ext/math/ag_serial_vec.h"
+#include "ext/math/ant_frustum.h"
+#include "ext/math/ag_algebra.h"
+#include "ext/video/ag_screen.h"
+#include "ext/video/ag_video.h"
+#include "ext/video/GLee.h"
+#include "ext/video/ag_painttarget.h"
+#include "ext/video/ag_color.h"
+#include "ext/video/ag_fontengine.h"
+#include "ext/video/ag_font.h"
+#include "ext/video/ag_surfacemanager.h"
+#include "ext/video/ag_gltexture.h"
+#include "ext/video/ag_surface.h"
+#include "ext/video/ag_texture.h"
+#include "ext/video/ag_glscreen.h"
+#include "ext/video/ag_sdlscreen.h"
+#include "ext/video/ag_sgeexport.h"
+#include "ext/video/ag_draw.h"
+#include "ext/video/ag_png.h"
+#include "ext/video/ag_sdlpainter.h"
+#include "ext/video/ag_glpainter.h"
+#include "ext/video/ag_fbo.h"
+#include "ext/video/ag_vdebug.h"
+#include "ext/video/ag_rendercontext.h"
+#include "ext/video/ag_sdlsurface.h"
+#include "ext/video/ag_texturecache.h"
+#include "ext/video/ag_clip_painttarget.h"
+#include "ext/video/ag_clip.h"
+#include "ext/video/ag_projection.h"
+#include "ext/video/ag_painter.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_layoutfactory.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_widget.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_application.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_table.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_layout.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_colorbutton.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_button.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_screenwidget.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_combo.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_frame.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_text.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_scroller.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_radiogroup.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_tooltip.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_menuitem.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_caption.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_window.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_checkbox.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_theme.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_local.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_edit.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_radio.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_menu.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_background.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_listbox.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_image.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_border.h"
 #ifdef SWIG
-
+%include "/home/david/projects/antargis/rant/ext/gui/ag_layoutfactory.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_widget.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_application.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_table.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_layout.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_colorbutton.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_button.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_screenwidget.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_combo.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_frame.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_text.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_scroller.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_radiogroup.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_tooltip.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_menuitem.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_caption.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_window.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_checkbox.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_theme.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_local.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_edit.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_radio.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_menu.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_background.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_listbox.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_image.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_border.h"
 #endif
 #endif

Modified: antargis/branches/rant/ext/gui/init.cc
===================================================================
--- antargis/branches/rant/ext/gui/init.cc	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/gui/init.cc	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,7 +1,10 @@
 #include <ag_debug.h>
+#include <ag_layout.h>
 
 void AG_Init_libantargisgui()
 {
 	TRACE;
+
+	AGLayout::registerLayouts();
 }
 

Modified: antargis/branches/rant/ext/math/ag_gauss.h
===================================================================
--- antargis/branches/rant/ext/math/ag_gauss.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/math/ag_gauss.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -8,7 +8,7 @@
 template<class TMatrix>
 bool gauss(TMatrix &a,TMatrix &b,int size)
 {
-  TRACE;
+  //TRACE;
   // cdebug("A:\n"<<a.toString());
   // cdebug("B:\n"<<b.toString());
 

Modified: antargis/branches/rant/ext/math/headers.hh
===================================================================
--- antargis/branches/rant/ext/math/headers.hh	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/math/headers.hh	2007-06-22 20:52:07 UTC (rev 1104)
@@ -22,10 +22,14 @@
 #include "ext/basic/ag_singleton.h"
 #include "ext/basic/ag_kill.h"
 #include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_mutex.h"
+#include "/home/david/projects/antargis/rant/ext/math/ag_rand.h"
 #include "/home/david/projects/antargis/rant/ext/math/ag_geometry.h"
-#include "/home/david/projects/antargis/rant/ext/math/ag_rand.h"
+#include "/home/david/projects/antargis/rant/ext/math/ag_algebra.h"
 #ifdef SWIG
+%include "/home/david/projects/antargis/rant/ext/math/ag_rand.h"
 %include "/home/david/projects/antargis/rant/ext/math/ag_geometry.h"
-%include "/home/david/projects/antargis/rant/ext/math/ag_rand.h"
+%include "/home/david/projects/antargis/rant/ext/math/ag_algebra.h"
 #endif
 #endif

Modified: antargis/branches/rant/ext/sound/ag_sound.cc
===================================================================
--- antargis/branches/rant/ext/sound/ag_sound.cc	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/sound/ag_sound.cc	2007-06-22 20:52:07 UTC (rev 1104)
@@ -7,9 +7,4 @@
 
 extern std::map<std::string,Mix_Chunk*> mSounds;
 
-void initSoundEngine()
-{
-
-}
-
 #warning FIXME: cleanup stored sounds ???

Modified: antargis/branches/rant/ext/sound/headers.hh
===================================================================
--- antargis/branches/rant/ext/sound/headers.hh	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/sound/headers.hh	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,8 +1,31 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
-
-
+#include "ext/basic/ag_base.h"
+#include "ext/basic/ag_collector.h"
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_debug.h"
+#include "ext/basic/ag_exception.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_profiler.h"
+#include "ext/basic/ag_regex.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_string.h"
+#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_stringstream.h"
+#include "ext/basic/ag_tools.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_video_base.h"
+#include "ext/basic/ag_xml.h"
+#include "ext/basic/ag_plugin.h"
+#include "ext/basic/ag_singleton.h"
+#include "ext/basic/ag_kill.h"
+#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_mutex.h"
+#include "/home/david/projects/antargis/rant/ext/sound/ag_mixer.h"
 #ifdef SWIG
-
+%include "/home/david/projects/antargis/rant/ext/sound/ag_mixer.h"
 #endif
 #endif

Modified: antargis/branches/rant/ext/sound/init.cc
===================================================================
--- antargis/branches/rant/ext/sound/init.cc	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/sound/init.cc	2007-06-22 20:52:07 UTC (rev 1104)
@@ -6,4 +6,4 @@
 void AG_Init_libantargissound()
 {
 	initSoundEngine();
-}
\ No newline at end of file
+}

Modified: antargis/branches/rant/ext/video/ag_color.h
===================================================================
--- antargis/branches/rant/ext/video/ag_color.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/video/ag_color.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -18,6 +18,8 @@
  * License along with this program.
  */
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #ifndef AG_COLOR_H
 #define AG_COLOR_H
 

Modified: antargis/branches/rant/ext/video/ag_font.h
===================================================================
--- antargis/branches/rant/ext/video/ag_font.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/video/ag_font.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -18,6 +18,8 @@
  * License along with this program.
  */
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #ifndef __AG_FONT_H
 #define __AG_FONT_H
 

Modified: antargis/branches/rant/ext/video/ag_fontengine.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_fontengine.cc	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/video/ag_fontengine.cc	2007-06-22 20:52:07 UTC (rev 1104)
@@ -48,6 +48,7 @@
 
 TTF_Font *getFont(std::string s,int i)
 {
+  TRACE;
   FontInfo info;
   info.pName=s;
   info.size=i;

Modified: antargis/branches/rant/ext/video/ag_fontengine.h
===================================================================
--- antargis/branches/rant/ext/video/ag_fontengine.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/video/ag_fontengine.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -18,6 +18,8 @@
  * License along with this program.
  */
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #ifndef AG_FONTENGINE_H
 #define AG_FONTENGINE_H
 

Modified: antargis/branches/rant/ext/video/ag_painttarget.h
===================================================================
--- antargis/branches/rant/ext/video/ag_painttarget.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/video/ag_painttarget.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -21,6 +21,8 @@
 #ifndef __AG_PAINTTARGET_H
 #define __AG_PAINTTARGET_H
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #include <ag_geometry.h>
 #include <ag_color.h>
 #include <ag_font.h>

Modified: antargis/branches/rant/ext/video/ag_screen.h
===================================================================
--- antargis/branches/rant/ext/video/ag_screen.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/video/ag_screen.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -18,6 +18,8 @@
  * License along with this program.
  */
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #ifndef AG_SCREEN_H
 #define AG_SCREEN_H
 

Modified: antargis/branches/rant/ext/video/ag_surface.h
===================================================================
--- antargis/branches/rant/ext/video/ag_surface.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/video/ag_surface.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -18,6 +18,8 @@
  * License along with this program.
  */
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #ifndef __GUI_SURFACE_H
 #define __GUI_SURFACE_H
 

Modified: antargis/branches/rant/ext/video/ag_texture.h
===================================================================
--- antargis/branches/rant/ext/video/ag_texture.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/video/ag_texture.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -18,6 +18,7 @@
  * License along with this program.
  */
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
 
 #ifndef AG_TEXTURE_H
 #define AG_TEXTURE_H

Modified: antargis/branches/rant/ext/video/ag_video.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_video.cc	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/video/ag_video.cc	2007-06-22 20:52:07 UTC (rev 1104)
@@ -6,6 +6,7 @@
 #include <ag_screen.h>
 #include <ag_sdlscreen.h>
 #include <ag_surfacemanager.h>
+#include <ag_main.h>
 
 #include <SDL_image.h>
 
@@ -19,6 +20,11 @@
 
 static const SDL_VideoInfo *videoInfo;
 
+AGVideoManager::AGVideoManager()
+{
+  mScreen=0;
+}
+
 void AGVideoManager::flip()
 {
   assert(mScreen);
@@ -36,6 +42,7 @@
 */
 void AGVideoManager::initVideo(int w,int h,int d,bool fs,bool gl,int vw,int vh)
 {
+  CTRACE;
   if(mScreen)
     {
       getSurfaceManager()->clear();
@@ -203,3 +210,10 @@
 {
   return lastVHeight;
 }
+
+AGVideoManager *getVideo()
+{
+  AGVideoManager *m=dynamic_cast<AGVideoManager*>(getMain()->getVideo());
+  assert(m);
+  return m;
+}

Modified: antargis/branches/rant/ext/video/ag_video.h
===================================================================
--- antargis/branches/rant/ext/video/ag_video.h	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/video/ag_video.h	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,6 +1,8 @@
 #ifndef AG_VIDEO_H
 #define AG_VIDEO_H
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #include <ag_video_base.h>
 
 #include <string>
@@ -39,6 +41,8 @@
 
 bool glMode();
 
+AGVideoManager *getVideo();
+
 #endif
 
 

Modified: antargis/branches/rant/ext/video/headers.hh
===================================================================
--- antargis/branches/rant/ext/video/headers.hh	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/video/headers.hh	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,5 +1,11 @@
 #ifndef __ANTARGIS_H__
 #define __ANTARGIS_H__
+#include "ext/math/ag_gauss.h"
+#include "ext/math/ag_geometry.h"
+#include "ext/math/ag_rand.h"
+#include "ext/math/ag_serial_vec.h"
+#include "ext/math/ant_frustum.h"
+#include "ext/math/ag_algebra.h"
 #include "ext/basic/ag_base.h"
 #include "ext/basic/ag_collector.h"
 #include "ext/basic/ag_config.h"
@@ -22,12 +28,30 @@
 #include "ext/basic/ag_singleton.h"
 #include "ext/basic/ag_kill.h"
 #include "ext/basic/ag_serial.h"
-#include "ext/math/ag_gauss.h"
-#include "ext/math/ag_geometry.h"
-#include "ext/math/ag_rand.h"
-#include "ext/math/ag_serial_vec.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_mutex.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_painttarget.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_surface.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_video.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_fontengine.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_painter.h"
 #include "/home/david/projects/antargis/rant/ext/video/ag_rendercontext.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_font.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_color.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_screen.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_texture.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_clip.h"
 #ifdef SWIG
+%include "/home/david/projects/antargis/rant/ext/video/ag_painttarget.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_surface.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_video.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_fontengine.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_painter.h"
 %include "/home/david/projects/antargis/rant/ext/video/ag_rendercontext.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_font.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_color.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_screen.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_texture.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_clip.h"
 #endif
 #endif

Modified: antargis/branches/rant/ext/video/init.cc
===================================================================
--- antargis/branches/rant/ext/video/init.cc	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ext/video/init.cc	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,7 +1,11 @@
 #include <ag_debug.h>
+#include <ag_main.h>
+#include <ag_video.h>
 
 void AG_Init_libantargisvideo()
 {
-	TRACE;
+  TRACE;
+  AGVideoManager *video=new AGVideoManager;
+  getMain()->setVideo(video);
 }
 

Modified: antargis/branches/rant/ruby/ant_hljobs.rb
===================================================================
--- antargis/branches/rant/ruby/ant_hljobs.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ruby/ant_hljobs.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -25,7 +25,7 @@
 # The base-class for all of these high-levels job is AntHLJob .
 # 
 
-require 'ents.rb'
+require 'entities.rb'
 
 # Base class for high-level jobs. It contains the basic functions that're needed for usage within
 # AntBoss (AntHero and AntHouse)

Modified: antargis/branches/rant/ruby/antargis.rb
===================================================================
--- antargis/branches/rant/ruby/antargis.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ruby/antargis.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -31,10 +31,11 @@
 # add programdir to path
 $programDir=Dir.pwd+"/ruby"
 $:.push($programDir)
+$:.push($programDir+"/entities")
 
 require 'antargislib.rb'
 require 'dialogs.rb'
-require 'ents.rb'
+require 'entities.rb'
 require 'map.rb'
 require 'view.rb'
 require 'game_result.rb'
@@ -618,9 +619,9 @@
 def startGame(file="savegames/savegame0.antlvl",clientConnection=nil)
 	app=nil
 	if clientConnection
-		app=AntGameApp.new(file,getMain.width,getMain.height,nil,clientConnection)
+		app=AntGameApp.new(file,getVideo.width,getVideo.height,nil,clientConnection)
 	else
-		app=AntGameApp.new(loadFile(file),getMain.width,getMain.height,nil,clientConnection)
+		app=AntGameApp.new(loadFile(file),getVideo.width,getVideo.height,nil,clientConnection)
 	end
 	#app.disableGC
 	app.run

Modified: antargis/branches/rant/ruby/antargislib.rb
===================================================================
--- antargis/branches/rant/ruby/antargislib.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ruby/antargislib.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -19,6 +19,10 @@
 		@@programDir=Dir.pwd+"/ruby"
 		# add programdir to path
 		$:.push(@@programDir)
+
+		@@extDir=Dir.pwd+"/ext"
+		# add programdir to path
+		$:.push(@@extDir)
 	end
 end
 
@@ -83,10 +87,18 @@
 if File.exists?("ext/antargisgame.so")
 	require 'ext/antargisgame'
 else
-	puts "Please run 'rake' before starting this program!"
+	puts "Please run 'rant' before starting this program!"
 	require 'antargisgame'
 end
+
+require 'antargissound.so'
+
 include Antargisgame
+include Antargisbasic
+include Antargisvideo
+include Antargisgui
+include Antargis3dengine
+include Antargissound
 	
 require 'ruby/gui/ag_tools.rb'
 require 'ant_tools'
@@ -175,7 +187,7 @@
 		}
 	
 	
-		@@main=AGMain.new
+		@@main=getMain #AGMain.new
 		xres=1024
 		if getConfig.get("xRes")!=""
 			xres=getConfig.get("xRes").to_i
@@ -200,15 +212,15 @@
 		if @@noVideo.nil?
 			#if xres!=1024 || yres!=768 || $fullscreen
 			dputs @@fullscreen
-			@@main.initVideo(xres,yres,32,@@fullscreen,@@opengl,1024,768)
+			getVideo.initVideo(xres,yres,32,@@fullscreen,@@opengl,1024,768)
 			#end
 		
 			getConfig.set("xRes",xres.to_s)
 			getConfig.set("yRes",yres.to_s)
 			getConfig.set("fullscreen",@@fullscreen.to_s)
 		
-			@@main.setCaption("Antargis")
-			@@main.setIcon("data/gui/editor/tower1.png")
+			getVideo.setCaption("Antargis")
+			getVideo.setIcon("data/gui/editor/tower1.png")
 		end
 	end
 	def MyAntargislib.startGC

Modified: antargis/branches/rant/ruby/campaign.rb
===================================================================
--- antargis/branches/rant/ruby/campaign.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ruby/campaign.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -48,7 +48,10 @@
 		loadscreen.setValue(0)
 		loadscreen.tick
 		begin
-			@app=AntGameApp.new(loadFile(@current),getMain.width,getMain.height,loadscreen)
+			fileContent=loadFile(@current)
+			w=getVideo.width
+			h=getVideo.height
+			@app=AntGameApp.new(fileContent,w,h,loadscreen)
 			@app.run
 			@result=@app.result
 			@app=nil
@@ -213,6 +216,7 @@
 			raise "file not found #{filename}"
 		end
 		puts "CONT"
+		puts filename,filename.class
 		@doc=Document.new(filename)
 		puts "CONT"
 		@xmlRoot=@doc.root

Modified: antargis/branches/rant/ruby/editview.rb
===================================================================
--- antargis/branches/rant/ruby/editview.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ruby/editview.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -18,7 +18,7 @@
 # License along with this program.
 #
 
-require 'ents.rb'
+require 'entities.rb'
 require 'editor/ent_list.rb'
 
 class AntRubyEditView<GLApp

Modified: antargis/branches/rant/ruby/entities/ant_boss.rb
===================================================================
--- antargis/branches/rant/ruby/entities/ant_boss.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ruby/entities/ant_boss.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -18,7 +18,7 @@
 # License along with this program.
 #
 
-require 'ents.rb'
+require 'entities.rb'
 require 'ant_hljobs.rb'
 require 'ant_formations.rb'
 

Modified: antargis/branches/rant/ruby/entities/ant_hero.rb
===================================================================
--- antargis/branches/rant/ruby/entities/ant_hero.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ruby/entities/ant_hero.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -18,7 +18,7 @@
 # License along with this program.
 #
 
-require 'ents.rb'
+require 'entities.rb'
 require 'ant_hljobs.rb'
 require 'ant_boss.rb'
 require 'ant_fire.rb'

Copied: antargis/branches/rant/ruby/entities/entities.rb (from rev 1103, antargis/branches/rant/ruby/entities/ents.rb)

Deleted: antargis/branches/rant/ruby/entities/ents.rb
===================================================================
--- antargis/branches/rant/ruby/entities/ents.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ruby/entities/ents.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,273 +0,0 @@
-#
-# Copyright (c) 2005 by David Kamphausen. All rights reserved.
-#
-# ents.rb
-# by David Kamphausen (david.kamphausen at web.de)
-#
-# The "Antargis" project, including all files needed to compile it,
-# is free software; you can redistribute it and/or use it and/or modify it
-# under the terms of the GNU General Public License as published
-# by the Free Software Foundation; either version 2 of the License,
-# or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-#
-# You should have received a copy of the GNU General Public
-# License along with this program.
-#
-
-require 'ant_local.rb'
-
-# this variables are used for playing sounds, which should be done with AntRubyEntity::playSound
-INNER_VOL_SIZE=9 # size of circle around camera-middle with max volume
-OUTER_VOL_SIZE=25 # size circle around camera describing volume descend
-
-# AntRubyEntity slighty enhances the functionality already provided by AntEntity.
-# This should be used for all the entity-types.
-class AntRubyEntity<AntEntity
-	attr_accessor :birthday
-	attr_reader :uid
-
-	def AntRubyEntity.setMap(map)
-		@@map=map
-	end
-	def getMap
-		@@map
-	end
-
-
-
-	def initialize(p)
-		super(p)
-		@xmlProps={}
-		@birthday=getMap.getTime
-		@mode=""
-		@handlers={}
-		self.learnAmount=0.05
-	
-		@uid=getMap.getUniqueID
-
-		#self.experience=0
-
-		setHunger(0) # general entities have no hunger
-	end
-	def setXMLProp(n,v)
-		@xmlProps[n]=v
-	end
-	def getXMLProp(n)
-		if @xmlProps[n]==nil
-			return ""
-		else
-			return @xmlProps[n]
-		end
-	end
-	def experienceFull
-		super
-		self.experience=1
-	end
-
-	def preloadXML(node)
-		if node.get("birthday")!=""
-			@birthday=node.get("birthday").to_f
-		end
-		@mode=node.get("mode")
-		if node.get("uid")!=""
-			@uid=node.get("uid").to_i
-			getMap.checkUID(@uid)
-		end
-		setName(node.get("name"))
-	end
-
-	def loadXML(node)
-		super
-	end
-	def saveXML(node)
-		super(node)
-		@xmlProps.each{|n,v|
-			node.set(n,v)
-		}
-		if @birthday
-			node.set("birthday", at birthday.to_s)
-		end
-		node.set("mode", at mode)
-		node.set("uid", at uid.to_s)
-	end
-	def getDescription
-		"This is an entity - no more info here."
-	end
-
-	# simple comparison operator, so that ents can be distinguished
-	def <=>(e)
-		to_s<=>e.to_s
-	end
-	def menCount
-		0
-	end
-	def getPlayer
-		nil
-	end
-	def fightTarget
-		@fightTarget
-	end
-	def getRand
-		if false
-			# FIXME - implement me (network code)
-			#rand
-			puts "mrand:#{@mrand}"
-			@mrand||=AGRandomizer.new("")
-			val=@mrand.randFloat(1)
-	
-			puts "#{self} getRand #{val}  #{@mrand}"
-			puts caller.join("\n")
-	
-			return val
-		end
-		agRand(1.0)
-	end
-
-	def setStrength(v)
-		super
-		setMoraleStrength(v*2)
-	end
-	def age
-		((getMap.getTime- at birthday).to_f/YEAR).to_i
-	end
-	def age=(years)
-		@birthday=getMap.getTime-years*YEAR
-	end
-	def getMen
-		[]
-	end
-	def setMode(mode)
-		@mode=mode
-	end
-	def getMode
-		@mode
-	end
-
-	def playSound(name,minDiff=0.5)
-		scene=getMap.getScene
-		d=((scene.getCamera.dim2-getPos2D).length-INNER_VOL_SIZE)
-		vol=1
-		if d>0
-			vol=[(OUTER_VOL_SIZE-d)/OUTER_VOL_SIZE,0].max
-		end
-		AntSound.playSoundGlobal(name,vol,minDiff)
-	end
-
-
-	def isOnOpenWater(p=nil)
-		if (not p)
-			p=getPos2D
-		end
-		getMap.getPos(p).z<-0.2
-	end
-	def isOnWater
-		getMap.getPos(getPos2D).z<0
-	end
-	def xmlName
-		xml=self.class.to_s
-		xml=xml[0..0].downcase+xml[1..1000]
-		return xml
-	end
-
-	def addHandler(eventName,&block)
-		@handlers[eventName]||=[]
-		@handlers[eventName].push(block)
-	end
-
-	def doEvent(name)
-		if @handlers[name]
-			@handlers[name].each{|b|
-				b.call
-			}
-		end
-	end
-
-	def newFightJob(p,target,distance)
-		@fightTarget=target
-		super
-		doEvent(:eventNewFightJob)
-	end
-	def newRestJob(t)
-		super
-		doEvent(:eventNewRestJob)
-	end
-	def eventNoJob
-		super
-		doEvent(:eventNoJob)
-	end
-	def eventJobFinished
-		super
-		doEvent(:eventJobFinished)
-	end
-
-	def resourceChanged	
-		super
-		AntInventory.update(self)
-	end
-
-	def underAttack
-		false
-	end
-
-# 	def _dump(depth)
-# 		[@uid].pack("n")
-# 	end
-# 	def _load(s)
-# 		getMap.getByUID(s.unpack("n"))
-# 	end
-
-
-	def setMesh(subtype="",sym=nil)
-		if subtype.is_a?(SceneNode)
-			puts  "THIS SHOULD NOT BE USED ANY LONGER: setMesh(realMesh) !!!!!!!!!!!!"
-			super(subtype) # wrapper
-			return subtype
-		end
-		@map={:AntSack=>:sack}
-		t=self.class.to_s
-		t=t.gsub("Ant","").downcase
-		t=t.to_sym
-		if sym
-			t=sym
-		end
-		
-		super(mesh=AntModels.createModel(t,subtype))
-		return mesh
-	end
-end
-
-# here comes a list of all the different entity-types BoA currently uses:
-require 'ant_hero.rb'
-require 'ant_sheep.rb'
-require 'ant_man.rb'
-require 'ant_house.rb'
-require 'ant_stone.rb'
-require 'ant_tree.rb'
-require 'ant_deco.rb'
-require 'ant_tower.rb'
-require 'ant_dwelling.rb'
-require 'ant_farm.rb'
-require 'ant_workshop.rb'
-require 'ant_fir.rb'
-require 'ant_grass.rb'
-require 'ant_druid.rb'
-require 'ant_decal.rb'
-require 'ant_sack.rb'
-require 'ant_mine.rb'
-require 'ant_boat.rb'
-require 'ant_fish.rb'
-require 'ant_arrow.rb'
-require 'ant_townhall.rb'
-require 'ant_mill.rb'
-require 'ant_well.rb'
-require 'ant_bakery.rb'
-require 'ant_field.rb'
-require 'ant_wolf.rb'
-require 'ant_buildingsite.rb'
-require 'ant_fishing_hut.rb'
-
-

Modified: antargis/branches/rant/ruby/gui/ag_tools.rb
===================================================================
--- antargis/branches/rant/ruby/gui/ag_tools.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ruby/gui/ag_tools.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -26,7 +26,7 @@
 # checks if libantargis is already loaded
 def hasLibantargis
 	begin
-		x=eval("Libantargis")
+		x=eval("Antargis")
 	rescue
 		return false
 	end
@@ -37,8 +37,8 @@
 
 # if libantargis was not yet loaded, try loading libantargisgui alone
 if not hasLibantargis
-	require 'libantargisgui'
-	include Libantargisgui
+	require 'antargisgui'
+	include Antargisgui
 end
 
 # some old abbrevs
@@ -61,30 +61,29 @@
 	end
 	# add Event Handler - this function should go into AGRubyApp
 	def addHandler(object,event,func)
+		puts event
+		puts object,object.class
 		if not defined? @handlers then
 			@handlers={}
 		end
-		#puts event
-		if object==nil then
+		if object.nil? then
 			raise "AGHandler.addHandler: object does not exist!"
 		else
-			#puts "MY CLASS:",self.class
 			object.send(event).connect(self)
-			hname=object.getName+":"+event.to_s
+			hname=makeHandlerName(object,event)
+			#hname=object.getName+":"+event.to_s
 			@handlers[hname]||=[]
-# 			if @handlers[object.getName+":"+event.to_s]==nil
-# 				@handlers[object.getName+":"+event.to_s]=[]
-# 			end
 			@handlers[hname].push(func)
-			#@handlers.uniq!
 		end
 	end
 	# event dispatcher
 	def signal(e)
 		@handlers||={}
-		callerName=e.getCaller.getName
-		evName=callerName+":"+e.getName
-		puts "#{callerName} #{evName}"
+		mcaller=e.getCaller
+		evName=makeHandlerName(mcaller,e.getName)
+		#callerName=e.getCaller.getName
+		#evName=callerName+":"+e.getName
+		#puts "#{callerName} #{evName}"
 		if @handlers.has_key?(evName) then
 			value=false
 			@handlers[evName].each{|handler|
@@ -107,6 +106,14 @@
 		end
 		return super(e)
 	end
+
+	def makeHandlerName(object,event)
+		if object.respond_to?(:getName)
+			return object.getName+":"+event.to_s
+		else
+			return object.object_id.to_s+":"+event.to_s
+		end
+	end
 end
 
 # this function adds a signal to the current object

Modified: antargis/branches/rant/ruby/mainmenu.rb
===================================================================
--- antargis/branches/rant/ruby/mainmenu.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ruby/mainmenu.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -264,7 +264,9 @@
 		campaignButtons=(0..(buttonCount-1)).to_a.collect{|c|"campaign#{c}"}
 		i=0
 		campaignButtons.each{|b|
+			puts "get widget named: #{b}"
 			c=@campaignMenu.getChild(b)
+			puts "got widget #{c} of type #{c.class}"
 			addHandler(c,:sigClick,:eventMission)
 			if @campaigns.length>i
 				c.setCaption(_(@campaigns[i].name))

Modified: antargis/branches/rant/ruby/tests/algebra_test.rb
===================================================================
--- antargis/branches/rant/ruby/tests/algebra_test.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ruby/tests/algebra_test.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,7 +1,8 @@
 #!/usr/bin/env ruby
 
-require 'libantargis.so'
-include Libantargis
+require 'ruby/antargisgui.rb'
+# libantargis.so'
+# include Libantargis
 
 setDebugLevel(0)
 

Modified: antargis/branches/rant/ruby/tests/basis_test.rb
===================================================================
--- antargis/branches/rant/ruby/tests/basis_test.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ruby/tests/basis_test.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -1,7 +1,6 @@
 #!/usr/bin/env ruby
 
-require 'libantargis.so'
-include Libantargis
+require 'ruby/antargismath.rb'
 
 setDebugLevel(0)
 

Modified: antargis/branches/rant/ruby/tests/clip_gradient_test.rb
===================================================================
--- antargis/branches/rant/ruby/tests/clip_gradient_test.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ruby/tests/clip_gradient_test.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -2,5 +2,5 @@
 
 require 'ruby/antargislib.rb'
 
-initVideo(640,480,32,false,false)
+getVideo.initVideo(640,480,32,false,false)
 

Modified: antargis/branches/rant/ruby/tests/clip_widget_test.rb
===================================================================
--- antargis/branches/rant/ruby/tests/clip_widget_test.rb	2007-06-14 13:01:13 UTC (rev 1103)
+++ antargis/branches/rant/ruby/tests/clip_widget_test.rb	2007-06-22 20:52:07 UTC (rev 1104)
@@ -2,7 +2,7 @@
 
 require 'ruby/antargislib.rb'
 
-getMain.initVideo(640,480,32,false,false)
+getVideo.initVideo(640,480,32,false,false)
 
 setDebugLevel(0)
 



From davidkamphausen at mail.berlios.de  Sat Jun 23 17:07:34 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 23 Jun 2007 17:07:34 +0200
Subject: [Antargis-svn] r1105 - in antargis/branches/rant: build ext
	ext/3dengine ext/basic ext/game ext/gui ext/math ext/sound
	ext/video ruby ruby/gui
Message-ID: <200706231507.l5NF7YET027632@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-23 17:07:27 +0200 (Sat, 23 Jun 2007)
New Revision: 1105

Added:
   antargis/branches/rant/build/cpp_parser.rb
   antargis/branches/rant/build/create_interface_new.rb
   antargis/branches/rant/ext/3dengine/
   antargis/branches/rant/ext/3dengine/ag_glsl.cc
   antargis/branches/rant/ext/3dengine/ag_glsl.h
   antargis/branches/rant/ext/3dengine/anim_mesh.cc
   antargis/branches/rant/ext/3dengine/anim_mesh.h
   antargis/branches/rant/ext/3dengine/anim_mesh_data.cc
   antargis/branches/rant/ext/3dengine/anim_mesh_data.h
   antargis/branches/rant/ext/3dengine/ant_camera.cc
   antargis/branches/rant/ext/3dengine/ant_camera.h
   antargis/branches/rant/ext/3dengine/ant_projection.cc
   antargis/branches/rant/ext/3dengine/ant_projection.h
   antargis/branches/rant/ext/3dengine/ant_renderer.cc
   antargis/branches/rant/ext/3dengine/ant_renderer.h
   antargis/branches/rant/ext/3dengine/glsl.cc
   antargis/branches/rant/ext/3dengine/glsl.h
   antargis/branches/rant/ext/3dengine/headers.hh
   antargis/branches/rant/ext/3dengine/init.cc
   antargis/branches/rant/ext/3dengine/mesh.cc
   antargis/branches/rant/ext/3dengine/mesh.h
   antargis/branches/rant/ext/3dengine/mesh_2d.cc
   antargis/branches/rant/ext/3dengine/mesh_2d.h
   antargis/branches/rant/ext/3dengine/mesh_2d_data.cc
   antargis/branches/rant/ext/3dengine/mesh_2d_data.h
   antargis/branches/rant/ext/3dengine/mesh_data.cc
   antargis/branches/rant/ext/3dengine/mesh_data.h
   antargis/branches/rant/ext/3dengine/mesh_optimizer.cc
   antargis/branches/rant/ext/3dengine/mesh_optimizer.h
   antargis/branches/rant/ext/3dengine/mesh_sort.cc
   antargis/branches/rant/ext/3dengine/mesh_sort.h
   antargis/branches/rant/ext/3dengine/quadtree.h
   antargis/branches/rant/ext/3dengine/scene.cc
   antargis/branches/rant/ext/3dengine/scene.h
   antargis/branches/rant/ext/3dengine/scene_2d.cc
   antargis/branches/rant/ext/3dengine/scene_2d.h
   antargis/branches/rant/ext/3dengine/scene_base.cc
   antargis/branches/rant/ext/3dengine/scene_base.h
   antargis/branches/rant/ext/3dengine/scenenode.cc
   antargis/branches/rant/ext/3dengine/scenenode.h
   antargis/branches/rant/ext/3dengine/templates.i
   antargis/branches/rant/ext/3dengine/vertex_array.cc
   antargis/branches/rant/ext/3dengine/vertex_array.h
   antargis/branches/rant/ext/basic/ag_messageobject.cc
   antargis/branches/rant/ext/basic/ag_messageobject.h
   antargis/branches/rant/ext/basic/ag_mutex.cc
   antargis/branches/rant/ext/basic/ag_mutex.h
   antargis/branches/rant/ext/game/ant_app.cc
   antargis/branches/rant/ext/game/ant_app.h
   antargis/branches/rant/ext/game/entity.cc
   antargis/branches/rant/ext/game/entity.h
   antargis/branches/rant/ext/game/entptr.cc
   antargis/branches/rant/ext/game/entptr.h
   antargis/branches/rant/ext/game/height_map.cc
   antargis/branches/rant/ext/game/height_map.h
   antargis/branches/rant/ext/game/heuristic.cc
   antargis/branches/rant/ext/game/heuristic.h
   antargis/branches/rant/ext/game/jobs.cc
   antargis/branches/rant/ext/game/jobs.h
   antargis/branches/rant/ext/game/map.cc
   antargis/branches/rant/ext/game/map.h
   antargis/branches/rant/ext/game/minimap.cc
   antargis/branches/rant/ext/game/minimap.h
   antargis/branches/rant/ext/game/resource.cc
   antargis/branches/rant/ext/game/resource.h
   antargis/branches/rant/ext/game/terrain.cc
   antargis/branches/rant/ext/game/terrain.h
   antargis/branches/rant/ext/game/water.cc
   antargis/branches/rant/ext/game/water.h
   antargis/branches/rant/ext/gui/ag_application.cc
   antargis/branches/rant/ext/gui/ag_application.h
   antargis/branches/rant/ext/gui/ag_background.cc
   antargis/branches/rant/ext/gui/ag_background.h
   antargis/branches/rant/ext/gui/ag_border.cc
   antargis/branches/rant/ext/gui/ag_border.h
   antargis/branches/rant/ext/gui/ag_button.cc
   antargis/branches/rant/ext/gui/ag_button.h
   antargis/branches/rant/ext/gui/ag_caption.cc
   antargis/branches/rant/ext/gui/ag_caption.h
   antargis/branches/rant/ext/gui/ag_checkbox.cc
   antargis/branches/rant/ext/gui/ag_checkbox.h
   antargis/branches/rant/ext/gui/ag_colorbutton.cc
   antargis/branches/rant/ext/gui/ag_colorbutton.h
   antargis/branches/rant/ext/gui/ag_combo.cc
   antargis/branches/rant/ext/gui/ag_combo.h
   antargis/branches/rant/ext/gui/ag_edit.cc
   antargis/branches/rant/ext/gui/ag_edit.h
   antargis/branches/rant/ext/gui/ag_frame.cc
   antargis/branches/rant/ext/gui/ag_frame.h
   antargis/branches/rant/ext/gui/ag_image.cc
   antargis/branches/rant/ext/gui/ag_image.h
   antargis/branches/rant/ext/gui/ag_layout.cc
   antargis/branches/rant/ext/gui/ag_layout.h
   antargis/branches/rant/ext/gui/ag_layoutcreators.cc
   antargis/branches/rant/ext/gui/ag_layoutfactory.cc
   antargis/branches/rant/ext/gui/ag_layoutfactory.h
   antargis/branches/rant/ext/gui/ag_listbox.cc
   antargis/branches/rant/ext/gui/ag_listbox.h
   antargis/branches/rant/ext/gui/ag_local.cc
   antargis/branches/rant/ext/gui/ag_local.h
   antargis/branches/rant/ext/gui/ag_menu.cc
   antargis/branches/rant/ext/gui/ag_menu.h
   antargis/branches/rant/ext/gui/ag_menuitem.cc
   antargis/branches/rant/ext/gui/ag_menuitem.h
   antargis/branches/rant/ext/gui/ag_radio.cc
   antargis/branches/rant/ext/gui/ag_radio.h
   antargis/branches/rant/ext/gui/ag_radiogroup.cc
   antargis/branches/rant/ext/gui/ag_radiogroup.h
   antargis/branches/rant/ext/gui/ag_screenwidget.cc
   antargis/branches/rant/ext/gui/ag_screenwidget.h
   antargis/branches/rant/ext/gui/ag_scroller.cc
   antargis/branches/rant/ext/gui/ag_scroller.h
   antargis/branches/rant/ext/gui/ag_table.cc
   antargis/branches/rant/ext/gui/ag_table.h
   antargis/branches/rant/ext/gui/ag_text.cc
   antargis/branches/rant/ext/gui/ag_text.h
   antargis/branches/rant/ext/gui/ag_theme.cc
   antargis/branches/rant/ext/gui/ag_theme.h
   antargis/branches/rant/ext/gui/ag_tooltip.cc
   antargis/branches/rant/ext/gui/ag_tooltip.h
   antargis/branches/rant/ext/gui/ag_widget.cc
   antargis/branches/rant/ext/gui/ag_widget.h
   antargis/branches/rant/ext/gui/ag_window.cc
   antargis/branches/rant/ext/gui/ag_window.h
   antargis/branches/rant/ext/math/ag_algebra.cc
   antargis/branches/rant/ext/math/ag_algebra.h
   antargis/branches/rant/ext/math/ant_frustum.cc
   antargis/branches/rant/ext/math/ant_frustum.h
   antargis/branches/rant/ext/sound/ag_mixer.cc
   antargis/branches/rant/ext/sound/ag_mixer.h
   antargis/branches/rant/ext/video/ag_clip.cc
   antargis/branches/rant/ext/video/ag_clip.h
   antargis/branches/rant/ext/video/ag_clip_painttarget.cc
   antargis/branches/rant/ext/video/ag_clip_painttarget.h
   antargis/branches/rant/ext/video/ag_painter.cc
   antargis/branches/rant/ext/video/ag_painter.h
   antargis/branches/rant/ext/video/ag_projection.cc
   antargis/branches/rant/ext/video/ag_projection.h
   antargis/branches/rant/ext/video/ag_sdlsurface.h
   antargis/branches/rant/ext/video/ag_texturecache.cc
   antargis/branches/rant/ext/video/ag_texturecache.h
   antargis/branches/rant/ruby/antargisgui.rb
   antargis/branches/rant/ruby/antargismath.rb
Modified:
   antargis/branches/rant/ext/basic/ag_main.cc
   antargis/branches/rant/ext/game/headers.hh
   antargis/branches/rant/ext/gui/headers.hh
   antargis/branches/rant/ext/video/ag_texture.cc
   antargis/branches/rant/ext/video/ag_vdebug.cc
   antargis/branches/rant/ext/video/ag_video.h
   antargis/branches/rant/ext/video/headers.hh
   antargis/branches/rant/ruby/ant_models.rb
   antargis/branches/rant/ruby/antargis.rb
   antargis/branches/rant/ruby/gui/ag_tools.rb
   antargis/branches/rant/ruby/map.rb
   antargis/branches/rant/ruby/view.rb
Log:
* added many many files


Added: antargis/branches/rant/build/cpp_parser.rb
===================================================================
--- antargis/branches/rant/build/cpp_parser.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/build/cpp_parser.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,45 @@
+#
+# simple c(++) parser
+
+class Parser
+	def initialize
+		@buf=""
+		@lines=[]
+	end
+
+	def parse(content)
+		@buf=content
+		# first remove line-comments
+		@buf.gsub!(/\/\/[^\n]*\n/,"")
+		# remove multi-line-comments
+		@buf.gsub!(/\/\*([^*]|\*[^\/])*\*\//,"")
+
+		# remove preprocessor
+		@buf=@buf.split("\n").collect{|l|l.gsub(/^#.*/,"")}.join("\n")
+
+		@buf.gsub!("virtual","")
+		@buf.gsub!(/(public|protected|private) *:/,"")
+
+		@buf.gsub!(/ +/," ")
+		@buf.gsub!(/\n+/,"\n")
+
+# 		puts @buf
+# 		puts "---"
+
+
+ 		#@buf.scan(/[^{;]*(\{[^}]*\})?;/) {|r|
+ 		@buf.scan(/(([^{;]|\n)*\{[^}]*\};|[^{;]*;)/) {|r|
+ 			puts "R:",r.join("||"),r.class
+ 		}
+
+	end
+
+	def output
+		puts @buf
+	end
+end
+
+f=File.open("ext/gui/ag_messageobject.h","r")
+p=Parser.new
+p.parse(f.read)
+p.output
\ No newline at end of file

Added: antargis/branches/rant/build/create_interface_new.rb
===================================================================
--- antargis/branches/rant/build/create_interface_new.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/build/create_interface_new.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,592 @@
+#!/usr/bin/env ruby
+#
+# Copyright (c) 2005 by David Kamphausen. All rights reserved.
+#
+# create_interface.rb
+# by David Kamphausen (david.kamphausen at web.de)
+#
+# The "Antargis" project, including all files needed to compile it,
+# is free software; you can redistribute it and/or use it and/or modify it
+# under the terms of the GNU General Public License as published
+# by the Free Software Foundation; either version 2 of the License,
+# or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+#
+# You should have received a copy of the GNU General Public
+# License along with this program.
+#
+
+require 'build/interface_template.rb'
+require 'build/base_tools.rb'
+
+class MyInput
+	attr_reader :swigInput, :outputDir
+	def initialize
+		@outputDir=Dir.pwd # default
+		@swigInput=""
+	
+
+		ARGV.each{|a|
+			case a
+				when /^-d=/
+					# in- and output dir
+					@outputDir=a[3..-1]
+				when /^-i=/
+					@swigInput=a[3..-1]
+				when /^-h/, /^--help/
+					@help=true
+					puts "Arguments:"
+					puts " -h, --help     print this help"
+					puts " -d=<DIR>       define output-directory"
+					puts " -i=<SWIGFILE>  define SWIG-input-file (swig.h) - can be set multiple times"
+			end
+		}
+
+		@swigInput=@swigInput.split(":")
+	end
+
+	def valid
+		@outputDir!="" && @help.nil?
+	end
+
+	def interfaceName
+		name=@outputDir+Dir.separator+"interface.i"
+		puts "INTERFACENAME:",name
+		name
+	end
+
+	def moduleName
+		moduleName=makeLibName(@outputDir)
+	end
+	def headersName
+		@outputDir+Dir.separator+"/headers.hh"
+	end
+	def markerName
+		@outputDir+Dir.separator+"marker.i"
+	end
+end
+
+class MClass
+  def initialize(name,superClass)
+    @name=name
+    @superClass=superClass
+  end
+end
+
+class SimpleParser
+	@mclasses=[]
+	def initialize(files)
+	end
+	
+end
+
+def getDirs
+  files=`find ext -type d`.gsub("\r","").split("\n")
+end
+
+def getFiles(dir)
+	Dir[dir+Dir.separator+"*.h"].select{|f|not f=~/swig.h/} #-[dir+Dir.separator+"swig.h"]
+end
+
+def grepBool(filename,string)
+	File.open(filename).each_line{|l|return true if l=~/#{string}/}
+	false
+end
+
+def getSwigInterfaceFiles(files)
+	files.select{|f|
+		grepBool(f,"INCLUDE_SWIG")
+	}
+end
+
+def getClasses
+end
+
+class ParsedClasses
+
+	attr_reader :deriveList
+
+	def initialize(files,allfiles)
+		@rubyClasses=[]
+		@files=files
+		loadAllDerivations(allfiles)
+		@myfiles=files
+		processDerivations
+		initLevels
+	end
+
+
+	def loadAllDerivations(allfiles)
+		@class2File={}
+		@deriveList={} # x=>y :x is child of y
+
+		allfiles.each{|fn|
+			g=File.open(fn)
+			cn=""
+			g.each{|a|
+				abak=a
+				a.gsub!("AGEXPORT","")
+				a.gsub!("EXPORT","")
+				
+				if a =~ /^class.*/ then
+					cn=a.gsub("class ","").gsub(/:.*/,"").gsub("\n","").gsub(" ","")
+					if cn=~/^[A-Z].*/
+						if a=~ /.*public.*/ then
+							pn=a.gsub(/.*public /,"").gsub("\n","")
+							@deriveList[cn]=pn
+							@class2File[cn]=fn
+						elsif not a=~/;/ then
+							@deriveList[cn]=nil
+							@class2File[cn]=fn
+						end
+					end
+				end
+			
+			}
+		}
+		@classList=@class2File.keys
+	end
+
+	def processDerivations
+		@rubyClasses << "AGRubyObject"
+		@classList.sort!.uniq!
+		
+		# check for children of AGWidget
+		changed=true
+		while changed do
+			changed=false
+			@deriveList.each {|x,y|
+				if @rubyClasses.member?(y) and not @rubyClasses.member?(x) then
+					@rubyClasses << x
+					changed=true
+				end
+			}
+		end
+		puts "-------------------------"
+		puts "CLASSLIST:"
+		puts @classList
+
+		puts "-------------------------"
+		puts "RUBY CLASSLIST:"
+		puts @rubyClasses
+
+		puts "-------------------------"
+		puts "DERIVATIONS:"
+			@deriveList.each {|x,y|
+				puts "#{x} #{y} #{@class2File[x]} "
+			}
+		puts "-------------------------"
+		puts "my ruby:"
+		puts getMyRubyClasses
+		puts "-------------------------"
+	end
+
+	def initLevels
+		puts "initLevels..."
+		@levels={}
+		@levels["AGRubyObject"]=0
+		changed=true
+		l=0
+		while changed
+			changed=false
+			@deriveList.each{|x,y|
+				if @levels[y]==l and @levels[x].nil?
+					@levels[x]=l+1
+					changed=true
+				end
+			}
+			l+=1
+		end
+
+		(0..l).each{|i|
+			@levels.each{|n,level|
+				if level==i
+					puts "#{i} #{n}"
+				end
+			}
+		}
+	#if false
+		puts "-------------"		
+		# give classes with no parent next level
+		@classList.each{|c|
+			if @levels[c].nil?
+				if (not @deriveList.keys.member?(c)) 
+					@levels[c]=l
+				end
+			end
+		}
+
+		# repeat process
+		changed=true
+		while changed
+			changed=false
+			@deriveList.each{|x,y|
+				if @levels[y]==l and @levels[x].nil?
+					@levels[x]=l+1
+					changed=true
+				end
+			}
+			l+=1
+		end
+
+		puts "-------------"		
+		# give classes with no parent next level
+		@classList.each{|c|
+			if @levels[c].nil?
+				if (@deriveList[@deriveList[c]].nil?)
+					@levels[c]=l
+				end
+			end
+		}
+
+		# repeat process
+		changed=true
+		while changed
+			changed=false
+			@deriveList.each{|x,y|
+				if @levels[y]==l and @levels[x].nil?
+					@levels[x]=l+1
+					changed=true
+				end
+			}
+			l+=1
+		end
+
+#end
+		(0..l).each{|i|
+			@levels.each{|n,level|
+				if level==i
+					puts "#{i} #{n}"
+				end
+			}
+		}
+		@classList.each{|c|
+			if @levels[c].nil?
+				puts "-- #{c}"
+			end
+		}
+
+		puts "initLevels...ok"
+
+	end
+
+	# in correct order
+	def getFileList
+		files=[]
+		l=@levels.values.max
+		(0..l).each{|i|
+			@levels.each{|n,level|
+				if level==i and @class2File[n]
+					files << @class2File[n]
+				end
+			}
+		}
+
+		puts "getFileList:"
+		puts files,files.class
+		puts "---------"
+
+		@classList.each{|c|
+			if @levels[c].nil? and @class2File[c]
+				files << @class2File[c]
+			end
+		}
+
+		puts "getFileList:"
+		puts files,files.class
+		puts "---------"
+		files=files.select{|f|@myfiles.member?(f)}
+		addfiles=@files-files
+		files+=addfiles
+
+
+		puts "getFileList:"
+		puts files,files.class
+		puts "---------"
+		if files.length>0
+			files.uniq!
+		end
+		puts files,files.class
+		puts "---------"
+		files
+	end
+
+
+	def getMyRubyClasses
+		@rubyClasses.select{|c|@myfiles.member?(@class2File[c])}
+	end
+	def getAllRubyClasses
+		@rubyClasses
+	end
+end
+
+
+def generateInterfaceFile(myInput,files,addfiles)
+	filename=myInput.interfaceName
+	puts "filename:",filename
+	interfaceI=File.open(filename,"w")
+	
+	
+	puts "SWIGINPUTS:",myInput.swigInput,"--------------"
+	
+	interfaceI.puts interface_template(myInput.moduleName,files,myInput.swigInput,addfiles,myInput.outputDir)
+	
+	interfaceI.close
+	
+	filename=myInput.headersName
+	headersH=File.open(filename,"w")
+	headersH.puts "#ifndef __ANTARGIS_H__"
+	headersH.puts "#define __ANTARGIS_H__"
+	headersH.puts addfiles.collect{|f|"#include \"#{f}\""}.join("\n")
+	headersH.puts files.collect{|f|"#include \"#{f}\""}.join("\n")
+	headersH.puts "#ifdef SWIG"
+	headersH.puts files.collect{|f|"%include \"#{f}\""}.join("\n")
+	headersH.puts "#endif"
+	headersH.puts "#endif"
+	headersH.close
+end
+
+
+myInput=MyInput.new
+
+files=getSwigInterfaceFiles(getFiles(myInput.outputDir))
+
+parsedClasses=ParsedClasses.new(files,`find $(pwd) -name "*.h"|grep -v swig`.split("\n"))
+files=parsedClasses.getFileList
+
+#exit
+
+puts "GETFILES:",files,files.class
+
+puts files.join("|")
+
+addfiles=[]
+myInput.swigInput.each{|inDir|
+	pattern=getDir(inDir)+Dir.separator+"*.h"
+	puts "PATTERN:",pattern
+	addfiles+=Dir[pattern].select{|f|not f=~/swig.h/}
+}
+
+generateInterfaceFile(myInput,files,addfiles)
+
+# old implementation
+
+
+classList=[]
+deriveList={} # x=>y :x is child of y
+rubyClasses={} # all, which are derived from AGRubyObject
+class2File={}
+
+
+# take RubyObject as base for RubyObjects :-)
+# so simply search for classes deriveListd from this!
+
+files.each{|fn|
+	g=File.open(fn)
+	cn=""
+	g.each{|a|
+		abak=a
+		a.gsub!("AGEXPORT","")
+		a.gsub!("EXPORT","")
+		
+		if a =~ /^class.*/ then
+			cn=a.gsub("class ","").gsub(/[:;].*/,"").gsub(/\n/,"").gsub(" ","")
+			if cn=~/^[A-Z].*/
+				classList+=[cn]
+				if a=~ /.*public.*/ then
+					pn=a.gsub(/.*public /,"").gsub(/\n/,"")
+					deriveList[cn]=pn
+					rubyClasses[cn]=false
+					rubyClasses[pn]=false
+					class2File[cn]=fn
+				elsif not a=~/;/ then
+					deriveList[cn]=nil
+				end
+			end
+		end
+	
+	}
+}
+
+rubyClasses["AGRubyObject"]=true
+
+classList.sort!.uniq!
+
+# check for children of AGWidget
+changed=true
+while changed do
+	changed=false
+	deriveList.each {|x,y|
+		if rubyClasses[y] and rubyClasses[x]==false then
+			rubyClasses[x]=true
+			changed=true
+		end
+	}
+end
+
+file=File.open(myInput.markerName,"w")
+
+# ok, first marking is included
+parsedClasses.getMyRubyClasses.each {|x|
+	#if y then
+		file.puts "%exception "+x+"::"+x+" {"
+		file.puts "	$action"
+		file.puts "	result->mRUBY=self;"
+		file.puts "#ifdef GCDEBUG"
+		file.puts '     result->mObjName=typeid(*result).name();'
+		file.puts '     printf("%lx   %s\n",self,typeid(*result).name());'
+		file.puts "#endif"
+		file.puts "	result->mRubyObject=true;"
+		file.puts "}"
+		file.puts "%markfunc "+x+" \"general_markfunc\""
+	#end
+}
+
+# calculate class-derivations
+derivations={}
+rubyClasses.each{|x,y|
+	derivations[x]=[]
+}
+deriveList.each{|x,y|
+	if not derivations[y]
+		derivations[y]=[]
+	end
+	derivations[y].push(x)
+}
+changed=true
+while changed
+	changed=false
+	derivations.each{|x,y|
+		y.each{|a|
+			if derivations[a]
+				old=derivations[x]
+				derivations[x]+=derivations[a]
+				derivations[x].sort!
+				derivations[x].uniq!
+				#puts x+":"+old.length.to_s+" "+derivations[x].length.to_s
+				if old.length<derivations[x].length
+					changed=true
+				end
+			end
+		}
+	}
+end
+
+# swig typemaps
+# so that always the lowest children in a derivation hierarchy is returned
+myRubyClasses=parsedClasses.getMyRubyClasses
+parsedClasses.deriveList.keys.each{|s|
+	if myRubyClasses.member?(s)
+		file.puts "%typemap(out) #{s}*{"
+		file.puts " if($1)"
+		file.puts " {"
+		file.puts "   $result=AG_NewPointerObj($1,SWIGTYPE_p_#{s},0);"
+		file.puts " }"
+		file.puts "}"
+
+		file.puts "%typemap(directorin) #{s}*{"
+		file.puts " if($1)"
+		file.puts " {"
+		file.puts "   $input=AG_NewPointerObj($1,SWIGTYPE_p_#{s},0);"
+		file.puts " }"
+		file.puts "}"
+
+	end
+}
+# normal typemaps
+classList.each{|c|
+	file.puts "%typemap(directorout) #{c} {"
+	file.puts " #{c} *b;"
+	file.puts " Data_Get_Struct($input,#{c},b);"
+	file.puts " $result=*b;"
+	file.puts "}"
+}
+
+file.puts "%typemap(directorout) Uint8 {"
+file.puts " $result=NUM2INT($input);"
+file.puts "}"
+
+rubyClasses=parsedClasses.getMyRubyClasses
+allRubyClasses=parsedClasses.getAllRubyClasses
+
+myClasses=[]
+
+deriveList.each{|b,a|
+	if rubyClasses.member?(b) || b=="AGRubyObject"
+		myClasses << b
+	end
+}
+
+myClasses=myClasses.sort.uniq
+
+puts "rubyClasses:",rubyClasses
+puts "myClasses:",myClasses
+
+file.puts <<EOT
+%{
+// cast-function map
+// it contains the mapping from parent-classes=>dyn-cast-functions to child-classes
+#include <string>
+#include <map>
+#include <list>
+#include <iostream>
+
+typedef swig_type_info*(*CastFunction)(void**);
+extern std::map<std::string,std::list<CastFunction> > agCastFunctions;
+%}
+EOT
+
+myClasses.each{|k|
+file.puts <<EOT	
+%{
+// try to cast from #{k} to one of its child classes (if they exist)
+static swig_type_info* #{k}_dynamic_cast(void **ptr)
+  {
+	  std::list<CastFunction> &funcs=agCastFunctions["#{k}"];
+    for(std::list<CastFunction>::iterator i=funcs.begin();i!=funcs.end();i++)
+      {
+         swig_type_info*t=(*i)(ptr);
+	       std::cout<<"test:"<<t<<std::endl;
+         if(t)
+           return t;
+      }
+   return 0;
+ }
+%}
+DYNAMIC_CAST(SWIGTYPE_p_#{k}, #{k}_dynamic_cast);
+EOT
+}
+
+deriveList.each{|b,a|
+	if rubyClasses.member?(b) and allRubyClasses.member?(a)
+		# for each pair generate a casting function and register it into agCastFunctions
+file.puts <<EOT
+%{
+swig_type_info* #{a}2#{b}cast(void **p)
+{
+        #{a}*a=(#{a}*)(*p);
+        #{b}*b=dynamic_cast<#{b}*>(a);
+				printf("TRY CAST #{a} 2 #{b} : %lx\\n",b);
+        if(b)
+        {
+                *p=(void*)b;
+                return SWIGTYPE_p_#{b};
+        }
+        return 0;
+}
+%}
+
+%insert("init") %{
+        agCastFunctions["#{a}"].push_back(&#{a}2#{b}cast);
+%}
+
+
+EOT
+	end
+}
+
+
+

Added: antargis/branches/rant/ext/3dengine/ag_glsl.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/ag_glsl.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ag_glsl.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,298 @@
+#include "ag_glsl.h"
+#include "ag_vdebug.h"
+#include "ag_main.h"
+//#include "scene.h"
+
+std::map<std::string,AGVertexProgram*> mVertexPrograms;
+std::map<std::string,AGFragProgram*> mFragPrograms;
+
+AGVertexProgram *getVertexProgram(const std::string &pFile)
+{
+  std::map<std::string,AGVertexProgram*>::iterator i=mVertexPrograms.find(pFile);
+
+  if(i==mVertexPrograms.end())
+    {
+      AGVertexProgram *p=new AGVertexProgram(pFile);
+      mVertexPrograms[pFile]=p;
+      return p;
+    }
+  return i->second;
+}
+
+AGFragProgram *getFragProgram(const std::string &pFile)
+{
+  std::map<std::string,AGFragProgram*>::iterator i=mFragPrograms.find(pFile);
+
+  if(i==mFragPrograms.end())
+    {
+      AGFragProgram *p=new AGFragProgram(pFile);
+      mFragPrograms[pFile]=p;
+      return p;
+    }
+  return i->second;
+}
+
+int GLSL_ok=-1;
+bool glslOk()
+{
+//  return false;
+  // do not check in each call, because this is slow!!!
+  if(GLSL_ok<0)
+    {
+      GLeeInit();
+      GLSL_ok=(GLEE_ARB_vertex_shader && GLEE_ARB_fragment_shader && GLEE_ARB_shading_language_100);
+    }
+  
+  return GLSL_ok;
+}
+
+void printInfoLog(GLhandleARB obj)
+{
+    int infologLength = 0;
+    int charsWritten  = 0;
+    char *infoLog;
+
+        glGetObjectParameterivARB(obj, GL_OBJECT_INFO_LOG_LENGTH_ARB,
+                                         &infologLength);
+
+    if (infologLength > 0)
+    {
+      printf("GLSL ERROR:\n");
+        infoLog = (char *)malloc(infologLength);
+        glGetInfoLogARB(obj, infologLength, &charsWritten, infoLog);
+                printf("%s\n",infoLog);
+        free(infoLog);
+    }
+}
+
+
+AGVertexProgram::AGVertexProgram(const std::string &pFile)
+{
+  //  CTRACE;
+  if(glslOk())
+    {
+      vertexShader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
+      std::string s=loadFile(pFile);
+      
+      const char*a=s.c_str();
+      const GLcharARB**x=&a;
+      glShaderSourceARB(vertexShader, 1, x,NULL);
+      glCompileShaderARB(vertexShader);
+      printInfoLog(vertexShader);
+      assertGL;
+    }
+}
+
+AGVertexProgram::~AGVertexProgram()
+{
+  CTRACE;
+  if(glslOk() && !hasQuit())
+    glDeleteObjectARB(vertexShader);
+  assertGL;
+}
+
+AGFragProgram::AGFragProgram(const std::string &pFile)
+{
+  mValid=false;
+  //  CTRACE;
+  if(glslOk() && pFile.length()>0)
+    {
+      fragShader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
+      std::string s=loadFile(pFile);
+      const char*a=s.c_str();
+      const GLcharARB**x=&a;
+      glShaderSourceARB(fragShader, 1, x,NULL);
+      glCompileShaderARB(fragShader);
+      printInfoLog(fragShader);
+      mValid=true;
+      assertGL;
+	
+    }
+}
+
+AGFragProgram::AGFragProgram()
+{
+  mValid=false;
+}
+
+AGFragProgram::~AGFragProgram()
+{
+  CTRACE;
+  if(glslOk() && !hasQuit())
+    glDeleteObjectARB(fragShader);
+  assertGL;
+
+}
+
+
+bool AGFragProgram::valid() const
+{
+  return mValid;
+}
+
+
+AGShaderProgram::AGShaderProgram(const std::string &pVertexFile,const std::string &pFragFile):
+  //  vertex(getVertexProgram(pVertexFile)),frag(getFragProgram(pFragFile))
+  vertex(pVertexFile),frag(pFragFile)
+{
+  //  CTRACE;
+  if(glslOk())
+    {
+      p = glCreateProgramObjectARB();
+      glAttachObjectARB(p,vertex.vertexShader);
+      if(frag.valid())
+	glAttachObjectARB(p,frag.fragShader);
+      
+      glLinkProgramARB(p);
+      printInfoLog(p);
+
+      assert(p);
+    }
+  on=false;
+  matrixBuf=new float[16*100];
+  name=pVertexFile+":"+pFragFile;
+  assertGL;
+
+}
+
+AGShaderProgram::~AGShaderProgram()
+{
+  disable();
+  CTRACE;
+  cdebug("name:"<<name);
+  if(glslOk() && !hasQuit())
+    glDeleteObjectARB(p);
+  cdebug("name:"<<name);
+  delete [] matrixBuf;
+  cdebug("name:"<<name);
+  assertGL;
+
+}
+
+
+void AGShaderProgram::enable()
+{
+  if(glslOk())
+    {
+      glUseProgramObjectARB(p);
+      on=true;
+      assertGL;
+
+    }
+}
+void AGShaderProgram::disable()
+{
+  if(glslOk())
+    {
+      glUseProgramObjectARB(0);
+      on=false;
+      assertGL;
+    }
+}
+
+void AGShaderProgram::update(float time)
+{
+  if(glslOk())
+    {
+      enable();
+      doUpdate(time);
+      disable();
+      assertGL;
+    }
+}
+
+void AGShaderProgram::doUpdate(float time)
+{
+}
+
+void AGShaderProgram::sendUniform(const std::string &pName,int i)
+{
+  glUniform1iARB(getLoc(pName),i);
+  assertGL;
+}
+void AGShaderProgram::sendUniform(const std::string &pName,float f)
+{
+  glUniform1fARB(getLoc(pName),f);
+  assertGL;
+}
+void AGShaderProgram::sendUniform(const std::string &pName,const AGVector3 &m)
+{
+  glUniform3fARB(getLoc(pName),m[0],m[1],m[2]);
+  assertGL;
+}
+void AGShaderProgram::sendUniform(const std::string &pName,const AGVector4 &m)
+{
+  glUniform4fARB(getLoc(pName),m[0],m[1],m[2],m[3]);
+  assertGL;
+}
+void AGShaderProgram::sendUniform(const std::string &pName,const AGMatrix4 &m)
+{
+  glUniformMatrix4fvARB(getLoc(pName),1,false,m);
+  assertGL;
+}
+void AGShaderProgram::sendUniform(const std::string &pName,const std::vector<AGMatrix4> &m)
+{
+  assert(m.size()<100);
+  float *p=matrixBuf;
+
+  for(size_t i=0;i<m.size();i++)
+    {
+      const float *s=m[i];
+      for(size_t j=0;j<16;j++)
+	*(p++)=*(s++);
+    }
+  assertGL;
+  glUniformMatrix4fvARB(getLoc(pName),m.size(),false,matrixBuf);
+  assertGL;
+}
+
+GLint AGShaderProgram::getLoc(const std::string &pName)
+{
+  // register only once !
+  
+  std::map<std::string,GLint>::iterator i=locations.find(pName);
+  if(i!=locations.end())
+    return i->second;
+  
+  GLint k=glGetUniformLocationARB(p,pName.c_str());
+  locations.insert(std::make_pair(pName,k));
+  assertGL;
+  return k;
+}
+
+GLint AGShaderProgram::getAttr(const std::string &pName)
+{
+  //  TRACE;
+  // register only once !
+  assert(on);
+  std::map<std::string,GLint>::iterator i=attrs.find(pName);
+  if(i!=attrs.end())
+    return i->second;
+  
+  assertGL;
+  GLint k=glGetAttribLocationARB(p,pName.c_str());
+  //  cdebug("k:"<<k);
+  if(k<0)
+    {
+      cdebug("ERROR:attribute could be get! Maybe it was not defined in the vertex-shader? :"<<pName);
+    }
+  assertGL;
+  attrs.insert(std::make_pair(pName,k));
+  assertGL;
+  return k;
+}
+
+void AGShaderProgram::sendAttribute(const std::string &pName,const std::vector<float> &vf)
+{
+  assertGL;
+  GLint loc=getAttr(pName);
+  assertGL;
+  glEnableClientState(GL_VERTEX_ARRAY);
+  assertGL;
+  glEnableVertexAttribArrayARB(loc); // add array
+  assertGL;
+
+  glVertexAttribPointerARB(loc,1,GL_FLOAT,0,0,&vf[0]); // set attributes (for each vertex an attribute)
+  assertGL;
+}
+

Added: antargis/branches/rant/ext/3dengine/ag_glsl.h
===================================================================
--- antargis/branches/rant/ext/3dengine/ag_glsl.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ag_glsl.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_glsl.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef AG_GLSL_H
+#define AG_GLSL_H
+
+#include "GLee.h"
+//#include "renderer.h"
+#include "ag_tools.h"
+#include "ag_geometry.h"
+
+#include <map>
+
+class Scene;
+
+class AGVertexProgram
+{
+ public:
+  AGVertexProgram(const std::string &pFile);
+  ~AGVertexProgram();
+
+ private:
+  GLhandleARB vertexShader;
+
+  friend class AGShaderProgram;
+};
+
+class AGFragProgram
+{
+ public:
+  AGFragProgram(const std::string &pFile);
+  AGFragProgram();
+  ~AGFragProgram();
+
+  bool valid() const;
+
+ private:
+  GLhandleARB fragShader;
+  bool mValid;
+
+  friend class AGShaderProgram;
+};
+
+
+class AGShaderParameter
+{
+ public:
+  
+};
+
+class AGShaderProgram
+{
+  AGVertexProgram vertex;
+  AGFragProgram frag;
+  std::map<std::string,GLint> locations;
+  std::map<std::string,GLint> attrs;
+  float *matrixBuf;
+  bool on;
+  std::string name;
+ protected:  
+  GLhandleARB p;
+
+ public:
+  AGShaderProgram(const std::string &pVertexFile,const std::string &pFragFile);
+  virtual ~AGShaderProgram();
+  virtual void enable();
+  virtual void disable();
+
+  void update(float time);
+  virtual void doUpdate(float time);
+
+  GLint getLoc(const std::string &pName);
+  GLint getAttr(const std::string &pName);
+
+  void sendUniform(const std::string &pName,int i);
+  void sendUniform(const std::string &pName,float f);
+  void sendUniform(const std::string &pName,const AGVector3 &m);
+  void sendUniform(const std::string &pName,const AGVector4 &m);
+  void sendUniform(const std::string &pName,const AGMatrix4 &m);
+  void sendUniform(const std::string &pName,const std::vector<AGMatrix4> &m);
+
+  void sendAttribute(const std::string &pName,const std::vector<float> &vf);
+};
+
+bool glslOk();
+
+#endif

Added: antargis/branches/rant/ext/3dengine/anim_mesh.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/anim_mesh.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/anim_mesh.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,396 @@
+#include "anim_mesh.h"
+#include "scene.h"
+#include "ag_texturecache.h"
+#include "ag_rendercontext.h"
+
+#include "ag_vdebug.h"
+#include "ag_xml.h"
+#include "ag_fs.h"
+#include "ag_config.h"
+#include "ag_profiler.h"
+#include "entity.h"
+
+#include <math.h>
+
+bool useShaderAnimation(); // imported from anim_mesh_data.cc
+
+
+void setRotation(AGMatrix4 &m,const AGVector3 &angles)
+{
+  double cr = cos( angles[0] );
+  double sr = sin( angles[0] );
+  double cp = cos( angles[1] );
+  double sp = sin( angles[1] );
+  double cy = cos( angles[2] );
+  double sy = sin( angles[2] );
+  // FIXME: maybe the coord must be switched
+
+  m.set(0,0,( float )( cp*cy ));
+  m.set(0,1,( float )( cp*sy ));
+  m.set(0,2,( float )( -sp ));
+    double srsp = sr*sp;
+  double crsp = cr*sp;
+
+  m.set(1,0,( float )( srsp*cy-cr*sy ));
+  m.set(1,1,( float )( srsp*sy+cr*cy ));
+  m.set(1,2,( float )( sr*cp ));
+  
+  m.set(2,0,( float )( crsp*cy+sr*sy ));
+  m.set(2,1,( float )( crsp*sy-sr*cy ));
+  m.set(2,2,( float )( cr*cp ));
+
+}
+
+void setTranslation(AGMatrix4 &m,const AGVector3 &t)
+{
+  m.set(3,0,t[0]);
+  m.set(3,1,t[1]);
+  m.set(3,2,t[2]);
+}
+
+
+void inverseRotate(AGVector3 &v, const AGMatrix4 &m )
+{
+  AGVector3 n;
+  n[0]=v[0]*m.get(0,0) + v[1]*m.get(0,1) + v[2]*m.get(0,2);
+  n[1]=v[0]*m.get(1,0) + v[1]*m.get(1,1) + v[2]*m.get(1,2);
+  n[2]=v[0]*m.get(2,0) + v[1]*m.get(2,1) + v[2]*m.get(2,2);
+  v=n;
+}
+
+void inverseTranslate(AGVector3 &v, const AGMatrix4 &m )
+{
+  v[0]-=m.get(3,0);
+  v[1]-=m.get(3,1);
+  v[2]-=m.get(3,2);
+}
+
+
+
+/////////////////////////////////////////////////////////////////////////
+// AnimMesh
+/////////////////////////////////////////////////////////////////////////
+
+
+AnimMesh::AnimMesh(Scene *pScene,AnimMeshData *data):
+  SceneNode(pScene,AGVector4(),data->bbox()),
+  mData(data),mMatrices(data->bones.size()+1),mShaderMatrices(20)
+{
+  curKey=0;
+  mTime=0;
+  
+  assert(mData->mAnimations.size()>0);
+  mAnimName=mData->mAnimations.begin()->first;
+  mAnimation=&mData->mAnimations.begin()->second;
+
+  mEntity=0;
+  setOrder(MESH_Z);
+
+}
+
+AnimMesh::~AnimMesh()
+{
+  //  CTRACE;
+}
+
+void AnimMesh::setEntity(AntEntity *e)
+{
+  mEntity=e;
+}
+
+
+void AnimMesh::drawDepth()
+{
+  STACKTRACE;
+  drawPrivate(false,false);
+}
+
+void AnimMesh::draw()
+{
+  STACKTRACE;
+  //return;
+  drawPrivate(true,false);
+}
+void AnimMesh::drawPick()
+{
+  STACKTRACE;
+  drawPrivate(false,true);
+}
+
+
+void AnimMesh::drawPrivate(bool textured, bool mem)
+{
+  assertGL;
+  AGRenderContext c;
+  if(textured)
+    {
+      c.setTexture(mData->mTexture.glTexture());
+      
+      c.setLighting(true);
+    }
+  c.begin();
+  glPushMatrix();
+
+  AGVector4 p=getPos();
+  glTranslatef(p[0],p[1],p[2]);
+  glRotatef(mRot[3],mRot[0],mRot[1],mRot[2]);
+
+  bool pick=mem&&(!textured);
+
+
+  if(useShaderAnimation() && !pick)
+    {
+      glMultMatrixf(mData->getTransform());
+      if(textured)
+	{
+	  mData->animShader.enable();
+
+	  mData->animShader.sendUniform("matrices",mShaderMatrices);
+	  
+	  //	  mData->mArrayDepth.setColors(false);
+	  mData->mArray.draw();
+
+	  mData->animShader.disable();
+
+	}
+      else if(mem)
+	{
+	  mData->mArray.drawPick();
+	}
+      else
+	{
+	  mData->animShaderDepth.enable();
+
+	  mData->animShaderDepth.sendUniform("matrices",mShaderMatrices);
+
+	  mData->mArrayDepth.setColors(false);
+
+	  mData->mArrayDepth.draw(); // FIXME: drawDepth makes some problems here
+
+	  mData->animShaderDepth.disable();
+	}
+    }
+
+  else if(!mData->animate)
+    {
+      glBegin(GL_TRIANGLES);
+      
+      // for a start do a simple drawing 
+      for(std::vector<size_t>::iterator i=mData->indices.begin();i!=mData->indices.end();i++)
+	{
+	  AGMatrix4 m(mData->getTransform());
+	  AGVector3 p((m*AGVector4(mData->pos[*i],1)).dim3());
+	  if(textured)
+	    {
+	      AGVector3 n((m*AGVector4(mData->normal[*i],0)).dim3());
+	      
+	      glNormal3fv(n);
+	      glTexCoord2fv(mData->uv[*i]);
+	    }
+	  glVertex3fv(p);
+	  
+	}
+      
+      glEnd();
+    }
+  else
+    {
+
+      // paint with transform
+
+      glMultMatrixf(mData->getTransform());
+
+      glBegin(GL_TRIANGLES);
+      
+      // for a start do a simple drawing 
+      for(std::vector<size_t>::iterator i=mData->indices.begin();i!=mData->indices.end();i++)
+	{
+	  int b=mData->bone[*i];
+	  AGMatrix4 m;
+	  if(b>=0)
+	    {
+	      m=mMatrices[b];
+	    }
+	  AGVector3 p((m*AGVector4(mData->pos[*i],1)).dim3());
+	  if(textured)
+	    {
+	      AGVector3 n((m*AGVector4(mData->normal[*i],0)).dim3());
+	      
+	      glNormal3fv(n);
+	      glTexCoord2fv(mData->uv[*i]);
+	    }
+	  glVertex3fv(p);
+	}
+      
+      glEnd();
+
+
+    }
+  
+  glPopMatrix();
+  assertGL;
+}
+
+void AnimMesh::advance(float time)
+{
+  if(!mData->animate)
+    return;
+  float oldTime=mTime;
+
+  mTime+=mAnimation->fps*time;
+
+  if(mAnimation->len>0)
+    {
+      if(mAnimation->loop)
+	while(mTime>mAnimation->end)
+	  mTime-=mAnimation->len;
+      else
+	mTime=std::min(mTime,mAnimation->end);
+    }
+  else
+    mTime=mAnimation->begin;
+
+  mTime=std::max(mTime,mAnimation->begin);
+
+  //  cdebug(mAnimName<<"  "<<mTime<<"  "<<mAnimation->len<<" "<<mAnimation->begin<<" "<<mAnimation->end);
+
+
+  // check events
+  if(mEntity && mData->frameEvents.size())
+    {
+      if(oldTime>mTime)
+	{
+	  for(std::map<int,AGString>::iterator i=mData->frameEvents.begin();i!=mData->frameEvents.end();i++)
+	    if(i->first>=oldTime || i->first<mTime)
+	      mEntity->animationEvent(i->second);
+	}
+      else
+	{
+	  for(std::map<int,AGString>::iterator i=mData->frameEvents.begin();i!=mData->frameEvents.end();i++)
+	    {
+	      if(i->first>=oldTime && i->first<mTime)
+		mEntity->animationEvent(i->second);
+	    }
+	}
+
+    }
+
+
+  update();
+}
+
+void AnimMesh::update()
+{
+  // this doesn't take much of rendering-time
+  // calculate 
+  
+  while(mTime>mData->animTime)
+    mTime-=mData->animTime;
+  
+  for(size_t k=0;k<mData->bones.size();k++)
+    {
+      Bone *bone=mData->bones[k];
+      AGMatrix4 final(bone->mRelative);
+      AGMatrix4 trans;
+      AGVector3 rot,pos;
+
+      // first get surrounding keyframes (rot & trans) for this bone 
+      // and calculate ri0,ri1 and ti0,ti1 (1-ti0 == ti1)
+
+      rot=bone->interpolateRot(mTime);
+      pos=bone->interpolateTrans(mTime);
+
+      ::setRotation(trans,rot);
+      setTranslation(trans,pos);
+      
+      
+      final=final*trans;
+      
+      if(mData->bones[k]->parent)
+	final=mMatrices[mData->bones[k]->parent->id]*final;
+      
+      mMatrices[k]=final;
+    }
+  mMatrices[mData->bones.size()]=AGMatrix4();
+
+  for(size_t k=0;k<mData->bones.size();k++)
+    mShaderMatrices[k]=mData->getTransform()*mMatrices[k];
+  mShaderMatrices[mData->bones.size()]=mData->getTransform()*mMatrices[mData->bones.size()];
+
+
+  for(size_t k=0;k<mData->bones.size();k++)
+    mShaderMatrices[k]=mMatrices[k];
+
+  mShaderMatrices[mData->bones.size()]=mMatrices[mData->bones.size()];
+}
+
+
+AnimMeshData *AnimMesh::getData()
+{
+  return mData;
+}
+
+
+void AnimMesh::setTransform(const AGMatrix4 &m)
+{
+  mTransform=m;
+  assert(mData);
+  mComplete=mData->getTransform()*mTransform;
+}
+
+void AnimMesh::setPos(const AGVector3 &p)
+{
+  SceneNode::setPos(p);
+
+  mTransform=AGMatrix4(mRot[3],mRot.dim3())*AGMatrix4(getPos());//p);//mPos);
+
+  assert(mData);
+  mComplete=mData->getTransform()*mTransform;
+}
+void AnimMesh::setRotation(const AGVector3 &r,float a)
+{
+  mRot=AGVector4(r,a);
+
+  mTransform=AGMatrix4(a,r)*AGMatrix4(getPos());
+
+  assert(mData);
+  mComplete=mData->getTransform()*mTransform;
+}
+
+void AnimMesh::setRotation(float r)
+{
+  setRotation(AGVector3(0,0,1),r+180);
+}
+
+AGString AnimMesh::getAnimation() const
+{
+  return mAnimName;
+}
+
+bool AnimMesh::setAnimation(const AGString &pName)
+{
+  if(mAnimName==pName)
+    return true;
+  if(mData->mAnimations.find(pName)==mData->mAnimations.end())
+    {
+      cdebug(AGString("Animation ")+pName+" is known here!");
+      return false;
+    }
+
+  mAnimation=&(mData->mAnimations[pName]);
+  mAnimName=pName;
+  mTime=mAnimation->begin;
+  return true;
+}
+
+void AnimMesh::mark()
+{
+  markObject(mData);
+}
+
+size_t AnimMesh::getTriangles() const
+{
+  return mData->indices.size()/3;
+}
+
+

Added: antargis/branches/rant/ext/3dengine/anim_mesh.h
===================================================================
--- antargis/branches/rant/ext/3dengine/anim_mesh.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/anim_mesh.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,70 @@
+#ifndef ANIM_MESH_H
+#define ANIM_MESH_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include "scene.h"
+#include "ag_surface.h"
+#include "ag_geometry.h"
+#include "scenenode.h"
+
+#include <vector>
+#include <map>
+
+#include "anim_mesh_data.h"
+
+class AntEntity;
+
+/**
+   AnimMesh is a skeleton animated mesh.
+   It support either shader-based and cpu-based animation.
+*/
+class AnimMesh:public SceneNode
+{
+  AnimMeshData *mData;
+  size_t curKey;
+  float mTime;
+  AGMatrix4 mTransform;
+  AGMatrix4 mComplete;
+  AGVector4 mRot;
+  AGString mAnimName;
+  Animation *mAnimation;
+  AntEntity *mEntity;
+
+  std::vector<AGMatrix4> mMatrices;
+  std::vector<AGMatrix4> mShaderMatrices;
+
+ public:
+  AnimMesh(Scene *pScene,AnimMeshData *data);
+  virtual ~AnimMesh();
+
+  void setTransform(const AGMatrix4 &m);
+
+  AGString getAnimation() const;
+  bool setAnimation(const AGString &pName);
+
+  void setPos(const AGVector3 &p);
+  void setRotation(const AGVector3 &r,float a);
+  void setRotation(float r);
+
+  AnimMeshData *getData();
+
+  virtual void draw();
+  virtual void drawDepth();
+  virtual void drawPick();
+  virtual void advance(float time);
+	
+  virtual void mark();
+
+  void setEntity(AntEntity *e);
+
+  virtual size_t getTriangles() const;
+
+ private:
+
+  void drawPrivate(bool textured,bool mem);
+
+  void update();
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/anim_mesh_data.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/anim_mesh_data.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/anim_mesh_data.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,337 @@
+#include "anim_mesh_data.h"
+#include "ag_texturecache.h"
+#include "ag_config.h"
+#include "ag_xml.h"
+
+#include <ag_serial.h>
+
+void setRotation(AGMatrix4 &m,const AGVector3 &angles); // from anim_mesh.cc
+void setTranslation(AGMatrix4 &m,const AGVector3 &t);
+void inverseRotate(AGVector3 &v, const AGMatrix4 &m );
+void inverseTranslate(AGVector3 &v, const AGMatrix4 &m );
+
+
+bool useAnimation()
+{
+  bool anim=getConfig()->get("animationType")!="false";
+  getConfig()->set("animationType",anim?"true":"false");
+  return anim;
+}
+
+bool useShaderAnimation()
+{
+  return glslOk() && GLEE_ARB_vertex_buffer_object; // doesn't work with vbos
+}
+
+AGVector3 Bone::interpolate(const std::vector<KeyFrame> &frames,float t)
+{
+  size_t i;
+  for(i=0;i<frames.size();i++)
+    {
+      if(frames.size()>i+1)
+	{
+	  if(frames[i+1].time>t)
+	    break;
+	}
+      else
+	break;
+    }
+  size_t j=i+1;
+  if(j>=frames.size())
+    return frames[i].v;
+  
+  float t0=frames[i].time;
+  float t1=frames[j].time;
+
+  float i0=(t-t0)/(t1-t0);
+  float i1=1-i0;
+
+  return frames[i].v*i1 + frames[j].v*i0;
+}
+AGVector3 Bone::interpolateRot(float t)
+{
+  return interpolate(rFrames,t);
+}
+AGVector3 Bone::interpolateTrans(float t)
+{
+  return interpolate(tFrames,t);
+}
+
+
+
+AnimMeshData::AnimMeshData(const AGFilename &xmlfile):
+  animShader("data/shaders/anim.vert","data/shaders/anim.frag"),
+  //  animShaderDepth("data/shaders/anim_depth.vert",""),
+  animShaderDepth("data/shaders/anim_depth.vert","data/shaders/anim_depth.frag"),
+  mArray(&animShader),
+  mArrayDepth(&animShaderDepth)
+{
+  Document doc(xmlfile);
+
+  Node &root=doc.root();
+
+  events=false;
+
+  animate=true;
+  if(root.get("debug")=="true")
+    animate=false;
+  if(!useAnimation())
+    animate=false;
+
+  cdebug("loading from:"<<root.get("model"));
+
+  loadAnt3(loadFile(root.get("model")),root.get("scale").toFloat(),root.get("texture"));
+  
+  // load animations
+  
+  cdebug("animTime:"<<animTime);
+
+  Node::NodeVector anims=root.getChildren("animation");
+  for(Node::NodeVector::iterator i=anims.begin();i!=anims.end();i++)
+    {
+      float begin=(*i)->get("begin").toFloat()-1;
+      float end=(*i)->get("end").toFloat()-1;
+      float fps=(*i)->get("fps").toFloat();
+      assert(fps>0);
+      assert(begin>=0);
+      assert(begin<animTime);
+      assert(begin<=end);
+      assert(end<animTime);
+      mAnimations[(*i)->get("name")]=Animation(begin,end,fps);
+
+      mAnimations[(*i)->get("name")].loop=((*i)->get("loop")!="false");
+
+      // parse events
+      Node::NodeVector enodes=(*i)->getChildren("event");
+      for(Node::NodeVector::iterator j=enodes.begin();j!=enodes.end();j++)
+	{
+	  frameEvents.insert(std::make_pair((*j)->get("frame").toInt(),(*j)->get("name")));
+	}
+      
+    }
+
+  if(anims.size()==0)
+    {
+      std::cerr<<"There are no animations in "<<xmlfile<<std::endl;
+      throw std::string("no animations found in xmlfile");
+    }
+  mName=AGString(xmlfile);
+}
+
+AnimMeshData::~AnimMeshData()
+{
+  CTRACE;
+  cdebug(mName);
+
+  // delete bones
+  for(std::vector<Bone*>::iterator i=bones.begin();i!=bones.end();++i)
+    delete *i;
+
+
+}
+
+AGBox3 AnimMeshData::bbox() const
+{
+  return mBBox;
+}
+
+void AnimMeshData::setEvents(bool e)
+{
+  events=e;
+}
+
+
+int getMeshDownScale()
+{
+  int s=1;
+  AGString n="meshDownScaleExp";
+
+  if(getConfig()->get(n)!="")
+    s=getConfig()->get(n).toInt();
+  
+  getConfig()->set(n,AGString(s));
+
+  return s;
+
+}
+
+void AnimMeshData::loadAnt3(const AGData &instr,float scale,const AGFilename &tex)
+{
+  mTexture=getTextureCache()->get(tex,getMeshDownScale());
+  BinaryStringIn l(instr);
+
+  Uint32 vs,ts;
+
+  l>>vs;
+  for(Uint32 i=0;i<vs;i++)
+    {
+      float x,y,z,tx,ty,nx,ny,nz;
+      Sint32 boneID;
+      l>>x>>y>>z>>tx>>ty>>boneID>>nx>>ny>>nz;
+
+      AGVector3 v(x,y,z);
+      v*=scale;
+      mBBox.include(v);
+      pos.push_back(v);
+      uv.push_back(AGVector2(tx,1-ty));
+      normal.push_back(AGVector3(nx,ny,nz));
+      bone.push_back(boneID);
+    }
+
+  l>>ts;
+  Uint32 index;
+  for(Uint32 i=0;i<ts*3;i++)
+    {
+      l>>index;
+      indices.push_back(index);
+    }
+
+  Uint32 nbones,frames;
+  l>>frames>>nbones;
+
+  for(size_t k=0;k<bone.size();k++)
+    {
+      if(bone[k]==-1)
+	{
+	  bonef.push_back(nbones);
+	  boneui.push_back(nbones);
+	}
+      else
+	{
+	  bonef.push_back(bone[k]);
+	  boneui.push_back(bone[k]);
+	}
+    }
+
+
+  animTime=frames;
+
+  for(Uint32 i=0;i<nbones;i++)
+    {
+      float x,y,z,rx,ry,rz;
+      Sint32 parent;
+      l>>x>>y>>z>>rx>>ry>>rz>>parent;
+      Bone *bone=new Bone;
+      bone->id=i;
+      bone->pos=AGVector3(x,y,z)*scale;
+      bone->rot=AGVector3(rx,ry,rz);
+      if(parent<0)
+	bone->parent=0;
+      else
+	{
+	  assert(parent<(int)i);
+	  bone->parent=bones[parent];
+	}
+
+      // read rot-frames
+      Sint32 frames;
+      l>>frames;
+      KeyFrame frame;
+      for(Sint32 r=0;r<frames;r++)
+	{
+	  float x,y,z,t;
+	  l>>t>>x>>y>>z;
+	  frame.time=t;
+	  frame.v=AGVector3(x,y,z);
+	  bone->rFrames.push_back(frame);
+	}
+
+      l>>frames;
+      for(Sint32 r=0;r<frames;r++)
+	{
+	  float x,y,z,t;
+	  l>>t>>x>>y>>z;
+	  frame.time=t;
+	  frame.v=AGVector3(x,y,z)*scale;
+	  bone->tFrames.push_back(frame);
+	}
+
+
+
+      bones.push_back(bone);
+    }
+
+  if(animate)
+    setupJoints();
+
+  setupArray();
+}
+
+void AnimMeshData::setTransform(const AGMatrix4 &m)
+{
+  mBase=m;
+}
+
+const AGMatrix4 &AnimMeshData::getTransform() const
+{
+  return mBase;
+}
+
+
+void AnimMeshData::setupJoints()
+{
+  for (std::vector<Bone*>::iterator i = bones.begin(); i!=bones.end(); i++ )
+    {
+      Bone& joint = **i;
+
+      setRotation(joint.mRelative, joint.rot);
+      setTranslation(joint.mRelative, joint.pos);
+
+      if(joint.parent)
+	joint.mAbsolute=joint.parent->mAbsolute*joint.mRelative;
+      else
+	joint.mAbsolute=joint.mRelative;
+
+    }
+
+  for (size_t i=0;i<pos.size();i++)
+    {
+      if(bone[i]!=-1)
+	{
+	  AGMatrix4 m(bones[bone[i]]->mAbsolute);
+	  AGVector3 test=pos[i];
+	  inverseTranslate(pos[i],m);
+	  inverseRotate(pos[i],m);
+
+	  // normals
+	  inverseRotate(normal[i],m);
+	}
+    }
+}
+
+
+void AnimMeshData::setupArray()
+{
+  for(size_t i=0;i<pos.size();i++)
+    mArray.addVertex(AGVector4(pos[i],1),AGVector4(1,1,1,1),normal[i],uv[i]);
+  for(size_t i=0;i<indices.size();i+=3)
+    mArray.addTriangle(indices[i],indices[i+1],indices[i+2]);
+
+  // set boneIDs
+  mArray.addAttribute("bones",bonef);
+  //  mArray.addAttribute("ibones",boneui);
+
+
+
+
+  for(size_t i=0;i<pos.size();i++)
+    mArrayDepth.addVertex(AGVector4(pos[i],1),AGVector4(1,1,1,1),normal[i],uv[i]);
+  for(size_t i=0;i<indices.size();i+=3)
+    mArrayDepth.addTriangle(indices[i],indices[i+1],indices[i+2]);
+
+  // set boneIDs
+  mArrayDepth.addAttribute("bones",bonef);
+  //  mArrayDepth.addAttribute("ibones",boneui);
+
+
+}
+
+std::vector<std::string> AnimMeshData::getAnimations() const
+{
+  std::vector<std::string> l;
+
+  for(std::map<AGString,Animation>::const_iterator i=mAnimations.begin();i!=mAnimations.end();i++)
+    l.push_back(i->first);
+
+  return l;
+}

Added: antargis/branches/rant/ext/3dengine/anim_mesh_data.h
===================================================================
--- antargis/branches/rant/ext/3dengine/anim_mesh_data.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/anim_mesh_data.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,109 @@
+#ifndef ANIM_MESH_DATA_H
+#define ANIM_MESH_DATA_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include "vertex_array.h"
+#include "glsl.h"
+#include "ag_texture.h"
+
+struct KeyFrame
+{
+  float time;
+  AGVector3 v;
+};
+
+struct Bone
+{
+  size_t id;
+  AGVector3 pos,rot;
+  AGMatrix4 mRelative,mAbsolute,mFinal;
+
+  Bone *parent;
+
+  std::vector<KeyFrame> rFrames,tFrames;
+
+
+  AGVector3 interpolateRot(float t);
+  AGVector3 interpolateTrans(float t);
+
+  AGVector3 interpolate(const std::vector<KeyFrame> &frames,float t);
+};
+
+struct Animation
+{
+  float begin;
+  float end;
+  float fps;
+  float len;
+  bool loop;
+
+  Animation()
+  {
+    begin=end=fps=1;
+    len=0;
+  }
+  Animation(float b,float e,float f):begin(b),end(e),fps(f)
+  {
+    len=end-begin;
+  }
+};
+
+class AnimMeshData:public AGRubyObject
+{
+  AntShaderProgram animShader;
+  AntShaderProgram animShaderDepth;
+  VertexArrayShader mArray;
+  VertexArrayShader mArrayDepth;
+
+  std::vector<AGVector3> pos;
+  std::vector<AGVector2> uv;
+  std::vector<AGVector3> normal;
+  std::vector<int> bone;
+  std::vector<float> bonef;
+  std::vector<Uint16> boneui;
+
+  std::vector<size_t> indices;
+
+  std::vector<Bone*> bones;
+
+  std::map<int,AGString> frameEvents;
+
+  float animTime;
+
+  AGTexture mTexture;
+
+  AGMatrix4 mBase;
+
+  std::map<AGString,Animation> mAnimations;
+
+  AGBox3 mBBox;
+
+  bool animate;
+
+  AGString mName;
+
+  bool events;
+
+ private:
+  void setupJoints();
+  void setupArray();
+  void loadAnt3(const AGData &instr,float scale,const AGFilename &pTexName);
+
+ public:
+  AnimMeshData(const AGFilename &xmlfile);
+  ~AnimMeshData();
+
+  AGBox3 bbox() const;
+
+  void setEvents(bool e);
+
+  void setTransform(const AGMatrix4 &m);
+  const AGMatrix4 &getTransform() const;
+
+  friend class AnimMesh;
+
+  std::vector<std::string> getAnimations() const;
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/ant_camera.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_camera.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ant_camera.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,268 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ant_camera.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ant_camera.h"
+#include "ant_renderer.h"
+#include <GL/gl.h>
+#include <GL/glu.h>
+#include <math.h>
+
+#include "ag_debug.h"
+
+AntCamera::AntCamera(int w,int h)
+{
+  mWidth=w;
+  mHeight=h;
+
+  cameraPosition=AGVector4(0,-20,20);
+  lightPosition=AGVector4( -25, -50, 60,1);
+  scenePosition=AGVector4(0,0,0,1);
+
+  cameraPosition=AGVector4(0,-15,15);
+
+  mPSM=false;
+  updateMatrices();
+}
+
+void AntCamera::incCameraDistance()
+{
+  float d=cameraPosition[2]+0.3;
+
+  d=std::min(d,20.0f);
+  cameraPosition=AGVector4(0,-d,d);
+  updateMatrices();
+}
+void AntCamera::decCameraDistance()
+{
+  float d=cameraPosition[2]-0.3;
+
+  d=std::max(d,12.0f);
+  cameraPosition=AGVector4(0,-d,d);
+  updateMatrices();
+}
+
+
+void AntCamera::updateMatrices()
+{
+
+  // 1. init camera view matrix
+  glMatrixMode(GL_MODELVIEW);
+  glLoadIdentity();
+  gluLookAt(cameraPosition[0]+scenePosition[0],cameraPosition[1]+scenePosition[1],cameraPosition[2]+scenePosition[2],
+	    scenePosition[0],scenePosition[1],scenePosition[2],
+	    0,0,1);
+  glGetFloatv(GL_MODELVIEW_MATRIX, cameraView);
+  
+  // 2. init camera projection matrix
+  
+  glMatrixMode(GL_PROJECTION);
+  glLoadIdentity();
+  gluPerspective(45.0f, ((float)mWidth)/mHeight, 3.0f, 63.0f);
+  glGetFloatv(GL_PROJECTION_MATRIX, cameraProjection);
+  glMatrixMode(GL_MODELVIEW);
+  if(mPSM)
+    {
+      // PSM
+      // calculation of lightposition is somehow crappy
+
+
+      // PSMs
+      //  lightPosition=AGVector4( -2.0, -3, 5.1,1)*100;
+      
+      // light View Matrix
+      glLoadIdentity();
+      
+      AGVector4 lp=lightPosition;
+      //    lp[
+      lp[3]=1;
+      lp=cameraProjection*cameraView*lp;
+      
+      lp/=lp[3];
+      
+      // it is something like (12,-10,10)
+      
+      
+      
+      
+      lp=AGVector4(-0.5,1.5,-0.5,1); // should be something like this 
+      lp*=100;
+      
+      
+      //lp=AGVector4(-2,2,-2,1);
+      gluLookAt(lp[0], lp[1], lp[2],
+		0,0,0,
+		0.0f, 1.0f, 0.0f);
+      glGetFloatv(GL_MODELVIEW_MATRIX, lightView);
+      
+      lightView=lightView*cameraProjection*cameraView;
+      // light projection Matrix
+      glLoadIdentity();
+      //    glOrtho(-10,10,-15,20,10,1000);
+      cdebug(lp.toString());
+      float s2=sqrt(2.0f);
+      float ldist=lp.length3();
+      
+      glOrtho(-s2,s2,-s2,s2,ldist-2*s2,ldist+10);//1,10);//ldist-2*s2,ldist+10*s2);
+      
+      
+      //very old:glOrtho(-1,2,-1.5,3,700,750);
+      //      glOrtho(-1,2,-1,1,2,8);
+      
+      glGetFloatv(GL_MODELVIEW_MATRIX, lightProjection);
+    }
+
+    {
+      //  lightPosition=AGVector4( -1.0, -3, 5.1,1);
+      
+      // calc light view,too
+      // light View Matrix
+      glLoadIdentity();
+      gluLookAt(lightPosition[0]+scenePosition[0], lightPosition[1]+scenePosition[1], lightPosition[2]+scenePosition[2],
+		scenePosition[0],scenePosition[1],scenePosition[2],
+		0.0f, 0.0f, 1.0f);
+      glGetFloatv(GL_MODELVIEW_MATRIX, lightView);
+      
+      
+      // light projection Matrix
+      glLoadIdentity();
+      
+	{
+#warning "add some decent calculation here"
+	  // use getFrustum for estimating a good light-frustum
+
+	  float near0=20,near1=60;
+	  float far0=20,far1=110;
+
+	  float mnear=sqrt(near0*near0+near1*near1);
+	  float mfar=sqrt(far0*far0+far1*far1);
+	  
+	  float left=-25;
+	  float right=14;
+	  float bottom=-15;
+	  float top=14;
+
+	  if(getRenderer()->badShadowMap())
+	    top=bottom+(top-bottom)*1024.0f/768.0f;
+
+	  glFrustum(left, right, bottom, top,
+		    mnear,mfar);
+
+	}
+      
+      glGetFloatv(GL_MODELVIEW_MATRIX, lightProjection);
+    }
+
+    // viewport
+  glMatrixMode(GL_MODELVIEW);
+    
+}
+
+
+Viewport AntCamera::getViewport() const
+{
+  Viewport p;
+  p.viewport[0]=0;
+  p.viewport[1]=0;
+  p.viewport[2]=mWidth;
+  p.viewport[3]=mHeight;
+  return p;
+}
+AGMatrix4 AntCamera::getModelview() const
+{
+  return cameraView;
+}
+AGMatrix4 AntCamera::getProjection() const
+{
+  return cameraProjection;
+}
+
+void AntCamera::setPosition(const AGVector3 &p)
+{
+  scenePosition=AGVector4(p,1);
+  updateMatrices();
+}
+
+AGVector4 AntCamera::getCameraPosition() const
+{
+  return AGVector4(scenePosition.dim3()+cameraPosition.dim3(),1);
+}
+AGVector4 AntCamera::getCameraPositionR() const
+{
+  return cameraPosition;
+}
+
+AGVector4 AntCamera::getLightPosition() const
+{
+  return AGVector4(scenePosition.dim3()+lightPosition.dim3(),1);
+}
+
+
+AGVector3 AntCamera::getPosition() const
+{
+  return scenePosition.dim3();
+}
+
+int AntCamera::getWidth() const
+{
+  return mWidth;
+}
+int AntCamera::getHeight() const
+{
+  return mHeight;
+}
+
+AGMatrix4 AntCamera::getLightComplete() const
+{
+  float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
+		0.0f, 0.5f, 0.0f, 0.0f,
+		0.0f, 0.0f, 0.5f, 0.0f,
+		0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
+  static AGMatrix4 biasMatrix(bias);
+  return biasMatrix*lightProjection*lightView;
+}
+
+AGMatrix4 AntCamera::getLightView() const
+{
+  return lightView;
+}
+AGMatrix4 AntCamera::getLightProjectionMatrix() const
+{
+  return lightProjection;
+}
+
+AntProjection AntCamera::getCameraProjection() const
+{
+  return AntProjection(getModelview(),getProjection(),getViewport());
+}
+AntProjection AntCamera::getLightProjection() const
+{
+  return AntProjection(getLightView(),getLightProjectionMatrix(),getViewport());
+}
+
+void AntCamera::setWidth(int w)
+{
+  mWidth=w;
+  updateMatrices();
+}
+void AntCamera::setHeight(int h)
+{
+  mHeight=h;
+  updateMatrices();
+}

Added: antargis/branches/rant/ext/3dengine/ant_camera.h
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_camera.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ant_camera.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ant_camera.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef ANT_CAMERA_H
+#define ANT_CAMERA_H
+
+#include <GLee.h>
+
+#include <ant_frustum.h>
+#include <ant_projection.h>
+#include <ag_rubyobj.h>
+
+/**
+   \brief a camera object for moving over a height map
+   \ingroup Engine3d
+
+   This function provides functions for moving a camera about and
+   computation of the used 4x4-matrixes for camera-view and lighting (mainly used for shadows)
+ */
+
+
+class AntCamera
+{
+ public:
+  AntCamera(int w,int h);
+
+  void incCameraDistance();
+  void decCameraDistance();
+
+  Viewport getViewport() const;
+  AGMatrix4 getModelview() const;
+  AGMatrix4 getProjection() const;
+
+  /// affects scenePosition
+  void setPosition(const AGVector3 &p);
+
+  /// returns absolute camera position
+  AGVector4 getCameraPosition() const;
+  AGVector4 getCameraPositionR() const;
+  AGVector4 getLightPosition() const;
+  AGVector3 getPosition() const;
+
+  int getWidth() const;
+  int getHeight() const;
+
+  void setWidth(int w);
+  void setHeight(int h);
+
+  AGMatrix4 getLightComplete() const;
+  AGMatrix4 getLightView() const;
+  AGMatrix4 getLightProjectionMatrix() const;
+
+  AntProjection getCameraProjection() const;
+  AntProjection getLightProjection() const;
+
+ private:
+
+  void updateMatrices();
+
+
+  /// this position is changed when moving around
+  AGVector4 scenePosition; 
+  /// camera and light position are fixed - to be understand as relative positions to scenePosition
+  AGVector4 cameraPosition;
+  AGVector4 lightPosition;
+
+  AGMatrix4 lightView,lightProjection;
+  AGMatrix4 cameraView,cameraProjection;
+
+  AGMatrix4 cameraPick;
+
+  /// use perspective shadow maps ?
+  bool mPSM; 
+
+  int mWidth,mHeight;
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/ant_projection.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_projection.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ant_projection.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,68 @@
+#include "ant_projection.h"
+
+#include <GL/glu.h>
+
+
+AntProjection::AntProjection(const AGMatrix4 &pMv,const AGMatrix4 &pPr,const Viewport &pVp):
+  modelview(pMv),projection(pPr),viewport(pVp)
+{
+}
+
+AGVector3 AntProjection::project(const AGVector3 &p) const
+{
+  GLdouble x,y,z;
+
+  GLdouble mv[16],pr[16];
+  for(int i=0;i<16;i++)
+    { 
+      mv[i]=((const float*)modelview)[i];
+      pr[i]=((const float*)projection)[i];
+    }
+
+  gluProject(p[0],p[1],p[2],mv,pr,viewport,&x,&y,&z);
+  return AGVector3(x,y,z);
+
+}
+AGVector3 AntProjection::unProject(const AGVector3 &p) const
+{
+  GLdouble x,y,z;
+
+  GLdouble mv[16],pr[16];
+  for(int i=0;i<16;i++)
+    { 
+      mv[i]=((const float*)modelview)[i];
+      pr[i]=((const float*)projection)[i];
+    }
+
+  gluUnProject(p[0],p[1],p[2],mv,pr,viewport,&x,&y,&z);
+  return AGVector3(x,y,z);
+}
+
+
+AntFrustum AntProjection::getFrustum() const
+{
+  float w=viewport[2];
+  float h=viewport[3];
+  float d=1;
+  float d0=0;
+
+  AGVector3 p000(unProject(AGVector3(0,0,d0)));
+  AGVector3 p100(unProject(AGVector3(w,0,d0)));
+  AGVector3 p010(unProject(AGVector3(0,h,d0)));
+  AGVector3 p110(unProject(AGVector3(w,h,d0)));
+  AGVector3 p001(unProject(AGVector3(0,0,d)));
+  AGVector3 p101(unProject(AGVector3(w,0,d)));
+  AGVector3 p011(unProject(AGVector3(0,h,d)));
+  AGVector3 p111(unProject(AGVector3(w,h,d)));
+
+  std::vector<AntPlane> ps;
+
+  ps.push_back(makePlane(p000,p010,p100)); // front
+  ps.push_back(makePlane(p101,p111,p001)); // back
+  ps.push_back(makePlane(p010,p011,p110)); // top
+  ps.push_back(makePlane(p001,p000,p101)); // bottom
+  ps.push_back(makePlane(p001,p011,p000)); // left
+  ps.push_back(makePlane(p100,p110,p101)); // right
+
+  return AntFrustum(ps);
+}

Added: antargis/branches/rant/ext/3dengine/ant_projection.h
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_projection.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ant_projection.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,35 @@
+#ifndef ANT_PROJECTION_H
+#define ANT_PROJECTION_H
+
+#include <GLee.h>
+
+#include <ant_frustum.h>
+
+struct Viewport
+{
+  GLint viewport[4];
+#ifndef SWIG
+  (operator GLint *)() const
+  {
+    return const_cast<Viewport*>(this)->viewport;
+  }
+#endif
+};
+
+
+class AntProjection
+{
+ public:
+  AntProjection(const AGMatrix4 &pMv,const AGMatrix4 &pPr,const Viewport &pVp);
+
+  AGVector3 project(const AGVector3 &p) const;
+  AGVector3 unProject(const AGVector3 &p) const;
+
+  AntFrustum getFrustum() const;
+
+ private:
+  AGMatrix4 modelview,projection;
+  Viewport viewport;
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/ant_renderer.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_renderer.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ant_renderer.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,381 @@
+#include "ant_renderer.h"
+#include "scene.h"
+#include "ag_vdebug.h"
+#include "ag_kill.h"
+#include "ag_config.h"
+#include "ag_fbo.h"
+
+Renderer *gRenderer=0;
+
+bool usePlainGL=true;
+
+Renderer::Renderer():
+  mCanMultitexture(-1),
+  mCanShadow(-1),
+  mCanGLSL(-1)
+{
+  mFBO=0;
+  CTRACE;
+  GLeeInit(); // this call is essential for letting glee work
+  assert(gRenderer==0);
+  gRenderer=this;
+  mScene=0;
+  
+  AGString shadowType=getConfig()->get("shadowType");
+  if(shadowType=="big" || shadowType=="")
+    shadowMapSize=1024;
+  else if(shadowType=="small")
+    shadowMapSize=512;
+  else
+    shadowMapSize=0;
+
+  switch(shadowMapSize)
+    {
+    case 0:
+      getConfig()->set("shadowType","none");break;
+    case 512:
+      getConfig()->set("shadowType","small");break;
+    case 1024:
+      getConfig()->set("shadowType","big");break;
+    }
+  
+
+  shadowInited=false;
+
+  if(!GLEE_EXT_texture3D)
+    std::cerr<<"Sorry, Battles of Antargis won't work without GL_EXT_texture3D extension!"<<std::endl;
+}
+
+Renderer::~Renderer()
+{
+  cdebug("gRenderer:"<<gRenderer);
+  assert(gRenderer==this);
+  gRenderer=0;
+  delete mFBO;
+}
+
+bool Renderer::canMultitexture()
+{
+  if(mCanMultitexture<0)
+    mCanMultitexture=GLEE_ARB_multitexture;
+  return mCanMultitexture;
+}
+
+bool Renderer::canShadow()
+{
+  if(mCanShadow<0)
+    mCanShadow=(GLEE_ARB_shadow && GLEE_ARB_shadow_ambient);
+  return mCanShadow && shadowMapSize>0;
+}
+
+bool Renderer::canGLSL()
+{
+  if(mCanGLSL<0)
+    mCanGLSL=(GLEE_ARB_vertex_shader && GLEE_ARB_fragment_shader && GLEE_ARB_shading_language_100);
+  return mCanGLSL;
+}
+
+void Renderer::setCurrentScene(Scene *scene)
+{
+  mScene=scene;
+}
+
+Scene *Renderer::getCurrentScene()
+{
+  assert(mScene);
+  return mScene;
+}
+
+GLint Renderer::getShadowUnit()
+{
+  assert(canMultitexture());
+  return 3;
+}
+GLint Renderer::getNormalUnit()
+{
+  if(canMultitexture())
+    return 0;
+  else
+    return 0;
+}
+
+void Renderer::initShadowTexture()
+{
+  if(!canShadow())
+    return;
+
+  if(shadowInited)
+    return;
+
+  CTRACE;
+  glGenTextures(1, &shadowMapTexture);
+  cdebug(1);
+  glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
+  //  glTexImage2D(   GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, shadowMapSize, shadowMapSize, 0,
+  //		  GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, NULL);
+  cdebug(2);
+
+  cdebug(shadowMapSize);
+  glTexImage2D(   GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT16, shadowMapSize, shadowMapSize, 0,
+		  GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, NULL);
+  cdebug(3);
+
+  assertGL;
+  cdebug(30);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //NEAREST);
+  cdebug(31);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); //NEAREST);
+  cdebug(32);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+  cdebug(33);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+  cdebug(4);
+  
+  glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
+  cdebug(5);
+
+  shadowInited=true;
+
+  if(canFBO())
+    {
+      mFBO=new AGFBO(shadowMapTexture,shadowMapSize,shadowMapSize);//,true);
+    }
+
+}
+
+void Renderer::beginShadowComputation()
+{
+  if(!shadowInited)
+    initShadowTexture();
+
+  if(mFBO)
+    {
+      mFBO->beginDraw();
+    }
+
+  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+  assertGL;
+  
+  
+  glMatrixMode(GL_PROJECTION);
+  glLoadMatrixf(getCurrentScene()->getLightProj());
+  
+  glMatrixMode(GL_MODELVIEW);
+  glLoadMatrixf(getCurrentScene()->getLightView());
+  
+  //Use viewport the same size as the shadow map
+  glViewport(0, 0, shadowMapSize, shadowMapSize);
+  
+  //Draw back faces into the shadow map
+  glCullFace(GL_FRONT);
+  glEnable(GL_CULL_FACE);
+  
+  //Disable color writes, and use flat shading for speed
+  glShadeModel(GL_FLAT);
+  glColorMask(0, 0, 0, 0);
+  
+  //Draw the scene
+  // Offset the drawing a little back, so that slopy surfaces don't get shadowed
+  glEnable(GL_POLYGON_OFFSET_FILL);
+  glPolygonOffset(1,1); // was 1,1
+
+  assertGL;
+
+}
+void Renderer::endShadowComputation()
+{
+  glDisable(GL_POLYGON_OFFSET_FILL);
+  assertGL;
+  //Read the depth buffer into the shadow map texture
+  glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
+  assertGL;
+
+  /// @todo switch to FBOs - this should bring an improvement of 17 to 19 fps
+
+    if(mFBO)
+      {
+	mFBO->endDraw();
+      }
+    else
+      {
+	glReadBuffer(GL_BACK);
+	
+	glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, 0, 0, shadowMapSize, shadowMapSize,0);
+	
+	glReadBuffer(GL_FRONT);
+      }
+
+  assertGL;
+
+
+  //restore states
+  assertGL;
+  glCullFace(GL_BACK);
+  
+  glShadeModel(GL_SMOOTH);
+  glColorMask(1, 1, 1, 1);
+}
+
+
+void Renderer::beginShadowDrawing()
+{
+  glActiveTexture(getShadowUnit());
+
+  glMatrixMode(GL_MODELVIEW);
+  // draw a flat shadow over 
+  //  glDisable(GL_LIGHTING);
+  //  glEnable(GL_COLOR_MATERIAL);
+  assertGL;
+  
+
+  if(usePlainGL)
+    {
+      //Calculate texture matrix for projection
+      //This matrix takes us from eye space to the light's clip space
+      //It is postmultiplied by the inverse of the current view matrix when specifying texgen
+      float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
+		    0.0f, 0.5f, 0.0f, 0.0f,
+		    0.0f, 0.0f, 0.5f, 0.0f,
+		    0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
+      static AGMatrix4 biasMatrix(bias);
+      AGMatrix4 textureMatrix=biasMatrix * getCurrentScene()->getLightProj() * getCurrentScene()->getLightView();
+      
+      //Set up texture coordinate generation.
+      glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+      assertGL;
+      glTexGenfv(GL_S, GL_EYE_PLANE, textureMatrix.getRow(0));
+      assertGL;
+      glEnable(GL_TEXTURE_GEN_S);
+      assertGL;
+      
+      glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+      assertGL;
+      glTexGenfv(GL_T, GL_EYE_PLANE, textureMatrix.getRow(1));
+      assertGL;
+      glEnable(GL_TEXTURE_GEN_T);
+      assertGL;
+      
+      glTexGeni(GL_R, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+      assertGL;
+      glTexGenfv(GL_R, GL_EYE_PLANE, textureMatrix.getRow(2));
+      assertGL;
+      glEnable(GL_TEXTURE_GEN_R);
+      
+      assertGL;
+      glTexGeni(GL_Q, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
+      assertGL;
+      glTexGenfv(GL_Q, GL_EYE_PLANE, textureMatrix.getRow(3));
+      assertGL;
+      glEnable(GL_TEXTURE_GEN_Q);
+      assertGL;
+    }
+  
+  //Bind & enable shadow map texture
+  glBindTexture(GL_TEXTURE_2D, shadowMapTexture);
+  glEnable(GL_TEXTURE_2D);
+  
+  //Enable shadow comparison
+  assertGL;
+
+  if(usePlainGL)
+    {
+            
+#ifndef OLD_SHADOW
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE);
+      assertGL;
+      //Shadow comparison should be true (ie not in shadow) if r<=texture
+      //        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL); // not needed ???
+      assertGL;
+      
+      //Shadow comparison should generate an INTENSITY result
+      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
+      assertGL;
+      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE);//INTENSITY);
+      assertGL;
+      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 1.0f-0.3f);//shadowAlpha);
+      assertGL;
+      //      glColor4f(0,0,0,0.3);
+      assertGL;
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+      //      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+
+#else
+      glEnable(GL_TEXTURE_2D);
+      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE, GL_INTENSITY);  //set this to a "depth texture"
+      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FAIL_VALUE_ARB, 0.5f);      //set the compare fail value
+
+      glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+      
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE_ARB);
+
+
+
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL); // not needed ???
+      assertGL;
+      
+      //Shadow comparison should generate an INTENSITY result
+      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY);
+      assertGL;
+      glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE);//INTENSITY);
+
+
+
+        // Set up the eye plane for projecting the shadow map on the scene
+
+#endif
+      //Set alpha test to discard false comparisons
+      //  glAlphaFunc(GL_GREATER,0.99f);//LEQUAL, 0.999f);
+      //      glAlphaFunc(GL_GEQUAL, 0.99f);
+      //      glDisable(GL_ALPHA_TEST);
+
+      
+    }
+
+  glActiveTexture(getNormalUnit());
+  assertGL;
+
+}
+void Renderer::endShadowDrawing()
+{
+  assertGL;
+
+  glDisable(GL_POLYGON_OFFSET_FILL);
+
+  glActiveTexture(getShadowUnit());
+  glBindTexture(GL_TEXTURE_2D,0);
+
+  if(usePlainGL)
+    {
+      glDisable(GL_ALPHA_TEST);
+      glDisable(GL_TEXTURE_GEN_S);
+      glDisable(GL_TEXTURE_GEN_T);
+      glDisable(GL_TEXTURE_GEN_R);
+      glDisable(GL_TEXTURE_GEN_Q);
+    }
+  glActiveTexture(getNormalUnit());
+  assertGL;
+
+}
+
+
+bool Renderer::badShadowMap()
+{
+  return shadowMapSize==1024;
+}
+
+
+Renderer *getRenderer()
+{
+  if(!gRenderer)
+    {
+      gRenderer=new Renderer;
+      REGISTER_SINGLETON(gRenderer);
+    }
+  assert(gRenderer);
+  return gRenderer;
+}

Added: antargis/branches/rant/ext/3dengine/ant_renderer.h
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_renderer.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/ant_renderer.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,56 @@
+#ifndef __RENDERER_H
+#define __RENDERER_H
+
+#include "GLee.h"
+
+class Scene;
+class AGFBO;
+
+class Renderer
+{
+  Renderer();
+ public:
+  ~Renderer();
+
+  bool canMultitexture();
+  bool canShadow();
+  bool canGLSL();
+
+  GLint getShadowUnit();
+  GLint getNormalUnit();
+
+  void setCurrentScene(Scene *scene);
+  Scene *getCurrentScene();
+
+  void initShadowTexture();
+  void beginShadowComputation();
+  void endShadowComputation();
+
+  void beginShadowDrawing();
+  void endShadowDrawing();
+
+  bool badShadowMap();
+  
+ private:
+
+  
+  int mCanMultitexture;
+  int mCanShadow;
+  int mCanGLSL;
+
+  GLuint shadowMapTexture;
+
+  AGFBO *mFBO;
+
+  int shadowMapSize;
+  bool shadowInited;
+
+  Scene *mScene;
+
+  friend Renderer *getRenderer();
+};
+
+Renderer *getRenderer();
+
+#endif
+

Added: antargis/branches/rant/ext/3dengine/glsl.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/glsl.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/glsl.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,370 @@
+#include "glsl.h"
+#include "ag_vdebug.h"
+#include "ag_main.h"
+#include "scene.h"
+/*
+std::map<std::string,AntVertexProgram*> mVertexPrograms2;
+std::map<std::string,AntFragProgram*> mFragPrograms2;
+
+AntVertexProgram *getVertexProgram(const std::string &pFile)
+{
+  std::map<std::string,AntVertexProgram*>::iterator i=mVertexPrograms.find(pFile);
+
+  if(i==mVertexPrograms.end())
+    {
+      AntVertexProgram *p=new AntVertexProgram(pFile);
+      mVertexPrograms[pFile]=p;
+      return p;
+    }
+  return i->second;
+}
+
+AntFragProgram *getFragProgram(const std::string &pFile)
+{
+  std::map<std::string,AntFragProgram*>::iterator i=mFragPrograms.find(pFile);
+
+  if(i==mFragPrograms.end())
+    {
+      AntFragProgram *p=new AntFragProgram(pFile);
+      mFragPrograms[pFile]=p;
+      return p;
+    }
+  return i->second;
+}
+*/
+
+bool glslOk();
+
+void printInfoLog(GLhandleARB obj);
+
+
+
+AntVertexProgram::AntVertexProgram(const std::string &pFile)
+{
+  //  CTRACE;
+  if(glslOk())
+    {
+      vertexShader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
+      std::string s=loadFile(pFile);
+      
+      const char*a=s.c_str();
+      const GLcharARB**x=&a;
+      glShaderSourceARB(vertexShader, 1, x,NULL);
+      glCompileShaderARB(vertexShader);
+      printInfoLog(vertexShader);
+      
+    }
+}
+
+AntVertexProgram::~AntVertexProgram()
+{
+  CTRACE;
+  if(glslOk() && !hasQuit())
+    glDeleteObjectARB(vertexShader);
+}
+
+AntFragProgram::AntFragProgram(const std::string &pFile)
+{
+  mValid=false;
+  //  CTRACE;
+  if(glslOk() && pFile.length()>0)
+    {
+      fragShader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
+      std::string s=loadFile(pFile);
+      const char*a=s.c_str();
+      const GLcharARB**x=&a;
+      glShaderSourceARB(fragShader, 1, x,NULL);
+      glCompileShaderARB(fragShader);
+      printInfoLog(fragShader);
+      mValid=true;
+      
+    }
+}
+
+AntFragProgram::AntFragProgram()
+{
+  mValid=false;
+}
+
+AntFragProgram::~AntFragProgram()
+{
+  CTRACE;
+  if(glslOk() && !hasQuit())
+    glDeleteObjectARB(fragShader);
+}
+
+
+bool AntFragProgram::valid() const
+{
+  return mValid;
+}
+
+
+AntShaderProgram::AntShaderProgram(const std::string &pVertexFile,const std::string &pFragFile):
+  //  vertex(getVertexProgram(pVertexFile)),frag(getFragProgram(pFragFile))
+  mVertexFile(pVertexFile),mFragFile(pFragFile),
+  vertex(0),frag(0)
+{
+  //  CTRACE;
+  on=false;
+  matrixBuf=new float[16*100];
+  name=pVertexFile+":"+pFragFile;
+
+  init();
+}
+
+AntShaderProgram::~AntShaderProgram()
+{
+  takeDown();
+
+  delete [] matrixBuf;
+}
+
+void AntShaderProgram::onScreenUp()
+{
+  CTRACE;
+  init();
+}
+void AntShaderProgram::onScreenDown()
+{
+  CTRACE;
+  takeDown();
+}
+
+
+void AntShaderProgram::init()
+{
+ if(glslOk())
+    {
+      vertex=new AntVertexProgram(mVertexFile);
+      frag=new AntFragProgram(mFragFile);
+
+      p = glCreateProgramObjectARB();
+      glAttachObjectARB(p,vertex->vertexShader);
+      if(frag->valid())
+	glAttachObjectARB(p,frag->fragShader);
+      
+      glLinkProgramARB(p);
+      printInfoLog(p);
+
+      assert(p);
+    }
+}
+
+void AntShaderProgram::takeDown()
+{
+  disable();
+  CTRACE;
+  cdebug("name:"<<name);
+  if(glslOk() && !hasQuit())
+    glDeleteObjectARB(p);
+  cdebug("name:"<<name);
+  cdebug("name:"<<name);
+  delete vertex;
+  delete frag;
+}
+
+
+
+void AntShaderProgram::enable()
+{
+  if(glslOk())
+    {
+      glUseProgramObjectARB(p);
+      on=true;
+    }
+}
+void AntShaderProgram::disable()
+{
+  if(glslOk())
+    {
+      glUseProgramObjectARB(0);
+      on=false;
+    }
+}
+
+void AntShaderProgram::update(float time)
+{
+  if(glslOk())
+    {
+      enable();
+      doUpdate(time);
+      disable();
+    }
+}
+
+void AntShaderProgram::doUpdate(float time)
+{
+}
+
+void AntShaderProgram::sendUniform(const std::string &pName,int i)
+{
+  glUniform1iARB(getLoc(pName),i);
+}
+void AntShaderProgram::sendUniform(const std::string &pName,float f)
+{
+  glUniform1fARB(getLoc(pName),f);
+}
+void AntShaderProgram::sendUniform(const std::string &pName,const AGVector3 &m)
+{
+  glUniform3fARB(getLoc(pName),m[0],m[1],m[2]);
+}
+void AntShaderProgram::sendUniform(const std::string &pName,const AGVector4 &m)
+{
+  glUniform4fARB(getLoc(pName),m[0],m[1],m[2],m[3]);
+}
+void AntShaderProgram::sendUniform(const std::string &pName,const AGMatrix4 &m)
+{
+  glUniformMatrix4fvARB(getLoc(pName),1,false,m);
+}
+void AntShaderProgram::sendUniform(const std::string &pName,const std::vector<AGMatrix4> &m)
+{
+  assert(m.size()<100);
+  float *p=matrixBuf;
+
+  for(size_t i=0;i<m.size();i++)
+    {
+      const float *s=m[i];
+      for(size_t j=0;j<16;j++)
+	*(p++)=*(s++);
+    }
+  assertGL;
+  glUniformMatrix4fvARB(getLoc(pName),m.size(),false,matrixBuf);
+  assertGL;
+}
+
+GLint AntShaderProgram::getLoc(const std::string &pName)
+{
+  // register only once !
+  
+  std::map<std::string,GLint>::iterator i=locations.find(pName);
+  if(i!=locations.end())
+    return i->second;
+  
+  GLint k=glGetUniformLocationARB(p,pName.c_str());
+  locations.insert(std::make_pair(pName,k));
+  return k;
+}
+
+GLint AntShaderProgram::getAttr(const std::string &pName)
+{
+  //  TRACE;
+  // register only once !
+  assert(on);
+  std::map<std::string,GLint>::iterator i=attrs.find(pName);
+  if(i!=attrs.end())
+    return i->second;
+  
+  assertGL;
+  GLint k=glGetAttribLocationARB(p,pName.c_str());
+  //  cdebug("k:"<<k);
+  if(k<0)
+    {
+      cdebug("ERROR:attribute could be get! Maybe it was not defined in the vertex-shader? :"<<pName);
+    }
+  assertGL;
+  attrs.insert(std::make_pair(pName,k));
+  return k;
+}
+
+void AntShaderProgram::sendAttribute(const std::string &pName,const std::vector<float> &vf)
+{
+  assertGL;
+  GLint loc=getAttr(pName);
+  assertGL;
+  glEnableClientState(GL_VERTEX_ARRAY);
+  assertGL;
+  glEnableVertexAttribArrayARB(loc); // add array
+  assertGL;
+
+  glVertexAttribPointerARB(loc,1,GL_FLOAT,0,0,&vf[0]); // set attributes (for each vertex an attribute)
+  assertGL;
+}
+
+
+
+///////////////////////////////////////////////////////////////////////////
+// AntShadowShader
+//
+///////////////////////////////////////////////////////////////////////////
+AntShadowShader::AntShadowShader(const std::string &pVertexFile,const std::string &pFragFile):
+	AntShaderProgram(pVertexFile,pFragFile)
+{
+}
+
+void AntShadowShader::doUpdate(float time)
+{
+  if(glslOk())
+    {
+      Renderer *r=getRenderer();
+      sendUniform("shadowTex",r->getShadowUnit());
+      sendUniform("normalTex",r->getNormalUnit());
+      sendUniform("lightComplete",r->getCurrentScene()->getLightComplete());
+    }
+}
+
+
+void AntShadowShader::enable()
+{
+  AntShaderProgram::enable();
+  if(glslOk())
+    {
+      Scene *scene=getRenderer()->getCurrentScene();
+
+      glActiveTexture(getRenderer()->getShadowUnit()); // shadow unit
+
+      glMatrixMode(GL_TEXTURE);
+      glPushMatrix();
+
+      // FIXME: move bias to frag-shader, as this shall reduce z-fighting
+      float bias[]={0.5f, 0.0f, 0.0f, 0.0f,
+		0.0f, 0.5f, 0.0f, 0.0f,
+		0.0f, 0.0f, 0.5f, 0.0f,
+		0.5f, 0.5f, 0.5f, 1.0f};        //bias from [-1, 1] to [0, 1]
+      glLoadMatrixf(bias);
+
+      glMultMatrixf(scene->getLightProj());
+      glMultMatrixf(scene->getLightView());
+
+      glActiveTexture(getRenderer()->getNormalUnit()); // tex unit
+
+      glMatrixMode(GL_MODELVIEW);
+    }
+}
+void AntShadowShader::disable()
+{
+  AntShaderProgram::disable();
+  if(glslOk())
+    {
+      glActiveTexture(getRenderer()->getShadowUnit()); // shadow unit
+      glMatrixMode(GL_TEXTURE);
+      glPopMatrix();
+      glMatrixMode(GL_MODELVIEW);
+      glActiveTexture(getRenderer()->getNormalUnit()); // tex unit
+    }
+}
+
+
+///////////////////////////////////////////////////////////////////////////
+// AntWaterShader
+//
+///////////////////////////////////////////////////////////////////////////
+
+
+AntWaterShader::AntWaterShader():
+  AntShaderProgram("data/shaders/simplewater.vert","data/shaders/simplewater.frag")
+{
+}
+void AntWaterShader::doUpdate(float time)
+{
+  if(glslOk())
+    {
+      AntShaderProgram::doUpdate(time);
+      
+      t+=time;
+      sendUniform("time", t);
+    }
+}
+
+
+

Added: antargis/branches/rant/ext/3dengine/glsl.h
===================================================================
--- antargis/branches/rant/ext/3dengine/glsl.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/glsl.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,113 @@
+#ifndef ANT_GLSL_H
+#define ANT_GLSL_H
+
+#include "ant_renderer.h"
+#include "ag_tools.h"
+#include "ag_geometry.h"
+#include "ag_glscreen.h"
+
+#include <map>
+
+class Scene;
+
+class AntVertexProgram
+{
+ public:
+  AntVertexProgram(const std::string &pFile);
+  ~AntVertexProgram();
+
+ private:
+  GLhandleARB vertexShader;
+
+  friend class AntShaderProgram;
+};
+
+class AntFragProgram
+{
+ public:
+  AntFragProgram(const std::string &pFile);
+  AntFragProgram();
+  ~AntFragProgram();
+
+  bool valid() const;
+
+ private:
+  GLhandleARB fragShader;
+  bool mValid;
+
+  friend class AntShaderProgram;
+};
+
+
+class AntShaderParameter
+{
+ public:
+  
+};
+
+class AntShaderProgram:public AGGLObject
+{
+  std::string mVertexFile,mFragFile;
+  AntVertexProgram *vertex;
+  AntFragProgram *frag;
+  std::map<std::string,GLint> locations;
+  std::map<std::string,GLint> attrs;
+  float *matrixBuf;
+  bool on;
+  std::string name;
+
+ protected:  
+  GLhandleARB p;
+
+ public:
+  AntShaderProgram(const std::string &pVertexFile,const std::string &pFragFile);
+  virtual ~AntShaderProgram();
+  virtual void enable();
+  virtual void disable();
+
+  void update(float time);
+  virtual void doUpdate(float time);
+
+  GLint getLoc(const std::string &pName);
+  GLint getAttr(const std::string &pName);
+
+  void sendUniform(const std::string &pName,int i);
+  void sendUniform(const std::string &pName,float f);
+  void sendUniform(const std::string &pName,const AGVector3 &m);
+  void sendUniform(const std::string &pName,const AGVector4 &m);
+  void sendUniform(const std::string &pName,const AGMatrix4 &m);
+  void sendUniform(const std::string &pName,const std::vector<AGMatrix4> &m);
+
+  void sendAttribute(const std::string &pName,const std::vector<float> &vf);
+
+  void onScreenUp();
+  void onScreenDown();
+
+
+ private:
+  void check();
+  void init();
+  void takeDown();
+
+};
+
+class AntShadowShader:public AntShaderProgram
+{
+ public:
+  AntShadowShader(const std::string &pVertexFile,const std::string &pFragFile);
+  void doUpdate(float time);
+  virtual void enable();
+  virtual void disable();
+};
+
+class AntWaterShader:public AntShaderProgram
+{
+  float t;
+ public:
+  AntWaterShader();
+  void doUpdate(float time);
+};
+
+bool glslOk();
+
+#endif

Added: antargis/branches/rant/ext/3dengine/headers.hh
===================================================================
--- antargis/branches/rant/ext/3dengine/headers.hh	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/headers.hh	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,47 @@
+#ifndef __ANTARGIS_H__
+#define __ANTARGIS_H__
+#include "ext/basic/ag_base.h"
+#include "ext/basic/ag_collector.h"
+#include "ext/basic/ag_config.h"
+#include "ext/basic/ag_debug.h"
+#include "ext/basic/ag_exception.h"
+#include "ext/basic/ag_fs.h"
+#include "ext/basic/ag_main.h"
+#include "ext/basic/ag_profiler.h"
+#include "ext/basic/ag_regex.h"
+#include "ext/basic/ag_rubyobj.h"
+#include "ext/basic/ag_rand_base.h"
+#include "ext/basic/ag_string.h"
+#include "ext/basic/ag_string_utf8.h"
+#include "ext/basic/ag_stringstream.h"
+#include "ext/basic/ag_tools.h"
+#include "ext/basic/ag_utf8.h"
+#include "ext/basic/ag_video_base.h"
+#include "ext/basic/ag_xml.h"
+#include "ext/basic/ag_plugin.h"
+#include "ext/basic/ag_singleton.h"
+#include "ext/basic/ag_kill.h"
+#include "ext/basic/ag_serial.h"
+#include "ext/basic/ag_messageobject.h"
+#include "ext/basic/ag_mutex.h"
+#include "/home/david/projects/antargis/rant/ext/3dengine/mesh_data.h"
+#include "/home/david/projects/antargis/rant/ext/3dengine/scene_base.h"
+#include "/home/david/projects/antargis/rant/ext/3dengine/scenenode.h"
+#include "/home/david/projects/antargis/rant/ext/3dengine/mesh_2d_data.h"
+#include "/home/david/projects/antargis/rant/ext/3dengine/anim_mesh_data.h"
+#include "/home/david/projects/antargis/rant/ext/3dengine/mesh.h"
+#include "/home/david/projects/antargis/rant/ext/3dengine/mesh_2d.h"
+#include "/home/david/projects/antargis/rant/ext/3dengine/scene.h"
+#include "/home/david/projects/antargis/rant/ext/3dengine/anim_mesh.h"
+#ifdef SWIG
+%include "/home/david/projects/antargis/rant/ext/3dengine/mesh_data.h"
+%include "/home/david/projects/antargis/rant/ext/3dengine/scene_base.h"
+%include "/home/david/projects/antargis/rant/ext/3dengine/scenenode.h"
+%include "/home/david/projects/antargis/rant/ext/3dengine/mesh_2d_data.h"
+%include "/home/david/projects/antargis/rant/ext/3dengine/anim_mesh_data.h"
+%include "/home/david/projects/antargis/rant/ext/3dengine/mesh.h"
+%include "/home/david/projects/antargis/rant/ext/3dengine/mesh_2d.h"
+%include "/home/david/projects/antargis/rant/ext/3dengine/scene.h"
+%include "/home/david/projects/antargis/rant/ext/3dengine/anim_mesh.h"
+#endif
+#endif

Added: antargis/branches/rant/ext/3dengine/init.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/init.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/init.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,7 @@
+#include <ag_debug.h>
+
+void AG_Init_libantargis3dengine()
+{
+  TRACE;
+}
+

Added: antargis/branches/rant/ext/3dengine/mesh.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,159 @@
+#include "mesh.h"
+
+#include <map>
+#include <vector>
+#include <math.h>
+#include <ag_vdebug.h>
+#include <ag_texturecache.h>
+#include <ag_profiler.h>
+
+
+
+
+//////////////////////////////////////////////////////////////////////
+// Mesh
+//////////////////////////////////////////////////////////////////////
+
+Mesh::Mesh(Scene *pScene):
+  SceneNode(pScene,AGVector4(),AGBox3())
+{
+  mData=0;
+  mRotation=0;
+  setOrder(MESH_Z);
+  mColor=AGVector4(1,1,1,1);
+  mVisible=true;
+}
+
+Mesh::Mesh(Scene *pScene,MeshData &data,const AGVector4 &pPos,float pRot):
+  SceneNode(pScene,pPos,data.bbox())
+{
+  mData=&data;
+  mRotation=pRot;
+  setOrder(MESH_Z);
+  mColor=AGVector4(1,1,1,1);
+  mVisible=true;
+}
+
+Mesh::~Mesh()
+{
+}
+
+void Mesh::draw()
+{
+  STACKTRACE;
+  if(!mVisible)
+    return;
+
+  begin();
+  if(mData)
+    {
+      mData->draw(mColor);
+    }
+  end();
+}
+void Mesh::drawDepth()
+{
+  STACKTRACE;
+  if(!mVisible)
+    return;
+  begin();
+  if(mData)
+    mData->drawDepth();
+  end();
+}
+void Mesh::drawShadow()
+{
+  STACKTRACE;
+  if(!mVisible)
+    return;
+  begin();
+  if(mData)
+    mData->drawShadow();
+  end();
+}
+
+size_t Mesh::getTriangles() const
+{
+  if(!mData)
+    return 0;
+  return mData->getTriangles();
+}
+
+void Mesh::begin()
+{
+  assertGL;
+
+  glPushMatrix();
+  AGVector4 p=getPos();
+  glTranslatef(p[0],p[1],p[2]);
+  glRotatef(mRotation,0.0,0.0,1.0);
+}
+void Mesh::end()
+{
+  glPopMatrix();
+}
+
+
+AGVector4 Mesh::lineHit(const AGLine3 &pLine) const
+{
+  if(!mData)
+    return AGVector4(0,0,0,0);
+  AGMatrix4 rot(-mRotation*M_PI/180.0,AGVector3(0,0,1));
+  AGMatrix4 tr(-getPos());
+  AGMatrix4 complete=rot*tr;
+  
+  AGVector4 p0(pLine.getV0(),1);
+  AGVector4 p1(pLine.getV1(),1);
+  
+  p0=complete*p0;
+  p1=complete*p1;
+  return mData->lineHit(AGLine3(AGVector3(p0[0],p0[1],p0[2]),
+				AGVector3(p1[0],p1[1],p1[2])))+AGVector4(getPos().dim3(),0);
+}
+
+void Mesh::setRotation(float r)
+{
+  mRotation=r;
+}
+
+MeshData *Mesh::getData()
+{
+  return mData;
+}
+
+void Mesh::drawPick()
+{
+  STACKTRACE;
+
+  if(!mVisible)
+    return;
+  begin();
+
+  if(mData)
+    mData->drawPick();
+  end();
+}
+
+
+bool Mesh::transparent()
+{
+  assert(mData);
+  return mData->transparent();
+}
+
+
+void Mesh::mark()
+{
+  markObject(getData());
+}
+
+
+void Mesh::setColor(const AGVector4 &pColor)
+{
+  mColor=pColor;
+}
+void Mesh::setVisible(bool v)
+{
+  mVisible=v;
+}
+

Added: antargis/branches/rant/ext/3dengine/mesh.h
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,58 @@
+#ifndef __MESH_H
+#define __MESH_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include "scene.h"
+#include "vertex_array.h"
+
+#include <map>
+
+#include "mesh_data.h"
+
+/** A mesh is a scenenode, that displays a mesh ;)
+    ok, now for the real info.
+    it contains a MeshData object, color and positional information.
+    Actual drawing is done by MeshData.
+
+*/
+class Mesh:public SceneNode
+{
+  MeshData *mData;
+  float mRotation;
+  AGVector4 mColor;
+  bool mVisible;
+  
+ public:
+  Mesh(Scene *pScene);
+  Mesh(Scene *pScene,MeshData &data,const AGVector4 &pPos,float pRot);
+  virtual ~Mesh();
+
+  void draw();
+  void drawDepth();
+  void drawShadow();
+  void drawPick();
+
+  virtual AGVector4 lineHit(const AGLine3 &pLine) const;
+
+  virtual size_t getTriangles() const;
+
+  /// set rotation around y-axis (e.g. turn people)
+  void setRotation(float r);
+  /// set color (for rings)
+  void setColor(const AGVector4 &pColor); 
+  void setVisible(bool v);
+
+  MeshData *getData();
+
+  void mark();
+
+  virtual bool transparent();
+
+
+ private:
+  void begin();
+  void end();
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/mesh_2d.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_2d.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_2d.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,93 @@
+#include "mesh_2d.h"
+#include <ag_debug.h>
+#include <ag_painter.h>
+
+Mesh2D::Mesh2D(Scene2D *pScene):
+  SceneNode(pScene,AGVector4(),AGBox3())
+{
+}
+Mesh2D::Mesh2D(Scene2D *pScene,Mesh2DData &data,const AGVector4 &pPos,float pRot):
+  SceneNode(pScene,pPos,data.bbox()),
+  mData(&data)
+{
+}
+Mesh2D::~Mesh2D()
+{
+}
+
+void Mesh2D::draw()
+{
+  Scene2D *s=dynamic_cast<Scene2D*>(getScene());
+  assert(s);
+  AGPainter *painter=s->getPainter();
+
+  assert(painter);
+
+  AGRect2 r=getDrawingRect();
+  AGTexture *t=mData->getTexture();
+
+  //  cdebug("r:"<<r);
+  painter->blit(*t,r);
+}
+
+AGRect2 Mesh2D::getDrawingRect()
+{
+  Scene2D *s=dynamic_cast<Scene2D*>(getScene());
+  assert(s);
+
+  AGTexture *t=mData->getTexture();
+  AGVector2 middle(s->getPosition(getPos()));
+  float w=t->width();
+  float h=t->height();
+  AGRect2 r(middle.getX()-w/2,middle.getY()-h/2,w,h);
+
+  mLast=r;
+
+  return r;
+}
+
+AGRect2 Mesh2D::getLastDrawingRect()
+{
+  return mLast;
+}
+
+AGVector4 Mesh2D::lineHit(const AGLine3 &pLine) const
+{
+  //FIXME
+  return AGVector4();
+}
+
+/// set rotation around y-axis (e.g. turn people)
+void Mesh2D::setRotation(float r)
+{
+}
+/// set color (for rings)
+void Mesh2D::setColor(const AGVector4 &pColor)
+{
+}
+void Mesh2D::setVisible(bool v)
+{
+}
+
+Mesh2DData *Mesh2D::getData()
+{
+  return mData;
+}
+
+void Mesh2D::mark()
+{
+  markObject(mData);
+}
+
+bool Mesh2D::hit(const AGVector2 &screenPos)
+{
+  AGRect2 dRect=getDrawingRect();
+  if(dRect.contains(screenPos))
+    {
+      // check if texture is !=transparent there
+      AGVector2 p=screenPos-dRect.getV0();
+      return mData->getTexture()->getPixel(p[0],p[1]).a>10; // some threshold here
+      
+    }
+  return false;
+}

Added: antargis/branches/rant/ext/3dengine/mesh_2d.h
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_2d.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_2d.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,46 @@
+#ifndef MESH_2D_H
+#define MESH_2D_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include "scenenode.h"
+#include "scene_2d.h"
+#include "mesh_2d_data.h"
+
+class Mesh2D:public SceneNode
+{
+ public:
+  Mesh2D(Scene2D *pScene);
+  Mesh2D(Scene2D *pScene,Mesh2DData &data,const AGVector4 &pPos,float pRot);
+  virtual ~Mesh2D();
+
+  void draw();
+
+  virtual AGVector4 lineHit(const AGLine3 &pLine) const;
+
+  /// set rotation around y-axis (e.g. turn people)
+  void setRotation(float r);
+  /// set color (for rings)
+  void setColor(const AGVector4 &pColor); 
+  void setVisible(bool v);
+
+  Mesh2DData *getData();
+
+  void mark();
+
+  bool hit(const AGVector2 &screenPos);
+
+ public:
+
+  AGRect2 getDrawingRect();
+  AGRect2 getLastDrawingRect();
+
+  Mesh2DData *mData;
+
+
+ private:
+  AGRect2 mLast;
+};
+
+
+#endif

Added: antargis/branches/rant/ext/3dengine/mesh_2d_data.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_2d_data.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_2d_data.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,22 @@
+#include "mesh_2d_data.h"
+
+Mesh2DData::Mesh2DData(AGTexture *pTexture):
+  mTexture(pTexture)
+{
+}
+  
+void Mesh2DData::mark()
+{
+  markObject(mTexture);
+}
+
+AGTexture *Mesh2DData::getTexture()
+{
+  return mTexture;
+}
+
+AGBox3 Mesh2DData::bbox() const
+{
+  // FIXME
+  return AGBox3();
+}

Added: antargis/branches/rant/ext/3dengine/mesh_2d_data.h
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_2d_data.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_2d_data.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,23 @@
+#ifndef MESH_2D_DATA
+#define MESH_2D_DATA
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include <ag_texture.h>
+
+class Mesh2DData:public AGRubyObject
+{
+ public:
+  Mesh2DData(AGTexture *pTexture);
+  
+  void mark();
+
+  AGTexture *getTexture();
+
+  AGBox3 bbox() const;
+
+ private:
+  AGTexture *mTexture;
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/mesh_data.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_data.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_data.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,391 @@
+#include "mesh_data.h"
+#include <ag_texturecache.h>
+#include "mesh_optimizer.h"
+#include <ag_rendercontext.h>
+
+#include <ag_serial.h>
+#include <ag_main.h>
+#include <ag_vdebug.h>
+
+//////////////////////////////////////////////////////////////////////
+// MeshData
+//////////////////////////////////////////////////////////////////////
+
+int getMeshDownScale(); // implemented in anim_mesh_data.cc
+
+
+MeshData::MeshData(const VertexArray &va,const std::string &pTexture,bool pShadow):mBBox(AGVector3(0,0,0),AGVector3(-1,0,0))
+{
+  CTRACE;
+  mArray=va;
+  mWithTexture=false;
+  if(pTexture!="" && videoInited())
+    {
+      mTexture=getTextureCache()->get(pTexture,getMeshDownScale());
+      mWithTexture=true;
+    }
+  mShadow=pShadow;
+  //  mAlpha=false;
+  mTransparent=false;
+  overdraw=false;
+  drawColors=true;
+  mPickable=true;
+  mLighting=true;
+  mCulling=true;
+}
+
+
+MeshData::MeshData(const std::string &filename,float zoom,const std::string &pTexture,bool pShadow):mBBox(AGVector3(0,0,0),AGVector3(-1,0,0))
+{
+  CTRACE;
+  Uint16 faces,meshes,vertices;
+  overdraw=false;
+
+  mTransparent=false;
+  mLighting=true;
+  mCulling=true;
+
+  //  mAlpha=false;
+
+  mWithTexture=false;
+  if(pTexture!="" && videoInited())
+    {
+      mTexture=getTextureCache()->get(pTexture,getMeshDownScale());
+      mWithTexture=true;
+    }
+  
+  MeshVertex mVertices[4];
+  MeshOptimizer opt;
+  bool withTex=filename.find(".ant2")!=filename.npos;
+
+  BinaryFileIn f(filename);
+  /*
+  
+  FILE *f=fopen(filename.c_str(),"rb");
+  assert(f);
+  fread(&meshes,sizeof(Uint16),1,f);*/
+
+  f>>meshes;
+  
+  for(;meshes>0;meshes--)
+    {
+      f>>faces;
+      //      fread(&faces,sizeof(Uint16),1,f);
+      
+      for(Uint16 i=0;i<faces;i++)
+	{
+	  //  fread(&vertices,sizeof(Uint16),1,f);
+	  f>>vertices;
+	  assert(vertices<=4);
+	  for(Uint16 j=0;j<vertices;j++)
+	    {
+	      AGVector3 v,n,c;
+	      f>>v;
+	      mVertices[j].v=AGVector4(v,1);
+	      f>>n;
+	      mVertices[j].n=n;
+	      f>>c; // load here first, as mVertices[.].c is a AGVector4
+	      mVertices[j].c=AGVector4(c,1);
+	      if(withTex)
+		f>>mVertices[j].t;
+
+	      mVertices[j].t[1]=1-mVertices[j].t[1];
+
+	      mVertices[j].v*=zoom;
+	      mVertices[j].v[3]=1;
+
+	      mBBox.include(mVertices[j].v.dim3());
+	      /*
+	      fread(mVertices[j].v,sizeof(float),3,f);
+	      fread(mVertices[j].n,sizeof(float),3,f);
+	      fread(mVertices[j].c,sizeof(float),3,f);
+	      if(withTex)
+		fread(mVertices[j].t,sizeof(float),2,f);
+	      mVertices[j].t[1]=1-mVertices[j].t[1];
+
+	      mVertices[j].v*=zoom;
+	      mVertices[j].v[3]=1;
+
+	      mBBox.include(mVertices[j].v.dim3());
+	      */
+	    }
+	  if(vertices==3)
+	    {
+	      opt.add(mVertices[0]);
+	      opt.add(mVertices[1]);
+	      opt.add(mVertices[2]);
+	    }
+	  else
+	    {
+	      opt.add(mVertices[0]);
+	      opt.add(mVertices[1]);
+	      opt.add(mVertices[2]);
+	      opt.add(mVertices[0]);
+	      opt.add(mVertices[2]);
+	      opt.add(mVertices[3]);
+	    }
+	}
+    }
+  //  fclose(f);
+  mShadow=pShadow;
+  mArray=opt.getArray();
+
+
+
+
+  drawColors=true;
+  mPickable=true;
+}
+
+MeshData::~MeshData()
+{
+  //  TRACE;
+}
+
+bool MeshData::transparent()
+{
+  return mTransparent;
+}
+
+void MeshData::setTransparent(bool p)
+{
+  mTransparent=p;
+}
+
+void MeshData::setLighting(bool l)
+{
+  mLighting=l;
+}
+
+AGBox3 MeshData::bbox() const
+{
+  return mBBox;
+}
+
+
+void MeshData::save(const std::string &pFilename)
+{
+  FILE *f=fopen(pFilename.c_str(),"wb");
+
+  size_t meshes=1;
+  size_t vertices=3;
+  size_t faces=mArray.getTriangles();
+
+  // meshes
+  fwrite(&meshes,sizeof(Uint16),1,f);
+
+  // faces
+  fwrite(&faces,sizeof(Uint16),1,f);
+  for(size_t i=0;i<faces;i++)
+    {
+      fwrite(&vertices,sizeof(Uint16),1,f);
+      for(size_t k=0;k<vertices;k++)
+	{
+	  size_t j=mArray.getIndex(i*vertices+k);
+	  fwrite(mArray.getVertex(j),sizeof(float),3,f);
+	  fwrite(mArray.getNormal(j),sizeof(float),3,f);
+	  fwrite(mArray.getColor(j),sizeof(float),3,f);
+	  fwrite(mArray.getTexCoord(j),sizeof(float),2,f);
+	}
+    }
+
+  fclose(f);
+}
+
+
+void MeshData::setOverdraw(bool o)
+{
+  overdraw=o;
+}
+
+void MeshData::drawPick()
+{
+  if(mPickable)
+    mArray.drawPick();
+}
+#ifdef OLD
+void MeshData::draw()
+{
+  if(!mShadow)
+    glDepthMask(false);
+
+  if(mTransparent)
+    glDisable(GL_CULL_FACE);
+
+  glEnable(GL_ALPHA_TEST);
+  glAlphaFunc(GL_GREATER,0.9);
+
+
+  if(mLighting)
+    glEnable(GL_LIGHTING);
+  else
+    glDisable(GL_LIGHTING);
+
+  glBindTexture(GL_TEXTURE_2D,0);
+  glEnable(GL_COLOR_MATERIAL);
+  glColorMaterial(GL_FRONT,GL_AMBIENT_AND_DIFFUSE);
+  
+
+  if(mWithTexture)
+    glBindTexture(GL_TEXTURE_2D,mTexture.getTextureID());
+
+  if(mTransparent)
+    {
+      glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);//_MIPMAP_LINEAR);//NEAREST);//GL_LINEAR);
+
+      //      glDisable(GL_LIGHTING);
+      glAlphaFunc(GL_GREATER,0.4f);
+      glEnable(GL_ALPHA_TEST);
+    }
+  if(overdraw)
+    {
+      glDisable(GL_ALPHA_TEST);
+      glDisable(GL_DEPTH_TEST);
+    }
+  mArray.setColors(drawColors);
+  mArray.draw();
+  if(overdraw)
+    {
+      glEnable(GL_DEPTH_TEST);
+      glEnable(GL_ALPHA_TEST);
+    }
+  if(mTransparent)
+    {
+      glAlphaFunc(GL_GREATER,0.9f);
+      glEnable(GL_LIGHTING);
+    }
+  //    glEnable(GL_ALPHA_TEST);
+
+
+  glBindTexture(GL_TEXTURE_2D,0);
+  if(!mShadow)
+    glDepthMask(true);
+
+  glDisable(GL_ALPHA_TEST);
+  if(mTransparent)
+    glEnable(GL_CULL_FACE);
+}
+#else
+
+void MeshData::setCulling(bool c)
+{
+  mCulling=c;
+}
+
+
+void MeshData::draw(const AGVector4 &pColor)
+{
+  AGRenderContext c;
+  
+  if(!mShadow)
+    c.setDepthWrite(false);
+
+  //  if(mTransparent)
+  c.setCulling(mCulling);
+
+  c.setAlpha(0.9,GL_GREATER);
+
+  c.setLighting(mLighting);
+
+  if(pColor!=AGVector4(1,1,1,1))
+    c.setColor(pColor);
+
+  if(mWithTexture)
+    c.setTexture(mTexture.glTexture());
+
+  if(mTransparent)
+    {
+      mTexture.setFilter(GL_LINEAR,GL_LINEAR);
+      c.setAlpha(0.4f,GL_GREATER);
+    }
+  if(overdraw)
+    {
+      c.setDepthWrite(false);
+      c.setDepthTest(false);
+      c.setAlpha(0,GL_NONE);
+    }
+  c.begin();
+  mArray.setColors(drawColors);
+  mArray.draw();
+}
+
+#endif
+
+
+void MeshData::setColors(bool c)
+{
+  drawColors=c;
+}
+
+size_t MeshData::getTriangles() const
+{
+  return mArray.getTriangles();
+}
+
+void MeshData::drawShadow()
+{
+  if(mTransparent)
+    glDisable(GL_CULL_FACE);
+
+  drawDepth();
+
+  if(mTransparent)
+    glEnable(GL_CULL_FACE);
+}
+void MeshData::drawDepth()
+{
+  assertGL;
+  AGRenderContext c;
+  if(mTransparent)
+    {
+      c.setCulling(false);
+      c.setAlpha(0.9f,GL_GREATER);
+      c.setTexture(mTexture.glTexture());
+      /*
+      glDisable(GL_CULL_FACE);
+      //      throw int();
+
+      glBindTexture(GL_TEXTURE_2D,mTexture.getTextureID());
+      glEnable(GL_ALPHA_TEST);
+      glAlphaFunc(GL_GREATER,0.9f);
+      */
+      //      cdebug("muh");
+    }
+  c.begin();
+  assertGL;
+  if(mShadow)
+    {
+      mArray.setColors(false);
+      mArray.draw();
+      mArray.setColors(true);
+    }
+  /*  if(mTransparent)
+    {
+      glEnable(GL_CULL_FACE);
+      glBindTexture(GL_TEXTURE_2D,0);
+      }*/
+}
+
+void MeshData::texCoordFromPos(float scale)
+{
+  for(size_t i=0;i<mArray.getTriangles()*3;i++)
+    {
+      size_t j=mArray.getIndex(i);
+
+      AGVector4 v=mArray.getVertex(j);
+      AGVector2 t(v[0]+v[1],v[2]);
+      mArray.setTexCoord(j,t*scale);
+    }
+}
+
+void MeshData::setPickable(bool p)
+{
+  mPickable=p;
+}
+
+void MeshData::makeInstances(const std::vector<AGMatrix4> &ts)
+{
+  VertexArray *va=::makeInstances(mArray,ts);
+  mArray=*va;
+  delete va;
+}

Added: antargis/branches/rant/ext/3dengine/mesh_data.h
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_data.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_data.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,67 @@
+#ifndef MESH_DATA_H
+#define MESH_DATA_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include "scenenode.h"
+#include "mesh_data.h"
+#include "vertex_array.h"
+#include "ag_texture.h"
+
+// Mesh organizing
+
+class MeshData:public AGRubyObject
+{
+  VertexArray mArray;
+  AGTexture mTexture;
+  bool mWithTexture;
+  bool mShadow;
+
+  AGBox3 mBBox;
+
+  bool mTransparent;
+
+  bool overdraw;
+  bool drawColors;
+  bool mPickable;
+  bool mLighting;
+  bool mCulling;
+
+ public:
+  MeshData(const std::string &filename,float zoom,const std::string &pTexture="",bool pShadow=true);
+  MeshData(const VertexArray &va,const std::string &pTexture,bool pShadow=true);
+  ~MeshData();
+
+  void draw(const AGVector4 &pColor);
+  void drawShadow();
+  void drawDepth();
+  void drawPick();
+
+  /// test function "instancing"
+  void makeInstances(const std::vector<AGMatrix4> &ts);
+
+
+  AGBox3 bbox() const;
+
+  void save(const std::string &pFilename);
+
+  virtual size_t getTriangles() const;
+
+  virtual AGVector4 lineHit(const AGLine3 &pLine) const
+  {
+    return mArray.lineHit(pLine);
+  }
+  void texCoordFromPos(float scale);
+  void setPickable(bool p);
+
+  void setTransparent(bool p);
+  virtual bool transparent();
+  void setLighting(bool l);
+
+  void setOverdraw(bool o);
+  void setCulling(bool c);
+  void setColors(bool c);
+};
+
+
+#endif

Added: antargis/branches/rant/ext/3dengine/mesh_optimizer.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_optimizer.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_optimizer.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,175 @@
+#include "mesh_optimizer.h"
+#include <ag_debug.h>
+#include <ag_serial.h>
+
+//////////////////////////////////////////////////////////////////////
+// Mesh-optimizing
+//////////////////////////////////////////////////////////////////////
+
+// sorting
+bool MeshVertex::operator<(const MeshVertex &p) const
+{
+  int i;
+  for(i=0;i<3;i++)
+    if(v[i]<p.v[i])
+      return true;
+  
+  for(i=0;i<4;i++)
+    if(c[i]<p.c[i])
+      return true;
+  
+  for(i=0;i<3;i++) 
+    if(n[i]<p.n[i]) 
+      return true; 
+  
+  for(i=0;i<2;i++)
+    if(t[i]<p.t[i]) 
+      return true;
+  
+    return false;
+}
+
+
+MeshOptimizer::MeshOptimizer()
+{
+  saved=0;
+}
+void MeshOptimizer::add(const MeshVertex &v)
+{
+  size_t index=mVertices.size();
+  std::map<MeshVertex,int>::iterator i=mMap.find(v);
+  if(i!=mMap.end())
+    {
+      saved++;
+      index=i->second;
+    }
+  else
+    {
+      mVertices.push_back(v);
+      mMap[v]=index;
+    }
+  assert(index<mVertices.size());
+  mIndices.push_back(index);
+  return;
+}
+
+
+struct MeshTriangle
+{
+  size_t i0,i1,i2;
+  MeshTriangle(size_t p0,size_t p1,size_t p2)
+  {
+    i0=p0;
+    i1=p1;
+    i2=p2;
+  }
+
+  bool operator<(const MeshTriangle &t) const;
+};
+
+struct TriCompare
+{
+  MeshOptimizer *o;
+  AGVector3 c;
+  TriCompare(MeshOptimizer *p,AGVector3 cam):o(p),c(cam)
+  {
+  }
+  bool operator()(const MeshTriangle &t1,const MeshTriangle &t2)
+  {
+    AGVector3 m0=(o->getV(t1.i0).dim3()+o->getV(t1.i1).dim3()+o->getV(t1.i2).dim3())/3.0;
+    AGVector3 m1=(o->getV(t2.i0).dim3()+o->getV(t2.i1).dim3()+o->getV(t2.i2).dim3())/3.0;
+
+    return (c-m0).length2()>(c-m1).length2();
+  }
+};
+
+
+
+VertexArray MeshOptimizer::getArray()
+{
+  CTRACE;
+  VertexArray a;
+  for(size_t i=0;i<mVertices.size();i++)
+    {
+      MeshVertex v=mVertices[i];
+      a.addVertex(v.v,v.c,v.n,v.t);
+    }
+
+  std::vector<MeshTriangle> tris;
+  for(size_t i=0;i<mIndices.size();i+=3)
+    {
+      tris.push_back(MeshTriangle(mIndices[i],mIndices[i+1],mIndices[i+2]));
+    }  
+  sort(tris.begin(),tris.end(),TriCompare(this,AGVector3(0,-10,10)));
+
+  for(std::vector<MeshTriangle>::iterator i=tris.begin();i!=tris.end();i++)
+    a.addTriangle(i->i0,i->i1,i->i2);
+
+
+  if(mIndices.size()==0)
+    cdebug("NO TRIANGLES FOUND!");
+  cdebug("SAVED:"<<1.0f-float(saved)/mIndices.size());
+  return a;
+}
+
+AGVector4 MeshOptimizer::getV(size_t i)
+{
+  return mVertices[i].v;
+}
+
+
+MeshOptimizer loadFromText(const std::string &pText, bool withTex, float zoom)
+{
+  MeshOptimizer opt;
+  MeshVertex mVertices[4];
+
+  BinaryStringIn in(pText);
+
+  Uint16 meshes,faces,vertices;
+  AGVector3 v;
+
+  in>>meshes;
+  cdebug("meshes:"<<meshes);
+  for(;meshes>0;meshes--)
+    {
+      in>>faces;
+      cdebug("faces:"<<faces);
+      for(Uint16 i=0;i<faces;i++)
+	{
+	  in>>vertices;
+	  cdebug("vs:"<<vertices);
+	  assert(vertices<=4);
+	  for(Uint16 j=0;j<vertices;j++)
+	    {
+	      in>>v;
+	      mVertices[j].v=AGVector4(v,1);
+	      //	      cdebug("v:"<<mVertices[j].v.toString());
+	      in>>mVertices[j].n;
+	      in>>v;
+	      mVertices[j].c=AGVector4(v,1);
+	      if(withTex)
+		in>>mVertices[j].t;
+	      mVertices[j].v*=zoom;
+	      mVertices[j].v[3]=1;
+	    }
+	  if(vertices==3)
+	    {
+	      opt.add(mVertices[0]);
+	      opt.add(mVertices[1]);
+	      opt.add(mVertices[2]);
+	    }
+	  else
+	    {
+	      opt.add(mVertices[0]);
+	      opt.add(mVertices[1]);
+	      opt.add(mVertices[2]);
+	      opt.add(mVertices[0]);
+	      opt.add(mVertices[2]);
+	      opt.add(mVertices[3]);
+	    }
+	}
+    }
+
+
+  return opt;
+}

Added: antargis/branches/rant/ext/3dengine/mesh_optimizer.h
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_optimizer.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_optimizer.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,53 @@
+#ifndef MESH_OPTIMIZER
+#define MESH_OPTIMIZER
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include "ag_geometry.h"
+#include "vertex_array.h"
+
+#include <map>
+
+/** This file provides functionality for:
+    building of an indexed mesh out of a set of (vertex,color,normal,tex2dcoords)
+    each 3 of them a triangle. Similar vertices will be joined automatically.
+    Use it like this:
+    
+    1) generate a MeshOptimizer objet
+    2) add 3*n vertices
+    3) get a VertexArray by calling getArray()
+*/
+
+struct MeshVertex
+{
+  AGVector4 v,c;
+  AGVector3 n;
+  AGVector2 t;
+
+  // sorting
+  bool operator<(const MeshVertex &p) const;
+};
+
+// generates index list for same vertices (with same colors/normals..)
+class MeshOptimizer
+{
+  std::map<MeshVertex,int> mMap;
+  std::vector<int> mIndices;
+
+  std::vector<MeshVertex> mVertices;
+  int saved;
+ public:
+  MeshOptimizer();
+
+  void add(const MeshVertex &v);
+  VertexArray getArray();
+
+  AGVector4 getV(size_t i);
+};
+
+
+// some old function ???
+// used in gen_tree ?? this gen_tree shouldn't be used anymore, too
+MeshOptimizer loadFromText(const std::string &pText, bool withTex, float zoom);
+
+#endif

Added: antargis/branches/rant/ext/3dengine/mesh_sort.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_sort.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_sort.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,23 @@
+#include "mesh_sort.h"
+
+
+bool SortDistance::operator()(const SceneNode *n1,const SceneNode *n2)
+{
+  AGVector3 m1=const_cast<SceneNode*>(n1)->bbox().base+const_cast<SceneNode*>(n1)->bbox().dir*0.5;
+  AGVector3 m2=const_cast<SceneNode*>(n2)->bbox().base+const_cast<SceneNode*>(n2)->bbox().dir*0.5;
+  
+  return (m1-cam).length2()<(m2-cam).length2();
+}
+
+bool SortOrder::operator()(const SceneNode *n1,const SceneNode *n2)
+{
+  return n1->getOrder()<n2->getOrder();
+}
+
+
+
+bool SortYCoord::operator()(const SceneNode *n1,const SceneNode *n2)
+{
+  //  return n1->getPos()[1]>n2->getPos()[1];
+  return n1->getOrder()<n2->getOrder() || (n1->getOrder()==n2->getOrder() && n1->getPos()[1]>n2->getPos()[1]);
+}

Added: antargis/branches/rant/ext/3dengine/mesh_sort.h
===================================================================
--- antargis/branches/rant/ext/3dengine/mesh_sort.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/mesh_sort.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,41 @@
+#ifndef MESH_SORT_H
+#define MESH_SORT_H
+
+#include <ag_geometry.h>
+#include "scenenode.h"
+
+/**
+   The class is for sorting purpose only. It provides the operator() function, that's needed
+   for the STL-sorting algorithms.
+   Here SceneNodes are sorted by their middle distance the camera.
+*/
+class SortDistance
+{
+  AGVector3 cam;
+public:
+  SortDistance(AGVector3 c):cam(c){}
+
+  bool operator()(const SceneNode *n1,const SceneNode *n2);
+};
+
+/**
+   This is a sorting class, too. It sorts by the given "SortOrder" of the scene-nodes
+*/
+class SortOrder
+{
+public:
+  SortOrder(){}
+
+  bool operator()(const SceneNode *n1,const SceneNode *n2);
+};
+
+class SortYCoord
+{
+ public:
+  SortYCoord(){}
+  
+  bool operator()(const SceneNode *n1,const SceneNode *n2);
+};
+
+
+#endif

Added: antargis/branches/rant/ext/3dengine/quadtree.h
===================================================================
--- antargis/branches/rant/ext/3dengine/quadtree.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/quadtree.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * quadtree.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef QUADTREE_H
+#define QUADTREE_H
+
+#include <ag_geometry.h>
+#include <ag_debug.h>
+
+#include <set>
+
+/**
+   sadly enough C++ still doesn't support templating in out of object files...
+
+   This is a simple quad-tree, that's based upon some "unknown object", that must contain
+   these functions:
+   * getRect()
+   * any more ???
+   The Rectangles are defined with AGRect2.
+
+   QuadTree doesn't own objects - you have to delete them yourself
+
+*/
+template<class T>
+class QuadTree
+  {
+    // ignore this node-structure - it works ;-)
+    struct Node
+      {
+        std::set
+          <T*> ts;
+        std::list<Node*> children;
+        AGRect2 r;
+
+        Node(AGRect2 R):r(R)
+      {}
+
+	~Node()
+	{
+	  for(typename std::list<Node*>::iterator i=children.begin();i!=children.end();++i)
+	    delete *i;
+	}
+
+	size_t size() const
+	{
+	  size_t s=ts.size();
+	  for(typename std::list<Node*>::const_iterator i=children.begin();i!=children.end();i++)
+	    s+=(*i)->size();
+	  return s;
+	}
+	void getAll(std::list<T*> &l)
+	{
+	  std::copy(ts.begin(),ts.end(),std::back_inserter(l));
+	  for(typename std::list<Node*>::iterator i=children.begin();i!=children.end();i++)
+	    (*i)->getAll(l);
+	}
+      
+        void get(const AGRect2 &pr,std::list<T*> &l)
+        {
+          typename std::set<T*>::iterator i=ts.begin();
+          for(;i!=ts.end();i++)
+            l.push_back(*i);
+            
+          typename std::list<Node*>::iterator j=children.begin();
+          for(;j!=children.end();j++)
+            if((*j)->r.collide(pr))
+              (*j)->get(pr,l);
+        }
+
+        void insert(T* t)
+        {
+          if(children.size())
+            {
+              typename std::list<Node*>::iterator i=children.begin();
+              for(;i!=children.end();i++)
+                if((*i)->r.contains(t->getRect()))
+                  {
+                    (*i)->insert(t);
+                    return;
+                  }
+            }
+          ts.insert(t);
+	  if(ts.size()>2 && children.size()==0 && r.w()>3 && r.h()>3)
+	    split();
+        }
+        
+        void clear()
+        {
+          typename std::list<Node*>::iterator i=children.begin();
+          for(;i!=children.end();i++)
+          {
+            (*i)->clear();
+            delete *i;
+          }
+          children.clear();
+
+          ts.clear();
+          
+        }
+
+        void split()
+        {
+          std::set
+            <T*> ot=ts;
+          ts.clear();
+          std::list<AGRect2> rs=r.split();
+          std::list<AGRect2>::iterator i=rs.begin();
+          for(;i!=rs.end();i++)
+            {
+              children.push_back(new Node(*i));
+            }
+          typename std::set
+            <T*>::iterator j=ot.begin();
+          for(;j!=ot.end();j++)
+            insert(*j);
+        }
+
+        bool remove
+          (T* t)
+          {
+            if(ts.find(t)!=ts.end())
+              {
+                ts.erase(t);
+                return true;
+              }
+            if(children.size())
+              {
+                typename std::list<Node*>::iterator i=children.begin();
+                for(;i!=children.end();i++)
+                  {
+                    if((*i)->r.contains(t->getRect()))
+		      return (*i)->remove(t);
+                  }
+              }
+	    return false;
+          }
+
+      };
+
+    Node *root;
+
+  public:
+
+    /**
+     * A quadtree tiles big rectangles into smaller ones. Elements get inserted into the smallest rectangle that contains an element.
+     * So you have a starting-rectangle
+     * @param r Starting rectangle, that gets tiled. This should contain everything that you want to store here. But don't make this
+     *  rectangle too big, because otherwise must be tiled several times before even one object can be inserted.
+    */
+
+    QuadTree(AGRect2 r)
+    {
+      root=new Node(r);
+    }
+    ~QuadTree()
+      {
+	delete root;
+      }
+
+    /**
+       insert an object
+       @param t the object you want to insert
+    */
+    void insert(T* t)
+    {
+      root->insert(t);
+    }
+
+    /// get all the objects - should be used at all (only testing purpose)
+    std::list<T*> getAll()
+      {
+	std::list<T*> l;
+	root->getAll(l);
+	return l;
+      }
+    
+    /// this one you should call - get all objects, that intersect (or are included in) this rectangle
+    std::list<T*> get(const AGRect2 &r)
+    {
+      std::list<T*> l;
+      root->get(r,l);
+      return l;
+    }
+    
+    /// remove some object
+    bool remove
+      (T* t)
+      {
+	if(t)
+	  return root->remove(t);
+	return false;
+      }
+      
+    /// empty this tree!
+    void clear()
+    {
+      root->clear();
+    }
+    size_t size() const
+    {
+      return root->size();
+    }
+  };
+
+#endif

Added: antargis/branches/rant/ext/3dengine/scene.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/scene.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scene.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,536 @@
+#include "ant_renderer.h"
+#include "scene.h"
+
+#include <GL/gl.h>
+#include <GL/glu.h>
+
+#include <ag_debug.h>
+#include <ag_vdebug.h>
+#include <ag_video.h>
+#include <ag_rendercontext.h>
+#include <algorithm>
+
+#include <math.h>
+
+#include "quadtree.h"
+#include "ag_profiler.h"
+#include "ag_main.h"
+#include "mesh_sort.h"
+
+bool PickNode::operator<(const PickNode &n) const
+{
+  return camDist<n.camDist;
+}
+
+
+
+Scene::Scene(int w,int h):
+  SceneBase(w,h)
+{
+  white=AGVector4(1,1,1,1);
+  black=AGVector4(0,0,0,1);
+  
+  cdebug("SHADOW:"<<(int)GLEE_ARB_shadow);
+  cdebug("SHADOW_AMB:"<<(int)GLEE_ARB_shadow_ambient);
+  
+  GLeeInit();
+  
+  if(getRenderer()->canShadow())
+    mShadow=1;
+  else
+    mShadow=0;
+  
+  mRubyObject=false;
+  mEnabled=true;
+
+}
+
+
+Scene::~Scene()
+{
+}
+
+size_t Scene::getDrawnMeshes() const
+{
+  return mMeshes;
+}
+
+size_t Scene::getTriangles() const
+{
+  return mTriangles;
+}
+
+size_t Scene::getPickTriangles() const
+{
+  return mPickTriangles;
+}
+
+
+void Scene::draw()
+{
+  if(!mEnabled)
+    return;
+  AGRenderContext c;
+  c.begin(); // reset gl-state
+
+  getRenderer()->setCurrentScene(this);
+  assertGL;
+
+  mMeshes=0;
+  mTriangles=0;
+  mPickTriangles=0;
+
+  for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
+    (*i)->sort(AGVector4(mCamera.getPosition(),1));
+  
+  if(mShadow)
+    {
+      calcShadowMap();
+      initScene();
+      drawShadow();
+    }
+  else
+    {
+      initScene();
+      drawScene();
+    }
+
+  getRenderer()->setCurrentScene(0);
+}
+
+void Scene::setShadow(int v)
+{
+  if(getRenderer()->canShadow())
+    {
+      mShadow=v;
+      cdebug(mShadow);
+    }
+}
+int Scene::getShadow() const
+{
+  return mShadow;
+}
+
+
+
+
+Scene::NodeList Scene::getCurrentNodes()
+{
+  STACKTRACE;
+  AGVector2 p=mCamera.getPosition().dim2();
+  NodeList l=mTree->get(AGRect2(p+AGVector2(-30,-30),p+AGVector2(30,30)));
+
+  for(NodeList::iterator i=l.begin();i!=l.end();i++)
+    {
+      if(mNodeSet.find(*i)==mNodeSet.end())
+	cdebug("ERROR:"<<*i);
+      assert(mNodeSet.find(*i)!=mNodeSet.end());
+    }
+  return l;
+}
+
+
+void Scene::calcShadowMap()
+{
+  STACKTRACE;
+  assertGL;
+  //  AGMatrix4 frustum=getFrustum();
+  size_t shadowMeshes=0;
+
+  getRenderer()->beginShadowComputation();
+
+  {
+    STACKTRACE;
+    NodeList l=getCurrentNodes();
+    Nodes sorted;
+    std::copy(l.rbegin(),l.rend(),std::back_inserter(sorted));
+    
+
+    {
+      // apply frustrum culling
+      AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
+      for(Nodes::iterator i=sorted.begin();i!=sorted.end();)
+	{
+	  if(cFrustum.collides((*i)->bbox()))
+	    i++;
+	  else
+	    i=sorted.erase(i);
+	}
+    }
+
+    sort(sorted.begin(),sorted.end(),SortOrder());
+      
+    for(Nodes::iterator i=sorted.begin();i!=sorted.end();i++)
+      {
+	{
+	  if((*i)->visible())
+	    {
+	      (*i)->drawDepth();
+	      mTriangles+=(*i)->getTriangles();
+	      shadowMeshes++;
+	    }
+	}
+    }
+  }
+  //  cdebug("shadowMeshes:"<<shadowMeshes);
+
+  getRenderer()->endShadowComputation();
+  assertGL;
+}
+
+/**
+   setups up lighting and gl-matrices (projection and such)
+*/
+void Scene::initScene()
+{
+  glClear(GL_DEPTH_BUFFER_BIT);
+  
+  glMatrixMode(GL_PROJECTION);
+  glLoadMatrixf(mCamera.getProjection());
+  
+  glMatrixMode(GL_MODELVIEW);
+  glLoadIdentity();
+
+  float xfactor=float(getVideo()->realWidth())/getVideo()->width();
+  float yfactor=float(getVideo()->realHeight())/getVideo()->height();
+  
+  glViewport(0, 0,(GLint)(mCamera.getWidth()*xfactor), (GLint)(mCamera.getHeight()*yfactor));
+  
+  //Use dim light to represent shadowed areas
+
+  AGVector4 l=mCamera.getLightPosition();
+  l[3]=1;
+
+  glLightfv(GL_LIGHT1, GL_POSITION, l);
+  glLightfv(GL_LIGHT1, GL_AMBIENT, AGVector4(0.1,0.1,0.1,1));//white*0.05f);
+  glLightfv(GL_LIGHT1, GL_DIFFUSE, AGVector4(0.3,0.3,0.3,1));//white*0.3f);//*0.2f);
+  glLightfv(GL_LIGHT1, GL_SPECULAR, black);
+  glEnable(GL_LIGHT1);
+
+  AGVector4 lightPosition2=AGVector4( 0, 0, -50,1);
+
+  //  glLightfv(GL_LIGHT2, GL_POSITION, lightPosition2+scenePosition);
+  glLightfv(GL_LIGHT2, GL_AMBIENT, black);
+  glLightfv(GL_LIGHT2, GL_DIFFUSE, AGVector4(0.7,0.7,0.7,1));//white*0.7f);//*0.2f);
+  glLightfv(GL_LIGHT2, GL_SPECULAR, white);
+  glLightfv(GL_LIGHT2, GL_SPOT_DIRECTION, AGVector4(0,0,-1,0));
+  glLightf(GL_LIGHT2,GL_LINEAR_ATTENUATION,0);
+  glLightf(GL_LIGHT2,GL_QUADRATIC_ATTENUATION,0);
+  glLightf(GL_LIGHT2,GL_CONSTANT_ATTENUATION,0);
+  glEnable(GL_LIGHT2);
+
+
+
+  glEnable(GL_LIGHTING);
+
+  glDisable(GL_LIGHT0);
+  glDisable(GL_LIGHT3);
+  glDisable(GL_LIGHT4);
+  glDisable(GL_LIGHT5);
+
+  //  glLoadMatrixf(cameraViewMatrix);
+  glLoadMatrixf(mCamera.getModelview());
+}
+
+#ifdef TEST_DL
+static GLuint displayList=0;
+static bool dlInited=false;
+#endif
+
+void Scene::drawScene()
+{
+#ifdef TEST_DL
+  // this was for testing only - to check if display-lists are any good.
+  // it seems they are comparable with VBOs - the problem is that they're inflexible
+  // please leave this code, so we have some example, if we happen to use this again at a later stage
+
+  if(dlInited)
+    {
+      glCallList(displayList);
+    }
+  else
+    {
+      dlInited=true;
+      displayList=glGenLists(1);
+      glNewList(displayList,GL_COMPILE);
+#endif
+
+  STACKTRACE; 
+
+  // this is used for frustum cullin
+  AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
+  
+  //2nd pass - Draw from camera's point of view
+
+  // draw scene with texturing and so
+
+  int drawn=0;
+
+  NodeList l=getCurrentNodes();
+  Nodes sorted;
+  std::copy(l.begin(),l.end(),std::back_inserter(sorted));
+
+  {
+    STACKTRACE;
+    for(Nodes::iterator i=sorted.begin();i!=sorted.end();)
+      {
+	if(cFrustum.collides((*i)->bbox()))
+	  i++;
+	else
+	  i=sorted.erase(i);
+      }
+  }
+
+  sort(sorted.begin(),sorted.end(),SortOrder());
+  // draw opaque objects first, from front to back
+  for(Nodes::iterator i=sorted.begin();i!=sorted.end();i++)
+    {
+      if(!(*i)->transparent())
+	{
+	  if((*i)->visible())
+	    {
+	      (*i)->draw();
+	      mTriangles+=(*i)->getTriangles();
+	      drawn++;
+	      mMeshes++;
+	    }
+	}
+    }
+  sort(sorted.begin(),sorted.end(),SortDistance(mCamera.getCameraPosition().dim3()));
+  // draw transparent ones next from back to front
+  for(Nodes::reverse_iterator i=sorted.rbegin();i!=sorted.rend();i++)
+    {
+      if((*i)->transparent())
+	{
+	  if((*i)->visible())
+	    {
+	      (*i)->draw();
+	      mTriangles+=(*i)->getTriangles();
+	      drawn++;
+	      mMeshes++;
+	    }
+	}
+    }
+
+#ifdef TEST_DL
+  glEndList();
+  glCallList(displayList);
+    }
+#endif
+
+}
+
+
+/// deprecated function - this is done in one pass with "normal" drawing
+/// it was used to paint the shadow afterwards in a 3rd pass
+void Scene::drawShadow()
+{
+  assertGL;
+
+  getRenderer()->beginShadowDrawing();
+  
+  drawScene();
+
+  getRenderer()->endShadowDrawing();
+
+  assertGL;
+}
+
+AGVector3 Scene::getCameraDirTo(const AGVector3 &p) const
+{
+  return mCamera.getCameraPosition().dim3()-p;
+}
+
+/** pickDraw is used for picking ;-)
+    it draws all the objects with opengl
+    and not using texturing, shaders and such - if I'm right here??
+*/
+void Scene::pickDraw()
+{
+  STACKTRACE;
+  GLuint name=1;
+  pickNames.clear();
+
+  AGMatrix4 frustum=cameraPickMatrix*mCamera.getModelview();
+
+  AntFrustum cFrustum=mCamera.getCameraProjection().getFrustum();
+  
+  NodeList l=getCurrentNodes();
+
+  for(NodeList::iterator i=l.begin();i!=l.end();i++)
+    {
+      STACKTRACE;
+      if((*i)->visible() && (*i)->bbox().collides(frustum))
+	if(cFrustum.collides((*i)->bbox()))
+	  {
+	    STACKTRACE;
+	    glPushName(name);
+	    (*i)->drawPick();
+	    glPopName();
+	    pickNames.insert(std::make_pair(name,*i));
+	    name++;
+	    mPickTriangles+=(*i)->getTriangles();
+	  }
+    }
+
+  glEnable(GL_CULL_FACE);
+}
+
+/// this a global function - use this for picking!
+/// x and y are in screen-coordinates in normal fashion
+/// so (0,0) is the top left corner and (1023,767) bottom right.
+/// the same for w and h
+Scene::PickResult Scene::pick(float x,float y,float w,float h)
+{
+  STACKTRACE;
+  size_t bufsize=4000;
+  GLuint buffer[bufsize+1];
+  
+  glSelectBuffer(bufsize,buffer);
+  glRenderMode(GL_SELECT);
+  
+  glMatrixMode(GL_PROJECTION);
+  glPushMatrix();
+  glLoadIdentity();
+  
+  assertGL;
+  gluPickMatrix(x,mCamera.getHeight()-y,h,w,getViewport());
+
+  assertGL;
+  
+  glMultMatrixf(mCamera.getProjection());
+  glGetFloatv(GL_PROJECTION_MATRIX, cameraPickMatrix);
+  assertGL;
+  
+  glMatrixMode(GL_MODELVIEW);
+  glPushMatrix();
+  glLoadIdentity();
+
+  glMultMatrixf(mCamera.getModelview());
+  glInitNames();
+  assertGL;
+
+  pickDraw();
+  assertGL;
+  
+  
+  // back to normality
+  glPopMatrix();
+  glMatrixMode(GL_PROJECTION);
+  glPopMatrix();
+  glMatrixMode(GL_MODELVIEW);
+  glFlush();
+  assertGL;
+  
+  int hits=glRenderMode(GL_RENDER);
+  assertGL;
+  PickResult r=processHits(hits,buffer,x+w/2,mCamera.getHeight()-(y+h/2));
+  std::sort(r.begin(),r.end());
+  return r;
+}
+
+/// helper function for gettin PickResult from opengl's buffers
+Scene::PickResult Scene::processHits (int hits, GLuint *buffer,float px,float py)
+{
+  STACKTRACE;
+  PickResult result;
+  if(hits==0)
+    return result;
+
+   unsigned int i, j;
+   GLuint names, *ptr, minZ,*ptrNames, numberOfNames;
+
+   ptr = (GLuint *) buffer;
+   minZ = 0xffffffff;
+   for (i = 0; i < (unsigned int)hits; i++) { 
+      names = *ptr;
+      ptr++;
+      if (*ptr < minZ) {
+	numberOfNames = names;
+	minZ = *ptr;
+
+	ptrNames = ptr+2;
+
+	GLuint *mptr=ptrNames;
+	for(j=0;j<numberOfNames;j++,mptr++)
+	  {
+	    PickNode n;
+	    n.node=pickNames[*mptr];
+	    n.camDist=minZ/float(0xFFFFFFFF); // (0-1)
+
+	    // get world-position
+	    GLdouble x,y,z;
+
+	    GLdouble modelview[16],projection[16];
+	    for(size_t i=0;i<16;i++)
+	      {
+		modelview[i]=((float*)mCamera.getModelview())[i];
+		projection[i]=((float*)cameraPickMatrix)[i];
+	      }
+
+	    gluUnProject(px,py,n.camDist,modelview,projection,getViewport(),&x,&y,&z);
+	    n.pos=AGVector4(x,y,z,1);
+	    n.camDist=(n.pos-mCamera.getCameraPosition()).length3();
+
+	    result.push_back(n);
+	  }
+
+      }
+      
+      ptr += names+2;
+   }
+
+   return result;
+}
+
+
+Viewport Scene::getViewport() const
+{
+  return mCamera.getViewport();
+}
+
+
+
+AGMatrix4 Scene::getLightComplete() const
+{
+  return mCamera.getLightComplete();
+}
+
+AGMatrix4 Scene::getLightView() const
+{
+  return mCamera.getLightView();
+}
+AGMatrix4 Scene::getLightProj() const
+{
+  return mCamera.getLightProjectionMatrix();
+}
+
+
+AGVector2 Scene::getPosition(const AGVector4 &v) const
+{
+  GLdouble x,y,z;
+  
+  GLdouble modelview[16],projection[16];
+  for(size_t i=0;i<16;i++)
+    {
+      modelview[i]=((const float*)mCamera.getModelview())[i];
+      projection[i]=((const float*)mCamera.getProjection())[i];
+    }
+
+  gluProject(v[0],v[1],v[2],modelview,projection,getViewport(),&x,&y,&z);
+  return AGVector2((int)x,((int)mCamera.getHeight()-y));
+}
+
+
+
+void Scene::setEnabled(bool p)
+{
+  mEnabled=p;
+}
+
+
+void Scene::advance(float time)
+{
+  if(mEnabled)
+    SceneBase::advance(time);
+}

Added: antargis/branches/rant/ext/3dengine/scene.h
===================================================================
--- antargis/branches/rant/ext/3dengine/scene.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scene.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,160 @@
+#ifndef __SCENE_H
+#define __SCENE_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include "GLee.h"
+#include "ag_geometry.h"
+#include "ag_geometry.h"
+
+#include <SDL_opengl.h>
+
+#include <vector>
+#include <set>
+#include <map>
+
+#include "scenenode.h"
+#include "scene_base.h"
+#include "ant_camera.h"
+
+/**
+   \defgroup Engine3d 3d-engine of BoA
+   \brief a very small 3d-engine used within BoA
+
+   For more information go to \see Scene
+*/
+
+
+
+
+
+/** 
+    \brief quad-tree based scene-manager
+    \ingroup Engine3d
+
+    Scene is scene-manager. it holds all the 3d-objects (meshes and particles).
+    These objects are stored in a QuadTree (could easily be exchanged for an octree, if needed).
+    It takes further for drawing modes like picking, shadow-rendering and depth-drawing (for shadow-depth-computation).
+    It contains a camera-object!
+    So in the current state it's not possible to render the same scene from to places at the same time.
+
+ */
+
+class Scene:public SceneBase
+{
+ public:
+  ////  typedef std::vector<PickNode> PickResult;
+  ////  typedef std::list<SceneNode*> NodeList;
+
+  Scene(int w,int h);
+  virtual ~Scene();
+
+  void draw();
+
+  // 0 == none, 1 == shadow mapping, 2 == perspective shadow mapping
+  void setShadow(int v);
+  int getShadow() const;
+
+
+  // ATTENTION: nodes are not owned by Scene afterwards - so they won't get deleted!
+  //            You have to do this yourself in the Entities or let ruby's GC do it for you (which would be the normal case)
+  /*  void addNode(SceneNode *node);
+  void removeNode(SceneNode *node);
+  void prepareUpdate(SceneNode *node);
+  void updatePos(SceneNode *node);
+  
+
+  void clear();
+
+  // (mx,my,0)
+  void setCamera(AGVector4 v);
+  AGVector4 getCamera() const;*/
+  virtual void advance(float time);
+  
+  /**
+     picking is currently done with opengl. this uses software (at least on my box), which is
+     pretty slow. Some new implementation using BSPs would be cool!
+     VertexArray or MeshData should contain it's data in such a tree. rays can be transformed using
+     inverse transformation-matrices. This way data can stay as is.
+  */
+  
+  PickResult pick(float x,float y,float w,float h);
+  /*
+  AntCamera &getCameraObject();
+*/
+  size_t getDrawnMeshes() const;
+
+  size_t getTriangles() const;
+  size_t getPickTriangles() const;
+
+
+  /**
+     get 2d-Position on screen for a 3dim vector in 3-space
+   */
+  AGVector2 getPosition(const AGVector4 &v) const;
+
+  /// get camera-viewing-direction to some 3d-point - used for particles
+  AGVector3 getCameraDirTo(const AGVector3 &p) const;
+
+  /*
+  /// width and height of screen
+  float width() const;
+  float height() const;
+
+  void mark();
+  */
+  AGMatrix4 getLightComplete() const;
+  AGMatrix4 getLightView() const;
+  AGMatrix4 getLightProj() const;
+
+  /*
+  AGVector2 getPosition(const AGVector4 &v) const;
+  */
+  NodeList getCurrentNodes();
+
+
+  void setEnabled(bool p);
+
+ private:
+  void calcShadowMap();
+  void drawScene();
+  void drawShadow();
+  void initScene();
+
+  void pickDraw();
+  PickResult processHits (int hits, GLuint *buffer,float x,float y);
+
+  Viewport getViewport() const;
+
+  int mShadow;
+
+  AGMatrix4 cameraPickMatrix;
+  /*
+  typedef std::vector<SceneNode*> Nodes;
+  typedef std::set<SceneNode*> NodeSet;
+
+  typedef QuadTree<SceneNode> Tree;
+
+  Tree *mTree;
+
+  AntCamera mCamera;
+
+  Nodes mNodes;
+  NodeSet mNodeSet;
+  */
+  AGVector4 white,black;
+
+  size_t mTriangles;
+  size_t mPickTriangles;
+  size_t mMeshes;
+
+  // picking vars
+  std::map<GLuint,SceneNode*> pickNames;
+
+  bool mEnabled;
+
+  friend class AntImpostorData;
+};
+
+
+#endif

Added: antargis/branches/rant/ext/3dengine/scene_2d.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/scene_2d.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scene_2d.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,122 @@
+#ifndef NO
+
+#include "scene_2d.h"
+#include "mesh_2d.h"
+#include "mesh_sort.h"
+#include <ag_debug.h>
+
+Scene2D::Scene2D(int w,int h):
+  SceneBase(w,h),mPainter(0)
+{
+}
+
+Scene2D::~Scene2D()
+{
+}
+
+void Scene2D::draw()
+{
+  // FIXME
+  
+  NodeList nodeList=getCurrentNodes();
+  Nodes ns;
+  std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
+
+
+  sort(ns.begin(),ns.end(),SortYCoord());
+
+  //FIXME:sort!!
+
+  for(Nodes::iterator i=ns.begin();i!=ns.end();i++)
+    (*i)->draw();
+}
+
+SceneBase::PickResult Scene2D::pick(float x,float y,float w,float h)
+{
+  PickResult result;
+  NodeList nodeList=getCurrentNodes();
+
+  Nodes ns;
+  std::copy(nodeList.begin(),nodeList.end(),std::back_inserter(ns));
+  sort(ns.begin(),ns.end(),SortOrder());
+
+  for(Nodes::reverse_iterator i=ns.rbegin();i!=ns.rend();i++)
+    {
+      Mesh2D*m=dynamic_cast<Mesh2D*>(*i);
+      if(m)
+	{
+	  if(m->hit(AGVector2(x,y)))
+	    {
+	      PickNode node;
+	      node.pos=m->getPos();
+	      node.node=m;
+	      node.camDist=0;
+
+	      cdebug("hit:"<<node.pos<<"   "<<node.node);
+	      result.push_back(node);
+	    }
+	}
+    }
+  
+
+  return result;
+}
+
+AGVector2 Scene2D::getPosition(const AGVector4 &v) const
+{
+  // FIXME: include camera !!
+  AGVector2 center(width()/2,height()/2);
+  AGVector2 cam(mCamera.getPosition().dim2());
+
+  AGVector2 n=v.dim2()-cam;
+
+  //  cdebug("n:"<<n);
+
+  //  cdebug("n:"<<n);
+  n*=32;
+  //  cdebug("n:"<<n);
+
+  n+=center;
+
+
+  return AGVector2(n[0],height()-n[1]);
+
+  throw std::runtime_error("FIXME");
+  return v.dim2();
+}
+
+SceneBase::NodeList Scene2D::getCurrentNodes()
+{
+  //  cdebug("FIXME");
+
+  NodeList l;
+  std::copy(mNodes.begin(),mNodes.end(),std::back_inserter(l));
+
+  //  throw std::runtime_error("FIXME");
+  return l;
+}
+
+//void setEnabled(bool p);
+
+void Scene2D::setPainter(AGPainter *p)
+{
+  CTRACE;
+  assert(mPainter==0);
+  mPainter=p;
+}
+void Scene2D::discardPainter()
+{
+  CTRACE;
+  assert(mPainter!=0);
+  mPainter=0;
+}
+
+AGPainter *Scene2D::getPainter()
+{
+  CTRACE;
+  assert(mPainter);
+  return mPainter;
+}
+
+
+#endif

Added: antargis/branches/rant/ext/3dengine/scene_2d.h
===================================================================
--- antargis/branches/rant/ext/3dengine/scene_2d.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scene_2d.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,47 @@
+#ifndef SCENE_2D_H
+#define SCENE_2D_H
+
+#include "scene_base.h"
+
+class AGPainter;
+
+class Scene2D:public SceneBase
+{
+ public:
+  typedef std::vector<PickNode> PickResult;
+  typedef std::list<SceneNode*> NodeList;
+
+  Scene2D(int w,int h);
+  virtual ~Scene2D();
+
+  void draw();
+
+  /**
+     picking is currently done with opengl. this uses software (at least on my box), which is
+     pretty slow. Some new implementation using BSPs would be cool!
+     VertexArray or MeshData should contain it's data in such a tree. rays can be transformed using
+     inverse transformation-matrices. This way data can stay as is.
+  */
+  PickResult pick(float x,float y,float w,float h);
+
+  //  AntCamera &getCameraObject();
+
+  AGVector2 getPosition(const AGVector4 &v) const;
+
+  NodeList getCurrentNodes();
+
+  void setEnabled(bool p);
+
+  void setPainter(AGPainter *p);
+  void discardPainter();
+
+  AGPainter *getPainter();
+ private:
+  AGPainter *mPainter;
+  
+  
+  
+
+};
+
+#endif

Added: antargis/branches/rant/ext/3dengine/scene_base.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/scene_base.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scene_base.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,143 @@
+#include "ag_profiler.h"
+
+#include "quadtree.h"
+
+#include "scene_base.h"
+
+SceneBase::SceneBase(int w,int h):
+  mTree(new QuadTree<SceneNode>(AGRect2(AGVector2(),AGVector2(w,h)))),
+  mCamera(w,h)
+{
+}
+
+
+SceneBase::~SceneBase()
+{
+  // tell nodes, that I'm no longer there :-)
+  for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
+    (*i)->resetScene(); 
+
+  delete mTree;
+}
+
+
+
+
+
+void SceneBase::addNode(SceneNode *node)
+{
+  if(mNodeSet.find(node)==mNodeSet.end())
+    {
+      node->setScene(this);
+
+      mNodes.push_back(node);
+      mNodeSet.insert(node);
+      assert(node->getScene()==this);
+      mTree->insert(node);
+    }
+}
+
+
+
+void SceneBase::updatePos(SceneNode *node)
+{
+  if(mNodeSet.find(node)==mNodeSet.end())
+    throw std::string("Dont know about this!");
+  mTree->insert(node);
+}
+
+void SceneBase::prepareUpdate(SceneNode *node)
+{
+  if(mNodeSet.find(node)==mNodeSet.end())
+    throw std::string("Dont know about this!");
+  mTree->remove(node);
+}
+
+
+void SceneBase::removeNode(SceneNode *node)
+{
+  if(mNodeSet.find(node)!=mNodeSet.end())
+    {
+      Nodes::iterator i=std::find(mNodes.begin(),mNodes.end(),node);
+      mNodes.erase(i);
+      mNodeSet.erase(node);
+      assert(node->getScene()==this);
+      node->resetScene();
+      assert(mTree->remove(node));
+    }
+  else
+    {
+      throw std::runtime_error("Trying to remove unknown node");
+    }
+}
+
+void SceneBase::clear()
+{
+  for(std::vector<SceneNode*>::iterator i=mNodes.begin();i!=mNodes.end();i++)
+    {
+      assert((*i)->getScene()==this);
+      (*i)->resetScene();
+    }
+  TRACE;
+  mNodes.clear();
+  mNodeSet.clear();
+  mTree->clear();
+}
+
+  // (mx,my,0)
+void SceneBase::setCamera(AGVector4 v)
+{
+  mCamera.setPosition(v.dim3());
+}
+
+void SceneBase::advance(float time)
+{
+  STACKTRACE; 
+
+  //  if(!mEnabled)
+  //    return;
+  // advance only in view
+
+  NodeList l=getCurrentNodes();
+
+  for(NodeList::iterator i=l.begin();i!=l.end();i++)
+    {
+      if((*i)->visible())
+	(*i)->advance(time);
+    }
+}
+
+float SceneBase::width() const
+{
+  return mCamera.getWidth();
+}
+float SceneBase::height() const
+{
+  return mCamera.getHeight();
+}
+
+void SceneBase::mark()
+{
+  SceneBase::Nodes::iterator i=mNodes.begin();
+
+  for(;i!=mNodes.end();i++)
+    {
+      markObject(*i);
+    }
+}
+
+AGVector4 SceneBase::getCamera() const
+{
+  return AGVector4(mCamera.getPosition(),1);
+}
+
+AntCamera &SceneBase::getCameraObject()
+{
+  return mCamera;
+}
+
+SceneBase::NodeList SceneBase::getCurrentNodes()
+{
+  throw std::runtime_error("not implemented!");
+  return NodeList();
+}

Added: antargis/branches/rant/ext/3dengine/scene_base.h
===================================================================
--- antargis/branches/rant/ext/3dengine/scene_base.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scene_base.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,95 @@
+#ifndef SCENE_BASE_H
+#define SCENE_BASE_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include "ant_camera.h"
+#include "scenenode.h"
+
+/**
+   some helper structure, which is used for storing
+   results when picking. it holds some information about:
+   * distance to camera (for sorting)
+   * the picked scene-node
+   * and the 3d-position, where the scene-node was touched
+   */
+struct PickNode
+{
+  AGVector4 pos;
+  SceneNode *node;
+  float camDist;
+  
+  bool operator<(const PickNode &n) const;
+};
+
+template<class T>
+class QuadTree;
+
+
+class SceneBase:public AGRubyObject
+{
+ public:
+  typedef std::vector<PickNode> PickResult;
+  typedef std::list<SceneNode*> NodeList;
+
+  SceneBase(int w,int h);
+  virtual ~SceneBase();
+
+//  void draw();
+
+  // ATTENTION: nodes are not owned by Scene afterwards - so they won't get deleted!
+  //            You have to do this yourself in the Entities or let ruby's GC do it for you (which would be the normal case)
+  void addNode(SceneNode *node);
+  void removeNode(SceneNode *node);
+  void prepareUpdate(SceneNode *node);
+  void updatePos(SceneNode *node);
+
+  void clear();
+
+  // (mx,my,0)
+  void setCamera(AGVector4 v);
+  AGVector4 getCamera() const;
+  virtual void advance(float time);
+
+  /**
+     picking is currently done with opengl. this uses software (at least on my box), which is
+     pretty slow. Some new implementation using BSPs would be cool!
+     VertexArray or MeshData should contain it's data in such a tree. rays can be transformed using
+     inverse transformation-matrices. This way data can stay as is.
+  */
+  //  virtual PickResult pick(float x,float y,float w,float h);
+
+  AntCamera &getCameraObject();
+
+//  size_t getDrawnMeshes() const;
+
+  /// width and height of screen
+  float width() const;
+  float height() const;
+
+  void mark();
+
+
+  /** get currently visible nodes */
+  virtual NodeList getCurrentNodes();
+
+  //  void setEnabled(bool p);
+
+ protected:
+
+  typedef std::vector<SceneNode*> Nodes;
+  typedef std::set<SceneNode*> NodeSet;
+
+  typedef QuadTree<SceneNode> Tree;
+
+  Tree *mTree;
+
+  AntCamera mCamera;
+
+  Nodes mNodes;
+  NodeSet mNodeSet;
+
+};
+
+
+#endif

Added: antargis/branches/rant/ext/3dengine/scenenode.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/scenenode.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scenenode.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,165 @@
+#include "scenenode.h"
+#include "scene.h"
+#include "ag_debug.h"
+
+SceneNode::SceneNode(SceneBase *s,const AGVector4 &pPos,const AGBox3 &b):
+  mPos(pPos),mBBox(b)
+{
+  assert(s);
+  mRubyObject=false;
+  mScene=s;
+  mVisible=true;
+  mOrder=1;
+
+  if(mScene)
+    mScene->addNode(this);
+}
+
+SceneNode::~SceneNode()
+{
+  //  CTRACE;
+  //mRubyObject=false; // why was this here ??????
+
+  // typical calling is:
+  // scenenode is saveDeleted by AntEntity - so mScene should be 0
+
+  //  assert(mScene==0); // but not at program end - this is the reason this is commented
+  if(mScene)
+    mScene->removeNode(this);
+}
+
+void SceneNode::setScene(SceneBase *pScene)
+{
+  assert(mScene==0 || mScene==pScene);
+  mScene=pScene;
+}
+
+
+/// release attaching to scene
+void SceneNode::resetScene()
+{
+  mScene=0;
+}
+
+/// this function is deprecated. It was once used for drawing 
+/// shadow in a 3rd render-pass.
+void SceneNode::drawShadow()
+{
+}
+
+/// This functions is used in the 1st depth-drawing render-pass,
+/// so you should not use colors or textures, when not needed
+void SceneNode::drawDepth()
+{
+}
+void SceneNode::draw()
+{
+}
+
+/// this function is used for picking objects.
+/// Picking is done one CPU, so shader-animated models are
+/// out of place here.
+void SceneNode::drawPick()
+{
+}
+void SceneNode::advance(float time)
+{
+}
+size_t SceneNode::getTriangles() const
+{
+  return 0;
+}
+AGVector4 SceneNode::lineHit(const AGLine3 &pLine) const
+{
+  AGVector4 mfalse(0,0,0,0);
+  return mfalse;
+}
+
+void SceneNode::sort(const AGVector4 &pCamera)
+{
+}
+
+bool SceneNode::operator==(const SceneNode &n) const
+{
+  return this==&n;
+}
+
+void SceneNode::setPos(const AGVector3&pPos)
+{
+  getScene()->prepareUpdate(this);
+  mPos=AGVector4(pPos,1);
+  getScene()->updatePos(this);
+}
+
+void SceneNode::setRotation(float r)
+{
+}
+
+
+bool SceneNode::transparent()
+{
+  return false;
+}
+
+AGBox3 SceneNode::bbox() const
+{
+  return mBBox+getPos().dim3();
+}
+
+AGRect2 SceneNode::getRect() const
+{
+  AGBox3 b=bbox();
+  return AGRect2(AGVector2(b.base[0],b.base[1]),AGVector2(b.base[0]+b.dir[0],b.base[1]+b.dir[1]));
+}
+
+
+SceneBase *SceneNode::getScene()
+{
+  if(!mScene)
+    throw std::runtime_error("scene==0");
+  return mScene;
+}
+
+bool SceneNode::sceneValid() const
+{
+  return mScene;
+}
+
+
+void SceneNode::clear()
+{
+  //  cdebug(typeid(*this).name());
+  if(mScene)
+    mScene->removeNode(this);
+  resetScene();
+}
+
+void SceneNode::setVisible(bool v)
+{
+  mVisible=v;
+}
+bool SceneNode::visible() const
+{
+  return mVisible;
+}
+
+void SceneNode::setOrder(int o)
+{
+  mOrder=o;
+}
+int SceneNode::getOrder() const
+{
+  return mOrder;
+}
+
+AGVector4 SceneNode::getPos() const
+{
+  return mPos;
+}
+
+void SceneNode::setBBox(const AGBox3 &pBox)
+{
+  getScene()->prepareUpdate(this);
+  mBBox=pBox;
+  getScene()->updatePos(this);
+}

Added: antargis/branches/rant/ext/3dengine/scenenode.h
===================================================================
--- antargis/branches/rant/ext/3dengine/scenenode.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/scenenode.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,99 @@
+#ifndef _SCENE_NODE_H
+#define _SCENE_NODE_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include <ag_geometry.h>
+#include <ag_rubyobj.h>
+
+class SceneBase;
+
+/// these are the drawing orders, by which Scene::drawScene orders all the meshes
+/// 1 will be drawn first and so forth
+
+#define TERRAIN_Z 1
+#define WATER_Z 2
+#define DECAL_Z 3
+#define RING_Z 4
+#define MESH_Z 5
+#define TREE_Z 6
+#define PARTICLE_Z 7
+
+/**
+   A scenenode represents any part of a scene. It holds information
+   about position, drawing order, bounding box and visibility.
+   A scenenode is created for exactly one scene and it can't be
+   assigned to any other scene, which shouldn't be necessary.
+
+   Scene and SceneNode give each other information about their 
+   "destroy-state". That means the destructor notifies the other object.
+
+*/
+class SceneNode:public AGRubyObject
+{
+ public:
+  SceneNode(SceneBase *s,const AGVector4 &pPos,const AGBox3 &pBox);
+  virtual ~SceneNode();
+
+  /// reset my scene pointer - should not be called in "normal" code - only by the Scene-object
+  virtual void resetScene();
+  virtual void drawShadow();
+  virtual void drawDepth();
+  virtual void draw();
+  virtual void drawPick();
+
+  /// advance mesh - e.g. animation
+  virtual void advance(float time);
+
+  virtual size_t getTriangles() const;
+  virtual AGVector4 lineHit(const AGLine3 &pLine) const;
+
+  /// sort triangles for given camera-view - shouldn't be used often!!!
+  virtual void sort(const AGVector4 &pCamera);
+
+  /// references equal??
+  bool operator==(const SceneNode &n) const;
+
+  virtual void setPos(const AGVector3&pPos);
+  AGVector4 getPos() const;
+  virtual void setRotation(float r);
+  void setBBox(const AGBox3 &pBox);
+
+  /// indicates, if this object is transparent. if that's the case, it will be drawn later.
+  /// drawing goes like this:1)draw all opaque objects from front to back; 2)draw transparent from back to front
+  /// this is the fastest way to do this
+  virtual bool transparent();
+
+  /// get bounding box
+  AGBox3 bbox() const;
+  AGRect2 getRect() const;
+
+  virtual void clear();
+
+  SceneBase *getScene();
+  /// this checks, if the current object is inserted into a scene
+  bool sceneValid() const;
+
+  void setVisible(bool v);
+  bool visible() const;
+
+  /// there is a drawing order, used by the scene-manager, which priorized. look at Scene::drawScene for more info.
+  void setOrder(int o);
+  int getOrder() const;
+  
+ private:
+  void setScene(SceneBase *pScene);
+
+  int mOrder;
+
+  SceneBase *mScene;
+  bool mVisible;
+
+  AGVector4 mPos;
+  AGBox3 mBBox;
+
+  friend class SceneBase;
+};
+
+typedef SceneNode *SceneNodePtr;
+#endif

Added: antargis/branches/rant/ext/3dengine/templates.i
===================================================================
--- antargis/branches/rant/ext/3dengine/templates.i	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/templates.i	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,4 @@
+%template(SceneNodeVector) std::vector<SceneNodePtr>;
+%template(PickResult) std::vector<PickNode>;
+%template(AGPairVec2Surface) std::pair<AGVector2,AGSurface*>;
+%template(SceneNodeList) std::list<SceneNode*>;
\ No newline at end of file

Added: antargis/branches/rant/ext/3dengine/vertex_array.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/vertex_array.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/vertex_array.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,705 @@
+#include "vertex_array.h"
+#include <SDL_opengl.h>
+#include <assert.h>
+#include <ag_vdebug.h>
+#include <ag_profiler.h>
+#include <ag_config.h>
+#include <ag_main.h>
+
+static bool useVBO()
+{
+  AGString s=getConfig()->get("useVBO");
+  //cdebug("useVBO:"<<s);
+  if(s!="true" && s!="false")
+    {
+      cdebug("useVBO:"<<s);
+      s="true";
+      getConfig()->set("useVBO",s);
+    }
+  return s=="true";
+}
+
+static bool useVertexArrays()
+{
+  AGString s=getConfig()->get("useVertexArrays");
+  if(s!="true" && s!="false")
+    {
+      s="true";
+      getConfig()->set("useVertexArrays",s);
+    }
+  return s=="true";
+}
+
+
+VertexArray::VertexArray(bool pDynamic):mDynamic(pDynamic),bbox(AGVector3(),AGVector3())
+{
+  bColor=true;
+  mBuffers=GLEE_ARB_vertex_buffer_object && useVBO();
+  mArrays=GLEE_EXT_vertex_array && useVertexArrays();
+
+  if(videoInited())
+    assert(GLEE_EXT_vertex_array);
+
+  displayListInited=false;
+
+  mChanged=false;
+
+  mVertexBuffer=0;
+  mColorBuffer=0;
+  mNormalBuffer=0;
+  mTexBuffer=0;
+  mIndexBuffer=0;
+  mTextures3D=false;
+}
+
+VertexArray::~VertexArray()
+{
+  //  CTRACE;
+  if(mBuffers && mVertexBuffer!=0) //mChanged==false)
+    {
+      glDeleteBuffersARB( 1, &mVertexBuffer );
+      glDeleteBuffersARB( 1, &mColorBuffer );
+      glDeleteBuffersARB( 1, &mNormalBuffer );
+      glDeleteBuffersARB( 1, &mTexBuffer );
+      if(!mDynamic)
+	glDeleteBuffersARB( 1, &mIndexBuffer );
+    }
+}
+
+
+void VertexArray::addVertex(AGVector4 pVertex, AGVector4 pColor, AGVector3 pNormal, AGVector2 pTex)
+{
+  mVertices.push_back(pVertex);
+  mColors.push_back(pColor);
+  mNormals.push_back(pNormal);
+  mTexCoords.push_back(pTex);
+  mChanged=true;
+  if(mVertices.size()==1)
+    bbox=AGBox3(pVertex.dim3(),AGVector3(0,0,0));
+  else
+    bbox.include(pVertex.dim3());
+}
+
+void VertexArray::addVertex(AGVector4 pVertex, AGVector4 pColor, AGVector3 pNormal, AGVector3 pTex)
+{
+  assert(mTextures3D || mVertices.size()==0);
+  mTextures3D=true;
+  mVertices.push_back(pVertex);
+  mColors.push_back(pColor);
+  mNormals.push_back(pNormal);
+  mTexCoords3D.push_back(pTex);
+  mChanged=true;
+  if(mVertices.size()==1)
+    bbox=AGBox3(pVertex.dim3(),AGVector3(0,0,0));
+  else
+    bbox.include(pVertex.dim3());
+}
+
+void VertexArray::addTriangle(size_t p0,size_t p1,size_t p2)
+{
+  assert(p0<mVertices.size());
+  assert(p1<mVertices.size());
+  assert(p2<mVertices.size());
+  mIndices.push_back(p0);
+  mIndices.push_back(p1);
+  mIndices.push_back(p2);
+  mChanged=true;
+}
+
+void VertexArray::init()
+{
+  if(mBuffers)
+    {
+      STACKTRACE;
+      glGenBuffersARB( 1, &mVertexBuffer );
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer );
+      glBufferDataARB( GL_ARRAY_BUFFER_ARB, mVertices.size()*sizeof(AGVector4), &(mVertices[0]), GL_STATIC_DRAW_ARB );
+      
+      glGenBuffersARB( 1, &mColorBuffer );
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mColorBuffer );
+      glBufferDataARB( GL_ARRAY_BUFFER_ARB, mColors.size()*sizeof(AGVector4), &(mColors[0]), GL_STATIC_DRAW_ARB );
+      
+      glGenBuffersARB( 1, &mNormalBuffer );
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mNormalBuffer );
+      glBufferDataARB( GL_ARRAY_BUFFER_ARB, mNormals.size()*sizeof(AGVector3), &(mNormals[0]), GL_STATIC_DRAW_ARB );
+      
+      glGenBuffersARB( 1, &mTexBuffer );
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer );
+      if(mTextures3D)
+	glBufferDataARB( GL_ARRAY_BUFFER_ARB, mTexCoords3D.size()*sizeof(AGVector3), &(mTexCoords3D[0]), GL_STATIC_DRAW_ARB );
+      else
+	glBufferDataARB( GL_ARRAY_BUFFER_ARB, mTexCoords.size()*sizeof(AGVector2), &(mTexCoords[0]), GL_STATIC_DRAW_ARB );
+
+      if(!mDynamic)
+	{
+	  glGenBuffersARB( 1, &mIndexBuffer );
+	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer );
+	  glBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndices.size()*sizeof(Uint16), &(mIndices[0]), GL_STATIC_DRAW_ARB );
+	}
+
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, 0);
+      glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
+
+
+    }
+  mChanged=false;
+}
+
+void VertexArray::setColors(bool color)
+{
+  bColor=color;
+}
+
+void VertexArray::draw()
+{
+  assertGL;
+  if(mChanged)
+    init();
+
+  assertGL;
+
+  if(mBuffers||mArrays)
+    {
+      glEnableClientState(GL_VERTEX_ARRAY);
+      glEnableClientState(GL_NORMAL_ARRAY);
+      if(bColor)
+	glEnableClientState(GL_COLOR_ARRAY);
+      else
+	glDisableClientState(GL_COLOR_ARRAY);
+      glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+    }
+
+  if(mBuffers)
+    {
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mNormalBuffer );
+      glNormalPointer(GL_FLOAT, 0, 0);
+
+      /*
+      glClientActiveTexture(GL_TEXTURE1);
+      glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer);
+      glTexCoordPointer(2, GL_FLOAT, 0, 0);
+      */
+      glClientActiveTexture(GL_TEXTURE0);
+
+      glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer);
+      if(mTextures3D)
+	glTexCoordPointer(3, GL_FLOAT, 0, 0);
+      else
+	glTexCoordPointer(2, GL_FLOAT, 0, 0);
+
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer);
+      glVertexPointer(4, GL_FLOAT, 0, 0);
+      if(bColor)
+	{
+	  glBindBufferARB( GL_ARRAY_BUFFER_ARB, mColorBuffer);
+	  glColorPointer(4, GL_FLOAT, 0, 0);
+	}
+
+      if(mDynamic)
+	{
+	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+			 &(mIndices[0]));
+	}
+      else
+	{
+	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer);
+	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,0);
+	}
+    }
+  else if(mArrays)
+    {
+      //      cdebug("too much work");
+      glNormalPointer(GL_FLOAT, 0, &(mNormals[0]));
+      glClientActiveTexture(GL_TEXTURE0);
+      if(mTextures3D)
+	glTexCoordPointer(3, GL_FLOAT, 0, &(mTexCoords3D[0]));
+      else
+	glTexCoordPointer(2, GL_FLOAT, 0, &(mTexCoords[0]));
+      glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
+      if(bColor)
+	glColorPointer(4, GL_FLOAT, 0, &(mColors[0]));
+      glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+		     &(mIndices[0]));
+  }
+  else
+    {
+      glClientActiveTexture(GL_TEXTURE0);
+      glBegin(GL_TRIANGLES);
+      for(std::vector<Uint16>::iterator i=mIndices.begin();i!=mIndices.end();i++)
+	{
+	  glNormal3fv(mNormals[*i]);
+	  if(mTextures3D)
+	    glTexCoord3fv(mTexCoords3D[*i]);
+	  else
+	    glTexCoord2fv(mTexCoords[*i]);
+	  if(bColor)
+	    glColor4fv(mColors[*i]);
+	  glVertex4fv(mVertices[*i]);
+	}
+      glEnd();
+      
+    }
+
+  if(mBuffers||mArrays)
+    {
+      glDisableClientState(GL_VERTEX_ARRAY);
+      glDisableClientState(GL_NORMAL_ARRAY);
+      glDisableClientState(GL_COLOR_ARRAY);
+      glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+    }
+  assertGL;
+
+}
+
+void VertexArray::drawPick()
+{
+  STACKTRACE;
+  if(false)
+    {
+      // use vertex arrays
+      glEnableClientState(GL_VERTEX_ARRAY);
+
+      glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
+      glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+		     &(mIndices[0]));
+      
+      glDisableClientState(GL_VERTEX_ARRAY);
+
+    }
+
+  else if(true)
+    {
+      if(displayListInited)
+	{
+	  STACKTRACE;
+	  
+	  glCallList(displayList);
+	}
+      else
+	{
+	  displayList=glGenLists(1);
+	  glNewList(displayList,GL_COMPILE);
+	  {
+	    // paint in software - because this is faster for picking
+	    glBegin(GL_TRIANGLES);
+	    for(std::vector<Uint16>::iterator i=mIndices.begin();i!=mIndices.end();i++)
+	      glVertex4fv(mVertices[*i]);
+	    glEnd();
+	  }
+	  glEndList();
+	  glCallList(displayList);
+
+	  displayListInited=true;
+	}
+    }
+  else
+    {
+      // FIXME: some this doesn't - what the heck!
+      if(mChanged)
+	init();
+      
+      
+      glEnableClientState(GL_VERTEX_ARRAY);
+      
+      
+      // disable textures
+      glClientActiveTexture(GL_TEXTURE1);
+      glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+      glClientActiveTexture(GL_TEXTURE0);
+      
+      glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+      
+      {
+	cdebug(mVertices.size());
+	cdebug(mIndices.size());
+	glBindBufferARB( GL_ARRAY_BUFFER_ARB,0);
+	glNormalPointer(GL_FLOAT,0,0);
+	glBindBufferARB( GL_ARRAY_BUFFER_ARB,0);
+	glTexCoordPointer(2,GL_FLOAT,0,0);
+	glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
+	glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+		       &(mIndices[0]));
+      }
+      
+      glDisableClientState(GL_VERTEX_ARRAY);
+    }
+}
+
+
+
+void VertexArray::drawDepth()
+{
+#ifdef OLD
+  if(mChanged)
+    init();
+
+  glEnableClientState(GL_VERTEX_ARRAY);
+
+
+  //  glDisable(GL_TEXTURE_2D);
+
+  if(mBuffers)
+    {
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer);
+      glVertexPointer(4, GL_FLOAT, 0, 0);
+
+      if(mDynamic)
+	{
+	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+			 &(mIndices[0]));
+	}
+      else
+	{
+	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer);
+	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,0);
+	}
+
+    }
+  else
+    {
+      //      cdebug("too much work");
+      glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
+
+      glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+		     &(mIndices[0]));
+  }
+
+  //  glEnable(GL_TEXTURE_2D);
+
+  glDisableClientState(GL_VERTEX_ARRAY);
+#else
+  if(mChanged)
+    init();
+
+  glEnableClientState(GL_VERTEX_ARRAY);
+
+  glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+
+
+  if(mBuffers)
+    {
+      glClientActiveTexture(GL_TEXTURE0);
+
+      glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mTexBuffer);
+      if(mTextures3D)
+	glTexCoordPointer(3, GL_FLOAT, 0, 0);
+      else
+	glTexCoordPointer(2, GL_FLOAT, 0, 0);
+
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, mVertexBuffer);
+      glVertexPointer(4, GL_FLOAT, 0, 0);
+
+      if(mDynamic)
+	{
+	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+			 &(mIndices[0]));
+	}
+      else
+	{
+	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, mIndexBuffer);
+	  glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,0);
+	}
+
+    }
+  else
+    {
+      if(mTextures3D)
+	glTexCoordPointer(3, GL_FLOAT, 0, &(mTexCoords3D[0]));
+      else
+	glTexCoordPointer(2, GL_FLOAT, 0, &(mTexCoords[0]));
+      glVertexPointer(4, GL_FLOAT, 0, &(mVertices[0]));
+
+      glDrawElements(GL_TRIANGLES, mIndices.size(), GL_UNSIGNED_SHORT,
+		     &(mIndices[0]));
+  }
+
+  glDisableClientState(GL_VERTEX_ARRAY);
+  glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+#endif
+}
+
+
+
+AGVector4 VertexArray::lineHit(const AGLine3 &pLine) const
+{
+  AGVector4 mfalse(0,0,0,0);
+  //  cdebug("box:"<<bbox.toString());
+  if(!bbox.collides(pLine))
+    return mfalse;
+
+  for(size_t i=0;i<mIndices.size();i+=3)
+    {
+      AGVector4 v0=mVertices[mIndices[i]];
+      AGVector4 v1=mVertices[mIndices[i+1]];
+      AGVector4 v2=mVertices[mIndices[i+2]];
+
+      AGTriangle3 t(v0.dim3(),v1.dim3(),v2.dim3());
+      AGVector4 r;
+      r=t.collide(pLine);
+      if(r[3]==1)
+	{
+	  return r;
+	}
+    }
+  return mfalse;
+}
+
+void VertexArray::update()
+{
+  if(mBuffers && mVertexBuffer!=0) //mChanged==false)
+    {
+      glDeleteBuffersARB( 1, &mVertexBuffer );
+      glDeleteBuffersARB( 1, &mColorBuffer );
+      glDeleteBuffersARB( 1, &mNormalBuffer );
+      glDeleteBuffersARB( 1, &mTexBuffer );
+      glDeleteBuffersARB( 1, &mIndexBuffer );
+      mVertexBuffer=0;
+    }
+  mChanged=true;
+}
+void VertexArray::clear()
+{
+  /*  if(mBuffers && mVertexBuffer!=0) //mChanged==false)
+    {
+      glDeleteBuffersARB( 1, &mVertexBuffer );
+      glDeleteBuffersARB( 1, &mColorBuffer );
+      glDeleteBuffersARB( 1, &mNormalBuffer );
+      glDeleteBuffersARB( 1, &mTexBuffer );
+      glDeleteBuffersARB( 1, &mIndexBuffer );
+      }*/
+  mVertices.clear();
+  mColors.clear();
+  mNormals.clear();
+  mTexCoords.clear();
+  mTexCoords3D.clear();
+  mIndices.clear();
+  update();
+}
+
+void VertexArray::setBuffers(bool pBuffers)
+{
+  mBuffers=false;
+}
+
+
+size_t VertexArray::getIndex(size_t i)
+{
+  return mIndices[i];
+}
+AGVector4 VertexArray::getVertex(size_t i)
+{
+  return mVertices[i];
+}
+AGVector4 VertexArray::getColor(size_t i)
+{
+  return mColors[i];
+}
+AGVector3 VertexArray::getNormal(size_t i)
+{
+  return mNormals[i];
+}
+  AGVector2 VertexArray::getTexCoord(size_t i)
+{
+  return mTexCoords[i];
+}
+
+void VertexArray::setTexCoord(size_t i,const AGVector2 &t)
+{
+  mTexCoords[i]=t;
+  update();
+}
+
+bool VertexArray::useVertexArrays() const
+{
+  return mArrays;
+}
+
+
+void VertexArray::onScreenUp()
+{
+    init();
+}
+
+void VertexArray::onScreenDown()
+{
+  if(mBuffers && mVertexBuffer!=0) //mChanged==false)
+    {
+      glDeleteBuffersARB( 1, &mVertexBuffer );
+      glDeleteBuffersARB( 1, &mColorBuffer );
+      glDeleteBuffersARB( 1, &mNormalBuffer );
+      glDeleteBuffersARB( 1, &mTexBuffer );
+      if(!mDynamic)
+	glDeleteBuffersARB( 1, &mIndexBuffer );
+    }
+  mVertexBuffer=mColorBuffer=mNormalBuffer=mTexBuffer=mIndexBuffer=0;
+}
+
+
+
+
+////////////////////////////////////////////////////////////////////
+// VertexArrayShader
+////////////////////////////////////////////////////////////////////
+
+
+
+VertexArrayShader::VertexArrayShader(AntShaderProgram *_p):p(_p)
+{
+  aInited=false;
+}
+VertexArrayShader::~VertexArrayShader()
+{
+  for(std::map<std::string,std::vector<float>*>::iterator i=as.begin();i!=as.end();++i)
+    {
+      if(i->second)
+	delete i->second;
+    }
+
+  for(std::map<std::string,std::vector<Uint16>*>::iterator i=elementAs.begin();i!=elementAs.end();++i)
+    {
+      if(i->second)
+	delete i->second;
+    }
+
+}
+
+void VertexArrayShader::addAttribute(const std::string &pName,const std::vector<float> &a)
+{
+  as[pName]=new std::vector<float>(a);
+  aInited=false;
+}
+
+void VertexArrayShader::addAttribute(const std::string &pName,const std::vector<Uint16> &a)
+{
+  elementAs[pName]=new std::vector<Uint16>(a);
+  aInited=false;
+}
+
+
+void VertexArrayShader::draw()
+{
+  assertGL;
+  p->enable();
+  assertGL;
+  if(!aInited)
+    aInit();
+  assertGL;
+  attach();
+  assertGL;
+  VertexArray::draw();
+  p->disable();
+}
+
+void VertexArrayShader::attach()
+{
+  //  if(useVertexArrays())
+    {
+      for(std::map<std::string,unsigned int>::iterator i=aids.begin();i!=aids.end();i++)
+	{
+	  GLint loc=p->getAttr(i->first);
+	  glEnableClientState(GL_VERTEX_ARRAY);
+	  glEnableVertexAttribArrayARB(loc); // add array
+	  glBindBufferARB( GL_ARRAY_BUFFER_ARB, i->second);
+	  glVertexAttribPointerARB(loc,1,GL_FLOAT,0,0,0);
+	  //      glTexCoordPointer(2, GL_FLOAT, 0, 0);
+	}
+
+      for(std::map<std::string,unsigned int>::iterator i=elementIds.begin();i!=elementIds.end();i++)
+	{
+  assertGL;
+	  GLint loc=p->getAttr(i->first);
+  assertGL;
+	  glEnableClientState(GL_VERTEX_ARRAY);
+  assertGL;
+	  glEnableVertexAttribArrayARB(loc); // add array
+  assertGL;
+	  glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, i->second);
+  assertGL;
+	  glVertexAttribPointerARB(loc,1,GL_UNSIGNED_SHORT,0,0,0);
+  assertGL;
+	  //      glTexCoordPointer(2, GL_FLOAT, 0, 0);
+	}
+
+    }
+}
+
+void VertexArrayShader::aInit()
+{
+  for(std::map<std::string,std::vector<float>*>::iterator i=as.begin();i!=as.end();i++)
+    {
+      unsigned int id;
+
+      glGenBuffersARB( 1, &id);
+      glBindBufferARB( GL_ARRAY_BUFFER_ARB, id);
+      glBufferDataARB( GL_ARRAY_BUFFER_ARB, i->second->size()*sizeof(float), &((*i->second)[0]), GL_STATIC_DRAW_ARB );
+
+      aids[i->first]=id;
+    }
+
+  for(std::map<std::string,std::vector<Uint16>*>::iterator i=elementAs.begin();i!=elementAs.end();i++)
+    {
+      unsigned int id;
+
+      glGenBuffersARB( 1, &id);
+      glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, id);
+      glBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, i->second->size()*sizeof(Uint16), &((*i->second)[0]), GL_STATIC_DRAW_ARB );
+
+      elementIds[i->first]=id;
+    }
+
+
+  aInited=true;
+}
+
+
+VertexArray *makeInstances(const VertexArray &va,const std::vector<AGMatrix4> &ts)
+{
+  VertexArray *na=new VertexArray;
+  size_t start=0;
+  size_t ci;
+
+  for(std::vector<AGMatrix4>::const_iterator i=ts.begin();i!=ts.end();i++)
+    {
+      assert(va.mVertices.size()==va.mNormals.size());
+      // transform normals and vertices
+      for(size_t j=0;j<va.mVertices.size();j++)
+	{
+	  AGVector4 v=va.mVertices[j];
+	  AGVector3 n=va.mNormals[j];
+
+	  v=*i*v;
+	  n=(*i*AGVector4(n,0)).dim3();
+	  
+	  na->mVertices.push_back(v);
+	  na->mNormals.push_back(n);
+	}
+
+      std::copy(va.mColors.begin(),va.mColors.end(),std::back_inserter(na->mColors));
+      std::copy(va.mTexCoords.begin(),va.mTexCoords.end(),std::back_inserter(na->mTexCoords));
+      std::copy(va.mTexCoords3D.begin(),va.mTexCoords3D.end(),std::back_inserter(na->mTexCoords3D));
+      for(std::vector<Uint16>::const_iterator j=va.mIndices.begin();j!=va.mIndices.end();j++)
+	{
+	  ci=*j+start;
+	  assert(ci>=start);
+	  assert(ci<na->mVertices.size());
+	  assert(ci<na->mColors.size());
+	  assert(ci<na->mNormals.size());
+	    
+	  na->mIndices.push_back(*j+start);
+	}
+      start+=va.mVertices.size();
+    }
+
+  na->bColor=va.bColor;
+  na->mChanged=true;
+
+  // calc bbox
+  na->bbox=AGBox3(AGVector3(),AGVector3());
+
+  
+
+  return na;
+}

Added: antargis/branches/rant/ext/3dengine/vertex_array.h
===================================================================
--- antargis/branches/rant/ext/3dengine/vertex_array.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/3dengine/vertex_array.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,127 @@
+#ifndef __vertex_array_h
+#define __vertex_array_h
+
+#include "scene.h"
+#include "glsl.h"
+#include <ag_geometry.h>
+#include <vector>
+#define GL_GLEXT_PROTOTYPES
+#include <SDL_opengl.h>
+
+#include <ag_surface.h>
+
+/**
+   VertexArray is for fast drawing meshes (3d-models).
+   It supports indexed vertex-arrays. If you do not have them in this format
+   look at mesh_optimizer.h.
+   The possible drawing modes are detected automatically. The best one is always used.
+   These include:
+   * vertex-arrays
+   * vertex-buffers
+   * direct drawing mode (glVertex4f...)
+
+   if you have to do special drawing like picking, use the corresp. functions (drawDepth,drawPick)
+*/
+
+class VertexArray:public AGGLObject
+{
+  std::vector<AGVector4> mVertices,mColors;
+  std::vector<AGVector3> mNormals;
+  std::vector<AGVector2> mTexCoords;
+  std::vector<AGVector3> mTexCoords3D;
+  std::vector<Uint16>  mIndices;
+
+  bool bColor;
+  bool mBuffers;
+  bool mArrays;
+  bool mChanged;
+  bool mTextures3D;
+
+  /// VA is dynamic, when index-buffer changes
+  bool mDynamic;
+
+  unsigned int mVertexBuffer,mColorBuffer,mNormalBuffer,mTexBuffer,mIndexBuffer;
+
+  AGBox3 bbox;
+
+  GLuint displayList;
+  bool displayListInited;
+
+ public:
+  VertexArray(bool pDynamic=false);
+  virtual ~VertexArray();
+  void addVertex(AGVector4 pVertex, AGVector4 pColor, AGVector3 pNormal, AGVector2 pTex);
+  void addVertex(AGVector4 pVertex, AGVector4 pColor, AGVector3 pNormal, AGVector3 pTex);
+  void addTriangle(size_t p0,size_t p1,size_t p2);
+
+  void setColors(bool color);
+  void setBuffers(bool pBuffers);
+  
+  virtual void draw();
+  virtual void drawDepth();
+  void drawPick();
+  void init();
+
+  void clear();
+  void update();
+
+  size_t getTriangles() const
+  {
+    return mIndices.size()/3;
+  }
+  
+  size_t getIndex(size_t i);
+  AGVector4 getVertex(size_t i);
+  AGVector4 getColor(size_t i);
+  AGVector3 getNormal(size_t i);
+  AGVector2 getTexCoord(size_t i);
+
+  void setTexCoord(size_t i,const AGVector2 &t);
+
+  AGVector4 lineHit(const AGLine3 &pLine) const;
+
+  bool useVertexArrays() const;
+  friend VertexArray *makeInstances(const VertexArray &va,const std::vector<AGMatrix4> &ts);
+
+  void onScreenUp();
+  void onScreenDown();
+
+};
+
+/**
+   makeInstances can be used for some kind of "batching".
+   It creates several instances of a mesh stored in va. The positions of the instances are 
+   given through transformation matrices in ts
+*/
+VertexArray *makeInstances(const VertexArray &va,const std::vector<AGMatrix4> &ts);
+
+/**
+   VertexArrayShader adds shader-support to vertex-arrays. You might need to attach data
+   to each vertex. You can do so by calling addAttribute(.,.).
+ */
+class VertexArrayShader:public VertexArray
+{
+  AntShaderProgram *p;
+  std::map<std::string,std::vector<float>*> as;
+  std::map<std::string,unsigned int> aids;
+
+  std::map<std::string,std::vector<Uint16>*> elementAs;
+  std::map<std::string,unsigned int> elementIds;
+
+  bool aInited;
+ public:
+  VertexArrayShader(AntShaderProgram *_p);
+  ~VertexArrayShader();
+  /// adds attributes to each vertex. the size of a should equal the vertex count
+  void addAttribute(const std::string &pName,const std::vector<float> &a);
+  void addAttribute(const std::string &pName,const std::vector<Uint16> &a);
+
+  virtual void draw();
+
+ private:
+  void aInit();
+  void attach();
+  
+};
+
+#endif

Modified: antargis/branches/rant/ext/basic/ag_main.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_main.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/basic/ag_main.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -52,11 +52,11 @@
 {
   return quited;
 }
-
+/*
 bool glMode()
 {
   return lastGL;
-}
+}*/
 
 
 /**

Added: antargis/branches/rant/ext/basic/ag_messageobject.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_messageobject.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/basic/ag_messageobject.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,677 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_messageobject.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_messageobject.h"
+#include "ag_debug.h"
+#include "ag_main.h"
+#include "ag_stringstream.h"
+#include "ag_video.h"
+
+SDL_Event AGEvent::NullEvent={SDL_NOEVENT};
+
+// AGEvent
+AGEvent::AGEvent(AGListener *pCaller,const AGString &pName,const SDL_Event &e):mCaller(pCaller),mName(pName),mEvent(e)
+{
+}
+AGEvent::~AGEvent()
+{
+}
+
+
+void AGEvent::setVector(const AGVector2 &v)
+{
+  mVector=v;
+}
+/// returns the drag-vector in case of a drag-event
+AGVector2 AGEvent::getVector() const
+{
+  return mVector;
+}
+
+
+/// sets the caller of this event - shouldn't be used outside of AGWidget
+void AGEvent::setCaller(AGListener *pCaller)
+{
+  mCaller=pCaller;
+}
+
+/// return the name of the event
+AGString AGEvent::getName() const
+{
+  return mName;
+}
+
+
+void AGEvent::setName(const AGString &n)
+{
+  mName=n;
+}
+
+bool AGEvent::isSDLEvent() const
+{
+  return eventOk(mEvent);
+}
+
+
+/// returns the caller of this event
+AGListener *AGEvent::getCaller() const
+{
+  return mCaller;
+}
+
+// AGSDLEvent
+
+const SDL_Event &AGEvent::get() const
+{
+  assert(eventOk(mEvent));
+  return mEvent;
+}
+
+AGVector2 AGEvent::getMousePosition() const
+{
+  assert(eventOk(mEvent));
+  AGVector2 p;
+  switch(mEvent.type) {
+  case SDL_MOUSEMOTION:
+    p[0]=mEvent.motion.x*getVideo()->width()/getVideo()->realWidth();
+    p[1]=mEvent.motion.y*getVideo()->height()/getVideo()->realHeight();
+    break;
+    
+  case SDL_MOUSEBUTTONUP:
+  case SDL_MOUSEBUTTONDOWN:
+    p[0]=mEvent.button.x*getVideo()->width()/getVideo()->realWidth();
+    p[1]=mEvent.button.y*getVideo()->height()/getVideo()->realHeight();
+    break;
+    
+  }
+  return p;
+}
+
+Uint16 AGEvent::getUnicode() const
+{
+  assert(eventOk(mEvent));
+  return mEvent.key.keysym.unicode;
+}
+
+
+SDLKey AGEvent::getKey() const
+{
+  assert(eventOk(mEvent));
+  return mEvent.key.keysym.sym;
+}
+
+SDLMod AGEvent::getMod() const
+{
+  assert(eventOk(mEvent));
+  return mEvent.key.keysym.mod;
+}
+
+int AGEvent::getButton() const
+{
+  assert(eventOk(mEvent));
+  switch(mEvent.type) {
+  case SDL_MOUSEMOTION:
+    return mEvent.motion.state;
+    break;
+    
+  case SDL_MOUSEBUTTONUP:
+  case SDL_MOUSEBUTTONDOWN:
+    return mEvent.button.button;
+    break;
+    
+  }
+  return 0;
+}
+
+
+
+// AGMouseEvent
+
+/*
+AGMouseEvent::AGMouseEvent(AGListener *pCaller,SDL_Event *pEvent):AGEvent(pCaller)
+{
+}
+AGMouseEvent::~AGMouseEvent()
+{
+}*/
+
+// AGListener
+
+AGListener::AGListener()
+{
+}
+
+AGListener::~AGListener()
+{
+}
+
+bool AGListener::signal(AGEvent *m)
+{
+  return false;
+}
+
+AGCPPListener::~AGCPPListener()
+{
+}
+
+
+
+// AGSignal
+
+AGSignal::AGSignal():mCaller(0)
+{
+}
+
+//AGSignal::AGSignal(const AGSignal &s):mListeners(s.mListeners
+
+
+
+AGSignal::AGSignal(AGMessageObject *pCaller):mCaller(pCaller)
+{
+}
+
+AGSignal::AGSignal(AGMessageObject *pCaller,const AGString &pName):
+  mName(pName),mCaller(pCaller)
+{
+}
+
+AGSignal::~AGSignal()
+{
+  std::set<AGListener*>::iterator i=mListeners.begin();
+  for(;i!=mListeners.end();i++)
+    {
+      AGMessageObject *o=dynamic_cast<AGMessageObject*>(*i);
+      if(o)
+	o->popSignal(this);
+    }
+}
+#undef connect
+
+
+/**
+   This is the simple connect version. You have to override signal(.) in AGListener and
+   provide a reasonable functionality there. For simple usage use AGSignal::connect( AGCPPListener *pListener);
+
+*/
+void AGSignal::connect(AGListener &pListener)
+{
+  mListeners.insert(&pListener);
+  AGMessageObject *o=dynamic_cast<AGMessageObject*>(&pListener);
+  if(o)
+    o->pushSignal(this);
+}
+void AGSignal::disconnect(AGListener &pListener)
+{
+  mListeners.erase(&pListener);
+}
+
+
+/**
+   When connecting a signal to a slot you call this function.
+   For instance you have a class:
+   <pre>
+   class A
+   {
+     public:
+     AGSignal sigSomething;
+   };
+   class B
+   {
+     public:
+     bool eventSomething( AGEvent *e);
+   };
+   A a;
+   B b;
+   // you can connect them like this;
+   A.sigSomething.connect(slot(&b,&B::eventSomething));
+   </pre>
+*/
+
+void AGSignal::connect(AGCPPListener *pListener)
+{
+  mSimpleListeners.insert(pListener);
+}
+void AGSignal::disconnect(AGCPPListener *pListener)
+{
+  mSimpleListeners.erase(pListener);
+}
+
+bool AGSignal::signal(AGEvent *m)
+{
+  m->setName(mName);
+  std::set<AGListener*>::iterator i=mListeners.begin();
+  bool value=false;
+  for(;i!=mListeners.end();i++)
+    {
+      if((*i)->signal(m))
+	value=true;
+    }
+
+  std::set<AGCPPListener*>::iterator j=mSimpleListeners.begin();
+  for(;j!=mSimpleListeners.end();j++)
+    {
+      if((*j)->signal(m))
+	value=true;
+    }
+
+  return value;
+}
+
+bool AGSignal::operator()(AGEvent *m)
+{
+  m->setName(mName);
+  return signal(m);
+}
+
+// AGMessageObject
+
+
+AGMessageObject *AGMessageObject::captureObject=0;
+
+
+AGMessageObject::AGMessageObject():
+  sigActive(this,"sigActive"),
+  sigKeyDown(this,"sigKeyDown"),
+  sigKeyUp(this,"sigKeyUp"),
+  sigMouseMotion(this,"sigMouseMotion"),
+  sigMouseButtonDown(this,"sigMouseButtonDown"),
+  sigMouseButtonUp(this,"sigMouseButtonUp"),
+  sigQuit(this,"sigQuit"),
+  sigSysWM(this,"sigSysWM"),
+  sigVideoResize(this,"sigVideoResize"),
+  mCanReceiveMessages(true)
+{
+}
+
+AGMessageObject::~AGMessageObject()
+{
+  std::set<AGSignal*> sigs=mSignals;
+  std::set<AGSignal*>::iterator i=sigs.begin();
+  for(;i!=sigs.end();i++)
+    (*i)->disconnect(*this);
+}
+
+void AGMessageObject::pushSignal(AGSignal *pSignal)
+{
+  mSignals.insert(pSignal);
+}
+
+void AGMessageObject::popSignal(AGSignal *pSignal)
+{
+  mSignals.erase(pSignal);
+}
+
+
+// 
+// exchange with a processEvent(const AGEvent &event)
+
+bool AGMessageObject::processEvent(AGEvent* agEvent) 
+{
+
+  //  dbout(1,"typeid:"<<typeid(this).name());
+  //  TRACE;
+  //  SDL_Event e;
+  bool rc=false;
+
+  //  const AGSDLEvent *agEvent=reinterpret_cast<const AGSDLEvent*>(pEvent);
+  if(agEvent->isSDLEvent())
+    {
+      const SDL_Event &event=agEvent->get();
+      switch(event.type) {
+      case SDL_ACTIVEEVENT:
+	rc = eventActive(agEvent) || sigActive(agEvent);
+	break;
+	
+      case SDL_KEYDOWN:
+	rc = eventKeyDown(agEvent) || sigKeyDown(agEvent);
+	break;
+    
+      case SDL_KEYUP:
+	rc = eventKeyUp(agEvent) || sigKeyUp(agEvent);
+	break;
+	
+      case SDL_MOUSEMOTION:
+	rc = eventMouseMotion(agEvent) || sigMouseMotion(agEvent);
+	break;
+	
+      case SDL_MOUSEBUTTONDOWN:
+	rc = eventMouseButtonDown(agEvent) || sigMouseButtonDown(agEvent);
+	break;
+	
+      case SDL_MOUSEBUTTONUP:
+	rc = eventMouseButtonUp(agEvent) || sigMouseButtonUp(agEvent);
+	break;
+	
+      case SDL_QUIT:
+	rc = eventQuit(agEvent) || sigQuit(agEvent);
+	break;
+	
+      case SDL_SYSWMEVENT:
+	rc = eventSysWM(agEvent) || sigSysWM(agEvent);
+	break;
+	
+      case SDL_VIDEORESIZE:
+	rc = eventResize(agEvent) || sigVideoResize(agEvent);
+	break;
+	
+      default:
+	rc = false;
+	break;
+      }
+    }
+  
+  return rc;
+}
+
+
+
+bool AGMessageObject::eventActive(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventKeyDown(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventKeyUp(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventMouseMotion(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventMouseButtonDown(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventMouseButtonUp(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventQuit(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventQuitModal(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventSysWM(AGEvent *m)
+{
+  return false;
+}
+bool AGMessageObject::eventResize(AGEvent *m)
+{
+  return false;
+}
+
+Uint8 AGMessageObject::getButtonState() const
+{
+  int x,y;
+  Uint8 b=SDL_GetMouseState(&x,&y);
+  return b;
+}
+AGVector2 AGMessageObject::getMousePosition() const
+{
+  int x,y;
+  SDL_GetMouseState(&x,&y);
+  return AGVector2(x,y);
+}
+
+
+bool AGMessageObject::acceptEvent(const SDL_Event *pEvent)
+{
+  return true;
+}
+
+AGEvent *newEvent(AGListener *pCaller,const AGString &pName,const SDL_Event &s)
+{
+  return new AGEvent(pCaller,pName,s);
+}
+
+
+AGString toString(SDL_keysym k)
+{
+  AGStringStream os;
+  os<<k.scancode<<":"<<(int)k.sym<<":"<<k.mod<<":"<<k.unicode;
+
+  return os.str();
+}
+
+AGString getUntil(AGString &b,const AGString &f)
+{
+  size_t i=b.find(f);
+  AGString s=b.substr(0,i);
+  if(i!=AGString::npos)
+    b=b.substr(i+1,AGString::npos);
+  return s;
+}
+
+SDL_keysym toKeysym(const AGString &s)
+{
+  SDL_keysym k;
+  AGString b=s;
+  k.scancode=getUntil(b,":").toUint8();
+  k.sym=(SDLKey)getUntil(b,":").toUint8();
+  k.mod=(SDLMod)getUntil(b,":").toUint8();
+  k.unicode=getUntil(b,":").toSint16();
+  
+
+  return k;
+}
+
+AGString toString(SDL_Event *pEvent)
+{
+  AGStringStream os;
+  if(pEvent)
+    {
+      switch(pEvent->type)
+	{
+	case SDL_ACTIVEEVENT:
+	  os<<"SDL_ACTIVEEVENT:"<<(int)pEvent->active.gain<<":"<<(int)pEvent->active.state;
+	  break;
+	case SDL_KEYDOWN:
+	  os<<"SDL_KEYDOWN:"<<(int)pEvent->key.which<<":"<<(int)pEvent->key.state<<":"<<toString(pEvent->key.keysym);
+	  break;
+	case SDL_KEYUP:
+	  os<<"SDL_KEYUP:"<<(int)pEvent->key.which<<":"<<(int)pEvent->key.state<<":"<<toString(pEvent->key.keysym);
+	  break;
+	case SDL_MOUSEMOTION:
+	  os<<"SDL_MOUSEMOTION:"<<(int)pEvent->motion.which<<":"<<(int)pEvent->motion.state<<":"<<pEvent->motion.x<<":"<<pEvent->motion.y<<":"<<pEvent->motion.xrel<<":"<<pEvent->motion.yrel;
+	  break;
+	case SDL_MOUSEBUTTONDOWN:
+	  os<<"SDL_MOUSEBUTTONDOWN:"<<(int)pEvent->button.which<<":"<<(int)pEvent->button.button<<":"<<(int)pEvent->button.state<<":"<<pEvent->button.x<<":"<<pEvent->button.y;
+	  break;
+	case SDL_MOUSEBUTTONUP:
+	  os<<"SDL_MOUSEBUTTONUP:"<<(int)pEvent->button.which<<":"<<(int)pEvent->button.button<<":"<<(int)pEvent->button.state<<":"<<pEvent->button.x<<":"<<pEvent->button.y;
+	  break;
+	case SDL_JOYAXISMOTION:
+	  os<<"SDL_JOYAXISMOTION:"<<(int)pEvent->jaxis.which<<":"<<(int)pEvent->jaxis.axis<<":"<<pEvent->jaxis.value;
+	  break;
+	case SDL_JOYBALLMOTION:
+	  os<<"SDL_JOYBALLMOTION:"<<(int)pEvent->jball.which<<":"<<(int)pEvent->jball.ball<<":"<<pEvent->jball.xrel<<":"<<pEvent->jball.yrel;
+	  break;
+	case SDL_JOYHATMOTION:
+	  os<<"SDL_JOYHATMOTION:"<<(int)pEvent->jhat.which<<":"<<(int)pEvent->jhat.hat<<":"<<(int)pEvent->jhat.value;
+	  break;
+	case SDL_JOYBUTTONDOWN:
+	  os<<"SDL_JOYBUTTONDOWN:"<<(int)pEvent->jbutton.which<<":"<<(int)pEvent->jbutton.button<<":"<<(int)pEvent->jbutton.state;
+	  break;
+	case SDL_JOYBUTTONUP:
+	  os<<"SDL_JOYBUTTONUP:"<<(int)pEvent->jbutton.which<<":"<<(int)pEvent->jbutton.button<<":"<<(int)pEvent->jbutton.state;
+	  break;
+	case SDL_QUIT:
+	  os<<"SDL_QUIT:";
+	  break;
+	case SDL_SYSWMEVENT:
+	  os<<"SDL_DUMMY;";
+	  break;
+	case SDL_VIDEOEXPOSE:
+	  os<<"SDL_VIDEOEXPOSE";
+	  break;
+	case SDL_NOEVENT:
+	  os<<"SDL_NOEVENT";
+	  break;
+	default:
+	  dbout(1,"UNKNOWN SDL_EVENT:"<<pEvent->type);
+	  os<<"SDL_NOEVENT";
+	  break;
+	}
+      if(os.str().length())
+	return os.str();
+      
+    }
+  return "SDL_NOEVENT";
+}
+
+
+
+SDL_Event *toSDLEvent(const AGString &p)
+{
+  AGString b=p;
+  AGString t=getUntil(b,":");
+  static SDL_Event event;
+
+  event.type=0;
+
+  if(t=="SDL_ACTIVEEVENT")
+    {
+      event.type=SDL_ACTIVEEVENT;
+      event.active.gain=getUntil(b,":").toUint8();
+      event.active.state=getUntil(b,":").toUint8();
+    }
+  else if(t=="SDL_KEYDOWN")
+    {
+      event.type=SDL_KEYDOWN;
+      event.key.which=getUntil(b,":").toUint8();
+      event.key.state=getUntil(b,":").toUint8();
+      event.key.keysym=toKeysym(b);
+    }
+  else if(t=="SDL_KEYUP")
+    {
+      event.type=SDL_KEYUP;
+      event.key.which=getUntil(b,":").toUint8();
+      event.key.state=getUntil(b,":").toUint8();
+      event.key.keysym=toKeysym(b);
+
+    }
+  else if(t=="SDL_MOUSEMOTION")
+    {
+      event.type=SDL_MOUSEMOTION;
+      event.motion.which=getUntil(b,":").toUint8();
+      event.motion.state=getUntil(b,":").toUint8();
+      event.motion.x=getUntil(b,":").toSint16();
+      event.motion.y=getUntil(b,":").toSint16();
+      event.motion.xrel=getUntil(b,":").toSint16();
+      event.motion.yrel=getUntil(b,":").toSint16();
+    }
+  else if(t=="SDL_MOUSEBUTTONDOWN")
+    {
+      event.type=SDL_MOUSEBUTTONDOWN;
+      event.button.which=getUntil(b,":").toUint8();
+      event.button.button=getUntil(b,":").toUint8();
+      event.button.state=getUntil(b,":").toUint8();
+      event.button.x=getUntil(b,":").toSint16();
+      event.button.y=getUntil(b,":").toSint16();
+    }
+  else if(t=="SDL_MOUSEBUTTONUP")
+    {
+      event.type=SDL_MOUSEBUTTONUP;
+      event.button.which=getUntil(b,":").toUint8();
+      event.button.button=getUntil(b,":").toUint8();
+      event.button.state=getUntil(b,":").toUint8();
+      event.button.x=getUntil(b,":").toSint16();
+      event.button.y=getUntil(b,":").toSint16();
+    }
+  else if(t=="SDL_JOYAXISMOTION")
+    {
+      event.type=SDL_JOYAXISMOTION;
+      event.jaxis.which=getUntil(b,":").toUint8();
+      event.jaxis.axis=getUntil(b,":").toUint8();
+      event.jaxis.value=getUntil(b,":").toUint8();
+    }
+  else if(t=="SDL_JOYBALLMOTION")
+    {
+      event.type=SDL_JOYBALLMOTION;
+      event.jball.which=getUntil(b,":").toUint8();
+      event.jball.ball=getUntil(b,":").toUint8();
+      event.jball.xrel=getUntil(b,":").toSint16();
+      event.jball.yrel=getUntil(b,":").toSint16();
+    }
+  else if(t=="SDL_JOYHATMOTION")
+    {
+      event.type=SDL_JOYHATMOTION;
+      event.jhat.which=getUntil(b,":").toUint8();
+      event.jhat.hat=getUntil(b,":").toUint8();
+      event.jhat.value=getUntil(b,":").toUint8();
+    }
+  else if(t=="SDL_JOYBUTTONDOWN")
+    {
+      event.type=SDL_JOYBUTTONDOWN;
+      event.jbutton.which=getUntil(b,":").toUint8();
+      event.jbutton.button=getUntil(b,":").toUint8();
+      event.jbutton.state=getUntil(b,":").toUint8();
+    }
+  else if(t=="SDL_JOYBUTTONUP")
+    {
+      event.type=SDL_JOYBUTTONUP;
+      event.jbutton.which=getUntil(b,":").toUint8();
+      event.jbutton.button=getUntil(b,":").toUint8();
+      event.jbutton.state=getUntil(b,":").toUint8();
+    }
+  else if(t=="SDL_SYSWMEVENT")
+    {
+      event.type=SDL_SYSWMEVENT;
+      // FIXME
+    }
+  else if(t=="SDL_VIDEOEXPOSE")
+    {
+      event.type=SDL_VIDEOEXPOSE;
+      
+    }
+  else if(t=="SDL_DUMMY")
+    {
+      event.type=SDL_USEREVENT;
+    }
+  else if(t=="SDL_QUIT")
+    {
+      event.type=SDL_QUIT;
+    }
+  else
+    {
+      event.type=SDL_NOEVENT;
+      return &event;
+    }
+  if(event.type)
+    return &event;
+
+  return 0;
+}
+bool eventOk(const SDL_Event &pEvent)
+{
+  //  dbout(1,"eventOk: check "<<(int)pEvent.type<<"!="<<SDL_NOEVENT<<" ???");
+  return (int)pEvent.type!=SDL_NOEVENT;
+}
+
+void resetEvent(SDL_Event &pEvent)
+{
+  pEvent.type=SDL_NOEVENT;
+}

Added: antargis/branches/rant/ext/basic/ag_messageobject.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_messageobject.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/basic/ag_messageobject.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,251 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_messageobject.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_MESSAGEOBJECT_H
+#define AG_MESSAGEOBJECT_H
+
+#include <SDL.h>
+#include <string>
+#include <set>
+
+#include "ag_geometry.h"
+#include "ag_rubyobj.h"
+
+class AGListener;
+class AGSignal;
+
+/** \defgroup events Event handling
+    \brief A small event handling mechanism
+
+    AntargisGUI contains a small event handling mechanism for both ruby and C++.
+    However they do work a little different.
+    
+    Each object that wants to send or receive a message (or event) must be derived from
+    AGMessageObject.
+
+*/
+
+
+
+/** AGEvent is the typical event which is passed when the user does anything.
+    You can however derive from it and pass it through a signal.
+    But you shouldn't delete it for yourself.
+ */
+class AGEvent
+{
+ public:
+  AGEvent(AGListener *pCaller,const AGString &pName,const SDL_Event &pEvent=NullEvent);
+  virtual ~AGEvent();
+
+  AGListener *getCaller() const;
+  
+  void setCaller(AGListener *pCaller);
+  AGString getName() const;
+
+  AGVector2 getMousePosition() const;
+  SDLKey getKey() const;
+  SDLMod getMod() const;
+  Uint16 getUnicode() const;
+  int getButton() const;
+
+  const SDL_Event &get() const;
+
+  bool isSDLEvent() const;
+
+  void setName(const AGString &n);
+
+  void setVector(const AGVector2 &v);
+  AGVector2 getVector() const;
+
+ private:
+  AGListener *mCaller;
+  AGString mName;
+
+  SDL_Event mEvent;
+
+  AGVector2 mVector;
+
+ protected:
+  static SDL_Event NullEvent;
+};
+
+
+/**
+   AGListener is the base for receiving an event. Any object which is derived from AGListener can
+   receive an event. But you should use AGMessageObject for this, as it holds basic "listening"
+   facilities.
+   @see AGEvent
+*/
+class AGListener:public AGRubyObject
+{
+ public:
+  AGListener();
+  virtual ~AGListener();
+  virtual bool signal(AGEvent *m);
+  
+};
+
+/**
+   some syntactic sugar for simple connecting of slots and signals.
+   @see AGSignal
+   @see AGMessageObject
+*/
+class AGCPPListener
+{
+ public:
+  virtual ~AGCPPListener();
+  virtual bool signal(AGEvent *m) const=0;
+};
+
+/**
+   some syntactic sugar for simple connecting of slots and signals.
+   @see AGSignal
+   @see AGMessageObject
+*/
+template<class T>
+class AGSlot0:public AGCPPListener
+{
+ public:
+  typedef bool (T::*FKT)(AGEvent *m);
+  T *base;
+  FKT f;
+  
+  AGSlot0(T *pBase,FKT pF):
+    base(pBase),f(pF)
+    {
+    }
+    virtual ~AGSlot0()
+      {
+      }
+
+    virtual bool signal(AGEvent *m) const
+    {
+      return (base->*f)(m);
+    }
+};
+
+class AGMessageObject;
+
+/** AGSignal is a placeholder-class for a function which calls all the Slots, which 
+    are connected to this signal.
+    For instance a button named "close" holds a sigClick signal and a dialog box has a slotClose.
+    You call sigClick(event) in the button and the connected slot is automatically called.
+    @see connect()
+*/
+class AGSignal
+{
+ public:
+  AGSignal();
+  AGSignal(AGMessageObject *pCaller);
+  AGSignal(AGMessageObject *pCaller,const AGString &pName);
+
+  virtual ~AGSignal();
+
+  void connect(AGListener &pListener);
+  void disconnect(AGListener &pListener);
+
+  void connect(AGCPPListener *pListener);
+  void disconnect(AGCPPListener *pListener);
+
+  bool signal(AGEvent *m);
+
+  bool operator()(AGEvent *m);
+ private:
+  std::set<AGListener*> mListeners;
+
+  std::set<AGCPPListener*> mSimpleListeners;
+
+  AGString mName;
+  AGMessageObject *mCaller;
+};
+
+/**
+   AGMessageObject handles libSDL-events and provides virtual handlers.
+*/
+class AGMessageObject:public AGListener
+{
+ public:
+  AGMessageObject();
+  virtual ~AGMessageObject();
+
+  bool processEvent(AGEvent *pEvent);
+
+  virtual bool acceptEvent(const SDL_Event *pEvent);
+
+
+  // event handler
+  virtual bool eventActive(AGEvent *m);
+  virtual bool eventKeyDown(AGEvent *m);
+  virtual bool eventKeyUp(AGEvent *m);
+  virtual bool eventMouseMotion(AGEvent *m);
+  virtual bool eventMouseButtonDown(AGEvent *m);
+  virtual bool eventMouseButtonUp(AGEvent *m);
+  virtual bool eventQuit(AGEvent *m);
+  virtual bool eventQuitModal(AGEvent *m);
+  virtual bool eventSysWM(AGEvent *m);
+  virtual bool eventResize(AGEvent *m);
+
+  virtual Uint8 getButtonState() const;
+  virtual AGVector2 getMousePosition() const;
+
+
+  AGSignal sigActive;
+  AGSignal sigKeyDown;
+  AGSignal sigKeyUp;
+  AGSignal sigMouseMotion;
+  AGSignal sigMouseButtonDown;
+  AGSignal sigMouseButtonUp;
+  AGSignal sigQuit;
+  AGSignal sigSysWM;
+  AGSignal sigVideoResize;
+
+  void pushSignal(AGSignal *pSignal);
+  void popSignal(AGSignal *pSignal);
+
+ private:
+  bool mCanReceiveMessages;
+
+  std::set<AGSignal*> mSignals;
+
+  static AGMessageObject *captureObject;
+};
+
+
+AGEvent *newEvent(AGListener *pCaller,const AGString &pName,const SDL_Event &s);
+
+/**
+ */   
+
+template<class T>
+AGCPPListener *slot(T *base,bool (T::*f)(AGEvent *))
+{
+  return new AGSlot0<T>(base,f);
+}
+
+
+AGString toString(SDL_Event *pEvent);
+SDL_Event *toSDLEvent(const AGString &p);
+
+bool eventOk(const SDL_Event &pEvent);
+void resetEvent(SDL_Event &pEvent);
+
+#endif

Added: antargis/branches/rant/ext/basic/ag_mutex.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_mutex.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/basic/ag_mutex.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,28 @@
+#include "ag_mutex.h"
+#include <stdlib.h>
+
+AGMutex::AGMutex()
+{
+  mut=SDL_CreateMutex();
+
+}
+AGMutex::~AGMutex()
+{
+  SDL_DestroyMutex(mut);
+}
+
+void AGMutex::enter()
+{
+  if(SDL_mutexP(mut)==-1){
+    fprintf(stderr, "Couldn't lock mutex\n");
+    exit(-1);
+  }
+}
+
+void AGMutex::leave()
+{
+  if(SDL_mutexV(mut)==-1){
+    fprintf(stderr, "Couldn't unlock mutex\n");
+    exit(-1);
+  }
+}

Added: antargis/branches/rant/ext/basic/ag_mutex.h
===================================================================
--- antargis/branches/rant/ext/basic/ag_mutex.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/basic/ag_mutex.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,20 @@
+#ifndef AG_MUTEX
+#define AG_MUTEX
+
+#include <SDL.h>
+#include <SDL_thread.h>
+
+class AGMutex
+{
+ public:
+  AGMutex();
+  ~AGMutex();
+
+  void enter();
+  void leave();
+ private:
+  SDL_mutex *mut;
+
+};
+
+#endif

Added: antargis/branches/rant/ext/game/ant_app.cc
===================================================================
--- antargis/branches/rant/ext/game/ant_app.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/ant_app.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,185 @@
+#include "ant_app.h"
+#include "ag_vdebug.h"
+#include "ag_profiler.h"
+
+GLApp::GLApp(int w,int h):scene(w,h)
+{
+  CTRACE;
+  shadow=true;
+  mx=my=0;
+  omx=-1;
+  frameTime=0;
+  frameCount=0;
+  hx=hy=-1;
+}
+
+GLApp::~GLApp()
+{
+  CTRACE;
+}
+
+
+void GLApp::draw()
+{
+  STACKTRACE;
+  drawGL();
+  AGApplication::draw();
+}
+
+void GLApp::drawGL()
+{
+  STACKTRACE;
+  glEnable(GL_DEPTH_TEST); // enable depth test
+  glDepthMask(true);
+
+  assertGL;
+  scene.draw();
+  assertGL;
+}
+
+bool GLApp::eventFrame(float t)
+{
+  if(hx>=0)
+    {
+      // check hovering
+      Scene::PickResult nodes=scene.pick(hx,hy,1,1);
+      
+      if(nodes.size())
+	eventHover(nodes,hb);
+      hx=hy=-1;
+    }
+  return true;
+}
+
+bool GLApp::eventMouseButtonDown(AGEvent *e)
+{
+  mMayClick=true;
+
+  if(e->isSDLEvent())
+    {
+      if(e->getButton()==5)
+	{
+	  getScene().getCameraObject().incCameraDistance();
+	}
+      else if(e->getButton()==4)
+	{
+	  getScene().getCameraObject().decCameraDistance();
+	}
+      else if(e->getButton()==1)
+	{
+	  AGVector2 p=e->getMousePosition();
+	  omx=p[0];
+	  omy=p[1];
+	}
+      /*      else if(e->getButton()==1)
+	{
+	  AGVector2 p=e->getMousePosition();
+	  Scene::PickResult nodes=scene.pick(p[0],p[1],1,1);
+	  }*/
+    }
+  return AGApplication::eventMouseButtonDown(e);
+}
+bool GLApp::eventMouseButtonUp(AGEvent *e)
+{
+  CTRACE;
+  omx=-1;
+  omy=-1;
+  if(mMayClick)
+    {
+      if(e->isSDLEvent())
+	{
+	  if(e->getButton()<4)
+	    {
+	      STACKTRACE;
+	      AGVector2 p=e->getMousePosition();
+	      Scene::PickResult nodes=scene.pick(p[0],p[1],1,1);
+
+	      eventClick(nodes,e->getButton());
+	    }
+	}
+    }
+  else
+    {
+      cdebug("click failed");
+    }
+  return AGApplication::eventMouseButtonUp(e);
+}
+
+void GLApp::eventClick(const Scene::PickResult &pNodes,int button)
+{
+}
+
+void GLApp::eventHover(const Scene::PickResult &pNodes,int button)
+{
+}
+
+
+bool GLApp::eventMouseMotion(AGEvent *e)
+{
+  if(e->isSDLEvent() && omx>=0)
+    {
+      AGVector2 p=e->getMousePosition();
+      //      AGVector4 cam=scene.getCamera();
+      mx=p[0]-omx;
+      my=p[1]-omy;
+      
+      setCamera(getCamera()+AGVector2(-mx*0.03,my*0.03));
+      //      camera=cam+AGVector4(-mx*0.03,my*0.03,0);
+      //      scene.setCamera(camera);
+      
+      omx=p[0];
+      omy=p[1];
+    }
+  if(e->isSDLEvent())
+    {
+      // check hovering - delayed 
+      AGVector2 p=e->getMousePosition();
+      hx=p[0];
+      hy=p[1];
+      hb=e->getButton();
+    }
+
+  mMayClick=false;
+  return AGApplication::eventMouseMotion(e);
+}
+
+AGVector2 GLApp::getCamera() const
+{
+  return scene.getCamera().dim2();
+}
+
+void GLApp::setCamera(const AGVector2 &p)
+{
+  scene.setCamera(AGVector4(p[0],p[1],getCameraHeight(p)));
+}
+
+bool GLApp::eventKeyDown(AGEvent *e)
+{
+  if(e->isSDLEvent())
+    {
+      if(e->getKey()==SDLK_s)
+	{
+	  //	    shadow=!shadow;
+	  scene.setShadow((scene.getShadow()+1)%3);
+	}
+    }
+  return AGApplication::eventKeyDown(e);
+}
+
+Scene &GLApp::getScene()
+{
+  assert(&scene);
+  return scene;
+}
+
+void GLApp::mark()
+{
+  //CTRACE;
+  markObject(&scene);
+  AGApplication::mark();
+}
+
+float GLApp::getCameraHeight(const AGVector2&p)
+{
+  return 0;
+}

Added: antargis/branches/rant/ext/game/ant_app.h
===================================================================
--- antargis/branches/rant/ext/game/ant_app.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/ant_app.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,84 @@
+#ifndef ANT_APP_H
+#define ANT_APP_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+/**
+ *	
+ * \mainpage Battles of Antargis - C++ documentation
+ *  \section Overview
+ *    This is the C++ part of the API-documentation.
+ *    It consists of three major parts:
+ *    \see AntargisGUI
+ *    \see Engine3d
+ *    \see GameEngine
+ * 
+ *    For information about the overall-architecture please refer to the ruby-documentation at: ../ruby/index.html
+ *
+ * 
+
+
+
+*/
+
+
+
+#include "scene.h"
+#include "ant_renderer.h"
+#include <iostream>
+#include <fstream>
+#include <ag_application.h>
+#include <ag_debug.h>
+#include <ag_main.h>
+#include <ag_geometry.h>
+
+#ifndef SWIG
+extern std::ofstream out;
+#endif
+
+class GLApp:public AGApplication
+{
+  bool shadow;
+  float mx,my;
+  float omx,omy;
+  AGVector4 camera;
+  float frameTime;
+  size_t frameCount;
+
+  bool mMayClick;
+
+  float hx,hy;
+  int hb;
+
+protected:
+  Scene scene;
+  
+public:
+  GLApp(int w,int h);
+  ~GLApp();
+
+  virtual void draw();
+  void drawGL();
+
+  bool eventFrame(float t);
+
+  virtual void eventClick(const Scene::PickResult &pNodes,int button);
+  virtual void eventHover(const Scene::PickResult &pNodes,int button);
+
+  virtual bool eventMouseButtonDown(AGEvent *m);
+  virtual bool eventMouseButtonUp(AGEvent *m);
+  virtual bool eventMouseMotion(AGEvent *m);
+  virtual bool eventKeyDown(AGEvent *m);
+
+  Scene &getScene();
+
+  virtual float getCameraHeight(const AGVector2&p);
+  virtual void setCamera(const AGVector2&p);
+  AGVector2 getCamera() const;
+
+  void mark();
+};
+
+
+
+#endif

Added: antargis/branches/rant/ext/game/entity.cc
===================================================================
--- antargis/branches/rant/ext/game/entity.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/entity.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,888 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * entity.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "entity.h"
+#include "map.h"
+#include "ag_debug.h"
+#include "jobs.h"
+#include "mesh.h"
+#include "anim_mesh.h"
+
+AntEntity::AntEntity(const AGVector3 &p):mPos(p)
+{
+  init();
+}
+AntEntity::AntEntity(const AGVector2 &p):mPos(getMap()->getPos(p))
+{
+  init();
+}
+
+AntEntity::AntEntity():mPos(0,0,0)
+{
+  init();
+}
+
+void AntEntity::init()
+{
+  mRubyObject=false;
+
+  mID=getMap()->getNewID();
+
+  mShowOnMinimap=false;
+  onGround=true;
+  onWater=false;
+
+  mJob=0;
+
+  mVirtualY=40;
+
+  mEnergy=1.0;
+  mHealSpeed=0.07;
+
+  mMorale=1.0;
+  mMoraleHeal=0.05;
+
+  mMoveSpeed=2;
+
+  mAggression=1;
+
+  //  mSurface=0;
+  //esh=0;
+  mDir=0;
+
+  mStrength=0.02;
+  mMoraleStrength=0.04;
+
+  mFood=1.0;
+  mHunger=0.006;
+  mHungerHitEnergy=0.02;
+  mHungerHitMorale=0.14;
+
+  mMoraleFlag=true;
+
+  mDefense=1.0;
+  //  mDirNum=1;
+
+  mMinimapSize=2;
+
+  experience=0;
+  learnAmount=0.1;
+
+  mDefeated=false;
+}
+
+
+AntEntity::~AntEntity()
+{
+  //  CTRACE;
+  for(Meshes::iterator i=mMeshes.begin();i!=mMeshes.end();i++)
+    saveDelete(*i);
+  mMeshes.clear();
+  delete mJob;
+}
+
+void AntEntity::resourceChanged()
+{
+}
+
+void AntEntity::saveXML(Node &node) const
+  {
+    Node &child=node.addChild("position");
+    mPos.saveXML(child);
+    node.set("energy",AGString(mEnergy));
+    node.set("healSpeed",AGString(mHealSpeed));
+    node.set("onGround",AGString(onGround));
+    node.set("onWater",AGString(onWater));
+    //    node.set("entityID",AGString(getID()));
+    node.set("name",getName());
+    //    node.set("classtype",getType());
+    node.set("morale",AGString(mMorale));
+    node.set("aggression",AGString(mAggression));
+    node.set("food",AGString(mFood));
+    node.set("id",AGString(mID));
+    node.set("exp",AGString(experience));
+    node.set("learnAmount",AGString(learnAmount));
+
+    node.set("defeated",AGString(mDefeated));
+
+    Node &res=node.addChild("resource");
+    resource.saveXML(res);
+
+
+
+    if(mJob)
+      {
+	Node &j=node.addChild("job");
+	j.set("type",mJob->xmlName());
+	mJob->saveXML(j);
+      }
+
+  }
+void AntEntity::loadXML(const Node &node)
+{
+  mEnergy=node.get("energy").toFloat();
+  mHealSpeed=node.get("healSpeed").toFloat();
+  onGround=node.get("onGround").toBool();
+  onWater=node.get("onWater").toBool();
+
+  mDefeated=node.get("defeated").toBool();
+  //  assert(onGround);
+  Node::NodeVector v=node.getChildren("position");
+  Node::const_iterator i=v.begin();
+  for(;i!=v.end();i++)
+    mPos.loadXML(**i);
+  mID=node.get("entityID").toInt();
+  getMap()->useID(mID);
+  if(node.get("morale")!="")
+    mMorale=node.get("morale").toFloat();
+  else
+    mMorale=1.0f;
+  mAggression=node.get("aggression").toFloat();
+  mAggression=std::min(3,std::max(1,int(mAggression))); //1,2,3 nothing else
+
+  if(node.get("food")!="")
+    mFood=node.get("food").toFloat();
+  if(node.get("hunger")!="")
+    mHunger=node.get("hunger").toFloat();
+
+  setName(node.get("name"));
+  //  setType(node.get("classtype"));
+
+  if(node.get("exp")!="")
+    experience=node.get("exp").toFloat();
+  if(node.get("learnAmount")!="")
+    learnAmount=node.get("learnAmount").toFloat();
+
+  Node::NodeVector v2=node.getChildren("resource");
+  if(v2.size()>0)
+    resource.loadXML(v2[0]);
+  
+  v2=node.getChildren("job");
+  if(v2.size()>0)
+    {
+      loadJob(v2[0]);
+    }
+  resourceChanged();
+}
+
+void AntEntity::loadJob(const Node &pNode)
+{
+  AGString t=pNode.get("type");
+  if(t=="restJob")
+    mJob=new RestJob;
+  else if(t=="fightJob")
+    mJob=new FightJob;
+  else if(t=="moveJob")
+    mJob=new MoveJob;
+  else if(t=="fetchJob")
+    mJob=new FetchJob;
+  if(mJob)
+    mJob->loadXML(pNode);
+}
+
+
+AGVector3 AntEntity::getPos3D() const
+  {
+    return mPos;
+  }
+AGVector2 AntEntity::getPos2D() const
+  {
+    return AGVector2(mPos[0],mPos[1]);
+  }
+
+void AntEntity::updatePos(const AGVector3 &p)
+{
+  if(mMeshes.size()==1)
+    {
+      mMeshes.front()->setPos(p);
+      return;
+    }
+  for(Meshes::iterator i=mMeshes.begin();i!=mMeshes.end();i++)
+    {
+      (*i)->setPos(p+mMeshPos[*i]);
+      (*i)->setRotation(mDir);
+    }
+  
+}
+
+void AntEntity::setPos(const AGVector3 &p)
+{
+  mPos=p;
+  updatePos(p);
+}
+void AntEntity::setPos(const AGVector2 &pp)
+{
+  AGVector2 p=getMap()->truncPos(pp); // make sure, that position is ok
+  if(onGround)
+    mPos=getMap()->getPos(p);
+  else if(onWater)
+    mPos=AGVector3(p,0);
+  else
+    {
+      mPos=AGVector3(p,mPos[2]);
+    }
+  updatePos(mPos);
+}
+
+void AntEntity::delJob()
+{
+  setJob(0);
+}
+
+void AntEntity::setJob(Job *pJob)
+{
+  //  assert(pJob);
+  if(mJob)
+    {
+      if(pJob)
+	{
+	  if((*mJob)<=(*pJob))
+	    {
+	      mJobFinished.push_back(mJob);
+	      //delete mJob;
+	    }
+	  else
+	    {
+	      // FIXME: Priorities are ignored for now
+	      //	      throw int(); // FIXME: delete this, it's a test if priorities get handled correctly
+	      mJobFinished.push_back(mJob);
+	      //	      delete pJob;
+	      //	  return;
+	    }
+	}
+      else
+	mJobFinished.push_back(mJob);
+    }
+  mJob=0;
+  if(mEnergy>=0.0) // do job anyways
+    {
+      if(!pJob)
+	mJob=pJob;
+      else
+	{
+	  if(mMorale>0.1 || !pJob->needsMorale()) // at least 10% morale
+	    mJob=pJob;
+	  else
+	    mJobFinished.push_back(pJob);
+	}
+    }
+  else
+    {
+      if(pJob)
+	mJobFinished.push_back(pJob);
+    }
+  if(mJob)
+    eventGotNewJob();
+}
+
+void AntEntity::eventGotNewJob()
+{
+}
+
+
+/** do anything in given time frame */
+void AntEntity::move(float pTime)
+{
+  if(mJobFinished.size() || mEnergy==0.0)
+    {
+      std::list<Job*>::iterator i=mJobFinished.begin();
+      for(;i!=mJobFinished.end();i++)
+	delete *i;
+      mJobFinished.clear();
+    }
+  else if(mEnergy>0.0)
+    {
+      starve(pTime);
+
+      if(mMorale<=0.1)
+	if(mJob)
+	  {
+	    assert(mJob->valid());
+	    if(mJob->needsMorale())
+	      setJob(0);// kill job
+	  }
+      if(!isStarving())
+	{
+	  mEnergy+=pTime*getHealSpeed()*0.2; // very slow healing when doin something
+	  if(mEnergy>1.0)
+	    mEnergy=1.0;
+	}
+    }
+  if(mJob)
+    {
+      assert(mJob->valid());
+      mJob->move(this,pTime);
+    }
+  else
+    eventNoJob();
+
+}
+
+void AntEntity::heal(float pTime)
+{
+  if(!isStarving())
+    {
+      mEnergy+=pTime*getHealSpeed()*0.8; // only rest til 1.0
+      if(mEnergy>1.0)
+	mEnergy=1.0;
+    }
+}
+
+void AntEntity::incMorale(float pTime)
+{
+  if(!isStarving())
+    {
+      mMorale+=pTime*mMoraleHeal;
+      if(mMorale>1.0)
+	mMorale=1.0;
+      if(mMorale>0.5)
+	mDefeated=false;
+    }
+}
+
+
+
+
+void AntEntity::eventJobFinished()
+{
+}
+
+void AntEntity::eventNoJob()
+{
+}
+
+
+void AntEntity::eventMapChanged()
+{
+  setPos(mPos);
+  /*
+  if(onGround)
+    mPos=getMap()->getPos(AGVector2(getPos2D()));
+  else if(onWater)
+    mPos=AGVector3(getPos2D()[0],getPos2D()[1],0);
+  */
+  updatePos(mPos);
+}
+
+void AntEntity::setMesh(SceneNode *m)
+{
+  // clear meshes from scene
+  for(Meshes::iterator i=mMeshes.begin();i!=mMeshes.end();i++)
+      saveDelete(*i);
+
+  mMeshes.clear();
+  mMeshPos.clear();
+  if(m)
+    {
+      AnimMesh *mesh=dynamic_cast<AnimMesh*>(m);
+      if(mesh)
+	mesh->setEntity(this);
+      mMeshes.push_back(m);
+
+      updatePos(mPos);
+    }
+}
+
+void AntEntity::addMesh(SceneNode *m,const AGVector3 &v)
+{
+  if(m)
+    {
+      AnimMesh *mesh=dynamic_cast<AnimMesh*>(m);
+      if(mesh)
+	mesh->setEntity(this);
+      mMeshes.push_back(m);
+      mMeshPos.insert(std::make_pair(m,v));
+
+      updatePos(mPos);
+    }
+}
+
+
+AntEntity::Meshes AntEntity::getMesh()
+{
+  return mMeshes;
+}
+
+SceneNode *AntEntity::getFirstMesh()
+{
+  return mMeshes.front();
+}
+
+
+
+int AntEntity::getID() const
+{
+  return mID;
+}
+
+AGString AntEntity::xmlName() const
+{
+  return "antEntity";
+}
+float AntEntity::getDirection() const
+{
+  return mDir;
+}
+
+
+void AntEntity::setDirection(float dir)
+{
+  mDir=dir;
+
+  if(mMeshes.size())
+    {
+      SceneNode *m=mMeshes.front();
+      if(m)
+	m->setRotation(dir);
+    }
+}
+
+void AntEntity::setVisible(bool v)
+{
+  for(Meshes::iterator i=mMeshes.begin();i!=mMeshes.end();i++)
+    (*i)->setVisible(v);
+}
+
+
+
+
+void AntEntity::newRestJob(float pTime)
+{
+  setJob(new RestJob(pTime));
+}
+void AntEntity::newFetchJob(int p,AGVector2 &pTarget,const AGString &what)
+{
+  setJob(new FetchJob(p,pTarget,what));
+}
+void AntEntity::newFetchJob(int p,AntEntity *pTarget,const AGString &what)
+{
+  setJob(new FetchJob(p,pTarget,what));
+}
+void AntEntity::newMoveJob(int p,const AGVector2 &pTarget,float pnear)
+{
+  setJob(new MoveJob(p,pTarget,pnear));
+}
+void AntEntity::newMoveJob(int p,const AGVector3 &pTarget,float pnear)
+{
+  setJob(new MoveJob(p,pTarget,pnear));
+}
+
+void AntEntity::newMoveJob(int p,AntEntity *pTarget,float pnear)
+{
+  setJob(new MoveJob(p,pTarget,pnear));
+}
+
+
+void AntEntity::newFightJob(int p,AntEntity *target,float distance)
+{
+  if(!canFight())
+    return;
+  if(mJob)
+    {
+      FightJob *f=dynamic_cast<FightJob*>(mJob);
+      if(f)
+	if(f->getTarget()==target)
+	  return;
+    }
+  setJob(new FightJob(p,target,distance));
+}
+
+void AntEntity::setSpeed(float f)
+{
+  mMoveSpeed=f;
+}
+float AntEntity::getSpeed() const
+{
+  return mMoveSpeed;
+}
+
+void AntEntity::setHealSpeed(float f)
+{
+  mHealSpeed=f;
+}
+
+void AntEntity::setMoraleHealSpeed(float f)
+{
+  mMoraleHeal=f;
+}
+
+void AntEntity::setMoraleFlag(bool f)
+{
+  mMoraleFlag=f;
+}
+
+
+void AntEntity::decEnergy(float amount)
+{
+  mEnergy-=amount;
+  if(mEnergy<0.0)
+    {
+      mEnergy=0.0;
+      eventDie();
+    }
+}
+
+bool AntEntity::hasJob() const
+      {
+        return mJob;
+      }
+
+float AntEntity::getHealSpeed() const
+      {
+        return mHealSpeed;
+      }
+
+
+void AntEntity::decMorale(float amount)
+{
+  if(!mMoraleFlag)
+    return;
+  mMorale-=amount;
+  if(mMorale<0.0)
+    {
+      mMorale=0.0;
+      mDefeated=true;
+      eventMoraleLow();
+    }
+}
+
+
+void AntEntity::eventDie()
+{
+  sigJobFinished();
+}
+
+float AntEntity::getMorale() const
+{
+  return mMorale;
+}
+float AntEntity::getEnergy() const
+{
+  return mEnergy;
+}
+
+void AntEntity::setAggression(float agg)
+{
+  mAggression=agg;
+}
+float AntEntity::getAggression() const
+{
+  return mAggression;
+}
+
+void AntEntity::eventGotFight(AntEntity*pOther)
+{
+}
+
+void AntEntity::eventDefeated()
+{
+}
+
+void AntEntity::sigDefeated()
+{
+  if(!mMoraleFlag)
+    return;
+  mMorale=-0.1; // really deep morale
+  mDefeated=true;
+  // this prevents other fight-jobs from not being discarded
+  eventDefeated();
+}
+
+
+
+void AntEntity::setName(const AGString &pName)
+{
+  mName=pName;
+}
+AGString AntEntity::getName() const
+{
+  return mName;
+}
+
+/*void AntEntity::setType(const AGString &pType)
+{
+  mType=pType;
+}
+AGString AntEntity::getType() const
+{
+  return mType;
+  }*/
+
+AGRect2 AntEntity::getRect() const
+{
+  // FIXME: exchange this with something suitable
+  return AGRect2(mPos[0]-0.1, mPos[1]-0.1, 0.2, 0.2);
+}
+
+
+
+void AntEntity::mark()
+{
+  AGRubyObject::mark();
+  for(Meshes::iterator i=mMeshes.begin();i!=mMeshes.end();i++)
+    markObject(*i);
+
+  if(mJob)
+    {
+      MoveJob *mj=dynamic_cast<MoveJob*>(mJob);
+      FightJob *fj=dynamic_cast<FightJob*>(mJob);
+      if(mj)
+	if(mj->getTarget())
+	  markObject(mj->getTarget(),false);
+      if(fj)
+	if(fj->getTarget())
+	  markObject(fj->getTarget(),false);
+	
+    }
+}
+
+
+void AntEntity::clear()
+{
+  clearMeshes();
+}
+
+
+void AntEntity::clearMeshes()
+{
+  for(Meshes::iterator i=mMeshes.begin();i!=mMeshes.end();i++)
+    {
+      saveDelete(*i);
+    }
+  mMeshes.clear();
+}
+
+void AntEntity::animationEvent(const AGString &pName)
+{
+}
+
+void AntEntity::setMinimapColor(const AGColor &c)
+{
+  mMinimapColor=c;
+  mShowOnMinimap=true;
+}
+
+AGColor AntEntity::getMinimapColor() const
+{
+  return mMinimapColor;
+}
+
+bool AntEntity::showOnMinimap() const
+{
+  return mShowOnMinimap;
+}
+
+void AntEntity::setStrength(float f)
+{
+  mStrength=f;
+}
+float AntEntity::getStrength() const
+{
+  return mStrength;
+}
+void AntEntity::setMoraleStrength(float f)
+{
+  mMoraleStrength=f;
+}
+float AntEntity::getMoraleStrength() const
+{
+  return mMoraleStrength;
+}
+
+void AntEntity::setDefense(float f)
+{
+  assert(f>0);
+  mDefense=f;
+}
+float AntEntity::getDefense() const
+{
+  return mDefense;
+}
+
+
+void AntEntity::setProvide(const AGString &pName,bool flag)
+{
+  if(flag)
+    mProvides.insert(pName);
+  else
+    mProvides.erase(pName);
+}
+
+bool AntEntity::provides(const AGString &pName) const
+{
+  return(mProvides.find(pName)!=mProvides.end());
+}
+
+bool AntEntity::canFight() const
+{
+  return (getEnergy()>0.0 && getMorale()>=0.1 && !mDefeated);
+}
+
+bool AntEntity::isFighting() const
+{
+  if(mJob)
+    {
+      FightJob *f=dynamic_cast<FightJob*>(mJob);
+      return f;
+    }
+  return false;
+}
+
+void AntEntity::sigJobFinished()
+{
+  mJobFinished.push_back(mJob);
+  mJob=0;
+  eventJobFinished();
+}
+
+void AntEntity::eventHaveDefeated(AntEntity *e)
+{
+}
+
+
+
+float AntEntity::getFood() const
+{
+  return mFood;
+}
+
+void AntEntity::incFood(float v)
+{
+  mFood+=v;
+  mFood=std::min(1.0f,mFood);
+}
+
+void AntEntity::starve(float pTime)
+{
+  mFood-=pTime*mHunger;
+  if(isStarving())
+    {
+      // get time for which mFood==0
+      float t=-mFood/mHunger;
+
+      // hit energy
+      decEnergy(mHungerHitEnergy*t);
+
+      // hit morale
+      decMorale(mHungerHitMorale*t);
+
+
+      mFood=0;
+    }
+}
+
+void AntEntity::eventMoraleLow()
+{
+}
+
+bool AntEntity::isStarving() const
+{
+  return mFood<=0;
+}
+
+void AntEntity::eventStartFighting()
+{
+}
+void AntEntity::eventStartMoving()
+{
+}
+
+void AntEntity::setHunger(float f)
+{
+  mHunger=f;
+}
+
+bool AntEntity::eventHitWaterMark(bool fromAbove)
+{
+  return true;
+}
+
+void AntEntity::setOnGround(bool p)
+{
+  onGround=false;
+}
+
+void AntEntity::setOnWater(bool p)
+{
+  if(p)
+    {
+      onWater=true;
+      onGround=false;
+    }
+  else
+    {
+      onWater=false;
+      onGround=true;
+    }
+  
+}
+bool AntEntity::isMoving() const
+{
+  if(!mJob)
+    return false;
+  return dynamic_cast<MoveJob*>(mJob);
+}
+
+AntEntity *AntEntity::getFightTarget()
+{
+  if(mJob)
+    {
+      FightJob *f=dynamic_cast<FightJob*>(mJob);
+      if(f)
+	return f->getTarget();
+    }
+  return 0;
+}
+
+void AntEntity::setMinimapSize(float f)
+{
+  mMinimapSize=f;
+}
+
+float AntEntity::getMinimapSize() const
+{
+  return mMinimapSize;
+}
+
+bool AntEntity::isOnWater() const
+{
+  return onWater;
+}
+
+bool AntEntity::isOnGround() const
+{
+  return onGround;
+}
+
+void AntEntity::experienceFull()
+{
+}
+
+void AntEntity::incExperience(float a)
+{
+  experience+=a;
+  if(experience>1)
+    experienceFull();
+}
+
+bool AntEntity::defeated() const
+{
+  return mDefeated;
+}

Added: antargis/branches/rant/ext/game/entity.h
===================================================================
--- antargis/branches/rant/ext/game/entity.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/entity.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,285 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * entity.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef ANT_ENTITY_H
+#define ANT_ENTITY_H
+
+#include "scene.h"
+#include <ag_xml.h>
+#include <ag_geometry.h>
+#include <ag_color.h>
+#include <ag_string.h>
+
+
+#include <set>
+#include <vector>
+
+class Mesh;
+class SceneNode;
+class Job;
+
+#include "resource.h"
+
+class AntEntity:public AGRubyObject
+  {
+  public:
+    typedef std::list<SceneNode*> Meshes;
+  private:
+    int mID;
+    AGString mName;
+
+    AGVector3 mPos;   // 3d-position
+    bool onGround;    // is this on the ground of the map?
+    bool onWater;
+
+    Job *mJob;        // current job
+
+    std::list<Job*> mJobFinished;  // finished jobs, in cue, so that they get deleted next time possible
+
+    std::set<AGString> mProvides;
+
+    // energy and healing
+    float mEnergy;
+    float mHealSpeed;
+
+    // morale and moralehealing
+    float mMorale;
+    float mMoraleHeal;
+
+    bool mMoraleFlag;
+
+    /// current food in stomach
+    float mFood;
+    /// food needed per second
+    float mHunger; 
+    /// hunger impact on energy
+    float mHungerHitEnergy;
+    /// hunger impact on morale
+    float mHungerHitMorale;
+
+    // moving
+    float mMoveSpeed;
+
+    float mAggression;
+
+    AGString mType;
+
+    Meshes mMeshes;
+    std::map<SceneNode*,AGVector3> mMeshPos;
+
+    int mVirtualY;
+
+    AGColor mMinimapColor;
+    bool mShowOnMinimap;
+    float mMinimapSize;
+
+    float mStrength;
+    float mMoraleStrength;
+    
+    float mDefense;
+
+    bool mDefeated;
+  public:
+    float experience;
+    float learnAmount;
+
+
+  public: //virtually protected
+    float mDir;  // direction in (0,360)
+    Resource resource;
+
+  public:
+    AntEntity();
+    AntEntity(const AGVector3 &p);
+    AntEntity(const AGVector2 &p);
+    virtual ~AntEntity();
+
+    bool defeated() const;
+
+    void setMinimapColor(const AGColor &c);
+    void setMinimapSize(float f);
+    AGColor getMinimapColor() const;
+    bool showOnMinimap() const;
+    float getMinimapSize() const;
+
+    void setStrength(float f);
+    float getStrength() const;
+    void setMoraleStrength(float f);
+    float getMoraleStrength() const;
+    void setDefense(float f);
+    float getDefense() const;
+
+    void setMoraleFlag(bool f);
+
+
+    // Positions
+    AGVector3 getPos3D() const;
+    AGVector2 getPos2D() const;
+    virtual void setPos(const AGVector2 &p); // overwrite this only on static Entities, otherwise this gets called really (!) often
+    void setPos(const AGVector3 &p);
+
+    // IDs, names and types
+    int getID() const;
+
+    AGString getName() const;
+    void setName(const AGString &pName);
+
+    //    AGString getType() const;
+    //    void setType(const AGString &pType);
+
+    void setProvide(const AGString &pName,bool flag);
+    bool provides(const AGString &pName) const;
+
+    // saving and loading
+    virtual AGString xmlName() const;
+
+    virtual void saveXML(Node &node) const;
+    virtual void loadXML(const Node &node);
+
+    // jobs
+
+  private:
+    void setJob(Job *pJob); // only for internal use and reseting
+
+  public:
+    virtual void newRestJob(float pTime);
+    virtual void newFetchJob(int p,AGVector2 &pTarget,const AGString &pWhat);
+    virtual void newFetchJob(int p,AntEntity *pTarget,const AGString &pWhat);
+    virtual void newMoveJob(int p,const AGVector2 &pTarget,float pnear=0.0);
+    virtual void newMoveJob(int p,const AGVector3 &pTarget,float pnear=0.0);
+    virtual void newMoveJob(int p,AntEntity *target,float pnear=0.0);
+    virtual void newFightJob(int p,AntEntity *target,float distance);
+    virtual void delJob();
+
+    bool isMoving() const;
+
+    virtual void resourceChanged();
+
+    bool hasJob() const;
+
+    AGRect2 getRect() const;
+
+    virtual void eventNoJob();
+    virtual void eventJobFinished();
+    virtual void eventGotNewJob();
+    virtual void eventGotFight(AntEntity*pOther);
+
+    // set/get speeds
+    void setSpeed(float f);
+    float getSpeed() const;
+
+    float getHealSpeed() const;
+    void setHealSpeed(float f);
+
+    void setMoraleHealSpeed(float f);
+
+    void setHunger(float f);
+
+    // aggression - handling
+
+    void setAggression(float agg);
+    float getAggression() const;
+    
+    virtual void eventDie(); // energy too low
+    virtual void eventDefeated(); // morale too low
+    virtual void eventHaveDefeated(AntEntity *e);
+    virtual void eventMoraleLow();
+
+    // called by FightJob
+    virtual void eventStartFighting();
+    virtual void eventStartMoving();
+
+    // should return if it's ok to proceed
+    virtual bool eventHitWaterMark(bool fromAbove);
+
+    void sigDefeated(); // morale too low
+    void sigJobFinished();
+
+    float getEnergy() const;
+    float getMorale() const;
+
+    bool canFight() const;
+    bool isFighting() const;
+
+    // appearance
+
+    // FIXME: this shouldn't be virtual, because it gets called too often!
+    //    virtual AGString getTexture() const;
+
+    // anything below shouldn't be used by ruby-functions
+
+    void setMesh(SceneNode *pMesh);
+    Meshes getMesh();
+    SceneNode *getFirstMesh();
+    void addMesh(SceneNode *pMesh,const AGVector3 &v);
+
+    // used only by *Jobs
+    void setDirection(float pAngle);
+    float getDirection() const;
+
+    void decEnergy(float amount);
+    void decMorale(float amount);
+    void incMorale(float pTime);
+
+    void incExperience(float amount);
+
+
+    virtual void experienceFull();
+
+    float getFood() const;
+    void incFood(float v);
+    bool isStarving() const;
+
+    bool isOnWater() const;
+    bool isOnGround() const;
+
+    void setOnWater(bool p);
+    void setOnGround(bool p);
+
+    // used only by Map - so that Position gets updated, when onGround
+    void eventMapChanged();
+    virtual void move(float pTime); // move entity FIXME: del move
+
+    void mark();
+
+    void clear();
+    void clearMeshes();
+
+    void setVisible(bool v);
+
+    virtual void animationEvent(const AGString &pName);
+
+    void heal(float pTime);
+
+    AntEntity *getFightTarget();
+
+  private:
+    void init();
+    void updatePos(const AGVector3 &p);
+
+    void starve(float pTime);
+
+    void loadJob(const Node &pNode);
+  };
+
+
+#endif

Added: antargis/branches/rant/ext/game/entptr.cc
===================================================================
--- antargis/branches/rant/ext/game/entptr.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/entptr.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,18 @@
+#include "entptr.h"
+// AntEntityPtr
+AntEntityPtr::AntEntityPtr():p(0)
+{
+}
+
+AntEntityPtr::AntEntityPtr(const AntEntityPtr &pp):p(pp.p)
+{
+}
+AntEntityPtr::AntEntityPtr(AntEntity *pp):p(pp)
+{
+}
+
+AntEntity *AntEntityPtr::get()
+{
+  assert(p);
+  return p;
+}

Added: antargis/branches/rant/ext/game/entptr.h
===================================================================
--- antargis/branches/rant/ext/game/entptr.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/entptr.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,20 @@
+#ifndef ENTPTR_H
+#define ENTPTR_H
+
+#include "entity.h"
+
+class AntEntityPtr
+{
+ public:
+  AntEntityPtr(const AntEntityPtr &p);
+  AntEntityPtr(AntEntity *p);
+  AntEntityPtr();
+
+  AntEntity *get();
+
+ private:
+  AntEntity *p;
+};
+
+
+#endif

Modified: antargis/branches/rant/ext/game/headers.hh
===================================================================
--- antargis/branches/rant/ext/game/headers.hh	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/headers.hh	2007-06-23 15:07:27 UTC (rev 1105)
@@ -104,15 +104,17 @@
 #include "ext/3dengine/ant_projection.h"
 #include "ext/3dengine/ag_glsl.h"
 #include "/home/david/projects/antargis/rant/ext/game/terrain.h"
+#include "/home/david/projects/antargis/rant/ext/game/entity.h"
 #include "/home/david/projects/antargis/rant/ext/game/height_map.h"
 #include "/home/david/projects/antargis/rant/ext/game/ant_app.h"
+#include "/home/david/projects/antargis/rant/ext/game/minimap.h"
 #include "/home/david/projects/antargis/rant/ext/game/map.h"
-#include "/home/david/projects/antargis/rant/ext/game/entity.h"
 #ifdef SWIG
 %include "/home/david/projects/antargis/rant/ext/game/terrain.h"
+%include "/home/david/projects/antargis/rant/ext/game/entity.h"
 %include "/home/david/projects/antargis/rant/ext/game/height_map.h"
 %include "/home/david/projects/antargis/rant/ext/game/ant_app.h"
+%include "/home/david/projects/antargis/rant/ext/game/minimap.h"
 %include "/home/david/projects/antargis/rant/ext/game/map.h"
-%include "/home/david/projects/antargis/rant/ext/game/entity.h"
 #endif
 #endif

Added: antargis/branches/rant/ext/game/height_map.cc
===================================================================
--- antargis/branches/rant/ext/game/height_map.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/height_map.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,633 @@
+#include "height_map.h"
+#include "terrain.h"
+#include <ag_serial.h>
+#include <ag_main.h>
+#include <ag_rand.h>
+
+//////////////////////////////////////////////////////////////////////////
+// HeightMap
+//////////////////////////////////////////////////////////////////////////
+
+char TerrainNames[][20]={"water","sand","earth","grass","grass2","forest","rock","rock2"};
+
+std::vector<float> genSomeHeights(int mW,int mH,float mMaxHeight);
+
+HeightMap::HeightMap(SceneBase *pScene,int w,int h):
+  sigMapChanged(this,"mapChanged"),
+  sigMapChangedComplete(this,"mapChangedComplete"),
+  mTerrainTypes(LASTTERRAIN+1),
+  mW(w),mH(h),mChangeRect(AGVector2(),AGVector2()),mChanges(0),
+  mScene(pScene)
+  
+{
+  mHeights=genSomeHeights(w+2,h+2,5);
+
+  for(int t=FIRSTTERRAIN;t<LASTTERRAIN; t++)
+    mTerrainTypes[TerrainType(t)]=genSomeHeights(w+2,h+2,1);
+
+  mTerrain=0;
+  //  initTerrainMesh();
+
+
+  setTerrainScale(WATER,0);
+  setTerrainScale(SAND,8/32.0);
+  setTerrainScale(EARTH,12/32.0);
+  setTerrainScale(GRASS,16/32.0);
+  setTerrainScale(GRASS2,20/32.0);
+  setTerrainScale(FOREST,23/32.0);
+  setTerrainScale(ROCK,31/32.0);
+  setTerrainScale(ROCK2,31/32.0);
+}
+
+HeightMap::~HeightMap()
+{
+  saveDelete(mTerrain);
+}
+
+void HeightMap::initTerrainMesh()
+{
+  if(videoInited())
+    mTerrain=new Terrain(mScene,*this);
+}
+
+void HeightMap::setTerrain(TerrainBase *pTerrain)
+{
+  assert(pTerrain);
+  assert(!mTerrain);
+  mTerrain=pTerrain;
+}
+
+
+void HeightMap::setHeight(float height)
+{
+  for(size_t y=0;y<mH+2;y++)
+    for(size_t x=0;x<mW+2;x++)
+      {
+	set(x,y,height);
+	setTerrain(x,y,EARTH,1);
+      }
+
+  mapChanged();
+}
+
+void HeightMap::addChange(const AGVector2 &v)
+{
+  mChanges++;
+  if(mChanges==1)
+    {
+      mChangeRect=AGRect2(v,v);
+    }
+  else
+    mChangeRect.include(v);
+}
+
+AGRect2 HeightMap::getChangeRect() const
+{
+  return mChangeRect;
+}
+
+
+void HeightMap::setTerrain(size_t x,size_t y,TerrainType t,float v)
+{
+  size_t p=x+y*(mW+2);
+
+  //  cdebug(p<<"  "<<EARTH<<" "<<mTerrainTypes[EARTH].size());
+  assert(mTerrainTypes[EARTH].size()>p);
+  mTerrainTypes[t][p]=v;
+  
+  float sum=0;
+  for(int i=FIRSTTERRAIN;i<LASTTERRAIN;i++)
+    {
+      assert(mTerrainTypes[TerrainType(i)].size()>p);
+      if(t!=i)
+	sum+=mTerrainTypes[TerrainType(i)][p];
+    }
+
+  for(int i=FIRSTTERRAIN;i<LASTTERRAIN;i++)
+    if(t!=i)
+      {
+	if(sum==0 || v==1)
+	  mTerrainTypes[TerrainType(i)][p]=0;
+	else
+	  mTerrainTypes[TerrainType(i)][p]=mTerrainTypes[TerrainType(i)][p]/sum*(1-v); // so sum(mTerraintypes[x][.]) == 1
+      }
+  addChange(AGVector2(x,y));
+}
+
+float HeightMap::getTerrain(size_t x,size_t y,TerrainType t) const
+{
+  size_t p=x+y*(mW+2);
+  return const_cast<HeightMap*>(this)->mTerrainTypes[t][p];
+}
+
+
+
+
+void HeightMap::set(size_t x,size_t y,float height)
+{
+  assert(x>=0);
+  assert(y>=0);
+  assert(x<mW+2);
+  assert(y<mH+2);
+  mHeights[x+y*(mW+2)]=height;
+  addChange(AGVector2(x,y));
+}
+
+void HeightMap::loadBinary(BinaryIn &is)
+{
+  CTRACE;
+  //  cdebug("file:"<<pName);
+  //  BinaryFileIn is(pName);
+  float f;
+
+  Uint32 tw,th; // temporary sizes for AMD64
+  is>>tw>>th;
+  mW=tw;
+  mH=th;
+
+  cdebug("mw:"<<mW<<"  "<<mH);
+  //  cdebug("pos:"<<is.pos());
+
+  assert(mW<10000 && mH<10000);
+  
+  
+  mHeights=std::vector<float>(mW*mH*4);
+  for(size_t y=0;y<mH+2;y++)
+    {
+      for(size_t x=0;x<mW+2;x++)
+	{
+	  is>>f;
+	  //	  cdebug(f);
+	  mHeights[x+y*(mW+2)]=f;
+	}
+    }
+
+  for(int i=FIRSTTERRAIN;i<LASTTERRAIN;i++)
+    {
+      mTerrainTypes[TerrainType(i)]=std::vector<float>(mW*mH*4);
+      
+      for(size_t y=0;y<mH+2;y++)
+	{
+	  for(size_t x=0;x<mW+2;x++)
+	    {
+	      is>>f;
+	      mTerrainTypes[TerrainType(i)][x+y*(mW+2)]=f;
+	      addChange(AGVector2(x,y));
+	    }
+	}
+    }
+}
+
+void HeightMap::saveBinary(BinaryOut &os) const
+{
+  CTRACE;
+  //  BinaryFileOut os(pName);
+
+  os<<(Uint32)mW<<(Uint32)mH;
+  //  cdebug("pos:"<<os.pos());
+
+  for(size_t y=0;y<mH+2;y++)
+    {
+      for(size_t x=0;x<mW+2;x++)
+	{
+	  os<<mHeights[x+y*(mW+2)];
+	}
+    }
+  
+  
+  for(int i=FIRSTTERRAIN;i<LASTTERRAIN;i++)
+    {
+      for(size_t y=0;y<mH+2;y++)
+	{
+	  for(size_t x=0;x<mW+2;x++)
+	    {
+	      os<<const_cast<HeightMap*>(this)->mTerrainTypes[TerrainType(i)][x+y*(mW+2)]; // trust me - I'm const
+	    }
+	}
+    }
+}
+
+void HeightMap::loadXML(const Node &node)
+{
+  CTRACE;
+  AGFilename filename=node.get("filename");
+  if(filename.length())
+    {
+      BinaryFileIn is(filename);
+      loadBinary(is);
+    }
+  else
+    {
+      Node::NodeVector nv=node.getChildren("data");
+      if(nv.size())
+	{
+	  AGString c=nv[0]->getContent();
+	  BinaryStringIn is(hexToBinary(c));
+	  loadBinary(is);
+	}
+      else
+	{
+	  mW=node.get("width").toInt();
+	  mH=node.get("height").toInt();
+	  
+	  cdebug("mW:"<<mW);
+	  cdebug("mH:"<<mH);
+	  mHeights=std::vector<float>(mW*mH*4);
+	  
+	  for(int i=FIRSTTERRAIN;i<LASTTERRAIN;i++)
+	    {
+	      mTerrainTypes[TerrainType(i)]=std::vector<float>(mW*mH*4);
+	      cdebug(mW<<"   "<<mH);
+	      cdebug(mTerrainTypes[TerrainType(i)].size());
+	      Node::NodeVector gv=node.getChildren(TerrainNames[i]);
+	      if(gv.size()==0)
+		continue;
+	      Node &g=**gv.begin();
+	      
+	      std::istringstream is(g.getContent());
+	      
+	      float f;
+	      for(size_t y=0;y<mH+2;y++)
+		{
+		  for(size_t x=0;x<mW+2;x++)
+		    {
+		      is>>f;
+		      mTerrainTypes[TerrainType(i)][x+y*(mW+2)]=f;
+		      addChange(AGVector2(x,y));
+		    }
+		}
+	    }
+	  
+	  
+	  Node::NodeVector hv=node.getChildren("height");
+	  
+	  if(hv.size()==0)// || gv.size()==0)
+	    return;
+	  assert(hv.size()==1);
+	  Node &h=**hv.begin();
+	  
+	  
+	  std::istringstream ish(h.getContent());
+	  
+	  float f;
+	  for(size_t y=0;y<mH+2;y++)
+	    {
+	      for(size_t x=0;x<mW+2;x++)
+		{
+		  ish>>f;
+		  mHeights[x+y*(mW+2)]=f;
+		}
+	    }
+	}
+    }
+  
+  checkTerrain();
+  
+  // compete change
+  if(mTerrain)
+    mTerrain->mapChangedComplete();
+  //  mTerrain->addToScenes();
+  mChanges=0;
+  mChangeRect=AGRect2(AGVector2(),AGVector2());
+
+
+  sigMapChangedComplete(new AGEvent(this,"mapChangedComplete"));
+}
+
+void HeightMap::newMap(int w,int h)
+{
+  mW=w;
+  mH=h;
+
+  mHeights=genSomeHeights(w+2,h+2,5);
+
+  for(int t=FIRSTTERRAIN;t<LASTTERRAIN; t++)
+    mTerrainTypes[TerrainType(t)]=genSomeHeights(w+2,h+2,1);
+  
+  checkTerrain();
+
+  // compete change
+  if(mTerrain)
+    mTerrain->mapChangedComplete();
+  //  mTerrain->addToScenes();
+  mChanges=0;
+  mChangeRect=AGRect2(AGVector2(),AGVector2());
+
+}
+
+
+void HeightMap::mapChanged()
+{
+  {
+    CTRACE;
+    sigMapChanged(new AGEvent(this,"mapChanged"));
+  }
+  {
+    CTRACE;
+    //    mTerrain->addToScenes();
+    //    mTerrain->mapChanged();
+    mChanges=0;
+    mChangeRect=AGRect2(AGVector2(),AGVector2());
+  }
+}
+
+
+void HeightMap::saveXML(Node &node) const
+{
+  node.set("width",AGString(mW));
+  node.set("height",AGString(mH));
+  
+  if(false) //(mW<=64 && mH<=64) || mName.length()==0)
+    {
+      AGStringStream osh;
+      osh.precision(2);
+      
+      for(size_t y=0;y<mH+2;y++)
+	{
+	  for(size_t x=0;x<mW+2;x++)
+	    {
+	      osh<<get(x,y)<<" ";
+	    }
+	  osh<<"\n";
+	}
+      node.addChild("height").setContent(osh.str());
+      
+      for(int i=FIRSTTERRAIN;i<LASTTERRAIN;i++)
+	{
+	  std::ostringstream os;
+	  os.precision(2);
+	  for(size_t y=0;y<mH+2;y++)
+	    {
+	      for(size_t x=0;x<mW+2;x++)
+		{
+		  os<<getTerrain(x,y,TerrainType(i))<<" ";
+		}
+	      os<<std::endl;
+	    }
+	  node.addChild(TerrainNames[i]).setContent(AGString(os.str()));
+	  
+	}
+    }
+  else if(false)
+    {
+      std::string name=mName.replace(".antlvl",".hmap");
+      BinaryFileOut os(name);
+      saveBinary(os);
+      node.set("filename",AGString(name));
+    }
+  else
+    {
+      BinaryStringOut os;
+      saveBinary(os);
+      Node &n=node.addChild("data");
+      n.setContent(AGString(binaryToHex(os.getString())));
+    }
+}
+
+
+std::vector<float> genSomeHeights(int mW,int mH,float mMaxHeight)
+{
+  std::vector<float> h(mW*mH);
+
+  for(int i=0;i<mW*mH;i++)
+    h[i]=0;
+  return h;
+  
+  for(int i=0;i<mW*mH;i++)
+    h[i]=agRand(mMaxHeight);
+  
+  int x,y;
+  // blur
+  
+  for(int j=0;j<2;j++) // once
+    for(x=0;x<mW-1;x++)
+      for(y=0;y<mH-1;y++)
+	h[x+y*mW]=(h[x+y*mW]+h[x+y*mW+1]+h[x+(y+1)*mW]+h[x+1+(y+1)*mW])/4;
+  
+  
+  return h;
+}
+
+float HeightMap::get(size_t x,size_t y) const
+{
+  assert(x>=0);
+  assert(y>=0);
+  if(x>=mW+2)
+    cdebug("x:"<<x<<"  mW:"<<mW);
+  assert(x<mW+2);
+  if(y>=mH+2)
+    cdebug("y:"<<y);
+  assert(y<mH+2);
+  return mHeights[x+y*(mW+2)];
+}
+
+AGVector4 HeightMap::getVertex(int x,int y)
+{
+  return AGVector4(x,y,getHeight(x,y),1);
+}
+
+float HeightMap::getHeight(float x,float y) const
+{
+  int mx=(int)(x);
+  int my=(int)(y);
+
+  float dx=x-mx;
+  float dy=y-my;
+
+  float a0=get(mx,my);
+  float a1=get(mx+1,my);
+  float a2=get(mx,my+1);
+  float a3=get(mx+1,my+1);
+
+  float h=(a0*(1-dx)+a1*dx)*(1-dy)+(a2*(1-dx)+a3*dx)*dy;
+  return h;
+
+}
+
+AGVector3 HeightMap::getNormalF(float x,float y) const
+{
+  AGVector4 v1,v2;
+  if(x>2)
+    v1=AGVector4(1,0,getHeight(x,y)-getHeight(x-1,y),0);
+  else
+    v1=AGVector4(1,0,getHeight(x+1,y)-getHeight(x,y),0);
+
+  if(y>2)
+    v2=AGVector4(0,1,getHeight(x,y)-getHeight(x,y-1),0);
+  else
+    v2=AGVector4(0,1,getHeight(x,y+1)-getHeight(x,y),0);
+  
+  AGVector4 v3=v1%v2;
+  v3.normalize3();
+
+  return AGVector3(v3[0],v3[1],v3[2]);
+}
+
+
+AGVector3 HeightMap::getNormal(int x,int y) const
+{
+  AGVector4 v1=AGVector4(1,0,get(x+1,y)-get(x,y),0);
+  AGVector4 v2=AGVector4(0,1,get(x,y+1)-get(x,y),0);
+  
+  AGVector4 v3=v1%v2;
+  v3.normalize3();
+  //  v3*=-1;
+  return AGVector3(v3[0],v3[1],v3[2]);
+}
+
+AGVector2 HeightMap::truncPos(const AGVector2 &p) const
+{
+  AGVector2 maxPos(mW+0.5,mH+0.5);
+  return AGVector2(std::max(0.0f,std::min(maxPos[0],p[0])),
+		   std::max(0.0f,std::min(maxPos[1],p[1])));
+}
+
+AGVector3 HeightMap::truncPos(const AGVector3 &p) const
+{
+  AGVector2 maxPos(mW+0.5,mH+0.5);
+  return AGVector3(std::max(0.0f,std::min(maxPos[0],p[0])),
+		   std::max(0.0f,std::min(maxPos[1],p[1])),
+		   p[2]);
+}
+
+void HeightMap::setTerrainScale(TerrainType t,float s)
+{
+  mTerrainScale[t]=s;
+}
+
+float HeightMap::getTerrainValue(float x,float y,TerrainType t)
+{
+  int mx=(int)(x);
+  int my=(int)(y);
+
+  float dx=x-mx;
+  float dy=y-my;
+
+  float a0=getTerrain(mx,my,t);
+  float a1=getTerrain(mx+1,my,t);
+  float a2=getTerrain(mx,my+1,t);
+  float a3=getTerrain(mx+1,my+1,t);
+
+  float h=(a0*(1-dx)+a1*dx)*(1-dy)+(a2*(1-dx)+a3*dx)*dy;
+  return h;
+}
+
+TerrainType HeightMap::getTerrain(float x,float y)
+{
+  TerrainType t=FIRSTTERRAIN;
+  float mmax=0.0f;
+  for(int i=FIRSTTERRAIN;i<LASTTERRAIN;i++)
+    {
+      float v=getTerrainValue(x,y,TerrainType(i));
+      if(v>mmax)
+	{
+	  t=TerrainType(i);
+	  mmax=v;
+	}
+    }
+  return t;
+}
+
+// mean value
+float HeightMap::getTerrainWeight(float x,float y)
+{
+  float mean=0;
+  for(int i=FIRSTTERRAIN;i<LASTTERRAIN;i++)
+    {
+      float v=getTerrainValue(x,y,TerrainType(i));
+      mean+=v*i;
+    }
+  return mean/(LASTTERRAIN-FIRSTTERRAIN);
+}
+
+float HeightMap::getMean(float x,float y)
+{
+  float mean=0;
+  for(int i=FIRSTTERRAIN;i<LASTTERRAIN;i++)
+    {
+      float v=getTerrainValue(x,y,TerrainType(i));
+      mean+=v*mTerrainScale[TerrainType(i)];
+    }
+  return mean;
+
+}
+
+
+float HeightMap::getTerrainScale(float x,float y)
+{
+  TerrainType t=getTerrain(x,y),t2;
+
+  float mean=getTerrainWeight(x,y);
+
+  if(mean<t)
+    {
+      t2=TerrainType(t-1);
+    }
+  else
+    t2=TerrainType(t+1);
+
+  float s1=mTerrainScale[t];
+  float s2=mTerrainScale[t2];
+
+  mean=fabs(std::max(std::min(mean,1.0f),-1.0f));
+
+  //  cdebug(mean);
+  float w=0;
+  return getMean(x,y)*(1-w)+s1*w;
+
+  return s1*(1-mean)+s2*mean;
+}
+
+SceneBase *HeightMap::getScene()
+{
+  return mScene;
+}
+
+AGVector2 HeightMap::getNextPlaceAbove(const AGVector2 &p,float height) const
+{
+  int x=(int)p[0];
+  int y=(int)p[1];
+  int d;
+  float maxh=height;
+  AGVector2 found(x,y);
+
+  for(d=0;d<5;d++)
+    {
+      for(int i=-d;i<=d;i++)
+	{
+	  std::vector<AGVector2> p;
+	  p.push_back(AGVector2(i,y-d));
+	  p.push_back(AGVector2(i,y+d));
+	  p.push_back(AGVector2(x-d,i));
+	  p.push_back(AGVector2(x+d,i));
+	  for(std::vector<AGVector2>::iterator k=p.begin();k!=p.end();++k)
+	    {
+	      if((*k)[0]<0 || (*k)[0]>mW || (*k)[1]<0 || (*k)[1]>mH)
+		continue;
+	      cdebug((*k)[0]<<"  "<<(*k)[1]<<" "<<x<<" "<<y<<" "<<i<<" "<<d);
+	      float h=getHeight((*k)[0],(*k)[1]);
+	      if(h>maxh)
+		{
+		  maxh=h;
+		  found=*k;
+		}
+	    }
+	}
+
+      if(maxh>height)
+	break;
+    }
+  return found;
+}
+
+void HeightMap::mark()
+{
+  if(mTerrain)
+    markObject(mTerrain);
+}
+
+void HeightMap::checkTerrain()
+{
+  if(!mTerrain)
+    initTerrainMesh();
+}

Added: antargis/branches/rant/ext/game/height_map.h
===================================================================
--- antargis/branches/rant/ext/game/height_map.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/height_map.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,124 @@
+#ifndef HEIGHT_MAP_H
+#define HEIGHT_MAP_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include "scene.h"
+#include <ag_geometry.h>
+#include <ag_xml.h>
+#include "entptr.h"
+#include <ag_messageobject.h>
+#include <ag_serial.h>
+
+class AntEntity;
+class AntEntityPtr;
+class Scene;
+class Mesh;
+class TerrainBase;
+
+enum TerrainType { WATER=0, SAND, EARTH, GRASS, GRASS2, FOREST, ROCK, ROCK2, LASTTERRAIN};
+
+#define FIRSTTERRAIN WATER
+
+class HeightMap:public AGMessageObject
+{
+ public:
+  HeightMap(SceneBase *pScene,int w,int h);
+  virtual ~HeightMap();
+
+  // get status
+
+  AGVector2 getNextPlaceAbove(const AGVector2 &p,float height) const;
+
+  float getHeight(float x,float y) const;
+  AGVector3 getNormal(int x,int y) const;
+  AGVector3 getNormalF(float x,float y) const;
+  AGVector4 getVertex(int x,int y);
+  float get(size_t x,size_t y) const;
+  //float getGrass(size_t x,size_t y) const;
+
+  void setTerrain(size_t x,size_t y,TerrainType t,float v);
+  float getTerrain(size_t x,size_t y,TerrainType t) const;
+
+  float getMean(float x,float y);
+  size_t getW() const
+  {
+    return mW;
+  }
+  size_t getH() const
+  {
+    return mH;
+  }
+
+  // truncate pos at borders
+  AGVector2 truncPos(const AGVector2 &p) const;
+  AGVector3 truncPos(const AGVector3 &p) const;
+
+  // save load
+  virtual void saveXML(Node &node) const;
+  virtual void loadXML(const Node &node);
+
+  // editing
+  void setHeight(float height); // for whole plane
+  void set(size_t x,size_t y,float height);
+
+  virtual void mapChanged();  
+
+
+  void setTerrainScale(TerrainType t,float s);
+  float getTerrainValue(float x,float y,TerrainType t);
+  TerrainType getTerrain(float x,float y);
+  float getTerrainWeight(float x,float y);
+  float getTerrainScale(float x,float y);
+
+
+  void addChange(const AGVector2 &v);
+
+  AGRect2 getChangeRect() const;
+
+  virtual void newMap(int w,int h);
+
+  AGSignal sigMapChanged;
+  AGSignal sigMapChangedComplete;
+
+  SceneBase *getScene();
+
+  /// override this function to include another terrain-mesh-type (like 2d-terrain)
+  virtual void initTerrainMesh();
+
+  void mark();
+
+  /// to be used by initTerrainMesh() - not otherwise !!!
+  void setTerrain(TerrainBase *pTerrain);
+
+ private:
+
+  void checkTerrain();
+
+  void loadBinary(BinaryIn &s);
+  void saveBinary(BinaryOut &s) const;
+
+
+  std::vector<float> mHeights;
+
+
+  std::map<TerrainType,float> mTerrainScale;
+
+  // sum of all should be one - or at least they get normalized to 1 and then the heighest is chosen and weighted with the mean value
+  //std::map<TerrainType,std::vector<float> > mTerrainTypes;
+  std::vector<std::vector<float> > mTerrainTypes;
+
+  size_t mW,mH;
+
+  AGRect2 mChangeRect;
+  size_t mChanges;
+
+  SceneBase *mScene;
+
+ protected:
+
+  TerrainBase *mTerrain;
+  AGString mName;
+};
+
+#endif

Added: antargis/branches/rant/ext/game/heuristic.cc
===================================================================
--- antargis/branches/rant/ext/game/heuristic.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/heuristic.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,78 @@
+#include "heuristic.h"
+#include <ag_debug.h>
+
+
+HeuristicFunction::Output HeuristicFunction::operator()(const Input &input) 
+{
+  return (input.second-input.first).length()*1.5;
+}
+
+
+StoredHeuristicFunction::StoredHeuristicFunction(size_t res,float width):
+  a(res*res*res*res),
+  r(res),
+  w(width)
+{
+}
+
+void StoredHeuristicFunction::store(Input in,Output out)
+{
+  size_t i=getIndex(in);
+  //  cdebug("index:"<<i);
+  //  cdebug("value:"<<out);
+  a[i]=out;
+}
+
+StoredHeuristicFunction::Output StoredHeuristicFunction::operator()(const Input &input)
+{
+  size_t i=getIndex(input);
+  //  cdebug("index:"<<i);
+  float v=a[i];
+  //  cdebug("value:"<<v);
+
+  return v*6;
+}
+
+size_t StoredHeuristicFunction::getIndex(const Input &in)
+{
+  size_t a,b,c,d;
+
+  //  cdebug(in.first<<":::"<<in.second);
+
+  a=in.first[0]*r/w;
+  b=in.first[1]*r/w;
+  c=in.second[0]*r/w;
+  d=in.second[1]*r/w;
+
+  a=std::min(a,r-1);
+  b=std::min(b,r-1);
+  c=std::min(c,r-1);
+  d=std::min(d,r-1);
+
+  assert(a<r);
+  assert(b<r);
+  assert(c<r);
+  assert(d<r);
+
+  size_t i=((a*r+b)*r+c)*r+d;
+
+  //  cdebug(i);
+  return i;
+}
+
+
+void StoredHeuristicFunction::display()
+{
+  for(int a=0;a<r;a++)
+    for(int b=0;b<r;b++)
+      for(int c=0;c<r;c++)
+	for(int d=0;d<r;d++)
+	  {
+	    AGVector2 p0(a*w/r,b*w/r);
+	    AGVector2 p1(c*w/r,d*w/r);
+
+	    float value=operator()(std::make_pair(p0,p1));
+	    if(value>0)
+	      std::cout<<a<<","<<b<<","<<c<<","<<d<<":"<<value<<std::endl;
+	  }
+}

Added: antargis/branches/rant/ext/game/heuristic.h
===================================================================
--- antargis/branches/rant/ext/game/heuristic.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/heuristic.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,40 @@
+#ifndef HEURISTIC_H
+#define HEURISTIC_H
+
+#include <ag_geometry.h>
+
+class HeuristicFunction
+{
+ public:
+  typedef std::pair<AGVector2,AGVector2> Input;
+  typedef float Output;
+
+  virtual ~HeuristicFunction()
+    {
+    }
+
+  virtual Output operator()(const Input &input);
+};
+
+class StoredHeuristicFunction:public HeuristicFunction
+{
+  // FIXME: maybe store measure-count, too - and average!!!
+
+  std::vector<float> a;
+  size_t r;
+  float w;
+ public:
+  StoredHeuristicFunction(size_t res,float width);
+
+  void store(Input in,Output out);
+
+  void display();
+
+  virtual Output operator()(const Input &input);
+ private:
+  size_t getIndex(const Input &in);
+};
+
+
+#endif
+

Added: antargis/branches/rant/ext/game/jobs.cc
===================================================================
--- antargis/branches/rant/ext/game/jobs.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/jobs.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,486 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * jobs.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "jobs.h"
+#include "entity.h"
+#include "map.h"
+#include <math.h>
+
+
+#define WATER_MARK -0.2
+
+Job::Job():priority(0),inited(false)
+{
+}
+
+Job::Job(int p):priority(p),inited(true)
+{}
+
+bool Job::valid() const
+{
+  return inited;
+}
+
+void Job::move(AntEntity *,float ptime)
+{}
+
+bool Job::operator<=(const Job &j) const
+{
+  return priority<=j.priority;
+}
+
+Job::~Job()
+{
+}
+
+void Job::jobFinished(AntEntity *e)
+{
+  e->sigJobFinished();
+}
+
+bool Job::needsMorale() const
+{
+  return false;
+}
+
+void Job::saveXML(Node &pNode) const
+{
+  pNode.set("priority",AGString(priority));
+}
+void Job::loadXML(const Node &pNode)
+{
+  if(pNode.get("priority").length())
+    priority=pNode.get("priority").toInt();
+  inited=true;
+}
+
+AGString Job::xmlName() const
+{
+  return "antJob";
+}
+
+
+/************************************************************************
+* MoveJob
+************************************************************************/
+
+MoveJob::MoveJob():
+  mTargetEntity(0)
+{
+}
+
+MoveJob::MoveJob(int p,AntEntity *pTarget,float pNear,bool pRun):Job(p),mTargetEntity(pTarget),mNear(pNear),mRun(pRun)
+{
+  assert(mTargetEntity);
+  m3d=false;
+  // speed=70; // pixels per second
+  //  runSpeed=100;
+}
+
+MoveJob::MoveJob(int p,const AGVector2 &pTarget,float pNear,bool pRun):Job(p),mTarget(getMap()->truncPos(pTarget)),mTargetEntity(0),mNear(pNear),mRun(pRun)
+{
+  m3d=false;
+  // speed=70; // pixels per second
+  //  runSpeed=100;
+}
+
+MoveJob::MoveJob(int p,const AGVector3 &pTarget,float pNear,bool pRun):Job(p),mTarget3(pTarget),mTargetEntity(0),mNear(pNear),mRun(pRun)
+{
+  m3d=true;
+  // speed=70; // pixels per second
+  //  runSpeed=100;
+}
+
+
+MoveJob::~MoveJob()
+{
+}
+
+// Jobs
+void MoveJob::move(AntEntity *e,float ptime)
+{
+  float aspeed;
+  float speed=e->getSpeed();
+
+  if(mTargetEntity)
+    {
+      mTarget=mTargetEntity->getPos2D();
+      mTarget3=mTargetEntity->getPos3D();
+    }
+ 
+#ifdef ENABLE_RUNNING  
+  float runSpeed=speed*1.3;
+
+  if(mRun && e->getCondition()>0.0)
+  {
+    // decrease condition and if condition is zero - switch of running
+    float newtime=e->decCondition(ptime);
+    moveBy(e,ptime-newtime,runSpeed);// take same runSpeed always
+    
+    ptime=newtime;
+  }
+#endif
+  aspeed=0.5*speed+0.5*e->getEnergy()*speed;
+  assert(this);
+  moveBy(e,ptime,aspeed); // use rest of time
+  assert(this);
+  
+}
+
+AGVector2 MoveJob::getDirection(const AntEntity *e) const
+{
+  return (mTarget-e->getPos2D()).normalized();
+}
+
+
+void MoveJob::moveBy(AntEntity *e,float ptime,float aspeed)
+{
+  float d0=getMap()->getPos(e->getPos2D())[2];
+
+  if(d0<WATER_MARK && e->isOnGround())
+    {
+      e->eventHitWaterMark(true);
+      return; // do nothing
+    }
+  else if(d0>WATER_MARK && e->isOnWater())
+    {
+      e->eventHitWaterMark(false);
+      return; // do nothing
+    }
+
+  AGVector3 oldPos=e->getPos3D();
+
+  if(m3d)
+    {
+      AGVector3 diff=e->getPos3D()-mTarget3;
+      float norm=diff.length();
+
+      if(norm-mNear>ptime*aspeed)
+	{
+	  diff=diff.normalized();
+	  e->setDirection(-diff.getAngle().angle*180.0/M_PI);
+	  e->setPos(e->getPos3D()-diff*ptime*aspeed);
+	}
+      else
+	{
+	  if(norm>mNear)
+	    e->setPos(mTarget3+diff.normalized()*mNear);
+	  e->setDirection(-diff.dim2().getAngle().angle*180.0/M_PI);
+	  jobFinished(e);
+	}
+
+    }
+  else
+    {
+      AGVector2 diff=e->getPos2D()-mTarget;
+      float norm=diff.length();
+      
+      if(norm-mNear>ptime*aspeed)
+	{
+	  diff=diff.normalized();
+	  e->setDirection(-diff.getAngle().angle*180.0/M_PI);
+	  e->setPos(e->getPos2D()-diff*ptime*aspeed);
+	}
+      else
+	{
+	  if(norm>mNear)
+	    e->setPos(mTarget+diff.normalized()*mNear);
+	  e->setDirection(-diff.getAngle().angle*180.0/M_PI);
+	  jobFinished(e);
+	}
+    }
+
+
+  float d1=getMap()->getPos(e->getPos2D())[2];
+  /*  if(d0<WATER_MARK && d1>WATER_MARK)
+    e->eventHitWaterMark(false);
+  else if(d0>WATER_MARK && d1<WATER_MARK)
+    e->eventHitWaterMark(true);
+  */
+
+  bool resetPos=false;
+
+  if(d1<WATER_MARK && e->isOnGround())
+    {
+      if(!e->eventHitWaterMark(true))
+	resetPos=true;
+    }
+  else if(d1>WATER_MARK && e->isOnWater())
+    {
+      if(!e->eventHitWaterMark(false))
+	resetPos=true;
+    }
+  if(resetPos)
+    e->setPos(oldPos);
+
+}
+
+void MoveJob::saveXML(Node &pNode) const
+{
+  Job::saveXML(pNode);
+  pNode.set("pos",mTarget.toString());
+  pNode.set("near",AGString(mNear));
+  pNode.set("run",mRun?"true":"false");
+}
+void MoveJob::loadXML(const Node &pNode)
+{
+  Job::loadXML(pNode);
+  if(pNode.get("pos").length())
+    mTarget=AGVector2(pNode.get("pos"));
+  if(pNode.get("near").length())
+    mNear=pNode.get("near").toFloat();
+  if(pNode.get("run").length())
+    mRun=pNode.get("run")=="true";
+}
+AGString MoveJob::xmlName() const
+{
+  return "moveJob";
+}
+
+
+
+/************************************************************************
+* FightJob
+************************************************************************/
+
+FightJob::FightJob():mTarget(0),mTargetID(-1)
+{
+}
+
+FightJob::FightJob(int p,AntEntity *pTarget,float pDistance):Job(p),mTarget(pTarget)
+{
+  fightDistance=pDistance;
+  moving=true;
+}
+
+FightJob::~FightJob()
+{
+}
+
+bool FightJob::needsMorale() const
+{
+  return true;
+}
+
+void FightJob::move(AntEntity *e,float ptime)
+{
+  if(mTarget==0)
+    {
+      mTarget=getMap()->getEntity(mTargetID);
+      if(!mTarget)
+	{
+	  cdebug("Could not find id:"<<mTargetID);
+	}
+      assert(mTarget);
+    }
+
+  if(e->getEnergy()<0)
+    throw std::runtime_error("Problem: fighting, but I'm alread dead!");
+    
+  if(mTarget->defeated())
+    {
+      // already died - so no sigDefeated
+      e->eventHaveDefeated(mTarget);
+      jobFinished(e);
+      return; // early out
+    }
+
+  if(mTarget->getEnergy()<=0.0)
+    {
+      // already died - so no sigDefeated
+      e->eventHaveDefeated(mTarget);
+      jobFinished(e);
+      return; // early out
+    }
+  else if(mTarget->getMorale()<0.1)
+    {
+      mTarget->sigDefeated();
+      e->eventHaveDefeated(mTarget);
+      jobFinished(e);
+      return; // early out
+    }
+  // if target is too far away run there, otherwise fight
+  AGVector2 diff=e->getPos2D()-mTarget->getPos2D();
+  float norm=diff.length();
+  float speed=e->getSpeed();
+
+
+  e->setDirection(-diff.getAngle().angle*180.0/M_PI);
+
+  if(norm-fightDistance>ptime*speed)
+    {
+      // run
+      diff=diff.normalized();
+      e->setPos(e->getPos2D()-diff*ptime*speed);
+      //    e->setDirection(-diff.getAngle().angle*180.0/M_PI);
+      if(!moving)
+	{
+	  e->eventStartMoving();
+	  moving=true;
+	}
+    }
+  else
+    {
+      // fight
+      mTarget->decEnergy(ptime*e->getStrength()*e->getAggression()/mTarget->getDefense());
+      mTarget->decMorale(ptime*e->getMoraleStrength()/mTarget->getDefense()); // FIXME: estimate this value
+      mTarget->eventGotFight(e);
+
+      e->incExperience(ptime*e->learnAmount);
+      if(moving)
+	{
+	  e->eventStartFighting();
+	  moving=false;
+	}
+
+    }
+}
+
+void FightJob::saveXML(Node &pNode) const
+{
+  Job::saveXML(pNode);
+  pNode.set("target",AGString(mTarget->getID()));
+  pNode.set("distance",AGString(fightDistance));
+  pNode.set("moving",moving?"true":"false");
+}
+void FightJob::loadXML(const Node &pNode)
+{
+  Job::loadXML(pNode);
+  if(pNode.get("target").length())
+    {
+      mTarget=0;
+      mTargetID=pNode.get("target").toInt();
+    }
+
+  if(pNode.get("distance").length())
+    fightDistance=pNode.get("distance").toFloat();
+  if(pNode.get("moving").length())
+    moving=pNode.get("moving")=="true";
+}
+AGString FightJob::xmlName() const
+{
+  return "fightJob";
+}
+
+
+/***************************************************************************
+ *
+ ***************************************************************************/
+
+FetchJob::FetchJob():
+  mTarget(0)
+{
+}
+
+FetchJob::FetchJob(int p,const AGVector2&pTarget,AGString what):MoveJob(p,pTarget,0.5),mWhat(what),mTarget(0)
+{
+}
+FetchJob::FetchJob(int p,AntEntity *pTarget,AGString what):MoveJob(p,pTarget->getPos2D(),0.5),mWhat(what),mTarget(pTarget)
+{
+}
+
+
+FetchJob::~FetchJob()
+{
+}
+void FetchJob::move(AntEntity *e,float ptime)
+{
+  MoveJob::move(e,ptime);
+}
+
+void FetchJob::jobFinished(AntEntity *e)
+{
+  e->resource.add(mWhat,1);
+  e->resourceChanged();
+  MoveJob::jobFinished(e);
+
+  if(mTarget)
+    {
+      mTarget->resource.sub(mWhat,1);
+      mTarget->resourceChanged();
+    }
+}
+
+void FetchJob::saveXML(Node &pNode) const
+{
+  MoveJob::saveXML(pNode);
+  pNode.set("target",AGString(mTarget->getID()));
+  pNode.set("what",AGString(mWhat));
+}
+void FetchJob::loadXML(const Node &pNode)
+{
+  MoveJob::loadXML(pNode);
+  if(pNode.get("target").length())
+    {
+      mTarget=0;
+      mTargetID=pNode.get("target").toInt();
+    }
+
+  if(pNode.get("what").length())
+    mWhat=pNode.get("what");
+
+}
+AGString FetchJob::xmlName() const
+{
+  return "fetchJob";
+}
+
+
+/***************************************************************************
+ *
+ ***************************************************************************/
+
+RestJob::RestJob():mTime(0)
+{
+}
+
+RestJob::RestJob(float pTime):Job(0),mTime(pTime)
+{
+}
+RestJob::~RestJob()
+{
+}
+void RestJob::move(AntEntity *e,float ptime)
+{
+  e->incMorale(std::min(ptime,mTime));
+  e->heal(std::min(ptime,mTime));
+  mTime-=ptime;
+  if(mTime<0)
+    jobFinished(e);
+}
+
+void RestJob::saveXML(Node &pNode) const
+{
+  Job::saveXML(pNode);
+
+  pNode.set("time",AGString(mTime));
+}
+void RestJob::loadXML(const Node &pNode)
+{
+  Job::loadXML(pNode);
+
+  if(pNode.get("time").length())
+    mTime=pNode.get("time").toFloat();
+}
+AGString RestJob::xmlName() const
+{
+  return "restJob";
+}
+

Added: antargis/branches/rant/ext/game/jobs.h
===================================================================
--- antargis/branches/rant/ext/game/jobs.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/jobs.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,144 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * jobs.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef ANT_JOBS_H
+#define ANT_JOBS_H
+#include <ag_geometry.h>
+
+class AntEntity;
+
+/**
+   Job class won't be exported to Ruby, because their constant
+   creation and deletion fills up the GC otherwise.
+*/
+class Job
+{
+  int priority;
+  bool inited;
+ public:
+  Job();
+  Job(int p);
+  virtual ~Job();
+  virtual void move(AntEntity *,float ptime);
+
+  virtual void saveXML(Node &pNode) const;
+  virtual void loadXML(const Node &pNode);
+
+  virtual AGString xmlName() const;
+
+  virtual void jobFinished(AntEntity *e);
+  bool operator<=(const Job &j) const;
+
+  virtual bool needsMorale() const;
+
+  bool valid() const;
+};
+
+class RestJob:public Job
+{
+  float mTime;
+ public:
+  RestJob();
+  RestJob(float pTime);
+  virtual ~RestJob();
+  void move(AntEntity *e,float ptime);
+
+  virtual void saveXML(Node &pNode) const;
+  virtual void loadXML(const Node &pNode);
+  virtual AGString xmlName() const;
+
+};
+
+class MoveJob:public Job
+{
+  AGVector2 mTarget;
+  AGVector3 mTarget3;
+  AntEntity *mTargetEntity;
+  float mNear;
+  bool mRun;
+
+  bool m3d;
+ public:
+  MoveJob();
+  MoveJob(int p,AntEntity *pTarget,float pnear=0,bool pRun=false);
+  MoveJob(int p,const AGVector2 &pTarget,float pnear=0,bool pRun=false);
+  MoveJob(int p,const AGVector3 &pTarget,float pnear=0,bool pRun=false);
+  virtual ~MoveJob();
+  void move(AntEntity *e,float ptime);
+  AGVector2 getDirection(const AntEntity *e) const;
+  
+  virtual void saveXML(Node &pNode) const;
+  virtual void loadXML(const Node &pNode);
+  virtual AGString xmlName() const;
+
+  AntEntity *getTarget()
+    {
+      return mTargetEntity;
+    }
+  
+ private:
+  void moveBy(AntEntity *e,float ptime,float aspeed);
+};
+
+// FIXME: implement near and far fighting (arrows)
+class FightJob:public Job
+{
+  AntEntity *mTarget;
+  float fightDistance;
+  bool moving;
+  int mTargetID;
+  
+ public:
+  FightJob();
+  FightJob(int p,AntEntity *pTarget, float pDistance=1);
+  
+  virtual ~FightJob();
+  void move(AntEntity *e,float ptime);
+  virtual bool needsMorale() const;
+  AntEntity *getTarget()
+    {
+      return mTarget;
+    }
+  
+  virtual void saveXML(Node &pNode) const;
+  virtual void loadXML(const Node &pNode);
+  virtual AGString xmlName() const;
+  
+};
+
+class FetchJob:public MoveJob
+{
+  AGString mWhat;
+  AntEntity *mTarget;
+  int mTargetID;
+ public:
+  FetchJob();
+  FetchJob(int p,const AGVector2 &pTarget,AGString what);
+  FetchJob(int p,AntEntity *pTarget,AGString what);
+  virtual ~FetchJob();
+  void move(AntEntity *e,float ptime);
+  virtual void jobFinished(AntEntity *e);
+  
+  virtual void saveXML(Node &pNode) const;
+  virtual void loadXML(const Node &pNode);
+  virtual AGString xmlName() const;
+};
+
+#endif

Added: antargis/branches/rant/ext/game/map.cc
===================================================================
--- antargis/branches/rant/ext/game/map.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/map.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,475 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * map.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "scene.h"
+#include "ag_rand.h"
+#include "map.h"
+#include "entity.h"
+#include <vector>
+#include <math.h>
+#include <ag_debug.h>
+#include "mesh.h"
+#include "terrain.h"
+#include "quadtree.h"
+#include "anim_mesh.h"
+#include "mesh_2d.h"
+#include "ag_profiler.h"
+
+
+
+//////////////////////////////////////////////////////////////////////////
+// AntMap
+//////////////////////////////////////////////////////////////////////////
+
+AntMap *myAntargisMap=0;
+AntMap *getMap()
+{
+  assert(myAntargisMap);
+  return myAntargisMap;
+}
+
+AntMap::AntMap(SceneBase *pScene,int w,int h):
+  HeightMap(pScene,w,h),
+  mEntQuad(new QuadTree<AntEntity>(AGRect2(0,0,w,h))),
+  mHeuristicFunction(0)
+{
+  myAntargisMap=this;
+  maxID=0;
+}
+AntMap::~AntMap()
+{
+  CTRACE;
+  printf("%lX\n",mRUBY);
+  if(myAntargisMap==this)
+    myAntargisMap=0;
+}
+
+AGVector3 AntMap::getPos(const AGVector2 &pPos) const
+{
+  return AGVector3(pPos[0],pPos[1],getHeight(pPos[0],pPos[1]));
+}
+
+
+
+AntEntity *AntMap::getEntity(int id) const
+{
+  EntityMap::const_iterator i=mEntityMap.find(id);
+  if(i==mEntityMap.end())
+    return 0;
+  return i->second;
+}
+
+// FIXME: exchange this function somehow!!
+int AntMap::getNewID()
+{
+  return maxID++;
+}
+
+void AntMap::useID(int id)
+{
+  maxID=std::max(maxID,id+1);
+}
+
+
+void AntMap::saveXML(Node &node) const
+{
+  HeightMap::saveXML(node);
+  
+  // entities
+  std::list<AntEntity*>::const_iterator i=mEntities.begin();
+  for(;i!=mEntities.end();i++)
+    {
+      Node &child=node.addChild((*i)->xmlName());
+      (*i)->saveXML(child);
+    }
+  
+}
+
+
+void AntMap::loadXML(const Node &node)
+{
+  HeightMap::loadXML(node);
+
+  Node::const_iterator i=node.begin();
+  for(;i!=node.end();i++)
+    {
+      //      AntEntity *e=0;
+      Node *n=*i;
+      processXMLNode(*n);
+      /*        {
+	  e->loadXML(*n);
+	  insertEntity(e);
+	  }*/
+    }
+  // tell entities, that map has changed
+  std::list<AntEntity*>::iterator k=mEntities.begin();
+  for(;k!=mEntities.end();k++)
+    (*k)->eventMapChanged();
+}
+
+void AntMap::insertEntity(AntEntity *e)
+{
+  //  cdebug("INSERTING:"<<e);
+  mEntities.push_back(e);
+  //  mEntList.push_back(e);
+  mEntityMap[e->getID()]=e;
+  mEntQuad->insert(e);
+  //  entsChanged();
+  //  mByType[e->getType()].insert(e);
+}
+
+void AntMap::removeEntity(AntEntity *p)
+{
+  {
+    EntityList::iterator i=std::find(mToDel.begin(),mToDel.end(),p);
+    if(i!=mToDel.end())
+      {
+	cdebug("Entity already deleted:"<<p);
+	return;
+      }
+  }
+
+
+  EntityList::iterator i=std::find(mEntities.begin(),mEntities.end(),p);
+  if(i!=mEntities.end())
+    mToDel.push_back(p);
+  else
+    {
+      cdebug("ERROR: Entity not found while removing:"<<p);
+      //      throw std::runtime_error("ERROR: Entity not found while removing");
+    }
+}
+
+
+void AntMap::move(float pTime)
+{
+  STACKTRACE; 
+  //return;
+  // first remove entities, which shall be deleted
+  std::list<AntEntity*>::iterator d=mToDel.begin();
+  for(;d!=mToDel.end();d++)
+    {
+      EntityList::iterator i=std::find(mEntities.begin(),mEntities.end(),*d);
+      if(i!=mEntities.end())
+	mEntities.erase(i);
+      else
+	cdebug("ERROR: Entity not found while deleting:"<<*d);
+      mEntityMap.erase((*d)->getID());
+      mEntQuad->remove(*i);
+      //      mByType[(*d)->getType()].erase(*d);
+
+      saveDelete(*d);
+    }
+  mToDel.clear();
+
+  // now move all entities
+
+  EntityList::iterator i=mEntities.begin();
+
+  for(;i!=mEntities.end();i++)
+    {
+      (*i)->move(pTime);
+    }
+}
+
+
+void AntMap::processXMLNode(const Node &node)
+{
+  //  AntEntity *e=0;
+  cdebug("type unknown:"<<node.getName());
+  //  return e;
+}
+
+/*std::vector<AntEntityPtr> AntMap::getByType(const AGString &pType)
+{
+  std::vector<AntEntityPtr> l;
+  EntityByType::iterator i=mByType.find(pType);
+  if(i!=mByType.end())
+    {
+      std::copy(i->second.begin(),i->second.end(),std::back_inserter(l));
+    }
+
+  return l;  
+  }*/
+
+
+AntMap::EntityList AntMap::getEntities(const AGRect2&r)
+{
+  return mEntQuad->get(r);
+}
+AntMap::EntityList AntMap::getAllEntities()
+{
+  return mEntities;
+}
+std::vector<AntEntityPtr> AntMap::getAllEntitiesV()
+{
+  std::vector<AntEntityPtr> v;
+  std::copy(mEntities.begin(),mEntities.end(),std::back_inserter(v));
+  return v;
+}
+std::vector<AntEntityPtr> AntMap::getEntities(const AGString &pName)
+{
+  std::vector<AntEntityPtr> v;
+  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+    if((*i)->provides(pName))
+      v.push_back(*i);
+  return v;
+}
+
+std::vector<AntEntityPtr> AntMap::getNextList(AntEntity *me,const AGString &pType,size_t atLeast)
+{
+  //  assert(mHeuristicFunction);
+
+  // FIXME: optimize this - use quadtree
+
+  std::multimap<float,AntEntity*> ents;
+
+
+  EntityList::iterator i=mEntities.begin();
+  AGVector2 p=me->getPos2D(); // FIXME: check for reachability, too ??
+
+  for(;i!=mEntities.end();i++)
+    {
+      if(me!=*i)
+        {
+          if((*i)->provides(pType) && (*i)->resource.get(pType)>=atLeast)
+            {
+	      /*
+              AGVector2 p2=(*i)->getPos2D()-p;
+              float norm=p2.length2();*/
+	      float norm;
+	      if(mHeuristicFunction)
+		norm=(*mHeuristicFunction)(std::make_pair((*i)->getPos2D(),p));
+	      else
+		norm=((*i)->getPos2D()-p).length2();
+              ents.insert(std::make_pair(norm,*i));
+            }
+        }
+    }
+
+  std::vector<AntEntityPtr> vec;
+
+  // take one of the nearest, but no farer away than 30% of nearest
+  //  AntEntity *e=0;
+  if(ents.size())
+    {
+      std::multimap<float,AntEntity*>::iterator j=ents.begin();
+      float nearest=j->first;
+      for(;j!=ents.end();j++)
+	{
+	  if(j->first<=nearest*1.3)
+	    vec.push_back(j->second);
+	}
+    }
+
+  return vec;
+}
+
+
+AntEntity *AntMap::getNext(AntEntity *me,const AGString &pType,size_t atLeast)
+{
+  //  assert(mHeuristicFunction);
+  // FIXME: optimize this - use quadtree
+
+  std::multimap<float,AntEntity*> ents;
+
+
+  EntityList::iterator i=mEntities.begin();
+  AGVector2 p=me->getPos2D(); // FIXME: check for reachability, too ??
+  //  float dist=0;
+
+  for(;i!=mEntities.end();i++)
+    {
+      if(me!=*i)
+        {
+          if((*i)->provides(pType) && (*i)->resource.get(pType)>=atLeast)
+            {
+	      //              AGVector2 p2=(*i)->getPos2D()-p;
+	      float norm;
+
+	      if(mHeuristicFunction)
+	        norm=(*mHeuristicFunction)(std::make_pair((*i)->getPos2D(),p));
+	      else
+		norm=((*i)->getPos2D()-p).length2();
+	      cdebug("norm:"<<norm<<" i:"<<*i<<" name:"<<(*i)->getName());
+	      //              float norm=p2.length2();
+              ents.insert(std::make_pair(norm,*i));
+            }
+        }
+    }
+
+
+  // take one of the nearest, but no farer away than 30% of nearest
+  AntEntity *e=0;
+  if(ents.size())
+    {
+      std::multimap<float,AntEntity*>::iterator j=ents.begin();
+      float nearest=j->first;
+      int r=agRand(std::min((int)ents.size(),5));
+      while(r>0 && (j->first<=nearest*1.3 || j->first<2000*2000))
+        {
+          j++;
+          r--;
+        }
+      if(r>0)
+        j--;
+      assert((j!=ents.end()));
+      e=j->second;
+      //      cdebug("DIST:"<<j->first);
+    }
+
+  return e;
+}
+
+void AntMap::setHeuristic(HeuristicFunction *pFunction)
+{
+  mHeuristicFunction=pFunction;
+}
+
+
+AntEntity *AntMap::getByName(const AGString &pName)
+{
+  EntityList::iterator i=mEntities.begin();
+
+  for(;i!=mEntities.end();i++)
+    {
+      if((*i)->getName()==pName)
+        return *i;
+    }
+  return 0;
+}
+
+void AntMap::loadMapFromMemory(const AGData &pMem)
+{
+  if(pMem.length())
+    {
+      Document d;
+      d.parseMemory(pMem);
+      loadXML(d.root());
+    }
+}
+
+void AntMap::loadMap(const AGFilename &pFilename)
+{
+  
+  loadMapFromMemory(loadFile(pFilename));
+}
+void AntMap::saveMap(const AGFilename &pFilename)
+{
+  mName=AGString(pFilename);
+  Document d;
+  Node &root=d.root();
+  root.setName("antargisLevel");
+  //  cdebug("root:"<<root);
+  saveXML(root);
+
+  AGData c=d.toString();
+  cdebug(c);
+  saveFile(pFilename,c);
+}
+
+void AntMap::clear()
+{
+  //  getScene()->clear();
+  CTRACE;
+  //  mPlayers.clear();
+
+  mEntQuad->clear();
+  mEntityMap.clear();
+
+  // save delete entities
+  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+    saveDelete(*i);
+  
+
+  mEntities.clear();
+
+}
+
+void AntMap::mapChanged()
+{
+  HeightMap::mapChanged();
+  // send info to entitites
+  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+    (*i)->setPos((*i)->getPos2D());
+}
+
+AntEntity *AntMap::getEntity(const Mesh &pMesh)
+{
+  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+    {
+      AntEntity::Meshes meshes=(*i)->getMesh();
+      if(std::find(meshes.begin(),meshes.end(),&pMesh)!=meshes.end())
+	//      if((*i)->getMesh()==&pMesh)
+	return *i;
+    }
+  return 0;
+}
+
+AntEntity *AntMap::getEntity(const AnimMesh &pMesh)
+{
+  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+    {
+      AntEntity::Meshes meshes=(*i)->getMesh();
+      if(std::find(meshes.begin(),meshes.end(),&pMesh)!=meshes.end())
+	return *i;
+    }
+  return 0;
+}
+
+AntEntity *AntMap::getEntity(const Mesh2D &pMesh)
+{
+  for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
+    {
+      AntEntity::Meshes meshes=(*i)->getMesh();
+      if(std::find(meshes.begin(),meshes.end(),&pMesh)!=meshes.end())
+	//      if((*i)->getMesh()==&pMesh)
+	return *i;
+    }
+  return 0;
+}
+
+
+
+
+
+
+//bool markingFinished=true;
+
+void AntMap::mark()
+{
+  CTRACE;
+  HeightMap::mark();
+  AntMap::EntityList::iterator i=mEntities.begin();
+
+  for(;i!=mEntities.end();i++)
+    markObject(*i);
+
+  // mark to del, too, otherwise it crashes when tidying before move() is called
+  for(i=mToDel.begin();i!=mToDel.end();i++)
+    markObject(*i);
+}
+
+
+void AntMap::newMap(int w,int h)
+{
+  clear();
+  HeightMap::newMap(w,h);
+}

Added: antargis/branches/rant/ext/game/map.h
===================================================================
--- antargis/branches/rant/ext/game/map.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/map.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * map.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef __MAP_H__
+#define __MAP_H__
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include "height_map.h"
+#include "heuristic.h"
+
+/**
+ * \defgroup GameEngine BoA Game-Engine
+ * \brief the C++ parts of the BoA game-engine
+ *
+*/
+
+
+//FIXME: add quadtree
+
+template<class T>
+class QuadTree;
+
+class AnimMesh;
+class Mesh2D;
+
+class AntMap:public HeightMap
+{
+ public:
+  typedef std::list<AntEntity*> EntityList;
+
+  AntMap(SceneBase *pScene,int w,int h);
+  ~AntMap();
+  
+  virtual void insertEntity(AntEntity *e);
+  virtual void removeEntity(AntEntity *p);
+  void clear();
+
+  int getNewID();
+  void useID(int id);
+
+  void newMap(int w,int h);
+  
+  EntityList getEntities(const AGRect2&r);
+  EntityList getAllEntities();
+  std::vector<AntEntityPtr> getAllEntitiesV();
+  std::vector<AntEntityPtr> getEntities(const AGString &pName);
+
+  AntEntity *getEntity(const Mesh &pMesh);
+  AntEntity *getEntity(const AnimMesh &pMesh);
+  AntEntity *getEntity(const Mesh2D &pMesh);
+  AntEntity *getEntity(int id) const;
+  AntEntity *getByName(const AGString &pName);
+
+  AntEntity *getNext(AntEntity *me,const AGString &pType,size_t atLeast=0);
+  std::vector<AntEntityPtr> getNextList(AntEntity *me,const AGString &pType,size_t atLeast=0);
+
+  void setHeuristic(HeuristicFunction *pFunction);
+
+  virtual void processXMLNode(const Node &node);
+
+  void saveXML(Node &node) const;
+  void loadXML(const Node &node);
+
+  void saveMap(const AGFilename &pFilename);
+  virtual void loadMap(const AGFilename &pFilename);
+  virtual void loadMapFromMemory(const AGData &Memory);
+
+  void move(float pTime);
+
+  AGVector3 getPos(const AGVector2 &pPos) const;
+
+  virtual void mark();
+
+  virtual void mapChanged();  
+
+
+  //  std::vector<AntEntityPtr> getByType(const AGString &pType);
+ private:
+  typedef std::map<size_t,AntEntity*> EntityMap;
+
+  EntityList mEntities;
+  EntityMap mEntityMap;
+  QuadTree<AntEntity> *mEntQuad;
+
+  //  typedef std::map<AGString,std::set<AntEntity*> > EntityByType;
+  
+  EntityList mToDel;
+
+  //  EntityByType mByType;
+
+  int maxID;
+
+  HeuristicFunction *mHeuristicFunction;
+
+
+};
+
+AntMap *getMap();
+
+
+#endif

Added: antargis/branches/rant/ext/game/minimap.cc
===================================================================
--- antargis/branches/rant/ext/game/minimap.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/minimap.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,378 @@
+#include "minimap.h"
+#include <ag_layoutfactory.h>
+#include <ag_screen.h>
+#include <ag_profiler.h>
+#include "ant_app.h"
+
+#define MAP_BORDER
+
+MiniMap::MiniMap(AGWidget *p,const AGRect2 &r,AntMap *pMap):
+  AGWidget(p,r),
+  mMap(pMap),
+  mSurface(r.w(),r.h())
+{
+  mMapBorder=24;
+  mScene=0;
+  mTexture=new AGTexture(mSurface);
+  setMap(mMap);
+}
+
+MiniMap::~MiniMap()
+{
+  delete mTexture;
+}
+
+
+bool MiniMap::mapChangedComplete(AGEvent *e)
+{
+  CTRACE;
+  mapChangedP(true);
+  return false;
+}
+  
+bool MiniMap::mapChanged(AGEvent *e)
+{
+  CTRACE;
+  mapChangedP(false);
+  return false;
+}
+
+float MiniMap::getNoise(int x,int y)
+{
+  return 1.0-((x*87644+y*653635+x*y*153637)%100)/float(1000.0);
+}
+
+void MiniMap::mapChangedP(bool forceFull=false)
+{
+  CTRACE;
+  if(!mMap)
+    return;
+  int w,h;
+  int x,y;
+  //  forceFull=true;
+  bool inmem=forceFull;
+
+  w=getRect().w();
+  h=getRect().h();
+
+  AGRect2 change=mMap->getChangeRect();
+  //  float mw=mMap->getW();
+  //  float mh=mMap->getH();
+
+  AGVector2 p0(change[0]),p1(change[1]);
+
+  AGVector2 sp0(fromMapCoords(p0));
+  AGVector2 sp1(fromMapCoords(p1));
+
+  int x0=std::min(sp0[0],sp1[0]);
+  int x1=std::max(sp0[0],sp1[0]);
+  int y0=std::min(sp0[1],sp1[1]);
+  int y1=std::max(sp0[1],sp1[1]);
+
+  AGPainter *p=0;
+
+  if((x1-x0)*(y1-y0)>w*h/8 || inmem)
+    {
+      TRACE;
+      p=new AGPainter(mSurface);
+      inmem=true;
+      x0=0;
+      y0=0;
+      x1=width()-1;
+      y1=height()-1;
+    }
+  else
+    {
+      p=new AGPainter(*mTexture);
+      inmem=false;
+    }
+
+  
+
+  AGVector3 light(-1,1,1);
+  light.normalize();
+
+  TerrainType t;
+
+  assert(mMap);  
+  
+  if(mMap)
+    {
+      CTRACE;
+      for(x=x0;x<x1;x++)
+	for(y=y0;y<y1;y++)
+	  {
+	    AGVector2 mv(toMapCoords(AGVector2(x,y)));
+
+	    AGColor c(0,0,0xFF);
+
+	    t=mMap->getTerrain(mv[0],mv[1]);
+	    float height=mMap->getHeight(mv[0],mv[1]);
+
+	    AGVector3 n=mMap->getNormalF(mv[0],mv[1]);
+
+	    float l=std::min(1.0f,n*light*0.5f+0.5f);
+	    
+	    if(t==WATER)
+	      c=AGColor(0xAA,0xAA,0xFF);
+	    else if(t==SAND)
+	      c=AGColor(0xFF,0x77,0);
+	    else if(t==EARTH)
+	      c=AGColor(0xAA,0x66,0);
+	    else if(t==GRASS)
+	      c=AGColor(0,0xaa,0);
+	    else if(t==GRASS2)
+	      c=AGColor(0x00,0xdd,0x00);
+	    else if(t==FOREST)
+	      c=AGColor(0x00,0x77,0x00);
+	    else if(t==ROCK)
+	      c=AGColor(0xAA,0xAA,0xAA);
+	    else if(t==ROCK2)
+	      c=AGColor(0xFF,0xFF,0xFF);
+
+	    c=c*l;
+
+	    if(height<=0)
+	      c=c*0.25+AGColor(0,0,0xFF)*0.75;
+	    else if(height<0.2)
+	      c=c*(height*4)+AGColor(0,0,0xFF)*(1-(height*4));
+	    else if(height<0.4)
+	      c=c*0.25+AGColor(0xFF,0x77,0)*0.75; // sand
+	    c*=getNoise(x,y);
+
+	    
+	    p->putPixel(AGVector2(x,y),c);
+	  }
+    }
+  else
+    {
+      for(x=0;x<w;x++)
+	for(y=0;y<h;y++)
+	  {
+	    p->putPixel(AGVector2(x,y),AGColor(0xFF,0,0));
+	  }
+    }
+
+  delete p;
+  if(inmem)
+    {
+      //      mSurface.save("sicke.png");
+      cdebug(mTexture);
+      delete mTexture;
+      mTexture=new AGTexture(mSurface);
+      cdebug(mTexture);
+      CTRACE;
+    }
+  return;
+}
+
+void MiniMap::draw(AGPainter &p)
+{
+  STACKTRACE;
+  //  CTRACE;
+  AGRect2 m=getRect().origin();
+  //  cdebug(mTexture<<"   "<<m);
+  p.blit(*mTexture,m);
+
+  drawEntities(p);
+
+  if(mScene)
+    {
+      AGVector4 cam=mScene->getCamera();
+      
+      int w,h;
+
+      AGVector2 v=fromMapCoords(cam.dim2());
+
+      // now with approx. frustum
+
+      w=25*getRect().w()/mMap->getW();
+      h=25*getRect().h()/mMap->getH();
+      
+      v-=AGVector2(w/2,h/2);
+
+      AGRect2 r(v[0],v[1],w,h);
+      AGColor c1(0xff,0xaa,0,0x77);
+      AGColor c2(0xee,0x77,0,0x77);
+      
+      p.drawBorder(r,2,c1,c2);
+      r=r.shrink(1);
+      p.drawBorder(r,2,c2,c1);
+    }
+}
+
+void MiniMap::drawEntities(AGPainter &p)
+{
+  //  return;
+  if(mMap)
+    {
+      std::vector<std::pair<AGRect2,AGVector4> > rects;
+      size_t es=0;
+      AntMap::EntityList e=mMap->getAllEntities();
+      for(AntMap::EntityList::iterator i=e.begin();i!=e.end();i++)
+	{
+	  if((*i)->showOnMinimap())
+	    {
+	      AGVector2 v=(*i)->getPos2D();
+	      v=fromMapCoords(v);
+
+	      float s=(*i)->getMinimapSize();
+	      AGVector4 c0=(*i)->getMinimapColor().toVec();
+	      AGVector4 c1=((*i)->getMinimapColor()*1.2).toVec();
+	      AGVector4 c2=((*i)->getMinimapColor()*1.5).toVec();
+
+	      if(s>2)
+		{
+		  rects.push_back(std::make_pair(AGRect2(v[0],v[1],s,s),c2));
+		  rects.push_back(std::make_pair(AGRect2(v[0]+1,v[1]+1,s-2,s-2),AGVector4(1,1,1,1)));
+		  if(s>4)
+		    rects.push_back(std::make_pair(AGRect2(v[0]+2,v[1]+2,s-4,s-4),c2));
+		}
+	      else
+		{
+		  rects.push_back(std::make_pair(AGRect2(v[0],v[1],s,s),c0));
+		  rects.push_back(std::make_pair(AGRect2(v[0],v[1],1,1),c2));
+		  rects.push_back(std::make_pair(AGRect2(v[0]+1,v[1],1,1),c1));
+		  rects.push_back(std::make_pair(AGRect2(v[0],v[1]+1,1,1),c1));
+		}
+	      es++;
+	    }
+	}
+      p.fillRects(rects); // batch processing - in gl much faster!!
+    }
+}
+
+void MiniMap::setMap(AntMap *pMap)
+{
+  mMap=pMap;
+  if(mMap)
+    {
+      mMap->sigMapChanged.connect(slot(this,&MiniMap::mapChanged));
+      mMap->sigMapChangedComplete.connect(slot(this,&MiniMap::mapChangedComplete));
+      mapChangedComplete(0);
+    }
+}
+void MiniMap::setScene(SceneBase *pScene)
+{
+  mScene=pScene;
+}
+
+bool MiniMap::eventMouseButtonDown(AGEvent *m)
+{
+  if(mMap==0 || mScene==0)
+    return AGWidget::eventMouseButtonDown(m);
+
+  AGWidget::eventMouseButtonDown(m);
+      
+      // eat up event - so antView, doesn't get it
+  if(m->isSDLEvent())
+    if(getScreenRect().contains(m->getMousePosition()))
+      return true;
+  return false;
+}
+
+bool MiniMap::eventMouseClick(AGEvent *m)
+{
+  AGVector2 p(m->getMousePosition()-getScreenRect()[0]);
+  if(mMap==0 || mScene==0)
+    return AGWidget::eventMouseClick(m);
+
+  AGVector2 v(p);
+
+  float w=25*getRect().w()/mMap->getW();
+  float h=25*getRect().h()/mMap->getH();
+
+  w/=2;
+  h/=2;
+  if(v[0]<w)
+    v[0]=w;
+  if(v[1]<h)
+    v[1]=h;
+  if(v[0]>width()-w)
+    v[0]=width()-w;
+  if(v[1]>height()-h)
+    v[1]=height()-h;
+
+  v=toMapCoords(v);
+
+  //  mScene->setCamera(AGVector4(v[0],v[1],0,0));
+  AGApplication *app=getApplication();
+  if(app)
+    {
+      GLApp *glapp=dynamic_cast<GLApp*>(app);
+      if(glapp)
+	glapp->setCamera(v);
+    }
+
+  return true;
+}
+
+AGVector2 MiniMap::toMapCoords(AGVector2 v) const
+{
+  AGRect2 r=getRect();
+  v[0]/=r.w();
+  v[1]/=r.h();
+
+  v[1]=1-v[1];
+
+#ifdef MAP_BORDER
+  v[0]*=mMap->getW()-mMapBorder*2;
+  v[1]*=mMap->getH()-mMapBorder*1.5;
+  v[0]+=mMapBorder;
+  v[1]+=mMapBorder*0.35;
+#else
+  v[0]*=mMap->getW();
+  v[1]*=mMap->getH();
+#endif
+  return v;
+}
+AGVector2 MiniMap::fromMapCoords(AGVector2 v) const
+{
+  AGRect2 r=getRect();
+
+#ifdef MAP_BORDER
+  v[0]-=mMapBorder;
+  v[1]-=mMapBorder*0.35;
+
+  v[0]/=mMap->getW()-mMapBorder*2;
+  v[1]/=mMap->getH()-mMapBorder*1.5;
+#else
+  v[0]/=mMap->getW();
+  v[1]/=mMap->getH();
+#endif
+
+  v[1]=1-v[1];
+
+  v[0]*=r.w();
+  v[1]*=r.h();
+
+  return v;
+}
+
+
+
+
+MiniMap *toMiniMap(AGWidget *w)
+{
+  return dynamic_cast<MiniMap*>(w);
+}
+
+// AGLayout creator
+class AGMiniMapLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(MiniMap,"miniMap")
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    CTRACE;
+    setResult(new MiniMap(pParent,pRect,0));
+  }
+};
+
+void registerMinimapCreator()
+{
+	TRACE;
+  getLayoutFactory()->addCreator("miniMap",new AGMiniMapLayoutCreator);
+}
+

Added: antargis/branches/rant/ext/game/minimap.h
===================================================================
--- antargis/branches/rant/ext/game/minimap.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/minimap.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,66 @@
+#ifndef MINIMAP_H
+#define MINIMAP_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include "map.h"
+#include <ag_widget.h>
+#include <ag_texture.h>
+
+class SceneBase;
+
+/**
+   MiniMap is the small map in lower corner.
+   it's displayed through some single texture. the people are drawn on top of this.
+   when the height-map changes, the texture has to be changed.
+   So there are two different functions (mapChanged*)
+
+   Two things you have to take care of:
+   1) you have to set a map with setMap
+   2) you have to set a scene (for frustum-display) (setScene)
+
+   because typically this object is created within an xml-layout-file
+
+ */
+class MiniMap:public AGWidget
+{
+ public:
+  MiniMap(AGWidget *p,const AGRect2 &r,AntMap *pMap);
+  virtual ~MiniMap();
+  
+  /// changes only part of the texture - shouldn't be called if the whole texture is changed, because this is SLOW!
+  bool mapChanged(AGEvent *e);
+  /// call this only if the complete texture is changed - otherwise this is SLOW!
+  bool mapChangedComplete(AGEvent *e);
+
+  void draw(AGPainter &p);
+
+  void setMap(AntMap *pMap);
+  void setScene(SceneBase *pScene);
+
+  virtual bool eventMouseClick(AGEvent *m);
+  virtual bool eventMouseButtonDown(AGEvent *m);
+
+ private:
+  // adds some fancy noise to the map display
+  float getNoise(int x,int y);
+
+  AGVector2 toMapCoords(AGVector2 v) const;
+  AGVector2 fromMapCoords(AGVector2 v) const;
+
+  void mapChangedP(bool force);
+
+  void drawEntities(AGPainter &p);
+
+  float mMapBorder;
+  AntMap *mMap;
+  SceneBase *mScene;
+  AGTexture *mTexture;
+  AGSurface mSurface;
+};
+
+MiniMap *toMiniMap(AGWidget *w);
+
+void registerMinimapCreator();
+
+#endif

Added: antargis/branches/rant/ext/game/resource.cc
===================================================================
--- antargis/branches/rant/ext/game/resource.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/resource.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,66 @@
+#include "resource.h"
+
+
+// RESOURCE
+
+Resource::Resource()
+{
+}
+float Resource::get(const std::string &pName)
+{
+  return r[pName];
+}
+void Resource::add(const std::string &pName,float value)
+{
+  r[pName]+=value;
+}
+void Resource::sub(const std::string &pName,float value)
+{
+  r[pName]=std::max(r[pName]-value,0.0f);
+}
+void Resource::set(const std::string &pName,float value)
+{
+  r[pName]=value;
+}
+
+void Resource::takeAll(Resource &pr)
+{
+  std::map<std::string,float>::iterator i=pr.r.begin();
+  for(;i!=pr.r.end();i++)
+    add(i->first,i->second);
+  pr.r.clear();
+}
+
+void Resource::take(Resource &r,const std::string &pName)
+{
+  add(pName,r.get(pName));
+  r.set(pName,0);
+}
+
+
+std::map<std::string,float> Resource::getAll() const
+{
+  return r;
+}
+
+
+void Resource::saveXML(Node &node) const
+{
+  for(std::map<std::string,float>::const_iterator i=r.begin();i!=r.end();++i)
+    node.set(i->first,AGString(i->second));
+  
+}
+void Resource::loadXML(const Node &node)
+{
+  Node::Attributes a=node.getAttributes();
+  for(Node::Attributes::iterator i=a.begin();i!=a.end();++i)
+    r[i->first]=i->second.toFloat();
+}
+
+bool Resource::empty() const
+{
+  for(std::map<std::string,float>::const_iterator i=r.begin();i!=r.end();++i)
+    if(i->second>0)
+      return false;
+  return true;
+}

Added: antargis/branches/rant/ext/game/resource.h
===================================================================
--- antargis/branches/rant/ext/game/resource.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/resource.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,45 @@
+#ifndef RESOURCE_H
+#define RESOURCE_H
+
+#include <map>
+#include <ag_xml.h>
+
+
+
+/**
+   Resource manages resources with BoA. Every entity has some kind of "bag", where
+   everything is stored. This is it. Resources are identified by strings.
+   You can get,set,sub and add resources.
+
+   
+FIXME: maybe remove Resource from c++??
+
+*/
+class Resource
+{
+  std::map<std::string,float> r;
+ public:
+  Resource();
+
+  void saveXML(Node &node) const;
+  void loadXML(const Node &node);
+
+  float get(const std::string &pName);
+  void add(const std::string &pName,float value);
+  void sub(const std::string &pName,float value);
+  void set(const std::string &pName,float value);
+
+  std::map<std::string,float> getAll() const;
+
+  /// take everything, that's in r and put it into "this"
+  void takeAll(Resource &r);
+
+  /// take everything of type pname, that's in r and put it into "this"
+  void take(Resource &r,const std::string &pName);
+
+  /// check if the "bag" is empty
+  bool empty() const;
+};
+
+
+#endif

Added: antargis/branches/rant/ext/game/terrain.cc
===================================================================
--- antargis/branches/rant/ext/game/terrain.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/terrain.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,346 @@
+#include "terrain.h"
+#include <ag_texturecache.h>
+#include <ag_rendercontext.h>
+#include <ag_profiler.h>
+#include <ag_config.h>
+#include <ag_vdebug.h>
+
+static bool gUse3dTextures=true;
+void setUsing3dTextures(bool use3dTextures)
+{
+  gUse3dTextures=use3dTextures;
+}
+
+bool use3dTextures()
+{
+  return gUse3dTextures;
+}
+
+//////////////////////////////////////////////////////////////////////////
+// TerrainPiece
+//////////////////////////////////////////////////////////////////////////
+TerrainPiece::TerrainPiece(SceneBase *pScene,Terrain *t,HeightMap &map,int xs,int ys,int w,int h,const AGVector4 &pPos,int scale):
+  SceneNode(pScene,AGVector4(),AGBox3()),
+  mXs(xs),mYs(ys),mW(w),mH(h),
+  mMap(&map)
+{
+  mScale=scale;
+  if(scale>0)
+    {
+      mXs/=scale;
+      mYs/=scale;
+      mW/=scale;
+      mH/=scale;
+    }
+  mTerrain=t;
+  mapChanged();
+  setOrder(TERRAIN_Z);
+}
+
+TerrainPiece::~TerrainPiece()
+{
+  if(sceneValid())
+    getScene()->removeNode(this);
+}
+
+void TerrainPiece::mapChanged()
+{
+  AGBox3 bb=bbox();
+
+  // first check, if this piece was really affected
+  if(bb.valid())
+    {
+      AGRect2 r=AGRect2(AGVector2(bb.base[0]-2,bb.base[1]-2),AGVector2(bb.base[0]+bb.dir[0]+4,bb.base[1]+bb.dir[1]+4));  // add some border (2)
+
+      if(!r.collide(mMap->getChangeRect()))
+	{
+	  return;
+	}
+    }
+
+
+  bb=AGBox3();
+  m3dArray.clear();
+
+  AGVector4 white(1,1,1,1);
+  AGVector4 v;
+  AGVector3 n;
+  AGVector2 tp;
+  AGVector3 tp3;
+  float texFactor3w=0.5;
+
+  size_t stepping=1;
+
+
+  // add Vertices
+  size_t x,y;
+  for(x=mXs;x<=mXs+mW;x+=stepping)
+    for(y=mYs;y<=mYs+mH;y+=stepping)
+      {
+	int sx=x*mScale,sy=y*mScale;
+	v=mMap->getVertex(sx,sy);
+
+	n=mMap->getNormal(sx,sy);
+
+	if(use3dTextures())
+	  {
+	    float texHeight=mMap->getTerrainScale(sx,sy);
+	    
+	    tp3=AGVector3(-v[0]*texFactor3w,-v[1]*texFactor3w,texHeight);
+	    m3dArray.addVertex(v,white,n,tp3);
+	  }
+	else
+	  {
+	    tp=AGVector2(-v[0]*texFactor3w,-v[1]*texFactor3w);
+	    m3dArray.addVertex(v,white,n,tp);
+	  }
+
+
+	bb.include(v.dim3());
+      }
+
+  for(x=mXs;x<mXs+mW;x+=stepping)
+    for(y=mYs;y<mYs+mH;y+=stepping)
+      {
+	int p0=(x-mXs)/stepping+(y-mYs)/stepping*(mW/stepping+1);
+	int p1=p0+1;
+	int p2=p0+(mW/stepping+1);
+	int p3=p2+1;
+	if(((x+y)%2)==0)
+	  {
+	    m3dArray.addTriangle(p2,p1,p0);
+	    m3dArray.addTriangle(p3,p1,p2);
+
+	  }
+	else
+	  {
+	    m3dArray.addTriangle(p3,p1,p0);
+	    m3dArray.addTriangle(p3,p0,p2);
+	  }
+
+      }
+  setBBox(bb);
+}
+
+void TerrainPiece::drawShadow()
+{
+  STACKTRACE;
+  m3dArray.setColors(false);
+  m3dArray.draw();
+  m3dArray.setColors(true);
+}
+void TerrainPiece::drawDepth()
+{
+  return;
+  glDepthMask(true);
+  m3dArray.setColors(false);
+  m3dArray.draw();
+  m3dArray.setColors(true);
+}
+
+void TerrainPiece::drawPick()
+{
+  STACKTRACE;
+  //  cdebug(m3dArray.getTriangles());
+
+  m3dArray.drawPick();
+}
+
+
+void TerrainPiece::draw()
+{
+  assertGL;
+
+  STACKTRACE;
+  AGRenderContext c;
+  c.setLighting(true);
+  if(use3dTextures())
+    {
+      c.setTexture(mTerrain->get3dTexture()->glTexture());
+      mTerrain->get3dTexture()->setFilter(GL_LINEAR,GL_LINEAR);
+    }
+  else
+    c.setTexture(mTerrain->getGrassTexture()->glTexture());
+
+  c.begin();
+
+  m3dArray.draw();
+  assertGL;
+}
+
+
+AGVector4 TerrainPiece::lineHit(const AGLine3 &pLine) const
+{
+  return m3dArray.lineHit(pLine);
+}
+
+size_t TerrainPiece::getTriangles() const
+{
+  return m3dArray.getTriangles();
+}
+
+int getTerrainTriangleSize()
+{
+  int s=1;
+
+  if(getConfig()->get("terrainTriangleSize")!="")
+    s=getConfig()->get("terrainTriangleSize").toInt();
+  
+  getConfig()->set("terrainTriangleSize",AGString(s));
+
+  return s;
+}
+
+
+int getTerrainDownScale()
+{
+  int s=1;
+
+  if(getConfig()->get("terrainDownScaleExp")!="")
+    s=getConfig()->get("terrainDownScaleExp").toInt();
+  
+  getConfig()->set("terrainDownScaleExp",AGString(s));
+
+  return s;
+}
+
+int getTerrainDownScaleZ()
+{
+  int s=1;
+
+  if(getConfig()->get("terrainDownScaleZExp")!="")
+    s=getConfig()->get("terrainDownScaleZExp").toInt();
+  
+  getConfig()->set("terrainDownScaleZExp",AGString(s));
+
+  return s;
+}
+
+////////////////////////////////////////////////////////////////////////////
+// TerrainBase
+////////////////////////////////////////////////////////////////////////////
+
+
+TerrainBase::TerrainBase(SceneBase *pScene,HeightMap &map):
+  mMap(&map),mScene(pScene)
+{
+  map.sigMapChanged.connect(slot(this,&TerrainBase::slotMapChanged));
+  map.sigMapChangedComplete.connect(slot(this,&TerrainBase::slotMapChangedComplete));
+}
+
+TerrainBase::~TerrainBase()
+{
+}
+
+bool TerrainBase::slotMapChanged(AGEvent *e)
+{
+  mapChanged();
+  return false;
+}
+bool TerrainBase::slotMapChangedComplete(AGEvent *e)
+{
+  mapChangedComplete();
+  return false;
+}
+
+
+SceneBase *TerrainBase::getScene()
+{
+  return mScene;
+}
+
+HeightMap *TerrainBase::getMap()
+{
+  return mMap;
+}
+
+void TerrainBase::mapChanged()
+{
+}
+
+void TerrainBase::mapChangedComplete()
+{
+}
+
+
+////////////////////////////////////////////////////////////////////////////
+// Terrain
+////////////////////////////////////////////////////////////////////////////
+
+Terrain::Terrain(SceneBase *pScene,HeightMap &map):
+  TerrainBase(pScene,map),
+  m3D(getTextureCache()->get3D("data/textures/terrain/new3d.png",getTerrainDownScale(),getTerrainDownScaleZ())),
+  mGrass(getTextureCache()->get("data/textures/terrain/grass4.png"))
+{
+  init();
+
+}
+
+void Terrain::init()
+{
+  size_t y,x;
+  int tilesize=16;
+  size_t tiles=0;
+
+  HeightMap *map=getMap();
+
+  for(y=0; y<map->getH();y+=tilesize)
+    for(x=0;x<map->getW();x+=tilesize)
+      {
+	TerrainPiece *t=new TerrainPiece(getScene(),this,*map,x,y,tilesize,tilesize,AGVector4(x,y,0,0),getTerrainTriangleSize());
+	WaterPiece *w=new WaterPiece(getScene(),*map,x,y,tilesize,tilesize,AGVector4(x,y,0,0));
+	pieces.push_front(t); // at least it's correct at the beginning
+	water.push_front(w);
+	mNodes.push_back(w);
+	mNodes.push_back(t);
+	tiles++;
+      }
+
+  w=map->getW();
+  h=map->getH();
+}
+
+void Terrain::mapChangedComplete()
+{
+  for(Pieces::iterator i=pieces.begin();i!=pieces.end();i++)
+    delete *i;
+  for(WPieces::iterator i=water.begin();i!=water.end();i++)
+    delete *i;
+
+  pieces.clear();
+  water.clear();
+  mNodes.clear();
+
+
+  init();
+}
+
+
+Terrain::~Terrain()
+{
+  for(Nodes::iterator i=mNodes.begin();i!=mNodes.end();i++)
+    saveDelete(*i);
+}
+
+void Terrain::mapChanged()
+{
+  for(Pieces::iterator i=pieces.begin();i!=pieces.end();i++)
+    {
+      (*i)->mapChanged();
+    }
+  for(WPieces::iterator i=water.begin();i!=water.end();i++)
+    {
+      (*i)->mapChanged();
+    }
+}
+
+AGTexture *Terrain::get3dTexture()
+{
+  return &m3D;
+}
+
+AGTexture *Terrain::getGrassTexture()
+{
+  return &mGrass;
+}
+

Added: antargis/branches/rant/ext/game/terrain.h
===================================================================
--- antargis/branches/rant/ext/game/terrain.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/terrain.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,132 @@
+#ifndef __antargis_gl_terrain_h
+#define __antargis_gl_terrain_h
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include <vector>
+
+#include "scene.h"
+#include "ag_geometry.h"
+#include <ag_surface.h>
+#include <math.h>
+
+#include "vertex_array.h"
+#include "water.h"
+
+#include <ag_xml.h>
+
+#include "map.h"
+
+using namespace std;
+
+class Terrain;
+
+/**
+   TerrainPiece displays (like WaterPiece) some small patch of terrain.
+   (Terrain and water is tiled for the ease of culling)
+   for more information on drawing-modes and such go to SceneNode.
+ */
+class TerrainPiece:public SceneNode
+{
+ public:
+  TerrainPiece(SceneBase *pScene,Terrain *t,HeightMap &map,int x,int y,int w,int h,const AGVector4 &pPos,int scale);
+  virtual ~TerrainPiece();
+
+  void draw();
+  void drawShadow();
+  void drawDepth();
+  void drawPick();
+
+  // returns (0,0,0,0) if no collision
+  // returns (x,y,z,1) if collision takes place
+  AGVector4 lineHit(const AGLine3 &pLine) const;
+  size_t getTriangles() const;
+
+  /// rebuilds the mesh
+  virtual void mapChanged();
+  
+ private:
+
+  Terrain *mTerrain;
+
+  size_t mXs,mYs;
+  size_t mW,mH;
+  int mScale;
+  HeightMap *mMap;
+
+  VertexArray m3dArray;
+};
+
+
+class TerrainBase:public AGRubyObject
+{
+ public:
+  TerrainBase(SceneBase *pScene,HeightMap &map);
+  virtual ~TerrainBase();
+
+  HeightMap *getMap();
+  SceneBase *getScene();
+
+  /// some parts of the map are changed
+  virtual void mapChanged();
+  /// the whole map is changed - so better take care of this (texture-upload instead of repainting on GPU)
+  virtual void mapChangedComplete();
+
+
+  virtual bool slotMapChanged(AGEvent *e);
+  virtual bool slotMapChangedComplete(AGEvent *e);
+
+
+ private:
+  /// the height-map
+  HeightMap *mMap;
+  
+  SceneBase *mScene;
+};
+
+/**
+   In a game-world there exists exactly one Terrain-object.
+   This object holds references to all water- and terrain-pieces, so
+   that in case the terrain changes these will be changed,too.
+
+*/
+class Terrain:public TerrainBase
+{
+  // Some containers for all the meshes
+  typedef std::list<TerrainPiece*> Pieces;
+  typedef std::list<WaterPiece*> WPieces;
+  typedef std::list<SceneNode*> Nodes;
+  Nodes mNodes;
+  Pieces pieces;
+  WPieces water;
+
+  float w,h;
+
+  /// 3d-texture used for the terrain
+  AGTexture m3D;
+
+  /// some (currently not used) grass-texture
+  AGTexture mGrass;
+
+
+public:
+  Terrain(SceneBase *pScene,HeightMap &map);
+
+  virtual ~Terrain();
+
+  AGTexture *get3dTexture();
+  AGTexture *getGrassTexture();
+
+  /// some parts of the map are changed
+  virtual void mapChanged();
+  /// the whole map is changed - so better take care of this (texture-upload instead of repainting on GPU)
+  virtual void mapChangedComplete();
+
+ private:
+  void init();
+};
+
+void setUsing3dTextures(bool use3dTextures);
+
+
+#endif

Added: antargis/branches/rant/ext/game/water.cc
===================================================================
--- antargis/branches/rant/ext/game/water.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/water.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,148 @@
+#include "water.h"
+#include "ag_vdebug.h"
+#include "ag_kill.h"
+#include "ag_rendercontext.h"
+#include "ag_profiler.h"
+#include "ag_config.h"
+
+AntWaterShader *gWaterShader=0;
+AntWaterShader *getWaterShader()
+{
+  if(!gWaterShader)
+    {
+      gWaterShader=new AntWaterShader;
+      REGISTER_SINGLETON(gWaterShader);
+    }
+  assert(gWaterShader);
+  return gWaterShader;
+}
+
+static int gWaterAnim=-10;
+bool useWaterAnimation()
+{
+  if(gWaterAnim==-10)
+    {
+      gWaterAnim=getConfig()->get("animationType")!="false";
+    }
+  return gWaterAnim;
+}
+
+
+WaterPiece::WaterPiece(SceneBase *pScene,HeightMap &map,int x,int y,int w,int h,const AGVector4 &pos):
+  SceneNode(pScene,pos,AGBox3()),
+  mX(x),mY(y),mW(w),mH(h),mMap(&map)
+{
+  step=2;
+  tex=getTextureCache()->get("data/textures/terrain/water.png");
+
+  //  mShader=new AntWaterShader;
+
+  mapChanged();
+  setOrder(WATER_Z);
+}
+
+
+WaterPiece::~WaterPiece()
+{
+  if(sceneValid())
+    getScene()->removeNode(this);
+
+}
+
+void WaterPiece::mapChanged()
+{
+  AGBox3 bb;
+  mArray.clear();
+
+  setVisible(false);
+  bool vis=false;
+  int x,y;
+  int step=2;
+  for(x=0;x<mW+step;x+=step)
+    for(y=0;y<mH+step;y+=step)
+      {
+	AGVector4 p(x,y,0);
+	p+=getPos();
+	AGVector4 c(1,1,1,0.7);
+	AGVector3 n(0,0,1);
+	AGVector2 t(x,y);
+	
+	mArray.addVertex(p,c,n,t);
+
+	bb.include(p.dim3()-AGVector3(0,0,1));
+	bb.include(p.dim3()+AGVector3(0,0,1));
+
+	if(mMap->get(mX+x,mY+y)<0.1 && !vis)
+	  {
+	    vis=true;
+	  }
+      }
+  setBBox(bb-getPos().dim3());
+
+  for(x=0;x<mW/step;x++)
+    for(y=0;y<mH/step;y++)
+      {
+	addTriangle(x,y, x+1,y, x,y+1);
+
+	addTriangle(x+1,y, x+1,y+1, x,y+1);
+      }
+
+  if(vis)
+    setVisible(true);
+}
+
+void WaterPiece::addTriangle(int x0,int y0,int x1,int y1,int x2, int y2)
+{
+  int w=(mW/step)+1;
+  mArray.addTriangle(x2+y2*w,x1+y1*w,x0+y0*w);
+}
+
+void WaterPiece::draw()
+{
+  STACKTRACE;
+  assertGL;
+
+  AGRenderContext c;
+  c.setAlpha(0,GL_NONE);
+  c.setCulling(false);
+  c.setTexture(tex.glTexture());
+  //  tex.setClamp(GL_REPEAT,GL_REPEAT,GL_REPEAT);//CLAMP_TO_EDGE);
+  //  c.setColor(AGVector4(0,0,1,1));
+  c.begin();
+
+  glDisable(GL_COLOR_MATERIAL);
+  glDisable(GL_CULL_FACE);
+  glDisable(GL_ALPHA_TEST);
+  glColor4f(1,1,1,1);
+  if(useWaterAnimation())
+    getWaterShader()->enable();
+  mArray.draw();
+  if(useWaterAnimation())
+    getWaterShader()->disable();
+  assertGL;
+}
+
+void WaterPiece::drawPick()
+{
+  STACKTRACE;
+  //cdebug(mArray.getTriangles());
+  //  mArray.drawPick();
+}
+
+void WaterPiece::advance(float t)
+{
+  assertGL;
+  getWaterShader()->update(t);
+  assertGL;
+}
+
+size_t WaterPiece::getTriangles() const
+{
+  return mArray.getTriangles();
+}
+
+bool WaterPiece::transparent()
+{
+  return true;
+}
+

Added: antargis/branches/rant/ext/game/water.h
===================================================================
--- antargis/branches/rant/ext/game/water.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/game/water.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,56 @@
+#ifndef __antargis_gl_water_h
+#define __antargis_gl_water_h
+
+#include "glsl.h"
+#include "scene.h"
+#include "ag_texturecache.h"
+#include "ag_geometry.h"
+#include "ag_texture.h"
+#include "vertex_array.h"
+#include "map.h"
+#include <math.h>
+
+class AntWaterShader;
+
+/**
+   A waterpiece is a scenenode, that displays some small patch of water. Water has
+   currently always the same height (==0).
+   The water is rendered with a VertexArray-object and is able to use some minor vertex shading
+   for animation.
+   In future some fragment shader using fresnel effects would be nice :-)
+*/
+class WaterPiece:public SceneNode
+{
+  AGTexture tex;
+ public:
+  WaterPiece(SceneBase *pScene,HeightMap &map,int x,int y,int w,int h,const AGVector4 &pos);
+  virtual ~WaterPiece();
+
+  /// draw in normal mode
+  void draw();
+  /// draw for picking (without shader)
+  void drawPick();
+
+  /// advance animation
+  void advance(float t);
+  size_t getTriangles() const;
+  bool transparent();
+
+  /// check for visibility, set bounding box and update vertex-array
+  virtual void mapChanged();
+
+ private:
+  void addTriangle(int x0,int y0,int x1,int y1,int x2, int y2);
+
+ private:
+  VertexArray mArray;
+  int mX;
+  int mY;
+  int mW;
+  int mH;
+  HeightMap *mMap;
+  int step;
+  AntWaterShader *mShader;
+};
+#endif
+

Added: antargis/branches/rant/ext/gui/ag_application.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_application.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_application.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,577 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_application.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_application.h"
+#include "ag_main.h"
+#include "ag_screen.h"
+#include "ag_glscreen.h"
+#include "ag_main.h"
+#include "ag_debug.h"
+#include "ag_mixer.h"
+#include "ag_texturecache.h"
+#include "ag_profiler.h"
+#include "ag_clip_painttarget.h"
+#include "ag_video.h"
+
+#include <ruby.h>
+
+void disableKeyrepeat()
+{
+  SDL_EnableKeyRepeat(0,0);
+}
+
+AGApplication *gApplication=0;
+
+AGVector2 gAppCursorPos;
+
+AGApplication *getApplication()
+{
+  return gApplication;
+}
+
+
+AGApplication::AGApplication():mRunning(true),mIdleCalls(true),mainWidget(0),mTooltip(0),mOverlay(0)
+{
+  SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY,SDL_DEFAULT_REPEAT_INTERVAL);
+  if(videoInited())
+    {
+      setCursor(getTextureCache()->get("blue_cursor.png"));
+      setNormalCursor();
+    }
+  mDemoTime=-1;
+}
+
+AGApplication::~AGApplication()
+{
+  CTRACE;
+  delete mCursor;
+}
+
+void AGApplication::setKeyRepeat(bool enable)
+{
+  if(enable)
+    SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY,SDL_DEFAULT_REPEAT_INTERVAL);
+  else
+    SDL_EnableKeyRepeat(0,0);
+}
+
+
+void AGApplication::setMainWidget(AGWidget *w)
+{
+  mainWidget=w;
+  setOverlay(0);
+  if(w)
+    w->redraw();
+}
+
+AGWidget *AGApplication::getMainWidget()
+{
+  return mainWidget;
+}
+
+/**
+ * \brief the main-loop of each application
+ *
+ * Each program has one or more application-objects.
+ * An application normally represents a single UI-screen. So it has
+ */
+
+bool AGApplication::run() 
+{
+  STACKTRACE; 
+  Uint32 last,now;
+  SDL_Event event;
+  float t;
+  mRunning=true;
+
+  gApplication=this;
+  
+  flushEventQueue();
+  last=now=SDL_GetTicks();
+
+  size_t loopCount=0;
+  
+  while(mRunning)
+    {
+      STACKTRACE; 
+      
+      gApplication=this;
+
+      {
+	// event handling
+	STACKTRACE;
+	// check for finished music
+	getMain()->repeatedCalls();
+	//	getSoundManager()->checkFinished();
+	
+	now=SDL_GetTicks();
+	/*
+	// pull motion events (may flood the eventqueue)
+		while(SDL_PeepEvents(&event, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) > 0)
+	  ;
+	*/
+	clearOldMousePosition();
+	dbout(2,"loop pre-event:"<<loopCount);
+	event=getNewEvent();
+	if(eventOk(event))
+	  {
+	    do
+	      {
+		dbout(2,"eventok  "<<toString(&event));
+		doEvent(event);
+		if(mIdleCalls)
+		  {
+		    dbout(2,"getNewEvent...  (idlecalls:"<<mIdleCalls<<")");
+		    event=getNewEvent();
+		  }
+		else
+		  resetEvent(event);
+	      }while(eventOk(event));
+	  } 
+	dbout(2,"loop post-event:"<<loopCount);
+	/*
+	if(mIdleCalls) 
+	  {
+	    if (SDL_PollEvent(&event) == 0) 
+	      eventIdle();
+	    else
+	      {
+		do
+		  {
+		    doEvent(&event);
+		  }while(SDL_PollEvent(&event)!=0);
+	      }
+	    
+	  } 
+	else 
+	  {
+	    SDL_WaitEvent(&event);
+	    doEvent(&event);
+	    }*/
+
+	if(mDemoTime>=0)
+	  {
+	    t=mDemoTime;
+	    mDemoTime=-1;
+	    dbout(2,"demo time:"<<t);
+	  }
+	else
+	  {
+	    t=(now-last)/1000.0;
+	  }
+	if(mainWidget)
+	  mainWidget->sigTick(t);
+	
+	dbout(2,"frame events:"<<t);
+	eventPrepareFrame(t);
+
+	eventFrame(t);
+      }
+      {
+	// drawing
+	STACKTRACE;
+	{
+	  STACKTRACE;
+	  prepareDraw();
+	}
+	{
+	  STACKTRACE;
+	  draw();
+	}
+      }
+      
+      eventFrameEnd(t);
+      last=now;
+
+      loopCount++;
+      dbout(2,"Running:"<<mRunning);
+    }
+  gApplication=0;
+
+  return true;
+}
+
+void AGApplication::setDemoTime(float t)
+{
+  dbout(2,"demoTime:"<<t);
+  mDemoTime=t;
+}
+
+
+SDL_Event AGApplication::getNewEvent()
+{
+  SDL_Event mEvent;
+  resetEvent(mEvent);
+  // pull motion events (may flood the eventqueue)
+  while(SDL_PeepEvents(&mEvent, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) > 0)
+    ;
+  
+  if(mIdleCalls) 
+    {
+      if (SDL_PollEvent(&mEvent) == 0) 
+	{
+	  resetEvent(mEvent);
+	  return mEvent;
+	}
+    } 
+  else 
+    SDL_WaitEvent(&mEvent);
+  return mEvent;
+}
+
+
+
+bool AGApplication::doEvent(const SDL_Event &event) 
+{
+  STACKTRACE;
+  SDL_Event e;
+  
+  // eat up old mouse motion events
+  while(SDL_PeepEvents(&e, 1, SDL_GETEVENT, SDL_MOUSEMOTIONMASK) > 0);
+  
+  AGEvent *message=newEvent(this,"",event);
+  bool processed=false;
+  if(mOverlay)
+    processed=mOverlay->processEvent(message);
+
+  if(!processed)
+    {
+      if(!processed && mainWidget)
+	processed=mainWidget->processEvent(message);
+
+      if(!processed)
+	processed=processEvent(message);
+    }
+  
+  delete message;
+  return processed;
+}
+
+void AGApplication::clearOldMousePosition()
+{
+}
+void AGApplication::drawCursor()
+{
+  if(!videoInited())
+    return;
+  AGPainter p;
+  if(mCursor)
+    {
+      mCursorOld=AGRect2(gAppCursorPos[0],gAppCursorPos[1],mCursor->width(),mCursor->height());
+      p.blit(*mCursor,mCursorOld);
+    }
+
+}
+
+void AGApplication::flushEventQueue()
+{
+}
+ 
+bool AGApplication::eventQuit(AGEvent *m)
+{
+  CTRACE;
+  mRunning=false;
+  return false;
+}
+
+bool AGApplication::eventIdle()
+{
+  return false;
+}
+
+
+/**
+   \brief prepares the actual drawing process
+
+   prepareDraw runs prepareDraw for the main-widget, which itself runs
+   prepareDraw recursively. This functions are meant to prepare possible
+   texture contents and other things, that might be updated in each frame.
+*/
+void AGApplication::prepareDraw()
+{
+  STACKTRACE; 
+
+  if(mainWidget)
+    {
+      mainWidget->prepareDrawAll();
+      mainWidget->useTexturesRecursive();
+    }
+  if(mOverlay)
+    mOverlay->prepareDrawAll();
+}  
+
+
+AGWidget *pLastDrawn=0;
+
+/**
+ * \brief query redraw
+ *
+ * Queries a complete screen redraw. This makes sense in SDL-mode only.
+ * There a dirty rectangle kind of painting is used.
+ */
+
+void AGApplication::redraw()
+{
+  pLastDrawn=0;
+
+  if(mainWidget)
+    mainWidget->redraw();
+}
+
+/**
+ * \brief calls the draw-function of the main-widget
+
+ * AGApplication::draw() calls the draw-function of the mainWidget and cares
+ * about drawing a custom mouse-cursor, the tooltip and possible overlays.
+ * At the end the screen-buffer is flipped.
+ */
+
+void AGApplication::draw()
+{
+  CTRACE;
+  if(delCue.size()>0)
+    {
+      for(std::list<AGWidget*>::iterator i=delCue.begin();i!=delCue.end();i++)
+	if(*i)
+	  saveDelete(*i);
+      delCue.clear();
+    }
+
+  if(!videoInited())
+    return;
+
+  bool oldClippingTechnique=false;
+  AGClipping clip;
+
+  STACKTRACE;
+  beginRender();
+
+  cdebug("mainWidget:"<<mainWidget);
+  if(mainWidget)
+    {
+      getScreen().begin();
+      
+      AGPainter *p;
+      AGClipPaintTarget paintTarget(&getScreen());
+
+      if(opengl())
+	p=new AGPainter(getScreen());
+      else
+	p=new AGPainter(paintTarget);
+
+      clip.exclude(mainWidget->getScreenRect());
+      if(pLastDrawn==mainWidget && !opengl())
+	{
+	  if(oldClippingTechnique)
+	    {
+	      AGRect2 r=mainWidget->getChangeRect();
+	      if(mCursor)
+		r+=mCursorOld;
+	      
+	      p->clip(r);
+	    }
+	  else
+	    {
+	      // FIXME: do some advanced clipping
+	      mainWidget->acquireClipping(clip);
+	    }
+	}
+      else
+	{
+	  clip.include(mainWidget->getScreenRect());
+	}
+
+      cdebug("CLIP:"<<clip.toString());
+      paintTarget.clip(clip);
+      mainWidget->drawAll(*p);
+
+      if(mTooltip)
+	{
+	  AGPainter p;
+	  mTooltip->drawAll(p);
+	}
+      if(mOverlay)
+	{
+	  AGPainter p;
+	  mOverlay->drawAll(p);
+	}
+
+      pLastDrawn=mainWidget;
+
+      delete p;
+    }
+  else
+    cdebug("no mainwidget");
+  drawCursor();
+
+  std::list<AGRect2> changeList;
+  if(mainWidget)
+    {
+      changeList=mainWidget->aquireChanges();
+      mainWidget->clearChangeRects();
+    }
+  if(opengl())// || true)
+    getScreen().flip();
+  else
+    {
+      std::vector<AGRect2> changeV=clip.clip(mainWidget->getScreenRect());
+      changeList.clear();
+      std::copy(changeV.begin(),changeV.end(),std::back_inserter(changeList));
+      getScreen().update(changeList);
+    }
+
+  endRender();
+  cdebug("end render");
+}
+
+/**
+ * \brief quit the application
+ *
+ * This sets the private mRunning to false. One might add a function, that
+ * checks if quitting is ok or reset mRunning to true. But this is not yet
+ * part of AGApplication.
+ */
+
+void AGApplication::tryQuit()
+{
+  CTRACE;
+  mRunning=false;
+}
+
+bool AGApplication::eventKeyDown(AGEvent *m)
+{
+  if(m->isSDLEvent())
+    {
+      SDLKey k=m->getKey();
+      SDLMod mod=m->getMod();
+
+      if(k==SDLK_RETURN && ((mod&KMOD_LALT)||(mod&KMOD_RALT)))
+	{
+	  getVideo()->toggleFull();
+	  eventChangedRes();
+	  redraw();
+	}
+      else if(k==SDLK_F10)
+	tryQuit();
+    }
+  return false;
+}
+
+void AGApplication::eventChangedRes()
+{
+}
+
+bool AGApplication::eventPrepareFrame(float pTime)
+{
+  return false;
+}
+
+
+bool AGApplication::eventFrame(float pTime)
+{
+  return false;
+}
+bool AGApplication::eventFrameEnd(float pTime)
+{
+  return false;
+}
+
+long AGApplication::getTicks() const
+{
+  return SDL_GetTicks();
+}
+
+/// delays execution for ms milliseconds. This can be used to decrease framerate and cpu-load.
+void AGApplication::delay(int ms)
+{
+  dbout(2,"delay:"<<ms);
+  SDL_Delay(ms);
+}
+
+
+/// mark my mainWidget and my tooltip, as they can be ruby-objects
+void AGApplication::mark()
+{
+  //  CTRACE;
+  if(mainWidget)
+    markObject(mainWidget);
+  if(mTooltip)
+    markObject(mTooltip);
+}
+
+/// this function sets the current tooltip, which is display above all widgets
+void AGApplication::setTooltip(AGTooltip *pTooltip)
+{
+  delete mTooltip;
+  mTooltip=pTooltip;
+    
+}
+
+/// this functions resets the tooltip pTooltip.
+/// @param pTooltip a tooltip of a widget
+void AGApplication::resetTooltip(AGTooltip *pTooltip)
+{
+  if(pTooltip==mTooltip)
+    {
+      delete mTooltip;
+      mTooltip=0;
+    }
+}
+
+AGWidget *AGApplication::getOverlay()
+{
+  return mOverlay;
+}
+
+
+void AGApplication::setOverlay(AGWidget *pOverlay)
+{
+  CTRACE;
+  if(mOverlay)
+    delCue.push_back(mOverlay);
+  mOverlay=pOverlay;
+}
+
+
+bool AGApplication::eventMouseMotion(AGEvent *m)
+{
+  gAppCursorPos=m->getMousePosition();
+  return AGMessageObject::eventMouseMotion(m);
+}
+
+/// this function disables hardware cursor and shows software-cursor instead
+void AGApplication::setCursor(const AGTexture &pTexture)
+{
+  mCursor=new AGTexture(pTexture);
+  SDL_ShowCursor(0);
+}
+
+/// this function enables hardware-cursor
+void AGApplication::setNormalCursor()
+{
+  SDL_ShowCursor(1);
+  delete mCursor;
+  mCursor=0;
+}
+
+bool AGApplication::hardwareCursor() const
+{
+  return mCursor==0;
+}

Added: antargis/branches/rant/ext/gui/ag_application.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_application.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_application.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_application.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_APPLICATION_H
+#define AG_APPLICATION_H
+
+#include <ag_messageobject.h>
+#include <ag_widget.h>
+#include <ag_tooltip.h>
+#include <ag_texture.h>
+
+/**
+   \defgroup application Application
+*/
+
+
+/**
+   \brief Base class for application - holds the main loop
+   \ingroup application
+
+  Use AGApplication as base class your application's class.
+  In this library it's assumed that you have different parts of your program, that
+  are really different. Each of these parts has its own AGApplication.
+  The actual control of these applications is done through a main-loop, that
+  queries new events from libSDL and gives them to the correct widgets.
+  This main-loop can by started by run(). After this your have some possibilities to access
+  control. FOr instance there are the different event* functions, which you can override in
+  an AGApplication's subclass.
+
+  If you want to quit this application call tryQuit().
+
+  Each AGApplication has a single main-widget, which is drawn in every frame.
+  Set it by calling setMainWidget().
+
+  The typical usage looks like this:
+  <pre>
+  class MyApp:public AGApplication
+  {
+    public:
+    bool eventFrame(float t)
+    {
+      std::cout<<"In this frame "<<t<<" seconds have passed."<<std::endl;
+    }
+  };
+
+  int main()
+  {
+    // here you have to init the video mode
+    AGMain main;
+    main.initVideo(800,600,32,false,false);
+
+    // the actual example
+    MyApp app;
+    app.run();
+    return 0;
+  }
+  </pre>
+*/
+class AGApplication:public AGMessageObject
+{
+ public:
+  AGApplication();
+  virtual ~AGApplication();
+
+  bool run();
+
+  /// called in each frame when idling
+  virtual bool eventIdle();           
+
+  virtual bool eventPrepareFrame(float pTime);
+
+  /// called between event-handling and drawing
+  virtual bool eventFrame(float pTime);
+  /// called after drawing - so before event handling
+  virtual bool eventFrameEnd(float pTime);
+
+
+  virtual bool eventQuit(AGEvent *m);
+  virtual bool eventKeyDown(AGEvent *m2);
+  virtual bool eventMouseMotion(AGEvent *m);
+
+  virtual void eventChangedRes();
+
+  void setMainWidget(AGWidget *w);
+  AGWidget *getMainWidget();
+
+  virtual void draw();
+  virtual void prepareDraw();
+
+  void redraw();
+
+  virtual void tryQuit();
+
+  long getTicks() const;
+  void delay(int ms);
+
+  void setTooltip(AGTooltip *pTooltip); // transfers ownage !
+  void resetTooltip(AGTooltip *pTooltip); // try to reset this one
+
+  void setOverlay(AGWidget *pOverlay);
+  AGWidget *getOverlay();
+
+  void setCursor(const AGTexture &pTexture);
+  void setNormalCursor();
+  bool hardwareCursor() const;
+
+  virtual SDL_Event getNewEvent();
+
+  void setKeyRepeat(bool enable);
+
+  void setDemoTime(float t);
+  
+ private:
+  void clearOldMousePosition();
+  void drawCursor();
+
+  void flushEventQueue();
+  bool doEvent(const SDL_Event &e);
+
+  bool mRunning;
+  bool mIdleCalls;
+  AGWidget *mainWidget;
+  AGTooltip *mTooltip;
+
+  AGWidget *mOverlay;
+
+  AGTexture *mCursor;
+  AGRect2 mCursorOld;
+
+  std::list<AGWidget*> delCue;
+
+  SDL_Event mEvent;
+
+  float mDemoTime;
+
+ public:
+  void mark();
+};
+
+/**
+   getApplication returns the current active application.
+   This gets set on each iteration of AGApplication::run. 
+   So it will be correct after finishing a frame, when you are
+   using nested AGApplications.
+*/
+AGApplication *getApplication(); // returns current active application
+
+void disableKeyrepeat();
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_background.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_background.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_background.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_background.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_background.h"
+#include "ag_draw.h"
+#include "ag_theme.h"
+#include "ag_debug.h"
+#include "ag_painter.h"
+#include "ag_texturecache.h"
+
+/** sets a uniform background of color pColor
+    @param pColor an rgba-color. so you can use transparent backgrounds,too.
+*/
+AGBackground::AGBackground(const AGColor &pColor):mTexture(0)
+{
+  //  CTRACE;
+  mColor=true;
+  mColors[0]=pColor;
+  mColors[1]=pColor;
+  mColors[2]=pColor;
+  mColors[3]=pColor;
+  mBorder=0;
+}
+
+
+/**
+   This constructor set a themed background.
+   @param pThemeName a typical string is "button.background.normal". Then the entry in the theme.xml file should look something like:
+<pre>
+ <button>
+   <background>
+     <normal>
+       <color name='gradientColor1' color='#12141c'/>
+       <color name='gradientColor2' color='#12141c'/>
+       <color name='gradientColor3' color='#12141c'/>
+       <color name='gradientColor4' color='#12141c'/>
+     </normal>
+   </background>
+  </button>
+</pre>
+*/
+
+AGBackground::AGBackground(const AGString &pThemeName):mTexture(0)
+{
+  //  CTRACE;
+
+  AGTheme *theme=getTheme();
+  mColor=false;
+  if(theme->hasSurface(pThemeName+".image"))
+    {
+      //      CTRACE;
+      cdebug(pThemeName+".image");
+      mTexture=&getTextureCache()->get(getTheme()->getSurfaceName(pThemeName+".image"));
+      //mTexture=new AGTexture(theme->getSurface(pThemeName+".image"));
+    }
+  else if(theme->hasColor(pThemeName+"."+"gradientColor1"))
+    {
+      mColor=true;
+      mColors[0]=theme->getColor(pThemeName+"."+"gradientColor1");
+      mColors[1]=theme->getColor(pThemeName+"."+"gradientColor2");
+      mColors[2]=theme->getColor(pThemeName+"."+"gradientColor3");
+      mColors[3]=theme->getColor(pThemeName+"."+"gradientColor4");
+    }
+
+  mBorder=theme->getInt(pThemeName+"."+"border");
+}
+
+/*
+AGBackground::AGBackground(const AGBackground &p):mTexture(0)
+{
+  if(p.mTexture)
+    mTexture=new AGTexture(*p.mTexture);
+  mColors[0]=p.mColors[0];
+  mColors[1]=p.mColors[1];
+  mColors[2]=p.mColors[2];
+  mColors[3]=p.mColors[3];
+
+  mColor=p.mColor;
+  mBorder=p.mBorder;
+}
+
+AGBackground::~AGBackground()
+{
+  delete mTexture;
+  }*/
+
+
+/// draws the background on painter in the given rectangle
+void AGBackground::draw(const AGRect2 &r,AGPainter &p)
+{
+  if(mTexture)
+    {
+      p.tile(*mTexture,r.shrink(mBorder));
+    }
+  else if(mColor)
+    p.drawGradient(r.shrink(mBorder),mColors[0],mColors[1],mColors[2],mColors[3]);
+ 
+}
+
+/// this is a help function, so that once made textures aren't automatically discarded.
+void AGBackground::useTextures()
+{
+  if(mTexture)
+    const_cast<AGTexture*>(mTexture)->useTexture();
+}

Added: antargis/branches/rant/ext/gui/ag_background.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_background.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_background.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_background.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_BACKGROUND_H
+#define AG_BACKGROUND_H
+
+#include <string>
+#include "ag_geometry.h"
+#include "ag_texture.h"
+#include "ag_color.h"
+
+class AGPainter;
+
+/** AGBackground is a helper class for widget-drawing
+    It is used to draw gradients and tiled backgrounds of widgets.
+    It is themable.
+ */
+class AGBackground
+{
+ public:
+  AGBackground(const AGString &pThemeName="");
+  AGBackground(const AGColor &pColor);
+  //  AGBackground(const AGBackground &pBackground);
+  //  ~AGBackground();
+
+  void draw(const AGRect2 &r,AGPainter &p);
+
+  void useTextures();
+ private:
+  const AGTexture *mTexture;
+  AGColor mColors[4];
+
+  bool mColor;
+  int mBorder;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_border.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_border.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_border.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_border.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_border.h"
+#include "ag_painter.h"
+#include "ag_theme.h"
+#include "ag_texturecache.h"
+
+AGBorder::AGBorder(const AGString &pTheme)
+{
+  mTheme=pTheme;
+  AGString imageName=pTheme+".image";
+
+  if((mEnable=getTheme()->hasSurface(imageName)))
+    {
+      AGSurface surface(getTheme()->getSurface(imageName));
+      //      mSurface=getTextureManager()->makeTexture(getTheme()->getSurface(pTheme+".image"));
+      mTexture=&getTextureCache()->get(getTheme()->getSurfaceName(imageName));
+      mWidth=mTexture->width()/3;
+
+      // build textures
+      for(int y=0;y<3;y++)
+	for(int x=0;x<3;x++)
+	  {
+	    AGRect2 r(x*mWidth,y*mWidth,mWidth,mWidth);
+	    mTextures.push_back(&getTextureCache()->get(getTheme()->getSurfaceName(imageName),r));
+	  }
+    }
+  else
+    {
+      mWidth=0;
+      mTexture=0;
+    }
+}
+
+void AGBorder::draw(const AGRect2 &pd,AGPainter &p)
+{
+  AGRect2 d=pd.alignGrid();
+  if(mTexture==0 || !mEnable)
+    return;
+
+  if(!mTexture->hasTexture())
+    {
+      // FIXME: discard this and fix border-painting -problem in GL!
+      mTexture=&getTextureCache()->get(getTheme()->getSurfaceName(mTheme+".image"));
+    }
+
+  int w=mTexture->width()/3;
+  int w2=w*2;
+
+  float x2=d.x1();
+  float y2=d.y1();
+  /*
+  // corners
+  p.blit(*mTexture,AGRect2(0,0,w,w),AGRect2(0,0,w,w));
+ 
+  p.blit(*mTexture,AGRect2(0,y2-w,w,w),AGRect2(0,w2,w,w));
+ 
+  p.blit(*mTexture,AGRect2(x2-w,0,w,w),AGRect2(w2,0,w,w));
+ 
+  p.blit(*mTexture,AGRect2(x2-w,y2-w,w,w),AGRect2(w2,w2,w,w));
+
+  // borders
+
+  // hor
+  p.tile(*mTexture,AGRect2(w,0,d.w()-w2,w),AGRect2(w,0,w,w));
+  p.tile(*mTexture,AGRect2(w,y2-w,d.w()-w2,w),AGRect2(w,w2,w,w));
+  // ver
+  p.tile(*mTexture,AGRect2(0,w,w,d.h()-w2),AGRect2(0,w,w,w));
+  p.tile(*mTexture,AGRect2(x2-w,w,w,d.h()-w2),AGRect2(w2,w,w,w));
+*/
+  // skip interior
+
+
+  p.tile(*mTextures[0],AGRect2(0,0,w,w));
+  p.tile(*mTextures[6],AGRect2(0,y2-w,w,w));
+  p.tile(*mTextures[2],AGRect2(x2-w,0,w,w));
+  p.tile(*mTextures[8],AGRect2(x2-w,y2-w,w,w));
+
+  // hor
+  p.tile(*mTextures[1],AGRect2(w,0,d.w()-w2,w));
+  p.tile(*mTextures[7],AGRect2(w,y2-w,d.w()-w2,w));
+  // ver
+  p.tile(*mTextures[3],AGRect2(0,w,w,d.h()-w2));
+  p.tile(*mTextures[5],AGRect2(x2-w,w,w,d.h()-w2));
+
+  
+}
+
+size_t AGBorder::getWidth() const
+{
+  return mWidth;
+}
+
+void AGBorder::useTextures()
+{
+  if(mTexture)
+    const_cast<AGTexture*>(mTexture)->useTexture();
+
+  for(std::vector<const AGTexture*>::iterator i=mTextures.begin();i!=mTextures.end();i++)
+    const_cast<AGTexture*>(*i)->useTexture();
+
+}
+

Added: antargis/branches/rant/ext/gui/ag_border.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_border.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_border.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_border.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef __AG_BORDER_H__
+#define __AG_BORDER_H__
+
+#include <string>
+#include "ag_texture.h"
+#include "ag_geometry.h"
+
+class AGPainter;
+
+
+class AGBorder
+{
+ public:
+  AGBorder(const AGString &pTheme="");
+
+  void draw(const AGRect2 &r,AGPainter &p);
+
+  size_t getWidth() const;
+
+  void useTextures();
+
+ private:
+  const AGTexture *mTexture;
+
+  std::vector<const AGTexture*> mTextures;
+
+  AGString mTheme;
+  bool mEnable;
+  size_t mWidth;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_button.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_button.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_button.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,390 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_button.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_button.h"
+#include "ag_draw.h"
+#include "ag_edit.h"
+#include "ag_theme.h"
+#include "ag_debug.h"
+#include "ag_image.h"
+#include "ag_border.h"
+#include "ag_glscreen.h"
+
+using namespace std;
+
+/**
+ * \brief creates a button with a text
+ *
+ * @param pParent the parent widget
+ * @param r       relative position within the parent
+ * @param pText   the caption displayed on the button. take '' for no text
+ * @param id      currently not any longer used id
+*/
+
+AGButton::AGButton(AGWidget *pParent,const AGRect2 &r,const AGStringUtf8&pText,int id):
+  AGWidget(pParent,r),
+  mText(pText),mID(id),mState(NORMAL),mTextW(0)
+{
+  mImageW=0;
+  setTheme("");
+  AGFont font("FreeSans.ttf");
+  font.setColor(AGColor(0,0,0));
+  mTextW=new AGEdit(this,r.origin().shrink(borderWidth));//,mText,font);
+  mTextW->setText(mText);
+  mTextW->setAlign(EDIT_CENTER);
+  mTextW->setVAlign(EDIT_VCENTER);
+  mTextW->setFont(font);
+  mTextW->setMutable(false);
+  mTextW->setBackground(false);
+  addChild(mTextW);
+
+  setTheme("");
+  mChecked=false;
+
+  //  cdebug("borderWidth:"<<borderWidth);
+  mEnabled=true;
+
+  if(opengl())
+    setCaching(true);
+}
+
+void AGButton::setSurface(AGSurface pSurface,bool pChangeSize)
+{
+  mSurface=pSurface;
+  mGrayedSurface=mSurface.grayed();
+  if(!mImageW)
+    {
+      mImageW=new AGImage(this,getRect().origin(),mSurface,false);
+      addChild(mImageW);
+    }
+  else
+    {
+      mImageW->setSurface(pSurface);
+      mImageW->show();
+    }
+  mTextW->hide();
+  if(pChangeSize)
+    {
+      setWidth(mImageW->width()+2+2*borderWidth);
+      setHeight(mImageW->height()+2+2*borderWidth);
+    }
+
+  else
+    {
+      // then center
+      mImageW->setLeft((width()-mImageW->width())/2);
+      mImageW->setTop((height()-mImageW->height())/2);
+    }
+  queryRedraw();
+}
+
+void AGButton::setTexture(const AGTexture &pTexture)
+{
+  if(!mImageW)
+    {
+      mImageW=new AGImage(this,getRect().origin(),mSurface,false);
+      addChild(mImageW);
+    }
+  else
+    {
+      //      mImageW->setSurface(pTexture);
+      mImageW->show();
+    }
+  mImageW->setTexture(pTexture);
+}
+
+
+void AGButton::draw(AGPainter &p)
+{
+  p.pushMatrix();
+  p.transform(AGRect2(0,0,width(),height()).shrink(borderWidth));
+  AGRect2 pr=getRect().origin();
+  mBG[mState].draw(pr,p);
+  mBorder[mState].draw(pr,p);
+  p.popMatrix();
+
+  if(borderWidth==0)
+    return;
+
+  AGColor bc1;
+  AGColor bc2;
+  AGTheme *theme=getTheme();
+
+  bc1=theme->getColor(mTheme+"button.border.color1");
+  bc2=theme->getColor(mTheme+"button.border.color2");
+
+  // draw border
+  
+  AGRect2 mr;
+  
+  mr=getRect().origin();
+  
+  if(mState==NORMAL || mState==LIGHTED)
+    p.drawBorder(mr,borderWidth,bc1,bc2);
+  else 
+    p.drawBorder(mr,borderWidth,bc2,bc1);
+}
+
+
+bool AGButton::eventMouseEnter()
+{
+  AGWidget::eventMouseEnter();
+  queryRedraw();
+  if(!mEnabled)
+    return false;
+  if(mChecked)
+    mState=CHECKEDLIGHTED;
+  else
+    mState=LIGHTED;
+  return false;
+}
+bool AGButton::eventMouseLeave()
+{
+  AGWidget::eventMouseLeave();
+  queryRedraw();
+  if(!mEnabled)
+    return false;
+  if(mChecked)
+    mState=CHECKED;
+  else
+    mState=NORMAL;
+  return false;
+}
+
+
+bool AGButton::eventMouseButtonDown(AGEvent *e)
+{
+  if(e->isSDLEvent())
+    {
+      if(getScreenRect().contains(e->getMousePosition()))
+	{
+	  if(mEnabled)
+	    {
+	      queryRedraw();
+	      if(mChecked)
+		mState=CHECKEDPRESSED;
+	      else
+		mState=PRESSED;
+
+	      AGWidget::eventMouseButtonDown(e); // let it get the buttondown-info
+	    }
+	  
+	  return true;
+	}
+    }
+  return AGWidget::eventMouseButtonDown(e);
+}
+
+bool AGButton::eventMouseButtonUp(AGEvent *e)
+{
+  if(e->isSDLEvent())
+    {
+      if(mEnabled)
+	{
+	  queryRedraw();
+	  if(getScreenRect().contains(e->getMousePosition()))
+	    {
+	      if(mChecked)
+		mState=CHECKEDLIGHTED;
+	      else
+		mState=LIGHTED;
+	    }
+	  else
+	    {
+	      if(mChecked)
+		mState=CHECKED;
+	      else
+		mState=NORMAL;
+	    }
+	}
+     
+    }
+  return AGWidget::eventMouseButtonUp(e);
+}
+
+void AGButton::setWidth(float w)
+{
+  assert(w>=0);
+  ccdebug(w);
+  AGWidget::setWidth(w);
+  std::list<AGWidget*>::iterator i=mChildren.begin();
+  for(;i!=mChildren.end();i++)
+    (*i)->setRect(getRect().shrink(borderWidth));
+}
+void AGButton::setHeight(float h)
+{
+  assert(h>=0);
+  AGWidget::setHeight(h);
+  std::list<AGWidget*>::iterator i=mChildren.begin();
+  for(;i!=mChildren.end();i++)
+    (*i)->setRect(getRect().shrink(borderWidth));
+}
+
+/**
+   \return returns the text displayed on the button
+*/
+AGStringUtf8 AGButton::getCaption() const
+{
+  return mText;
+}
+
+/**
+   dis- or enables the button. disabled buttons are typically displayed greyed and are 
+   not hoverable or clckable
+
+   \param pEnable true or false
+*/
+
+void AGButton::setEnabled(bool pEnable)
+{
+  if(mEnabled!=pEnable)
+    {
+      mEnabled=pEnable;
+      setState(mState); // check
+      queryRedraw();
+      if(mImageW)
+	{
+	  if(mEnabled)
+	    mImageW->setSurface(mSurface);
+	  else
+	    mImageW->setSurface(mGrayedSurface);
+	}
+
+    }
+}
+
+void AGButton::setTheme(const AGString &pTheme)
+{
+  queryRedraw();
+  mTheme=addPoint(pTheme);
+
+  lower=getTheme()->getInt(mTheme+"buttonLowerOnClick");
+  borderWidth=getTheme()->getInt(mTheme+"button.border.width");
+
+  mBG[NORMAL]=AGBackground(mTheme+"button.background.normal");
+  mBG[PRESSED]=AGBackground(mTheme+"button.background.pressed");
+  mBG[LIGHTED]=AGBackground(mTheme+"button.background.lighted");
+  mBG[CHECKED]=AGBackground(mTheme+"button.background.checked");
+  mBG[CHECKEDLIGHTED]=AGBackground(mTheme+"button.background.checkedlighted");
+  mBG[CHECKEDPRESSED]=AGBackground(mTheme+"button.background.checkedpressed");
+  mBG[DISABLED]=AGBackground(mTheme+"button.background.disabled");
+
+  mBorder[NORMAL]=AGBorder(mTheme+"button.border.normal");
+  mBorder[PRESSED]=AGBorder(mTheme+"button.border.pressed");
+  mBorder[LIGHTED]=AGBorder(mTheme+"button.border.lighted");
+  mBorder[CHECKED]=AGBorder(mTheme+"button.border.checked");
+  mBorder[CHECKEDLIGHTED]=AGBorder(mTheme+"button.border.checkedlighted");
+  mBorder[CHECKEDPRESSED]=AGBorder(mTheme+"button.border.checkedpressed");
+  mBorder[DISABLED]=AGBorder(mTheme+"button.border.disabled");
+
+  if(mTextW)
+    mTextW->setTheme(mTheme+"button.text");
+
+}
+
+void AGButton::setCaption(const AGStringUtf8 &pCaption)
+{
+  queryRedraw();
+  mText=pCaption;
+  if(mTextW)
+    mTextW->setText(pCaption);
+  if(mImageW)
+    mImageW->hide();
+}
+
+void AGButton::setState(const State &pState)
+{
+  queryRedraw();
+  if(mEnabled)
+    {
+      if(mState==DISABLED)
+	mState=NORMAL;
+      else
+	mState=pState;
+    }
+  else
+    mState=DISABLED;
+}
+
+AGButton::State AGButton::getState() const
+{
+  return mState;
+}
+
+
+void AGButton::setChecked(bool pChecked)
+{
+  queryRedraw();
+  mChecked=pChecked;
+  if(mChecked)
+    {
+      if(mState==LIGHTED || mState==CHECKEDLIGHTED)
+	setState(CHECKEDLIGHTED);
+      else
+	setState(CHECKED);
+    }
+  else
+    {
+      if(mState==LIGHTED || mState==CHECKEDLIGHTED)
+	setState(LIGHTED);
+      else
+	setState(NORMAL);
+    }
+}
+bool AGButton::isChecked() const
+{
+  return mChecked;
+}
+
+
+AGButton &toAGButton(AGWidget &pWidget)
+{
+  return dynamic_cast<AGButton&>(pWidget);
+}
+
+/**
+   \brief can this widget widget be focused.
+
+   \return always true
+*/
+bool AGButton::canFocus() const
+{
+  return true;
+}
+
+/**
+   \brief special function for "using textures"
+
+   within a texture-garbage-collection run all unused textures get cleaned,
+   so this function "uses" the textures. This way they won't get collected
+*/
+
+void AGButton::useTextures()
+{
+  for(std::map<State,AGBackground>::iterator i=mBG.begin();i!=mBG.end();++i)
+    i->second.useTextures();
+  for(std::map<State,AGBorder>::iterator i=mBorder.begin();i!=mBorder.end();++i)
+    i->second.useTextures();
+}
+
+bool AGButton::isOpaque() const
+{
+  return true;
+}

Added: antargis/branches/rant/ext/gui/ag_button.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_button.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_button.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_button.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_BUTTON_H
+#define AG_BUTTON_H
+
+#include "ag_widget.h"
+#include "ag_surface.h"
+#include "ag_background.h"
+#include "ag_border.h"
+
+#include <iostream>
+#include <map>
+
+class AGEdit;
+class AGImage;
+
+/**
+   \brief implements push-buttons
+   \ingroup widgets
+
+   AGButton represents a button, which can hold a text-caption or an image-caption, but not both.
+   Further it can have following states:
+*/
+
+class AGButton:public AGWidget
+{
+ public:
+  /// the different drawing states
+   enum State {
+     NORMAL,         //!< the normal state of a button
+     LIGHTED,        //!< the button is lighted or hovered
+     PRESSED,        //!< the button is pressed (typically hovered)
+     CHECKED,        //!< the button is checked (and not pressed)
+     CHECKEDLIGHTED, //!< a hovered and checked button
+     CHECKEDPRESSED, //!< hovered, checked and pressed
+     DISABLED        //!< the button disabled (greyed)
+   };
+
+  AGButton(AGWidget *pParent,const AGRect2 &r,const AGStringUtf8&pText,int id=-1);
+
+  void setSurface(AGSurface pSurface,bool pChangeSize=false);
+  void setTexture(const AGTexture &pTexture);
+
+  virtual void draw(AGPainter &p);
+
+  virtual bool eventMouseEnter();
+  virtual bool eventMouseLeave();
+
+  virtual bool eventMouseButtonDown(AGEvent *m);
+  virtual bool eventMouseButtonUp(AGEvent *m);
+
+  virtual void setWidth(float w);
+  virtual void setHeight(float w);
+
+  virtual AGStringUtf8 getCaption() const;
+
+  void setEnabled(bool pEnable);
+
+  void setTheme(const AGString &pTheme);
+
+  void setCaption(const AGStringUtf8 &pCaption);
+
+  /// sets the current state and ensures a redraw
+  virtual void setState(const State &pState);
+  State getState() const;
+
+  virtual void setChecked(bool pChecked);
+  bool isChecked() const;
+
+  bool canFocus() const;
+
+  virtual void useTextures();
+
+  bool isOpaque() const;
+
+ private:
+  AGStringUtf8 mText;
+  int mID;
+  AGString mTheme;
+  State mState;
+  int borderWidth;
+  AGSurface mSurface;
+  AGSurface mGrayedSurface;
+  bool mHasSurface;
+  AGEdit *mTextW;
+  AGImage *mImageW;
+
+  bool lower;
+  bool mChecked;
+
+  std::map<State,AGBackground> mBG;
+  std::map<State,AGBorder> mBorder;
+  bool mEnabled;
+};
+
+AGButton &toAGButton(AGWidget &pWidget);
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_caption.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_caption.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_caption.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_caption.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_caption.h"
+#include "ag_debug.h"
+#include "ag_screen.h"
+
+AGCaption::AGCaption(AGWidget *pParent,const AGRect2 &pRect,const AGStringUtf8 &pText,const AGFont &pFont,const AGBackground &pBG):
+  AGText(pParent,pRect,pText,pFont),
+  mBG(pBG)
+{
+}
+
+void AGCaption::draw(AGPainter &p)
+{
+  // draw bg
+  mBG.draw(getRect().origin(),p);
+  AGText::draw(p);
+}
+
+void AGCaption::setBackground(AGBackground pBG)
+{
+  mBG=pBG;
+}

Added: antargis/branches/rant/ext/gui/ag_caption.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_caption.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_caption.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_caption.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_CAPTION_H
+#define AG_CAPTION_H
+
+#include "ag_text.h"
+#include "ag_background.h"
+
+class AGCaption:public AGText
+{
+ public:
+  AGCaption(AGWidget *pParent,const AGRect2 &pRect,const AGStringUtf8 &pText,const AGFont &pFont,const AGBackground &pBG);
+
+  void draw(AGPainter &p);
+
+  void setBackground(AGBackground pBG);
+ private:
+  AGBackground mBG;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_checkbox.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_checkbox.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_checkbox.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_checkbox.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_checkbox.h"
+#include "ag_image.h"
+#include "ag_text.h"
+#include "ag_theme.h"
+#include "ag_debug.h"
+#include "ag_layoutfactory.h"
+#include "ag_local.h"
+
+AGCheckBox::AGCheckBox(AGWidget *pParent,AGRect2 pRect):
+  AGButton(pParent,pRect,"")//,mChecked(false)
+{
+  mSurfaces[0]=mSurfaces[1]=0;
+  /*  mImage=0;
+  if(getTheme()->hasSurface(mType+".normal"))
+    addChild(mImage=new AGImage(this,AGVector2(0,0),getTheme()->getSurface(mType+".normal"),false));
+  addChild(new AGText(this,AGVector2(0,0),pName,getTheme()->getFont(std::string("Font.")+mType)));
+
+  adaptHeightFromChildren();*/
+}
+
+bool AGCheckBox::eventMouseClick(AGEvent *m)
+{
+  CTRACE;
+  setChecked(!isChecked());
+  /*
+  mChecked=!mChecked;
+  if(mChecked)
+    setState(CHECKED);
+  else
+  setState(NORMAL);*/
+    /*
+
+  if(mImage)
+    {
+      if(mChecked)
+	mImage->setSurface(getTheme()->getSurface(mType+".checked"));
+      else
+	mImage->setSurface(getTheme()->getSurface(mType+".normal"));
+	}*/
+  return AGButton::eventMouseClick(m);//false;//true; // eat
+}
+
+/*
+std::string AGCheckBox::getName() const
+{
+  return mName;
+}
+*/
+
+
+void AGCheckBox::setSurfaces(AGSurface pDisabledSurface,AGSurface pEnabledSurface)
+{
+  delete mSurfaces[0];
+  delete mSurfaces[1];
+  mSurfaces[0]=new AGSurface(pDisabledSurface);
+  mSurfaces[1]=new AGSurface(pEnabledSurface);
+
+  //  setState(getState());
+  queryRedraw();
+}
+
+void AGCheckBox::setState(const State &pState)
+{
+  if(mSurfaces[0])
+    {
+      if(pState==NORMAL || pState==LIGHTED || pState==PRESSED)
+	setSurface(*(mSurfaces[0]));
+      else
+	setSurface(*(mSurfaces[1]));
+    }
+
+  AGButton::setState(pState);
+}
+
+

Added: antargis/branches/rant/ext/gui/ag_checkbox.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_checkbox.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_checkbox.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_checkbox.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_CHECK_BOX_H
+#define AG_CHECK_BOX_H
+
+//#include "ag_vtiler.h"
+#include "ag_button.h"
+
+class AGImage;
+
+class AGCheckBox:public AGButton
+{
+ public:
+  AGCheckBox(AGWidget *pParent,AGRect2 pRect);
+
+  void setSurfaces(AGSurface pDisabledSurface,AGSurface pEnabledSurface);
+
+  void setState(const State &pState);
+  virtual bool eventMouseClick(AGEvent *m);
+ private:
+  AGSurface *mSurfaces[2];
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_colorbutton.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_colorbutton.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_colorbutton.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_colorbutton.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_colorbutton.h"
+#include "ag_layoutfactory.h"
+
+AGColorButton::AGColorButton(AGWidget *pParent,const AGRect2 &r,int x,int y):
+  AGWidget(pParent,r),gridx(x),gridy(y),mColors(x*y)
+{
+}
+
+void AGColorButton::draw(AGPainter &p)
+{
+  AGWidget::draw(p);
+  
+  int i=0;
+  AGRect2 ar(getRect().origin());
+  float w=ar.w()/gridx;
+  float h=ar.h()/gridy;
+  for(int y=0;y<gridy;y++)
+    for(int x=0;x<gridx;x++)
+      {
+	AGRect2 r(ar.w()*x/gridx,ar.h()*y/gridy,w,h);
+	p.fillRect(r,mColors[i++]);
+      }
+}
+
+AGColor AGColorButton::getColor() const
+{
+  return mColor;
+}
+
+void AGColorButton::setColor(const AGColor &c)
+{
+  mColor=c;
+}
+void AGColorButton::setColor(int x,int y,const AGColor &c)
+{
+  assert(x>=0);
+  assert(y>=0);
+  assert(x<gridx);
+  assert(y<gridy);
+  mColors[x+y*gridx]=c;
+}
+
+
+AGColorButton &toAGColorButton(AGWidget &pWidget)
+{
+  return dynamic_cast<AGColorButton&>(pWidget);
+}
+
+bool AGColorButton::eventMouseClick(AGEvent *e)
+{
+  //  const AGSDLEvent *e=dynamic_cast<const AGSDLEvent*>(m);
+  if(e->isSDLEvent())
+    {
+      AGVector2 p=e->getMousePosition();
+      p-=getScreenRect().getV0();
+      float gx=p[0]*gridx/getRect().w();
+      float gy=p[1]*gridy/getRect().h();
+      float d=gx+gy*gridx;
+      cdebug(p[0]<<"   "<<p[1]);
+      cdebug("gx:"<<gx<<"  gy:"<<gy);
+      assert(d<gridx*gridy && d>=0);
+      mColor=mColors[size_t(d)];
+      cdebug(mColor.toString());
+    }
+
+  return AGWidget::eventMouseClick(e);
+}
+
+

Added: antargis/branches/rant/ext/gui/ag_colorbutton.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_colorbutton.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_colorbutton.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_colorbutton.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_COLORBUTTON_H
+#define AG_COLORBUTTON_H
+
+#include "ag_widget.h"
+#include "ag_color.h"
+#include <vector>
+
+class AGColorButton:public AGWidget
+{
+ public:
+  AGColorButton(AGWidget *pParent,const AGRect2 &r,int x,int y);
+
+  virtual void draw(AGPainter &p);
+
+  AGColor getColor() const;
+  void setColor(const AGColor &c);
+  void setColor(int x,int y,const AGColor &c);
+
+  virtual bool eventMouseClick(AGEvent *m);
+
+ private:
+  int gridx,gridy;
+  std::vector<AGColor> mColors;
+
+  AGColor mColor;
+};
+
+AGColorButton &toAGColorButton(AGWidget &pWidget);
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_combo.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_combo.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_combo.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,129 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_combo.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_application.h"
+#include "ag_button.h"
+#include "ag_combo.h"
+#include "ag_debug.h"
+#include "ag_edit.h"
+#include "ag_listbox.h"
+#include "ag_theme.h"
+
+AGComboBox::AGComboBox(AGWidget *pParent,const AGRect2 &pRect):
+  AGWidget(pParent,pRect),sigSelect(this,"sigSelect")
+{
+  mEdit=new AGEdit(this,AGRect2(0,0,width()-height(),height()));
+  mButton=new AGButton(this,AGRect2(width()-height(),0,height(),height()),"");
+
+  mButton->setSurface(AGSurface::load("data/gui/arrow_down.png"));
+
+  AGFont f=getTheme()->getFont("combobox.font");
+
+  mEdit->setMutable(false);
+  mEdit->setFont(f);
+  addChild(mEdit);
+  addChild(mButton);
+
+  mButton->sigClick.connect(slot(this,&AGComboBox::eventButtonClicked));
+}
+
+
+void AGComboBox::insertItem(const AGString &pID,const AGStringUtf8 &pContent)
+{
+  ops.push_back(std::make_pair(pID,pContent));
+  if(ops.size()==1)
+    mID=pID;
+  update();
+}
+
+void AGComboBox::update()
+{
+  if(ops.size()>0)
+    {
+      // find
+      AGStringUtf8 text;
+      for(std::list<std::pair<AGString,AGStringUtf8> >::iterator i=ops.begin();i!=ops.end();i++)
+	if(i->first==mID)
+	  {
+	    text=i->second;
+	    break;
+	  }
+
+      mEdit->setText(text);
+    }
+}
+
+bool AGComboBox::eventButtonClicked(AGEvent *pEvent)
+{
+  if(ops.size()==0)
+    return true;
+
+  AGRect2 sr=getScreenRect();
+
+  cdebug(sr.x());
+  cdebug(sr.y());
+  cdebug(width());
+  cdebug(getTheme()->getInt("listbox.item.height")*std::min(8,(int)ops.size()));
+
+  float mItemHeight=getTheme()->getInt("listbox.item.height");
+  if(mItemHeight<5)
+    mItemHeight=25;
+
+
+  mListBox=new AGListBox(0,AGRect2(sr.x(),sr.y()+height(),width(),mItemHeight*8));
+
+  mListBox->sigSelect.connect(slot(this,&AGComboBox::eventSelected));
+
+  for(std::list<std::pair<AGString,AGStringUtf8> >::iterator i=ops.begin();i!=ops.end();i++)
+    mListBox->insertItem(i->first,i->second);
+  if(ops.size()>0)
+    mListBox->selectItem(mID);
+
+  getApplication()->setOverlay(mListBox);
+  return true;
+}
+
+bool AGComboBox::eventSelected(AGEvent *pEvent)
+{
+  CTRACE;
+  mID=mListBox->getSelectedID();
+  update();
+  getApplication()->setOverlay(0);
+
+  sigSelect(new AGEvent(this,"sigSelect"));
+  return true;
+}
+
+AGString AGComboBox::getSelected() const
+{
+  return mID;
+}
+void AGComboBox::setSelected(const AGString &pID)
+{
+  mID=pID;
+  update();
+}
+
+void AGComboBox::clear()
+{
+  ops.clear();
+  mID="";
+  update();
+}

Added: antargis/branches/rant/ext/gui/ag_combo.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_combo.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_combo.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_combo.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_COMBO_H
+#define AG_COMBO_H
+
+#include <ag_widget.h>
+
+class AGEdit;
+class AGButton;
+class AGListBox;
+
+class AGComboBox:public AGWidget
+{
+ public:
+  AGComboBox(AGWidget *pParent,const AGRect2 &pRect);
+
+  void insertItem(const AGString &pID,const AGStringUtf8 &pContent);
+
+  bool eventButtonClicked(AGEvent *pEvent);
+  bool eventSelected(AGEvent *pEvent);
+
+  AGSignal sigSelect;
+  
+  AGString getSelected() const;
+  void setSelected(const AGString &pID);
+
+  void clear();
+
+ private:
+  void update();
+
+  AGEdit *mEdit;
+  AGButton *mButton;
+  AGListBox *mListBox;
+
+  AGString mID;
+
+  std::list<std::pair<AGString,AGStringUtf8> > ops;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_edit.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_edit.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_edit.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,996 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_edit.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_edit.h"
+#include "ag_fontengine.h"
+#include "ag_theme.h"
+#include "ag_debug.h"
+#include "ag_menu.h"
+#include "ag_sgeexport.h"
+#include "ag_glscreen.h"
+#include "ag_tools.h"
+
+
+AGEditLine::AGEditLine(const AGStringUtf8 &pText,AGFont pFont,bool pHardEnd):
+  mText(pText),mFont(pFont),mHardEnd(pHardEnd)
+{
+  mAlign=EDIT_LEFT;
+  mVAlign=EDIT_TOP;
+}
+
+AGEditLine::~AGEditLine()
+{
+}
+
+void AGEditLine::setAlign(AGAlign pAlign)
+{
+  mAlign=pAlign;
+}
+
+void AGEditLine::setVAlign(AGVAlign pVAlign)
+{
+  mVAlign=pVAlign;
+}
+
+void AGEditLine::setFont(const AGFont &pFont)
+{
+  mFont=pFont;
+}
+
+
+AGFont AGEditLine::getFont() const
+{
+  return mFont;
+}
+
+#define SMALL_CHUNKS
+
+void AGEditLine::draw(AGPainter &p,const AGVector2 &pPoint,const AGRect2 &pClip)
+{
+  int x=0;
+  if(mAlign==EDIT_CENTER)
+    x=(int)((pClip.w()-mFont.getWidth(mText))/2);
+
+#ifdef SMALL_CHUNKS
+  int mx=0;
+  std::vector<AGStringUtf8> a=mText.split(AGStringUtf8(" "));
+  for(std::vector<AGStringUtf8>::iterator i=a.begin();i!=a.end();i++)
+    {
+      //      cdebug(*i);
+      p.renderText(*i,AGVector2(pPoint[0]+x+mx,pPoint[1]),mFont);
+      mx+=getFontEngine()->getWidth(mFont,*i+" ");
+    }
+#else
+  p.renderText(mText+(mHardEnd?"":""),AGVector2(pPoint.x+x,pPoint.y),mFont);
+#endif
+}
+
+void AGEditLine::drawCursor(AGPainter &p,int cx,const AGVector2 &pPoint,const AGRect2 &pClip,const AGColor &c)
+{
+  int x1=getFontEngine()->getWidth(mFont,mText.substr(0,cx));
+  int x2=getFontEngine()->getWidth(mFont,mText.substr(0,cx+1));
+
+  int w=x2-x1;
+  if(w==0)
+    w=8;
+
+#ifdef SIMPLE_BOX_CURSOR
+  p.fillRect(AGRect2(pPoint[0]+x1,pPoint[1],w,height()),c);
+#else
+  float x=pPoint[0]+x1-4;
+  float y=pPoint[1];
+  float h=height();
+
+  w=10;
+
+  p.fillRect(AGRect2(x,y,w+1,3),c);
+  p.fillRect(AGRect2(x+w/2-1,y+3,3,h-6),c);
+  p.fillRect(AGRect2(x,y+h-3,w+1,3),c);
+#endif
+}
+
+
+int AGEditLine::height() const
+{
+  return getFontEngine()->getHeight(mFont,mText);
+}
+int AGEditLine::width() const
+{
+  return getFontEngine()->getWidth(mFont,mText);
+}
+
+void AGEditLine::insert(const AGStringUtf8 &c,int cx,bool pInsert)
+{
+  if(pInsert)
+    mText=mText.substr(0,cx)+c+mText.substr(cx,AGString::npos);
+  else if(cx<(long)mText.length())
+    mText[cx]=c;
+  else
+    mText+=c;
+}
+
+void AGEditLine::doDelete(int cx)
+{
+  if(mText.length()>0)
+    if(cx>=0&&cx<int(mText.length()))
+      mText=mText.substr(0,cx)+mText.substr(cx+1,AGString::npos);
+
+}
+
+AGEditLine AGEditLine::split(int cx)
+{
+  AGStringUtf8 n=mText.substr(cx,mText.npos);
+  mText=mText.substr(0,cx);
+  bool hard=mHardEnd;
+  mHardEnd=true;
+  return AGEditLine(n,mFont,hard);
+}
+
+int AGEditLine::length() const
+{
+  return mText.length();
+}
+
+void AGEditLine::append(const AGStringUtf8 &s)
+{
+  mText+=s;
+}
+
+void AGEditLine::prepend(const AGStringUtf8 &s)
+{
+  mText=s+mText;
+}
+AGStringUtf8 AGEditLine::getText() const
+{
+  return mText;
+}
+
+// returns the remaing string after wrapping
+std::pair<AGStringUtf8,bool> AGEditLine::checkWrap(int pW)
+{
+  // first check, if line is too long
+
+  if(getFontEngine()->getWidth(mFont,mText)<pW)
+    return std::make_pair("",false);
+
+  // ok, line is too long
+  // so search for a good split (between words), but not before half of width
+  std::vector<AGStringUtf8> words=mText.split(" ");
+  
+  std::vector<AGStringUtf8>::iterator i=words.begin();
+  int w=0,ow=0;
+  AGStringUtf8 s,os;
+
+  for(;i!=words.end();i++)
+    {
+      s+=*i;
+      w=getFontEngine()->getWidth(mFont,s);
+      if(w>pW)
+	break;
+
+      ow=w;
+      os=s;
+      s+=" ";
+    }
+  if(ow>pW/4 && ow<width())
+    {
+      // check if width will be at least a 1/4 of whole width
+      AGStringUtf8 n=mText.substr(os.length()+1,n.npos);
+      mText=mText.substr(0,os.length()+1);
+
+      bool hard=mHardEnd;
+      mHardEnd=false;
+      return std::make_pair(n,hard);
+    }
+
+
+  // find first character, which stands over
+  size_t k=0;
+  w=ow=0;
+  s=os="";
+  for(;k<mText.length();k++)
+    {
+      s+=mText.substr(k,1);
+      w=getFontEngine()->getWidth(mFont,s);
+      if(w>pW)
+	break;
+
+      ow=w;
+      os=s;
+    }
+  if(k>=mText.length())
+    return std::make_pair("",false); // some error
+  AGStringUtf8 n=mText.substr(k,mText.length());
+  mText=mText.substr(0,k);
+  bool hard=mHardEnd;
+  mHardEnd=false;
+  return std::make_pair(n,hard);
+}
+
+void AGEditLine::setHardEnd(bool pHardEnd)
+{
+  mHardEnd=pHardEnd;
+}
+
+bool AGEditLine::hardEnd() const
+{
+  return mHardEnd;
+}
+
+std::pair<AGStringUtf8,bool> AGEditLine::checkUnwrap(int pW,const AGStringUtf8 &s)
+{
+  AGStringUtf8 oldtext=mText;
+  //  mText+=" ";
+  mText+=s;
+  AGStringUtf8 testtext=mText;
+  std::pair<AGStringUtf8,bool> res=checkWrap(pW);
+  if(mText!=oldtext)
+    return std::make_pair(testtext.substr(mText.length(),AGString::npos),true);
+  else
+    return std::make_pair("",false);
+  
+}
+
+void AGEditLine::setText(const AGStringUtf8 &s)
+{
+  mText=s;
+}
+
+
+
+
+
+
+  
+AGEdit::AGEdit(AGWidget *pParent,const AGRect2 &pRect):
+  AGWidget(pParent,pRect),mCursorTime(0),mCursorLast(SDL_GetTicks()),
+  mLShift(false),mRShift(false),mLCtrl(false),mRCtrl(false),mLAlt(false),mRAlt(false),
+  mMultiLine(true),mWrapLines(true)
+{
+  mInserting=true;
+  mMaxLength=-1;
+  mMutable=true;
+  mShowCursor=true;
+  AGFont font1("FreeSans.ttf",14);
+  AGFont font2("FreeSans.ttf",13);
+  font1.setColor(AGColor(0,0,0));
+  font2.setColor(AGColor(0,0,0xFF));
+  AGEditLine l("",font1,true);
+  mAlign=EDIT_LEFT;
+  mVAlign=EDIT_TOP;
+  l.setAlign(mAlign);
+  l.setVAlign(mVAlign);
+  mLines.push_back(l);
+
+  mCx=mCy=0;
+  mViewCy=0;
+
+  AGString t=mTheme;
+  if(t.length())
+    t+=".";
+  mBackground=AGBackground(t+"edit.background");
+  mDrawBackground=true;
+  setTheme("edit");
+}
+
+void AGEdit::setMaxLength(int i)
+{
+  mMaxLength=i;
+}
+
+
+void AGEdit::draw(AGPainter &p)
+{
+  
+  int x,y,cy;
+  int completeHeight=0;
+  x=y=cy=0;
+  
+  drawBackground(p);//pRect);
+
+  std::list<AGEditLine>::iterator i=mLines.begin();
+
+  //  cdebug(pRect);
+  //  cdebug("getRect:"<<getRect());
+  AGRect2 mr(getRect());//pRect.project(getRect()));
+
+  AGColor cursorC=AGColor(0,0,0,0x7f);
+  if(mShowCursor) // && opengl())
+    cursorC=AGColor(0x7f,0x7f,0x7f,0x7f);
+  
+  if(mCy<mViewCy)
+    mViewCy=mCy;
+
+  // get complete height - for hor. centering
+  for(i=mLines.begin();i!=mLines.end();i++)
+    {
+      completeHeight+=i->height();
+    }
+
+  //  cdebug("completeHeight:"<<completeHeight);
+  //  cdebug("height:"<<getRect().h);
+  if(mVAlign==EDIT_VCENTER)
+    y=(int)(getRect().h()/2-completeHeight/2);
+  //  cdebug("y:"<<y);
+
+  i=mLines.begin();
+
+
+  //  cdebug("mRect:"<<getRect());
+  //  cdebug("mViewCy:"<<mViewCy);
+  for(int k=0;k<mViewCy;k++)
+    i++;
+
+  //  cdebug("mLines:"<<mLines.size());
+  for(;i!=mLines.end();i++)
+    {
+      //      cdebug((*i).getText());
+      //      cdebug("("<<x<<";"<<y<<")");
+      //      cdebug(mr);
+      i->draw(p,AGVector2(x,y),getRect().origin());//pRect.project(getRect()));
+      if(cy+mViewCy==mCy && mMutable && hasFocus()) // FIXME: Change show cursor only if widget has focus
+	i->drawCursor(p,mCx,AGVector2(x,y),getRect(),cursorC);
+      y+=i->height();
+      if(y>getRect().h())
+	{
+	  //	  cdebug("break - too far y:"<<y<<" h:"<<getRect().h);
+	  break;
+	}
+      cy++;
+      if(!mMultiLine)
+	{
+	  //	  cdebug("break - no multiline");
+	  break;
+	}
+    }
+
+  // do it next time
+  if(cy+mViewCy-1<mCy)
+    mViewCy=mCy-cy+1;
+
+}
+
+void AGEdit::drawBackground(AGPainter &p)
+{
+  //  CTRACE;
+  if(mDrawBackground)
+    {
+      //  CTRACE;
+      mBackground.draw(getRect().origin(),p);
+    }
+  //    p.tile(mBackground,getRect());
+}
+
+bool AGEdit::eventKeyUp(AGEvent *m)
+{
+  if(!mMutable)
+    return false;
+  //  const AGSDLEvent *m=reinterpret_cast<const AGSDLEvent*>(m2);
+  if(m->isSDLEvent())
+    {
+      SDLKey k=m->getKey();
+      //      char ins=0;
+      //      bool doInsert=false;
+      if(k==SDLK_LSHIFT)
+	mLShift=false;
+      else if(k==SDLK_RSHIFT)
+	mRShift=false;
+      else if(k==SDLK_LCTRL)
+	mLCtrl=false;
+      else if(k==SDLK_RCTRL)
+	mRCtrl=false;
+      else if(k==SDLK_LALT)
+	mLAlt=false;
+      else if(k==SDLK_RALT)
+	mRAlt=false;
+    }
+  return false;
+}
+bool AGEdit::eventKeyDown(AGEvent *m)
+{
+  if(!mMutable)
+    return false;
+  if(!hasFocus())
+    return false;
+  queryRedraw();
+  if(m->isSDLEvent())
+    {
+      SDLKey k=m->getKey();
+      Uint16 unicode=m->getUnicode();
+      AGStringUtf8 ins;
+      bool doInsert=false;
+      bool used=false;
+      if(k==SDLK_RIGHT)
+	{
+	  getActLine();
+	  if(actLine->length()>mCx)
+	    mCx++;
+	  else if(mCy<(int)mLines.size()-1)
+	    {
+	      mCy++;
+	      mCx=0;
+	    }
+	  return true;
+	}
+      else if(k==SDLK_LEFT)
+	{
+	  if(mCx>0)
+	    mCx--;
+	  else if(mCy>0)
+	    {
+	      mCy--;
+	      getActLine();
+	      mCx=actLine->length();
+	    }
+	  
+	  return true;
+	}
+      else if(k==SDLK_UP && mMultiLine)
+	{
+	  if(mCy>0)
+	    mCy--;
+	  getActLine();
+	  if(mCx>=actLine->length())
+	    mCx=actLine->length();
+	  return true;
+	}
+      else if(k==SDLK_DOWN && mMultiLine)
+	{
+	  if((int)mLines.size()>mCy+1)
+	    mCy++;
+	  getActLine();
+	  if(mCx>=actLine->length())
+	    mCx=actLine->length();
+	  return true;
+	}
+      /*      else if(k>=SDLK_0 && k<=SDLK_9)
+	{
+	  doInsert=true;
+	  if(mRShift||mLShift)
+	    {
+	      AGString s="=!\"??$%&/()";
+	      ins=s[k-SDLK_0];
+	    }
+	  else
+	    ins='0'+(k-SDLK_0);
+	}
+      else if(k>=SDLK_a && k<=SDLK_z)
+	{
+	  doInsert=true;
+	  if(mRShift||mLShift)
+	    ins='A'+(k-SDLK_a);
+	  else
+	    ins='a'+(k-SDLK_a);
+	    }*/
+      else if(k==SDLK_SPACE)
+	{
+	  doInsert=true;
+	  ins=" ";
+	}
+      else if(k==SDLK_BACKSPACE)
+	{
+	  if(mCx>0)
+	    {
+	      doDelete(mCx-1);
+	      mCx--;
+	    }
+	  else if(mCy>0 && mMultiLine)
+	    {
+	      mCy--;
+	      getActLine();
+	      mCx=actLine->length();
+	      if(!actLine->hardEnd())
+		{
+		  // delete last char
+		  doDelete(actLine->length()-1);
+		  mCx--;
+		}
+	      mergeLine(mCy);
+	    }
+	  checkWrap();
+	  used=true;
+	}
+      else if(k==SDLK_DELETE)
+	{
+	  doDelete(mCx);
+	  checkWrap();
+	  used=true;
+	}
+      else if(k==SDLK_RETURN && mMultiLine)
+	{
+	  getActLine();
+	  AGEditLine l=actLine->split(mCx);
+	  l.setAlign(mAlign);
+	  l.setVAlign(mVAlign);
+	  mCx=0;
+	  mCy++;
+	  insertLine(l);
+	  checkWrap();
+	  used=true;
+	}
+      else if(k==SDLK_END)
+	{
+	  getActLine();
+	  mCx=actLine->length();
+	  used=true;
+	}
+      else if(k==SDLK_HOME)
+	{
+	  mCx=0;
+	  used=true;
+	}
+
+      else if(k==SDLK_LSHIFT)
+	{
+	  used=true;
+	  mLShift=true;
+	}
+      else if(k==SDLK_RSHIFT)
+	{
+	  used=true;
+	  mRShift=true;
+	}
+      else if(k==SDLK_LCTRL)
+	{
+	  used=true;
+	  mLCtrl=true;
+	}
+      else if(k==SDLK_RCTRL)
+	{
+	  used=true;
+	  mRCtrl=true;
+	}
+      else if(k==SDLK_LALT)
+	{
+	  cdebug("lalt");
+	  mLAlt=true;
+	}
+      else if(k==SDLK_RALT)
+	{
+	  cdebug("ralt");
+	  mRAlt=true;
+	}
+      /*      else if(strlen(SDL_GetKeyName(k))==1)
+	{
+	  cdebug(k<<":"<<SDL_GetKeyName(k));
+	  ins=SDL_GetKeyName(k)[0];
+	  doInsert=true;
+	  }*/
+      //      else if(k==SDLK_WORLD_68)
+      else if((unicode&0xFFF8)!=0 || (k>=SDLK_0 && k<=SDLK_9) || (k>=SDLK_a && k<=SDLK_z))
+	{
+	  //	  ins=(mLShift||mRShift)?"?":"?";
+
+	  /*
+	  cdebug(unicode);
+	  //	  ins=(mLShift||mRShift)?"?":"?";
+
+	  cdebug(1);
+	  std::string n="  ";
+	  //	  ins="  ";
+	  cdebug(1);
+	  n[1]=(unicode>>8)&0xFF;
+	  cdebug(1);
+	  n[0]=(unicode)&0xFF;
+	  cdebug(1);
+	  ins=AGStringUtf8(n);
+	  cdebug(1);
+	  */
+	  ins=AGStringUtf8(unicode2Utf8(unicode));
+
+	  cdebug((int)ins.toString()[0]<<"  "<<(int)ins.toString()[1]);
+
+	  doInsert=true;
+	}
+      /*      else if(k==SDLK_WORLD_86)
+	{
+	  ins=(mLShift||mRShift)?"?":"?";
+	  doInsert=true;
+	}
+      else if(k==SDLK_WORLD_92)
+	{
+	  ins=(mLShift||mRShift)?"?":"?";
+	  doInsert=true;
+	}
+      else if(k==SDLK_WORLD_63)
+	{
+	  ins="?";
+	  doInsert=true;
+	}
+      */
+      cdebug("KEY:"<<SDL_GetKeyName(k)<<"  "<<k);
+
+      if(doInsert)
+	{
+	  if(insert(ins))
+	    mCx++;
+	  checkWrap();
+	  return true;
+	}
+      if(used)
+	return true;
+    }
+  return false;
+}
+
+bool AGEdit::insert(const AGStringUtf8 &c)
+{
+  if(mMaxLength>0)
+    {
+      if((int)getText().length()==mMaxLength)
+	{
+	  if(mInserting || mCx==actLine->length())
+	    return false; // ignore input
+	}
+    }
+  getActLine(); // FIXME:try to cache
+  actLine->insert(c,mCx,mInserting);
+  return true;
+}
+
+void AGEdit::getActLine()
+{
+  // slow
+  int i=0;
+  std::list<AGEditLine>::iterator j=mLines.begin();
+
+  for(;i!=mCy;i++)
+    j++;
+  actLine=&(*j);
+}
+
+void AGEdit::doDelete(int p)
+{
+  if(p>=0)
+    {
+      getActLine();
+      if(p==(int)actLine->length() && mCy<(int)mLines.size()-1)
+	{
+	  // merge 2 lines
+	  mergeLine(mCy);
+	}
+      else
+	actLine->doDelete(p);
+
+    }
+}
+
+void AGEdit::insertLine(AGEditLine l)
+{
+  std::list<AGEditLine>::iterator j=mLines.begin();
+  for(;&(*j)!=actLine;j++);
+  j++;
+  mLines.insert(j,l);
+}
+
+void AGEdit::mergeLine(int p)
+{
+  if(!mMultiLine)
+    return;
+  std::list<AGEditLine>::iterator j=mLines.begin();
+  int i=0;
+  for(;i<p;i++)
+    j++;
+  actLine=&(*j);
+  j++;
+  actLine->append(j->getText());
+  bool h=j->hardEnd();
+  mLines.erase(j);
+  actLine->setHardEnd(h);
+}
+
+void AGEdit::setMulti(bool pMultiLine)
+{
+  mMultiLine=pMultiLine;
+}
+
+void AGEdit::checkWrap()
+{
+  if(mWrapLines)
+    {
+      std::list<AGEditLine>::iterator i=mLines.begin();
+      for(;i!=mLines.end();)
+	{
+	  std::pair<AGStringUtf8,bool> n=i->checkWrap((int)width());
+	  if(n.first.length())
+	    {
+	      // make new line
+	      if(i->length()<mCx)
+		{
+		  mCx-=i->length();
+		  mCy++;
+		}
+	      i++;
+	      if(n.second) // is hard end
+		{
+		  AGEditLine l(n.first,actLine->getFont(),n.second);
+		  l.setAlign(mAlign);
+		  l.setVAlign(mVAlign);
+		  i=mLines.insert(i,l);
+		}
+	      else
+		{
+		  if(i==mLines.end())
+		    {
+		      AGEditLine l(n.first,actLine->getFont(),n.second);
+		      l.setAlign(mAlign);
+		      l.setVAlign(mVAlign);
+		      mLines.push_back(l);
+		      i=mLines.end();
+		      i--;
+		    }
+		  else
+		    {
+		      // fill line after
+		      i->prepend(n.first);
+		    }
+		}
+
+	    }
+	  else
+	    i++;
+	}
+     
+      // unwrapping -test
+
+      int cy=0;
+      i=mLines.begin();
+      for(;i!=mLines.end();)
+	{
+	  std::list<AGEditLine>::iterator j=i;
+	  j++;
+	  if(j!=mLines.end() && !i->hardEnd())
+	    {
+	      //	      cdebug(i->getText());
+	      std::pair<AGStringUtf8,bool> nText=i->checkUnwrap((int)width(),j->getText());
+	      if(nText.second) // changed
+		{
+		  int count=j->getText().length()-nText.first.length();
+		  // do nothing
+		  j->setText(nText.first);
+
+		  // correct cursor position
+		  if(cy==mCy-1)
+		    {
+		      // cursor is in next line
+		      mCx-=count;
+		      if(mCx<0)
+			{
+			  mCy--;
+			  mCx+=i->length();
+			}
+		    }
+		  else if(cy==mCy)
+		    {
+		      if(mCx>i->length())
+			{
+			  mCy++;
+			  mCx-=i->length();
+			}
+		    }
+		  if(nText.first=="")
+		    {
+		      // empty line
+		      i->setHardEnd(j->hardEnd());
+		      mLines.erase(j);
+		    }
+		}
+	      else
+		{
+		  i++;
+		  cy++;
+		}
+	    }
+	  else
+	    {
+	      i++;
+	      cy++;
+	    }
+	}
+ 
+    }
+}
+
+
+void AGEdit::setFont(const AGFont &pFont)
+{
+  mFont=pFont;
+  std::list<AGEditLine>::iterator i=mLines.begin();
+  for(;i!=mLines.end();i++)
+    i->setFont(mFont);
+
+}
+
+void AGEdit::setText(const AGStringUtf8 &pText)
+{
+  if(getText()==pText)
+    return;
+
+  queryRedraw();
+
+  clear();
+
+  size_t i;
+  for(i=0;i<pText.length();i++)
+    {
+      if(pText[i]=='\n')
+	{
+	  getActLine();
+	  AGEditLine l=actLine->split(mCx);
+	  l.setAlign(mAlign);
+	  l.setVAlign(mVAlign);
+	  mCx=0;
+	  mCy++;
+	  insertLine(l);
+	  checkWrap();
+	}
+      else
+	{
+	  insert(AGStringUtf8(pText[i]));
+	  mCx++;
+	  checkWrap();
+	}
+    }
+  setFont(mFont); // reset Font
+  checkWrap();
+  //  mCy=0;
+  //  mCx=mT
+  setFont(mFont); // reset Font
+}
+void AGEdit::setMutable(bool pMutable)
+{
+  mMutable=pMutable;
+  mShowCursor=pMutable; // FIXME: show cursor only if widget has focus
+}
+
+void AGEdit::setAlign(AGAlign pAlign)
+{
+  mAlign=pAlign;
+  std::list<AGEditLine>::iterator i=mLines.begin();
+  for(;i!=mLines.end();i++)
+    i->setAlign(pAlign);
+}
+
+void AGEdit::setVAlign(AGVAlign pVAlign)
+{
+  mVAlign=pVAlign;
+  std::list<AGEditLine>::iterator i=mLines.begin();
+  for(;i!=mLines.end();i++)
+    i->setVAlign(pVAlign);
+}
+
+void AGEdit::setBackground(const AGBackground &bg)
+{
+  mDrawBackground=true;
+  mBackground=bg;
+}
+
+
+void AGEdit::setBackground(bool pDrawBackground)
+{
+  queryRedraw();
+  mDrawBackground=pDrawBackground;
+}
+
+void AGEdit::setTheme(const AGString &s)
+{
+  queryRedraw();
+  AGString ms=s;
+  if(ms=="")
+    ms="edit";
+
+  AGFont font=getTheme()->getFont(s+".font");
+  setFont(font);
+  mTheme=s;
+
+  AGString t=mTheme;
+  if(t.length())
+    t+=".";
+
+  mBackground=AGBackground(t+"background");
+}
+
+bool AGEdit::canFocus() const
+{
+  return mMutable;
+}
+
+AGEdit &toAGEdit(AGWidget &w)
+{
+  return dynamic_cast<AGEdit&>(w);
+}
+
+AGStringUtf8 AGEdit::getText() const
+{
+  std::ostringstream os;
+  std::list<AGEditLine>::const_iterator i=mLines.begin();
+  for(;i!=mLines.end();)
+    {
+      bool hard=i->hardEnd();
+      os<<i->getText().toString();
+      i++;
+      if(i!=mLines.end() && hard)
+	os<<std::endl;
+    }
+  return AGStringUtf8(os.str());
+}
+
+void AGEdit::clear()
+{
+  mLines.clear();
+  mCx=mCy=0;
+  mViewCy=0;
+  AGFont font1("FreeSans.ttf",14);
+  AGEditLine l("",font1,true);
+  l.setAlign(mAlign);
+  l.setVAlign(mVAlign);
+  mLines.push_back(l);
+  getActLine();
+}
+
+
+bool AGEdit::eventGotFocus()
+{
+  queryRedraw();
+  return AGWidget::eventGotFocus();
+}
+bool AGEdit::eventLostFocus()
+{
+  queryRedraw();
+  return AGWidget::eventLostFocus();
+}
+
+void AGEdit::prepareDraw()
+{
+  mCursorTime+=SDL_GetTicks()-mCursorLast;
+  mCursorLast=SDL_GetTicks();
+  if(mCursorTime>300 && mMutable && hasFocus())
+    {
+      mCursorTime=0;
+      mShowCursor=!mShowCursor;
+      queryRedraw();
+    }
+
+
+  AGWidget::prepareDraw();
+}
+
+void AGEdit::setInsert(bool pInsert)
+{
+  mInserting=pInsert;
+}
+
+/// set Cursor to defined position p in text
+void AGEdit::setCursor(int p)
+{
+  std::list<AGEditLine>::iterator j=mLines.begin();
+
+  mCy=0;
+  mCx=0;
+  for(;j->length()<p;)
+    {
+      mCy++;
+      p-=j->length();
+      j++;
+    }
+  mCx=p;
+  actLine=&(*j);
+  
+}

Added: antargis/branches/rant/ext/gui/ag_edit.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_edit.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_edit.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,168 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_edit.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef __AG_EDIT_H
+#define __AG_EDIT_H
+
+#include "ag_widget.h"
+#include "ag_font.h"
+#include "ag_surface.h"
+#include "ag_background.h"
+#include "ag_utf8.h"
+#include "ag_string_utf8.h"
+
+enum AGAlign {EDIT_LEFT,EDIT_RIGHT,EDIT_JUSTIFY,EDIT_CENTER};
+enum AGVAlign {EDIT_TOP,EDIT_BOTTOM,EDIT_VCENTER};
+
+class AGEditLine
+{
+ public:
+  AGEditLine(const AGStringUtf8 &pText,AGFont pFont,bool pHardEnd);
+  virtual ~AGEditLine();
+
+  void setAlign(AGAlign pAlign);
+  void setVAlign(AGVAlign pVAlign);
+
+  virtual void draw(AGPainter &p,const AGVector2 &pPoint,const AGRect2 &pClip);
+  virtual void drawCursor(AGPainter &p,int cx,const AGVector2 &pPoint,const AGRect2 &pClip,const AGColor &c);
+  
+  int height() const;
+  int width() const;
+
+  void insert(const AGStringUtf8 &c,int cx,bool pInsert);
+  void doDelete(int cx);
+  AGEditLine split(int cx);
+
+  int length() const;
+
+  void append(const AGStringUtf8 &s);
+  void prepend(const AGStringUtf8 &s);
+  AGStringUtf8 getText() const;
+  AGFont getFont() const;
+  void setText(const AGStringUtf8 &s);
+
+  bool hardEnd() const;
+  void setHardEnd(bool pHardEnd);
+  std::pair<AGStringUtf8,bool> checkUnwrap(int pW,const AGStringUtf8 &s);
+
+  std::pair<AGStringUtf8,bool> checkWrap(int pW);
+
+  void setFont(const AGFont &pFont);
+
+ private:
+  AGStringUtf8 mText;
+  AGFont mFont;
+  bool mHardEnd;
+  AGAlign mAlign;
+  AGVAlign mVAlign;
+};
+
+class AGEdit:public AGWidget
+{
+ public:
+  AGEdit(AGWidget *pParent,const AGRect2 &pRect);
+
+  virtual void draw(AGPainter &p);
+  virtual void drawBackground(AGPainter &p);
+
+  virtual bool eventKeyDown(AGEvent *m);
+  virtual bool eventKeyUp(AGEvent *m);
+
+  void setMulti(bool mMultiLine);
+
+  bool insert(const AGStringUtf8 &c);
+  void doDelete(int p);
+
+  void setText(const AGStringUtf8 &pText);
+  void setFont(const AGFont &pFont);
+
+  void clear();
+
+  void setMutable(bool pMutable);
+
+  void setAlign(AGAlign pAlign);
+  void setVAlign(AGVAlign pVAlign);
+
+  void setBackground(bool pDrawBackground);
+  void setBackground(const AGBackground &bg);
+
+  void setTheme(const AGString &s);
+
+  bool canFocus() const;
+
+  AGStringUtf8 getText() const;
+
+  void setMaxLength(int i);
+
+  virtual bool eventGotFocus();
+  virtual bool eventLostFocus();
+
+  virtual void prepareDraw();
+
+  void setInsert(bool pInsert);
+
+  void setCursor(int p);
+
+ private:
+
+  void getActLine();
+  void insertLine(AGEditLine l);
+  void mergeLine(int p);
+  void checkWrap();
+
+  std::list<AGEditLine> mLines;
+  AGEditLine *actLine;
+  
+  int mCx,mCy; // cursor position
+  int mViewCy;
+  
+  Uint32 mCursorTime;
+  Uint32 mCursorLast;
+  bool mShowCursor;
+  bool mLShift,mRShift;
+  bool mLCtrl,mRCtrl;
+  bool mLAlt,mRAlt;
+
+  bool mInserting;
+
+  bool mMultiLine;
+
+  bool mWrapLines;
+
+  AGBackground mBackground;
+
+  AGFont mFont;
+
+  AGAlign mAlign;
+  AGVAlign mVAlign;
+
+  bool mMutable;
+  bool mDrawBackground;
+
+  AGString mTheme;
+
+  int mMaxLength;
+};
+
+AGEdit &toAGEdit(AGWidget &w);
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_frame.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_frame.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_frame.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,66 @@
+#include "ag_frame.h"
+#include "ag_screen.h"
+#include "ag_debug.h"
+
+AGFrame::AGFrame(AGWidget *pParent,const AGRect2 &pRect,size_t pWidth):AGWidget(pParent,pRect),
+								       mWidth(pWidth),mBorder(0),mTexture((int)width(),(int)height())
+{
+  mTextureInited=false;
+  mUseTexture=true;
+  mBg=0;
+}
+AGFrame::AGFrame(AGWidget *pParent,const AGRect2 &pRect,const AGBorder &pBorder):AGWidget(pParent,pRect),
+										 mWidth(pBorder.getWidth()),mBorder(new AGBorder(pBorder)),mTexture((int)width(),(int)height())
+{
+  mTextureInited=false;
+  mUseTexture=true;
+  mBg=0;
+}
+
+AGFrame::~AGFrame()
+{
+  delete mBorder;
+  delete mBg;
+}
+
+AGRect2 AGFrame::getClientRect() const
+{
+  return getRect().origin().shrink(mWidth);
+}
+
+void AGFrame::prepareDraw()
+{
+  if(mUseTexture && mBorder)
+    {
+      //      if(!mTextureInited)
+      if(!mTexture.hasTexture())
+	{
+	  AGPainter p(mTexture);
+	  mBorder->draw(getRect().origin(),p);
+	  mTextureInited=true;
+
+	}
+    }
+  AGWidget::prepareDraw();
+}
+
+void AGFrame::draw(AGPainter &p)
+{
+  //  CTRACE;
+  if(mBg)
+    {
+      mBg->draw(getRect().origin(),p);
+    }
+  if(mBorder)
+    {
+      if(mUseTexture && mTextureInited)
+	p.blit(mTexture,mTexture.getRect());
+      else
+	mBorder->draw(getRect().origin(),p);
+    }
+}
+
+void AGFrame::setBackground(const AGBackground &pBg)
+{
+  mBg=new AGBackground(pBg);
+}

Added: antargis/branches/rant/ext/gui/ag_frame.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_frame.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_frame.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,33 @@
+#ifndef AG_FRAME_H
+#define AG_FRAME_H
+
+#include "ag_border.h"
+#include "ag_background.h"
+#include "ag_widget.h"
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+class AGFrame:public AGWidget
+{
+ public:
+  AGFrame(AGWidget *pParent,const AGRect2 &pRect,size_t width); // transparent frame
+  AGFrame(AGWidget *pParent,const AGRect2 &pRect,const AGBorder &pBorder);
+  ~AGFrame();
+
+  void setBackground(const AGBackground &pBg);
+
+  AGRect2 getClientRect() const;
+
+  void draw(AGPainter &p);
+  void prepareDraw();
+
+ private:
+  size_t mWidth;
+  AGBorder *mBorder;
+  AGBackground *mBg;
+  AGTexture mTexture;
+  bool mTextureInited;
+  bool mUseTexture;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_image.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_image.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_image.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_image.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_image.h"
+#include "ag_debug.h"
+
+AGImage::AGImage(AGWidget *pParent,const AGRect2 &r,AGSurface pSurface,bool pTile):
+  AGWidget(pParent,r),
+  mTexture(pSurface),mTile(pTile)
+{
+  mCenter=true;
+  //  CTRACE;
+  /*  if(pRect!=pSurface.getRect() && pRect.w()!=0 && pRect.h()!=0)
+    {
+      //      mSrcRect=pRect;
+
+      setHeight(pRect.h());
+      setWidth(pRect.w());
+      }*/
+}
+AGImage::AGImage(AGWidget *pParent,const AGRect2 &r,AGTexture pTexture,bool pTile):
+  AGWidget(pParent,r),
+  mTexture(pTexture),mTile(pTile)
+{
+  mCenter=true;
+  //  CTRACE;
+  /*  if(pRect!=pTexture.getRect() && pRect.w()!=0 && pRect.h()!=0)
+    {
+      mSrcRect=pRect;
+
+      setHeight(pRect.h());
+      setWidth(pRect.w());
+      }*/
+}
+
+
+
+AGImage::~AGImage()
+{
+}
+
+void AGImage::draw(AGPainter &p)
+{
+  // do always center for now
+  bool center=true;
+
+
+  if(mTile)
+    {
+      //      if(mSrcRect.w()==0 || mSrcRect.h()==0)
+      //	mSrcRect=mTexture.getRect();
+      p.tile(mTexture,getRect().origin());//,mSrcRect);
+    }
+  else if(center)
+    {
+      
+      AGRect2 mr=getRect().origin();
+
+      if(mCenter)
+	mr+=AGVector2((width()-mTexture.width())/2,(height()-mTexture.height())/2);
+
+      p.blit(mTexture,mr);
+    }
+  else
+    p.blit(mTexture,getRect().origin());
+}
+
+void AGImage::setSurface(const AGSurface &pSurface)
+{
+  AGTexture t(pSurface);
+  mTexture=t;
+  queryRedraw();
+}
+void AGImage::setTexture(const AGTexture &pTexture)
+{
+  mTexture=pTexture;
+  queryRedraw();
+}
+
+void AGImage::useTextures()
+{
+  mTexture.useTexture();
+}
+
+void AGImage::setCenter(bool c)
+{
+  mCenter=c;
+}

Added: antargis/branches/rant/ext/gui/ag_image.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_image.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_image.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_image.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_IMAGE_H
+#define AG_IMAGE_H
+
+#include "ag_widget.h"
+#include "ag_texture.h"
+
+class AGImage:public AGWidget
+{
+ public:
+  AGImage(AGWidget *pParent,const AGRect2 &r,AGSurface pSurface,bool pTile);
+  AGImage(AGWidget *pParent,const AGRect2 &r,AGTexture pTexture,bool pTile);
+  virtual ~AGImage();
+
+  virtual void draw(AGPainter &p);
+
+  void setSurface(const AGSurface &pSurface);
+  void setTexture(const AGTexture &pTexture);
+
+  void useTextures();
+
+  void setCenter(bool c);
+
+ private:
+  AGTexture mTexture;
+  bool mTile;
+  bool mCenter;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_layout.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_layout.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_layout.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,231 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_layout.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_layout.h"
+#include "ag_xml.h"
+#include "ag_tools.h"
+#include "ag_theme.h"
+#include "ag_listbox.h"
+#include "ag_combo.h"
+#include "ag_image.h"
+#include "ag_frame.h"
+
+#include "ag_button.h"
+#include "ag_edit.h"
+#include "ag_window.h"
+#include "ag_text.h"
+#include "ag_main.h"
+#include "ag_video.h"
+
+#include "ag_layoutfactory.h"
+
+// keep in mind: ag_local.h must be included after ruby.h!!!
+#include "ag_local.h"
+
+AGLayout::AGLayout(AGWidget *pgParent):
+  AGWidget(pgParent,AGRect2(0,0,0,0))
+{
+  CTRACE;
+}
+
+void AGLayout::loadXML(const std::string &pXMLData)
+{
+  CTRACE;
+
+  // disable GC here
+  // marking makes problems here - as the widgets are not inserted into the tree 
+  // when _() is called, which itself is a ruby-dependent thingy
+  Document p;
+  p.parseMemory(pXMLData);
+
+
+	cdebug("dump of XML:"<<p.toString());
+
+
+  AGWidget *pgParent=getParent();
+
+  AGRect2 geom;
+  AGString geomS=p.root().get("geometry");
+  if(geomS.length())
+    geom=AGRect2(geomS);
+  else if(getParent())
+    geom=pgParent->getRect().origin();
+  else
+    geom=AGRect2(0,0,getVideo()->width(),getVideo()->height());
+
+
+  cdebug("GEOMETRY:"<<geom.toString());
+
+  setRect(geom);
+  setName(p.root().get("name"));
+
+  parseChildren(this,p.root());
+
+
+  if(mTabIndices.size())
+    {
+      AGWidget *w=mTabIndices.begin()->second;
+      w->gainCompleteFocus(); // is ok, because till here layout isn't inserted into screen yet
+    }
+}
+
+bool AGLayout::eventKeyDown(AGEvent *m)
+{
+  if(m->getKey()==SDLK_TAB)
+    {
+      // search element, which has focus
+      std::map<int,AGWidget*>::iterator i=mTabIndices.begin();
+
+      for(;i!=mTabIndices.end();i++)
+	if(i->second->hasFocus())
+	  break;
+
+      if(i!=mTabIndices.end())
+	i++;
+      if(i==mTabIndices.end())
+	i=mTabIndices.begin();
+      if(i!=mTabIndices.end())
+	i->second->gainFocus();
+
+      return true;
+    }
+  else
+    return AGWidget::eventKeyDown(m);
+}
+
+
+void AGLayout::addTabIndex(int i,AGWidget *pWidget)
+{
+  mTabIndices[i]=pWidget;
+}
+
+int AGLayout::getNextTabIndex() const
+{
+  if(mTabIndices.size()>0)
+    return mTabIndices.rbegin()->first+1;
+  else
+    return 1;
+}
+
+
+
+AGLayout *getLayout(AGWidget *pWidget)
+{
+  AGLayout *l=dynamic_cast<AGLayout*>(pWidget);
+  if(l)
+    return l;
+  else if(pWidget->getParent())
+    return getLayout(pWidget->getParent());
+  return 0;
+}
+
+
+AGWidget *parseNode(AGWidget *pParent,const Node &pNode)
+{
+  AGString n=pNode.getName();
+
+  AGRect2 geom=getLayoutGeometry(pParent,pNode);
+
+  AGWidget *w=0;
+
+  //  cdebug("n:"<<n);
+
+  w=getLayoutFactory()->create(pParent,geom,pNode);
+
+  if(w!=0 && pNode.get("name").length())
+      w->setName(pNode.get("name"));
+
+  if(w!=0 && pNode.get("visible")=="false")
+    w->hide();
+
+  if(w!=0 && pNode.get("tooltip").length())
+    w->setTooltip(_(pNode.get("tooltip")));
+
+  if(w!=0 && pNode.get("tabindex").length())
+    {
+      AGLayout *l=getLayout(pParent);
+      if(l)
+	{
+	  l->addTabIndex(pNode.get("tabindex").toInt(),w);
+	}
+      else
+	cdebug("ERROR in parseNode(.):tabindex given but not embedded in layout???");
+    }
+
+  if(w!=0 && pNode.get("cache")=="true")
+    w->setCaching(true);
+
+  parseChildren(w,pNode);
+
+  if(w)
+    w->initHandlers();
+
+  return w;
+}
+
+AGRect2 getLayoutGeometry(AGWidget *pParent,const Node &pNode)
+{
+  //  TRACE;
+  AGRect2 geom=pParent->getClientRect();
+  AGTable *t=dynamic_cast<AGTable*>(pParent);
+  //  cdebug(pNode.getName());
+  //  cdebug(geom);
+  if(t)
+    if(pNode.get("col")!="" && pNode.get("row")!="")
+      {
+	int col=pNode.get("col").toInt();
+	int row=pNode.get("row").toInt();
+	
+	geom=t->getClientRect(col,row);
+	//	assert(pParent->getRect().origin().contains(geom));
+	//	cdebug("col:"<<col<<" row:"<<row<<":"<<geom);
+	if(!pParent->getRect().origin().contains(geom))
+	  {
+	    std::cerr<<"parent-geometry doesn't contain geom:"<<std::endl;
+	    std::cerr<<"parent:"<<pParent->getRect().origin()<<" geom:"<<geom<<std::endl;
+	    std::cerr<<"node-name:"<<pNode.getName()<<"  parent-name:"<<pParent->getName()<<std::endl;
+	  }
+	assert(pParent->getRect().origin().contains(geom));
+      }
+  
+
+  AGString geomS=pNode.get("geometry");
+  if(geomS.length())
+    geom=AGRect2(geomS);
+  return geom;
+}
+
+void parseChildren(AGWidget *pParent,const Node &pNode)
+{
+	TRACE;
+  if(pParent)
+    {
+      Node::const_iterator i=pNode.begin();
+      for(;i!=pNode.end();i++)
+	{
+		cdebug("I:"<<(*i)->getName()<<" name:"<<(*i)->get("name"));
+	  AGWidget *w=parseNode(pParent,**i);
+	  if(w)
+	    pParent->addChild(w);
+	}
+    }
+}
+
+

Added: antargis/branches/rant/ext/gui/ag_layout.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_layout.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_layout.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_layout.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_LAYOUT_H
+#define AG_LAYOUT_H
+
+#include "ag_widget.h"
+#include "ag_xml.h"
+
+class AGTable;
+
+class AGLayout:public AGWidget
+{
+ public:
+  AGLayout(AGWidget *pgParent);
+  
+  virtual void loadXML(const std::string &pXMLData);
+
+  void addTabIndex(int i,AGWidget *pWidget);
+
+  virtual bool eventKeyDown(AGEvent *m);
+  int getNextTabIndex() const;
+
+  static void registerLayouts();
+
+ private:
+  std::map<int,AGWidget*> mTabIndices;
+};
+
+AGWidget *parseNode(AGWidget *pParent,const Node &pNode);
+void parseChildren(AGWidget *pParent,const Node &pNode);
+//AGTable *parseTable(AGWidget *pParent,const Node &pNode,const AGRect2 &geom);
+AGRect2 getLayoutGeometry(AGWidget *pParent,const Node &pNode);
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_layoutcreators.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_layoutcreators.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_layoutcreators.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,518 @@
+#include <ag_button.h>
+#include <ag_checkbox.h>
+#include <ag_colorbutton.h>
+#include <ag_combo.h>
+#include <ag_edit.h>
+#include <ag_frame.h>
+#include <ag_image.h>
+#include <ag_layout.h>
+#include <ag_listbox.h>
+#include <ag_local.h>
+#include <ag_radio.h>
+#include <ag_radiogroup.h>
+#include <ag_table.h>
+#include <ag_theme.h>
+#include <ag_window.h>
+#include <ag_screenwidget.h>
+
+#include "ag_layoutfactory.h"
+
+AGWidget *parseNode(AGWidget *pParent,const Node &pNode);
+
+
+// Layout-Factories
+class AGButtonLayoutCreator:public AGLayoutCreator
+{
+ public:
+  REGISTER_COMPONENT(Button,"button")
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    AGButton *b;
+    AGStringUtf8 caption=_(pNode.get("caption"));
+    b=new AGButton(pParent,pRect,AGStringUtf8(caption));
+    setResult(b);
+    AGFilename captionImage=pNode.get("caption-image");
+    if(captionImage.length())
+      b->setSurface(AGSurface::load(captionImage),false);
+    if(pNode.get("enabled")=="false")
+      b->setEnabled(false);
+
+    b->setTheme(pNode.get("theme"));
+  }
+};
+
+
+class AGTableLayoutCreator:public AGLayoutCreator
+{
+ public:
+  REGISTER_COMPONENT(Table,"table")
+
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    AGWidget *w=parseTable(pParent,pNode,pRect);
+    pParent->addChild(w);
+    w=0;
+    setResult(0);
+  }
+
+AGTable *parseTable(AGWidget *pParent,const Node &pNode,const AGRect2 &geom)
+{
+  AGTable *t;
+  t=new AGTable(pParent,geom);
+  setResult(t); // set result - so garbage collector gets to know this one
+
+  int w,h;
+  w=pNode.get("cols").toInt();
+  h=pNode.get("rows").toInt();
+
+  t->setName(pNode.get("name"));
+
+  if(pNode.get("visible")=="false")
+    t->hide();
+
+
+  std::vector<std::pair<float,bool> > rows(h);
+  std::vector<std::pair<float,bool> > cols(w);
+
+  // parse rows/cols info
+  Node::const_iterator i=pNode.begin();
+  for(;i!=pNode.end();i++)
+    {
+      if((*i)->getName()=="colsize")
+	{
+	  int id=(*i)->get("col").toInt();
+	  assert(id>=0 && id<w);
+	  //	  cdebug("id:"<<id);
+	  AGString s=(*i)->get("fixed");
+	  //	  cdebug("fixed:"<<s);
+	  if(s.length())
+	    cols[id]=std::make_pair(s.toFloat(),true);
+	  else
+	    {
+	      s=(*i)->get("relative");
+	      //	      cdebug("relative:"<<s);
+	      cols[id]=std::make_pair(s.toFloat(),false);
+	    }
+	}
+      else if((*i)->getName()=="rowsize")
+	{
+	  int id=(*i)->get("row").toInt();
+	  assert(id>=0 && id<h);
+
+	  AGString s=(*i)->get("fixed");
+	  if(s.length())
+	    rows[id]=std::make_pair(s.toFloat(),true);
+	  else
+	    {
+	      s=(*i)->get("relative");
+	      rows[id]=std::make_pair(s.toFloat(),false);
+	    }
+	}
+    }
+
+  for(int k=0;k<w;k++)
+    {
+      if(cols[k].first==0.0f) // not inited
+	t->addColumn(1.0f);
+      else if(cols[k].second)
+	t->addFixedColumn(cols[k].first);
+      else
+	t->addColumn(cols[k].first);
+    }
+  for(int k=0;k<h;k++)
+    {
+      if(rows[k].first==0.0f) // not inited
+	t->addRow(1.0f);
+      else if(rows[k].second)
+	t->addFixedRow(rows[k].first);
+      else
+	t->addRow(rows[k].first);
+    }
+
+  // now get children
+
+  i=pNode.begin();
+  for(;i!=pNode.end();i++)
+    {
+      AGWidget *w=parseNode(t,**i);
+      if(w)
+	{
+	  int col=(*i)->get("col").toInt();
+	  int row=(*i)->get("row").toInt();
+	  //	  cdebug(col<<"/"<<row);
+	  t->addChild(col,row,w);
+	}
+    }
+  //  t->arrange();
+
+  if(pNode.get("cache")=="true")
+    t->setCaching(true);
+
+  return t;
+}
+
+
+};
+
+class AGWindowLayoutCreator:public AGLayoutCreator
+{
+ public:
+  REGISTER_COMPONENT(Window,"window")
+  
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    AGStringUtf8 title=_(pNode.get("title"));
+    AGString theme=pNode.get("theme");
+    
+    AGWidget *w=new AGWindow(pParent,pRect,AGStringUtf8(title),theme);
+    setResult(w);
+  }
+};
+
+IMPLEMENT_COMPONENT_FACTORY(Table);
+IMPLEMENT_COMPONENT_FACTORY(Button);
+IMPLEMENT_COMPONENT_FACTORY(Window);
+
+
+// AGText creator
+class AGTextLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(Text,"text")
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    //    AGWidget *w=new AGText(pParent,pRect,text,font);
+    AGEdit *w=new AGEdit(pParent,pRect);
+    setResult(w);
+
+
+    AGStringUtf8 text=_(pNode.get("caption"));
+    text=text.replace("\\n","\n");
+    w->setText(AGStringUtf8(text));
+    AGString fontname=pNode.get("font");
+    if(fontname=="")
+      fontname="text.font";
+
+    AGFont font;
+    font=getTheme()->getFont(fontname);
+    w->setFont(font);
+    
+    if(pNode.get("align")=="left")
+      w->setAlign(EDIT_LEFT);
+    if(pNode.get("align")=="right")
+      w->setAlign(EDIT_RIGHT);
+    if(pNode.get("align")=="center")
+      w->setAlign(EDIT_CENTER);
+
+    if(pNode.get("valign")=="top")
+      w->setVAlign(EDIT_TOP);
+    if(pNode.get("valign")=="bottom")
+      w->setVAlign(EDIT_BOTTOM);
+    if(pNode.get("valign")=="center")
+      w->setVAlign(EDIT_VCENTER);
+
+    //    w->setAlign(EDIT_CENTER);
+    w->setMutable(false);
+    w->setBackground(false);
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(Text);
+
+
+// AGText creator
+class AGEditLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(Edit,"edit")
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    CTRACE;
+    AGString text=pNode.get("text");
+    bool multi=pNode.get("multi")=="true";
+    
+    //    AGWidget *w=new AGText(pParent,pRect,text,font);
+    AGEdit *w=new AGEdit(pParent,pRect);
+    setResult(w);
+    w->setText(AGStringUtf8(text));
+    if(pNode.get("font")!="")
+    {
+      AGFont font;
+      font=getTheme()->getFont(pNode.get("font"));
+      w->setFont(font);
+    }
+    //    w->setAlign(EDIT_CENTER);
+    w->setMutable(true);//false);
+    w->setBackground(true);//false);
+    w->setMulti(multi);
+    if(!multi)
+      w->setVAlign(EDIT_VCENTER);
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(Edit);
+
+
+
+// AGListBox creator
+class AGListBoxLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(ListBox,"listBox")
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    setResult(new AGListBox(pParent,pRect));
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(ListBox);
+
+
+// AGComboBox creator
+class AGComboBoxLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(ComboBox,"comboBox")
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    CTRACE;
+    AGComboBox *l=new AGComboBox(pParent,pRect);
+    setResult(l);
+
+    Node::const_iterator i=pNode.begin();
+    for(;i!=pNode.end();i++)
+      {
+	if((*i)->getName()=="item")
+	  l->insertItem((*i)->get("id"),AGStringUtf8((*i)->get("text")));
+      }
+
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(ComboBox);
+
+
+
+// AGLayout creator
+class AGLayoutLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(Layout,"layout")
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    CTRACE;
+    AGFilename filename=pNode.get("filename");
+    AGWidget *w=new AGWidget(pParent,pRect);
+    setResult(w);
+    AGLayout *l=new AGLayout(w);
+    l->loadXML(loadFile(filename));//pRect);
+    w->addChild(l);
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(Layout);
+
+
+// AGLayout creator
+class AGImageLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(Image,"image")
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    AGFilename filename=pNode.get("filename");
+
+    AGSurface s(0,0);
+    if(filename.length())
+      s=AGSurface::load(filename);
+
+    AGRect2 r=pRect;
+    if(pNode.get("x").length())
+      r.setX(pNode.get("x").toFloat());
+    if(pNode.get("y").length())
+      r.setY(pNode.get("y").toFloat());
+
+#warning "add subsurfaces"
+    
+
+    AGWidget *w;
+
+    if(pNode.get("tile")=="true")
+      w=new AGImage(pParent,r,s,true);
+    else
+      w=new AGImage(pParent,r,s,false);
+
+    setResult(w);
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(Image);
+
+
+// AGLayout creator
+class AGFrameLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(Frame,"frame")
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    CTRACE;
+    AGString border=pNode.get("border");
+    size_t width=pNode.get("width").toInt();
+
+    AGFrame *w;
+    if(border.length())
+      w=new AGFrame(pParent,pRect,AGBorder(border));
+    else
+      w=new AGFrame(pParent,pRect,width);
+
+    setResult(w);
+    if(pNode.get("background").length())
+      w->setBackground(AGBackground(pNode.get("background")));
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(Frame);
+
+
+// AGLayout creator
+class AGCellLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(Cell,"cell")
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    setResult(new AGWidget(pParent,pRect));
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(Cell);
+
+
+// AGRadio creator
+class AGCheckBoxLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(CheckBox,"checkBox")
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    AGCheckBox *b=new AGCheckBox(pParent,pRect);
+    AGStringUtf8 caption=_(pNode.get("caption"));
+    if(caption.length())
+      b->setCaption(AGStringUtf8(caption));
+
+    std::string captionImage=pNode.get("caption-image");
+    if(captionImage.length())
+      b->setSurface(AGSurface::load(captionImage),false);
+    if(pNode.get("enabled")=="false")
+      b->setEnabled(false);
+    if(pNode.get("theme").length())
+      b->setTheme(pNode.get("theme"));
+    if(pNode.get("checked")=="true")
+      b->setChecked(true);
+
+    if(pNode.get("disabledImage")!="" && pNode.get("enabledImage")!="")
+      {
+	b->setSurfaces(AGSurface::load(pNode.get("disabledImage")),AGSurface::load(pNode.get("enabledImage")));
+      }
+      
+
+    setResult(b);
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(CheckBox);
+
+// Layout-Factories
+class AGColorButtonLayoutCreator:public AGLayoutCreator
+{
+ public:
+  REGISTER_COMPONENT(ColorButton,"colorButton")
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    setResult(new AGColorButton(pParent,pRect,pNode.get("gridx").toInt(),pNode.get("gridy").toInt()));
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(ColorButton);
+
+
+
+// AGRadioGroup creator
+class AGRadioGroupLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(RadioGroup,"radioGroup")
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    setResult(new AGRadioGroup(pParent,pRect));
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(RadioGroup);
+
+// AGRadio creator
+class AGRadioLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(Radio,"radio")
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    AGRadio *b=new AGRadio(pParent,pRect);
+    AGStringUtf8 caption=_(pNode.get("caption"));
+    if(caption.length())
+      b->setCaption(AGStringUtf8(caption));
+
+    AGFilename captionImage=pNode.get("caption-image");
+    if(captionImage.length())
+      b->setSurface(AGSurface::load(captionImage),false);
+    if(pNode.get("enabled")=="false")
+      b->setEnabled(false);
+    if(pNode.get("theme").length())
+      b->setTheme(pNode.get("theme"));
+    if(pNode.get("checked")=="true")
+      b->setChecked(true);
+    setResult(b);
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(Radio);
+
+
+
+class AGScreenWidgetLayoutCreator:public AGLayoutCreator
+{
+public:
+  REGISTER_COMPONENT(ScreenWidget,"screenWidget")
+
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+  {
+    CTRACE;
+    setResult(new AGScreenWidget());
+  }
+};
+IMPLEMENT_COMPONENT_FACTORY(ScreenWidget);
+
+
+void AGLayout::registerLayouts()
+{
+	TRACE;
+  getLayoutFactory()->addCreator("checkBox",new AGCheckBoxLayoutCreator);
+  getLayoutFactory()->addCreator("colorButton",new AGColorButtonLayoutCreator);
+  getLayoutFactory()->addCreator("table",new AGTableLayoutCreator);
+  getLayoutFactory()->addCreator("button",new AGButtonLayoutCreator);
+  getLayoutFactory()->addCreator("window",new AGWindowLayoutCreator);
+  getLayoutFactory()->addCreator("text",new AGTextLayoutCreator);
+  getLayoutFactory()->addCreator("edit",new AGEditLayoutCreator);
+  getLayoutFactory()->addCreator("listBox",new AGListBoxLayoutCreator);
+  getLayoutFactory()->addCreator("comboBox",new AGComboBoxLayoutCreator);
+  getLayoutFactory()->addCreator("layout",new AGLayoutLayoutCreator);
+  getLayoutFactory()->addCreator("image",new AGImageLayoutCreator);
+  getLayoutFactory()->addCreator("frame",new AGFrameLayoutCreator);
+  getLayoutFactory()->addCreator("cell",new AGCellLayoutCreator);
+  getLayoutFactory()->addCreator("radioGroup",new AGRadioGroupLayoutCreator);
+  getLayoutFactory()->addCreator("radio",new AGRadioLayoutCreator);
+//  getLayoutFactory()->addCreator("miniMap",new AGMiniMapLayoutCreator);
+  getLayoutFactory()->addCreator("screenWidget",new AGScreenWidgetLayoutCreator);
+
+}

Added: antargis/branches/rant/ext/gui/ag_layoutfactory.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_layoutfactory.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_layoutfactory.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_layoutfactory.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_layoutfactory.h"
+#include "ag_debug.h"
+#include "ag_kill.h"
+
+AGLayoutCreator::AGLayoutCreator():mWidget(0)
+{
+}
+
+void AGLayoutCreator::create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+{
+}
+
+void AGLayoutCreator::setResult(AGWidget *pWidget)
+{
+  mWidget=pWidget;
+}
+AGWidget *AGLayoutCreator::getResult()
+{
+  return mWidget;
+}
+
+void AGLayoutCreator::clearResult()
+{
+  mWidget=0;
+}
+
+void AGLayoutCreator::mark()
+{
+  if(mWidget)
+    markObject(mWidget);
+}
+
+
+
+AGLayoutFactory::AGLayoutFactory()
+{
+  REGISTER_SINGLETON(this);
+}
+
+AGLayoutFactory::~AGLayoutFactory()
+{
+}
+
+void AGLayoutFactory::addCreator(const AGString &pName,AGLayoutCreator *creator)
+{
+  mCreators[pName]=creator;
+}
+
+void AGLayoutFactory::removeCreator(const AGString &pName,AGLayoutCreator *creator)
+{
+  std::map<AGString,AGLayoutCreator*>::iterator i=mCreators.find(pName);
+  if(i->second==creator)
+    mCreators.erase(i);
+}
+
+
+AGWidget *AGLayoutFactory::create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode)
+{
+  AGLayoutCreator *creator=mCreators[pNode.getName()];
+
+  if(creator)
+    {
+      AGWidget *w;
+      creator->create(pParent,pRect,pNode);
+      w=creator->getResult();
+      creator->clearResult();
+
+      return w;
+    }
+  std::string name;
+  if(name!="" && name!="colsize" && name!="rowsize")
+    {
+      cdebug("no creation at:"<<name);
+    }
+  return 0;
+}
+  
+AGLayoutFactory *mLayoutFactory=0;
+AGLayoutFactory *getLayoutFactory()
+{
+  if(!mLayoutFactory)
+    mLayoutFactory=new AGLayoutFactory;
+  return mLayoutFactory;
+}
+
+
+

Added: antargis/branches/rant/ext/gui/ag_layoutfactory.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_layoutfactory.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_layoutfactory.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_layoutfactory.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_LAYOUTFACTORY_H
+#define AG_LAYOUTFACTORY_H
+
+#include <ag_singleton.h>
+#include <ag_utf8.h>
+#include <ag_widget.h>
+#include <ag_xml.h>
+
+class AGLayoutCreator:public AGSingleton
+{
+ public:
+  AGLayoutCreator();//const AGString &pName);
+  //  virtual ~AGLayoutCreator();
+  virtual void create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode);
+  void setResult(AGWidget *pWidget);
+  AGWidget *getResult();
+
+  void clearResult();
+
+  void mark();
+ private:
+  AGWidget *mWidget;
+    //std::string mName;
+
+};
+
+class AGLayoutFactory
+{
+  std::map<AGString,AGLayoutCreator*> mCreators;
+
+  AGLayoutFactory();
+ public:
+  ~AGLayoutFactory();
+
+  void addCreator(const AGString &pName,AGLayoutCreator *creator);
+  void removeCreator(const AGString &pName,AGLayoutCreator *creator);
+
+  AGWidget *create(AGWidget *pParent,const AGRect2 &pRect,const Node &pNode);
+  
+  friend AGLayoutFactory *getLayoutFactory();
+};
+
+AGLayoutFactory *getLayoutFactory();
+/*
+#define IMPLEMENT_COMPONENT_FACTORY(CLASS) \
+AG##CLASS##LayoutCreator factory_##CLASS
+
+#define REGISTER_COMPONENT(CLASS,NAME) AG##CLASS##LayoutCreator():AGLayoutCreator(NAME){}
+*/
+
+#define IMPLEMENT_COMPONENT_FACTORY(CLASS)
+#define REGISTER_COMPONENT(CLASS,NAME)
+
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_listbox.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_listbox.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_listbox.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,272 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_listbox.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_debug.h"
+#include "ag_edit.h"
+#include "ag_listbox.h"
+#include "ag_theme.h"
+#include "ag_scroller.h"
+#include "ag_stringstream.h"
+
+#include <sstream>
+
+AGListBoxItem::AGListBoxItem(AGString pID,AGStringUtf8 pValue)
+{
+  id=pID;
+  value=pValue;
+}
+
+AGListBox::AGListBox(AGWidget *pParent,const AGRect2 &pRect):AGWidget(pParent,pRect),
+							     sigSelect(this,"sigSelect"),
+							     sigDoubleClick(this,"sigDoubleClick")
+{
+  mBackground=AGBackground("listbox.background");
+  mHilight=AGBackground("listbox.selected");
+  // insert AGEdits
+  int y=0;
+  int count=0;
+  mItemHeight=getTheme()->getInt("listbox.item.height");
+  if(mItemHeight<5)
+    mItemHeight=25;
+
+  AGFont f=getTheme()->getFont("listbox.font");
+
+
+  mScroller=new AGScroller(this,AGRect2(width()-mItemHeight,0,mItemHeight,height()),false);
+  addChild(mScroller);
+
+  mScroller->sigValueChanged.connect(slot(this,&AGListBox::eventScroller));
+
+  for(;y<pRect.h();y+=mItemHeight,count++)
+    {
+      AGRect2 r(0,y,pRect.w()-mItemHeight,mItemHeight);
+      //      cdebug(r);
+      AGEdit *e=new AGEdit(this,r);
+      e->setMutable(false);
+      e->setBackground(false);
+      e->setFont(f);
+      AGStringStream os;
+      os<<"ListBoxItem"<<count;
+      e->setName(os.str());
+
+      mEdits.push_back(e);
+      addChild(e);
+    }
+  mHeight=count;
+  mY=0;
+  mSelected=-1;
+}
+
+void AGListBox::insertItem(AGString pID,AGStringUtf8 pValue)
+{
+  mItems.push_back(AGListBoxItem(pID,pValue));
+  arrange();
+}
+void AGListBox::selectItem(AGString pID)
+{
+  for(size_t i=0;i<mItems.size();i++)
+    if(mItems[i].id==pID)
+      {
+	mSelected=i;
+	mY=std::max(0,int(i)-mHeight/2); // FIXME: maybe find better zoom
+      }
+  arrange();
+}
+
+AGString AGListBox::getSelectedID() const
+{
+  if(mSelected>=0 && size_t(mSelected)<mItems.size())
+    return mItems[mSelected].id;
+  return "";
+}
+
+AGString AGListBox::getSelectedValue() const
+{
+  if(mSelected>=0 && size_t(mSelected)<mItems.size())
+    return mItems[mSelected].id;
+  return "";
+}
+
+bool AGListBox::eventKeyDown(AGEvent *m)
+{
+  if(m->isSDLEvent())
+    {
+      SDLKey k=m->getKey();
+      if(k==SDLK_UP)
+	{
+	  if(mSelected<2 && mItems.size()>0)
+	    mSelected=0;
+	  else
+	    mSelected--;
+	  if(mSelected<mY)
+	    mY=mSelected;
+	  arrange();
+	  return true;
+	}
+      else if(k==SDLK_DOWN)
+	{
+	  if(mSelected<int(mItems.size())-1)
+	    mSelected++;
+	  if(mSelected>=mY+mHeight)
+	    mY++;
+	  arrange();
+	  return true;
+	}
+    }
+  return AGWidget::eventKeyDown(m);
+}
+
+
+void AGListBox::arrange()
+{
+  size_t y,y2=0;
+  
+  // first clear all
+  for(y=0;y<mEdits.size();y++)
+    mEdits[y]->setText("");
+
+  for(y=mY,y2=0;y<(size_t)(mY+mHeight) && y<mItems.size();y++,y2++)
+    mEdits[y2]->setText(mItems[y].value);
+
+  updateScroller();
+}
+
+void AGListBox::draw(AGPainter &p)
+{
+  mBackground.draw(getRect().origin(),p);
+  p.pushMatrix();
+
+  if(mSelected>=0 && mSelected<(int)mItems.size())
+    {
+      int y=mSelected-mY;
+      
+      AGRect2 r(0,y*mItemHeight,width(),mItemHeight);
+      p.transform(r);
+      mHilight.draw(getRect().origin(),p);
+    }
+  p.popMatrix();
+  AGWidget::draw(p);
+}
+
+bool AGListBox::eventMouseClick(AGEvent *e)
+{
+  CTRACE;
+  if(e->isSDLEvent())
+    {
+      AGVector2 p=e->getMousePosition();
+
+      int b=e->getButton();
+      //      cdebug(b);
+      if(b==4)
+	{
+	  // up wheel
+	  if(mY>0)
+	    mY--;
+	  arrange();
+	  return true;
+	}
+      else if(b==5)
+	{
+	  // down wheel
+	  if(mY<=(int)mItems.size()-mHeight)
+	    mY++;
+	  arrange();
+	  return true;
+	}
+      else
+	{
+
+	  int y=(int)(p[1]-getScreenRect().y());
+	  //	  cdebug("y:"<<y);
+	  y/=mItemHeight;
+	  //	  cdebug("y:"<<y);
+	  //	  cdebug(mItemHeight);
+	  int n=y+mY;
+	  //	  cdebug("n:"<<n);
+	  if(n<(int)mItems.size())
+	    mSelected=n;
+
+	  e->setName("sigSelect");
+	      
+	  sigSelect(e);
+	  return true;
+	}
+    }
+  return false;
+}
+
+AGListBox &toAGListBox(AGWidget &w)
+{
+  return dynamic_cast<AGListBox&>(w);
+}
+
+void AGListBox::clearList()
+{
+  mY=mSelected=0;
+  mItems.clear();
+}
+
+bool AGListBox::eventMouseButtonDown(AGEvent *m)
+{
+  // ensure that event is eaten
+  bool r=AGWidget::eventMouseButtonDown(m);
+  if(m->isSDLEvent())
+    if(getScreenRect().contains(m->getMousePosition()))
+      return true;
+  return r;
+}
+bool AGListBox::eventMouseButtonUp(AGEvent *m)
+{
+  // ensure that event is eaten
+  bool r=AGWidget::eventMouseButtonUp(m);
+  if(m->isSDLEvent())
+    if(getScreenRect().contains(m->getMousePosition()))
+      return true;
+  return r;
+}
+
+bool AGListBox::eventScroller(AGEvent *e)
+{
+  mY=(int)mScroller->getValue();
+  arrange();
+  return false;
+}
+
+void AGListBox::updateScroller()
+{
+  // update scroller
+  {
+    int itemCount=mItems.size();
+    int visibleCount=(int)(height()/mItemHeight);
+
+    int maxVal=std::max(0,itemCount-visibleCount);
+
+    /*    cdebug("maxVal:"<<maxVal);
+    cdebug("vis:"<<visibleCount);
+    cdebug("items:"<<itemCount);
+    cdebug("my:"<<mY);
+    */
+    mScroller->setInterval(0,maxVal);
+    mScroller->setScrollerSize(std::min(visibleCount,maxVal));
+    mScroller->setValue(mY);
+    mScroller->setStepping(1);
+  }
+
+}

Added: antargis/branches/rant/ext/gui/ag_listbox.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_listbox.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_listbox.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_listbox.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef __AG_LISTBOX_H
+#define __AG_LISTBOX_H
+
+#include <string>
+#include <vector>
+#include "ag_widget.h"
+#include "ag_background.h"
+
+class AGEdit;
+class AGScroller;
+
+struct AGListBoxItem
+{
+  AGListBoxItem(AGString pID,AGStringUtf8 pValue);
+  AGString id;
+  AGStringUtf8 value;
+};
+
+
+// Single selection for a start
+class AGListBox:public AGWidget
+{
+ public:
+  AGListBox(AGWidget *pParent,const AGRect2 &pRect);
+
+  void insertItem(AGString pID,AGStringUtf8 pValue);
+  void selectItem(AGString pID);
+
+  AGString getSelectedID() const;
+  AGString getSelectedValue() const;
+
+  virtual bool eventKeyDown(AGEvent *m);
+
+  AGSignal sigSelect;
+  AGSignal sigDoubleClick;
+
+  virtual void draw(AGPainter &p);
+  virtual bool eventMouseClick(AGEvent *m);
+  virtual bool eventMouseButtonDown(AGEvent *m);
+  virtual bool eventMouseButtonUp(AGEvent *m);
+
+  bool eventScroller(AGEvent *e);
+
+  void clearList();
+
+  void updateScroller();
+
+ private:
+
+  void arrange();
+
+  int mY;
+  std::vector<AGListBoxItem> mItems;
+  int mSelected;
+  int mHeight;
+  int mItemHeight;
+  std::vector<AGEdit*> mEdits;
+  AGBackground mBackground,mHilight;
+
+  AGScroller *mScroller;
+};
+
+
+AGListBox &toAGListBox(AGWidget &w);
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_local.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_local.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_local.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_local.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_local.h"
+#include "ag_debug.h"
+
+
+AGLocalizer *gLocalizer=0;
+
+AGLocalizer::~AGLocalizer()
+{
+  if(gLocalizer==this)
+    gLocalizer=0;
+}
+  
+AGStringUtf8 AGLocalizer::find(const AGString &p)
+{
+  return AGStringUtf8(p);
+}
+
+void setLocalizer(AGLocalizer *p)
+{
+  gLocalizer=p;
+}
+
+AGLocalizer *getLocalizer()
+{
+  return gLocalizer;
+}
+
+
+AGStringUtf8 translate(const AGString &s)
+{
+  AGLocalizer *l=getLocalizer();
+
+  if(l)
+    return l->find(s);
+  return AGStringUtf8(s);
+}

Added: antargis/branches/rant/ext/gui/ag_local.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_local.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_local.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_local.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_LOCAL_H
+#define AG_LOCAL_H
+
+#include <ag_string.h>
+#include <ag_string_utf8.h>
+
+class AGLocalizer
+{
+ public:
+  virtual ~AGLocalizer();
+  
+  virtual AGStringUtf8 find(const AGString &p);
+  
+};
+
+void setLocalizer(AGLocalizer *p);
+AGLocalizer *getLocalizer();
+
+AGStringUtf8 translate(const AGString &s);
+
+#ifndef SWIG
+#ifdef _
+#undef _
+#endif
+#ifdef __
+#undef __
+#endif
+#define _(x) translate(x)
+#define __(x) translate(x)
+#endif
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_menu.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_menu.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_menu.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,129 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_menu.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_menu.h"
+#include "ag_menuitem.h"
+#include "ag_font.h"
+#include "ag_text.h"
+#include "ag_surface.h"
+#include "ag_theme.h"
+
+#include "ag_debug.h"
+
+using namespace std;
+
+AGMenu::AGMenu(AGWidget *pParent,AGVector2 pWishPos,const AGStringUtf8 &pName):
+  AGTable(pParent,AGRect2(pWishPos[0],pWishPos[1],1,1)),
+  sigSelected(this,"sigSelected"),
+  mName(pName.toString()),
+  mWishPos(pWishPos)
+{
+  mBg=AGTexture(getTheme()->getSurface("menu.background.image"));
+  hide();
+  addColumn(1);
+  mW=0;
+  mH=0;
+}
+
+void AGMenu::show(AGVector2 pWishPos)
+{
+  AGWidget::show();
+  mWishPos=pWishPos;
+  AGVector2 p=fromScreen(mWishPos);
+  setTop(p[1]);
+  setLeft(p[0]);
+
+  std::list<AGWidget*>::iterator i=mChildren.begin();
+  for(;i!=mChildren.end();i++)
+    cdebug((*i)->getRect().toString());
+
+}
+
+void AGMenu::addItem(const AGStringUtf8 &pString)
+{
+  AGMenuItem *i=new AGMenuItem(this,pString);
+  addFixedRow(i->height());
+  
+  addChild(0,getRows()-1,i);
+
+  mW=std::max(mW,i->width());
+  setWidth(mW);
+  setHeight(mW);
+  arrange();
+}
+
+AGMenu &AGMenu::addMenu(const AGStringUtf8 &pString)
+{
+  AGSubMenu *s=new AGSubMenu(this,pString);
+  addFixedRow(s->height());
+  addChild(0,getRows()-1,s);
+
+  mH+=s->height();
+  setWidth(mW);
+  setHeight(mW);
+  arrange();
+
+  return *s->getMenu();
+}
+
+
+void AGMenu::draw(AGPainter &p)
+{
+  //  cdebug("draw");
+  //  return;
+  //  adaptWidthFromChildren();
+  //  AGPainter p(getScreen());
+  p.tile(mBg);//,r.project(getRect()));
+
+  //  cdebug(r.project(getRect()).toString());
+}
+
+void AGMenu::eventItemSelected(const AGString &pString)
+{
+  std::list<AGWidget*>::iterator i=mChildren.begin();
+  for(;i!=mChildren.end();i++)
+    {
+      AGMenuItem *item=dynamic_cast<AGMenuItem*>(*i);
+      //cdebug("item:"<<item);
+      if(item)
+	{
+	  //  cdebug(item->getName()<<" "<<pString);
+	  if(item->getSelected() && item->getName()!=pString)
+	    {
+	      //  cdebug("unSelect");
+	      item->unSelect();
+	    }
+	}
+    }
+}
+void AGMenu::eventItemClicked(const AGString &pString)
+{
+  sigSelected(new AGEvent(this,pString));
+  
+  AGMenuItem *mi=dynamic_cast<AGMenuItem*>(getParent());
+  if(mi)
+    {
+      AGMenu *m=dynamic_cast<AGMenu*>(mi->getParent());
+      if(m)
+	m->eventItemClicked(pString);
+    }
+  hide();
+  cdebug("hide");
+}

Added: antargis/branches/rant/ext/gui/ag_menu.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_menu.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_menu.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_menu.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_MENU_H
+#define AG_MENU_H
+
+#include "ag_table.h"
+#include "ag_texture.h"
+
+class AGMenu:public AGTable
+{
+ public:
+  AGMenu(AGWidget *pParent,AGVector2 pWishPos,const AGStringUtf8 &pName);
+
+  void show(AGVector2 pWishPos);
+
+  void addItem(const AGStringUtf8 &pString);
+  AGMenu &addMenu(const AGStringUtf8 &pString);
+
+  void draw(AGPainter &p);
+
+  void eventItemSelected(const AGString &pString);
+  void eventItemClicked(const AGString &pString);
+
+  AGSignal sigSelected;
+
+ private:
+  AGTexture mBg;
+  AGString mName;
+  AGVector2 mWishPos;
+
+  float mW,mH;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_menuitem.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_menuitem.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_menuitem.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,173 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_menuitem.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_menuitem.h"
+#include "ag_debug.h"
+#include "ag_draw.h"
+#include "ag_theme.h"
+#include "ag_image.h"
+#include "ag_menu.h"
+
+AGMenuItem::AGMenuItem(AGWidget *pParent,const AGStringUtf8 &pText):
+  AGTable(pParent,AGRect2(0,0,0,0)),mText(pText),mMouseOver(false),mSelected(false)
+{
+  AGFont font(getTheme()->getFont("Font.menu"));
+
+
+  //  adaptWidthFromChildren(); // so that parent can adapt to this
+
+  //  addChild(new AGText(this,AGVector2(0,0),"X",AGFont("Arial.ttf",25))); // test
+  AGSurface surface=getTheme()->getSurface("menu.item.image");//getScreen().loadSurface("/home/david/projects/oldantargis/graphics/menu_house_small.png");
+
+  addFixedRow(surface.height());
+  addFixedColumn(surface.width());
+  addColumn(1);
+  arrange();
+
+  addChild(0,0,new AGImage(this,getRect().origin(),surface,false));
+  addChild(1,0,new AGText(this,getRect().origin(),pText,font));
+
+}
+AGMenuItem::~AGMenuItem()
+{
+}
+
+void AGMenuItem::draw(AGPainter &p)//const AGRect2 &pr)
+{
+  //  AGRect2 r=pr.project(getRect());
+
+  AGColor c1,c2,c3,c4;
+
+  AGString style=".menu";
+  if(mSelected)//MouseOver)
+    {
+      style+=".lighted";
+      
+      AGTheme *theme=getTheme();
+      
+      c1=theme->getColor(AGString("gradientColor1")+style);
+      c2=theme->getColor(AGString("gradientColor2")+style);
+      c3=theme->getColor(AGString("gradientColor3")+style);
+      c4=theme->getColor(AGString("gradientColor4")+style);
+      
+      //      AGSurface s(getScreen());
+      p.drawGradient(p.getRect(),c1,c2,c3,c4);
+    }
+
+
+}
+
+bool AGMenuItem::eventMouseEnter()
+{
+  mMouseOver=true;
+  mSelected=true;
+  eventSelect();
+
+  AGMenu *p=dynamic_cast<AGMenu*>(getParent());
+  //  cdebug(p);
+  if(p)
+    {
+      p->eventItemSelected(mText.toString());
+    }
+  return false;
+}
+
+bool AGMenuItem::eventMouseLeave()
+{
+  mMouseOver=false;
+  return false;
+}
+
+AGString AGMenuItem::getName() const
+{
+  return mText.toString();
+}
+
+bool AGMenuItem::getSelected() const
+{
+  return mSelected;
+}
+void AGMenuItem::unSelect()
+{
+  mSelected=false;
+  eventUnselect();
+}
+
+void AGMenuItem::eventSelect()
+{
+}
+void AGMenuItem::eventUnselect()
+{
+}
+
+bool AGMenuItem::eventMouseClick(AGEvent *m)
+{
+  cdebug("bool AGMenuItem::eventMouseClick(const AGEvent *m)");
+  AGMenu *me=dynamic_cast<AGMenu*>(getParent());
+  if(me)
+    {
+      me->eventItemClicked(mText.toString());
+      
+      return true;
+    }
+  return false;
+}
+
+// AGSubMenu
+
+AGSubMenu::AGSubMenu(AGWidget *pParent,const AGStringUtf8 &pText):
+  AGMenuItem(pParent,pText)
+{
+  AGSurface surface2=AGSurface::load("right_arrow.png");
+  addChildBack(new AGImage(this,getRect().origin(),surface2,false));
+
+  addChild(mSubMenu=new AGMenu(this,AGVector2(0,0),pText));
+  mSubMenu->hide();
+}
+
+AGSubMenu::~AGSubMenu()
+{
+}
+
+AGMenu *AGSubMenu::getMenu()
+{
+  return mSubMenu;
+}
+
+void AGSubMenu::addChild(AGWidget*pWidget)
+{
+  AGWidget::addChild(pWidget);
+}
+
+void AGSubMenu::eventSelect()
+{
+  AGRect2 r(getScreenRect());
+
+  getMenu()->show(r.getV10());
+}
+void AGSubMenu::eventUnselect()
+{
+  getMenu()->hide();
+}
+
+bool AGSubMenu::eventMouseClick(AGEvent *m)
+{
+  return false;
+}

Added: antargis/branches/rant/ext/gui/ag_menuitem.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_menuitem.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_menuitem.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_menuitem.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_MENUITEM_H
+#define AG_MENUITEM_H
+
+#include "ag_text.h"
+#include "ag_table.h"
+
+class AGMenu;
+
+class AGMenuItem:public AGTable
+{
+ public:
+  AGMenuItem(AGWidget *pParent,const AGStringUtf8 &pText);
+  virtual ~AGMenuItem();
+
+  void draw(AGPainter &p);
+
+  virtual bool eventMouseEnter();
+  virtual bool eventMouseLeave();
+  
+  bool getSelected() const;
+  void unSelect();
+
+  AGString getName() const;
+
+  virtual bool eventMouseClick(AGEvent *m);
+
+  virtual void eventSelect();
+  virtual void eventUnselect();
+
+ private:
+  AGStringUtf8 mText;
+  bool mMouseOver;
+  bool mSelected;
+};
+
+class AGSubMenu:public AGMenuItem
+{
+ public:
+  AGSubMenu(AGWidget *pParent,const AGStringUtf8 &ptext);
+  virtual ~AGSubMenu();
+
+  AGMenu *getMenu();
+
+  virtual void eventSelect();
+  virtual void eventUnselect();
+
+  virtual bool eventMouseClick(AGEvent *m);
+
+ private:
+  void addChild(AGWidget*pWidget);
+
+  AGMenu *mSubMenu;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_radio.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_radio.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_radio.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_radio.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+
+#include "ag_radio.h"
+#include "ag_local.h"
+#include "ag_theme.h"
+#include "ag_image.h"
+#include "ag_layoutfactory.h"
+#include "ag_radiogroup.h"
+#include <typeinfo>
+
+
+AGRadio::AGRadio(AGWidget *pParent,AGRect2 pRect):
+  AGCheckBox(pParent,pRect),mGroup(0)
+{
+  // search mGroup
+  AGWidget *w=pParent;
+  AGRadioGroup *g=0;
+  while(w && g==0)
+    {
+      g=dynamic_cast<AGRadioGroup*>(w);
+      w=w->getParent();
+    }
+  if(g)
+    mGroup=g;
+
+  if(mGroup)
+    mGroup->add(this);
+}
+
+AGRadio::~AGRadio()
+{
+  if(mGroup)
+    mGroup->erase(this);
+}
+
+void AGRadio::setChecked(bool pChecked)
+{
+  bool c=isChecked();
+  if(c!=pChecked)
+    {
+      AGCheckBox::setChecked(pChecked);
+      
+      if(pChecked)
+	{
+	  if(mGroup)
+	    mGroup->eventChange(getName());
+	}
+    }
+}
+
+void AGRadio::deselect()
+{
+  setChecked(false);
+}
+
+void AGRadio::setGroup(AGRadioGroup *pGroup)
+{
+  mGroup=pGroup;
+}
+
+bool AGRadio::eventMouseClick(AGEvent *m)
+{
+  if(!isChecked())
+    setChecked(true);
+
+  return AGButton::eventMouseClick(m);
+}
+
+
+

Added: antargis/branches/rant/ext/gui/ag_radio.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_radio.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_radio.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_radio.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_RADIO_H
+#define AG_RADIO_H
+
+#include "ag_checkbox.h"
+
+class AGRadioGroup;
+
+class AGRadio:public AGCheckBox
+{
+ public:
+  AGRadio(AGWidget *pParent,AGRect2 pRect);
+  virtual ~AGRadio();
+
+  void setGroup(AGRadioGroup *pGroup);
+  bool eventMouseClick(AGEvent *m);
+  
+  void deselect();
+
+  virtual void setChecked(bool pChecked);
+
+ private:
+  AGRadioGroup *mGroup;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_radiogroup.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_radiogroup.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_radiogroup.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_radiogroup.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+
+#include "ag_radio.h"
+#include "ag_radiogroup.h"
+#include "ag_local.h"
+#include "ag_theme.h"
+#include "ag_image.h"
+#include "ag_layoutfactory.h"
+#include <typeinfo>
+
+
+AGRadioGroup::AGRadioGroup(AGWidget *p,const AGRect2 &r):
+  AGWidget(p,r),
+  sigChanged(this,"sigChanged")
+{
+}
+AGRadioGroup::~AGRadioGroup()
+{
+  std::set<AGRadio*>::iterator i=mChildren.begin();
+
+  for(;i!=mChildren.end();i++)
+    (*i)->setGroup(0);
+}
+
+void AGRadioGroup::eventChange(const AGString &p)
+{
+  std::set<AGRadio*>::iterator i=mChildren.begin();
+
+  for(;i!=mChildren.end();i++)
+    {
+      if((*i)->getName()!=p)
+	(*i)->deselect();
+    }
+
+}
+
+void AGRadioGroup::add(AGRadio *r)
+{
+  mChildren.insert(r);
+}
+void AGRadioGroup::erase(AGRadio *r)
+{
+  mChildren.erase(r);
+}
+
+
+
+
+

Added: antargis/branches/rant/ext/gui/ag_radiogroup.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_radiogroup.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_radiogroup.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2007 by David Kamphausen. All rights reserved.
+ *
+ * ag_radiogroup.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_RADIOGROUP_H
+#define AG_RADIOGROUP_H
+
+#include <ag_widget.h>
+
+class AGRadio;
+
+// derive from AGWidget, so that it can be put into the hierarchy
+class AGRadioGroup:public AGWidget
+{
+ public:
+  AGRadioGroup(AGWidget *pParent,const AGRect2 &pr);
+  virtual ~AGRadioGroup();
+
+  virtual void eventChange(const AGString &p);
+
+  void add(AGRadio *r);
+  void erase(AGRadio *r);
+  
+  AGSignal sigChanged;
+ private:
+  std::set<AGRadio*> mChildren;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_screenwidget.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_screenwidget.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_screenwidget.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_screenwidget.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_screen.h"
+#include "ag_screenwidget.h"
+#include "ag_surface.h"
+#include "ag_theme.h"
+#include "ag_debug.h"
+
+
+AGScreenWidget::AGScreenWidget():
+  AGWidget(0,getScreen().getRect())
+{
+  //  mTexture=AGTexture(getTheme()->getSurface("screen.background.image"));
+}
+AGScreenWidget::~AGScreenWidget()
+{
+}
+
+void AGScreenWidget::draw(AGPainter &p)
+{
+  //  p.clip(AGRect2(10,10,50,50));
+  //p.tile(mTexture);
+  p.fillRect(p.getRect().origin(),AGColor(0,0,0));
+}

Added: antargis/branches/rant/ext/gui/ag_screenwidget.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_screenwidget.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_screenwidget.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_screenwidget.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef AG_SCREENWIDGET_H
+#define AG_SCREENWIDGET_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include "ag_widget.h"
+#include "ag_texture.h"
+
+class AGScreenWidget:public AGWidget
+{
+ public:
+  AGScreenWidget();
+  virtual ~AGScreenWidget();
+
+  virtual void draw(AGPainter &p);
+ private:
+  AGTexture mTexture;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_scroller.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_scroller.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_scroller.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,251 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_scroller.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+
+#include "ag_scroller.h"
+#include "ag_button.h"
+#include "ag_border.h"
+#include "ag_background.h"
+#include "ag_debug.h"
+
+AGScroller::AGScroller(AGWidget *pParent,const AGRect2 &pRect,bool pHor):
+  AGWidget(pParent,pRect),
+  sigValueChanged(this,"sigValueChanged"),
+  mHorizontal(pHor)
+{
+  mBorder=new AGBorder("button.border.normal");
+  mBackground=new AGBackground("button.background.normal");
+
+  mMax=1;
+  mMin=0;
+  mValueWidth=0.3;
+  mValue=0.2;
+  mStepping=0.1;
+
+  mVirtualValue=mValue;
+
+  mBorderWidth=2;
+
+  if(mHorizontal)
+    {
+      mB1=new AGButton(this,AGRect2(mBorderWidth,mBorderWidth,height()-mBorderWidth*2,height()-mBorderWidth*2),"");
+      mB2=new AGButton(this,AGRect2(width()+mBorderWidth-height(),mBorderWidth,height()-mBorderWidth*2,height()-mBorderWidth*2),"");
+
+      mScroller=new AGButton(this,AGRect2(mBorderWidth+height(),mBorderWidth,(width()-2*height())*0.5  ,height()-mBorderWidth*2),"");
+
+      //      mScroller->setSurface(AGSurface::load("data/gui/v_bars.png"));
+    }
+  else
+    {
+      mB1=new AGButton(this,AGRect2(mBorderWidth,mBorderWidth,width()-mBorderWidth*2,width()-mBorderWidth*2),"");
+      mB2=new AGButton(this,AGRect2(mBorderWidth,height()+mBorderWidth-width(),width()-mBorderWidth*2,width()-mBorderWidth*2),"");
+
+      mScroller=new AGButton(this,AGRect2(mBorderWidth,mBorderWidth+width(),width()-mBorderWidth*2,(height()-2*width())*0.5),"");
+
+      //      mScroller->setSurface(AGSurface::load("data/gui/h_bars.png"));
+    }
+
+  addChild(mB1);
+  addChild(mB2);
+  addChild(mScroller);
+
+  mScroller->sigDragBy.connect(slot(this,&AGScroller::eventDragBy));
+  mB1->sigClick.connect(slot(this,&AGScroller::eventUpClick));
+  mB2->sigClick.connect(slot(this,&AGScroller::eventDownClick));
+
+  updateScroller();
+
+  if(mHorizontal)
+    {
+      mB1->setSurface(AGSurface::load("data/gui/arrow_left.png"));
+      mB2->setSurface(AGSurface::load("data/gui/arrow_right.png"));
+      mScroller->setSurface(AGSurface::load("data/gui/v_bars.png"));
+    }
+  else
+    {
+      mB1->setSurface(AGSurface::load("data/gui/arrow_up.png"));
+      mB2->setSurface(AGSurface::load("data/gui/arrow_down.png"));
+      mScroller->setSurface(AGSurface::load("data/gui/h_bars.png"));
+    }
+  
+  mB1->setCaching(false);
+  mB2->setCaching(false);
+  mScroller->setCaching(false);
+  setCaching(true);
+}
+
+AGScroller::~AGScroller()
+{
+  delete mBorder;
+  delete mBackground;
+}
+
+void AGScroller::draw(AGPainter &p)
+{
+  AGRect2 pr=getRect().origin();
+  mBackground->draw(pr,p);
+  mBorder->draw(pr,p);
+}
+
+
+bool AGScroller::eventDragBy(AGEvent *pEvent)
+{
+  AGVector2 v=pEvent->getVector();
+  if(mHorizontal)
+    {
+      mVirtualValue+=v[0]/getMovingWidth()*(mMax-mMin);
+      mVirtualValue=std::max(mVirtualValue,mMin);
+      mVirtualValue=std::min(mVirtualValue,mMax);
+      updateScroller();
+    }
+  else
+    {
+      mVirtualValue+=v[1]/getMovingWidth()*(mMax-mMin);
+      mVirtualValue=std::max(mVirtualValue,mMin);
+      mVirtualValue=std::min(mVirtualValue,mMax);
+      updateScroller();
+    }
+  return true;
+}
+
+float AGScroller::getScrollerWidth()
+{
+  float v=0;
+  if(mHorizontal)
+    v=(width()-mBorderWidth*2-getScrollerHeight()*2);
+  else
+    v=(height()-mBorderWidth*2-getScrollerHeight()*2);
+
+  if(mMax!=mMin)
+    v*=mValueWidth/(mMax-mMin);
+  return v;
+    
+}
+float AGScroller::getScrollerHeight()
+{
+  if(mHorizontal)
+    return (height()-mBorderWidth*2);
+  else
+    return (width()-mBorderWidth*2);
+    
+}
+float AGScroller::getMovingWidth()
+{
+  if(mHorizontal)
+    return width()-getScrollerWidth()-2*mBorderWidth-2*getScrollerHeight();
+  else
+    {
+      return height()-getScrollerWidth()-2*mBorderWidth-2*getScrollerHeight();
+    }
+}
+
+void AGScroller::updateScroller()
+{
+  mVirtualValue=std::max(mVirtualValue,mMin);
+  mVirtualValue=std::min(mVirtualValue,mMax);
+
+
+  float nv=int((mVirtualValue-mMin)/mStepping+0.5)*mStepping+mMin;
+
+  if(nv!=mValue)
+    {
+      mValue=nv;
+      sigValueChanged(new AGEvent(this,"sigValueChanged"));
+    }
+
+
+  if(mHorizontal)
+    {
+      float x=mBorderWidth+getScrollerHeight();
+      if(mMax!=mMin)
+	x+=getMovingWidth()*(mValue-mMin)/(mMax-mMin);
+      float y=mBorderWidth;
+      float w=getScrollerWidth();
+      float h=getScrollerHeight();
+      mScroller->setRect(AGRect2(x,y,w,h));
+    }
+  else
+    {
+      float x=mBorderWidth;
+      float y=mBorderWidth+getScrollerHeight();
+
+      if(mMax!=mMin)
+	y+=getMovingWidth()*(mValue-mMin)/(mMax-mMin);
+      float h=getScrollerWidth();
+      float w=getScrollerHeight();
+
+      mScroller->setRect(AGRect2(x,y,w,h));
+    }
+  queryRedraw();
+}
+
+bool AGScroller::eventUpClick(AGEvent *pEvent)
+{
+  mVirtualValue-=mStepping;
+  mVirtualValue=std::max(mVirtualValue,mMin);
+  mVirtualValue=std::min(mVirtualValue,mMax);
+  updateScroller();
+  return true;
+}
+bool AGScroller::eventDownClick(AGEvent *pEvent)
+{
+  mVirtualValue+=mStepping;
+  mVirtualValue=std::max(mVirtualValue,mMin);
+  mVirtualValue=std::min(mVirtualValue,mMax);
+  updateScroller();
+  return true;
+}
+
+void AGScroller::setValue(float pValue)
+{
+  mVirtualValue=pValue;
+  updateScroller();
+}
+void AGScroller::setScrollerSize(float pSize)
+{
+  mValueWidth=pSize;
+  updateScroller();
+}
+void AGScroller::setInterval(float pMin,float pMax)
+{
+  mMin=pMin;
+  mMax=pMax;
+  assert(mMin<=mMax);
+  updateScroller();
+}
+void AGScroller::setStepping(float pStep)
+{
+  mStepping=pStep;
+  updateScroller();
+}
+
+
+float AGScroller::getValue() const
+{
+  return mValue;
+}
+float AGScroller::getMin() const
+{
+  return mMin;
+}
+float AGScroller::getMax() const
+{
+  return mMax;
+}

Added: antargis/branches/rant/ext/gui/ag_scroller.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_scroller.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_scroller.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_scroller.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef __AG_SCROLLER_H
+#define __AG_SCROLLER_H
+
+#include <ag_widget.h>
+
+class AGButton;
+class AGBorder;
+class AGBackground;
+
+class AGScroller:public AGWidget
+{
+ public:
+  AGScroller(AGWidget *pParent,const AGRect2 &pRect,bool pHor);
+  ~AGScroller();
+
+  void draw(AGPainter &p);
+
+  bool eventDragBy(AGEvent *pEvent);
+  bool eventUpClick(AGEvent *pEvent);
+  bool eventDownClick(AGEvent *pEvent);
+
+  AGSignal sigValueChanged;
+
+  void setValue(float pValue);
+  void setScrollerSize(float pSize);
+  void setInterval(float pMin,float pMax);
+  void setStepping(float pStep);
+
+  float getValue() const;
+  float getMin() const;
+  float getMax() const;
+
+ private:
+
+  /// width of scroller if hor (otherwise height)
+  float getScrollerWidth();
+  /// height of scroller if hor (otherwise width)
+  float getScrollerHeight();
+  float getMovingWidth();
+
+  void updateScroller();
+
+
+  float mValue;
+  float mValueWidth;
+  float mMin,mMax;
+  float mStepping;
+
+  float mVirtualValue;
+
+  float mBorderWidth;
+
+  bool mHorizontal;
+  AGButton *mB1,*mB2;
+  AGButton *mScroller;
+  AGBorder *mBorder;
+  AGBackground *mBackground;
+};
+
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_table.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_table.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_table.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,320 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_table.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_table.h"
+#include "ag_debug.h"
+
+AGTable::AGTable(AGWidget *pWidget,const AGRect2 &pRect):
+  AGWidget(pWidget,pRect),
+  w(0),h(0),xw(0),yw(0),mInserted(false)
+{
+}
+
+AGTable::~AGTable()
+{
+}
+
+/// add a column with fixed size of 'size'
+/// @param size gives to size of the column in pixels
+void AGTable::addFixedColumn(float size)
+{
+  if(mInserted)
+    return;
+  cols.push_back(std::make_pair(size,true));
+  w++;
+}
+/// add a row with fixed size of 'size'
+/// @param size gives to size of the row in pixels
+void AGTable::addFixedRow(float size)
+{
+  if(mInserted)
+    return;
+  rows.push_back(std::make_pair(size,true));
+  h++;
+}
+
+/// add a column with relative size.
+/// @param weight
+///  All weights of columns are summed up. After giving their space
+///  to the fixed columns ( AGTable::addFixedColumn() ), each relative sized
+///  column gets its relative size according the weight. (size_left*weight/sum(weights))
+void AGTable::addColumn(float weight)
+{
+  if(mInserted || weight<=0.0f)
+    return;
+  cols.push_back(std::make_pair(weight,false));
+  w++;
+  xw+=weight;
+}
+
+/// add a row with relative size.
+/// @param weight
+///  All weights of rows are summed up. After giving their space
+///  to the fixed rows ( AGTable::addFixedRow() ), each relative sized
+///  row gets its relative size according the weight. (size_left*weight/sum(weights))
+void AGTable::addRow(float weight)
+{
+  if(mInserted || weight<=0.0f)
+    return;
+  rows.push_back(std::make_pair(weight,false));
+  h++;
+  yw+=weight;
+}
+
+/// adds a widget to the given cell (px,py)
+void AGTable::addChild(int px,int py,AGWidget *pWidget)
+{
+  if(px>=w || py>=h || px<0 || py<0)
+    {
+      std::cerr<<"ERROR: wrong table-position:"<<px<<","<<py<<std::endl;
+      std::cerr<<"table size is:"<<w<<","<<h<<std::endl;
+      throw std::runtime_error("WARNING:wrong input position");
+      return;
+    }
+
+  if(!mInserted)
+    children=std::vector<AGWidget*>(w*h,(AGWidget*)0);
+
+  if(children[px+py*w])
+    cdebug("Children "<<px<<","<<py<<" already set!");
+
+  mInserted=true;
+  children[px+py*w]=pWidget;
+  AGWidget::addChild(pWidget);
+}
+
+/// returns the Position and size of a given cell (x,y)
+AGRect2 AGTable::getClientRect(int x,int y) const
+{
+  AGRect2 mrect(0,0,0,0);
+
+  int mx,my;
+
+  // first get the fixed sizes
+  int fx,fy;
+  int mfx,mfy; // max
+  fx=fy=0;
+  mfx=mfy=0;
+  
+  // in y dir
+  for(mx=0;mx<w;mx++)
+    {
+      fy=0;
+      //      if(cols[mx]==0.0)
+	for(my=0;my<h;my++)
+	  {
+	    if(rows[my].second)
+	      fy+=(int)(rows[my].first);
+	  }
+      mfy=std::max(mfy,fy);
+    }
+
+  // x dir
+  for(my=0;my<h;my++)
+    {
+      fx=0;
+      //      if(rows[my]==0.0) // only check fixed
+	for(mx=0;mx<w;mx++)
+	  {
+	    if(cols[mx].second)
+	      {
+		fx+=(int)(cols[mx].first);
+	      }
+	    
+	  }
+      mfx=std::max(mfx,fx);
+    }
+
+
+  if(cols[x].second)
+    mrect.setWidth(cols[x].first);
+  else
+    mrect.setWidth((width()-mfx)*cols[x].first/xw);
+  
+  if(rows[y].second)
+    mrect.setHeight(rows[y].first);
+  else
+    mrect.setHeight((height()-mfy)*rows[y].first/yw);
+  
+  int ax=0;
+  for(mx=0;mx<w;mx++)
+    {
+      if(mx==x)
+	{
+	  mrect.setX(ax);
+	  break;
+	}
+      else
+	{
+	  if(cols[mx].second)
+	    ax+=(int)(cols[mx].first);
+	  else
+	    ax+=(int)((width()-mfx)*cols[mx].first/xw);
+	}
+    }
+
+  int ay=0;
+  for(my=0;my<h;my++)
+    {
+      if(my==y)
+	{
+	  mrect.setY(ay);
+	  break;
+	}
+      else
+	{
+	  if(rows[my].second)
+	    ay+=(int)(rows[my].first);
+	  else
+	    ay+=(int)((height()-mfy)*rows[my].first/yw);
+	}
+    }
+  return mrect;
+}
+
+void AGTable::arrange()
+{
+  CTRACE;
+  int mx,my;
+
+  // first get the fixed sizes
+  int fx,fy;
+  int mfx,mfy; // max
+  fx=fy=0;
+  mfx=mfy=0;
+  
+  // in y dir
+  for(mx=0;mx<w;mx++)
+    {
+      fy=0;
+      //      if(cols[mx]==0.0)
+	for(my=0;my<h;my++)
+	  {
+	    //	    AGWidget *wd=children[mx+my*w];
+	    //	    if(wd)
+	      {
+		if(rows[my].second)
+		  fy+=(int)(rows[my].first);
+	      }
+	  }
+      mfy=std::max(mfy,fy);
+    }
+
+  // x dir
+  for(my=0;my<h;my++)
+    {
+      fx=0;
+      //      if(rows[my]==0.0) // only check fixed
+	for(mx=0;mx<w;mx++)
+	  {
+	    //	    AGWidget *wd=children[mx+my*w];
+	    //	    if(wd)
+	      {
+		if(cols[mx].second)
+		  {
+		    fx+=(int)(cols[mx].first);
+		  }
+	      }
+	  }
+      mfx=std::max(mfx,fx);
+    }
+
+  // assign width's and height's for all non-fixed
+  for(mx=0;mx<w;mx++)
+    for(my=0;my<h;my++)
+      {
+	if(!cols[mx].second)
+	  {
+	    AGWidget *wd=children[mx+my*w];
+	    if(wd)
+	      {
+		wd->setWidth((int)((width()-mfx)*cols[mx].first/xw));
+	      }
+	  }
+	if(!rows[my].second)
+	  {
+	    AGWidget *wd=children[mx+my*w];
+	    if(wd)
+	      {
+		wd->setHeight((int)((height()-mfy)*rows[my].first/yw));
+	      }
+	  }
+      }
+
+  // assign positions
+  // first x 
+  float ax=0;
+  for(mx=0;mx<w;mx++)
+    {
+      float maxx=0;
+      for(my=0;my<h;my++)
+	{
+	  AGWidget *wd=children[mx+my*w];
+	  if(wd)
+	    {
+	      wd->setLeft(ax);
+
+	      maxx=std::max(maxx,wd->width());
+	    }
+	}
+      ax+=maxx;
+    }
+
+  // now y
+  float ay=0;
+  for(my=0;my<h;my++)
+    {
+      float maxy=0;
+      for(mx=0;mx<w;mx++)
+	{
+	  AGWidget *wd=children[mx+my*w];
+	  if(wd)
+	    {
+	      wd->setTop(ay);
+
+	      maxy=std::max(maxy,wd->height());
+	    }
+	}
+      ay+=maxy;
+    }
+  
+}
+
+
+void AGTable::setWidth(float w)
+{
+  cdebug(w);
+  AGWidget::setWidth(w);
+  arrange();
+}
+void AGTable::setHeight(float w)
+{
+  AGWidget::setHeight(w);
+  arrange();
+}
+
+size_t AGTable::getRows() const
+{
+  return rows.size();
+}
+size_t AGTable::getColumns() const
+{
+  return cols.size();
+}

Added: antargis/branches/rant/ext/gui/ag_table.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_table.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_table.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_table.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_TABLE_H
+#define AG_TABLE_H
+
+#include "ag_widget.h"
+
+#include <vector>
+
+/**
+   Description:
+   At first you can adjust rows/columns - then you can insert some children.
+   after that rows and columns are fixed.
+
+   Please call AGTable::arrange() whenever you changed extends and/or row/column-info.
+   
+   @todo children should be re-arranged whenever AGTable::arrange() is called!
+*/
+
+class AGTable:public AGWidget
+{
+ public:
+  AGTable(AGWidget *pWidget,const AGRect2 &pRect);
+  virtual ~AGTable();
+
+  void addFixedColumn(float size);
+  void addFixedRow(float size);
+
+  void addColumn(float weight);
+  void addRow(float weight);
+
+  void addChild(int x,int y,AGWidget *pWidget);
+  AGRect2 getClientRect(int x,int y) const;
+
+  void arrange();
+
+  virtual void setWidth(float w);
+  virtual void setHeight(float w);
+
+  size_t getRows() const;
+  size_t getColumns() const;
+
+ private:
+  int w,h;
+  float xw,yw; // weights
+
+  std::vector<std::pair<float,bool> > rows,cols;
+
+  std::vector<AGWidget*> children;
+
+  bool mInserted;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_text.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_text.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_text.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_text.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+
+#include "ag_text.h"
+#include "ag_debug.h"
+#include "ag_surface.h"
+#include "ag_fontengine.h"
+#include "ag_geometry.h"
+
+#include <iostream>
+
+
+using namespace std;
+
+AGText::AGText(AGWidget *pParent,const AGRect2 &r,const AGStringUtf8 &pText,const AGFont &pFont):
+  AGWidget(pParent,r),
+  mText(pText),mFont(pFont)
+{
+  mFixedSize=true;
+}
+
+AGText::AGText(AGWidget *pParent,const AGVector2 &p,const AGStringUtf8 &pText,const AGFont &pFont):
+  AGWidget(pParent,AGRect2(p[0],p[1],pFont.getWidth(pText),pFont.getHeight(pText))),
+  mText(pText),mFont(pFont)
+{
+  mFixedSize=false;
+}
+
+void AGText::draw(AGPainter &p)
+{
+  float x=(width()-mFont.getWidth(mText))/2;
+  float y=(height()-mFont.getHeight(mText))/2;
+  p.renderText(mText,AGVector2((int)x,(int)y),mFont);
+}
+
+void AGText::setDeriveRect()
+{
+  setRect(AGRect2(getRect().x(),getRect().y(),mFont.getWidth(mText),mFont.getHeight(mText)));
+}
+
+void AGText::setText(const AGStringUtf8 &pText)
+{
+  mText=pText;
+  if(!mFixedSize)
+    {
+      setWidth(mFont.getWidth(pText));
+      setHeight(mFont.getHeight(pText));
+    }
+}
+AGStringUtf8 AGText::getText() const
+{
+  return mText;
+}
+
+AGText &toAGText(AGWidget &w)
+{
+  return dynamic_cast<AGText&>(w);
+}
+
+void AGText::setFont(const AGFont &f)
+{
+  mFont=f;
+}

Added: antargis/branches/rant/ext/gui/ag_text.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_text.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_text.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_text.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_TEXT_H
+#define AG_TEXT_H
+
+#include "ag_widget.h"
+#include "ag_font.h"
+
+class AGText:public AGWidget
+{
+ public:
+  AGText(AGWidget *pParent,const AGRect2 &pRect,const AGStringUtf8 &pText,const AGFont &pFont);
+#ifndef SWIG
+  AGText(AGWidget *pParent,const AGVector2 &pPoint,const AGStringUtf8 &pText,const AGFont &pFont);
+#endif
+
+  void setDeriveRect();
+  virtual void draw(AGPainter &p);
+
+  void setText(const AGStringUtf8 &pText);
+  AGStringUtf8 getText() const;
+
+  void setFont(const AGFont &f);
+
+ private:
+  AGStringUtf8 mText;
+  AGFont mFont;
+  bool mFixedSize;
+};
+
+AGText &toAGText(AGWidget &w);
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_theme.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_theme.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_theme.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,226 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_theme.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_theme.h"
+#include "ag_debug.h"
+#include "ag_xml.h"
+#include "ag_tools.h"
+#include "ag_config.h"
+
+#include <iostream>
+using namespace std;
+
+AGTheme *mTheme=0;
+
+AGTheme::AGTheme()
+{
+}
+
+AGTheme::~AGTheme()
+{
+}
+
+void AGTheme::setFont(const AGString &pName,AGFont pFont)
+{
+  mFonts[pName]=pFont;
+}
+void AGTheme::setColor(const AGString &pName,AGColor pColor)
+{
+  //  cdebug(pName);
+  mColors[pName]=pColor;
+  //  cout<<"setting:"<<pName<<":"<<pColor.toString()<<endl;
+}
+
+
+AGFont AGTheme::getFont(const AGString &pName)
+{
+  //  cdebug(pName<<":"<<mFonts[pName].toString());
+  if(mFonts.find(pName)==mFonts.end())
+    return mFonts[trunk(pName)];
+  return mFonts[pName];
+}
+AGColor AGTheme::getColor(const AGString &pName)
+{
+  //  cdebug(pName);
+  if(mColors.find(pName)==mColors.end())
+    return mColors[trunk(pName)];
+  return mColors[pName];
+}
+
+AGString AGTheme::trunk(AGString s)
+{
+  //  cdebug(s);
+  size_t i=s.find(".");
+  if(i!=s.npos)
+    s=s.substr(0,i);
+  return s;
+}
+
+int AGTheme::getInt(const AGString &pName)
+{
+  if(mInts.find(pName)==mInts.end())
+    return mInts[trunk(pName)];
+  return mInts[pName];
+}
+void AGTheme::setInt(const AGString &pName,int i)
+{
+  mInts[pName]=i;
+}
+
+
+
+void loadDefaultTheme()
+{
+  loadThemeFile("theme.xml");
+  
+  if(!mTheme)
+    mTheme=new AGTheme;
+}
+
+void setTheme(const AGTheme &t)
+{
+  if(mTheme)
+    delete mTheme;
+  mTheme=new AGTheme(t);
+}
+
+AGTheme *getTheme()
+{
+  if(mTheme==0)
+    loadDefaultTheme();
+  return mTheme;
+}
+
+bool AGTheme::hasSurface(const AGString &pName) const
+{
+  //  cdebug(pName);
+  return(mSurfaces.find(pName)!=mSurfaces.end());
+}
+bool AGTheme::hasColor(const AGString &pName) const
+{
+  //  cdebug(pName);
+  return(mColors.find(pName)!=mColors.end());
+}
+
+
+AGSurface AGTheme::getSurface(const AGString &pName)
+{
+  if(mSurfaces.find(pName)==mSurfaces.end())
+    return mSurfaces[trunk(pName)];
+  return mSurfaces[pName];
+}
+void AGTheme::setSurface(const AGString &pName,const AGSurface &pSurface)
+{
+  assert(pSurface.valid());
+  mSurfaces[pName]=pSurface;
+  assert(mSurfaces[pName].valid());
+}
+
+std::string AGTheme::getSurfaceName(const AGString &pName)
+{
+  if(mSurfaceNames.find(pName)==mSurfaceNames.end())
+    return mSurfaceNames[trunk(pName)];
+  return mSurfaceNames[pName];
+}
+void AGTheme::setSurfaceName(const AGString &pName,const std::string &pSurface)
+{
+  mSurfaceNames[pName]=pSurface;
+}
+
+
+void loadTheme(const Node&node,AGTheme &t,AGString name)
+{
+  Node::const_iterator i=node.begin();
+  for(;i!=node.end();i++)
+    {
+      
+      AGString n=name;
+      if(n.length())
+	n+=".";
+      n+=(*i)->getName();
+      if((*i)->get("name").length())
+	{
+	  AGString sname=name+"."+(*i)->get("name");
+	  // read color /image whatever
+	  if((*i)->getName()=="color")
+	    t.setColor(sname,AGColor((*i)->get("color")));
+	  if((*i)->getName()=="image")
+	    {
+	      t.setSurface(sname,AGSurface::load((*i)->get("file")));
+	      t.setSurfaceName(sname,(*i)->get("file"));
+	    }
+	  if((*i)->getName()=="value")
+	    t.setInt(sname,(*i)->get("value").toInt());
+	  if((*i)->getName()=="font")
+	    {
+	      AGFont f((*i)->get("file"),(*i)->get("size").toInt());
+	      f.setColor(AGColor((*i)->get("color")));
+	      f.setEmbossed((*i)->get("embossed")=="true");
+	      f.setInset((*i)->get("inset")=="true");
+	      if((*i)->get("style")=="bold")
+		f.setStyle(AGFont::BOLD);
+	      f.setBorderColor(AGColor((*i)->get("borderColor")));
+	      f.setBorder((*i)->get("borderWidth").toInt());
+
+	      t.setFont(sname,f);
+	    }
+	}
+      else
+	loadTheme(**i,t,n);
+    }
+}
+
+void loadTheme(const AGData &pXML)
+{
+  AGTheme theme;
+
+  Document p;
+  p.parseMemory(pXML);
+
+  Node n=p.root();
+
+  loadTheme(n,theme,"");
+  
+  setTheme(theme);
+}
+
+bool loadThemeFile(const AGFilename &pFilename)
+{
+  AGTheme theme;
+
+  Document p;
+  if(!p.parseFile(pFilename))
+    return false;
+
+  const Node &n=p.root();
+
+  loadTheme(n,theme,"");
+  
+  setTheme(theme);
+  return true;
+}
+
+AGString addPoint(const AGString &pTheme)
+{
+  if(pTheme.length())
+    if(pTheme[pTheme.length()-1]!='.')
+      return pTheme+".";
+  return pTheme;
+}

Added: antargis/branches/rant/ext/gui/ag_theme.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_theme.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_theme.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_theme.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_THEME_H
+#define AG_THEME_H
+
+#include "ag_font.h"
+#include "ag_surface.h"
+
+#include <map>
+
+class AGTheme
+{
+ public:
+  AGTheme();
+  virtual ~AGTheme();
+
+  AGFont getFont(const AGString &pName);
+  AGColor getColor(const AGString &pName);
+
+  void setFont(const AGString &pName,AGFont pFont);
+  void setColor(const AGString &pName,AGColor pColor);
+
+  int getInt(const AGString &pName);
+  void setInt(const AGString &pName,int i);
+
+  AGSurface getSurface(const AGString &pName);
+  void setSurface(const AGString &pName,const AGSurface &pSurface);
+
+  std::string getSurfaceName(const AGString &pName);
+  void setSurfaceName(const AGString &pName,const std::string &pSurface);
+
+
+  bool hasSurface(const AGString &pName) const;
+  bool hasColor(const AGString &pName) const;
+
+ private:
+
+  AGString trunk(AGString s);
+
+  std::map<AGString,AGFont> mFonts;
+  std::map<AGString,AGColor> mColors;
+  std::map<AGString,AGSurface> mSurfaces;
+  std::map<AGString,std::string> mSurfaceNames;
+  std::map<AGString,int> mInts;
+};
+
+AGTheme *getTheme();
+void setTheme(const AGTheme &aTheme);
+void loadTheme(const AGData &pXML);
+bool loadThemeFile(const AGFilename &pFilename);
+
+AGString addPoint(const AGString &pTheme);
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_tooltip.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_tooltip.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_tooltip.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_tooltip.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_tooltip.h"
+#include "ag_theme.h"
+#include "ag_screen.h"
+#include "ag_edit.h"
+#include "ag_debug.h"
+#include "ag_tools.h"
+
+AGTooltip::AGTooltip(const AGRect2 &pRect,const AGStringUtf8 &pText):
+  AGWidget(0,pRect),
+  mText(pText),
+  mFont(getTheme()->getFont("tooltip.font")),
+  mBgColor(getTheme()->getColor("tooltip.bgcolor")),
+  mBorderColor(getTheme()->getColor("tooltip.bordercolor"))
+{
+
+  float sw=getScreen().getWidth();
+  float sh=getScreen().getHeight();
+
+  mText=mText.replace("\\n","\n");
+
+  float tw,th;
+
+  if(mText.find("\n")!=std::string::npos)
+    {
+      // estimate each line size
+      std::vector<AGStringUtf8> a=mText.split("\n");
+      tw=th=0;
+      for(std::vector<AGStringUtf8>::iterator i=a.begin();i!=a.end();++i)
+	{
+	  tw=std::max(tw,(float)mFont.getWidth(*i));
+	  th+=mFont.getHeight(*i);
+	}
+    }
+  else
+    {
+      // first estimate a rectangle which can hold the text
+      float ftw=mFont.getWidth(mText);
+      float fth=mFont.getHeight(mText);
+      float maxw=150;
+      if(ftw>maxw)
+	{
+	  tw=maxw;
+	  th=(ftw+50)/maxw*(fth+4);
+	}
+      else
+	{
+	  // 1 line only
+	  tw=ftw;
+	  th=fth;
+	}
+    }
+  tw+=6;
+  th+=5;
+
+  // now estimate a nice position
+
+  // check below
+
+  cdebug("th:"<<th);
+  cdebug("bottom:"<<bottom());
+  cdebug("sh:"<<sh);
+  cdebug("left:"<<left());
+
+  if(th+bottom()+4<sh)
+    setRect(AGRect2(left(),bottom()+2,tw,th));
+  else if(top()-4-tw>0)
+    // above
+    setRect(AGRect2(left(),top()-th-2,tw,th));
+  else if(tw+right()+4<sw)
+    // right
+    setRect(AGRect2(right()+2,top(),tw,th));
+  else
+    // above
+    setRect(AGRect2(left(),top()-th-2,tw,th));
+
+  if(right()>sw)
+    setLeft(sw-2-width());
+  //  setRect(AGRect2(0,0,tw,th));
+
+  cdebug(getRect());
+  
+  //  mFont.setColor(AGColor(0,0,0));
+  AGEdit *e=new AGEdit(this,getRect().origin().shrink(1));
+  e->setText(mText);
+  e->setFont(mFont);
+  e->setMutable(false);
+  e->setBackground(false);
+  addChild(e);
+}
+
+void AGTooltip::draw(AGPainter &p)
+{
+  //  p.transform(getRect());
+  p.fillRect(getRect().origin(),mBorderColor);
+  p.fillRect(getRect().origin().shrink(1),mBgColor);
+}

Added: antargis/branches/rant/ext/gui/ag_tooltip.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_tooltip.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_tooltip.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_tooltip.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_TOOLTIP_H
+#define AG_TOOLTIP_H
+
+#include <ag_widget.h>
+
+class AGTooltip:public AGWidget
+{
+ public:
+  AGTooltip(const AGRect2 &pRect,const AGStringUtf8 &pText);
+
+  virtual void draw(AGPainter &p);
+ private:
+  AGStringUtf8 mText;
+  AGFont mFont;
+  AGColor mBgColor;
+  AGColor mBorderColor;
+};
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_widget.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_widget.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_widget.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,1110 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_widget.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_widget.h"
+#include "ag_debug.h"
+#include "ag_screen.h"
+#include "ag_main.h"
+#include "ag_menu.h"
+#include "ag_kill.h"
+#include <map>
+#include <iostream>
+#include <algorithm>
+#include <typeinfo>
+#include <ag_tooltip.h>
+#include "ag_application.h"
+#include "ag_layout.h"
+#include "ag_config.h"
+#include "ag_clip.h"
+
+#define FOCUS_BY_SORT
+
+
+using namespace std;
+
+//AGWidget *agNoParent=0;
+
+static bool gNewClippingTechnique=true;
+
+void setNewClippingTechnique(bool f)
+{
+  gNewClippingTechnique=f;
+}
+bool getNewClippingTechnique()
+{
+  return gNewClippingTechnique;
+}
+
+
+
+class MWidgetSet:public std::set<AGWidget*>
+{
+public:
+  virtual ~MWidgetSet();
+};
+MWidgetSet *mPAllWidgets=0; // workaround - to check if still widget exists or not
+bool mWidgetSetDeleted=false;
+
+MWidgetSet::~MWidgetSet()
+{
+  CTRACE;
+  mPAllWidgets=0;
+  mWidgetSetDeleted=true;
+}
+
+MWidgetSet *getAllWidgets()
+{
+  if(!mPAllWidgets)
+    {
+      if(!mWidgetSetDeleted)
+	{
+	  mPAllWidgets=new MWidgetSet;
+	  REGISTER_SINGLETON(mPAllWidgets);
+	}
+    }
+  return mPAllWidgets;
+}
+
+
+AGWidget::AGWidget(AGWidget *pParent,const AGRect2 &r):
+  sigMouseEnter(this,"sigMouseEnter"),
+  sigMouseLeave(this,"sigMouseLeave"),
+  sigClick(this,"sigClick"),
+  mr(r),mParent(pParent),mChildrenEventFirst(false),mChildrenDrawFirst(false),mMouseIn(false),mButtonDown(false),
+  mFixedWidth(false),mFixedHeight(false),mVisible(true),mCaching(false),
+  mHasFocus(false),mFocus(0)
+
+{
+  mChangeRect=AGRect2(0,0,0,0);
+  mCache=0;
+  mCacheTouched=false;
+  mTooltipWidget=0;
+  mRubyObject=false;
+  mModal=false;
+  if(getAllWidgets())
+    getAllWidgets()->insert(this);
+
+  getMain()->getCollector()->insertGlobal(this);
+}
+
+AGWidget::~AGWidget()
+{
+  CTRACE;
+
+  if(!mParent)
+    if(hasMain())
+      getMain()->getCollector()->removeGlobal(this);
+
+
+  //  throw int();
+  std::list<AGWidget*>::iterator i=mChildren.begin();
+  for(;i!=mChildren.end();i++)
+    {
+      (*i)->setParent(0);
+    }
+  if(getParent())
+    {
+      if(getAllWidgets())
+	{
+	  if(getAllWidgets()->find(getParent())==getAllWidgets()->end())
+	    {
+	      dbout(5000,"WARNING:Error in ~AGWidget!!!");
+	    }
+	  else
+	    getParent()->eventChildrenDeleted(this);
+	}
+    }
+  if(getAllWidgets())
+    getAllWidgets()->erase(this);
+}
+
+void AGWidget::removeChild(AGWidget *w)
+{
+  std::list<AGWidget*>::iterator i=std::find(mChildren.begin(),mChildren.end(),w);
+  if(i!=mChildren.end())
+    {
+      mChildren.erase(i);
+      w->setParent(0);
+    }
+}
+
+
+void AGWidget::eventChildrenDeleted(AGWidget *pWidget)
+{
+  std::list<AGWidget*>::iterator i=mChildren.begin();
+  for(;i!=mChildren.end();i++)
+    {
+      if(*i==pWidget)
+	{
+	  mChildren.erase(i);
+	  break;
+	}
+    }
+  i=mToClear.begin();
+  for(;i!=mToClear.end();i++)
+    {
+      if(*i==pWidget)
+	{
+	  mToClear.erase(i);
+	  break;
+	}
+    }
+}
+
+
+void AGWidget::draw(AGPainter &p)
+{
+}
+
+void AGWidget::delObjects()
+{
+ // clearing widgets
+  if(mToClear.size())
+    {
+      std::list<AGWidget*>::iterator i=mToClear.begin();
+      for(;i!=mToClear.end();i++)
+	{
+	  if(!(*i)->mRubyObject) // don't delete ruby-objects - they get deleted by garbage collection
+	    {
+	      dbout(5000,"type:"<<typeid(**i).name());
+	      delete *i;
+	    }
+	}
+      mToClear.clear();
+    }
+}
+
+void AGWidget::drawAll(AGPainter &p)
+{
+  delObjects();
+
+  if(!mVisible)
+    return;
+
+  if(mCache)
+    {
+      p.blit(*mCache,getRect(),getRect().origin());
+    }
+  else
+    {
+      p.pushMatrix();
+
+      p.transform(getRect());
+
+      if(!mChildrenDrawFirst)
+	draw(p);
+
+      std::list<AGWidget*>::reverse_iterator i=mChildren.rbegin(); // draw from back to front
+      
+      for(;i!=mChildren.rend();i++)
+	(*i)->drawAll(p);
+      
+      if(mChildrenDrawFirst)
+	draw(p);
+
+      drawAfter(p);
+    
+      p.popMatrix();
+      setDrawn();
+      //	  getScreen().flip();
+      //	  SDL_Delay(500);
+    }
+}
+
+AGRect2 AGWidget::getRect() const
+{
+  return mr;
+}
+
+AGRect2 AGWidget::getClientRect() const
+{
+  return mr.origin();
+}
+
+bool AGWidget::processEvent(AGEvent *event)
+{
+  if(!mVisible)
+    return false;
+
+  bool processed = false;
+  // do i have a capturehook set ? (modal)
+  // i will send that event to my children
+
+  std::list<AGWidget*>::iterator i;
+
+  std::list<AGWidget*> children=mChildren; // copy children, so that changes do not affect iteration
+  for(i=children.begin();i!=children.end() && !processed; i++)
+    processed=(*i)->processEvent(event);
+  
+  if(processed)
+    return processed;
+
+  event->setCaller(this);
+  
+  // let me see if i can process it myself
+  if(AGMessageObject::processEvent(event))
+    return true;
+  
+  checkFocus();
+  if(mModal)
+    return true;
+  return false;
+}
+
+bool AGWidget::eventShow()
+{
+  return false;
+}
+bool AGWidget::eventHide()
+{
+  return false;
+}
+
+bool AGWidget::eventMouseEnter()
+{
+  if(mTooltip.length())
+    {
+      mTooltipWidget=new AGTooltip(getScreenRect(),mTooltip);
+      getApplication()->setTooltip(mTooltipWidget);
+    }
+
+  return false;
+}
+bool AGWidget::eventMouseLeave()
+{
+  if(mTooltipWidget)
+    {
+      getApplication()->resetTooltip(mTooltipWidget);
+      mTooltipWidget=0;
+    }
+  return false;
+}
+
+bool AGWidget::eventMouseMotion(AGEvent *e)
+{
+  if(!visible())
+    return false;
+
+  if(e->isSDLEvent())
+    {
+      if(getScreenRect().contains(e->getMousePosition()))
+	{
+	  if(!mMouseIn)
+	    {
+	      mMouseIn=true;
+	      eventMouseEnter() || sigMouseEnter(e);
+	    }
+	}
+      else
+	{
+	  if(mMouseIn)
+	    {
+	      mMouseIn=false;
+	      eventMouseLeave() || sigMouseLeave(e);
+	    }
+	}
+
+      if(mButtonDown)
+	{
+	  AGVector2 v=e->getMousePosition()-mOldMousePos;
+	  e->setVector(v);
+	  eventDragBy(e,v) || sigDragBy(e);
+	  mOldMousePos=e->getMousePosition();
+	}
+    }
+  return false;
+}
+
+bool AGWidget::eventMouseButtonDown(AGEvent *e)
+{
+  if(e->isSDLEvent())
+    {
+      if(getScreenRect().contains(e->getMousePosition()))
+	{
+	  mButtonDown=true;
+	  mOldMousePos=e->getMousePosition();
+	}
+    }
+  return false;
+}
+
+bool AGWidget::eventMouseButtonUp(AGEvent *e)
+{
+  bool was=mButtonDown;
+
+  mButtonDown=false;
+  
+  if(e->isSDLEvent())
+    {
+      if(getScreenRect().contains(e->getMousePosition()))
+	{
+	  if(was)
+	    {
+	      e->setName("sigClick");
+	      if(!isParent(getApplication()->getOverlay()))
+		getApplication()->setOverlay(0);
+	      
+	      if(canFocus())
+		gainFocus();
+
+	      return (eventMouseClick(e) || sigClick(e));
+
+	    }
+	}
+    }
+  return false;
+
+}
+
+bool AGWidget::eventMouseClick(AGEvent *m)
+{
+  return false;
+}
+
+void AGWidget::addChild(AGWidget *w)
+{
+  mChildren.push_front(w); // set on top
+  if(mHasFocus && w->canFocus())
+    {
+      gainFocus(w);
+    }
+  queryRedraw();
+}
+
+void AGWidget::clear()
+{
+  // delay it till be draw everything - so this doesn't kill widgets while processing events
+  std::copy(mChildren.begin(),mChildren.end(),std::back_inserter(mToClear));
+  mChildren.clear();
+}
+
+void AGWidget::erase(AGWidget *w)
+{
+  std::list<AGWidget*>::iterator i=std::find(mChildren.begin(),mChildren.end(),w);
+  if(i!=mChildren.end())
+    {
+      mToClear.push_back(w);
+      
+      mChildren.erase(i);
+    }
+}
+
+void AGWidget::addChildBack(AGWidget *w)
+{
+  mChildren.push_back(w); // set on top
+}
+
+void AGWidget::regChange()
+{
+  AGRect2 t=getScreenRect().grow(5);
+
+  pushChangeRect(t);
+
+  if(mChangeRect.width()==0 || mChangeRect.height()==0)
+    mChangeRect=t;
+  else
+    {
+      mChangeRect.include(t[0]);
+      mChangeRect.include(t[1]);
+    }
+}
+
+void AGWidget::setRect(const AGRect2 &pRect)
+{
+  regChange();
+  mr=pRect;
+  regChange();
+  if(mParent)
+    mParent->redraw();
+}
+
+float AGWidget::minWidth() const
+{
+  // accumulate max
+  std::list<AGWidget*>::const_iterator i=mChildren.begin();
+  float m=0;
+
+  for(;i!=mChildren.end();i++)
+    m=std::max(m,(*i)->minWidth());
+
+  return m;
+}
+
+float AGWidget::minHeight() const
+{
+  // accumulate max
+  std::list<AGWidget*>::const_iterator i=mChildren.begin();
+  float m=0;
+
+  for(;i!=mChildren.end();i++)
+    m=std::max(m,(*i)->minHeight());
+
+  return m;
+}
+
+float AGWidget::width() const
+{
+  return mr.w();
+}
+
+float AGWidget::height() const
+{
+  return mr.h();
+}
+
+bool AGWidget::fixedWidth() const
+{
+  return mFixedWidth;
+}
+
+bool AGWidget::fixedHeight() const
+{
+  return mFixedHeight;
+}
+
+void AGWidget::setWidth(float w)
+{
+  regChange();
+  mr.setWidth(w);
+  regChange();
+}
+void AGWidget::setHeight(float h)
+{
+  regChange();
+  mr.setHeight(h);
+  regChange();
+}
+
+void AGWidget::setTop(float y)
+{
+  regChange();
+  mr.setTop(y);
+  regChange();
+}
+void AGWidget::setLeft(float x)
+{
+  regChange();
+  mr.setLeft(x);
+  regChange();
+}
+float AGWidget::bottom() const
+{
+  return mr[1][1];
+}
+float AGWidget::right() const
+{
+  return mr[1][0];
+}
+
+
+float AGWidget::top() const
+{
+  return mr.y();
+}
+
+float AGWidget::left() const
+{
+  return mr.x();
+}
+
+void AGWidget::show()
+{
+  mVisible=true;
+  queryRedraw();
+}
+void AGWidget::hide()
+{
+  mVisible=false;
+  queryRedraw();
+}
+
+void AGWidget::setVisible(bool v)
+{
+  if(mVisible!=v)
+    {
+      queryRedraw();
+    }
+  mVisible=v;
+}
+
+
+void AGWidget::setParent(AGWidget *pParent)
+{
+  if(!mParent)
+    {
+      if(hasMain())
+	getMain()->getCollector()->removeGlobal(this);
+    }
+
+  mParent=pParent;
+}
+
+
+AGWidget *AGWidget::getParent()
+{
+  return mParent;
+}
+
+AGVector2 AGWidget::getScreenPosition() const
+{
+  AGVector2 p=mr[0];
+
+  if(mParent)
+    p+=mParent->getScreenPosition();
+
+  return p;
+}
+
+
+AGRect2 AGWidget::getScreenRect() const
+{
+  AGRect2 srect(mr.origin()+getScreenPosition());
+  return srect;
+}
+
+AGVector2 AGWidget::fromScreen(const AGVector2 &p) const
+{
+  if(!mParent)
+    return p;
+  AGRect2 r(mParent->getScreenRect());
+  return p-r[0];
+}
+
+bool AGWidget::canFocus() const
+{
+  std::list<AGWidget*>::const_iterator i=mChildren.begin();
+
+  for(;i!=mChildren.end();i++)
+    if((*i)->canFocus())
+      {
+
+	return true;
+      }
+
+  return false;
+}
+
+bool AGWidget::eventGotFocus()
+{
+  mHasFocus=true;
+  return false;
+}
+
+bool AGWidget::eventLostFocus()
+{
+  if(mFocus)
+    mFocus->eventLostFocus();
+  mHasFocus=false;
+  mFocus=0;
+  
+  return false;
+}
+/*
+void AGWidget::setMenu(AGMenu *pMenu)
+{
+  mMenu=pMenu;
+  }*/
+
+void AGWidget::gainCompleteFocus(AGWidget *pWidget)
+{
+#ifdef FOCUS_BY_SORT
+  if(mParent)
+    mParent->gainCompleteFocus(this);
+  if(pWidget)
+    {
+      //      dbout(5000,mChildren.size());
+      std::list<AGWidget*>::iterator i=std::find(mChildren.begin(),mChildren.end(),pWidget);
+      if(i!=mChildren.end())
+	{
+	  mChildren.erase(i);
+	  mChildren.push_front(pWidget);
+	}
+      //      dbout(5000,mChildren.size());
+    }
+#endif
+}
+
+void AGWidget::gainFocus(AGWidget *pWidget)
+{
+#ifdef FOCUS_BY_SORT
+  if(pWidget)
+    {
+      //      dbout(5000,mChildren.size());
+      std::list<AGWidget*>::iterator i=std::find(mChildren.begin(),mChildren.end(),pWidget);
+      if(i!=mChildren.end())
+	{
+	  mChildren.erase(i);
+
+	  if(mChildren.size()>0)
+	    (*mChildren.begin())->eventLostFocus();
+
+	  mChildren.push_front(pWidget);
+	  pWidget->eventGotFocus();
+
+	}
+      //      dbout(5000,mChildren.size());
+    }
+  else if(mParent)
+    {
+      if(canFocus())
+	{
+	  mParent->gainFocus(this);
+	}
+    }
+#else
+  if(pWidget==0 && mParent)
+    mParent->gainFocus(this);
+  else if(mParent)
+    mParent->gainFocus(pWidget);
+  else
+    gainFocusDown(pWidget);
+#endif
+}
+
+void AGWidget::gainFocusDown(AGWidget *pWidget)
+{
+  std::list<AGWidget*>::iterator i;
+  i=std::find(mChildren.begin(),mChildren.end(),pWidget);
+  if(i!=mChildren.end())
+    {
+      // found
+      if(!mHasFocus)
+	{
+	  if(mParent)
+	    mParent->gainFocus(this);
+	  else
+	    {
+	      mHasFocus=true;
+	      eventGotFocus();
+	    }
+	}
+      
+      if(mFocus!=pWidget)
+	{
+	  if(mFocus)
+	    mFocus->eventLostFocus();
+	  mFocus=pWidget;
+	  mFocus->eventGotFocus();
+	}
+    }
+  else
+    {
+      for(i=mChildren.begin();i!=mChildren.end();i++)
+	(*i)->gainFocusDown(pWidget);
+    }
+}
+
+void AGWidget::checkFocus()
+{
+  if(mChildren.size()>0 && mFocus && mHasFocus)
+    {
+      if(mFocus!=*mChildren.begin())
+	{
+	  std::list<AGWidget*>::iterator i;
+	  
+	  i=std::find(mChildren.begin(),mChildren.end(),mFocus);
+	  // delete children and set to front 
+	  mChildren.erase(i);
+	  mChildren.push_front(mFocus);
+	  //	  dbout(5000,"mchildren #:"<<mChildren.size());
+	}
+    }
+}
+
+bool AGWidget::hasFocus(const AGWidget *pWidget)
+{
+#ifdef FOCUS_BY_SORT
+  if(pWidget==0)
+    {
+      if(mParent)
+	return mParent->hasFocus(this);
+      else
+	return true;
+    }
+  if(mChildren.size()==0)
+    return true; // some error
+
+  if(*mChildren.begin()==pWidget)
+    {
+      if(mParent)
+	return mParent->hasFocus(this); // ok - so go on and check if "this" has focus
+      return true; // ok
+    }
+
+  return false;
+#else
+  if(pWidget==0)
+    {
+      if(mParent)
+	return mParent->hasFocus(this);
+      else
+	return true;
+    }
+  else if(mFocus!=pWidget)
+    return false;
+  else if(mParent)
+    return mParent->hasFocus(this);
+  return true;
+#endif
+}
+
+
+bool AGWidget::eventDragBy(AGEvent *event,const AGVector2 &pDiff)
+{
+  return false;
+}
+
+bool AGWidget::getFocus() const
+{
+  return mHasFocus;
+}
+
+const AGString &AGWidget::getName() const
+{
+  return mName;
+}
+void AGWidget::setName(const AGString &pName)
+{
+  mName=pName;
+}
+
+void AGWidget::drawAfter(AGPainter &p)
+{
+}
+
+bool AGWidget::visible() const
+{
+  return mVisible;
+}
+
+/// override this and return true, if widget is opaque and you want to increase performance
+bool AGWidget::isOpaque() const
+{
+  return false;
+}
+
+
+
+AGWidget *AGWidget::getChild(const AGString &pName)
+{
+	CTRACE;
+  if(mName==pName)
+    return this;
+
+  AGWidget *w=0;
+  std::list<AGWidget*>::iterator i=mChildren.begin();
+
+  for(;i!=mChildren.end();i++)
+    {
+      w=(*i)->getChild(pName);
+      if(w)
+				break;
+    }
+	cdebug("w:"<<w);
+  return w;
+}
+
+void AGWidget::setModal(bool pModal)
+{
+  mModal=pModal;
+}
+
+void AGWidget::mark()
+{
+  for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();i++)
+    {
+      markObject(*i);
+    }
+
+  // mark mToClear also - as it can be that they are still used on stack
+  for(std::list<AGWidget*>::iterator i=mToClear.begin();i!=mToClear.end();i++)
+    markObject(*i);
+}
+
+
+
+AGWidget *toAGWidget(AGMessageObject *o)
+{
+  return dynamic_cast<AGWidget*>(o);
+}
+
+
+bool AGWidget::redraw() const
+{
+  return mCacheTouched;
+}
+
+bool AGWidget::checkRedraw() const
+{
+  if(!mVisible)
+    return false;
+  if(redraw())
+    return true;
+  for(std::list<AGWidget*>::const_iterator i=mChildren.begin();i!=mChildren.end();++i)
+    if((*i)->checkRedraw())
+      return true;
+  return false;
+}
+
+void AGWidget::prepareDrawAll()
+{
+  if(!mVisible)
+    return;
+
+  for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();++i)
+    (*i)->prepareDrawAll();
+
+  prepareDraw();
+  
+}
+
+
+void AGWidget::prepareDraw()
+{
+  if(!mVisible)
+    return;
+
+  if(mCache)
+    {
+      if(checkRedraw() || !mCache->hasTexture())
+	{
+	  mCache->clearContent();
+
+	  AGPainter p(*mCache);
+
+	  if(!mChildrenDrawFirst)
+	    draw(p);
+	  
+	  std::list<AGWidget*>::reverse_iterator i=mChildren.rbegin(); // draw from back to front
+
+	  for(;i!=mChildren.rend();i++)
+	    (*i)->drawAll(p);
+
+	  if(mChildrenDrawFirst)
+	    draw(p);
+
+	  drawAfter(p);
+
+	  setDrawn();
+
+	  /*
+	  {
+	    static int i=0;
+	    i++;
+	    std::ostringstream os;
+	    os<<"widget_"<<i<<".png";
+	    AGSurface ms(mCache->sdlTexture());
+	    ms.save(os.str());
+	    
+	  }
+	  */
+
+	  if(mParent)
+	    {
+	      //CTRACE;
+	      cdebug("parent->queryRedraw::"<<typeid(*this).name()<<":"<<getName());
+	      mParent->queryRedraw();
+	    }
+
+	  assert(checkRedraw()==false);
+	  assert(mCache->hasTexture());
+	}
+    }
+}
+void AGWidget::setCaching(bool pEnable)
+{
+  // FIXME: really no caching without GL? 
+  //  if(!glMode())
+  //    return;
+
+
+  if(getConfig()->get("widgetTextureCache")=="false")
+    return;
+  getConfig()->set("widgetTextureCache","true");
+
+  mCaching=pEnable;
+  delete mCache;
+
+  mCache=0;
+  mCacheTouched=false;
+  if(pEnable)
+    {
+      mCache=new AGTexture((int)width(),(int)height());
+      
+      mCacheTouched=true;
+    }
+}
+
+void AGWidget::setDrawn()
+{
+  if(!mVisible)
+    return;
+
+  mCacheTouched=false;
+  for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();++i)
+    (*i)->setDrawn();
+  mChangeRect=AGRect2(0,0,0,0);
+}
+
+void AGWidget::queryRedraw()
+{
+  cdebug(getName()<<"::"<<typeid(*this).name());
+  mCacheTouched=true;
+  regChange();
+}
+
+/**
+   \brief special function for "using textures"
+
+   within a texture-garbage-collection run all unused textures get cleaned,
+   so this function "uses" the textures. This way they won't get collected
+*/
+void AGWidget::useTextures()
+{
+}
+
+/**
+   \brief special function for "using textures"
+
+   within a texture-garbage-collection run all unused textures get cleaned,
+   so this function "uses" the textures. This way they won't get collected.
+
+   This function calles useTextures() recursively. Don't override this one!
+*/
+void AGWidget::useTexturesRecursive()
+{
+  useTextures();
+  for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();++i)
+    (*i)->useTexturesRecursive();
+}
+
+AGRect2 AGWidget::getChangeRect()
+{
+  AGRect2 r=mChangeRect;
+  
+  for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();++i)
+    {
+      AGRect2 n=(*i)->getChangeRect();
+      if(n.width()!=0 && n.height()!=0)
+	{
+	  if(r.width()!=0 && r.height()!=0)
+	    {
+	      r.include(n[0]);
+	      r.include(n[1]);
+	    }
+	  else
+	    r=n;
+	}
+    }
+  return r;
+}
+
+void AGWidget::setTooltip(const AGStringUtf8 &pTooltip)
+{
+  mTooltip=pTooltip;
+}
+
+AGLayout *AGWidget::getLayout()
+{
+  AGLayout *l=dynamic_cast<AGLayout*>(this);
+  if(l)
+    return l;
+  if(mParent)
+    return mParent->getLayout();
+  return 0;
+}
+
+void AGWidget::initHandlers()
+{
+}
+
+void AGWidget::eventTick(float pTime)
+{
+}
+void AGWidget::sigTick(float pTime)
+{
+  eventTick(pTime);
+  for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();++i)
+    (*i)->sigTick(pTime);
+}
+
+void AGWidget::close()
+{
+  if(mParent)
+    mParent->removeChild(this);
+}
+
+bool AGWidget::isParent(AGWidget *pParent)
+{
+  if(mParent==pParent)
+    return true;
+  else if(mParent!=0)
+    return mParent->isParent(pParent);
+  return false;
+}
+
+void AGWidget::acquireClipping(AGClipping &p)
+{
+  if(!visible())
+    return;
+
+  //  cdebug("clipping before:"<<p.toString());
+  if(isOpaque())
+    p.exclude(getScreenRect());
+  
+  for(std::list<AGRect2>::iterator i=mMyChanges.begin();i!=mMyChanges.end();i++)
+    p.include(*i);//+getScreenPosition());
+
+  //  cdebug("clipping in:"<<p.toString());
+  
+  for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();i++)
+    (*i)->acquireClipping(p);
+
+  //  cdebug("clipping after:"<<p.toString());
+  return;
+}
+
+
+std::list<AGRect2> AGWidget::aquireChanges()
+{
+  std::list<AGRect2> l;
+
+  for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();i++)
+    {
+      std::list<AGRect2> t=(*i)->aquireChanges();
+      // FIXME: check, if opaque and truncates rectangles
+      std::copy(t.begin(),t.end(),std::back_inserter(l));
+    }
+  std::copy(mMyChanges.begin(),mMyChanges.end(),std::back_inserter(l));
+  
+  return l;
+}
+void AGWidget::pushChangeRect(const AGRect2 &pRect)
+{
+  cdebug("push:"<<pRect);
+  mMyChanges.push_back(pRect);
+}
+void AGWidget::clearChangeRects()
+{
+  cdebug("clearing - size was:"<<mMyChanges.size());
+  mMyChanges.clear();
+  for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();i++)
+    (*i)->clearChangeRects();
+}

Added: antargis/branches/rant/ext/gui/ag_widget.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_widget.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_widget.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,263 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_widget.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_WIDGET_H
+#define AG_WIDGET_H
+
+#include "ag_geometry.h"
+#include "ag_messageobject.h"
+
+#include <list>
+
+#include "ag_painter.h"
+
+class AGTooltip;
+class AGLayout;
+class AGClipping;
+
+/** 
+    \defgroup widgets Widgets
+    \brief contains all the widgets
+
+    Everything that has a display on screen is called a widget. There are plenty of different widget-types
+    and you are free to define new ones.
+
+    An AGApplication object has one single main-widget, that you can define.
+    All other widgets are children (or grandchildren ...) of this main-widget.
+
+    A simple example how to use nested widgets is:
+    <pre>
+    AGWidget *parent,*w;
+    AGApplication app;
+    
+    parent=new AGWidget(0,AGRect2(0,0,640,480));
+    w=new AGWidget(parent,AGRect2(0,0,100,100));
+    parent->addChild(w);
+    app.setMainWidget(parent);
+    </pre>
+
+    Nearly all of the widget-types are created this way. Adding a widget to another will automate
+    the drawing and event-processing.
+
+*/
+
+
+
+/**
+   \brief base class for all widgets
+
+   \ingroup widgets
+
+   AGWidget is the base class for all widgets. It manages the hierarchy and memory of the widgets.
+   You should never delete an AGWidget for yourself if you don't know exactly what you're doing.
+   The widgets get deleted by their parents
+*/
+
+class AGWidget:public AGMessageObject
+{
+ public:
+  AGWidget(AGWidget *pParent,const AGRect2 &r);
+  virtual ~AGWidget();
+
+  virtual void initHandlers();
+  
+  virtual void draw(AGPainter &p);
+  virtual void drawAfter(AGPainter &p);
+  virtual void drawAll(AGPainter &p);
+  AGRect2 getRect() const;
+  virtual AGRect2 getClientRect() const;
+  void setRect(const AGRect2 &pRect);
+  
+  void setParent(AGWidget *pParent);
+  AGWidget *getParent();
+  bool isParent(AGWidget *pParent);
+
+  virtual bool eventShow();
+  virtual bool eventHide();
+
+  virtual bool eventMouseMotion(AGEvent *m);
+
+  virtual bool eventMouseEnter();
+  virtual bool eventMouseLeave();
+  virtual bool eventMouseClick(AGEvent *m);
+
+  virtual bool eventMouseButtonDown(AGEvent *m);
+  virtual bool eventMouseButtonUp(AGEvent *m);
+
+  virtual bool eventGotFocus();
+  virtual bool eventLostFocus();
+
+  virtual void eventTick(float pTime);
+  void sigTick(float pTime);
+
+  virtual bool canFocus() const;
+
+  bool processEvent(AGEvent *event);
+
+  AGSignal sigMouseEnter;
+  AGSignal sigMouseLeave;
+  AGSignal sigClick;
+  AGSignal sigDragBy;
+
+  virtual float minWidth() const;
+  virtual float minHeight() const;
+
+  float width() const;
+  float height() const;
+  float top() const;
+  float left() const;
+  float bottom() const;
+  float right() const;
+
+  bool visible() const;
+  void setVisible(bool v);
+  bool isOpaque() const;
+
+  virtual void setWidth(float w);
+  virtual void setHeight(float w);
+  virtual void setTop(float y);
+  virtual void setLeft(float x);
+
+  bool fixedWidth() const;
+  bool fixedHeight() const;
+
+  void show();
+  void hide();
+  void close();
+
+  virtual void mark();
+
+  virtual void addChild(AGWidget *w);
+  virtual void addChildBack(AGWidget *w);
+
+  virtual void removeChild(AGWidget *w);
+
+  // Functions for caching appearance
+  virtual bool redraw() const;
+  virtual void prepareDraw();
+
+  void prepareDrawAll();
+
+  void setCaching(bool pEnable);
+  bool checkRedraw() const;
+  void setDrawn();
+  void queryRedraw();
+  AGRect2 getChangeRect();
+
+  // when caching, "normal" textures are not used, so they get discarded
+  // to prevent this, use this function to "use" them in each frame
+  virtual void useTextures(); // when caching
+  void useTexturesRecursive(); // when caching
+
+
+  // clear children
+  void clear();
+
+  AGRect2 getScreenRect() const;
+  AGVector2 getScreenPosition() const;
+  AGVector2 fromScreen(const AGVector2 &p) const;
+
+  // focus
+
+  /** should only be called by a child */
+  void gainFocus(AGWidget *pWidget=0);
+  void gainCompleteFocus(AGWidget *pWidget=0);
+
+
+  virtual bool eventDragBy(AGEvent *event,const AGVector2 &pDiff);
+
+  bool getFocus() const;
+  bool hasFocus(const AGWidget *pWidget=0);
+
+  AGLayout *getLayout();
+
+
+  const AGString &getName() const;
+  void setName(const AGString &pName);
+  AGWidget *getChild(const AGString &pName);
+
+  void setModal(bool pModal);
+
+  void erase(AGWidget *w);
+
+  void eventChildrenDeleted(AGWidget *pWidget);
+
+  void setTooltip(const AGStringUtf8 &pTooltip);
+
+  void acquireClipping(AGClipping &p);
+
+  std::list<AGRect2> aquireChanges();
+  void pushChangeRect(const AGRect2 &pRect);
+  void clearChangeRects();
+
+ private:
+  std::list<AGRect2> mMyChanges;
+
+  void regChange();
+
+  void drawCache();
+
+  void delObjects();
+
+  void gainFocusDown(AGWidget *pWidget);
+
+  void checkFocus();
+
+  std::list<AGWidget*> mToClear;
+
+  AGRect2 mr;
+  AGWidget *mParent;
+  bool mChildrenEventFirst;
+  bool mChildrenDrawFirst;
+  bool mMouseIn;
+  bool mButtonDown;
+  bool mFixedWidth,mFixedHeight;
+  bool mVisible;
+  bool mCaching;
+  AGTexture *mCache;
+  bool mCacheTouched;
+
+  bool mHasFocus;
+  AGWidget *mFocus;
+
+  AGVector2 mOldMousePos;
+
+  AGString mName;
+  bool mModal;
+
+  AGRect2 mChangeRect;
+
+  AGStringUtf8 mTooltip;
+  AGTooltip *mTooltipWidget;
+
+ protected:
+  std::list<AGWidget*> mChildren;
+
+};
+
+AGWidget *toAGWidget(AGMessageObject *o);
+
+void setNewClippingTechnique(bool f);
+bool getNewClippingTechnique();
+
+
+#endif

Added: antargis/branches/rant/ext/gui/ag_window.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_window.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_window.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,227 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_window.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_window.h"
+#include "ag_surface.h"
+#include "ag_theme.h"
+#include "ag_image.h"
+#include "ag_text.h"
+#include "ag_debug.h"
+#include "ag_button.h"
+#include "ag_caption.h"
+#include "ag_texturecache.h"
+
+#undef connect
+
+AGWindow::AGWindow(AGWidget *pWidget,const AGRect2 &pRect,const AGStringUtf8 &pTitle,const AGString &pTheme):
+  AGTable(pWidget,pRect),sigClose(this,"sigClose"),mTitle(pTitle)
+
+{
+  CTRACE;
+
+  AGString tstr="window.border.image";
+  if(pTheme!="")
+    tstr=pTheme+"."+tstr;
+
+
+  cdebug("image:"<<tstr);
+  AGSurface s=getTheme()->getSurface(tstr);
+  float bw=s.getRect().w()/3;
+  int titBarHeight=20;
+
+  //  cdebug("window_border:"<<s.width()<<"/"<<s.height());
+  AGTable *t=0;
+
+
+  std::vector<const AGTexture*> textures;
+
+  // build textures
+  for(int y=0;y<3;y++)
+    for(int x=0;x<3;x++)
+      {
+	AGRect2 r(x*bw,y*bw,bw,bw);
+	
+	textures.push_back(&getTextureCache()->get(getTheme()->getSurfaceName(tstr),r));
+      }
+
+
+
+ 
+  if(pTitle.length())
+    {
+      // use 4 rows
+      addFixedRow(bw); // upper border
+      addFixedRow(titBarHeight); // titletext and button
+      //      addFixedRow(bw); // lower border below titletext
+      addRow(1.0); 
+      addFixedRow(bw); // lower lower below window
+      addFixedColumn(bw);
+      addColumn(1.0);
+      addFixedColumn(bw);
+      
+      AGTable::addChild(0,0,new AGImage(this,AGRect2(0,0,bw,bw),*textures[0],true));
+      AGTable::addChild(1,0,new AGImage(this,AGRect2(0,0,bw,bw),*textures[1],true));
+      AGTable::addChild(2,0,new AGImage(this,AGRect2(0,0,bw,bw),*textures[2],true));
+      
+      AGImage *i1,*i2;
+
+      AGTable::addChild(0,1,i1=new AGImage(this,AGRect2(0,0,bw,titBarHeight),*textures[3],true));//,AGRect2(0,bw,bw,bw)));
+      // title
+      t=dynamic_cast<AGTable*>(getTitleBar((int)(width()-2*bw),titBarHeight));
+
+      AGTable::addChild(2,1,i2=new AGImage(this,AGRect2(0,0,bw,titBarHeight),*textures[5],true));
+      i1->setHeight(t->height());
+      i2->setHeight(t->height());
+
+      cdebug("i2:"<<i2->width()<<"   "<<i2->height());
+      cdebug("bw:"<<bw);
+
+      
+      AGTable::addChild(0,2,new AGImage(this,AGRect2(0,0,bw,bw),*textures[3],true));
+      AGTable::addChild(2,2,new AGImage(this,AGRect2(0,0,bw,bw),*textures[5],true));
+      
+      AGTable::addChild(0,3,new AGImage(this,AGRect2(0,0,bw,bw),*textures[6],true));
+      AGTable::addChild(1,3,new AGImage(this,AGRect2(0,0,bw,bw),*textures[7],true));
+      AGTable::addChild(2,3,new AGImage(this,AGRect2(0,0,bw,bw),*textures[8],true));
+      
+      AGTable::addChild(1,2,mClient=new AGCaption(this,AGRect2(0,0,0,0),"",getTheme()->getFont("window.title.font"),AGBackground("window.background")));
+
+    }
+  else
+    {
+      // use 3 rows
+      addFixedRow(bw);
+      addRow(1.0);
+      addFixedRow(bw);
+      addFixedColumn(bw);
+      addColumn(1.0);
+      addFixedColumn(bw);
+      
+      AGTable::addChild(0,0,new AGImage(this,AGRect2(0,0,bw,bw),*textures[0],true));
+      AGTable::addChild(1,0,new AGImage(this,AGRect2(0,0,bw,bw),*textures[1],true));
+      AGTable::addChild(2,0,new AGImage(this,AGRect2(0,0,bw,bw),*textures[2],true));
+      
+      AGTable::addChild(0,1,new AGImage(this,AGRect2(0,0,bw,bw),*textures[3],true));
+      AGTable::addChild(2,1,new AGImage(this,AGRect2(0,0,bw,bw),*textures[5],true));
+      
+      AGTable::addChild(0,2,new AGImage(this,AGRect2(0,0,bw,bw),*textures[6],true));
+      AGTable::addChild(1,2,new AGImage(this,AGRect2(0,0,bw,bw),*textures[7],true));
+      AGTable::addChild(2,2,new AGImage(this,AGRect2(0,0,bw,bw),*textures[8],true));
+      
+      AGTable::addChild(1,1,mClient=new AGCaption(this,AGRect2(0,0,0,0),"",getTheme()->getFont("window.title.font"),AGBackground("window.background")));
+    }
+
+  arrange();
+}
+
+void AGWindow::addChild(AGWidget *w)
+{
+  // FIXME: change this somehow?
+  AGWidget::addChild(w);
+  //  mClient->addChild(w);
+}
+
+AGWidget *AGWindow::getClient()
+{
+  return mClient;
+}
+
+bool AGWindow::eventMouseButtonDown(AGEvent *e)
+{
+  CTRACE;
+  if(!hasFocus())
+    {
+      CTRACE;
+      if(e->isSDLEvent())
+	if(getScreenRect().contains(e->getMousePosition()))
+	  if(getParent())
+	    {
+	      getParent()->gainFocus(this);
+	      return true;
+	    }
+    }
+
+  bool ret=AGTable::eventMouseButtonDown(e);
+
+  if(e->isSDLEvent())
+    if(getScreenRect().contains(e->getMousePosition()))
+      return true; // eat - if it was here - always!!!
+  return ret;
+
+}
+
+bool AGWindow::eventDragBy(AGEvent *event,const AGVector2 &pDiff)
+{
+  //  TRACE;
+  setTop(top()+pDiff[1]);
+  setLeft(left()+pDiff[0]);
+  return true;
+}
+
+AGWidget *AGWindow::getTitleBar(int w,int h)
+{
+  cdebug("W:"<<w);
+  AGTable *t=new AGTable(this,AGRect2(0,0,0,20));//60,20));
+  AGSurface closeSurface=getTheme()->getSurface("window.buttons.close");
+  AGButton *closeButton;
+  AGWidget *title;
+
+  AGTable::addChild(1,1,t);
+
+  t->addRow(1.0);
+
+  t->addColumn(1.0);
+  t->addFixedColumn(h);//close button
+  
+  //  t->addChild(0,0,title=new AGButton(t,AGRect2(0,0,0,0),mTitle));
+  t->addChild(0,0,title=new AGCaption(t,AGRect2(0,0,0,0),mTitle,getTheme()->getFont("window.title.font"),AGBackground("window.title.background")));
+  t->addChild(1,0,closeButton=new AGButton(t,AGRect2(0,0,20,20),"aa"));
+  closeButton->setSurface(closeSurface,false);
+  title->setName("title"); // FIXME: maybe name getName()+".title"
+
+  //  AGListener 
+  closeButton->sigClick.connect(slot(this,&AGWindow::tryClose));
+  //  t->arrange();
+  return t;
+}
+
+bool AGWindow::tryClose(AGEvent *m)
+{
+  TRACE;
+  hide();
+  m->setCaller(this);
+  sigClose(m);
+  return false;
+}
+
+void AGWindow::close()
+{
+  hide();
+}
+
+AGRect2 AGWindow::getClientRect() const
+{
+  return const_cast<AGWindow*>(this)->getClient()->getClientRect()+mClient->getRect().getV0();
+}
+
+AGWindow &toAGWindow(AGWidget &w)
+{
+  return dynamic_cast<AGWindow&>(w);
+}

Added: antargis/branches/rant/ext/gui/ag_window.h
===================================================================
--- antargis/branches/rant/ext/gui/ag_window.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/ag_window.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_window.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_WINDOW_H
+#define AG_WINDOW_H
+
+#include "ag_table.h"
+
+class AGWindow:public AGTable
+{
+ public:
+  AGWindow(AGWidget *pWidget,const AGRect2 &pRect,const AGStringUtf8 &pTitle="",const AGString &pTheme="");
+
+  void addChild(AGWidget *w);
+
+  AGWidget *getClient();
+
+  virtual bool eventMouseButtonDown(AGEvent *m);
+  bool eventDragBy(AGEvent *event,const AGVector2 &pDiff);
+
+  void close();
+
+  // slot
+  virtual bool tryClose(AGEvent *m);
+
+  AGRect2 getClientRect() const;
+
+  AGSignal sigClose;
+
+ private:
+
+  AGWidget *getTitleBar(int w,int h);
+
+  AGStringUtf8 mTitle;
+  AGWidget *mClient;
+};
+
+AGWindow &toAGWindow(AGWidget &w);
+
+#endif

Modified: antargis/branches/rant/ext/gui/headers.hh
===================================================================
--- antargis/branches/rant/ext/gui/headers.hh	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/gui/headers.hh	2007-06-23 15:07:27 UTC (rev 1105)
@@ -63,27 +63,27 @@
 #include "/home/david/projects/antargis/rant/ext/gui/ag_table.h"
 #include "/home/david/projects/antargis/rant/ext/gui/ag_layout.h"
 #include "/home/david/projects/antargis/rant/ext/gui/ag_colorbutton.h"
-#include "/home/david/projects/antargis/rant/ext/gui/ag_button.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_image.h"
 #include "/home/david/projects/antargis/rant/ext/gui/ag_screenwidget.h"
-#include "/home/david/projects/antargis/rant/ext/gui/ag_combo.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_listbox.h"
 #include "/home/david/projects/antargis/rant/ext/gui/ag_frame.h"
 #include "/home/david/projects/antargis/rant/ext/gui/ag_text.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_button.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_edit.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_radiogroup.h"
 #include "/home/david/projects/antargis/rant/ext/gui/ag_scroller.h"
-#include "/home/david/projects/antargis/rant/ext/gui/ag_radiogroup.h"
 #include "/home/david/projects/antargis/rant/ext/gui/ag_tooltip.h"
-#include "/home/david/projects/antargis/rant/ext/gui/ag_menuitem.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_combo.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_menu.h"
 #include "/home/david/projects/antargis/rant/ext/gui/ag_caption.h"
 #include "/home/david/projects/antargis/rant/ext/gui/ag_window.h"
 #include "/home/david/projects/antargis/rant/ext/gui/ag_checkbox.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_menuitem.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_radio.h"
 #include "/home/david/projects/antargis/rant/ext/gui/ag_theme.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_border.h"
+#include "/home/david/projects/antargis/rant/ext/gui/ag_background.h"
 #include "/home/david/projects/antargis/rant/ext/gui/ag_local.h"
-#include "/home/david/projects/antargis/rant/ext/gui/ag_edit.h"
-#include "/home/david/projects/antargis/rant/ext/gui/ag_radio.h"
-#include "/home/david/projects/antargis/rant/ext/gui/ag_menu.h"
-#include "/home/david/projects/antargis/rant/ext/gui/ag_background.h"
-#include "/home/david/projects/antargis/rant/ext/gui/ag_listbox.h"
-#include "/home/david/projects/antargis/rant/ext/gui/ag_image.h"
-#include "/home/david/projects/antargis/rant/ext/gui/ag_border.h"
 #ifdef SWIG
 %include "/home/david/projects/antargis/rant/ext/gui/ag_layoutfactory.h"
 %include "/home/david/projects/antargis/rant/ext/gui/ag_widget.h"
@@ -91,26 +91,26 @@
 %include "/home/david/projects/antargis/rant/ext/gui/ag_table.h"
 %include "/home/david/projects/antargis/rant/ext/gui/ag_layout.h"
 %include "/home/david/projects/antargis/rant/ext/gui/ag_colorbutton.h"
-%include "/home/david/projects/antargis/rant/ext/gui/ag_button.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_image.h"
 %include "/home/david/projects/antargis/rant/ext/gui/ag_screenwidget.h"
-%include "/home/david/projects/antargis/rant/ext/gui/ag_combo.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_listbox.h"
 %include "/home/david/projects/antargis/rant/ext/gui/ag_frame.h"
 %include "/home/david/projects/antargis/rant/ext/gui/ag_text.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_button.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_edit.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_radiogroup.h"
 %include "/home/david/projects/antargis/rant/ext/gui/ag_scroller.h"
-%include "/home/david/projects/antargis/rant/ext/gui/ag_radiogroup.h"
 %include "/home/david/projects/antargis/rant/ext/gui/ag_tooltip.h"
-%include "/home/david/projects/antargis/rant/ext/gui/ag_menuitem.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_combo.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_menu.h"
 %include "/home/david/projects/antargis/rant/ext/gui/ag_caption.h"
 %include "/home/david/projects/antargis/rant/ext/gui/ag_window.h"
 %include "/home/david/projects/antargis/rant/ext/gui/ag_checkbox.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_menuitem.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_radio.h"
 %include "/home/david/projects/antargis/rant/ext/gui/ag_theme.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_border.h"
+%include "/home/david/projects/antargis/rant/ext/gui/ag_background.h"
 %include "/home/david/projects/antargis/rant/ext/gui/ag_local.h"
-%include "/home/david/projects/antargis/rant/ext/gui/ag_edit.h"
-%include "/home/david/projects/antargis/rant/ext/gui/ag_radio.h"
-%include "/home/david/projects/antargis/rant/ext/gui/ag_menu.h"
-%include "/home/david/projects/antargis/rant/ext/gui/ag_background.h"
-%include "/home/david/projects/antargis/rant/ext/gui/ag_listbox.h"
-%include "/home/david/projects/antargis/rant/ext/gui/ag_image.h"
-%include "/home/david/projects/antargis/rant/ext/gui/ag_border.h"
 #endif
 #endif

Added: antargis/branches/rant/ext/math/ag_algebra.cc
===================================================================
--- antargis/branches/rant/ext/math/ag_algebra.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/math/ag_algebra.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,208 @@
+#include "ag_algebra.h"
+#include "ag_debug.h"
+#include "ag_gauss.h"
+#include "ag_stringstream.h"
+
+
+
+AGMatrixN::AGMatrixN(size_t w,size_t h):m(w*h,0),
+					mW(w),mH(h)
+{
+}
+
+AGMatrixN::AGMatrixN(const AGMatrixN &n):m(n.m),
+					mW(n.mW),
+					mH(n.mH)
+{
+}
+
+void AGMatrixN::set(size_t x,size_t y,float v)
+{
+  assert(x<mW);
+  assert(y<mH);
+  m[index(x,y)]=v;
+}
+float AGMatrixN::get(size_t x,size_t y) const
+{
+  assert(x<mW);
+  assert(y<mH);
+  return m[index(x,y)];
+}
+
+AGMatrixN &AGMatrixN::operator*=(const AGMatrixN &p)
+{
+  assert(mW==p.mH);
+  AGMatrixN n(p.mW,mH);
+  for(size_t x=0;x<p.mW;x++)
+    for(size_t y=0;y<mH;y++)
+      {
+	float v=0;
+	for(size_t k=0;k<mW;k++)
+	  v+=get(k,y)*p.get(x,k);
+	n.set(x,y,v);
+      }
+  *this=n;
+  return *this;
+    
+}
+AGMatrixN AGMatrixN::operator*(const AGMatrixN &p) const
+{
+  assert(mW==p.mH);
+  AGMatrixN n(p.mW,mH);
+  for(size_t x=0;x<p.mW;x++)
+    for(size_t y=0;y<mH;y++)
+      {
+	float v=0;
+	for(size_t k=0;k<mW;k++)
+	  v+=get(k,y)*p.get(x,k);
+	n.set(x,y,v);
+      }
+  return n;
+}
+
+AGMatrixN AGMatrixN::operator-(const AGMatrixN &p) const
+{
+  assert(mW==p.mW);
+  assert(mH==p.mH);
+  AGMatrixN n(mW,mH);
+
+  for(size_t x=0;x<mW;x++)
+    for(size_t y=0;y<mH;y++)
+      n.set(x,y,get(x,y)-p.get(x,y));
+  return n;
+}
+
+float AGMatrixN::scalar() const
+{
+  float s=0;
+  float v;
+  for(size_t x=0;x<mW;x++)
+    for(size_t y=0;y<mH;y++)
+      {
+	v=get(x,y);
+	s+=v*v;
+      }
+  return sqrt(s);
+}
+
+
+AGMatrixN AGMatrixN::makeQuadratic() const
+{
+  size_t nw=std::max(mW,mH);
+  AGMatrixN a(nw,nw);
+  a.copyFrom(*this);
+  return a;
+}
+
+/// a very simple way to compute a pseudo-inverse
+/// using svd may be better - no matter ;-)
+/// for details go to http://en.wikipedia.org/wiki/Pseudoinverse
+AGMatrixN AGMatrixN::pseudoInverse() const
+{
+  AGMatrixN t=transposed();
+  if(mW<mH)
+    return (t*(*this)).inverse()*t;
+  else
+    return t*((*this)*t).inverse();
+}
+
+AGMatrixN AGMatrixN::transposed() const
+{
+  AGMatrixN a(mH,mW);
+  for(size_t x=0;x<mW;x++)
+    for(size_t y=0;y<mH;y++)
+      a.set(y,x,get(x,y));
+  return a;
+}
+
+
+
+AGMatrixN AGMatrixN::inverse() const
+{
+  size_t nw=std::max(mW,mH);
+  AGMatrixN a(nw,nw),b(nw,nw);
+
+  a.makeUnitMatrix();
+  b.copyFrom(*this);
+  /*
+  std::cout<<"A:"<<std::endl;
+  a.output();
+  std::cout<<"B:"<<std::endl;
+  b.output();
+  */
+  gauss(a,b,nw);
+  /*
+  std::cout<<"A:"<<std::endl;
+  a.output();
+  std::cout<<"B:"<<std::endl;
+  b.output();*/
+  return a;
+}
+
+void AGMatrixN::makeUnitMatrix()
+{
+  for(size_t x=0;x<mW;x++)
+    for(size_t y=0;y<mH;y++)
+      set(x,y,(x==y?1:0));
+}
+  
+void AGMatrixN::copyFrom(const AGMatrixN &p)
+{
+  for(size_t x=0;x<mW && x<p.mW;x++)
+    for(size_t y=0;y<mH && y<p.mH;y++)
+      set(x,y,p.get(x,y));
+}
+
+void AGMatrixN::output() const
+{
+  for(size_t y=0;y<mH;y++)
+    {
+      for(size_t x=0;x<mW;x++)
+	{
+	  std::cout<<get(x,y)<<"\t";
+	}
+      std::cout<<"\n";
+    }
+
+}
+
+AGString AGMatrixN::toString() const
+{
+  AGStringStream s;
+  for(size_t y=0;y<mH;y++)
+    {
+      for(size_t x=0;x<mW;x++)
+	{
+	  s<<get(x,y)<<"\t";
+	}
+      s<<"\n";
+    }
+  return s.str();
+}
+
+void AGMatrixN::swapRows(size_t a,size_t b)
+{
+  if(a==b)
+    return;
+  assert(a<mH);
+  assert(b<mH);
+  for(size_t x=0;x<mW;x++)
+    {
+      float t=get(x,a);
+      set(x,a,get(x,b));
+      set(x,b,t);
+    }
+}
+void AGMatrixN::swapCols(size_t a,size_t b)
+{
+  if(a==b)
+    return;
+  assert(a<mW);
+  assert(b<mW);
+  for(size_t y=0;y<mH;y++)
+    {
+      float t=get(a,y);
+      set(a,y,get(b,y));
+      set(b,y,t);
+    }
+}

Added: antargis/branches/rant/ext/math/ag_algebra.h
===================================================================
--- antargis/branches/rant/ext/math/ag_algebra.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/math/ag_algebra.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,50 @@
+#ifndef AG_ALGEBRA_H
+#define AG_ALGEBRA_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include <vector>
+#include <ag_string.h>
+
+class AGMatrixN
+{
+ public:
+  AGMatrixN(size_t w,size_t h);
+  AGMatrixN(const AGMatrixN &p);
+
+  void set(size_t x,size_t y,float v);
+  float get(size_t x,size_t y) const;
+
+  AGMatrixN &operator*=(const AGMatrixN &p);
+  AGMatrixN operator*(const AGMatrixN &p) const;
+
+  AGMatrixN operator-(const AGMatrixN &p) const;
+
+  float scalar() const;
+
+  AGMatrixN inverse() const;
+  AGMatrixN pseudoInverse() const;
+  AGMatrixN makeQuadratic() const;
+
+  AGMatrixN transposed() const;
+
+  void makeUnitMatrix();
+
+  void copyFrom(const AGMatrixN &p);
+
+  void output() const;
+
+  AGString toString() const;
+
+  void swapRows(size_t a,size_t b);
+  void swapCols(size_t a,size_t b);
+
+ private:
+  
+  inline size_t index(size_t x,size_t y) const { return x+y*mW; }
+
+  std::vector<float> m;
+  size_t mW,mH;
+};
+
+#endif

Added: antargis/branches/rant/ext/math/ant_frustum.cc
===================================================================
--- antargis/branches/rant/ext/math/ant_frustum.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/math/ant_frustum.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ant_frustum.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ant_frustum.h"
+#include "ag_debug.h"
+#include "ag_profiler.h"
+
+/////////////////////////////////////////////////////////////////////
+// AntPlane
+/////////////////////////////////////////////////////////////////////
+
+AntPlane::AntPlane(const AGVector3 &dir,float offset):
+  mDir(dir),
+  mOffset(offset)
+{
+}
+
+AntPlane makePlane(const AGVector3 &p0,const AGVector3 &p1,const AGVector3 &p2)
+{
+  AGVector3 up=p1-p0;
+  AGVector3 right=p2-p0;
+  up/=up.length();
+  right/=right.length();
+#warning "maybe this must be swapped!"
+  AGVector3 dir=up%right;
+  
+  return AntPlane(dir,dir*p0);
+}
+
+
+/////////////////////////////////////////////////////////////////////
+// AntFrustum
+/////////////////////////////////////////////////////////////////////
+AntFrustum::AntFrustum(const std::vector<AntPlane> &pPlanes):
+  mPlanes(pPlanes)
+{
+  assert(mPlanes.size()==6);
+
+  //  cdebug(*this);
+}
+
+bool AntFrustum::inside(const AGVector3 &v) const
+{
+  for(std::vector<AntPlane>::const_iterator i=mPlanes.begin();i!=mPlanes.end();++i)
+    if(!i->inside(v))
+      return false;
+  return true;
+}
+
+bool AntFrustum::collides(const AGBox3 &b) const
+{
+  static std::vector<AGVector3> vs(8);
+  {
+    b.calcVertices(vs);
+  }
+  static bool outside;
+  static std::vector<AntPlane>::const_iterator i;
+  static std::vector<AGVector3>::iterator j;
+
+  
+  for(i=mPlanes.begin();i!=mPlanes.end();++i)
+    {
+      outside=true;
+      for(j=vs.begin();j!=vs.end();++j)
+	{
+	  if(i->inside(*j))
+	    {
+	      outside=false;
+	      break;
+	    }
+	}
+      if(outside)
+	return false;
+    }
+  return true;
+}
+
+
+std::ostream &operator<<(std::ostream &o,const AntPlane &p)
+{
+  o<<"("<<p.mDir<<","<<p.mOffset<<")";
+  return o;
+}
+std::ostream &operator<<(std::ostream &o,const AntFrustum &p)
+{
+  for(std::vector<AntPlane>::const_iterator i=p.mPlanes.begin();i!=p.mPlanes.end();++i)
+    o<<*i<<";";
+  return o;
+}

Added: antargis/branches/rant/ext/math/ant_frustum.h
===================================================================
--- antargis/branches/rant/ext/math/ant_frustum.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/math/ant_frustum.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ant_frustum.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef ANT_FRUSTUM_H
+#define ANT_FRUSTUM_H
+
+#include "ag_geometry.h"
+
+class AntPlane
+{
+ public:
+  AntPlane(const AGVector3 &dir,float offset);
+
+  bool inside(const AGVector3 &v) const;
+
+  friend std::ostream &operator<<(std::ostream &o,const AntPlane &p);
+ private:
+  AGVector3 mDir;
+  float mOffset;
+};
+
+/// p0 is center - p1 is above and p2 at the right, then positive normal points into screen
+AntPlane makePlane(const AGVector3 &p0,const AGVector3 &p1,const AGVector3 &p2);
+
+class AntFrustum
+{
+ public:
+  AntFrustum(const std::vector<AntPlane> &pPlanes);
+
+  bool inside(const AGVector3 &v) const;
+  bool collides(const AGBox3 &v) const;
+
+  friend std::ostream &operator<<(std::ostream &o,const AntFrustum &p);
+ private:
+  std::vector<AntPlane> mPlanes;
+};
+
+std::ostream &operator<<(std::ostream &o,const AntPlane &p);
+std::ostream &operator<<(std::ostream &o,const AntFrustum &p);
+
+inline bool AntPlane::inside(const AGVector3 &v) const
+{
+  return v*mDir-mOffset>0;
+}
+
+#endif

Added: antargis/branches/rant/ext/sound/ag_mixer.cc
===================================================================
--- antargis/branches/rant/ext/sound/ag_mixer.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/sound/ag_mixer.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,455 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_sound.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_mixer.h"
+#include "ag_kill.h"
+#include "ag_debug.h"
+#include "ag_mutex.h"
+#include "ag_fs.h"
+#include "ag_config.h"
+#include "ag_main.h"
+
+#define USE_RWOPS
+
+#include <SDL_mixer.h>
+#include <map>
+#include <set>
+
+Mix_Music *mMusic=0;
+bool mMusicFinished=false;
+bool mMusicInited=false;
+
+bool mNoSound=false;
+
+const int cSoundChannels=16;
+
+std::map<std::string,Mix_Chunk*> mSounds;
+
+std::set<int> mFreeChannels;
+AGMutex *mSoundMutex;
+
+void musicFinished()
+{
+  mMusicFinished=true;
+}
+void channelDone(int channel)
+{
+  mSoundMutex->enter();
+  mFreeChannels.insert(channel);
+  mSoundMutex->leave();
+}
+int getFreeChannel()
+{
+  mSoundMutex->enter();
+  // FIXME: lock
+  int c=-1;
+  if(mFreeChannels.size())
+    {
+      c=*mFreeChannels.begin();
+      mFreeChannels.erase(c);
+    }
+  // FIXME: unlock
+  mSoundMutex->leave();
+  return c;
+}
+
+
+class AGPrivateSoundNotifier:public AGRepeatedCall
+{
+public:
+  void call()
+  {
+    getSoundManager()->checkFinished();
+  }
+};
+
+static AGPrivateSoundNotifier *privateSoundNotifier=0;
+
+
+void initSoundEngine()
+{
+  if(!mMusicInited)
+    {
+      TRACE;
+      mSoundMutex=new AGMutex;
+
+      size_t chunkSize=1024;
+      if(getConfig()->get("mixerChunkSize")=="2048")
+	chunkSize=2048;
+      if(getConfig()->get("mixerChunkSize")=="4096")
+	chunkSize=4096;
+      if(getConfig()->get("mixerChunkSize")=="8192")
+	chunkSize=8192;
+
+      cdebug("CHUNKSIZE:"<<chunkSize);
+
+      if(Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, chunkSize)==-1) {
+	printf("Mix_OpenAudio: %s\n", Mix_GetError());
+	mNoSound=true;
+	return;
+      }
+      mMusic=0;
+      
+      Mix_HookMusicFinished(musicFinished);
+
+      // enable mixing
+
+
+      Mix_AllocateChannels(cSoundChannels);
+      for(int i=0;i<cSoundChannels;i++)
+	mFreeChannels.insert(i);
+
+
+      Mix_ChannelFinished(channelDone);
+      mMusicInited=true;
+    }
+
+  if(!privateSoundNotifier)
+    {
+      privateSoundNotifier=new AGPrivateSoundNotifier;
+    }
+
+}
+
+void closeSoundEngine()
+{
+  if(mNoSound)
+    return;
+  if(mMusicInited)
+    {
+      if(mMusic)
+	{
+	  // free music
+	  Mix_FreeMusic(mMusic);
+	  mMusic=0;
+	}
+      //FIXME: readd this
+      Mix_CloseAudio();
+      delete mSoundMutex;
+    }
+}
+
+
+AGSound::~AGSound()
+{ 
+	if(getCollector())
+		getCollector()->removeGlobal(this);
+
+  closeSoundEngine();
+}
+
+bool AGSound::playMp3(const std::string &pFilename)
+{
+  if(mNoSound)
+    return false;
+  if(mMusic)
+    {
+      return false;
+    }
+  initSoundEngine();
+  // load the MP3 file "music.mp3" to play as music
+  mMusic=Mix_LoadMUS(pFilename.c_str());
+  if(!mMusic) {
+    printf("Mix_LoadMUS(\"%s\"): %s\n",pFilename.c_str(), Mix_GetError());
+    //    assertGL;
+    return false;
+  }
+    
+  // this might be a critical error...
+  
+  
+  
+  // play music forever
+  // Mix_Music *music; // I assume this has been loaded already
+  // -1 is forever
+  // 0 is never
+  // 1 is once
+  if(Mix_PlayMusic(mMusic, 1)==-1) {
+    printf("Mix_PlayMusic: %s\n", Mix_GetError());
+    //    assertGL;
+    // well, there's no music, but most games don't break without music...
+  }
+  
+  
+    
+  mMusicFinished=false;
+
+  // set hook
+
+  //  assertGL;
+    
+  return true;
+}
+
+bool AGSound::isMusicPlaying() const
+{
+  return mMusicFinished;
+}
+
+
+bool AGSound::playMp3DRM(const std::string &pFilename,AGDecryptor &pDec)
+{
+  //  assertGL;
+  if(mNoSound)
+    return false;
+  // must decrypt and write to disc :-(((
+  std::string file=loadFile(pFilename);
+
+  file=pDec.decrypt(file,pFilename);
+
+  /*  return playMp3(findFile("file.ogg"));
+  playWave(findFile("file.wav"),1);
+  return true;*/
+
+#ifndef OLDDEC
+  cdebug("ok decrypting");
+  if(!saveFile("drm.dat",file))
+    {
+      cdebug("error before playing!");
+      return false;
+    }
+  cdebug("playing");
+
+
+
+
+
+  return playMp3(findFile("drm.dat"));
+#else
+
+  SDL_RWops* rw=SDL_RWFromMem(const_cast<char*>(file.c_str()),file.length());
+
+
+  initSoundEngine();
+  // load the MP3 file "music.mp3" to play as music
+  mMusic=Mix_LoadMUS_RW(rw);
+  if(!mMusic) {
+    printf("Mix_LoadMUS_RW(\"%s\"): %s\n",pFilename.c_str(), Mix_GetError());
+    //    assertGL;
+    return false;
+  }
+    
+  //  assertGL;
+  // this might be a critical error...
+  
+  
+  
+  // play music forever
+  // Mix_Music *music; // I assume this has been loaded already
+  // -1 is forever
+  // 0 is never
+  // 1 is once
+  if(Mix_PlayMusic(mMusic, 1)==-1) {
+    printf("Mix_PlayMusic: %s\n", Mix_GetError());
+    // well, there's no music, but most games don't break without music...
+  }
+  
+  
+  //  assertGL;
+    
+  mMusicFinished=false;
+
+  // set hook
+    
+  return true;
+
+
+
+
+
+
+#endif
+}
+
+
+
+void AGSound::stopMp3()
+{
+  if(mNoSound)
+    return;
+  if(mMusic)
+    {
+      Mix_HaltMusic();
+      Mix_FreeMusic(mMusic);
+      mMusic=0;
+    }      
+}
+AGSound::AGSound():AGMessageObject(),sigMp3Finished(this,"sigMp3Finished")
+{
+	if(getCollector())
+		getCollector()->insertGlobal(this);
+	else
+		std::cerr<<"Possible Error:getCollector()==0!"<<std::endl;
+  REGISTER_SINGLETON(this);
+  soundVol=1.0f;
+
+  mNoSound=getConfig()->get("soundEnabled")=="false";
+  getConfig()->set("soundEnabled",mNoSound?"false":"true");
+}
+
+void AGSound::checkFinished()
+{
+  if(mNoSound)
+    return;
+  if(mMusicInited)
+    if(mMusicFinished)
+      {
+	Mix_FreeMusic(mMusic);
+	mMusic=0;
+	
+	
+	sigMp3Finished(new AGEvent(this,"musicFinished"));
+	mMusicFinished=false;
+      }
+}
+
+void AGSound::fadeOutMusic(int ms)
+{
+  if(mNoSound)
+    return;
+  assert(ms>0);
+  Mix_FadeOutMusic(ms);
+}
+
+void AGSound::volumeSound(int i,float v)
+{
+  int mv=((int)(v*MIX_MAX_VOLUME));
+  mv=std::min(std::max(0,mv),MIX_MAX_VOLUME);
+  if(i>=0 && i<cSoundChannels)
+    Mix_Volume(i,mv);
+}
+
+
+void AGSound::volumeSound(float v)
+{
+  if(mNoSound)
+    return;
+  initSoundEngine();
+  if(mNoSound)
+    return;
+  int mv=((int)(v*MIX_MAX_VOLUME));
+  mv=std::min(std::max(0,mv),MIX_MAX_VOLUME);
+  for(int i=0;i<cSoundChannels;++i)
+    Mix_Volume(i,mv);
+  soundVol=v;
+}
+void AGSound::volumeMusic(float v)
+{
+  if(mNoSound)
+    return;
+  initSoundEngine();
+  Mix_VolumeMusic(((int)(v*MIX_MAX_VOLUME)));
+}
+
+
+
+void AGSound::playWave(const std::string &pFilename,float volume)
+{
+  if(mNoSound)
+    return;
+  initSoundEngine();
+  if(volume<0)
+    volume=soundVol;
+  else
+    volume*=soundVol;
+  if(mFreeChannels.size()>0)
+    {
+      loadWave(pFilename);
+      int channel=getFreeChannel();
+      if(channel>=0)
+	{
+	  Mix_Chunk *c=mSounds[pFilename];
+	  Mix_Volume(channel,(int)(std::min(1.0f,volume)*MIX_MAX_VOLUME));
+	  Mix_PlayChannel(channel,c,0);
+	}
+    }
+
+}
+
+
+int AGSound::loopPlay(const std::string &pFilename,float volume)
+{
+  if(mNoSound)
+    return false;
+  initSoundEngine();
+  if(volume<0)
+    volume=soundVol;
+  if(mFreeChannels.size()>0)
+    {
+      loadWave(pFilename);
+      int channel=getFreeChannel();
+      if(channel>=0)
+	{
+	  Mix_Chunk *c=mSounds[pFilename];
+	  Mix_Volume(channel,(int)(std::min(1.0f,volume)*MIX_MAX_VOLUME));
+	  Mix_PlayChannel(channel,c,-1);
+	}
+      return channel;
+    }
+  return -1;
+}
+void AGSound::stopChannel(int i,int ms)
+{
+  if(mNoSound)
+    return;
+  if(i>=0 && i<cSoundChannels)
+    Mix_FadeOutChannel(i,ms);
+  channelDone(i);
+}
+
+void AGSound::stopAllChannels(int ms)
+{
+  if(mNoSound)
+    return;
+  for(int i=0;i<cSoundChannels;i++)
+    if(mFreeChannels.find(i)==mFreeChannels.end())
+      stopChannel(i,ms);
+}
+
+
+
+void AGSound::loadWave(const std::string &pFilename)
+{
+  if(mNoSound)
+    return;
+  std::map<std::string,Mix_Chunk*>::iterator i=mSounds.find(pFilename);
+  if(i!=mSounds.end())
+    return;
+  
+  Mix_Chunk *sample;
+  std::string file=loadFile(pFilename);
+  sample=Mix_LoadWAV_RW(SDL_RWFromMem(const_cast<char*>(file.c_str()),file.length()),1);
+
+  mSounds[pFilename]=sample;
+}
+
+
+
+AGSound *mSoundManager=0;
+AGSound *getSoundManager()
+{
+  if(!mSoundManager)
+    {
+      mSoundManager=new AGSound;
+    }
+  return mSoundManager;
+}
+
+

Added: antargis/branches/rant/ext/sound/ag_mixer.h
===================================================================
--- antargis/branches/rant/ext/sound/ag_mixer.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/sound/ag_mixer.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_sound.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef AG_SOUND_H
+#define AG_SOUND_H
+
+#include <string>
+#include <ag_widget.h>
+#include <ag_surface.h> // for decryptor
+
+// use widget, though this isn't one, because it provides useable functions
+class AGSound:public AGMessageObject
+// #Widget
+{
+ public:
+  AGSound(); // NEVER use this! - it's only provided due to swig
+  ~AGSound();
+  bool playMp3(const std::string &pFilename);
+  bool playMp3DRM(const std::string &pFilename,AGDecryptor &pDec);
+
+  bool isMusicPlaying() const;
+
+  void stopMp3();
+  void checkFinished();
+  void fadeOutMusic(int ms);
+
+  void playWave(const std::string &pFilename,float v=-1.0);
+  int loopPlay(const std::string &pFilename,float v=-1.0);
+  void stopChannel(int i,int ms=200);
+  void stopAllChannels(int ms=200);
+
+  void volumeSound(int i,float v); // 0 to 1
+  void volumeSound(float v); // 0 to 1
+  void volumeMusic(float v); // 0 to 1
+
+  void loadWave(const std::string &pFilename);
+
+
+  AGSignal sigMp3Finished;
+ private:
+
+  friend AGSound *getSoundManager();
+  float soundVol;
+
+};
+
+AGSound *getSoundManager();
+
+#endif
+

Added: antargis/branches/rant/ext/video/ag_clip.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_clip.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_clip.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,101 @@
+#include "ag_clip.h"
+#include "ag_projection.h"
+#include "ag_stringstream.h"
+#include <stdexcept>
+
+void AGClipping::exclude(const AGRect2 &r)
+{
+  mExclude.push_back(r);
+  //FIXME: check for intersections
+}
+ 
+void AGClipping::include(const AGRect2 &r)
+{
+  std::vector<AGRect2> n;
+  
+  for(std::vector<AGRect2>::iterator i=mExclude.begin();i!=mExclude.end();i++)
+    {
+      std::vector<AGRect2> t=(*i).difference(r);
+      std::copy(t.begin(),t.end(),std::back_inserter(n));
+    }
+  mExclude=n;
+}
+  
+std::vector<AGRect2> AGClipping::clip(const AGRect2&r)
+{
+  std::vector<AGRect2> t,n;
+
+  t.push_back(r);
+
+  for(std::vector<AGRect2>::iterator i=mExclude.begin();i!=mExclude.end();i++)
+    {
+      for(std::vector<AGRect2>::iterator j=t.begin();j!=t.end();j++)
+	{
+	  std::vector<AGRect2> t2=j->difference(*i);
+	  for(std::vector<AGRect2>::iterator k=t2.begin();k!=t2.end();k++)
+	    {
+	      if(k->w()>0 && k->h()>0)
+		n.push_back(*k);
+	    }
+	}
+      t=n;
+      n.clear();
+      
+    }
+
+  // FIXME: check for optimization
+
+  return t;
+  
+}
+
+bool AGClipping::included(const AGVector2 &v)
+{
+  for(std::vector<AGRect2>::iterator i=mExclude.begin();i!=mExclude.end();i++)
+    if(i->contains(v))
+      return false;
+  return true;
+}
+
+
+std::vector<std::pair<AGRect2,AGRect2> > AGClipping::clip(const AGRect2&r,const AGRect2 &sync)
+{
+  std::vector<std::pair<AGRect2,AGRect2> > n;
+
+  std::vector<AGRect2> t=clip(r);
+
+  AGProjection2D p(r,sync);
+  
+  for(std::vector<AGRect2>::iterator i=t.begin();i!=t.end();i++)
+    {
+      n.push_back(std::make_pair(*i,p.project(*i)));
+    }
+
+  return n;
+}
+
+AGString AGClipping::toString() const
+{
+  AGStringStream os;
+
+  os<<"[AGClipping:";
+  for(std::vector<AGRect2>::const_iterator i=mExclude.begin();i!=mExclude.end();i++)
+    os<<i->toString()<<";";
+  os<<"]";
+
+  return os.str();
+}
+
+std::vector<AGLine2> AGClipping::clip(const AGLine2 &p)
+{
+  #warning "implement me"
+  std::vector<AGLine2> l;
+  l.push_back(p);
+  return l;
+}
+
+bool AGClipping::valid() const
+{
+  #warning "IMPLEMENT ME"
+  return true;
+}

Added: antargis/branches/rant/ext/video/ag_clip.h
===================================================================
--- antargis/branches/rant/ext/video/ag_clip.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_clip.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,33 @@
+#ifndef AG_CLIP_H
+#define AG_CLIP_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include <ag_geometry.h>
+
+class AGClipping
+{
+ public:
+  void include(const AGRect2 &r);
+  void exclude(const AGRect2 &r);
+  
+  std::vector<AGRect2> clip(const AGRect2&r);
+  std::vector<std::pair<AGRect2,AGRect2> > clip(const AGRect2&r,const AGRect2 &sync);
+
+  std::vector<AGLine2> clip(const AGLine2 &p);
+
+  bool included(const AGVector2 &v);
+
+  bool valid() const;
+
+  AGString toString() const;
+
+ private:
+
+  void optimize();
+
+  //  std::vector<AGRect2> mInclude;
+  std::vector<AGRect2> mExclude;
+};
+
+#endif

Added: antargis/branches/rant/ext/video/ag_clip_painttarget.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_clip_painttarget.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_clip_painttarget.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,197 @@
+#include "ag_clip_painttarget.h"
+#include "ag_debug.h"
+#include "ag_projection.h"
+
+AGClipPaintTarget::AGClipPaintTarget(AGPaintTarget *pTarget):mTarget(pTarget)
+{
+}
+
+void AGClipPaintTarget::blitTri(const AGTexture &pSource,const AGTriangle2 &pSrc,const AGTriangle2 &pDest)
+{
+  cdebug("NOT IMPLEMENTED!");
+}
+
+void AGClipPaintTarget::blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc,const AGColor &pColor)
+{
+  std::vector<std::pair<AGRect2,AGRect2> > l=mClipping.clip(pDest,pSrc);
+  for(std::vector<std::pair<AGRect2,AGRect2> >::iterator i=l.begin();i!=l.end();i++)
+    {
+      mTarget->blit(pSource,i->first,i->second,pColor);
+    }
+}
+
+void AGClipPaintTarget::blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc)
+{
+  std::vector<std::pair<AGRect2,AGRect2> > l=mClipping.clip(pDest,pSrc);
+  for(std::vector<std::pair<AGRect2,AGRect2> >::iterator i=l.begin();i!=l.end();i++)
+    {
+      mTarget->blit(pSource,i->first,i->second);
+    }
+}
+
+void AGClipPaintTarget::blit(const AGSurface &pSource,const AGRect2 &pDest,const AGRect2 &pSrc)
+{
+  std::vector<std::pair<AGRect2,AGRect2> > l=mClipping.clip(pDest,pSrc);
+  for(std::vector<std::pair<AGRect2,AGRect2> >::iterator i=l.begin();i!=l.end();i++)
+    {
+      mTarget->blit(pSource,i->first,i->second);
+    }
+}
+
+void AGClipPaintTarget::drawLine(const AGVector2 &p0,const AGVector2 &p1,const AGColor &c)
+{
+  std::vector<AGLine2> l=mClipping.clip(AGLine2(p0,p1));
+  for(std::vector<AGLine2>::iterator i=l.begin();i!=l.end();i++)
+    mTarget->drawLine(i->getV0(),i->getV1(),c);
+}
+
+void AGClipPaintTarget::fillRect(const AGRect2 &pr,const AGColor &c)
+{
+  std::vector<AGRect2> l=mClipping.clip(pr);
+  for(std::vector<AGRect2>::iterator i=l.begin();i!=l.end();i++)
+    mTarget->fillRect(*i,c);
+}
+
+void AGClipPaintTarget::fillRects(const std::vector<std::pair<AGRect2,AGVector4> > &pr)
+{
+  std::vector<std::pair<AGRect2,AGVector4> > l;
+
+  // collect clippings
+  for(std::vector<std::pair<AGRect2,AGVector4> >::const_iterator i=pr.begin();i!=pr.end();i++)
+    {
+      std::vector<AGRect2> l2=mClipping.clip(i->first);
+      for(std::vector<AGRect2>::iterator i2=l2.begin();i2!=l2.end();i2++)
+	l.push_back(std::make_pair(*i2,i->second));
+    }
+  mTarget->fillRects(l);
+}
+   
+void AGClipPaintTarget::blit(const AGTexture &pSource,const std::vector<std::pair<AGRect2,AGRect2> > &pSrcDestRects,const AGColor &pColor)
+{
+  std::vector<std::pair<AGRect2,AGRect2> > l;
+
+  // collect clippings
+  for(std::vector<std::pair<AGRect2,AGRect2> >::const_iterator i=pSrcDestRects.begin();i!=pSrcDestRects.end();i++)
+    {
+      std::vector<std::pair<AGRect2,AGRect2> > l2=mClipping.clip(i->first,i->second);
+      std::copy(l2.begin(),l2.end(),std::back_inserter(l));
+    }
+  mTarget->blit(pSource,l,pColor);
+}
+
+void AGClipPaintTarget::tile(const AGTexture &pSource,const AGRect2 &pTarget, const AGColor &pColor)
+{
+  //std::vector<std::pair<AGRect2,AGRect2> > l2=mClipping.clip(i->first);
+  
+  cdebug("WARNING: AGClipPaintTarget::tile not implemented yet!");
+}
+   
+void AGClipPaintTarget::putPixel(int x,int y,const AGColor &c)
+{
+  if(mClipping.included(AGVector2(x,y)))
+    mTarget->putPixel(x,y,c);
+}
+
+AGColor AGClipPaintTarget::getPixel(int x,int y) const
+{
+  return mTarget->getPixel(x,y);
+}
+
+  // manage painting sessions
+void AGClipPaintTarget::clip(const AGClipping &c)
+{
+  mClipping=c;
+}
+
+void AGClipPaintTarget::unclip()
+{
+  mClipping=AGClipping();
+}
+
+AGRect2 AGClipPaintTarget::getRect() const
+{
+  return mTarget->getRect();
+}
+
+void AGClipPaintTarget::drawGradientAlpha(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr)
+{
+  CTRACE;
+  std::vector<AGRect2> rs=mClipping.clip(rect);
+
+  AGRect2 t(0,0,1,1);
+  AGProjection2D p(rect,t);
+
+  for(std::vector<AGRect2>::iterator i=rs.begin();i!=rs.end();i++)
+    {
+      AGRect2 r2=p.project(*i);
+      float x,y;
+      AGColor ul2,ur2,dl2,dr2;
+      
+      x=r2.x0();y=r2.y0();
+      ul2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x1();y=r2.y0();
+      ur2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x0();y=r2.y1();
+      dl2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x1();y=r2.y1();
+      dr2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      mTarget->drawGradientAlpha(*i,ul2,ur2,dl2,dr2);
+			    
+    }
+}
+
+void AGClipPaintTarget::drawGradient(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr)
+{
+  std::vector<AGRect2> rs=mClipping.clip(rect);
+
+  AGRect2 t(0,0,1,1);
+  AGProjection2D p(rect,t);
+
+  for(std::vector<AGRect2>::iterator i=rs.begin();i!=rs.end();i++)
+    {
+      AGRect2 r2=p.project(*i);
+      float x,y;
+      AGColor ul2,ur2,dl2,dr2;
+
+      cdebug("rect:"<<rect);
+      cdebug("r2:"<<r2);
+      cdebug("i:"<<*i);
+      
+      x=r2.x0();y=r2.y0();
+      ul2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x1();y=r2.y0();
+      ur2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x0();y=r2.y1();
+      dl2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      x=r2.x1();y=r2.y1();
+      dr2=(ul*(1-x)+ur*x)*(1-y)+
+	(dl*(1-x)+dr*x)*y;
+
+      cdebug("ul:"<<ul);
+      cdebug("ur:"<<ur);
+      cdebug("dl:"<<dl);
+      cdebug("dr:"<<dr);
+
+      cdebug("ul2:"<<ul2);
+      cdebug("ur2:"<<ur2);
+      cdebug("dl2:"<<dl2);
+      cdebug("dr2:"<<dr2);
+
+      mTarget->drawGradient(*i,ul2,ur2,dl2,dr2);
+			    
+    }
+}

Added: antargis/branches/rant/ext/video/ag_clip_painttarget.h
===================================================================
--- antargis/branches/rant/ext/video/ag_clip_painttarget.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_clip_painttarget.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_painttarget.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef __AG_CLIP_PAINTTARGET_H
+#define __AG_CLIP_PAINTTARGET_H
+
+#include <ag_painttarget.h>
+#include <ag_clip.h>
+
+/// virtual paint target - use this for advanced clipping !
+class AGClipPaintTarget:public AGPaintTarget
+{
+ public:
+  AGClipPaintTarget(AGPaintTarget *pTarget);
+
+  virtual void blitTri(const AGTexture &pSource,const AGTriangle2 &pSrc,const AGTriangle2 &pDest);
+
+  virtual void blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc,const AGColor &pColor);
+  virtual void blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc);
+  virtual void blit(const AGSurface &pSource,const AGRect2 &pDest,const AGRect2 &pSrc);
+
+  virtual void drawLine(const AGVector2 &p0,const AGVector2 &p1,const AGColor &c);
+  virtual void fillRect(const AGRect2 &pr,const AGColor &c);
+
+  virtual void fillRects(const std::vector<std::pair<AGRect2,AGVector4> > &pr);
+   
+  virtual void blit(const AGTexture &pSource,const std::vector<std::pair<AGRect2,AGRect2> > &pSrcDestRects,const AGColor &pColor);
+
+  virtual void tile(const AGTexture &pSource,const AGRect2 &pTarget, const AGColor &pColor);
+
+  virtual void drawGradientAlpha(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr);
+  virtual void drawGradient(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr);
+   
+  virtual AGRect2 getRect() const;
+
+  virtual void putPixel(int x,int y,const AGColor &c);
+  virtual AGColor getPixel(int x,int y) const;
+
+  // manage painting sessions
+  virtual void clip(const AGClipping &c);
+
+  virtual void unclip();
+
+ private:
+  AGPaintTarget *mTarget;
+  AGClipping mClipping;
+};
+
+
+#endif
+

Added: antargis/branches/rant/ext/video/ag_painter.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_painter.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_painter.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,614 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_painter.cc
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include <ag_debug.h>
+#include <ag_draw.h>
+#include <ag_fontengine.h>
+#include <ag_glscreen.h>
+#include <ag_painter.h>
+#include <ag_profiler.h>
+#include <ag_sdlsurface.h>
+#include <ag_texture.h>
+#include <math.h>
+
+#include <stdexcept>
+
+//#define SPEED_TEST
+
+/////////////////////////////////////////////////////////////////////////////////
+// AGProjection
+/////////////////////////////////////////////////////////////////////////////////
+
+
+AGProjection::AGProjection(const AGRect2 &pClip):clip(pClip)
+{
+  a.set(0,0,1);
+  a.set(0,1,0);
+  a.set(0,2,0);
+  a.set(1,0,0);
+  a.set(1,1,1);
+  a.set(1,2,0);
+  a.set(2,0,0);
+  a.set(2,1,0);
+  a.set(2,2,0);
+}
+
+AGProjection::AGProjection(const AGClipping &pClip):advancedClipping(pClip)
+{
+  a.set(0,0,1);
+  a.set(0,1,0);
+  a.set(0,2,0);
+  a.set(1,0,0);
+  a.set(1,1,1);
+  a.set(1,2,0);
+  a.set(2,0,0);
+  a.set(2,1,0);
+  a.set(2,2,0);
+}
+
+
+AGVector2 AGProjection::project(const AGVector2 &p) const
+{
+  AGVector2 r=(a*AGVector3(p[0],p[1],1)).dim2();
+
+  return r;
+}
+bool AGProjection::pointOk(const AGVector2 &p) const
+{
+  return clip.contains(p);
+}
+
+AGRect2 AGProjection::project(const AGRect2 &p) const
+{
+  AGRect2 r((a*AGVector3(p[0],1)).dim2(),
+	    (a*AGVector3(p[1],1)).dim2());
+  return r;
+}
+AGRect2 AGProjection::clipRect(AGRect2 target) const
+{
+  return clip.intersect(target);
+}
+
+
+std::pair<AGRect2,AGRect2> AGProjection::clipRect(AGRect2 target,AGRect2 src) const
+{
+  AGRect2 i=clip.intersect(target);
+  if(i.width()<=0 || i.height()<=0)
+    return std::make_pair(AGRect2(0,0,0,0),AGRect2(0,0,0,0));
+
+  assert(target.x0()<clip.x1());
+
+
+ // clip left
+  if(target.x0()<clip.x0())
+    {
+      float a=(clip.x0()-target.x0())/target.w();
+      float nw=target.x1()-clip.x0();
+      target.setLeft(clip.x0());
+      target.setWidth(nw);
+      nw=src.w()*(1.0f-a);
+      src.setLeft(src.x0()+src.w()*a);
+      src.setWidth(nw);
+    }
+
+  // clip top
+  if(target.y0()<clip.y0())
+    {
+      float a=(clip.y0()-target.y0())/target.h();
+      float nh=target.y1()-clip.y0();
+      target.setTop(clip.y0());
+      target.setHeight(nh);
+      nh=src.h()*(1.0f-a);
+      src.setTop(src.y0()+src.h()*a);
+      src.setHeight(nh);
+    }
+
+  // clip right
+  if(target.x1()>clip.x1())
+    {
+      float a=(target.x1()-clip.x1())/target.w();
+      target.setRight(clip.x1());
+      src.setRight(src.x1()-src.w()*a);
+    }
+
+  // clip bottom
+  if(target.y1()>clip.y1())
+    {
+      float a=(target.y1()-clip.y1())/target.h();
+      target.setBottom(clip.y1());
+      src.setBottom(src.y1()-src.h()*a);
+    }
+
+  return std::make_pair(target,src);
+}
+
+void AGProjection::translate(const AGVector2 &v)
+{
+  a.get(2,0)+=v[0];
+  a.get(2,1)+=v[1];
+}
+
+void AGProjection::setClip(const AGRect2&p)
+{
+  clip=clip.intersect(p);
+}
+
+
+AGRect2 AGProjection::getRect() const
+{
+  AGRect2 r=clip;
+
+  r-=AGVector2(a.get(2,0),a.get(2,1));
+  return r;
+}
+
+AGLine2 AGProjection::clipLine(AGLine2 l) const
+{
+  AGLine2 d;
+
+  AGRect2 r=clip;
+
+  if((l[0][0]<r.x0() && l[1][0]<r.x0()) ||
+     (l[0][0]>r.x1() && l[1][0]>r.x1()) ||
+     (l[0][1]<r.y0() && l[1][1]<r.y0()) ||
+     (l[0][1]>r.y1() && l[1][1]>r.y1()))
+    return d; // hidden
+
+  float a;
+  // clip
+  for(size_t i=0;i<1;i++)
+    {
+      if(l[i][0]<r.x0())
+	{
+	  a=(r.x0()-l[i][0])/(l[1-i][0]-l[i][0]);
+	  l[i][0]=r.x0();
+	  l[i][1]=l[i][1]+(l[1-i][1]-l[i][1])*a;
+	}
+      if(l[i][1]<r.y0())
+	{
+	  a=(r.y0()-l[i][1])/(l[1-i][1]-l[i][1]);
+	  l[i][1]=r.y0();
+	  l[i][0]=l[i][0]+(l[1-i][0]-l[i][0])*a;
+	}
+      if(l[i][0]>r.x1())
+	{
+	  a=(l[i][0]-r.x1())/(l[i][0]-l[1-i][0]);
+	  l[i][0]=r.x1();
+	  l[i][1]=l[i][1]+(l[1-i][1]-l[i][1])*a;
+	}
+      if(l[i][1]>r.y1())
+	{
+	  a=(l[i][1]-r.y1())/(l[i][1]-l[1-i][1]);
+	  l[i][1]=r.y1();
+	  l[i][0]=l[i][0]+(l[1-i][0]-l[i][0])*a;
+	}
+
+    }
+  return l;
+    
+}
+
+
+
+/////////////////////////////////////////////////////////////////////////////////
+// AGPainter
+/////////////////////////////////////////////////////////////////////////////////
+
+AGPainter::AGPainter():mCurrent(getScreen().getRect()),mTarget(&getScreen())
+{
+  mTarget->beginPaint();
+}
+
+AGPainter::AGPainter(const AGPainter &p):ps(p.ps),mCurrent(p.mCurrent),mTarget(p.mTarget)
+{
+  mTarget->beginPaint();
+}
+
+AGPainter::AGPainter(AGPaintTarget &pTarget):mCurrent(pTarget.getRect()),mTarget(&pTarget)
+{
+  mTarget->beginPaint();
+}
+
+
+AGPainter::~AGPainter()
+{
+  if(mTarget.valid())
+    {
+      mTarget->unclip();
+      mTarget->endPaint();
+    }
+}
+
+void AGPainter::putPixel(const AGVector2 &p,const AGColor &c)
+{
+  AGVector2 n=project(p);
+  if(pointOk(n))
+    {
+      mTarget->putPixel((int)n[0],(int)n[1],c);
+    }
+}
+
+void AGPainter::blit(const AGTexture &pSource,const AGRect2 &pDest)
+{
+  AGRect2 s=pSource.getRect();
+  // ASSUME: we don't want to scale
+  blit(pSource,AGRect2(pDest.x(),pDest.y(),s.w(),s.h()),s);
+}
+
+AGVector2 AGPainter::project(const AGVector2 &p) const
+{
+  return mCurrent.project(p);
+}
+bool AGPainter::pointOk(const AGVector2 &p) const
+{
+  return mCurrent.pointOk(p);
+}
+
+
+void AGPainter::blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc)
+{
+  STACKTRACE;
+  AGRect2 d;
+  d=mCurrent.project(pDest);
+
+#ifdef OLDCLIP
+
+  std::pair<AGRect2,AGRect2> p=mCurrent.clipRect(d,pSrc);
+
+  //  cdebug(p.first<<"   "<<p.second);
+  if(p.first.w()>0 && p.first.h()>0 && p.second.w()>0 && p.second.h()>0)
+    mTarget->blit(pSource,p.first,p.second);
+
+
+#else
+  #warning "add clipping!"
+
+  mTarget->blit(pSource,d,pSrc);//pSource.getRect());
+#endif
+}
+
+void AGPainter::blit(const AGTexture &pSource,const AGRect2 &pDest,const AGColor &pColor)
+{
+  AGRect2 s=pSource.getRect();
+  // ASSUME: we don't want to scale
+  blit(pSource,AGRect2(pDest.x(),pDest.y(),s.w(),s.h()),s,pColor);
+}
+
+void AGPainter::blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc,const AGColor &pColor)
+{
+  STACKTRACE;
+#ifdef SPEED_TEST
+  mTarget->blit(pSource,pDest,pSrc,pColor);
+  return;
+#endif
+
+  AGRect2 d;
+  d=mCurrent.project(pDest);
+  std::pair<AGRect2,AGRect2> p=mCurrent.clipRect(d,pSrc);
+
+  if(p.first.w()>0 && p.first.h()>0 && p.second.w()>0 && p.second.h()>0)
+    mTarget->blit(pSource,p.first,p.second,pColor);
+}
+
+
+void AGPainter::tile(const AGTexture &pSource)
+{
+  tile(pSource,mTarget->getRect());
+}
+void AGPainter::tile(const AGTexture &pSource,const AGRect2 &pDest)
+{
+  tile(pSource,pDest,pSource.getRect());
+}
+void AGPainter::tile(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc)
+{
+  STACKTRACE;
+  float x,y;
+  if(!dynamic_cast<AGGLScreen*>(mTarget.getPtr()))
+    {
+      #warning "remove this and implement in agtexture*"
+      for(y=pDest.y0();y<pDest.y1();y+=pSrc.h())
+	for(x=pDest.x0();x<pDest.x1();x+=pSrc.w())
+	  {
+	    float w=std::min(pSrc.w(),pDest.x1()-x);
+	    float h=std::min(pSrc.h(),pDest.y1()-y);
+	    blit(pSource,AGRect2(x,y,w,h),AGRect2(pSrc.x0(),pSrc.y0(),w,h));
+	  }
+      
+    }
+  else
+    {
+      mTarget->tile(pSource,mCurrent.project(pDest),AGColor(0xff,0xff,0xff,0xff));
+    }
+
+
+}
+
+
+// AGSurface-painting
+void AGPainter::blit(const AGSurface &pSource,const AGRect2 &pDest)
+{
+  AGRect2 s=pSource.getRect();
+  // ASSUME: we don't want to scale
+  blit(pSource,AGRect2(pDest.x(),pDest.y(),s.w(),s.h()),s);
+}
+void AGPainter::blit(const AGSurface &pSource,const AGRect2 &pDest,const AGRect2 &pSrc)
+{
+  STACKTRACE;
+  AGRect2 d;
+  d=mCurrent.project(pDest);
+  std::pair<AGRect2,AGRect2> p=mCurrent.clipRect(d,pSrc);
+
+  if(p.first.w()>0 && p.first.h()>0 && p.second.w()>0 && p.second.h()>0)
+    mTarget->blit(pSource,p.first,p.second);
+}
+void AGPainter::tile(const AGSurface &pSource)
+{
+  tile(pSource,mTarget->getRect());
+}
+void AGPainter::tile(const AGSurface &pSource,const AGRect2 &pDest)
+{
+  tile(pSource,pDest,pSource.getRect());
+
+}
+void AGPainter::tile(const AGSurface &pSource,const AGRect2 &pDest,const AGRect2 &pSrc)
+{
+  STACKTRACE;
+  float x,y;
+
+  std::vector<std::pair<AGRect2,AGRect2> > rects;
+  for(y=pDest.y0();y<pDest.y1();y+=pSrc.h())
+    for(x=pDest.x0();x<pDest.x1();x+=pSrc.w())
+      {
+	float w=std::min(pSrc.w(),pDest.x1()-x);
+	float h=std::min(pSrc.h(),pDest.y1()-y);
+	
+	rects.push_back(std::make_pair(AGRect2(pSrc.x0(),pSrc.y0(),w,h),AGRect2(x,y,w,h)));
+      }
+  mTarget->blit(pSource,rects,AGColor(0xff,0xff,0xff,0xff));
+}
+
+AGColor calcColor(AGVector2 p,const AGColor &pc0,const AGColor &pc1,const AGColor &pc2,const AGColor &pc3)
+{
+  return (pc0*(1-p[0]) + pc1*p[0])*(1-p[1]) + (pc2*(1-p[0]) + pc3*p[0])*p[1];
+}
+  
+void AGPainter::drawGradient(const AGRect2 &pr,const AGColor &pc0,const AGColor &pc1,const AGColor &pc2,const AGColor &pc3)
+{
+  STACKTRACE;
+  AGGLScreen *glScreen=dynamic_cast<AGGLScreen*>(mTarget.getPtr());
+  
+  AGRect2 src(0,0,1,1);
+
+  AGRect2 d=mCurrent.project(pr);
+  std::pair<AGRect2,AGRect2> p=mCurrent.clipRect(d,src);
+
+  AGColor c0=calcColor(p.second.getV0(),pc0,pc1,pc2,pc3);
+  AGColor c1=calcColor(p.second.getV10(),pc0,pc1,pc2,pc3);
+  AGColor c2=calcColor(p.second.getV01(),pc0,pc1,pc2,pc3);
+  AGColor c3=calcColor(p.second.getV1(),pc0,pc1,pc2,pc3);
+
+  AGRect2 r=p.first;
+
+  if(p.first.w()>0 && p.first.h()>0 && p.second.w()>0 && p.second.h()>0)
+    {
+      mTarget->drawGradient(r,c0,c1,c2,c3);
+      /*
+      if(glScreen)
+	{
+	  glScreen->drawGradient(r,c0,c1,c2,c3);
+	}
+      else if(opengl() && dynamic_cast<AGTexture*>(mTarget.getPtr()))
+	{
+	  dynamic_cast<AGTexture*>(mTarget.getPtr())->drawGradient(r,c0,c1,c2,c3);
+	}
+      else
+	{
+	  AGSDLScreen *sdlScreen=dynamic_cast<AGSDLScreen*>(mTarget.getPtr());
+	    
+	  if(sdlScreen)
+	    {
+	      sdlScreen->drawGradient(d,pc0,pc1,pc2,pc3);
+	      //	      sdlScreen->drawGradient(r,c0,c1,c2,c3);
+	    }
+	  else
+	    {
+	      float cx,cy,y,x;
+	      float dx=1.0/r.w();
+	      float dy=1.0/r.h();
+	      for(cy=0,y=r.y0();y<r.y1();y+=1,cy+=dy)
+		for(cx=0,x=r.x0();x<r.x1();x+=1,cx+=dx)
+		  putPixel(AGVector2(x,y),(c0*(1-cx)+c1*cx)*(1-cy)+(c2*(1-cx)+c3*cx)*cy);
+	    }
+
+	    }*/
+    }
+}
+void AGPainter::renderText(const AGStringUtf8 &pText,const AGVector2 &p,const AGFont &f)
+{
+  STACKTRACE;
+  AGTexture *t=getFontEngine()->renderText(0,0,pText,f);
+  if(t)
+    blit(*t,AGRect2(p[0],p[1],t->getSurfaceWidth(),t->getSurfaceHeight()));
+
+}
+void AGPainter::drawBorder(const AGRect2& pRect,int width, const AGColor& c1, const AGColor& c2)
+{
+  STACKTRACE;
+  AGGLScreen *glScreen=dynamic_cast<AGGLScreen*>(mTarget.getPtr());
+  if(glScreen)
+    {
+      #warning "add clipping in gl"
+      glScreen->clip(mCurrent.clip);
+      glScreen->drawBorder(mCurrent.project(pRect),width,c1,c2);
+      //      glScreen->fillRect(AGRect2(0,0,1024,768),c1);
+      glScreen->unclip();
+      return;
+    }
+  // FIXME: 
+  // 1) maybe improve gl-renderer by using triangles
+  // 2) otherwise use line-drawing (which is clipped and transformed itself
+  // 3) transform is done for each line - maybe is slow
+  AGRect2 d=pRect;
+
+  for(int t=0;t<width;t++)
+    {
+      drawLine(d.getV0(),d.getV01(),c1);
+      drawLine(d.getV0(),d.getV10(),c1);
+
+      drawLine(d.getV01(),d.getV1(),c2);
+      drawLine(d.getV10(),d.getV1(),c2);
+      d=d.shrink(1);
+    }
+}
+
+void AGPainter::fillRect(const AGRect2 &pDest,const AGColor &c)
+{
+  STACKTRACE;
+  AGRect2 d,pSrc;
+  d=mCurrent.project(pDest);
+  // FIXME: remove clipRect !!
+  AGRect2 p=mCurrent.clipRect(d);
+  if(p.w()>0 && p.h()>0)
+    {
+      //      cdebug(p);
+      mTarget->fillRect(p,c);
+    }
+}
+
+void AGPainter::fillRects(const std::vector<std::pair<AGRect2,AGVector4> > &pRects)
+{
+  STACKTRACE;
+  std::vector<std::pair<AGRect2,AGVector4> > rs;
+
+  for(std::vector<std::pair<AGRect2,AGVector4> >::const_iterator i=pRects.begin();i!=pRects.end();++i)
+    {
+      AGRect2 d=mCurrent.project(i->first);
+      if(!opengl())
+	d=mCurrent.clipRect(d);
+      if(d.w()>0 && d.h()>0)
+	rs.push_back(std::make_pair(d,i->second));
+    }
+
+  if(rs.size())
+    mTarget->fillRects(rs);
+}
+
+
+void AGPainter::drawPoint(const AGVector2 &p,const AGColor &c,float size)
+{
+  STACKTRACE;
+  AGVector2 d=mCurrent.project(p);
+  if(mCurrent.pointOk(p))
+    {
+      mTarget->putPixel((int)d[0],(int)d[1],c);
+    }
+}
+
+
+AGColor AGPainter::getPixel(int x,int y)
+{
+  AGVector2 p=mCurrent.project(AGVector2(x,y));
+  if(!mCurrent.pointOk(p))
+    throw std::string("pixel out of clipping!");
+  return mTarget->getPixel((int)p[0],(int)p[1]);
+}
+
+void AGPainter::drawLine(const AGVector2 &p0,const AGVector2 &p1,const AGColor &c)
+{
+  #warning "Add line clipping"
+  AGVector2 m0=mCurrent.project(p0);
+  AGVector2 m1=mCurrent.project(p1);
+  mTarget->drawLine(m0,m1,c);
+}
+
+void AGPainter::blitTri(const AGTexture &pSource,const AGTriangle2 &pSrc,const AGTriangle2 &pDest)
+{
+  mTarget->blitTri(pSource,pSrc,pDest);
+}
+
+void AGPainter::drawCircle(const AGVector2 &p,float rad,const AGColor &color)
+{
+  // clipping done in putPixel
+
+  int x,y;
+  float r2=rad*rad;
+  for(x=((int)(p[0]-rad-1));x<=p[0]+rad+1;x++)
+    for(y=((int)(p[1]-rad-1));y<=p[1]+rad+1;y++)
+      {
+	float dx=x-p[0];
+	float dy=y-p[1];
+	float d2=dx*dx+dy*dy;
+
+	if(d2<r2)
+	  {
+	    AGVector2 c(x,y);
+	    putPixel(c,color);
+	  }
+      }
+}
+
+void AGPainter::pushMatrix()
+{
+  ps.push_back(mCurrent);
+}
+void AGPainter::popMatrix()
+{
+  mCurrent=ps.back();
+  ps.pop_back();
+  mTarget->clip(mCurrent.clip);
+}
+void AGPainter::translate(const AGVector2 &v)
+{
+  mCurrent.translate(v);
+}
+void AGPainter::scale(const AGVector2 &v)
+{
+  throw std::string("not implemented!");
+}
+void AGPainter::clip(const AGRect2 &r)
+{
+  AGRect2 p=mCurrent.project(r);
+  mCurrent.setClip(p);
+  mTarget->clip(mCurrent.clip);
+}
+
+void AGPainter::transform(const AGRect2 &r)
+{
+  translate(r[0]);
+  clip(r.origin());
+}
+
+AGRect2 AGPainter::getRect() const
+{
+  return mCurrent.getRect();
+}
+
+void AGPainter::clip(const AGClipping &clip)
+{
+	CTRACE;
+	throw std::runtime_error("NOT IMPLEMENTED !");
+}
+
+
+AGPaintTarget *AGPainter::getTarget()
+{
+  return mTarget.getPtr();
+}
+

Added: antargis/branches/rant/ext/video/ag_painter.h
===================================================================
--- antargis/branches/rant/ext/video/ag_painter.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_painter.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_painter.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#ifndef __AG_PAINTER_H
+#define __AG_PAINTER_H
+
+#include <ag_color.h>
+#include <ag_surface.h>
+#include <ag_geometry.h>
+#include <ag_font.h>
+#include <ag_painttarget.h>
+#include <ag_clip.h>
+#include <ag_base.h>
+
+
+#include <list>
+
+class AGTriangle2;
+class AGRect2;
+
+struct AGProjection
+{
+  AGMatrix3 a;
+  AGRect2 clip;
+  AGClipping advancedClipping;
+
+  AGProjection(const AGRect2 &pClip);
+  AGProjection(const AGClipping &pClip);
+
+  AGVector2 project(const AGVector2 &p) const;
+  bool pointOk(const AGVector2 &p) const;
+
+  AGRect2 project(const AGRect2 &p) const;
+
+  std::pair<AGRect2,AGRect2> clipRect(AGRect2 target,AGRect2 src) const;
+  AGRect2 clipRect(AGRect2 target) const;
+
+
+  AGLine2 clipLine(AGLine2 l) const;
+
+  void translate(const AGVector2 &v);
+  void setClip(const AGRect2&p);
+
+  AGRect2 getRect() const;
+};
+
+#ifdef SWIG
+#undef AGEXPORT
+#define AGEXPORT
+#endif
+
+class AGEXPORT AGPainter
+{
+ public:
+  AGPainter();
+  AGPainter(const AGPainter &p);
+  AGPainter(AGPaintTarget &pTarget);
+  
+  ~AGPainter();
+
+  void putPixel(const AGVector2 &p,const AGColor &c);
+  AGColor getPixel(int x,int y);
+
+  void drawCircle(const AGVector2 &p,float rad,const AGColor &c);
+
+  void blitTri(const AGTexture &pSource,const AGTriangle2 &pSrc,const AGTriangle2 &pDest);
+
+  void blit(const AGTexture &pSource,const AGRect2 &pDest);
+  void blit(const AGTexture &pSource,const AGRect2 &pDest,const AGColor &pColor);
+  void blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc);
+  void blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc,const AGColor &pColor);
+  void tile(const AGTexture &pSource);
+  void tile(const AGTexture &pSource,const AGRect2 &pDest);
+  void tile(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc);
+
+  void blit(const AGSurface &pSource,const AGRect2 &pDest);
+  void blit(const AGSurface &pSource,const AGRect2 &pDest,const AGRect2 &pSrc);
+  void tile(const AGSurface &pSource);
+  void tile(const AGSurface &pSource,const AGRect2 &pDest);
+  void tile(const AGSurface &pSource,const AGRect2 &pDest,const AGRect2 &pSrc);
+  
+  void renderText(const AGStringUtf8 &pText,const AGVector2 &p,const AGFont &f);
+
+  AGRect2 getRect() const;
+
+  void drawGradient(const AGRect2 &r,const AGColor &c0,const AGColor &c1,const AGColor &c2,const AGColor &c3);
+  void drawBorder(const AGRect2& rect,int width, const AGColor& c1, const AGColor& c2);
+  void fillRect(const AGRect2 &pRect,const AGColor &c);
+  void drawLine(const AGVector2 &p0,const AGVector2 &p1,const AGColor &c);
+  void drawPoint(const AGVector2 &p,const AGColor &c,float size);
+
+  void fillRects(const std::vector<std::pair<AGRect2,AGVector4> > &pRects);
+
+  void pushMatrix();
+  void popMatrix();
+  void translate(const AGVector2 &v);
+  void scale(const AGVector2 &v);
+  void clip(const AGRect2 &r);
+
+  void clip(const AGClipping &clip);
+
+  void transform(const AGRect2 &r);
+
+  AGVector2 project(const AGVector2 &p) const;
+  bool pointOk(const AGVector2 &p) const;
+
+  AGPaintTarget *getTarget();
+
+ private:
+  std::list<AGProjection> ps;
+
+  AGProjection mCurrent;
+
+  gc_ptr<AGPaintTarget> mTarget;
+};
+
+#endif

Added: antargis/branches/rant/ext/video/ag_projection.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_projection.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_projection.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,38 @@
+#include "ag_projection.h"
+#include "ag_debug.h"
+
+
+AGProjection2D::AGProjection2D(const AGRect2 &from, const AGRect2 &to)
+{
+  assert(from.content()>0 && to.content()>0);
+
+  float sx=to.w()/from.w();
+  float sy=to.h()/from.h();
+  AGMatrix3 m1(-from.getV0());
+  AGMatrix3 m2(sx,sy);
+  AGMatrix3 m3(to.getV0());
+
+  m=m3*m2*m1;
+  /*  cdebug("m1:"<<m1.toString());
+  cdebug("m2:"<<m2.toString());
+  cdebug("m3:"<<m3.toString());
+  
+
+  cdebug("sx:"<<sx);
+  cdebug("sy:"<<sy);
+  cdebug("M:"<<m.toString());*/
+}
+  
+AGRect2 AGProjection2D::project(const AGRect2 &r)
+{
+  return AGRect2((m*r.getV0()).dim2(),(m*r.getV1()).dim2());
+}
+AGVector2 AGProjection2D::project(const AGVector2 &p)
+{
+  return (m*p).dim2();
+}
+
+void AGProjection2D::pushProjection(const AGProjection2D &p)
+{
+  m*=p.m;
+}

Added: antargis/branches/rant/ext/video/ag_projection.h
===================================================================
--- antargis/branches/rant/ext/video/ag_projection.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_projection.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,21 @@
+#ifndef AG_PROJECTION
+#define AG_PROJECTION
+
+#include <ag_geometry.h>
+
+
+class AGProjection2D
+{
+  AGMatrix3 m;
+ public:
+  AGProjection2D(const AGRect2 &from, const AGRect2 &to);
+  
+  AGRect2 project(const AGRect2 &r);
+  AGVector2 project(const AGVector2 &p);
+
+  void pushProjection(const AGProjection2D &p);
+};
+
+
+
+#endif

Added: antargis/branches/rant/ext/video/ag_sdlsurface.h
===================================================================
--- antargis/branches/rant/ext/video/ag_sdlsurface.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_sdlsurface.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_sdlsurface.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef __GUI_SDLSURFACE_H
+#define __GUI_SDLSURFACE_H
+
+#include "ag_screen.h"
+
+class AGSDLScreen:public AGScreen
+{
+ public:
+  AGSDLScreen(SDL_Surface *s);
+
+  virtual void blit(const AGTexture &pSource,const AGRect2 &pDest,const AGRect2 &pSrc);
+
+  virtual void flip();
+  virtual void update(const std::list<AGRect2> &rs);
+
+  virtual AGRect2 getRect() const;
+
+  virtual void fillRect(const AGRect2 &pRect,const AGColor &c);
+  virtual void fillRects(const std::vector<std::pair<AGRect2,AGVector4> > &pRects);
+  virtual void drawLine(const AGVector2 &p0,const AGVector2 &p1,const AGColor &c);
+
+  virtual void drawGradientAlpha(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr);
+  virtual void drawGradient(const AGRect2& rect, const AGColor& ul, const AGColor& ur, const AGColor& dl, const AGColor& dr);
+
+  virtual void drawBorder(const AGRect2& rect,int W, const AGColor& c1, const AGColor& c2);
+
+  virtual void putPixel(int x,int y,const AGColor &c);
+
+  //  virtual SDL_Surface *newSurface(int x,int y);
+
+  //  virtual AGSurface loadSurface(const std::string &pFilename);
+
+  //  virtual AGTexture displayFormat(SDL_Surface *s);
+
+  //  virtual AGTexture makeTexture(const AGSurface &s);
+
+  virtual size_t getWidth() const;
+  virtual size_t getHeight() const;
+
+  virtual void clip(const AGRect2 &r);
+  virtual void unclip();
+
+  AGSurface screenshot(bool frontBuffer=true);
+
+ private:
+  SDL_Surface *s;
+ public:
+};
+
+#endif

Modified: antargis/branches/rant/ext/video/ag_texture.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_texture.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_texture.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -169,7 +169,7 @@
 
 bool AGTexture::hasTexture() const
 {
-  return mTexture || !glMode();
+  return mTexture || !opengl();
 }
 void AGTexture::clearTexture()
 {

Added: antargis/branches/rant/ext/video/ag_texturecache.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_texturecache.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_texturecache.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,158 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_texturecache.cpp
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#include "ag_texture.h"
+#include "ag_texturecache.h"
+#include "ag_png.h"
+#include "ag_kill.h"
+#include "ag_geometry.h"
+
+AGTextureCache *mTextureCache=0;
+AGTextureCache *getTextureCache()
+{
+  if(!mTextureCache)
+    mTextureCache=new AGTextureCache;
+  return mTextureCache;
+}
+
+AGTextureCache::AGTextureCache()
+{
+  getInstanceKiller()->reg(createKiller(this));
+}
+
+const AGTexture &AGTextureCache::get(const AGFilename &pTexture,const AGRect2 &pSub)
+{
+  std::string s=pTexture+":"+pSub.toString();
+
+  std::map<AGFilename,AGTexture*>::iterator i=mTextures.find(s);
+  if(i==mTextures.end())
+    {
+      // load
+      AGSurface ms=AGSurface::load(pTexture).getSubSurface(pSub);
+      
+
+
+      /*      while(downScaleExp>1 && ms.width()>16 && ms.height()>16)
+	{
+	  ms=ms.scale(ms.width()/2,ms.height()/2);
+	  downScaleExp--;
+	}
+      */
+      mTextures[s]=new AGTexture(ms,false);
+    }
+  return *(mTextures[s]);
+}
+
+
+const AGTexture &AGTextureCache::get(const AGFilename &pTexture,int downScaleExp)
+  {
+    std::map<AGFilename,AGTexture*>::iterator i=mTextures.find(pTexture);
+    if(i==mTextures.end())
+      {
+        // load
+        AGSurface ms=AGSurface::load(pTexture);
+
+	while(downScaleExp>1 && ms.width()>16 && ms.height()>16)
+	  {
+	    ms=ms.scale(ms.width()/2,ms.height()/2);
+	    downScaleExp--;
+	  }
+
+        mTextures[pTexture]=new AGTexture(ms,false);
+      }
+    return *(mTextures[pTexture]);
+  }
+
+AGSurface skipHalfTexture(const AGSurface &s)
+{
+  TRACE;
+  if(s.width()>s.height())
+    {
+      int w=s.width();
+      int h=s.height();
+      int nw=w/2;
+      int nh=h;
+      AGSurface n(nw,nh);
+
+      for(int i=0;i<nw/nh;i++)
+	{
+	  for(int y=0;y<nh;y++)
+	    for(int x=0;x<nh;x++)
+	      {
+		n.putPixel(x+nh*i,y,s.getPixel(x+2*nh*i,y));
+	      }
+	}
+
+      return n;
+    }
+  else
+    {
+      int w=s.width();
+      int h=s.height();
+      int nw=w;
+      int nh=h/2;
+      AGSurface n(nw,nh);
+
+      for(int i=0;i<nh/nw;i++)
+	{
+	  for(int y=0;y<nw;y++)
+	    for(int x=0;x<nw;x++)
+	      {
+		n.putPixel(x,y+nw*i,s.getPixel(x,y+2*nw*i));
+	      }
+	}
+
+      return n;
+    }
+}
+
+
+const AGTexture &AGTextureCache::get3D(const AGFilename &pTexture,int downScaleExp,int downScaleZ)
+{
+  std::map<AGFilename,AGTexture*>::iterator i=mTextures.find(pTexture);
+  if(i==mTextures.end())
+    {
+      // load
+      AGSurface ms=AGSurface::load(pTexture);
+
+      cdebug("3d texture size old0:"<<ms.width()<<","<<ms.height());
+      
+      while(downScaleExp>1 && ms.width()>16 && ms.height()>16)
+	{
+	  ms=ms.scale(ms.width()/2,ms.height()/2);
+	  downScaleExp--;
+	}
+
+      cdebug("3d texture size old1:"<<ms.width()<<","<<ms.height());
+
+      while(downScaleZ>1)
+	{
+	  ms=skipHalfTexture(ms);
+	  
+	  downScaleZ--;
+	}
+
+      cdebug("3d texture size:"<<ms.width()<<","<<ms.height());
+
+      
+      mTextures[pTexture]=new AGTexture(ms,true);
+    }
+  return *(mTextures[pTexture]);
+}

Added: antargis/branches/rant/ext/video/ag_texturecache.h
===================================================================
--- antargis/branches/rant/ext/video/ag_texturecache.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_texturecache.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2005 by David Kamphausen. All rights reserved.
+ *
+ * ag_texturecache.h
+ * by David Kamphausen (david.kamphausen at web.de)
+ *
+ * The "Antargis" project, including all files needed to compile it,
+ * is free software; you can redistribute it and/or use it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program.
+ */
+
+#ifndef __TEXTURE_CACHE_H__
+#define __TEXTURE_CACHE_H__
+
+#include "ag_surface.h"
+#include "ag_debug.h"
+#include <ag_fs.h>
+
+#include <string>
+#include <map>
+
+class AGRect2;
+
+class AGTextureCache
+  {
+    AGTextureCache();
+  public:
+    const AGTexture &get(const AGFilename &pTexture,int downScaleExp=1);
+    const AGTexture &get3D(const AGFilename &pTexture,int downScaleExp=1,int downScaleZ=1);
+
+    const AGTexture &get(const AGFilename &pTexture,const AGRect2 &pSub);
+  private:
+    std::map<AGFilename,AGTexture*> mTextures;
+    
+    friend AGTextureCache *getTextureCache();
+  };
+
+AGTextureCache *getTextureCache();
+
+
+#endif

Modified: antargis/branches/rant/ext/video/ag_vdebug.cc
===================================================================
--- antargis/branches/rant/ext/video/ag_vdebug.cc	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_vdebug.cc	2007-06-23 15:07:27 UTC (rev 1105)
@@ -3,7 +3,7 @@
 
 void agAssertGL(std::string s)
 {
-  if(glMode())
+  if(opengl())
     {
       GLenum error = glGetError();
       if(error != GL_NO_ERROR) {

Modified: antargis/branches/rant/ext/video/ag_video.h
===================================================================
--- antargis/branches/rant/ext/video/ag_video.h	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/ag_video.h	2007-06-23 15:07:27 UTC (rev 1105)
@@ -39,7 +39,8 @@
 
 };
 
-bool glMode();
+//bool glMode();
+bool opengl();
 
 AGVideoManager *getVideo();
 

Modified: antargis/branches/rant/ext/video/headers.hh
===================================================================
--- antargis/branches/rant/ext/video/headers.hh	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ext/video/headers.hh	2007-06-23 15:07:27 UTC (rev 1105)
@@ -32,26 +32,26 @@
 #include "ext/basic/ag_mutex.h"
 #include "/home/david/projects/antargis/rant/ext/video/ag_painttarget.h"
 #include "/home/david/projects/antargis/rant/ext/video/ag_surface.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_texture.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_screen.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_fontengine.h"
 #include "/home/david/projects/antargis/rant/ext/video/ag_video.h"
-#include "/home/david/projects/antargis/rant/ext/video/ag_fontengine.h"
-#include "/home/david/projects/antargis/rant/ext/video/ag_painter.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_clip.h"
 #include "/home/david/projects/antargis/rant/ext/video/ag_rendercontext.h"
 #include "/home/david/projects/antargis/rant/ext/video/ag_font.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_painter.h"
 #include "/home/david/projects/antargis/rant/ext/video/ag_color.h"
-#include "/home/david/projects/antargis/rant/ext/video/ag_screen.h"
-#include "/home/david/projects/antargis/rant/ext/video/ag_texture.h"
-#include "/home/david/projects/antargis/rant/ext/video/ag_clip.h"
 #ifdef SWIG
 %include "/home/david/projects/antargis/rant/ext/video/ag_painttarget.h"
 %include "/home/david/projects/antargis/rant/ext/video/ag_surface.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_texture.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_screen.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_fontengine.h"
 %include "/home/david/projects/antargis/rant/ext/video/ag_video.h"
-%include "/home/david/projects/antargis/rant/ext/video/ag_fontengine.h"
-%include "/home/david/projects/antargis/rant/ext/video/ag_painter.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_clip.h"
 %include "/home/david/projects/antargis/rant/ext/video/ag_rendercontext.h"
 %include "/home/david/projects/antargis/rant/ext/video/ag_font.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_painter.h"
 %include "/home/david/projects/antargis/rant/ext/video/ag_color.h"
-%include "/home/david/projects/antargis/rant/ext/video/ag_screen.h"
-%include "/home/david/projects/antargis/rant/ext/video/ag_texture.h"
-%include "/home/david/projects/antargis/rant/ext/video/ag_clip.h"
 #endif
 #endif

Modified: antargis/branches/rant/ruby/ant_models.rb
===================================================================
--- antargis/branches/rant/ruby/ant_models.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ruby/ant_models.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -229,8 +229,14 @@
 				if not fileExists(pngname)
 					pngname=""
 				end
-	
-				scenenode=Mesh.new(getMap.getScene,getMeshData(ant2name,getStaticModelScaling(name),pngname),AGVector4.new(0,0,0),angle)
+
+				s=getMap.getScene
+
+				s=getMap.getScene
+				data=getMeshData(ant2name,getStaticModelScaling(name),pngname)
+				v=AGVector4.new(0,0,0)
+				puts "scene:#{s} data:#{data} vec:#{v} angle:#{angle}"
+				scenenode=Mesh.new(s,data,v,angle)
 			end
 		end
 	

Modified: antargis/branches/rant/ruby/antargis.rb
===================================================================
--- antargis/branches/rant/ruby/antargis.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ruby/antargis.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -105,7 +105,7 @@
 		puts "PANEL:", at buttonpanel
 		raise 1 if @buttonpanel.nil?
 
-		@miniMap=toMiniMap(@layout.getChild("miniMap"))
+		@miniMap=@layout.getChild("miniMap")
 		@fps=0
 
 		setMainWidget(@layout)

Added: antargis/branches/rant/ruby/antargisgui.rb
===================================================================
--- antargis/branches/rant/ruby/antargisgui.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ruby/antargisgui.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,14 @@
+@@programDir=Dir.pwd+"/ruby"
+@@extDir=Dir.pwd+"/ext"
+# add programdir to path
+$:.push(@@programDir)
+$:.push(@@extDir)
+
+
+require 'ext/antargisgui.so'
+include Antargisgui
+#require 'ext/antargisbasic.so'
+include Antargisbasic
+include Antargismath
+include Antargisvideo
+

Added: antargis/branches/rant/ruby/antargismath.rb
===================================================================
--- antargis/branches/rant/ruby/antargismath.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ruby/antargismath.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -0,0 +1,11 @@
+@@programDir=Dir.pwd+"/ruby"
+@@extDir=Dir.pwd+"/ext"
+# add programdir to path
+$:.push(@@programDir)
+$:.push(@@extDir)
+
+
+require 'ext/antargismath.so'
+include Antargisbasic
+include Antargismath
+

Modified: antargis/branches/rant/ruby/gui/ag_tools.rb
===================================================================
--- antargis/branches/rant/ruby/gui/ag_tools.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ruby/gui/ag_tools.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -134,23 +134,12 @@
 	eval("@#{name}=AGSignal.new(self,'#{name}')\n")
 end
 
-if hasLibantargis
-	module Libantargis
-		class AGApplication
-			include AGHandler
-		end
-		class AGWidget
-			include AGHandler
-		end
+module Antargisgui
+	class AGApplication
+		include AGHandler
 	end
-else
-	module Libantargisgui
-		class AGApplication
-			include AGHandler
-		end
-		class AGWidget
-			include AGHandler
-		end
+	class AGWidget
+		include AGHandler
 	end
 end
 

Modified: antargis/branches/rant/ruby/map.rb
===================================================================
--- antargis/branches/rant/ruby/map.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ruby/map.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -52,6 +52,11 @@
 	attr_reader :path
 
 	def initialize(app,pScene,w,h,playerName="Rowen")
+		assert{app.is_a?(AGApplication)}
+		assert{pScene.is_a?(SceneBase)}
+		assert{w.is_a?(Numeric)}
+		assert{h.is_a?(Numeric)}
+
 		super(pScene,w,h)
 		@pause=false # is game paused
 		@app=app

Modified: antargis/branches/rant/ruby/view.rb
===================================================================
--- antargis/branches/rant/ruby/view.rb	2007-06-22 20:52:07 UTC (rev 1104)
+++ antargis/branches/rant/ruby/view.rb	2007-06-23 15:07:27 UTC (rev 1105)
@@ -203,6 +203,7 @@
 	def initialize(p,r)
 		super(p,r)
 		setName("ButtonPanel")
+		puts self,self.class,respond_to?(:clearHandlers),self.is_a?(AGWidget),self.methods.join("//")
 		clearHandlers
 		@jobButtons=["doRest","doDismiss","doDropFood","doDropWeapon","doBuild"]
 		@aggButtons={"doAgg0"=>1,"doAgg1"=>2,"doAgg2"=>3}



From davidkamphausen at mail.berlios.de  Sat Jun 23 18:53:30 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 23 Jun 2007 18:53:30 +0200
Subject: [Antargis-svn] r1106 - in antargis/branches/rant/ext: 3dengine game
	video
Message-ID: <200706231653.l5NGrUpI003883@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-23 18:53:28 +0200 (Sat, 23 Jun 2007)
New Revision: 1106

Modified:
   antargis/branches/rant/ext/3dengine/headers.hh
   antargis/branches/rant/ext/game/headers.hh
   antargis/branches/rant/ext/game/heuristic.h
   antargis/branches/rant/ext/game/jobs.h
   antargis/branches/rant/ext/game/map.h
   antargis/branches/rant/ext/game/resource.h
   antargis/branches/rant/ext/game/water.h
   antargis/branches/rant/ext/video/ag_texturecache.h
   antargis/branches/rant/ext/video/headers.hh
Log:
* some more changes


Modified: antargis/branches/rant/ext/3dengine/headers.hh
===================================================================
--- antargis/branches/rant/ext/3dengine/headers.hh	2007-06-23 15:07:27 UTC (rev 1105)
+++ antargis/branches/rant/ext/3dengine/headers.hh	2007-06-23 16:53:28 UTC (rev 1106)
@@ -33,6 +33,7 @@
 #include "/home/david/projects/antargis/rant/ext/3dengine/mesh_2d.h"
 #include "/home/david/projects/antargis/rant/ext/3dengine/scene.h"
 #include "/home/david/projects/antargis/rant/ext/3dengine/anim_mesh.h"
+#include "/home/david/projects/antargis/rant/ext/3dengine/mesh_optimizer.h"
 #ifdef SWIG
 %include "/home/david/projects/antargis/rant/ext/3dengine/mesh_data.h"
 %include "/home/david/projects/antargis/rant/ext/3dengine/scene_base.h"
@@ -43,5 +44,6 @@
 %include "/home/david/projects/antargis/rant/ext/3dengine/mesh_2d.h"
 %include "/home/david/projects/antargis/rant/ext/3dengine/scene.h"
 %include "/home/david/projects/antargis/rant/ext/3dengine/anim_mesh.h"
+%include "/home/david/projects/antargis/rant/ext/3dengine/mesh_optimizer.h"
 #endif
 #endif

Modified: antargis/branches/rant/ext/game/headers.hh
===================================================================
--- antargis/branches/rant/ext/game/headers.hh	2007-06-23 15:07:27 UTC (rev 1105)
+++ antargis/branches/rant/ext/game/headers.hh	2007-06-23 16:53:28 UTC (rev 1106)
@@ -103,18 +103,28 @@
 #include "ext/3dengine/mesh_2d_data.h"
 #include "ext/3dengine/ant_projection.h"
 #include "ext/3dengine/ag_glsl.h"
+#include "/home/david/projects/antargis/rant/ext/game/path.h"
 #include "/home/david/projects/antargis/rant/ext/game/terrain.h"
 #include "/home/david/projects/antargis/rant/ext/game/entity.h"
+#include "/home/david/projects/antargis/rant/ext/game/water.h"
 #include "/home/david/projects/antargis/rant/ext/game/height_map.h"
 #include "/home/david/projects/antargis/rant/ext/game/ant_app.h"
 #include "/home/david/projects/antargis/rant/ext/game/minimap.h"
 #include "/home/david/projects/antargis/rant/ext/game/map.h"
+#include "/home/david/projects/antargis/rant/ext/game/heuristic.h"
+#include "/home/david/projects/antargis/rant/ext/game/jobs.h"
+#include "/home/david/projects/antargis/rant/ext/game/resource.h"
 #ifdef SWIG
+%include "/home/david/projects/antargis/rant/ext/game/path.h"
 %include "/home/david/projects/antargis/rant/ext/game/terrain.h"
 %include "/home/david/projects/antargis/rant/ext/game/entity.h"
+%include "/home/david/projects/antargis/rant/ext/game/water.h"
 %include "/home/david/projects/antargis/rant/ext/game/height_map.h"
 %include "/home/david/projects/antargis/rant/ext/game/ant_app.h"
 %include "/home/david/projects/antargis/rant/ext/game/minimap.h"
 %include "/home/david/projects/antargis/rant/ext/game/map.h"
+%include "/home/david/projects/antargis/rant/ext/game/heuristic.h"
+%include "/home/david/projects/antargis/rant/ext/game/jobs.h"
+%include "/home/david/projects/antargis/rant/ext/game/resource.h"
 #endif
 #endif

Modified: antargis/branches/rant/ext/game/heuristic.h
===================================================================
--- antargis/branches/rant/ext/game/heuristic.h	2007-06-23 15:07:27 UTC (rev 1105)
+++ antargis/branches/rant/ext/game/heuristic.h	2007-06-23 16:53:28 UTC (rev 1106)
@@ -1,6 +1,8 @@
 #ifndef HEURISTIC_H
 #define HEURISTIC_H
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #include <ag_geometry.h>
 
 class HeuristicFunction

Modified: antargis/branches/rant/ext/game/jobs.h
===================================================================
--- antargis/branches/rant/ext/game/jobs.h	2007-06-23 15:07:27 UTC (rev 1105)
+++ antargis/branches/rant/ext/game/jobs.h	2007-06-23 16:53:28 UTC (rev 1106)
@@ -22,6 +22,8 @@
 #define ANT_JOBS_H
 #include <ag_geometry.h>
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 class AntEntity;
 
 /**

Modified: antargis/branches/rant/ext/game/map.h
===================================================================
--- antargis/branches/rant/ext/game/map.h	2007-06-23 15:07:27 UTC (rev 1105)
+++ antargis/branches/rant/ext/game/map.h	2007-06-23 16:53:28 UTC (rev 1106)
@@ -60,8 +60,10 @@
   
   EntityList getEntities(const AGRect2&r);
   EntityList getAllEntities();
-  std::vector<AntEntityPtr> getAllEntitiesV();
-  std::vector<AntEntityPtr> getEntities(const AGString &pName);
+//  std::vector<AntEntityPtr> getAllEntitiesV();
+//  std::vector<AntEntityPtr> getEntities(const AGString &pName);
+  std::vector<AntEntity*> getAllEntitiesV();
+  std::vector<AntEntity*> getEntities(const AGString &pName);
 
   AntEntity *getEntity(const Mesh &pMesh);
   AntEntity *getEntity(const AnimMesh &pMesh);
@@ -70,7 +72,8 @@
   AntEntity *getByName(const AGString &pName);
 
   AntEntity *getNext(AntEntity *me,const AGString &pType,size_t atLeast=0);
-  std::vector<AntEntityPtr> getNextList(AntEntity *me,const AGString &pType,size_t atLeast=0);
+//  std::vector<AntEntityPtr> getNextList(AntEntity *me,const AGString &pType,size_t atLeast=0);
+  std::vector<AntEntity*> getNextList(AntEntity *me,const AGString &pType,size_t atLeast=0);
 
   void setHeuristic(HeuristicFunction *pFunction);
 

Modified: antargis/branches/rant/ext/game/resource.h
===================================================================
--- antargis/branches/rant/ext/game/resource.h	2007-06-23 15:07:27 UTC (rev 1105)
+++ antargis/branches/rant/ext/game/resource.h	2007-06-23 16:53:28 UTC (rev 1106)
@@ -1,6 +1,8 @@
 #ifndef RESOURCE_H
 #define RESOURCE_H
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #include <map>
 #include <ag_xml.h>
 

Modified: antargis/branches/rant/ext/game/water.h
===================================================================
--- antargis/branches/rant/ext/game/water.h	2007-06-23 15:07:27 UTC (rev 1105)
+++ antargis/branches/rant/ext/game/water.h	2007-06-23 16:53:28 UTC (rev 1106)
@@ -1,6 +1,8 @@
 #ifndef __antargis_gl_water_h
 #define __antargis_gl_water_h
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #include "glsl.h"
 #include "scene.h"
 #include "ag_texturecache.h"

Modified: antargis/branches/rant/ext/video/ag_texturecache.h
===================================================================
--- antargis/branches/rant/ext/video/ag_texturecache.h	2007-06-23 15:07:27 UTC (rev 1105)
+++ antargis/branches/rant/ext/video/ag_texturecache.h	2007-06-23 16:53:28 UTC (rev 1106)
@@ -18,6 +18,8 @@
  * License along with this program.
  */
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #ifndef __TEXTURE_CACHE_H__
 #define __TEXTURE_CACHE_H__
 

Modified: antargis/branches/rant/ext/video/headers.hh
===================================================================
--- antargis/branches/rant/ext/video/headers.hh	2007-06-23 15:07:27 UTC (rev 1105)
+++ antargis/branches/rant/ext/video/headers.hh	2007-06-23 16:53:28 UTC (rev 1106)
@@ -38,6 +38,7 @@
 #include "/home/david/projects/antargis/rant/ext/video/ag_video.h"
 #include "/home/david/projects/antargis/rant/ext/video/ag_clip.h"
 #include "/home/david/projects/antargis/rant/ext/video/ag_rendercontext.h"
+#include "/home/david/projects/antargis/rant/ext/video/ag_texturecache.h"
 #include "/home/david/projects/antargis/rant/ext/video/ag_font.h"
 #include "/home/david/projects/antargis/rant/ext/video/ag_painter.h"
 #include "/home/david/projects/antargis/rant/ext/video/ag_color.h"
@@ -50,6 +51,7 @@
 %include "/home/david/projects/antargis/rant/ext/video/ag_video.h"
 %include "/home/david/projects/antargis/rant/ext/video/ag_clip.h"
 %include "/home/david/projects/antargis/rant/ext/video/ag_rendercontext.h"
+%include "/home/david/projects/antargis/rant/ext/video/ag_texturecache.h"
 %include "/home/david/projects/antargis/rant/ext/video/ag_font.h"
 %include "/home/david/projects/antargis/rant/ext/video/ag_painter.h"
 %include "/home/david/projects/antargis/rant/ext/video/ag_color.h"



From davidkamphausen at mail.berlios.de  Sat Jun 23 18:54:19 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 23 Jun 2007 18:54:19 +0200
Subject: [Antargis-svn] r1107 - in antargis/branches/rant/ext: basic
	external game gui math ruby sound video
Message-ID: <200706231654.l5NGsJfw004165@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-23 18:54:17 +0200 (Sat, 23 Jun 2007)
New Revision: 1107

Added:
   antargis/branches/rant/ext/basic/templates.i
   antargis/branches/rant/ext/external/templates.i
   antargis/branches/rant/ext/game/templates.i
   antargis/branches/rant/ext/gui/templates.i
   antargis/branches/rant/ext/math/templates.i
   antargis/branches/rant/ext/ruby/templates.i
   antargis/branches/rant/ext/sound/templates.i
   antargis/branches/rant/ext/video/templates.i
Log:
* some more files


Added: antargis/branches/rant/ext/basic/templates.i
===================================================================
--- antargis/branches/rant/ext/basic/templates.i	2007-06-23 16:53:28 UTC (rev 1106)
+++ antargis/branches/rant/ext/basic/templates.i	2007-06-23 16:54:17 UTC (rev 1107)
@@ -0,0 +1,11 @@
+%template(StdVectorPNode) std::vector<Node*>;
+%template(AGNodeList) std::vector<Node>;
+//%template(AGNodePList) std::vector<Node*>;
+
+
+
+%template(StringVector) std::vector<std::string>;
+%template(AGStringVector) std::vector<AGString>;
+%template(AGFilenameVector) std::vector<AGFilename>;
+
+

Added: antargis/branches/rant/ext/external/templates.i
===================================================================

Added: antargis/branches/rant/ext/game/templates.i
===================================================================
--- antargis/branches/rant/ext/game/templates.i	2007-06-23 16:53:28 UTC (rev 1106)
+++ antargis/branches/rant/ext/game/templates.i	2007-06-23 16:54:17 UTC (rev 1107)
@@ -0,0 +1,28 @@
+%{
+AntEntity *SWIG_RB2AntEntity(VALUE x) {
+	AntEntity *e=0;
+	Data_Get_Struct(x,AntEntity,e);
+	return 0;
+}
+VALUE SWIG_AntEntity2RB(AntEntity*e ) {
+	return AG_NewPointerObj(e,SWIGTYPE_p_AntEntity,0);
+}
+bool SWIG_ANTENTITY_P(VALUE x) {
+	return true; // FIXME ???
+    //return TYPE(x) == T_STRING;
+}
+
+%}
+
+namespace std
+{
+	specialize_std_vector(AntEntity*,SWIG_ANTENTITY_P,SWIG_RB2AntEntity,SWIG_AntEntity2RB);
+	specialize_std_list(AntEntity*,SWIG_ANTENTITY_P,SWIG_RB2AntEntity,SWIG_AntEntity2RB);
+}
+
+
+%template(EntityPVector) std::vector<AntEntity*>;
+%template(EntityPList) std::list<AntEntity*>;
+%template(EntityVector) std::vector<AntEntityPtr>;
+%template(ResourceMap) std::map<std::string,float>;
+%template(AGResourceMap) std::map<AGString,float>;

Added: antargis/branches/rant/ext/gui/templates.i
===================================================================

Added: antargis/branches/rant/ext/math/templates.i
===================================================================
--- antargis/branches/rant/ext/math/templates.i	2007-06-23 16:53:28 UTC (rev 1106)
+++ antargis/branches/rant/ext/math/templates.i	2007-06-23 16:54:17 UTC (rev 1107)
@@ -0,0 +1,9 @@
+%template(StdVectorAGRect2) std::vector<AGRect2>;
+%template(StdVectorAGVector2) std::vector<AGVector2>;
+%template(StdVectorAGVector3) std::vector<AGVector3>;
+%template(StdVectorAGVector4) std::vector<AGVector4>;
+
+
+%template(AGRect2List) std::list<AGRect2>;
+%template(AGMatrixVector) std::vector<AGMatrix4>;
+

Added: antargis/branches/rant/ext/ruby/templates.i
===================================================================

Added: antargis/branches/rant/ext/sound/templates.i
===================================================================

Added: antargis/branches/rant/ext/video/templates.i
===================================================================



From davidkamphausen at mail.berlios.de  Sat Jun 23 18:55:10 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 23 Jun 2007 18:55:10 +0200
Subject: [Antargis-svn] r1108 - in antargis/branches/rant: build data/gui
	data/gui/images data/gui/images/basic ext/game
Message-ID: <200706231655.l5NGtANp004243@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-23 18:55:08 +0200 (Sat, 23 Jun 2007)
New Revision: 1108

Added:
   antargis/branches/rant/build/ag_data.i
   antargis/branches/rant/build/ag_filename.i
   antargis/branches/rant/build/ag_string.i
   antargis/branches/rant/data/gui/images/
   antargis/branches/rant/data/gui/images/basic/
   antargis/branches/rant/data/gui/images/basic/bg_tile.png
   antargis/branches/rant/data/gui/images/basic/bg_tile2.png
   antargis/branches/rant/data/gui/images/basic/bigbg_tile.png
   antargis/branches/rant/data/gui/images/basic/blue_cursor.png
   antargis/branches/rant/data/gui/images/basic/blue_cursor.svg
   antargis/branches/rant/data/gui/images/basic/box.png
   antargis/branches/rant/data/gui/images/basic/box_cross.png
   antargis/branches/rant/data/gui/images/basic/button1.svg
   antargis/branches/rant/data/gui/images/basic/buttontest2.png
   antargis/branches/rant/data/gui/images/basic/buttontest3.png
   antargis/branches/rant/data/gui/images/basic/buttontest3b.png
   antargis/branches/rant/data/gui/images/basic/close_button.png
   antargis/branches/rant/data/gui/images/basic/cursor2.svg
   antargis/branches/rant/data/gui/images/basic/menu_house_small.png
   antargis/branches/rant/data/gui/images/basic/oldpaper.png
   antargis/branches/rant/data/gui/images/basic/right_arrow.png
   antargis/branches/rant/data/gui/images/basic/round.png
   antargis/branches/rant/data/gui/images/basic/round_checked.png
   antargis/branches/rant/data/gui/images/basic/sword.png
   antargis/branches/rant/data/gui/images/basic/win_border.png
   antargis/branches/rant/ext/game/path.cc
   antargis/branches/rant/ext/game/path.h
Log:
* some more files


Added: antargis/branches/rant/build/ag_data.i
===================================================================
--- antargis/branches/rant/build/ag_data.i	2007-06-23 16:54:17 UTC (rev 1107)
+++ antargis/branches/rant/build/ag_data.i	2007-06-23 16:55:08 UTC (rev 1108)
@@ -0,0 +1,82 @@
+//
+// SWIG typemaps for std::string
+// Luigi Ballabio
+// Apr 8, 2002
+//
+// Ruby implementation
+
+
+// ------------------------------------------------------------------------
+// std::string is typemapped by value
+// This can prevent exporting methods which return a string
+// in order for the user to modify it.
+// However, I think I'll wait until someone asks for it...
+// ------------------------------------------------------------------------
+
+%include exception.i
+
+%{
+#include <ag_string.h>
+#include <ag_fs.h>
+%}
+
+
+    // Ruby wants class names to start with a capital letter
+    // %rename(String) string;
+//    class string;
+
+    /* Overloading check */
+    %typemap(typecheck) AGData = char *;
+    %typemap(typecheck) const AGData & = char *;
+
+    %typemap(in) AGData {
+        if (TYPE($input) == T_STRING) {
+            $1 = AGData(RSTRING($input)->ptr,RSTRING($input)->len);
+        } else {
+            SWIG_exception(SWIG_TypeError, "not a string");
+        }
+    }
+
+    %typemap(in) const AGData & (AGData temp) {
+        if (TYPE($input) == T_STRING) {
+            temp = AGData(RSTRING($input)->ptr,RSTRING($input)->len);
+            $1 = &temp;
+        } else {
+            SWIG_exception(SWIG_TypeError, "not a string");
+        }
+    }
+
+    %typemap(out) AGData {
+        $result = rb_str_new($1.c_str(),$1.length());
+    }
+
+    %typemap(out) const AGData & {
+        $result = rb_str_new($1->c_str(),$1->length());
+    }
+
+    %typemap(directorin) AGData, const AGData &, AGData & "$input=rb_str_new($1_name.c_str(),$1_name.length());";
+
+    %typemap(directorin) AGData *, const AGData * "$1_name->c_str()";
+    
+    %typemap(directorout) AGData {
+        if (TYPE($input) == T_STRING)
+            $result = AGData(RSTRING($input)->ptr,RSTRING($input)->len);
+        else
+            throw Swig::DirectorTypeMismatchException("string expected");
+    }
+    
+    %typemap(directorout) const AGData & (AGData temp) {
+        if (TYPE($input) == T_STRING) {
+            temp = AGData(RSTRING($input)->ptr,RSTRING($input)->len);
+            $result = &temp;
+        } else {
+            throw Swig::DirectorTypeMismatchException("string expected");
+        }
+    }
+/*
+    %typemap(throws) AGData, const string &
+        "rb_raise(rb_eRuntimeError, $1.c_str());";
+
+    %typemap(throws) string *, const string *
+        "rb_raise(rb_eRuntimeError, $1->c_str());";
+*/

Added: antargis/branches/rant/build/ag_filename.i
===================================================================
--- antargis/branches/rant/build/ag_filename.i	2007-06-23 16:54:17 UTC (rev 1107)
+++ antargis/branches/rant/build/ag_filename.i	2007-06-23 16:55:08 UTC (rev 1108)
@@ -0,0 +1,82 @@
+//
+// SWIG typemaps for std::string
+// Luigi Ballabio
+// Apr 8, 2002
+//
+// Ruby implementation
+
+
+// ------------------------------------------------------------------------
+// std::string is typemapped by value
+// This can prevent exporting methods which return a string
+// in order for the user to modify it.
+// However, I think I'll wait until someone asks for it...
+// ------------------------------------------------------------------------
+
+%include exception.i
+
+%{
+#include <ag_string.h>
+#include <ag_fs.h>
+%}
+
+
+    // Ruby wants class names to start with a capital letter
+    // %rename(String) string;
+//    class string;
+
+    /* Overloading check */
+    %typemap(typecheck) AGFilename = char *;
+    %typemap(typecheck) const AGFilename & = char *;
+
+    %typemap(in) AGFilename {
+        if (TYPE($input) == T_STRING) {
+            $1 = AGFilename(RSTRING($input)->ptr,RSTRING($input)->len);
+        } else {
+            SWIG_exception(SWIG_TypeError, "not a string");
+        }
+    }
+
+    %typemap(in) const AGFilename & (AGFilename temp) {
+        if (TYPE($input) == T_STRING) {
+            temp = AGFilename(RSTRING($input)->ptr,RSTRING($input)->len);
+            $1 = &temp;
+        } else {
+            SWIG_exception(SWIG_TypeError, "not a string");
+        }
+    }
+
+    %typemap(out) AGFilename {
+        $result = rb_str_new($1.c_str(),$1.length());
+    }
+
+    %typemap(out) const AGFilename & {
+        $result = rb_str_new($1->c_str(),$1->length());
+    }
+
+    %typemap(directorin) AGFilename, const AGFilename &, AGFilename & "$input=rb_str_new($1_name.c_str(),$1_name.length());";
+
+    %typemap(directorin) AGFilename *, const AGFilename * "$1_name->c_str()";
+    
+    %typemap(directorout) AGFilename {
+        if (TYPE($input) == T_STRING)
+            $result = AGFilename(RSTRING($input)->ptr,RSTRING($input)->len);
+        else
+            throw Swig::DirectorTypeMismatchException("string expected");
+    }
+    
+    %typemap(directorout) const AGFilename & (AGFilename temp) {
+        if (TYPE($input) == T_STRING) {
+            temp = AGFilename(RSTRING($input)->ptr,RSTRING($input)->len);
+            $result = &temp;
+        } else {
+            throw Swig::DirectorTypeMismatchException("string expected");
+        }
+    }
+/*
+    %typemap(throws) AGFilename, const string &
+        "rb_raise(rb_eRuntimeError, $1.c_str());";
+
+    %typemap(throws) string *, const string *
+        "rb_raise(rb_eRuntimeError, $1->c_str());";
+*/

Added: antargis/branches/rant/build/ag_string.i
===================================================================
--- antargis/branches/rant/build/ag_string.i	2007-06-23 16:54:17 UTC (rev 1107)
+++ antargis/branches/rant/build/ag_string.i	2007-06-23 16:55:08 UTC (rev 1108)
@@ -0,0 +1,96 @@
+//
+// SWIG typemaps for std::string
+// Luigi Ballabio
+// Apr 8, 2002
+//
+// Ruby implementation
+
+
+// ------------------------------------------------------------------------
+// std::string is typemapped by value
+// This can prevent exporting methods which return a string
+// in order for the user to modify it.
+// However, I think I'll wait until someone asks for it...
+// ------------------------------------------------------------------------
+
+%include exception.i
+
+%{
+#include <ag_string.h>
+%}
+
+
+    // Ruby wants class names to start with a capital letter
+%rename(String) AGString;
+class AGString;
+
+    /* Overloading check */
+    %typemap(typecheck) AGString = char *;
+    %typemap(typecheck) const AGString & = char *;
+
+    %typemap(in) AGString {
+        if (TYPE($input) == T_STRING) {
+            $1 = AGString(RSTRING($input)->ptr,RSTRING($input)->len);
+        } else {
+            SWIG_exception(SWIG_TypeError, "not a string");
+        }
+    }
+
+    %typemap(in) const AGString & (AGString temp) {
+        if (TYPE($input) == T_STRING) {
+            temp = AGString(RSTRING($input)->ptr,RSTRING($input)->len);
+            $1 = &temp;
+        } else {
+            SWIG_exception(SWIG_TypeError, "not a string");
+        }
+    }
+
+    %typemap(out) AGString {
+        $result = rb_str_new($1.c_str(),$1.length());
+    }
+
+    %typemap(out) const AGString & {
+        $result = rb_str_new($1->c_str(),$1->length());
+    }
+
+    %typemap(directorin) AGString, const AGString &, AGString & "$input=rb_str_new($1_name.c_str(),$1_name.length());";
+
+    %typemap(directorin) AGString *, const AGString * "$1_name->c_str()";
+    
+    %typemap(directorout) AGString {
+        if (TYPE($input) == T_STRING)
+            $result = AGString(RSTRING($input)->ptr,RSTRING($input)->len);
+        else
+            throw Swig::DirectorTypeMismatchException("string expected");
+    }
+    
+    %typemap(directorout) const AGString & (AGString temp) {
+        if (TYPE($input) == T_STRING) {
+            temp = AGString(RSTRING($input)->ptr,RSTRING($input)->len);
+            $result = &temp;
+        } else {
+            throw Swig::DirectorTypeMismatchException("string expected");
+        }
+    }
+/*
+    %typemap(throws) AGString, const string &
+        "rb_raise(rb_eRuntimeError, $1.c_str());";
+
+    %typemap(throws) string *, const string *
+        "rb_raise(rb_eRuntimeError, $1->c_str());";
+*/
+
+%{
+AGString SWIG_RB2AGSTR(VALUE x) {
+    return AGString(RSTRING_PTR(x), RSTRING_LEN(x));
+}
+VALUE SWIG_AGSTR2RB(const AGString& s) {
+    return rb_str_new(s.data(), s.size());
+}
+%}
+namespace std
+{
+	specialize_std_vector(AGString,SWIG_STRING_P,SWIG_RB2AGSTR,SWIG_AGSTR2RB);
+	specialize_std_vector(AGFilename,SWIG_STRING_P,SWIG_RB2AGSTR,SWIG_AGSTR2RB);
+	specialize_std_vector(AGData,SWIG_STRING_P,SWIG_RB2AGSTR,SWIG_AGSTR2RB);
+}
\ No newline at end of file

Added: antargis/branches/rant/data/gui/images/basic/bg_tile.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/bg_tile.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/bg_tile2.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/bg_tile2.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/bigbg_tile.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/bigbg_tile.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/blue_cursor.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/blue_cursor.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/blue_cursor.svg
===================================================================
--- antargis/branches/rant/data/gui/images/basic/blue_cursor.svg	2007-06-23 16:54:17 UTC (rev 1107)
+++ antargis/branches/rant/data/gui/images/basic/blue_cursor.svg	2007-06-23 16:55:08 UTC (rev 1108)
@@ -0,0 +1,111 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://web.resource.org/cc/"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:xlink="http://www.w3.org/1999/xlink"
+   xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="210mm"
+   height="297mm"
+   id="svg2"
+   sodipodi:version="0.32"
+   inkscape:version="0.43"
+   sodipodi:docbase="/home/david/projects/antargis/ant/gui/data"
+   sodipodi:docname="blue_cursor.svg"
+   inkscape:export-filename="/home/david/projects/antargis/ant/gui/data/blue_cursor.png"
+   inkscape:export-xdpi="40.119999"
+   inkscape:export-ydpi="40.119999">
+  <defs
+     id="defs4">
+    <linearGradient
+       id="linearGradient2187">
+      <stop
+         style="stop-color:#756ef4;stop-opacity:1;"
+         offset="0"
+         id="stop2189" />
+      <stop
+         style="stop-color:#3935eb;stop-opacity:1"
+         offset="1"
+         id="stop2191" />
+    </linearGradient>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2187"
+       id="radialGradient2193"
+       cx="108.93887"
+       cy="279.11292"
+       fx="108.93887"
+       fy="279.11292"
+       r="27.2846"
+       gradientTransform="matrix(1.360582,2.032202,-0.528133,0.353591,108.1275,-43.79641)"
+       gradientUnits="userSpaceOnUse" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2187"
+       id="radialGradient2205"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.58498,2.423483,-0.615237,0.421672,107.7002,-106.4241)"
+       cx="108.93887"
+       cy="279.11292"
+       fx="108.93887"
+       fy="279.11292"
+       r="27.2846" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2187"
+       id="radialGradient2209"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.360582,2.032202,-0.528133,0.353591,72.21495,-31.55257)"
+       cx="108.93887"
+       cy="279.11292"
+       fx="108.93887"
+       fy="279.11292"
+       r="27.2846" />
+  </defs>
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="0.5"
+     inkscape:cx="115"
+     inkscape:cy="768"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     inkscape:window-width="1392"
+     inkscape:window-height="964"
+     inkscape:window-x="0"
+     inkscape:window-y="0" />
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Ebene 1"
+     inkscape:groupmode="layer"
+     id="layer1">
+    <path
+       style="fill:#ffffff;fill-opacity:1;stroke:#120fa5;stroke-width:2.14211988;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       d="M 83.562661,248.19712 L 96.268641,314.61748 L 109.8252,305.33147 L 124.80482,328.20645 L 139.75187,318.6088 L 124.82872,296.24487 L 139.34585,287.26183 L 83.562661,248.19712 z "
+       id="path2213"
+       sodipodi:nodetypes="cccccccc" />
+    <path
+       style="fill:url(#radialGradient2193);fill-opacity:1;stroke:#000000;stroke-width:1.68599999;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       d="M 88.111305,255.13625 L 98.5493,309.26413 L 110.87601,301.72431 L 125.641,324.24831 L 135.38047,317.80036 L 120.82994,295.31581 L 134.21614,287.44912 L 88.111305,255.13625 z "
+       id="rect1307"
+       sodipodi:nodetypes="cccccccc" />
+  </g>
+</svg>

Added: antargis/branches/rant/data/gui/images/basic/box.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/box.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/box_cross.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/box_cross.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/button1.svg
===================================================================
--- antargis/branches/rant/data/gui/images/basic/button1.svg	2007-06-23 16:54:17 UTC (rev 1107)
+++ antargis/branches/rant/data/gui/images/basic/button1.svg	2007-06-23 16:55:08 UTC (rev 1108)
@@ -0,0 +1,149 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://web.resource.org/cc/"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:xlink="http://www.w3.org/1999/xlink"
+   xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   sodipodi:docname="button1.svg"
+   sodipodi:docbase="/home/david/projects/antargis/svn/antargisgui/trunk/data"
+   inkscape:version="0.41"
+   sodipodi:version="0.32"
+   id="svg2"
+   height="297mm"
+   width="210mm">
+  <defs
+     id="defs3">
+    <linearGradient
+       id="linearGradient2094">
+      <stop
+         id="stop2096"
+         offset="0.0000000"
+         style="stop-color:#dadada;stop-opacity:0.52156866;" />
+      <stop
+         id="stop2098"
+         offset="1.0000000"
+         style="stop-color:#cea600;stop-opacity:0.51372552;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2084">
+      <stop
+         id="stop2086"
+         offset="0.0000000"
+         style="stop-color:#dab000;stop-opacity:0.51999998;" />
+      <stop
+         id="stop2088"
+         offset="1.0000000"
+         style="stop-color:#9b7d00;stop-opacity:0.51333332;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2062">
+      <stop
+         id="stop2064"
+         offset="0.0000000"
+         style="stop-color:#f5b50e;stop-opacity:1.0000000;" />
+      <stop
+         id="stop2066"
+         offset="1.0000000"
+         style="stop-color:#694c00;stop-opacity:1.0000000;" />
+    </linearGradient>
+    <linearGradient
+       gradientUnits="userSpaceOnUse"
+       y2="563.75726"
+       x2="302.37729"
+       y1="450.36023"
+       x1="233.03575"
+       gradientTransform="scale(0.988786,1.011341)"
+       id="linearGradient2068"
+       xlink:href="#linearGradient2062"
+       inkscape:collect="always" />
+    <radialGradient
+       gradientUnits="userSpaceOnUse"
+       r="90.465416"
+       fy="425.68250"
+       fx="201.97609"
+       cy="425.68250"
+       cx="201.97609"
+       gradientTransform="matrix(0.974734,0.000000,0.000000,1.006921,4.490741,0.000000)"
+       id="radialGradient2082"
+       xlink:href="#linearGradient2084"
+       inkscape:collect="always" />
+    <radialGradient
+       r="197.00835"
+       fy="423.10641"
+       fx="198.80493"
+       cy="423.10641"
+       cx="198.80493"
+       gradientTransform="scale(0.990195,1.009902)"
+       gradientUnits="userSpaceOnUse"
+       id="radialGradient2092"
+       xlink:href="#linearGradient2094"
+       inkscape:collect="always" />
+  </defs>
+  <sodipodi:namedview
+     inkscape:window-y="0"
+     inkscape:window-x="0"
+     inkscape:window-height="960"
+     inkscape:window-width="1393"
+     inkscape:current-layer="layer1"
+     inkscape:document-units="px"
+     inkscape:cy="519.99988"
+     inkscape:cx="374.99983"
+     inkscape:zoom="0.98994949"
+     inkscape:pageshadow="2"
+     inkscape:pageopacity="0.0"
+     borderopacity="1.0"
+     bordercolor="#666666"
+     pagecolor="#ffffff"
+     id="base" />
+  <metadata
+     id="metadata4">
+    <rdf:RDF
+       id="RDF5">
+      <cc:Work
+         id="Work6"
+         rdf:about="">
+        <dc:format
+           id="format7">image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage"
+           id="type9" />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     id="layer1"
+     inkscape:groupmode="layer"
+     inkscape:label="Layer 1">
+    <rect
+       ry="23.571428"
+       y="398.07648"
+       x="166.42857"
+       height="157.14307"
+       width="153.57143"
+       id="rect1291"
+       style="stroke-opacity:1.0000000;stroke-miterlimit:4.0000000;stroke-width:3.0000000;stroke:url(#linearGradient2068);fill-opacity:1.0000000;fill:#dfb400" />
+    <rect
+       rx="23.571428"
+       ry="23.571428"
+       y="398.07639"
+       x="166.78571"
+       height="156.42879"
+       width="151.42857"
+       id="rect2070"
+       style="fill:url(#radialGradient2082);fill-opacity:1.0000000;stroke:none;stroke-width:3.0000000;stroke-miterlimit:4.0000000;stroke-opacity:1.0000000" />
+    <rect
+       rx="23.571428"
+       ry="23.571428"
+       y="402.71921"
+       x="171.42856"
+       height="146.42879"
+       width="143.57144"
+       id="rect2090"
+       style="stroke-dasharray:none;fill:url(#radialGradient2092);fill-opacity:1.0;stroke:#000000;stroke-width:1.8000000;stroke-miterlimit:4.0000000;stroke-opacity:0.29302326" />
+  </g>
+</svg>

Added: antargis/branches/rant/data/gui/images/basic/buttontest2.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/buttontest2.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/buttontest3.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/buttontest3.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/buttontest3b.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/buttontest3b.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/close_button.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/close_button.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/cursor2.svg
===================================================================
--- antargis/branches/rant/data/gui/images/basic/cursor2.svg	2007-06-23 16:54:17 UTC (rev 1107)
+++ antargis/branches/rant/data/gui/images/basic/cursor2.svg	2007-06-23 16:55:08 UTC (rev 1108)
@@ -0,0 +1,203 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://web.resource.org/cc/"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:xlink="http://www.w3.org/1999/xlink"
+   xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="210mm"
+   height="297mm"
+   id="svg2"
+   sodipodi:version="0.32"
+   inkscape:version="0.43"
+   sodipodi:docbase="/home/david/projects/antargis/ant/gui/data"
+   sodipodi:docname="cursor2.svg"
+   inkscape:export-filename="/home/david/projects/antargis/ant/gui/data/blue_cursor.png"
+   inkscape:export-xdpi="40.119999"
+   inkscape:export-ydpi="40.119999">
+  <defs
+     id="defs4">
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient2196">
+      <stop
+         style="stop-color:#515151;stop-opacity:1;"
+         offset="0"
+         id="stop2198" />
+      <stop
+         style="stop-color:#515151;stop-opacity:0;"
+         offset="1"
+         id="stop2200" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2185">
+      <stop
+         style="stop-color:#0a0a0a;stop-opacity:1;"
+         offset="0"
+         id="stop2187" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop2190" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2187">
+      <stop
+         style="stop-color:#c3c2cb;stop-opacity:1;"
+         offset="0"
+         id="stop2189" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="1"
+         id="stop2191" />
+    </linearGradient>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2187"
+       id="radialGradient2193"
+       cx="108.93887"
+       cy="279.11292"
+       fx="108.93887"
+       fy="279.11292"
+       r="27.2846"
+       gradientTransform="matrix(1.360582,2.032202,-0.528133,0.353591,107.6538,-48.04704)"
+       gradientUnits="userSpaceOnUse" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2187"
+       id="radialGradient2205"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.58498,2.423483,-0.615237,0.421672,107.7002,-106.4241)"
+       cx="108.93887"
+       cy="279.11292"
+       fx="108.93887"
+       fy="279.11292"
+       r="27.2846" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2187"
+       id="radialGradient2209"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.360582,2.032202,-0.528133,0.353591,72.21495,-31.55257)"
+       cx="108.93887"
+       cy="279.11292"
+       fx="108.93887"
+       fy="279.11292"
+       r="27.2846" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2185"
+       id="radialGradient2192"
+       cx="111.65727"
+       cy="288.20178"
+       fx="111.65727"
+       fy="288.20178"
+       r="28.094604"
+       gradientTransform="matrix(0.787047,1.364371,-0.60534,0.349195,198.6288,36.19876)"
+       gradientUnits="userSpaceOnUse" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2196"
+       id="radialGradient2202"
+       cx="113.47369"
+       cy="304.78323"
+       fx="113.47369"
+       fy="304.78323"
+       r="16.210526"
+       gradientTransform="matrix(1,4.157915e-17,-8.173759e-18,1.753247,-1.760765e-15,-229.577)"
+       gradientUnits="userSpaceOnUse" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2196"
+       id="radialGradient2206"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1,1.398079e-16,-2.893131e-16,1.753247,4.064546e-14,-229.577)"
+       cx="113.47369"
+       cy="304.78323"
+       fx="113.47369"
+       fy="304.78323"
+       r="16.210526" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2196"
+       id="radialGradient2210"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.928885,6.796555e-2,2.995047e-2,1.465559,-1.058698,-149.607)"
+       cx="114.15783"
+       cy="305.9628"
+       fx="114.15783"
+       fy="305.9628"
+       r="16.210526" />
+  </defs>
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1"
+     inkscape:cx="114"
+     inkscape:cy="764"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     inkscape:window-width="1392"
+     inkscape:window-height="964"
+     inkscape:window-x="0"
+     inkscape:window-y="0" />
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Ebene 1"
+     inkscape:groupmode="layer"
+     id="layer1">
+    <path
+       sodipodi:type="arc"
+       style="fill:url(#radialGradient2210);fill-opacity:1;stroke:none;stroke-width:0.78600001;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="path2208"
+       sodipodi:cx="113.47369"
+       sodipodi:cy="304.78323"
+       sodipodi:rx="16.210526"
+       sodipodi:ry="28.421053"
+       d="M 129.68421 304.78323 A 16.210526 28.421053 0 1 1  97.263161,304.78323 A 16.210526 28.421053 0 1 1  129.68421 304.78323 z"
+       transform="matrix(0.57557,-0.529625,0.239928,0.96251,-39.04886,50.60339)" />
+    <path
+       sodipodi:type="arc"
+       style="fill:url(#radialGradient2206);fill-opacity:1;stroke:none;stroke-width:0.78600001;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="path2204"
+       sodipodi:cx="113.47369"
+       sodipodi:cy="304.78323"
+       sodipodi:rx="16.210526"
+       sodipodi:ry="28.421053"
+       d="M 129.68421 304.78323 A 16.210526 28.421053 0 1 1  97.263161,304.78323 A 16.210526 28.421053 0 1 1  129.68421 304.78323 z"
+       transform="matrix(0.711618,0.200994,-0.58995,0.579657,214.4646,97.61851)" />
+    <path
+       sodipodi:type="arc"
+       style="fill:url(#radialGradient2202);fill-opacity:1;stroke:none;stroke-width:0.78600001;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       id="path2194"
+       sodipodi:cx="113.47369"
+       sodipodi:cy="304.78323"
+       sodipodi:rx="16.210526"
+       sodipodi:ry="28.421053"
+       d="M 129.68421 304.78323 A 16.210526 28.421053 0 1 1  97.263161,304.78323 A 16.210526 28.421053 0 1 1  129.68421 304.78323 z"
+       transform="matrix(0.37197,-0.694996,0.584275,0.735324,-100.0865,159.8644)" />
+    <path
+       style="fill:url(#radialGradient2193);fill-opacity:1;stroke:#000000;stroke-width:0.78600001;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
+       d="M 91.83311,259.00592 L 102.27111,309.47967 L 110.40233,297.47368 L 125.16732,319.99768 L 134.90679,313.54973 L 120.35626,291.06518 L 133.33644,289.55939 L 91.83311,259.00592 z "
+       id="rect1307"
+       sodipodi:nodetypes="cccccccc" />
+  </g>
+</svg>

Added: antargis/branches/rant/data/gui/images/basic/menu_house_small.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/menu_house_small.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/oldpaper.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/oldpaper.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/right_arrow.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/right_arrow.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/round.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/round.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/round_checked.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/round_checked.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/sword.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/sword.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/data/gui/images/basic/win_border.png
===================================================================
(Binary files differ)


Property changes on: antargis/branches/rant/data/gui/images/basic/win_border.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: antargis/branches/rant/ext/game/path.cc
===================================================================
--- antargis/branches/rant/ext/game/path.cc	2007-06-23 16:54:17 UTC (rev 1107)
+++ antargis/branches/rant/ext/game/path.cc	2007-06-23 16:55:08 UTC (rev 1108)
@@ -0,0 +1,913 @@
+#include "path.h"
+#include <math.h>
+#include <stdexcept>
+#include <ag_profiler.h>
+#include <ag_debug.h>
+//#include <SDL.h>
+#include <ag_surface.h>
+#include <ag_painter.h>
+
+
+
+///////////////////////////////////////////////////////////////////////
+// Node
+///////////////////////////////////////////////////////////////////////
+
+
+SimpleGraph::Node::~Node()
+{
+
+}
+
+bool SimpleGraph::NodePtrCompare::operator()(const Node *a,const Node *b)
+{
+  return a->p<b->p;
+}
+
+
+SimpleGraph::Node::NodeMap SimpleGraph::Node::getNextNodes()
+{
+  SimpleGraph::Node::NodeMap m;
+
+  for(Edges::iterator i=edges.begin();i!=edges.end();i++)
+    {
+      if((*i)->a==this)
+	m[(*i)->b]=(*i)->w0;
+      else
+	m[(*i)->a]=(*i)->w1;
+    }
+
+  return m;
+}
+
+///////////////////////////////////////////////////////////////////////
+// Edge
+///////////////////////////////////////////////////////////////////////
+
+SimpleGraph::Edge::Edge(Node *pa,Node *pb,float p0,float p1)
+{
+  if(pa<pb)
+    {
+      a=pa;
+      b=pb;
+      w0=p0;
+      w1=p1;
+    }
+  else
+    {
+      a=pb;
+      b=pa;
+      w0=p1;
+      w1=p0;
+    }
+}
+SimpleGraph::Edge::~Edge()
+{
+}
+
+bool SimpleGraph::EdgePtrCompare::operator()(const Edge *a,const Edge *b)
+{
+  return(a->a->p < b->a->p || (a->a->p==b->a->p && a->b->p<b->b->p));
+}
+
+
+bool SimpleGraph::Edge::operator<(const Edge &e) const
+{
+  return a<e.a || (a==e.a && b<e.b);
+}
+
+float SimpleGraph::Edge::maxWeight() const
+{
+  return std::max(w0,w1);
+}
+
+SimpleGraph::Node *SimpleGraph::Edge::getOther(Node *n)
+{
+  if(a==n)
+    return b;
+  if(b==n)
+    return a;
+  return 0;
+}
+
+/*
+SimpleGraph::HalfEdge *SimpleGraph::Edge::getHalfEdgeFrom(Node *n)
+{
+  HalfEdge *h;
+  if(a==n)
+    {
+      h->a=a;
+      h->b=b;
+      h->w=w0;
+    }
+  else
+    {
+      h->b=a;
+      h->a=b;
+      h->w=w1;
+    }
+  return h;
+}
+SimpleGraph::HalfEdge *SimpleGraph::Edge::getHalfEdgeTo(Node *n)
+{
+  HalfEdge *h;
+  if(a!=n)
+    {
+      h->a=a;
+      h->b=b;
+      h->w=w0;
+    }
+  else
+    {
+      h->b=a;
+      h->a=b;
+      h->w=w1;
+    }
+  return h;
+  }*/
+
+
+///////////////////////////////////////////////////////////////////////
+// PathWeighter
+///////////////////////////////////////////////////////////////////////
+
+PathWeighter::~PathWeighter()
+{
+}
+float PathWeighter::weight(float h0,float h1)
+{
+  if(h0<0.3 || h1<0.3)
+    return 100000; // high weight for non-passable water ;-)
+
+  return fabs(h0-h1);
+}
+
+///////////////////////////////////////////////////////////////////////
+// MapPathWeighter
+///////////////////////////////////////////////////////////////////////
+
+MapPathWeighter::MapPathWeighter(HeightMap *pMap):
+  mMap(pMap)
+{
+}
+float MapPathWeighter::weight(const AGVector2 &a,const AGVector2 &b)
+{
+  return complexWeight(a,b);
+
+
+
+  float w=(a-b).length();
+  if(w>1)
+    throw std::runtime_error("not implemented");
+  float h0=mMap->getHeight(a[0],a[1]);
+  float h1=mMap->getHeight(b[0],b[1]);
+
+  w+=weightHeight(h0,h1);
+
+  return w;
+}
+
+float MapPathWeighter::complexWeight(const AGVector2 &a,const AGVector2 &b)
+{
+  // simply measure all "1 units"
+  AGVector2 delta=b-a;
+  float dist=delta.length();
+  AGVector2 dir=delta/dist;
+
+  float weight=0;
+  float stepping=0.1;
+
+
+  float i=std::min(stepping,dist);
+  float oi=0;
+
+
+  while(oi!=i)
+    {
+      float d=i-oi;
+      AGVector2 ca=a+dir*oi;
+      AGVector2 cb=a+dir*i;
+
+      float h0=mMap->getHeight(ca[0],ca[1]);
+      float h1=mMap->getHeight(cb[0],cb[1]);
+      float cw=d+weightHeight(h0,h1);
+
+      weight+=cw;
+
+      oi=i;
+      i=std::min(i+stepping,dist);
+    }
+  return weight;
+}
+
+float MapPathWeighter::weightHeight(float a,float b) const
+{
+  float f=1; // some factor - to be estimated
+
+
+  if(b<0.2)
+    return (0.2-b)*1000;
+
+  if(b>a)
+    {
+      // uphill
+      return (b-a)*f;
+    }
+  else
+    return -(b-a)*f*0.3; 
+}
+
+
+
+
+bool MapPathWeighter::accessible(const AGVector2 &a)
+{
+  //  return true;
+  float hmin=10;
+  for(int x=-1;x<2;x++)
+    for(int y=-1;y<2;y++)
+      {
+	float px=a[0]+x;
+	float py=a[1]+y;
+	px=std::max(0.0f,std::min(px,mMap->getW()-1.0f));
+	py=std::max(0.0f,std::min(py,mMap->getH()-1.0f));
+	hmin=std::min(hmin,mMap->getHeight(px,py));
+      }
+  return hmin>0;
+}
+
+
+
+///////////////////////////////////////////////////////////////////////
+// Graph
+///////////////////////////////////////////////////////////////////////
+
+SimpleGraph::SimpleGraph()
+{
+  mWidth=0.00001;
+}
+
+
+SimpleGraph::Node *SimpleGraph::addNode(const AGVector2 &p)
+{
+  Node *n=findNode(p);
+  if(!n)
+    {
+      n=new Node;
+      n->p=p;
+      mNodes.insert(n);
+      mNodeMap[p]=n;
+    }
+
+  mWidth=std::max((double)mWidth,std::max(fabs(p[0]),fabs(p[1])));
+
+  return n;
+}
+
+void SimpleGraph::paintNode(const AGRect2& r,AGPaintTarget &t,const AGVector2 &p,const AGColor &c)
+{
+  AGPainter painter(t);
+  float xscale=r.width()/width();
+  float yscale=r.height()/width();
+
+
+  float x=p[0]*xscale+r.x();
+  float y=p[1]*yscale+r.y();
+  
+  painter.fillRect(AGRect2(x,y,10,10),c);
+  
+}
+
+
+void SimpleGraph::paint(const AGRect2& r,AGPaintTarget &t,Heuristic &heuristic)
+{
+  AGColor green(0,0xFF,0,0xFF);
+  AGColor red(0xFF,0,0,0xFF);
+  float xscale=r.width()/width();
+  float yscale=r.height()/width();
+  AGPainter painter(t);
+
+  for(EdgeSet::iterator i=mEdges.begin();i!=mEdges.end();i++)
+    {
+      AGVector2 p0=(*i)->a->p;
+      float x0=p0[0]*xscale+r.x();
+      float y0=p0[1]*yscale+r.y();
+      AGVector2 p1=(*i)->b->p;
+      float x1=p1[0]*xscale+r.x();
+      float y1=p1[1]*yscale+r.y();
+
+      painter.drawLine(AGVector2(x0,y0),AGVector2(x1,y1),red);
+
+      AGVector2 m((x0+x1)/2-10,(y0+y1)/2-10);
+
+      painter.renderText(AGStringUtf8((int)(*i)->w0)+":"+AGStringUtf8((int)(*i)->w1),m,AGFont());
+      
+    }
+
+
+  for(NodeSet::iterator i=mNodes.begin();i!=mNodes.end();i++)
+    {
+      AGVector2 p=(*i)->p;
+      float x=p[0]*xscale+r.x();
+      float y=p[1]*yscale+r.y();
+
+      painter.fillRect(AGRect2(x,y,2,2),green);
+
+      painter.renderText(AGStringUtf8(int(heuristic.distance((*i)->p))),AGVector2(x-10,y-10),AGFont());
+
+    }
+}
+
+
+
+float SimpleGraph::width() const
+{
+  return mWidth;
+}
+
+size_t SimpleGraph::size() const
+{
+  return mNodes.size();
+}
+
+
+SimpleGraph::Edge *SimpleGraph::addEdge(Node *a, Node *b,float w0,float w1)
+{
+  Node *n1=a;
+  Node *n2=b;
+  assert(n1);
+  assert(n2);
+  Edge *e=new Edge(n1,n2,w0,w1);
+
+  n1->edges.push_back(e);
+
+  n2->edges.push_back(e);
+
+  mEdges.insert(e);
+
+  return e;
+}
+
+void SimpleGraph::removeEdge(Edge *e)
+{
+  //  cdebug("1");
+  mEdges.erase(e);
+  //  cdebug("2");
+
+  e->a->edges.remove(e);
+  e->b->edges.remove(e);
+  //  cdebug("3");
+
+  //  delete e;
+}
+
+void SimpleGraph::removeNode(Node *n)
+{
+  mNodes.erase(n);
+  mNodeMap.erase(n->p);
+}
+
+
+
+SimpleGraph::~SimpleGraph()
+{
+  for(NodeSet::iterator i=mNodes.begin();i!=mNodes.end();i++)
+    delete *i;
+  for(EdgeSet::iterator i=mEdges.begin();i!=mEdges.end();i++)
+    delete *i;
+}
+
+SimpleGraph::Node *SimpleGraph::findNearest(const AGVector2 &p)
+{
+  if(mNodes.size()==0)
+    return 0;
+
+  NodeSet::iterator i=mNodes.begin();
+  Node *n=*i;
+  float dist=(n->p-p).length();
+  for(;i!=mNodes.end();i++)
+    {
+      float d=((*i)->p-p).length();
+      if(d<dist)
+	{
+	  n=*i;
+	  dist=d;
+	}
+    }
+  return n;
+}
+
+AGVector2 SimpleGraph::findNearestVector(const AGVector2 &p)
+{
+  return findNearest(p)->p;
+}
+
+
+
+SimpleGraph::Node *SimpleGraph::findNode(const AGVector2 &p)
+{
+  return mNodeMap[p];
+}
+
+void SimpleGraph::print()
+{
+  for(EdgeSet::iterator i=mEdges.begin();i!=mEdges.end();i++)
+    std::cout<<(*i)->a->p<<":"<<(*i)->b->p<<":"<<(*i)->w0<<":"<<(*i)->w1<<std::endl;
+}
+
+void SimpleGraph::printInfo()
+{
+  std::cout<<"nodes:"<<mNodes.size()<<std::endl;
+  std::cout<<"edges:"<<mEdges.size()<<std::endl;
+}
+
+void SimpleGraph::check()
+{
+  // check if all nodes have an edge
+  for(NodeSet::iterator i=mNodes.begin();i!=mNodes.end();i++)
+    {
+      if((*i)->edges.size()==0)
+	{
+	  cdebug("empty node:"<<(*i)->p<<"("<<(*i));
+	  throw std::runtime_error("check failed 0");
+	}
+      for(Edges::iterator j=(*i)->edges.begin();j!=(*i)->edges.end();j++)
+	{
+	  if((*j)->a!=(*i) && (*j)->b!=(*i))
+	    throw std::runtime_error("check failed 1");
+	  if(mEdges.find(*j)==mEdges.end())
+	    throw std::runtime_error("check failed 2");
+	}
+    }
+}
+
+
+///////////////////////////////////////////////////////////////////////
+// DecimatedGraph
+///////////////////////////////////////////////////////////////////////
+
+class SortEdges
+{
+public:
+  bool operator()(const SimpleGraph::Edge*e1,const SimpleGraph::Edge*e2)
+  {
+    return e1->maxWeight()<e2->maxWeight();
+  }
+};
+
+void DecimatedGraph::decimate(float amount,MapPathWeighter *pWeighter)
+{
+  size_t m=(size_t)(mNodes.size()*(1.0-amount));
+
+  m=std::max((unsigned int)m,2U);
+
+  while(mNodes.size()>m)
+    {
+      cdebug(mNodes.size()<<" vs. "<<m);
+
+      tryRemove(*mEdges.begin(),pWeighter);
+    }
+
+}
+
+void DecimatedGraph::tryRemove(Edge *e,MapPathWeighter *pWeighter)
+{
+  collapseEdge(e,pWeighter);
+}
+
+//   w0->  w0-> w0->
+// X  --  a -- b -- Y
+//   w0<-  w0-> w0<-
+//
+
+
+void DecimatedGraph::collapseEdge(Edge *e,MapPathWeighter *pWeighter)
+{
+  if(mNodes.size()<=2)
+    return;
+  
+
+  AGVector2 np=(e->a->p+e->b->p)*0.5;
+  //  e->a->p=np;
+
+  Node *nn=addNode(np);
+
+  Edges all;
+  std::copy(e->a->edges.begin(),e->a->edges.end(),std::back_inserter(all));
+  std::copy(e->b->edges.begin(),e->b->edges.end(),std::back_inserter(all));
+
+  //  cdebug("all:"<<all.size());
+
+  std::set<Edge> nedges; // collect edges and sort out doubles
+
+  for(Edges::iterator i=all.begin();i!=all.end();i++)
+    {
+      if(*i!=e)
+	{
+	  if((*i)->a==e->a)
+	    {
+	      // X <- a -> b
+	      nedges.insert(makeEdge((*i)->b,nn,pWeighter));
+	      //	      nedges.insert(Edge((*i)->b,nn,(*i)->w1+e->w0/2, (*i)->w0+e->w1/2));
+	    }
+	  else if((*i)->b==e->a)
+	    {
+	      // X -> a -> b
+	      nedges.insert(makeEdge((*i)->a,nn,pWeighter));
+	      //	      nedges.insert(Edge((*i)->a,nn,(*i)->w0+e->w0/2, (*i)->w1+e->w1/2));
+	    }
+	  else if((*i)->a==e->b)
+	    {
+	      // a -> b -> X
+	      //nedges.insert(Edge(nn,(*i)->b,e->w0/2+(*i)->w0, e->w1/2+(*i)->w1));
+	      nedges.insert(makeEdge(nn,(*i)->b,pWeighter));
+	    }
+	  else if((*i)->b==e->b)
+	    {
+	      // a -> b <- X
+	      //nedges.insert(Edge(nn,(*i)->a, e->w0/2+(*i)->w1, e->w1/2+(*i)->w0));
+	      nedges.insert(makeEdge(nn,(*i)->a,pWeighter));
+	    }
+	}
+    }
+
+  for(std::set<Edge>::iterator i=nedges.begin();i!=nedges.end();i++)
+    addEdge(i->a,i->b,i->w0,i->w1);
+  
+
+  //  cdebug("ok");
+  //  print();
+  //  cdebug("removing:"<<e->b->p<<"("<<e->b);
+  removeNode(e->b);
+  //  cdebug("removing:"<<e->a->p<<"("<<e->a);
+  removeNode(e->a);
+
+  for(Edges::iterator i=all.begin();i!=all.end();i++)
+    removeEdge(*i);
+
+  //  cdebug("ok........");
+  
+}
+
+
+SimpleGraph::Edge DecimatedGraph::makeEdge(Node *a,Node *b,MapPathWeighter *pWeighter)
+{
+  return Edge(a,b,pWeighter->weight(a->p,b->p),pWeighter->weight(b->p,a->p));
+}
+
+
+
+///////////////////////////////////////////////////////////////////////
+// Graph generation
+///////////////////////////////////////////////////////////////////////
+
+SimpleGraph *makeGraph(HeightMap *pMap, MapPathWeighter *pWeighter,size_t res)
+{
+  size_t x,y;
+  SimpleGraph *graph=new SimpleGraph;
+  std::map<std::pair<size_t,size_t>,SimpleGraph::Node*> nodes;
+
+  size_t w=pMap->getW();
+  size_t h=pMap->getH();
+
+
+  //  w=h=4;
+
+  for(x=0;x<w;x+=res)
+    for(y=0;y<h;y+=res)
+      {
+	if(pWeighter->accessible(AGVector2(x,y)))
+	  nodes[std::make_pair(x,y)]=graph->addNode(AGVector2(x,y));
+      }
+
+  for(x=0;x<w;x+=res)
+    for(y=0;y<h;y+=res)
+      {
+	std::pair<size_t,size_t> p(x,y);
+	std::pair<size_t,size_t> p1(x+res,y);
+	std::pair<size_t,size_t> p2(x,y+res);
+	if(x<w-1)
+	  {
+	    SimpleGraph::Node *a=nodes[p];
+	    SimpleGraph::Node *b=nodes[p1];
+	    if(a && b)
+	      graph->addEdge(a,b,pWeighter->weight(AGVector2(x,y),AGVector2(x+res,y)),pWeighter->weight(AGVector2(x+res,y),AGVector2(x,y)));
+	  }
+	if(y<h-1)
+	  {
+	    SimpleGraph::Node *a=nodes[p];
+	    SimpleGraph::Node *b=nodes[p2];
+	    if(a && b)
+	      graph->addEdge(a,b,pWeighter->weight(AGVector2(x,y),AGVector2(x,y+res)),pWeighter->weight(AGVector2(x,y+res),AGVector2(x,y)));
+	  }
+      }
+  return graph;
+
+}
+
+HeuristicFunction *computeHeuristic(SimpleGraph *g)
+{
+  StoredHeuristicFunction *h=new StoredHeuristicFunction(32,g->width());
+
+  size_t c=0;
+
+  AGSurface ms(32,32);
+
+
+  //  SimpleGraph::NodeSet testSet;
+  //  testSet.insert(g->findNearest(AGVector2(176,167)));
+
+
+
+  //??????????????????
+
+  for(SimpleGraph::NodeSet::iterator i=g->mNodes.begin();i!=g->mNodes.end();i++)
+    //for(SimpleGraph::NodeSet::iterator i=testSet.begin();i!=testSet.end();i++)
+    {
+      std::map<SimpleGraph::Node*,float> weights;
+      std::set<SimpleGraph::Node*> modified;
+      modified.insert(*i);
+      while(modified.size())
+	{
+	  SimpleGraph::Node *n=*modified.begin();
+	  modified.erase(modified.begin());
+	  
+	  SimpleGraph::Node::NodeMap ns=n->getNextNodes();
+	  float old=weights[n];
+
+	  for(SimpleGraph::Node::NodeMap::iterator j=ns.begin();j!=ns.end();j++)
+	    {
+	      float now=weights[j->first];
+	      //	      cdebug("now:"<<now<<"  old:"<<old<<" plus:"<<j->second);
+	      if(now==0 || (now>j->second+old))
+		{
+		  modified.insert(j->first);
+		  weights[j->first]=j->second+old;
+		  //		  cdebug("saved:"<<weights[j->first]);
+
+		  if(false)
+		  {
+		    int x=(int)j->first->p[0];
+		    int y=(int)j->first->p[1];
+		    //		    cdebug("w:"<<g->width());
+
+		    x=(int)(x*32/g->width());
+		    y=(int)(y*32/g->width());
+		    int c=(int)weights[j->first]*4;
+		    int c2=(int)weights[j->first];
+		    AGColor mc(c,c2,c2,255);
+		    //		    cdebug(x<<";"<<y<<":"<<mc);
+
+		    ms.putPixel(x,y,mc);
+
+		  }
+
+
+
+
+		}
+	    }
+	}
+
+      //FIXME: store data !!
+
+      for(std::map<SimpleGraph::Node*,float>::iterator j=weights.begin();j!=weights.end();j++)
+	{
+	  h->store(std::make_pair((*i)->p,j->first->p),j->second);
+	}
+
+      h->store(std::make_pair((*i)->p,(*i)->p),0);
+
+      //      ms.save("path.png");
+      //      exit(1);
+
+
+      c++;
+      cdebug(c<<" out of "<<g->mNodes.size());
+    }
+
+  //  h->display();
+
+  return h;
+}
+
+///////////////////////////////////////////////////////////////////////
+// Path
+///////////////////////////////////////////////////////////////////////
+
+
+Path::Path()
+{
+  weight=0;
+}
+
+float Path::getWeight(Heuristic *h) const
+{
+  if(size()>0)
+    return weight+h->distance(back()->p);
+  return -1;
+}
+
+void Path::push(SimpleGraph::Node *n,float w)
+{
+  push_back(n);
+  weight+=w;
+}
+
+void Path::paint(const AGRect2 &r,AGPaintTarget &t,float scale)
+{
+  AGVector2 old;
+  AGColor green(0,0xFF,0,0xFF);
+  AGColor red(0xFF,0,0,0xFF);
+  AGPainter painter(t);
+
+  for(iterator i=begin();i!=end();i++)
+    {
+      AGVector2 current((*i)->p[0]*r.width()/scale+r.x0(),
+			(*i)->p[1]*r.height()/scale+r.y0());
+      if(i!=begin())
+	{
+	  painter.drawLine(old,current,green);
+	}
+      painter.fillRect(AGRect2(current[0],current[1],3,3),red);
+      old=current;
+    }
+  painter.renderText(AGStringUtf8(weight),AGVector2(0,0),AGFont());
+  painter.renderText(AGStringUtf8(size()),AGVector2(0,50),AGFont());
+  
+
+}
+
+///////////////////////////////////////////////////////////////////////
+// Pathfinder
+///////////////////////////////////////////////////////////////////////
+
+
+Pathfinder::Pathfinder(SimpleGraph *pGraph,HeuristicFunction *pHeuristic,PathDebugging *d):
+  mGraph(pGraph),mHeuristic(pHeuristic),
+  mDebug(d)
+{
+}
+
+void Pathfinder::mark()
+{
+  markObject(mGraph);
+}
+
+struct Path;
+
+
+
+// Heuristic
+bool Heuristic::operator()(const Path &a,const Path &b)
+{
+  return a.getWeight(this)<b.getWeight(this);
+}
+
+float Heuristic::distance(const AGVector2&from)
+{
+  //  cdebug("from:"<<from<<" to:"<<to);
+  if((to-AGVector2(90,90)).length()<1)
+    throw int();
+  return (*p)(std::make_pair(from,to));
+}
+
+
+
+std::vector<AGVector2> Pathfinder::computePath(const AGVector2 &pFrom, const AGVector2 &pTo)
+{
+  STACKTRACE;
+
+  Uint32 t0=SDL_GetTicks();
+  
+  SimpleGraph::Node *from=mGraph->findNearest(pFrom);
+  SimpleGraph::Node *to=mGraph->findNearest(pTo);
+
+
+  cdebug("FROM:"<<from->p);
+  cdebug("TO:"<<to->p);
+
+  Path initial;
+  initial.push(from,0);
+
+  //  Heuristic heuristic(to->p);
+  std::set<Path,Heuristic> pathSet(Heuristic(to->p,mHeuristic));
+  std::vector<AGVector2> result;
+
+  pathSet.insert(initial);
+
+  size_t tries=0;
+
+  while(tries<1000 && pathSet.size()>0)
+    {
+      Path path=*pathSet.begin();
+
+      if(mDebug)
+	mDebug->debugPath(path,path.getWeight(new Heuristic(to->p,mHeuristic)));
+
+      {
+	SimpleGraph::Node *oldi=0;
+	  for(Path::iterator i=path.begin();i!=path.end();i++)
+	    {
+	      /*
+	      std::cout<<(*i)->p<<":";
+	      if(oldi)
+		{
+		  for(SimpleGraph::Edges::iterator j=oldi->edges.begin();j!=oldi->edges.end();j++)
+		    {
+		      if((*j)->a==*i)
+			std::cout<<"("<<(*j)->w0<<")";
+		      else if((*j)->b==*i)
+			std::cout<<"("<<(*j)->w1<<")";
+		    }
+		}
+	      */
+	      oldi=*i;
+	    }
+	std::cout<<std::endl;
+      }
+
+      pathSet.erase(pathSet.begin());
+      SimpleGraph::Node *last=path.back();
+      if(last==to)
+	{
+	  Uint32 t1=SDL_GetTicks();
+	  std::cout<<"TIME:"<<t1-t0<<std::endl;
+	  cdebug("time:"<<t1-t0);
+	  cdebug("len:"<<path.size());
+	  cdebug("tries:"<<tries);
+	  cdebug("PATHHHHHHHHHHHHHHHHHHHH:");
+	  cdebug(path.weight);
+	  for(Path::iterator i=path.begin();i!=path.end();i++)
+	    {
+	      cdebug((*i)->p);
+	      result.push_back((*i)->p);
+	    }
+
+	  return result; // ready
+	}
+      
+      
+      cdebug("heuristic:"<<path.getWeight(new Heuristic(to->p,mHeuristic)));
+      cdebug("gone:"<<path.weight);
+      cdebug("setsize:"<<pathSet.size());
+      cdebug("rest:"<<(last->p-to->p).length()<<"  p:"<<last->p);
+      cdebug("tries:"<<tries);
+      
+
+      SimpleGraph::Node::NodeMap nextNodes=last->getNextNodes();
+
+      std::set<SimpleGraph::Node*> alreadyGone;
+      std::copy(path.begin(),path.end(),std::inserter(alreadyGone,alreadyGone.begin()));
+
+      for(SimpleGraph::Node::NodeMap::iterator i=nextNodes.begin();i!=nextNodes.end();i++)
+	{
+	  if(alreadyGone.find(i->first)==alreadyGone.end())
+	    {
+	      cdebug("possible:"<<i->first<<"   "<<i->second);
+	      Path npath=path;
+	      npath.push(i->first,i->second);
+	      pathSet.insert(npath);
+	    }
+	}
+
+
+      tries++;
+    }
+
+
+  return result;
+
+}
+
+std::vector<AGVector2> Pathfinder::refinePath(const std::vector<AGVector2> &p,MapPathWeighter *pWeighter)
+{
+  std::vector<AGVector2> result=p;
+  
+  if(result.size()<3)
+    return result;
+
+  std::vector<AGVector2>::iterator i=result.begin()+1;
+
+  for(;i!=result.end()-1;)
+    {
+      // check if waypoint is discardable
+      AGVector2 a=*(i-1);
+      AGVector2 b=*i;
+      AGVector2 c=*(i+1);
+
+      float w0=pWeighter->weight(a,b);
+      float w1=pWeighter->weight(b,c);
+      float w2=pWeighter->weight(a,c);
+
+      cdebug("WEIGHTS:"<<w0<<"  "<<w1<<"  "<<w2);
+
+      if(w0+w1>w2)
+	i=result.erase(i);
+      else
+	i++;
+    }
+
+
+  return result;
+}

Added: antargis/branches/rant/ext/game/path.h
===================================================================
--- antargis/branches/rant/ext/game/path.h	2007-06-23 16:54:17 UTC (rev 1107)
+++ antargis/branches/rant/ext/game/path.h	2007-06-23 16:55:08 UTC (rev 1108)
@@ -0,0 +1,265 @@
+#ifndef PATH_H
+#define PATH_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include "height_map.h"
+#include "heuristic.h"
+
+#include <ag_surface.h>
+
+/**
+   This file is WORK-IN-PROGRESS !!!!!!!!!!!!!!!!!!!!!!
+
+   The purpose is some path-finding-algorithm based upon "A-star". (A*)
+   
+   Because path-finding is a somewhat hard topic, we should try some
+   hierarchical approach:
+   * build some graph out of the height-map - weight come from height and terrain-type (swamp and deep sand vs. plain grass)
+   * nodes that are near each other get eliminated (thrown together), if terrain connection is possible (and too much longer)
+   * several levels of this graph can be used, according to the distance that has to be gone
+   * for people that have boats, water can be crossed, so there has to be a different path-graph !
+
+*/
+
+class Heuristic;
+
+class PathWeighter:public AGRubyObject
+{
+ public:
+  virtual ~PathWeighter();
+  virtual float weight(float h0,float h1);
+};
+
+class MapPathWeighter:public PathWeighter
+{
+ public:
+  MapPathWeighter(HeightMap *pMap);
+  virtual float weight(const AGVector2 &a,const AGVector2 &b);
+  virtual bool accessible(const AGVector2 &a);
+ private:
+
+  virtual float complexWeight(const AGVector2 &a,const AGVector2 &b);
+  virtual float weightHeight(float a,float b) const;
+
+  HeightMap *mMap;
+};
+
+
+struct AGVector2Sort
+{
+  public:
+  bool operator()(const AGVector2 &a,const AGVector2 &b)
+  {
+    return a[0]<b[0] || (a[0]==b[0] && a[1]<b[1]);
+  }
+};
+
+
+class SimpleGraph:public AGRubyObject
+{
+ public:
+  struct Node;
+  struct Edge;
+
+  typedef std::list<Edge*> Edges;
+  typedef std::list<Node*> Nodes;
+
+  class NodePtrCompare
+  {
+  public:
+    bool operator()(const Node *a,const Node *b);
+  };
+    
+  class EdgePtrCompare
+  {
+  public:
+    bool operator()(const Edge *a,const Edge *b);
+  };
+
+  // only used for processing and not for storing !
+  struct HalfEdge
+  {
+    Node *a,*b;
+    float w;
+  };
+  struct Edge
+  {
+    Node *a,*b;
+    float w0,w1;
+
+    Edge(Node *pa,Node *pb,float p0,float p1);
+    ~Edge();
+
+    bool operator<(const Edge &e) const;
+    float maxWeight() const;
+
+    Node *getOther(Node *n);
+
+    /*
+    HalfEdge *getHalfEdgeFrom(Node *n);
+
+    HalfEdge *getHalfEdgeTo(Node *n);
+    */
+  };
+
+  struct Node
+  {
+    AGVector2 p;
+    Edges edges;
+    typedef std::map<Node*,float,NodePtrCompare> NodeMap;
+    
+    ~Node();
+
+    NodeMap getNextNodes();
+  };
+
+  struct EdgeSort
+  {
+    public:
+    bool operator()(const Edge*a,const Edge *b)
+    {
+      float w0=weight(a);
+      float w1=weight(b);
+      return w0<w1 || (w0==w1 && a<b);
+    }
+    private:
+    float weight(const Edge *a)
+    {
+      return a->w0+a->w1;
+    }
+  };
+
+  SimpleGraph();
+  
+
+  Node *addNode(const AGVector2 &p);
+  /**
+     @param w0 is weight of going from a to b
+     @param w1 is weight of goinf from b to a
+  */
+  Edge *addEdge(Node *a,Node *b,float w0,float w1);
+
+  void removeEdge(Edge *e);
+  void removeNode(Node *n);
+  void print();
+  void printInfo();
+
+  ~SimpleGraph();
+
+
+  void check();
+  
+
+  Node *findNearest(const AGVector2 &p);
+  AGVector2 findNearestVector(const AGVector2 &p);
+
+  float width() const;
+
+  size_t size() const;
+
+  void paint(const AGRect2& r,AGPaintTarget &t,Heuristic &heuristic);
+  void paintNode(const AGRect2& r,AGPaintTarget &t,const AGVector2 &p,const AGColor &c);
+
+
+ protected:
+
+  Node *findNode(const AGVector2 &p);
+
+  // FIXME: quadtree out of nodes !!!
+
+  typedef std::map<AGVector2,Node*,AGVector2Sort> NodeMap;
+  typedef std::set<Node*,NodePtrCompare> NodeSet;
+  typedef std::set<Edge*,EdgeSort> EdgeSet;
+  NodeMap mNodeMap;
+  NodeSet mNodes;
+  EdgeSet mEdges;
+  float mWidth;
+
+
+  friend HeuristicFunction *computeHeuristic(SimpleGraph *g);
+
+};
+
+SimpleGraph *makeGraph(HeightMap *pMap, MapPathWeighter *pWeighter,size_t res=1);
+HeuristicFunction *computeHeuristic(SimpleGraph *g);
+
+
+class DecimatedGraph:public SimpleGraph
+{
+ public:
+  DecimatedGraph()
+    {
+    }
+  DecimatedGraph(const SimpleGraph &g):SimpleGraph(g)
+    {
+    }
+  void decimate(float amount,MapPathWeighter *pWeighter);
+ private:
+  void tryRemove(Edge *e,MapPathWeighter *pWeighter);
+  void collapseEdge(Edge *e,MapPathWeighter *pWeighter);
+
+  Edge makeEdge(Node *a,Node *b,MapPathWeighter *pWeighter);
+
+};
+
+struct Path;
+
+class Heuristic
+{
+  AGVector2 to;
+  HeuristicFunction *p;
+ public:
+  Heuristic(const AGVector2 &pTo,HeuristicFunction *f):to(pTo),p(f)
+    {
+    }
+  bool operator()(const Path &a,const Path &b);
+  float distance(const AGVector2&from);
+};
+
+struct Path:public std::list<SimpleGraph::Node*>
+{
+  float weight;
+  
+  Path();
+  
+  float getWeight(Heuristic *h) const;
+  
+  void push(SimpleGraph::Node *n,float w);
+  
+  void paint(const AGRect2 &r,AGPaintTarget &t,float scale);
+  
+};
+
+
+class PathDebugging
+{
+ public:
+  virtual ~PathDebugging()
+    {
+    }
+  virtual void debugPath(Path &p,float heuristic)
+  {
+  }
+};
+  
+
+class Pathfinder:public AGRubyObject
+{
+ public:
+
+  Pathfinder(SimpleGraph *pGraph,HeuristicFunction *pHeuristic,PathDebugging *pDebugger=0);
+
+  virtual void mark();
+
+  std::vector<AGVector2> computePath(const AGVector2 &from, const AGVector2 &to);
+
+  std::vector<AGVector2> refinePath(const std::vector<AGVector2> &p,MapPathWeighter *pWeighter);
+
+ private:
+  SimpleGraph *mGraph;
+  HeuristicFunction *mHeuristic;
+  PathDebugging *mDebug;
+};
+
+#endif



From davidkamphausen at mail.berlios.de  Sat Jun 23 21:26:46 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 23 Jun 2007 21:26:46 +0200
Subject: [Antargis-svn] r1109 - in antargis/branches/rant: build
	ext/3dengine ext/basic ext/game ext/math ruby ruby/entities
Message-ID: <200706231926.l5NJQkox025763@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-23 21:26:45 +0200 (Sat, 23 Jun 2007)
New Revision: 1109

Modified:
   antargis/branches/rant/build/create_interface_new.rb
   antargis/branches/rant/build/std_list.i
   antargis/branches/rant/ext/3dengine/ant_camera.h
   antargis/branches/rant/ext/3dengine/ant_projection.cc
   antargis/branches/rant/ext/3dengine/ant_projection.h
   antargis/branches/rant/ext/3dengine/headers.hh
   antargis/branches/rant/ext/basic/ag_rubyobj.cc
   antargis/branches/rant/ext/game/headers.hh
   antargis/branches/rant/ext/game/map.cc
   antargis/branches/rant/ext/game/map.h
   antargis/branches/rant/ext/game/path.cc
   antargis/branches/rant/ext/game/path.h
   antargis/branches/rant/ext/game/templates.i
   antargis/branches/rant/ext/math/ant_frustum.cc
   antargis/branches/rant/ext/math/ant_frustum.h
   antargis/branches/rant/ext/math/headers.hh
   antargis/branches/rant/ruby/entities/ant_fire.rb
   antargis/branches/rant/ruby/map.rb
   antargis/branches/rant/ruby/view.rb
Log:
* some more patches


Modified: antargis/branches/rant/build/create_interface_new.rb
===================================================================
--- antargis/branches/rant/build/create_interface_new.rb	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/build/create_interface_new.rb	2007-06-23 19:26:45 UTC (rev 1109)
@@ -165,23 +165,23 @@
 				end
 			}
 		end
-		puts "-------------------------"
-		puts "CLASSLIST:"
-		puts @classList
-
-		puts "-------------------------"
-		puts "RUBY CLASSLIST:"
-		puts @rubyClasses
-
-		puts "-------------------------"
-		puts "DERIVATIONS:"
-			@deriveList.each {|x,y|
-				puts "#{x} #{y} #{@class2File[x]} "
-			}
-		puts "-------------------------"
-		puts "my ruby:"
-		puts getMyRubyClasses
-		puts "-------------------------"
+# 		puts "-------------------------"
+# 		puts "CLASSLIST:"
+# 		puts @classList
+# 
+# 		puts "-------------------------"
+# 		puts "RUBY CLASSLIST:"
+# 		puts @rubyClasses
+# 
+# 		puts "-------------------------"
+# 		puts "DERIVATIONS:"
+# 			@deriveList.each {|x,y|
+# 				puts "#{x} #{y} #{@class2File[x]} "
+# 			}
+# 		puts "-------------------------"
+# 		puts "my ruby:"
+# 		puts getMyRubyClasses
+# 		puts "-------------------------"
 	end
 
 	def initLevels

Modified: antargis/branches/rant/build/std_list.i
===================================================================
--- antargis/branches/rant/build/std_list.i	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/build/std_list.i	2007-06-23 19:26:45 UTC (rev 1109)
@@ -424,7 +424,7 @@
             }
 		
             void each() {
-		for(std::list<T*>::iterator i=self->begin();i!=self->end();i++) // with ptr2
+		for(std::list<T>::iterator i=self->begin();i!=self->end();i++) // with ptr2
                     rb_yield(CONVERT_TO(&(*i));
             }
         }

Modified: antargis/branches/rant/ext/3dengine/ant_camera.h
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_camera.h	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ext/3dengine/ant_camera.h	2007-06-23 19:26:45 UTC (rev 1109)
@@ -21,6 +21,8 @@
 #ifndef ANT_CAMERA_H
 #define ANT_CAMERA_H
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #include <GLee.h>
 
 #include <ant_frustum.h>

Modified: antargis/branches/rant/ext/3dengine/ant_projection.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_projection.cc	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ext/3dengine/ant_projection.cc	2007-06-23 19:26:45 UTC (rev 1109)
@@ -1,8 +1,14 @@
 #include "ant_projection.h"
+#include <ag_debug.h>
 
 #include <GL/glu.h>
 
 
+AntProjection::AntProjection()
+{
+  cdebug("Possible Error: AntProjection not initialized!");
+}
+
 AntProjection::AntProjection(const AGMatrix4 &pMv,const AGMatrix4 &pPr,const Viewport &pVp):
   modelview(pMv),projection(pPr),viewport(pVp)
 {

Modified: antargis/branches/rant/ext/3dengine/ant_projection.h
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_projection.h	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ext/3dengine/ant_projection.h	2007-06-23 19:26:45 UTC (rev 1109)
@@ -1,6 +1,8 @@
 #ifndef ANT_PROJECTION_H
 #define ANT_PROJECTION_H
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #include <GLee.h>
 
 #include <ant_frustum.h>
@@ -20,6 +22,7 @@
 class AntProjection
 {
  public:
+  AntProjection();
   AntProjection(const AGMatrix4 &pMv,const AGMatrix4 &pPr,const Viewport &pVp);
 
   AGVector3 project(const AGVector3 &p) const;

Modified: antargis/branches/rant/ext/3dengine/headers.hh
===================================================================
--- antargis/branches/rant/ext/3dengine/headers.hh	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ext/3dengine/headers.hh	2007-06-23 19:26:45 UTC (rev 1109)
@@ -31,9 +31,12 @@
 #include "/home/david/projects/antargis/rant/ext/3dengine/anim_mesh_data.h"
 #include "/home/david/projects/antargis/rant/ext/3dengine/mesh.h"
 #include "/home/david/projects/antargis/rant/ext/3dengine/mesh_2d.h"
+#include "/home/david/projects/antargis/rant/ext/3dengine/ant_particle.h"
 #include "/home/david/projects/antargis/rant/ext/3dengine/scene.h"
 #include "/home/david/projects/antargis/rant/ext/3dengine/anim_mesh.h"
+#include "/home/david/projects/antargis/rant/ext/3dengine/ant_camera.h"
 #include "/home/david/projects/antargis/rant/ext/3dengine/mesh_optimizer.h"
+#include "/home/david/projects/antargis/rant/ext/3dengine/ant_projection.h"
 #ifdef SWIG
 %include "/home/david/projects/antargis/rant/ext/3dengine/mesh_data.h"
 %include "/home/david/projects/antargis/rant/ext/3dengine/scene_base.h"
@@ -42,8 +45,11 @@
 %include "/home/david/projects/antargis/rant/ext/3dengine/anim_mesh_data.h"
 %include "/home/david/projects/antargis/rant/ext/3dengine/mesh.h"
 %include "/home/david/projects/antargis/rant/ext/3dengine/mesh_2d.h"
+%include "/home/david/projects/antargis/rant/ext/3dengine/ant_particle.h"
 %include "/home/david/projects/antargis/rant/ext/3dengine/scene.h"
 %include "/home/david/projects/antargis/rant/ext/3dengine/anim_mesh.h"
+%include "/home/david/projects/antargis/rant/ext/3dengine/ant_camera.h"
 %include "/home/david/projects/antargis/rant/ext/3dengine/mesh_optimizer.h"
+%include "/home/david/projects/antargis/rant/ext/3dengine/ant_projection.h"
 #endif
 #endif

Modified: antargis/branches/rant/ext/basic/ag_rubyobj.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_rubyobj.cc	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ext/basic/ag_rubyobj.cc	2007-06-23 19:26:45 UTC (rev 1109)
@@ -22,6 +22,10 @@
   mDeleted=false;
   gExistingRubies.insert(this);
   mRUBY=0;
+#ifdef GCDEBUG
+  printf("NEW ME:%lx\n",this);
+#endif
+  
 }
 AGRubyObject::~AGRubyObject()
 {
@@ -31,7 +35,7 @@
 
   //  cdebug("DEL:"<<mRUBY);
 #ifdef GCDEBUG
-  printf("DEL:%lx  %s\n",mRUBY,mObjName.c_str());
+  printf("DEL:%lx  %s (me:%lx)\n",mRUBY,mObjName.c_str(),this);
 #endif
   mDeleted=true;
   gExistingRubies.erase(this);

Modified: antargis/branches/rant/ext/game/headers.hh
===================================================================
--- antargis/branches/rant/ext/game/headers.hh	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ext/game/headers.hh	2007-06-23 19:26:45 UTC (rev 1109)
@@ -103,6 +103,7 @@
 #include "ext/3dengine/mesh_2d_data.h"
 #include "ext/3dengine/ant_projection.h"
 #include "ext/3dengine/ag_glsl.h"
+#include "ext/3dengine/ant_particle.h"
 #include "/home/david/projects/antargis/rant/ext/game/path.h"
 #include "/home/david/projects/antargis/rant/ext/game/terrain.h"
 #include "/home/david/projects/antargis/rant/ext/game/entity.h"

Modified: antargis/branches/rant/ext/game/map.cc
===================================================================
--- antargis/branches/rant/ext/game/map.cc	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ext/game/map.cc	2007-06-23 19:26:45 UTC (rev 1109)
@@ -218,22 +218,25 @@
 {
   return mEntities;
 }
+/*
 std::vector<AntEntityPtr> AntMap::getAllEntitiesV()
 {
   std::vector<AntEntityPtr> v;
   std::copy(mEntities.begin(),mEntities.end(),std::back_inserter(v));
   return v;
 }
-std::vector<AntEntityPtr> AntMap::getEntities(const AGString &pName)
+*/
+
+std::vector<AntEntity*> AntMap::getEntities(const AGString &pName)
 {
-  std::vector<AntEntityPtr> v;
+  std::vector<AntEntity*> v;
   for(EntityList::iterator i=mEntities.begin();i!=mEntities.end();i++)
     if((*i)->provides(pName))
       v.push_back(*i);
   return v;
 }
 
-std::vector<AntEntityPtr> AntMap::getNextList(AntEntity *me,const AGString &pType,size_t atLeast)
+std::vector<AntEntity*> AntMap::getNextList(AntEntity *me,const AGString &pType,size_t atLeast)
 {
   //  assert(mHeuristicFunction);
 
@@ -264,7 +267,7 @@
         }
     }
 
-  std::vector<AntEntityPtr> vec;
+  std::vector<AntEntity*> vec;
 
   // take one of the nearest, but no farer away than 30% of nearest
   //  AntEntity *e=0;

Modified: antargis/branches/rant/ext/game/map.h
===================================================================
--- antargis/branches/rant/ext/game/map.h	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ext/game/map.h	2007-06-23 19:26:45 UTC (rev 1109)
@@ -62,7 +62,7 @@
   EntityList getAllEntities();
 //  std::vector<AntEntityPtr> getAllEntitiesV();
 //  std::vector<AntEntityPtr> getEntities(const AGString &pName);
-  std::vector<AntEntity*> getAllEntitiesV();
+//  std::vector<AntEntity*> getAllEntitiesV();
   std::vector<AntEntity*> getEntities(const AGString &pName);
 
   AntEntity *getEntity(const Mesh &pMesh);

Modified: antargis/branches/rant/ext/game/path.cc
===================================================================
--- antargis/branches/rant/ext/game/path.cc	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ext/game/path.cc	2007-06-23 19:26:45 UTC (rev 1109)
@@ -244,10 +244,25 @@
 
 SimpleGraph::SimpleGraph()
 {
+  CTRACE;
   mWidth=0.00001;
 }
 
+SimpleGraph::SimpleGraph(const SimpleGraph &g)
+{
+  mWidth=g.mWidth;
 
+  std::map<Node*,Node*> nodemap;
+  for(NodeMap::const_iterator i=g.mNodeMap.begin();i!=g.mNodeMap.end();i++)
+    {
+      nodemap[i->second]=addNode(i->first);
+    }
+  for(EdgeSet::const_iterator i=g.mEdges.begin();i!=g.mEdges.end();i++)
+    addEdge(nodemap[(*i)->a],nodemap[(*i)->b],(*i)->w0,(*i)->w1);
+}
+
+
+
 SimpleGraph::Node *SimpleGraph::addNode(const AGVector2 &p)
 {
   Node *n=findNode(p);
@@ -371,6 +386,7 @@
 
 SimpleGraph::~SimpleGraph()
 {
+  CTRACE;
   for(NodeSet::iterator i=mNodes.begin();i!=mNodes.end();i++)
     delete *i;
   for(EdgeSet::iterator i=mEdges.begin();i!=mEdges.end();i++)
@@ -455,6 +471,25 @@
   }
 };
 
+
+DecimatedGraph::DecimatedGraph()
+{
+  CTRACE;
+}
+
+DecimatedGraph::DecimatedGraph(const SimpleGraph &g):SimpleGraph(g)
+{
+  CTRACE;
+  cdebug("old:"<<(&g));
+}
+
+DecimatedGraph::~DecimatedGraph()
+{
+  CTRACE;
+}
+
+
+
 void DecimatedGraph::decimate(float amount,MapPathWeighter *pWeighter)
 {
   size_t m=(size_t)(mNodes.size()*(1.0-amount));
@@ -747,6 +782,8 @@
   mGraph(pGraph),mHeuristic(pHeuristic),
   mDebug(d)
 {
+  CTRACE;
+  cdebug("Simplegraph:"<<mGraph);
 }
 
 void Pathfinder::mark()

Modified: antargis/branches/rant/ext/game/path.h
===================================================================
--- antargis/branches/rant/ext/game/path.h	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ext/game/path.h	2007-06-23 19:26:45 UTC (rev 1109)
@@ -131,7 +131,7 @@
   };
 
   SimpleGraph();
-  
+  SimpleGraph(const SimpleGraph &g);
 
   Node *addNode(const AGVector2 &p);
   /**
@@ -188,12 +188,9 @@
 class DecimatedGraph:public SimpleGraph
 {
  public:
-  DecimatedGraph()
-    {
-    }
-  DecimatedGraph(const SimpleGraph &g):SimpleGraph(g)
-    {
-    }
+  DecimatedGraph();
+  DecimatedGraph(const SimpleGraph &g);
+  ~DecimatedGraph();
   void decimate(float amount,MapPathWeighter *pWeighter);
  private:
   void tryRemove(Edge *e,MapPathWeighter *pWeighter);

Modified: antargis/branches/rant/ext/game/templates.i
===================================================================
--- antargis/branches/rant/ext/game/templates.i	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ext/game/templates.i	2007-06-23 19:26:45 UTC (rev 1109)
@@ -16,8 +16,8 @@
 
 namespace std
 {
-	specialize_std_vector(AntEntity*,SWIG_ANTENTITY_P,SWIG_RB2AntEntity,SWIG_AntEntity2RB);
-	specialize_std_list(AntEntity*,SWIG_ANTENTITY_P,SWIG_RB2AntEntity,SWIG_AntEntity2RB);
+	specialize_std_vector(AntEntity,SWIG_ANTENTITY_P,SWIG_RB2AntEntity,SWIG_AntEntity2RB);
+	specialize_std_list(AntEntity,SWIG_ANTENTITY_P,SWIG_RB2AntEntity,SWIG_AntEntity2RB);
 }
 
 

Modified: antargis/branches/rant/ext/math/ant_frustum.cc
===================================================================
--- antargis/branches/rant/ext/math/ant_frustum.cc	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ext/math/ant_frustum.cc	2007-06-23 19:26:45 UTC (rev 1109)
@@ -48,6 +48,11 @@
 /////////////////////////////////////////////////////////////////////
 // AntFrustum
 /////////////////////////////////////////////////////////////////////
+AntFrustum::AntFrustum()
+{
+	throw std::runtime_error("Possible error in AntFrustum::AntFrustum(): this function shouldn't be called!");
+}
+
 AntFrustum::AntFrustum(const std::vector<AntPlane> &pPlanes):
   mPlanes(pPlanes)
 {

Modified: antargis/branches/rant/ext/math/ant_frustum.h
===================================================================
--- antargis/branches/rant/ext/math/ant_frustum.h	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ext/math/ant_frustum.h	2007-06-23 19:26:45 UTC (rev 1109)
@@ -18,6 +18,8 @@
  * License along with this program.
  */
 
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
 #ifndef ANT_FRUSTUM_H
 #define ANT_FRUSTUM_H
 
@@ -42,6 +44,7 @@
 class AntFrustum
 {
  public:
+  AntFrustum();
   AntFrustum(const std::vector<AntPlane> &pPlanes);
 
   bool inside(const AGVector3 &v) const;

Modified: antargis/branches/rant/ext/math/headers.hh
===================================================================
--- antargis/branches/rant/ext/math/headers.hh	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ext/math/headers.hh	2007-06-23 19:26:45 UTC (rev 1109)
@@ -26,10 +26,12 @@
 #include "ext/basic/ag_mutex.h"
 #include "/home/david/projects/antargis/rant/ext/math/ag_rand.h"
 #include "/home/david/projects/antargis/rant/ext/math/ag_geometry.h"
+#include "/home/david/projects/antargis/rant/ext/math/ant_frustum.h"
 #include "/home/david/projects/antargis/rant/ext/math/ag_algebra.h"
 #ifdef SWIG
 %include "/home/david/projects/antargis/rant/ext/math/ag_rand.h"
 %include "/home/david/projects/antargis/rant/ext/math/ag_geometry.h"
+%include "/home/david/projects/antargis/rant/ext/math/ant_frustum.h"
 %include "/home/david/projects/antargis/rant/ext/math/ag_algebra.h"
 #endif
 #endif

Modified: antargis/branches/rant/ruby/entities/ant_fire.rb
===================================================================
--- antargis/branches/rant/ruby/entities/ant_fire.rb	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ruby/entities/ant_fire.rb	2007-06-23 19:26:45 UTC (rev 1109)
@@ -4,9 +4,9 @@
 		mp=AGVector3.new(0,0,0)
 		setMesh(:on)
 		if MyAntargislib.opengl
-			@smokeMesh=Smoke.new(getMap.getScene,4)
+			@smokeMesh=AntParticle.new(getMap.getScene,4)
 			addMesh(@smokeMesh,mp)
-			smoke=Smoke.new(getMap.getScene,40)
+			smoke=AntParticle.new(getMap.getScene,40)
 			smoke.setFire(true)
 			smoke.setMaxTime(0.8)
 			addMesh(smoke,mp)

Modified: antargis/branches/rant/ruby/map.rb
===================================================================
--- antargis/branches/rant/ruby/map.rb	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ruby/map.rb	2007-06-23 19:26:45 UTC (rev 1109)
@@ -178,10 +178,10 @@
 	#end
 
 	def getHeroes()
-		ents=getAllEntitiesV
+		ents=getAllEntities
 		ret=[]
 		ents.each{|eptr|
-			ent=eptr.get
+			ent=eptr
 			#dputs ent
 			if ent.class==AntHero
 				ret.push(ent)

Modified: antargis/branches/rant/ruby/view.rb
===================================================================
--- antargis/branches/rant/ruby/view.rb	2007-06-23 16:55:08 UTC (rev 1108)
+++ antargis/branches/rant/ruby/view.rb	2007-06-23 19:26:45 UTC (rev 1109)
@@ -166,7 +166,7 @@
 		return true
 	end
 	def checkMove(t)
-		if getMain.fullscreen
+		if getVideo.fullscreen
 			p=@mousepos
 			m=0
 			w=20



From davidkamphausen at mail.berlios.de  Sat Jun 23 21:27:49 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 23 Jun 2007 21:27:49 +0200
Subject: [Antargis-svn] r1110 - antargis/branches/rant/ext/3dengine
Message-ID: <200706231927.l5NJRnAN025877@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-23 21:27:48 +0200 (Sat, 23 Jun 2007)
New Revision: 1110

Added:
   antargis/branches/rant/ext/3dengine/ant_particle.cc
   antargis/branches/rant/ext/3dengine/ant_particle.h
Log:
* missing files added


Added: antargis/branches/rant/ext/3dengine/ant_particle.cc
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_particle.cc	2007-06-23 19:26:45 UTC (rev 1109)
+++ antargis/branches/rant/ext/3dengine/ant_particle.cc	2007-06-23 19:27:48 UTC (rev 1110)
@@ -0,0 +1,194 @@
+#include "ant_renderer.h"
+#include "scene.h"
+#include "ant_particle.h"
+#include "ag_texturecache.h"
+#include "ag_rendercontext.h"
+#include "ag_main.h"
+#include "map.h"
+#include "ag_config.h"
+#include "ag_profiler.h"
+
+static bool gParticle=true;
+static long lastParticleTest=0;
+
+// small caching fct, so that lookup is not that long???
+bool particleEnabled()
+{
+  long ts=getMain()->getTicks();
+  if(getMain()->getTicks()-lastParticleTest>1000)
+    {
+      gParticle=getConfig()->get("particleEffects")!="false";
+      lastParticleTest=ts;
+      getConfig()->set("particleEffects",gParticle?"true":"false");
+    }
+
+  return gParticle;
+}
+
+float randf()
+{
+  return (rand()%10000)/10000.0;
+}
+
+AntParticle::AntParticle(Scene *pScene,float f):
+  SceneNode(pScene,AGVector4(),AGBox3(AGVector3(-0.5,-0.5,0),AGVector3(1,1,10)))
+{
+  maxtime=20;
+
+  mtime=0;
+  freq=f;
+  stime=1/freq;
+  if(videoInited())
+    mTexture=getTextureCache()->get("data/textures/point.png");
+  fire=false;
+  setOrder(PARTICLE_Z);
+  enabled=true;
+}
+
+void AntParticle::setFire(bool f)
+{
+  fire=f;
+}
+
+void AntParticle::setMaxTime(float m)
+{
+  maxtime=m;
+}
+
+void AntParticle::advance(float time)
+{
+  STACKTRACE;
+  if(!particleEnabled())
+    return;
+  //  return;
+  // advance pieces
+  for(std::list<Piece*>::iterator i=mPieces.begin();i!=mPieces.end();i++)
+    {
+      (*i)->lived+=time;
+      // move
+      (*i)->pos+=(*i)->speed*time;
+    }
+  // delete old pieces
+  while(mPieces.size())
+    {
+      if(mPieces.back()->lived>maxtime)
+	{
+	  delete mPieces.back();
+	  mPieces.pop_back();
+	}
+      else
+	break;
+    }
+
+  if(!enabled)
+    return;
+
+  // create new piece
+  mtime+=time;
+
+  float timevar=1;
+
+  if(mtime>stime)
+    {
+      Piece *ps=new Piece;
+
+      if(fire)
+	{
+	  ps->pos=getPos().dim3();
+	  ps->lived=-timevar*randf();
+	  ps->light=randf()*0.8+0.2;//5+0.5;
+	  ps->size=randf()*0.05+0.1;
+	  ps->speed=AGVector3(randf()*0.4-0.2,0,1+randf()*0.5);
+	  ps->color=AGVector3(1,1,0);
+	}
+      else
+	{
+	  ps->pos=getPos().dim3();
+	  ps->lived=-timevar*randf();
+	  ps->light=randf()*0.2+0.2;//5+0.5;
+	  ps->size=randf()*0.1+0.2;
+	  ps->speed=AGVector3(randf()*0.01,0,0.2+randf()*0.1);
+	  ps->color=AGVector3(1,1,1);
+	}
+      mPieces.push_front(ps);
+      mtime-=stime;
+	  
+    }
+}
+
+void AntParticle::draw()
+{
+  STACKTRACE;
+
+  if(!particleEnabled())
+    return;
+
+  AGVector3 dir=getRenderer()->getCurrentScene()->getCameraDirTo(getPos().dim3());
+
+  AGVector3 pdown(0,0,-1);
+  AGVector3 side=dir%pdown;
+  AGVector3 up=side%dir;
+
+  side.normalize();
+  up.normalize();
+
+  AGRenderContext c;
+  c.setAlpha(0,GL_NONE);
+  c.setDepthWrite(false);
+  c.setTexture(mTexture.glTexture());
+  c.setColor(AGVector4(1,1,1,1));
+  c.begin();
+
+  glBegin(GL_QUADS);
+
+  float a,s,l;
+  AGVector4 color;
+
+  for(std::list<Piece*>::iterator i=mPieces.begin();i!=mPieces.end();i++)
+    {
+      a=1;
+      if(!fire)
+	if((*i)->lived<1)
+	  a=(*i)->lived;
+      
+      a=std::min(maxtime-(*i)->lived,a);
+
+      l=(*i)->light;
+      s=(*i)->size;
+      color=AGVector4((*i)->color[0]*l,(*i)->color[1]*l,(*i)->color[2]*l,a);
+      if(fire)
+	{
+	  float x=maxtime/(*i)->lived;
+	  x=std::max(std::min(x,1.0f),0.0f);
+	  (*i)->color=AGVector3(1,0,0)*x+AGVector3(1,1,0)*(1-x);
+	}
+      else
+	{
+	  if((*i)->lived<3)
+	    s*=(*i)->lived/3;
+	}
+      glColor4fv(color);
+      glTexCoord2f(0,0);
+      glVertex3fv((*i)->pos+(AGVector3(0,0,0)-side+up)*s);
+
+      glColor4fv(color);
+      glTexCoord2f(1,0);
+      glVertex3fv((*i)->pos+(side+up)*s);
+
+      glColor4fv(color);
+      glTexCoord2f(1,1);
+      glVertex3fv((*i)->pos+(side-up)*s);
+      
+      glColor4fv(color);
+      glTexCoord2f(0,1);
+      glVertex3fv((*i)->pos+(AGVector3(0,0,0)-side-up)*s);
+
+    }
+  glEnd();
+  
+}
+
+void AntParticle::setEnabled(bool f)
+{
+  enabled=f;
+}

Added: antargis/branches/rant/ext/3dengine/ant_particle.h
===================================================================
--- antargis/branches/rant/ext/3dengine/ant_particle.h	2007-06-23 19:26:45 UTC (rev 1109)
+++ antargis/branches/rant/ext/3dengine/ant_particle.h	2007-06-23 19:27:48 UTC (rev 1110)
@@ -0,0 +1,62 @@
+#ifndef ANT_PARTICLE_H
+#define ANT_PARTICLE_H
+
+// INCLUDE_SWIG - used to filter, which files are included in swig-interfacing
+
+#include "scenenode.h"
+#include "ag_texture.h"
+
+/**
+   some very simple particle engine for displaying
+   smoke and ugly fire.
+*/
+class AntParticle:public SceneNode
+{
+  /// this represents one single particle
+  struct Piece
+  {
+    AGVector3 pos;
+    AGVector3 speed;
+    AGVector3 color;
+    float lived;
+    float light;
+    float size;
+    
+  };
+
+  std::list<Piece*> mPieces;
+  float maxtime,freq;
+  float mtime;
+  float stime;
+  bool fire;
+  bool enabled;
+
+  AGTexture mTexture;
+
+
+ public:
+  /// make some smoke (or fire) in Scene pScene with output frequency f
+  AntParticle(Scene *pScene,float f);
+  /// if f is true this object will display a fire - otherwise it's smoke
+  /// default is smoke
+  void setFire(bool f);
+  /// maximal time for a particle to live
+  void setMaxTime(float m);
+
+  /// advance the smoke-particles; generate new ones; discard old ones
+  void advance(float time);
+
+  /// let Scene take care of drawing order for transparency
+  virtual bool transparent()
+  {
+    return true;
+  }
+
+  void draw();
+
+  /// disable the generation of new particles (smoke will fade slowly)
+  void setEnabled(bool f);
+
+};
+
+#endif



From davidkamphausen at mail.berlios.de  Sat Jun 23 21:29:01 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 23 Jun 2007 21:29:01 +0200
Subject: [Antargis-svn] r1111 - antargis/branches/rant
Message-ID: <200706231929.l5NJT1UO026039@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-23 21:29:00 +0200 (Sat, 23 Jun 2007)
New Revision: 1111

Removed:
   antargis/branches/rant/bak/
Log:
* del it!




From davidkamphausen at mail.berlios.de  Sat Jun 23 21:30:25 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 23 Jun 2007 21:30:25 +0200
Subject: [Antargis-svn] r1112 - in antargis/branches/rant: . build
Message-ID: <200706231930.l5NJUP8F026217@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-23 21:30:24 +0200 (Sat, 23 Jun 2007)
New Revision: 1112

Modified:
   antargis/branches/rant/Rantfile
   antargis/branches/rant/build/create_interface.rb
Log:
* small update


Modified: antargis/branches/rant/Rantfile
===================================================================
--- antargis/branches/rant/Rantfile	2007-06-23 19:29:00 UTC (rev 1111)
+++ antargis/branches/rant/Rantfile	2007-06-23 19:30:24 UTC (rev 1112)
@@ -204,7 +204,7 @@
 	list
 }
 gen Rule, /^.*interface.i$/ => interfaceSrc do |t|
-	sys "ruby build/create_interface_new.rb -d=#{getDir(sys.expand_path(t.name))} -i=#{importsForInterface(t.name)}"
+	sys "ruby build/create_interface.rb -d=#{getDir(sys.expand_path(t.name))} -i=#{importsForInterface(t.name)}"
 end
 #
 ###########################################

Modified: antargis/branches/rant/build/create_interface.rb
===================================================================
--- antargis/branches/rant/build/create_interface.rb	2007-06-23 19:29:00 UTC (rev 1111)
+++ antargis/branches/rant/build/create_interface.rb	2007-06-23 19:30:24 UTC (rev 1112)
@@ -22,30 +22,53 @@
 require 'build/interface_template.rb'
 require 'build/base_tools.rb'
 
-outputDir=Dir.pwd # default
-swigInput=""
+class MyInput
+	attr_reader :swigInput, :outputDir
+	def initialize
+		@outputDir=Dir.pwd # default
+		@swigInput=""
+	
 
+		ARGV.each{|a|
+			case a
+				when /^-d=/
+					# in- and output dir
+					@outputDir=a[3..-1]
+				when /^-i=/
+					@swigInput=a[3..-1]
+				when /^-h/, /^--help/
+					@help=true
+					puts "Arguments:"
+					puts " -h, --help     print this help"
+					puts " -d=<DIR>       define output-directory"
+					puts " -i=<SWIGFILE>  define SWIG-input-file (swig.h) - can be set multiple times"
+			end
+		}
 
-ARGV.each{|a|
-	case a
-		when /^-d=/
-			# in- and output dir
-			outputDir=a[3..-1]
-		when /^-i=/
-			swigInput=a[3..-1]
-		when /^-h/, /^--help/
-			puts "Arguments:"
-			puts " -h, --help     print this help"
-			puts " -d=<DIR>       define output-directory"
-			puts " -i=<SWIGFILE>  define SWIG-input-file (swig.h) - can be set multiple times"
+		@swigInput=@swigInput.split(":")
 	end
-}
 
-swigInput=swigInput.split(":")
+	def valid
+		@outputDir!="" && @help.nil?
+	end
 
-puts "DIR:"
-puts outputDir
-#exit
+	def interfaceName
+		name=@outputDir+Dir.separator+"interface.i"
+		puts "INTERFACENAME:",name
+		name
+	end
+
+	def moduleName
+		moduleName=makeLibName(@outputDir)
+	end
+	def headersName
+		@outputDir+Dir.separator+"/headers.hh"
+	end
+	def markerName
+		@outputDir+Dir.separator+"marker.i"
+	end
+end
+
 class MClass
   def initialize(name,superClass)
     @name=name
@@ -53,6 +76,13 @@
   end
 end
 
+class SimpleParser
+	@mclasses=[]
+	def initialize(files)
+	end
+	
+end
+
 def getDirs
   files=`find ext -type d`.gsub("\r","").split("\n")
 end
@@ -75,52 +105,273 @@
 def getClasses
 end
 
+class ParsedClasses
 
-files=getSwigInterfaceFiles(getFiles(outputDir))
+	attr_reader :deriveList
 
-addfiles=[]
-swigInput.each{|inDir|
-	pattern=getDir(inDir)+Dir.separator+"*.h"
-	puts "PATTERN:",pattern
-	addfiles+=Dir[pattern].select{|f|not f=~/swig.h/}
-}
+	def initialize(files,allfiles)
+		@rubyClasses=[]
+		@files=files
+		loadAllDerivations(allfiles)
+		@myfiles=files
+		processDerivations
+		initLevels
+	end
 
 
-filename=outputDir+Dir.separator+"/interface.i"
-puts "filename:",filename
-interfaceI=File.open(filename,"w")
+	def loadAllDerivations(allfiles)
+		@class2File={}
+		@deriveList={} # x=>y :x is child of y
 
-moduleName="Libantargis"
-moduleName=makeLibName(outputDir)
-interfaceI.puts interface_template(moduleName,files,swigInput,addfiles,outputDir)
+		allfiles.each{|fn|
+			g=File.open(fn)
+			cn=""
+			g.each{|a|
+				abak=a
+				a.gsub!("AGEXPORT","")
+				a.gsub!("EXPORT","")
+				
+				if a =~ /^class.*/ then
+					cn=a.gsub("class ","").gsub(/:.*/,"").gsub("\n","").gsub(" ","")
+					if cn=~/^[A-Z].*/
+						if a=~ /.*public.*/ then
+							pn=a.gsub(/.*public /,"").gsub("\n","")
+							@deriveList[cn]=pn
+							@class2File[cn]=fn
+						elsif not a=~/;/ then
+							@deriveList[cn]=nil
+							@class2File[cn]=fn
+						end
+					end
+				end
+			
+			}
+		}
+		@classList=@class2File.keys
+	end
 
-interfaceI.close
+	def processDerivations
+		@rubyClasses << "AGRubyObject"
+		@classList.sort!.uniq!
+		
+		# check for children of AGWidget
+		changed=true
+		while changed do
+			changed=false
+			@deriveList.each {|x,y|
+				if @rubyClasses.member?(y) and not @rubyClasses.member?(x) then
+					@rubyClasses << x
+					changed=true
+				end
+			}
+		end
+# 		puts "-------------------------"
+# 		puts "CLASSLIST:"
+# 		puts @classList
+# 
+# 		puts "-------------------------"
+# 		puts "RUBY CLASSLIST:"
+# 		puts @rubyClasses
+# 
+# 		puts "-------------------------"
+# 		puts "DERIVATIONS:"
+# 			@deriveList.each {|x,y|
+# 				puts "#{x} #{y} #{@class2File[x]} "
+# 			}
+# 		puts "-------------------------"
+# 		puts "my ruby:"
+# 		puts getMyRubyClasses
+# 		puts "-------------------------"
+	end
 
-filename=outputDir+Dir.separator+"/headers.hh"
-headersH=File.open(filename,"w")
-headersH.puts "#ifndef __ANTARGIS_H__"
-headersH.puts "#define __ANTARGIS_H__"
-headersH.puts addfiles.collect{|f|"#include \"#{f}\""}.join("\n")
-headersH.puts files.collect{|f|"#include \"#{f}\""}.join("\n")
-headersH.puts "#ifdef SWIG"
-headersH.puts files.collect{|f|"%include \"#{f}\""}.join("\n")
-headersH.puts "#endif"
-headersH.puts "#endif"
-headersH.close
+	def initLevels
+		puts "initLevels..."
+		@levels={}
+		@levels["AGRubyObject"]=0
+		changed=true
+		l=0
+		while changed
+			changed=false
+			@deriveList.each{|x,y|
+				if @levels[y]==l and @levels[x].nil?
+					@levels[x]=l+1
+					changed=true
+				end
+			}
+			l+=1
+		end
 
+		(0..l).each{|i|
+			@levels.each{|n,level|
+				if level==i
+					puts "#{i} #{n}"
+				end
+			}
+		}
+	#if false
+		puts "-------------"		
+		# give classes with no parent next level
+		@classList.each{|c|
+			if @levels[c].nil?
+				if (not @deriveList.keys.member?(c)) 
+					@levels[c]=l
+				end
+			end
+		}
 
+		# repeat process
+		changed=true
+		while changed
+			changed=false
+			@deriveList.each{|x,y|
+				if @levels[y]==l and @levels[x].nil?
+					@levels[x]=l+1
+					changed=true
+				end
+			}
+			l+=1
+		end
 
-puts "GETFILES:"
+		puts "-------------"		
+		# give classes with no parent next level
+		@classList.each{|c|
+			if @levels[c].nil?
+				if (@deriveList[@deriveList[c]].nil?)
+					@levels[c]=l
+				end
+			end
+		}
 
-puts files.join("|")
+		# repeat process
+		changed=true
+		while changed
+			changed=false
+			@deriveList.each{|x,y|
+				if @levels[y]==l and @levels[x].nil?
+					@levels[x]=l+1
+					changed=true
+				end
+			}
+			l+=1
+		end
 
+#end
+		(0..l).each{|i|
+			@levels.each{|n,level|
+				if level==i
+					puts "#{i} #{n}"
+				end
+			}
+		}
+		@classList.each{|c|
+			if @levels[c].nil?
+				puts "-- #{c}"
+			end
+		}
 
+		puts "initLevels...ok"
 
+	end
 
+	# in correct order
+	def getFileList
+		files=[]
+		l=@levels.values.max
+		(0..l).each{|i|
+			@levels.each{|n,level|
+				if level==i and @class2File[n]
+					files << @class2File[n]
+				end
+			}
+		}
 
+		puts "getFileList:"
+		puts files,files.class
+		puts "---------"
 
+		@classList.each{|c|
+			if @levels[c].nil? and @class2File[c]
+				files << @class2File[c]
+			end
+		}
+
+		puts "getFileList:"
+		puts files,files.class
+		puts "---------"
+		files=files.select{|f|@myfiles.member?(f)}
+		addfiles=@files-files
+		files+=addfiles
+
+
+		puts "getFileList:"
+		puts files,files.class
+		puts "---------"
+		if files.length>0
+			files.uniq!
+		end
+		puts files,files.class
+		puts "---------"
+		files
+	end
+
+
+	def getMyRubyClasses
+		@rubyClasses.select{|c|@myfiles.member?(@class2File[c])}
+	end
+	def getAllRubyClasses
+		@rubyClasses
+	end
+end
+
+
+def generateInterfaceFile(myInput,files,addfiles)
+	filename=myInput.interfaceName
+	puts "filename:",filename
+	interfaceI=File.open(filename,"w")
+	
+	
+	puts "SWIGINPUTS:",myInput.swigInput,"--------------"
+	
+	interfaceI.puts interface_template(myInput.moduleName,files,myInput.swigInput,addfiles,myInput.outputDir)
+	
+	interfaceI.close
+	
+	filename=myInput.headersName
+	headersH=File.open(filename,"w")
+	headersH.puts "#ifndef __ANTARGIS_H__"
+	headersH.puts "#define __ANTARGIS_H__"
+	headersH.puts addfiles.collect{|f|"#include \"#{f}\""}.join("\n")
+	headersH.puts files.collect{|f|"#include \"#{f}\""}.join("\n")
+	headersH.puts "#ifdef SWIG"
+	headersH.puts files.collect{|f|"%include \"#{f}\""}.join("\n")
+	headersH.puts "#endif"
+	headersH.puts "#endif"
+	headersH.close
+end
+
+
+myInput=MyInput.new
+
+files=getSwigInterfaceFiles(getFiles(myInput.outputDir))
+
+parsedClasses=ParsedClasses.new(files,`find $(pwd) -name "*.h"|grep -v swig`.split("\n"))
+files=parsedClasses.getFileList
+
 #exit
 
+puts "GETFILES:",files,files.class
+
+puts files.join("|")
+
+addfiles=[]
+myInput.swigInput.each{|inDir|
+	pattern=getDir(inDir)+Dir.separator+"*.h"
+	puts "PATTERN:",pattern
+	addfiles+=Dir[pattern].select{|f|not f=~/swig.h/}
+}
+
+generateInterfaceFile(myInput,files,addfiles)
+
 # old implementation
 
 
@@ -137,18 +388,23 @@
 	g=File.open(fn)
 	cn=""
 	g.each{|a|
+		abak=a
 		a.gsub!("AGEXPORT","")
 		a.gsub!("EXPORT","")
 		
 		if a =~ /^class.*/ then
 			cn=a.gsub("class ","").gsub(/[:;].*/,"").gsub(/\n/,"").gsub(" ","")
-			classList+=[cn]
-			if a=~ /.*public.*/ then
-				pn=a.gsub(/.*public /,"").gsub(/\n/,"")
-				deriveList[cn]=pn
-				rubyClasses[cn]=false
-				rubyClasses[pn]=false
-				class2File[cn]=fn
+			if cn=~/^[A-Z].*/
+				classList+=[cn]
+				if a=~ /.*public.*/ then
+					pn=a.gsub(/.*public /,"").gsub(/\n/,"")
+					deriveList[cn]=pn
+					rubyClasses[cn]=false
+					rubyClasses[pn]=false
+					class2File[cn]=fn
+				elsif not a=~/;/ then
+					deriveList[cn]=nil
+				end
 			end
 		end
 	
@@ -171,11 +427,11 @@
 	}
 end
 
-file=File.open(outputDir+Dir.separator+"marker.i","w")
+file=File.open(myInput.markerName,"w")
 
 # ok, first marking is included
-rubyClasses.each {|x,y|
-	if y then
+parsedClasses.getMyRubyClasses.each {|x|
+	#if y then
 		file.puts "%exception "+x+"::"+x+" {"
 		file.puts "	$action"
 		file.puts "	result->mRUBY=self;"
@@ -186,7 +442,7 @@
 		file.puts "	result->mRubyObject=true;"
 		file.puts "}"
 		file.puts "%markfunc "+x+" \"general_markfunc\""
-	end
+	#end
 }
 
 # calculate class-derivations
@@ -221,9 +477,9 @@
 
 # swig typemaps
 # so that always the lowest children in a derivation hierarchy is returned
-
-deriveList.keys.each{|s|
-	if rubyClasses[s]
+myRubyClasses=parsedClasses.getMyRubyClasses
+parsedClasses.deriveList.keys.each{|s|
+	if myRubyClasses.member?(s)
 		file.puts "%typemap(out) #{s}*{"
 		file.puts " if($1)"
 		file.puts " {"
@@ -253,39 +509,84 @@
 file.puts " $result=NUM2INT($input);"
 file.puts "}"
 
+rubyClasses=parsedClasses.getMyRubyClasses
+allRubyClasses=parsedClasses.getAllRubyClasses
 
-truncClasses={}
+myClasses=[]
 
 deriveList.each{|b,a|
-	if rubyClasses[b] and rubyClasses[a]
-		#puts "DERIVE #{a} #{b}"
-		truncClasses[a]||=[]
-		truncClasses[a] << b
+	if rubyClasses.member?(b) || b=="AGRubyObject"
+		myClasses << b
 	end
 }
-truncClasses.each{|k,a|
-	file.puts <<EOT
+
+myClasses=myClasses.sort.uniq
+
+puts "rubyClasses:",rubyClasses
+puts "myClasses:",myClasses
+
+file.puts <<EOT
 %{
-static swig_type_info* #{k}_dynamic_cast(void **ptr) {
+// cast-function map
+// it contains the mapping from parent-classes=>dyn-cast-functions to child-classes
+#include <string>
+#include <map>
+#include <list>
+#include <iostream>
+
+typedef swig_type_info*(*CastFunction)(void**);
+extern std::map<std::string,std::list<CastFunction> > agCastFunctions;
+%}
 EOT
-			a.each{|x|
-				file.puts <<EOT
+
+myClasses.each{|k|
+file.puts <<EOT	
+%{
+// try to cast from #{k} to one of its child classes (if they exist)
+static swig_type_info* #{k}_dynamic_cast(void **ptr)
   {
-		#{x} *e = dynamic_cast<#{x} *>((#{k}*)*ptr);
-		if (e) 
-		{
-			*ptr = (void *) e;
-			return SWIGTYPE_p_#{x};
-		}
-  }
-EOT
-			}
-	file.puts <<EOT
-  return 0;
+	  std::list<CastFunction> &funcs=agCastFunctions["#{k}"];
+    for(std::list<CastFunction>::iterator i=funcs.begin();i!=funcs.end();i++)
+      {
+         swig_type_info*t=(*i)(ptr);
+	       std::cout<<"test:"<<t<<std::endl;
+         if(t)
+           return t;
+      }
+   return 0;
  }
 %}
 DYNAMIC_CAST(SWIGTYPE_p_#{k}, #{k}_dynamic_cast);
 EOT
+}
 
+deriveList.each{|b,a|
+	if rubyClasses.member?(b) and allRubyClasses.member?(a)
+		# for each pair generate a casting function and register it into agCastFunctions
+file.puts <<EOT
+%{
+swig_type_info* #{a}2#{b}cast(void **p)
+{
+        #{a}*a=(#{a}*)(*p);
+        #{b}*b=dynamic_cast<#{b}*>(a);
+				printf("TRY CAST #{a} 2 #{b} : %lx\\n",b);
+        if(b)
+        {
+                *p=(void*)b;
+                return SWIGTYPE_p_#{b};
+        }
+        return 0;
+}
+%}
 
+%insert("init") %{
+        agCastFunctions["#{a}"].push_back(&#{a}2#{b}cast);
+%}
+
+
+EOT
+	end
 }
+
+
+



From davidkamphausen at mail.berlios.de  Sat Jun 23 21:30:41 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 23 Jun 2007 21:30:41 +0200
Subject: [Antargis-svn] r1113 - antargis/branches/rant/build
Message-ID: <200706231930.l5NJUfSP026259@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-23 21:30:41 +0200 (Sat, 23 Jun 2007)
New Revision: 1113

Removed:
   antargis/branches/rant/build/create_interface_new.rb
Log:
D    build/create_interface_new.rb


Deleted: antargis/branches/rant/build/create_interface_new.rb
===================================================================
--- antargis/branches/rant/build/create_interface_new.rb	2007-06-23 19:30:24 UTC (rev 1112)
+++ antargis/branches/rant/build/create_interface_new.rb	2007-06-23 19:30:41 UTC (rev 1113)
@@ -1,592 +0,0 @@
-#!/usr/bin/env ruby
-#
-# Copyright (c) 2005 by David Kamphausen. All rights reserved.
-#
-# create_interface.rb
-# by David Kamphausen (david.kamphausen at web.de)
-#
-# The "Antargis" project, including all files needed to compile it,
-# is free software; you can redistribute it and/or use it and/or modify it
-# under the terms of the GNU General Public License as published
-# by the Free Software Foundation; either version 2 of the License,
-# or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-#
-# You should have received a copy of the GNU General Public
-# License along with this program.
-#
-
-require 'build/interface_template.rb'
-require 'build/base_tools.rb'
-
-class MyInput
-	attr_reader :swigInput, :outputDir
-	def initialize
-		@outputDir=Dir.pwd # default
-		@swigInput=""
-	
-
-		ARGV.each{|a|
-			case a
-				when /^-d=/
-					# in- and output dir
-					@outputDir=a[3..-1]
-				when /^-i=/
-					@swigInput=a[3..-1]
-				when /^-h/, /^--help/
-					@help=true
-					puts "Arguments:"
-					puts " -h, --help     print this help"
-					puts " -d=<DIR>       define output-directory"
-					puts " -i=<SWIGFILE>  define SWIG-input-file (swig.h) - can be set multiple times"
-			end
-		}
-
-		@swigInput=@swigInput.split(":")
-	end
-
-	def valid
-		@outputDir!="" && @help.nil?
-	end
-
-	def interfaceName
-		name=@outputDir+Dir.separator+"interface.i"
-		puts "INTERFACENAME:",name
-		name
-	end
-
-	def moduleName
-		moduleName=makeLibName(@outputDir)
-	end
-	def headersName
-		@outputDir+Dir.separator+"/headers.hh"
-	end
-	def markerName
-		@outputDir+Dir.separator+"marker.i"
-	end
-end
-
-class MClass
-  def initialize(name,superClass)
-    @name=name
-    @superClass=superClass
-  end
-end
-
-class SimpleParser
-	@mclasses=[]
-	def initialize(files)
-	end
-	
-end
-
-def getDirs
-  files=`find ext -type d`.gsub("\r","").split("\n")
-end
-
-def getFiles(dir)
-	Dir[dir+Dir.separator+"*.h"].select{|f|not f=~/swig.h/} #-[dir+Dir.separator+"swig.h"]
-end
-
-def grepBool(filename,string)
-	File.open(filename).each_line{|l|return true if l=~/#{string}/}
-	false
-end
-
-def getSwigInterfaceFiles(files)
-	files.select{|f|
-		grepBool(f,"INCLUDE_SWIG")
-	}
-end
-
-def getClasses
-end
-
-class ParsedClasses
-
-	attr_reader :deriveList
-
-	def initialize(files,allfiles)
-		@rubyClasses=[]
-		@files=files
-		loadAllDerivations(allfiles)
-		@myfiles=files
-		processDerivations
-		initLevels
-	end
-
-
-	def loadAllDerivations(allfiles)
-		@class2File={}
-		@deriveList={} # x=>y :x is child of y
-
-		allfiles.each{|fn|
-			g=File.open(fn)
-			cn=""
-			g.each{|a|
-				abak=a
-				a.gsub!("AGEXPORT","")
-				a.gsub!("EXPORT","")
-				
-				if a =~ /^class.*/ then
-					cn=a.gsub("class ","").gsub(/:.*/,"").gsub("\n","").gsub(" ","")
-					if cn=~/^[A-Z].*/
-						if a=~ /.*public.*/ then
-							pn=a.gsub(/.*public /,"").gsub("\n","")
-							@deriveList[cn]=pn
-							@class2File[cn]=fn
-						elsif not a=~/;/ then
-							@deriveList[cn]=nil
-							@class2File[cn]=fn
-						end
-					end
-				end
-			
-			}
-		}
-		@classList=@class2File.keys
-	end
-
-	def processDerivations
-		@rubyClasses << "AGRubyObject"
-		@classList.sort!.uniq!
-		
-		# check for children of AGWidget
-		changed=true
-		while changed do
-			changed=false
-			@deriveList.each {|x,y|
-				if @rubyClasses.member?(y) and not @rubyClasses.member?(x) then
-					@rubyClasses << x
-					changed=true
-				end
-			}
-		end
-# 		puts "-------------------------"
-# 		puts "CLASSLIST:"
-# 		puts @classList
-# 
-# 		puts "-------------------------"
-# 		puts "RUBY CLASSLIST:"
-# 		puts @rubyClasses
-# 
-# 		puts "-------------------------"
-# 		puts "DERIVATIONS:"
-# 			@deriveList.each {|x,y|
-# 				puts "#{x} #{y} #{@class2File[x]} "
-# 			}
-# 		puts "-------------------------"
-# 		puts "my ruby:"
-# 		puts getMyRubyClasses
-# 		puts "-------------------------"
-	end
-
-	def initLevels
-		puts "initLevels..."
-		@levels={}
-		@levels["AGRubyObject"]=0
-		changed=true
-		l=0
-		while changed
-			changed=false
-			@deriveList.each{|x,y|
-				if @levels[y]==l and @levels[x].nil?
-					@levels[x]=l+1
-					changed=true
-				end
-			}
-			l+=1
-		end
-
-		(0..l).each{|i|
-			@levels.each{|n,level|
-				if level==i
-					puts "#{i} #{n}"
-				end
-			}
-		}
-	#if false
-		puts "-------------"		
-		# give classes with no parent next level
-		@classList.each{|c|
-			if @levels[c].nil?
-				if (not @deriveList.keys.member?(c)) 
-					@levels[c]=l
-				end
-			end
-		}
-
-		# repeat process
-		changed=true
-		while changed
-			changed=false
-			@deriveList.each{|x,y|
-				if @levels[y]==l and @levels[x].nil?
-					@levels[x]=l+1
-					changed=true
-				end
-			}
-			l+=1
-		end
-
-		puts "-------------"		
-		# give classes with no parent next level
-		@classList.each{|c|
-			if @levels[c].nil?
-				if (@deriveList[@deriveList[c]].nil?)
-					@levels[c]=l
-				end
-			end
-		}
-
-		# repeat process
-		changed=true
-		while changed
-			changed=false
-			@deriveList.each{|x,y|
-				if @levels[y]==l and @levels[x].nil?
-					@levels[x]=l+1
-					changed=true
-				end
-			}
-			l+=1
-		end
-
-#end
-		(0..l).each{|i|
-			@levels.each{|n,level|
-				if level==i
-					puts "#{i} #{n}"
-				end
-			}
-		}
-		@classList.each{|c|
-			if @levels[c].nil?
-				puts "-- #{c}"
-			end
-		}
-
-		puts "initLevels...ok"
-
-	end
-
-	# in correct order
-	def getFileList
-		files=[]
-		l=@levels.values.max
-		(0..l).each{|i|
-			@levels.each{|n,level|
-				if level==i and @class2File[n]
-					files << @class2File[n]
-				end
-			}
-		}
-
-		puts "getFileList:"
-		puts files,files.class
-		puts "---------"
-
-		@classList.each{|c|
-			if @levels[c].nil? and @class2File[c]
-				files << @class2File[c]
-			end
-		}
-
-		puts "getFileList:"
-		puts files,files.class
-		puts "---------"
-		files=files.select{|f|@myfiles.member?(f)}
-		addfiles=@files-files
-		files+=addfiles
-
-
-		puts "getFileList:"
-		puts files,files.class
-		puts "---------"
-		if files.length>0
-			files.uniq!
-		end
-		puts files,files.class
-		puts "---------"
-		files
-	end
-
-
-	def getMyRubyClasses
-		@rubyClasses.select{|c|@myfiles.member?(@class2File[c])}
-	end
-	def getAllRubyClasses
-		@rubyClasses
-	end
-end
-
-
-def generateInterfaceFile(myInput,files,addfiles)
-	filename=myInput.interfaceName
-	puts "filename:",filename
-	interfaceI=File.open(filename,"w")
-	
-	
-	puts "SWIGINPUTS:",myInput.swigInput,"--------------"
-	
-	interfaceI.puts interface_template(myInput.moduleName,files,myInput.swigInput,addfiles,myInput.outputDir)
-	
-	interfaceI.close
-	
-	filename=myInput.headersName
-	headersH=File.open(filename,"w")
-	headersH.puts "#ifndef __ANTARGIS_H__"
-	headersH.puts "#define __ANTARGIS_H__"
-	headersH.puts addfiles.collect{|f|"#include \"#{f}\""}.join("\n")
-	headersH.puts files.collect{|f|"#include \"#{f}\""}.join("\n")
-	headersH.puts "#ifdef SWIG"
-	headersH.puts files.collect{|f|"%include \"#{f}\""}.join("\n")
-	headersH.puts "#endif"
-	headersH.puts "#endif"
-	headersH.close
-end
-
-
-myInput=MyInput.new
-
-files=getSwigInterfaceFiles(getFiles(myInput.outputDir))
-
-parsedClasses=ParsedClasses.new(files,`find $(pwd) -name "*.h"|grep -v swig`.split("\n"))
-files=parsedClasses.getFileList
-
-#exit
-
-puts "GETFILES:",files,files.class
-
-puts files.join("|")
-
-addfiles=[]
-myInput.swigInput.each{|inDir|
-	pattern=getDir(inDir)+Dir.separator+"*.h"
-	puts "PATTERN:",pattern
-	addfiles+=Dir[pattern].select{|f|not f=~/swig.h/}
-}
-
-generateInterfaceFile(myInput,files,addfiles)
-
-# old implementation
-
-
-classList=[]
-deriveList={} # x=>y :x is child of y
-rubyClasses={} # all, which are derived from AGRubyObject
-class2File={}
-
-
-# take RubyObject as base for RubyObjects :-)
-# so simply search for classes deriveListd from this!
-
-files.each{|fn|
-	g=File.open(fn)
-	cn=""
-	g.each{|a|
-		abak=a
-		a.gsub!("AGEXPORT","")
-		a.gsub!("EXPORT","")
-		
-		if a =~ /^class.*/ then
-			cn=a.gsub("class ","").gsub(/[:;].*/,"").gsub(/\n/,"").gsub(" ","")
-			if cn=~/^[A-Z].*/
-				classList+=[cn]
-				if a=~ /.*public.*/ then
-					pn=a.gsub(/.*public /,"").gsub(/\n/,"")
-					deriveList[cn]=pn
-					rubyClasses[cn]=false
-					rubyClasses[pn]=false
-					class2File[cn]=fn
-				elsif not a=~/;/ then
-					deriveList[cn]=nil
-				end
-			end
-		end
-	
-	}
-}
-
-rubyClasses["AGRubyObject"]=true
-
-classList.sort!.uniq!
-
-# check for children of AGWidget
-changed=true
-while changed do
-	changed=false
-	deriveList.each {|x,y|
-		if rubyClasses[y] and rubyClasses[x]==false then
-			rubyClasses[x]=true
-			changed=true
-		end
-	}
-end
-
-file=File.open(myInput.markerName,"w")
-
-# ok, first marking is included
-parsedClasses.getMyRubyClasses.each {|x|
-	#if y then
-		file.puts "%exception "+x+"::"+x+" {"
-		file.puts "	$action"
-		file.puts "	result->mRUBY=self;"
-		file.puts "#ifdef GCDEBUG"
-		file.puts '     result->mObjName=typeid(*result).name();'
-		file.puts '     printf("%lx   %s\n",self,typeid(*result).name());'
-		file.puts "#endif"
-		file.puts "	result->mRubyObject=true;"
-		file.puts "}"
-		file.puts "%markfunc "+x+" \"general_markfunc\""
-	#end
-}
-
-# calculate class-derivations
-derivations={}
-rubyClasses.each{|x,y|
-	derivations[x]=[]
-}
-deriveList.each{|x,y|
-	if not derivations[y]
-		derivations[y]=[]
-	end
-	derivations[y].push(x)
-}
-changed=true
-while changed
-	changed=false
-	derivations.each{|x,y|
-		y.each{|a|
-			if derivations[a]
-				old=derivations[x]
-				derivations[x]+=derivations[a]
-				derivations[x].sort!
-				derivations[x].uniq!
-				#puts x+":"+old.length.to_s+" "+derivations[x].length.to_s
-				if old.length<derivations[x].length
-					changed=true
-				end
-			end
-		}
-	}
-end
-
-# swig typemaps
-# so that always the lowest children in a derivation hierarchy is returned
-myRubyClasses=parsedClasses.getMyRubyClasses
-parsedClasses.deriveList.keys.each{|s|
-	if myRubyClasses.member?(s)
-		file.puts "%typemap(out) #{s}*{"
-		file.puts " if($1)"
-		file.puts " {"
-		file.puts "   $result=AG_NewPointerObj($1,SWIGTYPE_p_#{s},0);"
-		file.puts " }"
-		file.puts "}"
-
-		file.puts "%typemap(directorin) #{s}*{"
-		file.puts " if($1)"
-		file.puts " {"
-		file.puts "   $input=AG_NewPointerObj($1,SWIGTYPE_p_#{s},0);"
-		file.puts " }"
-		file.puts "}"
-
-	end
-}
-# normal typemaps
-classList.each{|c|
-	file.puts "%typemap(directorout) #{c} {"
-	file.puts " #{c} *b;"
-	file.puts " Data_Get_Struct($input,#{c},b);"
-	file.puts " $result=*b;"
-	file.puts "}"
-}
-
-file.puts "%typemap(directorout) Uint8 {"
-file.puts " $result=NUM2INT($input);"
-file.puts "}"
-
-rubyClasses=parsedClasses.getMyRubyClasses
-allRubyClasses=parsedClasses.getAllRubyClasses
-
-myClasses=[]
-
-deriveList.each{|b,a|
-	if rubyClasses.member?(b) || b=="AGRubyObject"
-		myClasses << b
-	end
-}
-
-myClasses=myClasses.sort.uniq
-
-puts "rubyClasses:",rubyClasses
-puts "myClasses:",myClasses
-
-file.puts <<EOT
-%{
-// cast-function map
-// it contains the mapping from parent-classes=>dyn-cast-functions to child-classes
-#include <string>
-#include <map>
-#include <list>
-#include <iostream>
-
-typedef swig_type_info*(*CastFunction)(void**);
-extern std::map<std::string,std::list<CastFunction> > agCastFunctions;
-%}
-EOT
-
-myClasses.each{|k|
-file.puts <<EOT	
-%{
-// try to cast from #{k} to one of its child classes (if they exist)
-static swig_type_info* #{k}_dynamic_cast(void **ptr)
-  {
-	  std::list<CastFunction> &funcs=agCastFunctions["#{k}"];
-    for(std::list<CastFunction>::iterator i=funcs.begin();i!=funcs.end();i++)
-      {
-         swig_type_info*t=(*i)(ptr);
-	       std::cout<<"test:"<<t<<std::endl;
-         if(t)
-           return t;
-      }
-   return 0;
- }
-%}
-DYNAMIC_CAST(SWIGTYPE_p_#{k}, #{k}_dynamic_cast);
-EOT
-}
-
-deriveList.each{|b,a|
-	if rubyClasses.member?(b) and allRubyClasses.member?(a)
-		# for each pair generate a casting function and register it into agCastFunctions
-file.puts <<EOT
-%{
-swig_type_info* #{a}2#{b}cast(void **p)
-{
-        #{a}*a=(#{a}*)(*p);
-        #{b}*b=dynamic_cast<#{b}*>(a);
-				printf("TRY CAST #{a} 2 #{b} : %lx\\n",b);
-        if(b)
-        {
-                *p=(void*)b;
-                return SWIGTYPE_p_#{b};
-        }
-        return 0;
-}
-%}
-
-%insert("init") %{
-        agCastFunctions["#{a}"].push_back(&#{a}2#{b}cast);
-%}
-
-
-EOT
-	end
-}
-
-
-



From davidkamphausen at mail.berlios.de  Sun Jun 24 12:21:29 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 24 Jun 2007 12:21:29 +0200
Subject: [Antargis-svn] r1114 - in antargis/branches/rant: . ext/gui ruby
	ruby/entities
Message-ID: <200706241021.l5OALT5I005629@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-24 12:21:29 +0200 (Sun, 24 Jun 2007)
New Revision: 1114

Modified:
   antargis/branches/rant/Rantfile
   antargis/branches/rant/ext/gui/ag_widget.cc
   antargis/branches/rant/ext/gui/templates.i
   antargis/branches/rant/ruby/dialogs.rb
   antargis/branches/rant/ruby/entities/ant_workshop.rb
Log:
* small fixes


Modified: antargis/branches/rant/Rantfile
===================================================================
--- antargis/branches/rant/Rantfile	2007-06-23 19:30:41 UTC (rev 1113)
+++ antargis/branches/rant/Rantfile	2007-06-24 10:21:29 UTC (rev 1114)
@@ -2,6 +2,8 @@
 import "autoclean"                    # autoclean includes the a simple facility for a clean-make-target
 
 require 'build/base_tools.rb'
+
+require 'config.rb'                   # include build-options
     
 
 # sitearchdir - include in usr/local
@@ -33,7 +35,16 @@
 var :INCLUDES => sourceDirs+[rubyIncDir,"."] #.collect{|d|"-I#{d}"}.join(" ")+" "+externalIncludes+" "+rubyIncDir
 var :INCLUDESTR => var[:INCLUDES].collect{|d|"-I#{d}"}.join(" ")+" "+externalIncludes
 
-var :CFLAGS => var[:INCLUDESTR]+" -g -O0 -DGCDEBUG"
+
+# configure cflags out of config.rb
+cflags=""
+cflags+=" -DGCDEBUG" if $antConfig["gcdebug"]   # enable debuggin of garbage-collection
+cflags+=" -g -O0"    if $antConfig["debug"]     # disable optimizations for better debugging
+cflags+=" -O2"       unless $antConfig["debug"] # enable optimizations
+	
+
+
+var :CFLAGS => var[:INCLUDESTR]+cflags
     
 var.env %w(CC CFLAGS)
     

Modified: antargis/branches/rant/ext/gui/ag_widget.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_widget.cc	2007-06-23 19:30:41 UTC (rev 1113)
+++ antargis/branches/rant/ext/gui/ag_widget.cc	2007-06-24 10:21:29 UTC (rev 1114)
@@ -1103,7 +1103,7 @@
 }
 void AGWidget::clearChangeRects()
 {
-  cdebug("clearing - size was:"<<mMyChanges.size());
+  //  cdebug("clearing - size was:"<<mMyChanges.size());
   mMyChanges.clear();
   for(std::list<AGWidget*>::iterator i=mChildren.begin();i!=mChildren.end();i++)
     (*i)->clearChangeRects();

Modified: antargis/branches/rant/ext/gui/templates.i
===================================================================
--- antargis/branches/rant/ext/gui/templates.i	2007-06-23 19:30:41 UTC (rev 1113)
+++ antargis/branches/rant/ext/gui/templates.i	2007-06-24 10:21:29 UTC (rev 1114)
@@ -0,0 +1 @@
+%include <SDL_keysym.h>

Modified: antargis/branches/rant/ruby/dialogs.rb
===================================================================
--- antargis/branches/rant/ruby/dialogs.rb	2007-06-23 19:30:41 UTC (rev 1113)
+++ antargis/branches/rant/ruby/dialogs.rb	2007-06-24 10:21:29 UTC (rev 1114)
@@ -76,6 +76,11 @@
 	
 	def eventKeyDown(e)
 		if super then return true end
+		
+		puts "#{e.getKey},#{SDLK_ESCAPE}"
+		raise 1
+
+
 		case e.getKey
 			when SDLK_ESCAPE
 				eventClose(e)

Modified: antargis/branches/rant/ruby/entities/ant_workshop.rb
===================================================================
--- antargis/branches/rant/ruby/entities/ant_workshop.rb	2007-06-23 19:30:41 UTC (rev 1113)
+++ antargis/branches/rant/ruby/entities/ant_workshop.rb	2007-06-24 10:21:29 UTC (rev 1114)
@@ -44,7 +44,7 @@
 		setMesh
 		p=AGVector3.new(-1.3,-1.2,2.2)
 		if opengl
-			addMesh(@smokeMesh=Smoke.new(getMap.getScene,5),p)
+			addMesh(@smokeMesh=AntParticle.new(getMap.getScene,5),p)
 			checkSmoke
 		end
 	end



From davidkamphausen at mail.berlios.de  Sun Jun 24 12:32:12 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sun, 24 Jun 2007 12:32:12 +0200
Subject: [Antargis-svn] r1115 - in antargis/branches/rant: ext/basic ruby
Message-ID: <200706241032.l5OAWCPM009416@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-24 12:32:11 +0200 (Sun, 24 Jun 2007)
New Revision: 1115

Modified:
   antargis/branches/rant/ext/basic/templates.i
   antargis/branches/rant/ruby/dialogs.rb
Log:
* fixed bug with key-press in dialogs


Modified: antargis/branches/rant/ext/basic/templates.i
===================================================================
--- antargis/branches/rant/ext/basic/templates.i	2007-06-24 10:21:29 UTC (rev 1114)
+++ antargis/branches/rant/ext/basic/templates.i	2007-06-24 10:32:11 UTC (rev 1115)
@@ -1,3 +1,5 @@
+%include <SDL_keysym.h>
+
 %template(StdVectorPNode) std::vector<Node*>;
 %template(AGNodeList) std::vector<Node>;
 //%template(AGNodePList) std::vector<Node*>;

Modified: antargis/branches/rant/ruby/dialogs.rb
===================================================================
--- antargis/branches/rant/ruby/dialogs.rb	2007-06-24 10:21:29 UTC (rev 1114)
+++ antargis/branches/rant/ruby/dialogs.rb	2007-06-24 10:32:11 UTC (rev 1115)
@@ -76,11 +76,7 @@
 	
 	def eventKeyDown(e)
 		if super then return true end
-		
-		puts "#{e.getKey},#{SDLK_ESCAPE}"
-		raise 1
 
-
 		case e.getKey
 			when SDLK_ESCAPE
 				eventClose(e)



From davidkamphausen at mail.berlios.de  Mon Jun 25 20:50:27 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Mon, 25 Jun 2007 20:50:27 +0200
Subject: [Antargis-svn] r1116 - in antargis/branches/rant: . build
	data/gui/layout ext ext/basic ext/gui ruby ruby/entities
Message-ID: <200706251850.l5PIoRZe008254@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-25 20:50:26 +0200 (Mon, 25 Jun 2007)
New Revision: 1116

Added:
   antargis/branches/rant/build/win32/
Modified:
   antargis/branches/rant/Rantfile
   antargis/branches/rant/build/ag_data.i
   antargis/branches/rant/build/ag_filename.i
   antargis/branches/rant/build/base_tools.rb
   antargis/branches/rant/build/common.i
   antargis/branches/rant/data/gui/layout/campaign.xml
   antargis/branches/rant/data/gui/layout/mainmenu.xml
   antargis/branches/rant/data/gui/layout/options.xml
   antargis/branches/rant/data/gui/layout/single.xml
   antargis/branches/rant/ext/.rant.meta
   antargis/branches/rant/ext/basic/ag_rubyobj.cc
   antargis/branches/rant/ext/gui/ag_application.cc
   antargis/branches/rant/ext/gui/ag_widget.cc
   antargis/branches/rant/ruby/entities/ant_bakery.rb
   antargis/branches/rant/ruby/mainmenu.rb
Log:
* many changes


Modified: antargis/branches/rant/Rantfile
===================================================================
--- antargis/branches/rant/Rantfile	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/Rantfile	2007-06-25 18:50:26 UTC (rev 1116)
@@ -1,4 +1,4 @@
-import "md5"                          # md5 is needed for automatic checksum-check for changes in files
+#import "md5"                          # md5 is needed for automatic checksum-check for changes in files
 import "autoclean"                    # autoclean includes the a simple facility for a clean-make-target
 
 require 'build/base_tools.rb'
@@ -6,34 +6,41 @@
 require 'config.rb'                   # include build-options
     
 
-# sitearchdir - include in usr/local
 
-rubyIncDir=getConfig("archdir")
-
+# get library-dependencies for libSDL
 sdlLibs=[`sdl-config --libs`]
-   
+
+# configure source-directories.
+# DLLs will be build for each directory and in the given order.
+# on the left the directory containing the sources is given
+# on the right the dependencies, which can be one of the following:
+# - an external library, which then marked by "-l" in front, like "-lz" for the z-library
+# - an internal dependency on a directory
+# NOTE: dependencies are not automatically inherited, you have to include them yourself!
+
 sourceDeps=[
 	["ext/external",["-lz"]],
 	["ext/basic",["ext/external"]+sdlLibs],
 	["ext/math",["ext/basic"]],
 	["ext/video",["ext/math","ext/basic","-lSDL_image","-lSDL_ttf","-lGL","-lGLU"]],
 	["ext/gui",["ext/basic","ext/math","ext/video"]],
-	["ext/sound",["ext/basic","-lSDL_mixer"]], # FIXME: remove dependency from AGWidget somehow !
+	["ext/sound",["ext/basic","-lSDL_mixer"]],
 	["ext/3dengine",["ext/basic"]],
 	["ext/game",["ext/basic","ext/math","ext/video","ext/gui","ext/3dengine"]],
 ]
 
 $sourceDeps=sourceDeps
 
-sourceDirs=sourceDeps.collect{|a|a[0]}
+sourceDirs=sourceDeps.collect{|a|a[0]}    # collect dirs containing source (in the correct order !)
 
-# puts sourceDirs
-# exit
-
 externalIncludes=`sdl-config --cflags`.gsub("\n","")
+
+# sitearchdir - include in usr/local
+rubyIncDir=getConfig("archdir")
     
-var :INCLUDES => sourceDirs+[rubyIncDir,"."] #.collect{|d|"-I#{d}"}.join(" ")+" "+externalIncludes+" "+rubyIncDir
-var :INCLUDESTR => var[:INCLUDES].collect{|d|"-I#{d}"}.join(" ")+" "+externalIncludes
+# gather include-directories (separately from other cflags, so they can be used for swig later on
+var :INCLUDES => sourceDirs+[rubyIncDir,"."]
+var :INCLUDESTR => var[:INCLUDES].collect{|d|"-I#{d}"}.join(" ")+" "+externalIncludes    # build include-string (-I...)
 
 
 # configure cflags out of config.rb
@@ -43,15 +50,10 @@
 cflags+=" -O2"       unless $antConfig["debug"] # enable optimizations
 	
 
+var :CFLAGS => var[:INCLUDESTR]+cflags          # store cflags in "var" for later read-out while compiling
 
-var :CFLAGS => var[:INCLUDESTR]+cflags
-    
-var.env %w(CC CFLAGS)
-    
-sources=sourceDirs.collect{|dir,deps|sys[dir+"/*.cc"]}.flatten.collect{|f|f.sub_ext("oo")}
+var.env %w(CC CFLAGS)                           # get cflags from environment
 
-sources+=(sourceDirs-["ext/external"]).collect{|dir|dir+"/swig.oo"}
-
 ###########################################
 # all-target
 buildLibs=sourceDirs.collect{|d|"ext"+Dir.separator+"lib"+makeLibName(d)+".so"}
@@ -66,10 +68,7 @@
 ###########################################
 # configure - clean-task
 gen AutoClean, :clean
-var[:clean].include "**/marker.i"
-var[:clean].include "**/*swig.h"
-var[:clean].include "**/*swig.cc"
-var[:clean].include "**/*.so"
+#var[:clean].include "**/marker.i"   # not needed any more - managed by Rule
 ###########################################
 
 
@@ -79,32 +78,26 @@
 # build libraries (without swig)
 #
 sourceDeps.each{|pair|
-	dir,dep=pair
-	target="ext"+Dir.separator+"lib"+makeLibName(dir)+".so"
-	tsources=Dir[dir+Dir.separator+"*.cc"]-[dir+Dir.separator+"swig.cc"]
-	tsources.collect!{|f|f.sub_ext("oo")}
-	tsources+=Dir[dir+Dir.separator+"*.c"].collect!{|f|f.sub_ext("o")}
+	dir,dep=pair                                                               # get directory and dependencies
+	target="ext"+Dir.separator+"lib"+makeLibName(dir)+".so"                    # make library name like "ext/libantargisgui.so"
+	tsources=Dir[dir+Dir.separator+"*.cc"].select{|f|not f=~/swig/}            # get all *.cc files (without the swig-generated file)
+	tsources.collect!{|f|f.sub_ext("oo")}                                      # translate the .cc files to .oo
+	tsources+=Dir[dir+Dir.separator+"*.c"].collect!{|f|f.sub_ext("o")}         # add *.c files if there are any
 	extlibs=[]
 	dep.each{|d|
 		if d[0..0]=="-"
-			extlibs << d
+			extlibs << d                                                           # gather external libraries (-lz)
 		else
-			tsources+=["ext"+Dir.separator+"lib"+makeLibName(d)+".so"]
+			tsources+=["ext"+Dir.separator+"lib"+makeLibName(d)+".so"]             # gather internal deps like (ext/libantargisbasic.so)
 		end
 	}
-# 	puts "DIR:",dir
-# 	puts "TSOURCES:"
-# 	puts tsources
-# 	puts "TARGET:",target
-	task target => tsources do |t|
-# 		puts extlibs
-# 		puts t.prerequisites
-		cmd="g++ -shared -o "+sys.expand_path(t.name)+" "+(t.prerequisites.collect{|f|sys.expand_path(f)}+ extlibs).join(" ")
+	gen Rule, target => tsources do |t|
+		# build command
+		cmd=makeCommand($antConfig["LINKSHARED"],sys.expand_path(t.name), (t.prerequisites.collect{|f|sys.expand_path(f)}+extlibs).join(" "))
 		sys cmd
-		#sys %w(g++ -shared -o ), sys.expand_path(t.name), t.prerequisites.collect{|f|sys.expand_path(f)}+ extlibs
 	end
 }
-#exit
+#
 ###########################################
 
 
@@ -123,17 +116,11 @@
 			tsources+=["ext"+Dir.separator+makeLibName(d)+".so"]
 		end
 	}
-#  	puts "DIR:",dir
-#  	puts "TSOURCES:"
-#  	puts tsources
-#  	puts "TARGET:",target
-	task target => tsources do |t|
-		sys %w(g++ -shared -o ), sys.expand_path(t.name), t.prerequisites.collect{|f|sys.expand_path(f)}
+	gen Rule, target => tsources do |t|
+		cmd=makeCommand($antConfig["LINKSHARED"],sys.expand_path(t.name), t.prerequisites.collect{|f|sys.expand_path(f)}.join(" "))
+		sys cmd
 	end
 }
-# task "libantargis.so" => sources do |t|
-#   sys %w(g++ -shared -o ), sys.expand_path(t.name), t.prerequisites.collect{|f|sys.expand_path(f)}
-# end
 ###########################################
     
 
@@ -141,7 +128,8 @@
 # build c
 #
 gen Rule, '.o' => '.c' do |t|
-        sys "ccache gcc -c -o #{sys.expand_path(t.name)} #{var :CFLAGS} #{sys.expand_path(t.source)}"
+	cmd=makeCommand($antConfig["CC"],sys.expand_path(t.name),"#{var :CFLAGS} #{sys.expand_path(t.source)}")
+	sys cmd
 end
 ###########################################
 
@@ -149,19 +137,10 @@
 # build c++
 #
 gen Rule, '.oo' => '.cc' do |t|
-        sys "ccache g++ -c -o #{sys.expand_path(t.name)} #{var :CFLAGS} #{sys.expand_path(t.source)}"
+	cmd=makeCommand($antConfig["CXX"],sys.expand_path(t.name),"#{var :CFLAGS} #{sys.expand_path(t.source)}")
+	sys cmd
 end
-
-# # task "ext/math/swig.oo" => "ext/math/swig.cc" do |t|
-# # 	raise 123
-# # end
-# # 
-# # swigOsrc = lambda {|target|
-# # 	[target.sub("swig.oo","swig.cc")]
-# # }
-# # gen Rule, /^.*swig.oo/ => swigOsrc do |t|
-# #         sys "ccache g++ -c -o #{sys.expand_path(t.name)} #{var :CFLAGS} #{sys.expand_path(t.source)}"
-# # end
+#
 ###########################################
 
 
@@ -174,8 +153,9 @@
 	[target.sub(name+"swig.cc","interface.i")]+sys["build/*.i"]+importsForInterface(target).split(":") 
 }
 
-gen Rule, /^.*swig.cc$/ => swigSrc do |t|
-	sys "swig -v -Wall -ruby -c++ -o #{sys.expand_path(t.name)} -DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR} #{sys.expand_path(t.source)}"
+gen Rule, /^.*swig.(cc|h)$/ => swigSrc do |t|
+	cmd=makeCommand($antConfig["SWIG"],sys.expand_path(t.name),"-DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR} #{sys.expand_path(t.source)}")
+	sys cmd
 end
 #
 ###########################################
@@ -187,35 +167,25 @@
 #
 
 def importsForInterface(name)
-	
 	$sourceDeps.each{|t|
 		if name=~/#{t[0]}/
 			return t[1].select{|f|not f=~/-.*/}.collect{|f|f+"/interface.i"}.join(":")
 		end
 	}
 	return ""
-
-
-	case name
-		when /ext\/math/
-			"ext/basic/interface.i"
-		when /ext\/video/
-			"ext/basic/interface.i:ext/math/interface.i"
-		else
-			""
-	end
-#	puts "NAME:",name
-#	exit
 end
 
 interfaceSrc = lambda { |target| 
 	list=Dir[getDir(target)+Dir.separator+"*.h"].select{|f|not f=~/swig.h/}+Dir["build/*.rb"] # FIXME:replace
 	list+=importsForInterface(target).split(":")
-	puts "LIST:",list,"---"
 	list
 }
-gen Rule, /^.*interface.i$/ => interfaceSrc do |t|
-	sys "ruby build/create_interface.rb -d=#{getDir(sys.expand_path(t.name))} -i=#{importsForInterface(t.name)}"
+gen Rule, /^.*(marker|interface).i$/ => interfaceSrc do |t|
+	cmd=makeCommand($antConfig["CREATEINTERFACE"],getDir(sys.expand_path(t.name)),importsForInterface(t.name))
+	sys cmd
 end
 #
 ###########################################
+
+
+

Modified: antargis/branches/rant/build/ag_data.i
===================================================================
--- antargis/branches/rant/build/ag_data.i	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/build/ag_data.i	2007-06-25 18:50:26 UTC (rev 1116)
@@ -23,7 +23,7 @@
 
     // Ruby wants class names to start with a capital letter
     // %rename(String) string;
-//    class string;
+    class AGData;
 
     /* Overloading check */
     %typemap(typecheck) AGData = char *;

Modified: antargis/branches/rant/build/ag_filename.i
===================================================================
--- antargis/branches/rant/build/ag_filename.i	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/build/ag_filename.i	2007-06-25 18:50:26 UTC (rev 1116)
@@ -23,7 +23,7 @@
 
     // Ruby wants class names to start with a capital letter
     // %rename(String) string;
-//    class string;
+    class AGFilename;
 
     /* Overloading check */
     %typemap(typecheck) AGFilename = char *;

Modified: antargis/branches/rant/build/base_tools.rb
===================================================================
--- antargis/branches/rant/build/base_tools.rb	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/build/base_tools.rb	2007-06-25 18:50:26 UTC (rev 1116)
@@ -22,3 +22,8 @@
   return r if r.nil?
   r.gsub(/\$\(([^\)]*)\)/) {|a|getConfig(a[2..-2])} # replace recursive values within this form: $(...)
 end
+
+# build a command out of templates in config.rb
+def makeCommand(cmd,output,input)
+	cmd.sub("?OUTPUT?",output).sub("?INPUT?",input)
+end
\ No newline at end of file

Modified: antargis/branches/rant/build/common.i
===================================================================
--- antargis/branches/rant/build/common.i	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/build/common.i	2007-06-25 18:50:26 UTC (rev 1116)
@@ -1,12 +1,12 @@
 %feature("director");
 %include "typemaps.i"
 %include "std_string.i"
-%include "AGString.i"
+//%include "AGString.i"
 %include "std_vector.i"
 %include "std_pair.i"
 %include "std_map.i"
 %include "std_list.i"
-//%include "ag_string.i"
+%include "ag_string.i"
 %include "ag_filename.i"
 %include "ag_data.i"
 
@@ -17,7 +17,9 @@
 AG_NewPointerObj(void *ptr, swig_type_info *type, int flags)
 {
 	AGRubyObject *o=(AGRubyObject*)ptr;
+#ifdef GCDEBUG
 	printf("AG_NewPointerObj o:0x%lx , ruby:0x%lx vl:0x%lx\n",o,o->mRubyObject,o->mRUBY);
+#endif
 	if(o->mRubyObject)
 		return o->mRUBY;
 
@@ -25,7 +27,9 @@
 
 	o->mRubyObject=true;
 	o->mRUBY=SWIG_NewPointerObj((void *) o, t,flags);
+#ifdef GCDEBUG
 	printf("NEW AG_NewPointerObj o:0x%lx , ruby:0x%lx vl:0x%lx\n",o,o->mRubyObject,o->mRUBY);
+#endif
 	return o->mRUBY;
 }
 

Modified: antargis/branches/rant/data/gui/layout/campaign.xml
===================================================================
--- antargis/branches/rant/data/gui/layout/campaign.xml	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/data/gui/layout/campaign.xml	2007-06-25 18:50:26 UTC (rev 1116)
@@ -50,6 +50,6 @@
 				<text col="0" row="2" name="campaignDescription" font="story.font" align="center" enabled="false" caption=""/>
 			</table>
 		</table>
-		<text col="0" row="3" font="yellow.font" align="center" enabled="false" caption="(C) 2005 by the Antargis-team"/>
+		<text col="0" row="3" font="yellow.font" align="center" enabled="false" caption="(C) 2005-2007 by the Antargis-team"/>
 	</table>
 </layout>

Modified: antargis/branches/rant/data/gui/layout/mainmenu.xml
===================================================================
--- antargis/branches/rant/data/gui/layout/mainmenu.xml	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/data/gui/layout/mainmenu.xml	2007-06-25 18:50:26 UTC (rev 1116)
@@ -46,6 +46,6 @@
 				</frame>
 			</table>
 		</table>
-		<text col="0" row="3" font="yellow.font" align="center" enabled="false" caption="(C) 2005 by the Antargis-team"/>
+		<text col="0" row="3" font="yellow.font" align="center" enabled="false" caption="(C) 2005-2007 by the Antargis-team"/>
 	</table>
 </layout>

Modified: antargis/branches/rant/data/gui/layout/options.xml
===================================================================
--- antargis/branches/rant/data/gui/layout/options.xml	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/data/gui/layout/options.xml	2007-06-25 18:50:26 UTC (rev 1116)
@@ -106,6 +106,6 @@
 				</table>
 			</radioGroup>
 		</table>
-		<text col="0" row="3" font="yellow.font" align="center" enabled="false" caption="(C) 2005 by the Antargis-team"/>
+		<text col="0" row="3" font="yellow.font" align="center" enabled="false" caption="(C) 2005-2007 by the Antargis-team"/>
 	</table>
 </layout>

Modified: antargis/branches/rant/data/gui/layout/single.xml
===================================================================
--- antargis/branches/rant/data/gui/layout/single.xml	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/data/gui/layout/single.xml	2007-06-25 18:50:26 UTC (rev 1116)
@@ -47,6 +47,6 @@
 				</table>
 			</table>
 		</table>
-		<text col="0" row="3" font="yellow.font" align="center" enabled="false" caption="(C) 2005 by the Antargis-team"/>
+		<text col="0" row="3" font="yellow.font" align="center" enabled="false" caption="(C) 2005-2007 by the Antargis-team"/>
 	</table>
 </layout>

Modified: antargis/branches/rant/ext/.rant.meta
===================================================================
--- antargis/branches/rant/ext/.rant.meta	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/ext/.rant.meta	2007-06-25 18:50:26 UTC (rev 1116)
@@ -1,7 +1,135 @@
 Rant
+libantargisexternal.so
+2
+prerequisites_sig_md5
+1
+3cedb4faecf684c055ae15b7137ecd50660c3ce33439666f4c3bbf2c90b5d56475a688182fcc4e827a16819858fcf565b997f20acfc0205d6a2d23b2070dd09cc958fc20101f94a08177c8a189aae31b
+target_sig_md5
+1
+7fa3f2f4232bda44555357f58bc1cfe9
+antargis3dengine.so
+2
+prerequisites_sig_md5
+1
+01ece2d834c2aa55d470c0aa91007b4855779375dee8000c16850f6efcbe366f9446863bb2d0af8e2ea93d7cf4fe508c
+target_sig_md5
+1
+e0e6e7483ffdcd897fcfa40fb63f92c3
+libantargisvideo.so
+2
+prerequisites_sig_md5
+1
+002f9e267617fcb72c4fb978b9beb0fc01c0b4d8c26e933aa135c2faea09f33f1c4ff715bb34c24e176b25496aa4db7834c872e2123e719ba5050c7ce0b62bb23aec5919092d64b6101632ada6209622419e53177932609ecdabcc101c022fee423356e24215145e2bf3e048f436a9ce472c95204c2bb4a60fd07559c33d6a4b4ab1035f65ad68c9df1f64d65dfa991c5080868f7c76e9008d5837a57ece77335896b92c1985b57094accfb09e74e25f5e9c66ff1d8c359db85fbb77ee25172265b4b58953896dcadf4ae95c037344ea68b6de48dea2e8903b1af3ca99c71d566a286943ae3623e4735a9004ff31ee9e8e9f1b082d6acd8c415d81707d5a394a927bb513226a9d1905bd561b30c3747bb05cc6911ae5a7b3ccbd6f9482bb103cbee26a6407b99f468bd39bde0a3523e9c2dc8866299d63e8324f9a42f5a6769fc467827c18671b9d83fb9d8a981e0f56c58311d370c2c9f7ae500ee626a49650d6ec46bb84f57975ca8f0a8be3fc0a8edf35ef5161cd9dda302bc400a2daccc2e990b9e41ab17086d24c9bd322fb09c3efb3d9dbcf74ec01d3e7170bee3be632f8db4591103ba7c99ad758f3e631c7c8
+target_sig_md5
+1
+047cb4e513ceb2cac02f9835edaf1106
+antargismath.so
+2
+prerequisites_sig_md5
+1
+2fd34b7beb9fddf380425b196b84e5fb55779375dee8000c16850f6efcbe366fc467827c18671b9d83fb9d8a981e0f56
+target_sig_md5
+1
+b5d8bd5837608b25c97913c9ca82846e
+libantargis3dengine.so
+2
+prerequisites_sig_md5
+1
+105ba72ae6d8a3e7d3b664a86430475317596c69a5a96c188f77d80c9e9d165625973b3a9e356e1c7a122b03717fcb0d25f934c66595121b167f24f7bcf13cfb28fd33d5710ee421e71b3c29b5d74dda31e0991913fd38cefdd7c00256402c4f34c872e2123e719ba5050c7ce0b62bb246d327ac31522036603b7a10f8aab8f44b16f1c18e63d7e99aab160b874fecb574b94bfe778192c6105f9ff9fd499e5887e4580838f92c64e3ca373c5623431c8b99c4fb3b8bc0d715dc438f88be3181a140b61f78eb30653dcd792bad4f043db7523d050e2ef24fc1e0fe184e372544bd4a7b0dc42319ef93adc53d660cfde2c7a656179d44ba6191b08cf35e0bfefec96546e1b2ef6fc6a6708b62eaae3667df276d6117d7a714f0ba6c52c867cbfae3dedd1ea086d021af835f198d3bf6beeaee29b7734eef5d757280e7c2473f68faef37bd85e56fcd6f030cc496a9ff34
+target_sig_md5
+1
+9446863bb2d0af8e2ea93d7cf4fe508c
+libantargissound.so
+2
+prerequisites_sig_md5
+1
+34c872e2123e719ba5050c7ce0b62bb24da795f84d2273d36c5d86f9e0c2e7bc60031d6af82471f5b792403faaaabbebb3b75099ba86ea131fc40d7b5427c874
+target_sig_md5
+1
+453b94e98445bdd17d5017afd89a8df3
+antargisbasic.so
+2
+prerequisites_sig_md5
+1
+34c872e2123e719ba5050c7ce0b62bb2ca067f7ab178da5a16418cb2313a62f9eb43e10d26c7a1b88f5a9d9234a5b5d6
+target_sig_md5
+1
+55779375dee8000c16850f6efcbe366f
+libantargismath.so
+2
+prerequisites_sig_md5
+1
+000aacb38152d084628e68c5b60fbe6c34c872e2123e719ba5050c7ce0b62bb24642f7e6c5c821b10718b6c4ae25c062847fa85d0734cd899c2e5e722aeb7be9ab8c493898352ba1606ae8127e6a99edcc1452c4d3ba9b09aa3753a741208ba8df80addfd13d57a378d4b48d66f15a6de9a27147ef031f5fc08581c6ef7b5497
+target_sig_md5
+1
+c467827c18671b9d83fb9d8a981e0f56
+libantargisgui.so
+2
+prerequisites_sig_md5
+1
+047cb4e513ceb2cac02f9835edaf11060995f407ed2e711306ffd6f99dd218021099057a84f7b1c9bd20becbece1a4351550d1e77500414a18bf148ef9dae16018f9cf569420bbcc32f8d5a22c36d1092136012771a49d7f4609b3d09ff194c42736f8f1b4c9d81028e85adcf3194f4934c872e2123e719ba5050c7ce0b62bb242f600b8fed8ed3170b2716a77d8e73f455b29f06550f3b822a5938553744aec6152a1a07ca065fd1cb4f23baee18b3f63e932eda0d6819d579a7d2896dfa2db6a5bff4dc8b7905058f1408d5f874bc8733c82537f414cd0bb4f8de35db172137cc4b02d5bbb8b6f65283dfac9d8d4b894c6a38c3a3d608d878059283499bcc29cd47badd10cf78ae2b4fe05390393a0a4199c050b13ab4f2a85e8d1660dc573adae8caa4ee35b565f31b0ce2ca3fd8bb856d96b67e9cf434e2ec2bb8c3b8f9bbba2a01f43a40b083c91d97783ddab59bd6ab65828f764468398104b3ea019bdc2899ea2a44d1602b34b69df56bd7ce1c467827c18671b9d83fb9d8a981e0f56c599a0431bc2cacb1415d4ecf8d5ea7cc7f16c521245a8ae1e74ecd6e90bbbf9d1906084beb095ce840142c7b77d55d9e30c806ce70ebf42c7b23f42b11d380fe628de248848fc25a750ead1d24ae932e79fa353a4033329f1026361a1678d54e81f3d5f0e370ad050f5651fd4e5!
 0805f2064368b9f6c7f365e159d9ec0b72c7
+target_sig_md5
+1
+f9035dd63a15d6b39064ee18c6d6610d
+libantargisgame.so
+2
+prerequisites_sig_md5
+1
+04344fd903271dcebfad227e90283b47047cb4e513ceb2cac02f9835edaf11060643b66820d2b30362a192fa8688372d2e06762707c397287ac47a5990b9f47734c872e2123e719ba5050c7ce0b62bb24f987eff3595f8ad5167175780180c4a5e23dfe04d74c28daba9108cdf482d4b69aa6fbeffd4a61f47faa54e0a0d97f37aeeabe317b8d0d3822cbf3038ea768b8d6165bec2304d76a39e1dc63c93536f9446863bb2d0af8e2ea93d7cf4fe508caf8b9a79ceb24180e080ff6e9bf397deb3bd2792b4b6060f2d5227eb3cd44556c467827c18671b9d83fb9d8a981e0f56d34c1a5ae34f3624e1cdfba62cbf7695e4fe422fb11e35d27bff652d99e5d307e7ec22359d9a9feb9b495aed8ae0d6a7f9035dd63a15d6b39064ee18c6d6610d
+target_sig_md5
+1
+2be2d4fe8fcc1182f86e4cc0fcf6d63e
+libantargisbasic.so
+2
+prerequisites_sig_md5
+1
+2b6a36f4d1663d8b80062ab4e7beae18591c5b8f3171b242ba7c231bd72a061a660fbd1c678f76f05fbca8fb35e2205f691841758a3630be9ab49a889d074c9d6b88902cd8d5665c51039e3c14d470af6ffc363b6c80f17b9f4a17373335c792760054753ccc2852327487f6e1c6d0ba7a8975e12a0c8950f21cb9593e7c31287cce33f7fb1805db020ac780186c701b7e9a2e0f9672d535670e940a5bd0c4f67fa3f2f4232bda44555357f58bc1cfe980e380c2ead2e32283ac93c906492760863c5b7902342c679c2879e0ea0aa0d78fdd30ce22387dad7b80b4ad770b7a439bd5de34207d007398e6deb963466125a860b611050e68adc545131dfdd85af5adea56135b09d6d9fb753e19e03833f0b0e5c46e36467b034a7988db881332f9cb41a6e39a25e450c0bc258f5f01412fd3c44fe8d72a5fdf6f93a9b9bd47f15eda28fd616bcc03d4715e900542c50327e6abf3f052f117d7b82738991f87e07a
+target_sig_md5
+1
+34c872e2123e719ba5050c7ce0b62bb2
+antargisvideo.so
+2
+prerequisites_sig_md5
+1
+047cb4e513ceb2cac02f9835edaf11064538e88c80f14fc2b5281d71a96af57d55779375dee8000c16850f6efcbe366fb5d8bd5837608b25c97913c9ca82846e
+target_sig_md5
+1
+50c05c0cb4e4506031224a8027bf6676
+antargisgui.so
+2
+prerequisites_sig_md5
+1
+50c05c0cb4e4506031224a8027bf667655779375dee8000c16850f6efcbe366fb5d8bd5837608b25c97913c9ca82846ef6067d9d9ac56ba3be550844ac345b8af9035dd63a15d6b39064ee18c6d6610d
+target_sig_md5
+1
+8616b01c787c259720b62e63dc71cd52
 interface.i
 2
 prerequisites_sig_md5
 0
 target_sig_md5
 0
+antargissound.so
+2
+prerequisites_sig_md5
+1
+1a863a108a9b8b3405fa37b0694b1b57453b94e98445bdd17d5017afd89a8df355779375dee8000c16850f6efcbe366f
+target_sig_md5
+1
+14722ae85908c11196cd19f269f81863
+antargisgame.so
+2
+prerequisites_sig_md5
+1
+2be2d4fe8fcc1182f86e4cc0fcf6d63e50c05c0cb4e4506031224a8027bf667655779375dee8000c16850f6efcbe366f56094a6d27cddcf7b10ed7f229fead418616b01c787c259720b62e63dc71cd52b5d8bd5837608b25c97913c9ca82846ee0e6e7483ffdcd897fcfa40fb63f92c3
+target_sig_md5
+1
+a6f5f5cb095884bb6b50ec55e047f342
+antargisexternal.so
+2
+prerequisites_sig_md5
+1
+7fa3f2f4232bda44555357f58bc1cfe9f8e85a1a9e99802a41aeca1899087f1d
+target_sig_md5
+1
+ca067f7ab178da5a16418cb2313a62f9

Modified: antargis/branches/rant/ext/basic/ag_rubyobj.cc
===================================================================
--- antargis/branches/rant/ext/basic/ag_rubyobj.cc	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/ext/basic/ag_rubyobj.cc	2007-06-25 18:50:26 UTC (rev 1116)
@@ -131,7 +131,9 @@
   assert(o);
   if(gExistingRubies.find(o)==gExistingRubies.end())
     {
+#ifdef GCDEBUG
       cdebug("already deleted!");
+#endif
       return false; // already deleted
     }
   assert(!o->mDeleted);

Modified: antargis/branches/rant/ext/gui/ag_application.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_application.cc	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/ext/gui/ag_application.cc	2007-06-25 18:50:26 UTC (rev 1116)
@@ -363,7 +363,7 @@
   STACKTRACE;
   beginRender();
 
-  cdebug("mainWidget:"<<mainWidget);
+//  cdebug("mainWidget:"<<mainWidget);
   if(mainWidget)
     {
       getScreen().begin();
@@ -398,7 +398,7 @@
 	  clip.include(mainWidget->getScreenRect());
 	}
 
-      cdebug("CLIP:"<<clip.toString());
+  //    cdebug("CLIP:"<<clip.toString());
       paintTarget.clip(clip);
       mainWidget->drawAll(*p);
 
@@ -438,7 +438,7 @@
     }
 
   endRender();
-  cdebug("end render");
+//  cdebug("end render");
 }
 
 /**

Modified: antargis/branches/rant/ext/gui/ag_widget.cc
===================================================================
--- antargis/branches/rant/ext/gui/ag_widget.cc	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/ext/gui/ag_widget.cc	2007-06-25 18:50:26 UTC (rev 1116)
@@ -817,7 +817,7 @@
       if(w)
 				break;
     }
-	cdebug("w:"<<w);
+//	cdebug("w:"<<w);
   return w;
 }
 
@@ -965,7 +965,7 @@
 
 void AGWidget::queryRedraw()
 {
-  cdebug(getName()<<"::"<<typeid(*this).name());
+//  cdebug(getName()<<"::"<<typeid(*this).name());
   mCacheTouched=true;
   regChange();
 }
@@ -1098,7 +1098,7 @@
 }
 void AGWidget::pushChangeRect(const AGRect2 &pRect)
 {
-  cdebug("push:"<<pRect);
+//  cdebug("push:"<<pRect);
   mMyChanges.push_back(pRect);
 }
 void AGWidget::clearChangeRects()

Modified: antargis/branches/rant/ruby/entities/ant_bakery.rb
===================================================================
--- antargis/branches/rant/ruby/entities/ant_bakery.rb	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/ruby/entities/ant_bakery.rb	2007-06-25 18:50:26 UTC (rev 1116)
@@ -15,7 +15,7 @@
 	def setupMesh
 		setMesh
 		p=AGVector3.new(0,1.6,2.2)
-		addMesh(@smokeMesh=Smoke.new(getMap.getScene,5),p)
+		addMesh(@smokeMesh=AntParticle.new(getMap.getScene,5),p)
 		checkSmoke
 	end
 

Modified: antargis/branches/rant/ruby/mainmenu.rb
===================================================================
--- antargis/branches/rant/ruby/mainmenu.rb	2007-06-24 10:32:11 UTC (rev 1115)
+++ antargis/branches/rant/ruby/mainmenu.rb	2007-06-25 18:50:26 UTC (rev 1116)
@@ -170,7 +170,6 @@
 			return true
 		end
 		puts "MUH"
-		#raise 1
 		@loadMenu.getChild("desc").setText(AGStringUtf8.new(""))
 		filename=id=@loadMenu.getChild("list").getSelectedID
 		fn="savegames/"+id.gsub(".antcmp",".png")



From davidkamphausen at mail.berlios.de  Tue Jun 26 20:21:49 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Tue, 26 Jun 2007 20:21:49 +0200
Subject: [Antargis-svn] r1117 - antargis/branches/rant/ext/3dengine
Message-ID: <200706261821.l5QILnkS016538@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-26 20:21:49 +0200 (Tue, 26 Jun 2007)
New Revision: 1117

Modified:
   antargis/branches/rant/ext/3dengine/
Log:
_M   3dengine



Property changes on: antargis/branches/rant/ext/3dengine
___________________________________________________________________
Name: svn:ignore
   + *.oo
marker.i
interface.i




From davidkamphausen at mail.berlios.de  Tue Jun 26 20:23:01 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Tue, 26 Jun 2007 20:23:01 +0200
Subject: [Antargis-svn] r1118 - in antargis/branches/rant: . build ext
	ext/basic ext/external ext/game ext/gui ext/math ext/ruby
	ext/sound ext/video
Message-ID: <200706261823.l5QIN1ib016657@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-26 20:23:01 +0200 (Tue, 26 Jun 2007)
New Revision: 1118

Modified:
   antargis/branches/rant/Rantfile
   antargis/branches/rant/build/create_interface.rb
   antargis/branches/rant/ext/
   antargis/branches/rant/ext/basic/
   antargis/branches/rant/ext/external/
   antargis/branches/rant/ext/game/
   antargis/branches/rant/ext/gui/
   antargis/branches/rant/ext/math/
   antargis/branches/rant/ext/ruby/
   antargis/branches/rant/ext/sound/
   antargis/branches/rant/ext/video/
Log:
* small changes and set svn:ignore


Modified: antargis/branches/rant/Rantfile
===================================================================
--- antargis/branches/rant/Rantfile	2007-06-26 18:21:49 UTC (rev 1117)
+++ antargis/branches/rant/Rantfile	2007-06-26 18:23:01 UTC (rev 1118)
@@ -68,7 +68,8 @@
 ###########################################
 # configure - clean-task
 gen AutoClean, :clean
-#var[:clean].include "**/marker.i"   # not needed any more - managed by Rule
+var[:clean].include "**/marker.i"   # not needed any more - managed by Rule
+var[:clean].include "ext/*.so"
 ###########################################
 
 
@@ -91,7 +92,7 @@
 			tsources+=["ext"+Dir.separator+"lib"+makeLibName(d)+".so"]             # gather internal deps like (ext/libantargisbasic.so)
 		end
 	}
-	gen Rule, target => tsources do |t|
+	task target => tsources do |t|
 		# build command
 		cmd=makeCommand($antConfig["LINKSHARED"],sys.expand_path(t.name), (t.prerequisites.collect{|f|sys.expand_path(f)}+extlibs).join(" "))
 		sys cmd
@@ -116,7 +117,7 @@
 			tsources+=["ext"+Dir.separator+makeLibName(d)+".so"]
 		end
 	}
-	gen Rule, target => tsources do |t|
+	task target => tsources do |t|
 		cmd=makeCommand($antConfig["LINKSHARED"],sys.expand_path(t.name), t.prerequisites.collect{|f|sys.expand_path(f)}.join(" "))
 		sys cmd
 	end
@@ -180,7 +181,7 @@
 	list+=importsForInterface(target).split(":")
 	list
 }
-gen Rule, /^.*(marker|interface).i$/ => interfaceSrc do |t|
+gen Rule, /^.*interface.i$/ => interfaceSrc do |t|
 	cmd=makeCommand($antConfig["CREATEINTERFACE"],getDir(sys.expand_path(t.name)),importsForInterface(t.name))
 	sys cmd
 end

Modified: antargis/branches/rant/build/create_interface.rb
===================================================================
--- antargis/branches/rant/build/create_interface.rb	2007-06-26 18:21:49 UTC (rev 1117)
+++ antargis/branches/rant/build/create_interface.rb	2007-06-26 18:23:01 UTC (rev 1118)
@@ -19,6 +19,12 @@
 # License along with this program.
 #
 
+# = Short Description =
+# 
+
+
+
+
 require 'build/interface_template.rb'
 require 'build/base_tools.rb'
 
@@ -69,42 +75,23 @@
 	end
 end
 
-class MClass
-  def initialize(name,superClass)
-    @name=name
-    @superClass=superClass
-  end
-end
-
-class SimpleParser
-	@mclasses=[]
-	def initialize(files)
-	end
-	
-end
-
-def getDirs
-  files=`find ext -type d`.gsub("\r","").split("\n")
-end
-
 def getFiles(dir)
 	Dir[dir+Dir.separator+"*.h"].select{|f|not f=~/swig.h/} #-[dir+Dir.separator+"swig.h"]
 end
 
+## check if the given string is contained in the file specified by filename
 def grepBool(filename,string)
 	File.open(filename).each_line{|l|return true if l=~/#{string}/}
 	false
 end
 
+## select those files that are set be exported through swig
 def getSwigInterfaceFiles(files)
 	files.select{|f|
 		grepBool(f,"INCLUDE_SWIG")
 	}
 end
 
-def getClasses
-end
-
 class ParsedClasses
 
 	attr_reader :deriveList
@@ -150,6 +137,7 @@
 		@classList=@class2File.keys
 	end
 
+	# check which classes are derived from AGRubyObject and thus handled specifically
 	def processDerivations
 		@rubyClasses << "AGRubyObject"
 		@classList.sort!.uniq!
@@ -165,31 +153,12 @@
 				end
 			}
 		end
-# 		puts "-------------------------"
-# 		puts "CLASSLIST:"
-# 		puts @classList
-# 
-# 		puts "-------------------------"
-# 		puts "RUBY CLASSLIST:"
-# 		puts @rubyClasses
-# 
-# 		puts "-------------------------"
-# 		puts "DERIVATIONS:"
-# 			@deriveList.each {|x,y|
-# 				puts "#{x} #{y} #{@class2File[x]} "
-# 			}
-# 		puts "-------------------------"
-# 		puts "my ruby:"
-# 		puts getMyRubyClasses
-# 		puts "-------------------------"
 	end
 
-	def initLevels
-		puts "initLevels..."
-		@levels={}
-		@levels["AGRubyObject"]=0
+	## through derivations
+	def spreadLevels
 		changed=true
-		l=0
+		l=@levels.values.max
 		while changed
 			changed=false
 			@deriveList.each{|x,y|
@@ -200,17 +169,15 @@
 			}
 			l+=1
 		end
+	end
 
-		(0..l).each{|i|
-			@levels.each{|n,level|
-				if level==i
-					puts "#{i} #{n}"
-				end
-			}
-		}
-	#if false
-		puts "-------------"		
-		# give classes with no parent next level
+	def initLevels
+		puts "initLevels..."
+		@levels={}
+		@levels["AGRubyObject"]=0
+		spreadLevels
+
+		# give classes with no extisting parent next level
 		@classList.each{|c|
 			if @levels[c].nil?
 				if (not @deriveList.keys.member?(c)) 
@@ -219,43 +186,24 @@
 			end
 		}
 
-		# repeat process
-		changed=true
-		while changed
-			changed=false
-			@deriveList.each{|x,y|
-				if @levels[y]==l and @levels[x].nil?
-					@levels[x]=l+1
-					changed=true
-				end
-			}
-			l+=1
-		end
+		spreadLevels
 
-		puts "-------------"		
-		# give classes with no parent next level
-		@classList.each{|c|
-			if @levels[c].nil?
-				if (@deriveList[@deriveList[c]].nil?)
-					@levels[c]=l
+		if true
+			l=@levels.values.max+1
+			# give classes with no parent next level
+			@classList.each{|c|
+				if @levels[c].nil?
+					if (@deriveList[@deriveList[c]].nil?)
+						@levels[c]=l
+					end
 				end
-			end
-		}
-
-		# repeat process
-		changed=true
-		while changed
-			changed=false
-			@deriveList.each{|x,y|
-				if @levels[y]==l and @levels[x].nil?
-					@levels[x]=l+1
-					changed=true
-				end
 			}
-			l+=1
+	
+			spreadLevels
 		end
 
-#end
+		l=@levels.values.max
+
 		(0..l).each{|i|
 			@levels.each{|n,level|
 				if level==i
@@ -263,18 +211,20 @@
 				end
 			}
 		}
+		failed=false
 		@classList.each{|c|
 			if @levels[c].nil?
 				puts "-- #{c}"
+				failed=true
 			end
 		}
-
-		puts "initLevels...ok"
-
+		raise "Non processes classes found!" if failed
 	end
 
 	# in correct order
 	def getFileList
+
+		# build file list out of class-order (files may appear several times)
 		files=[]
 		l=@levels.values.max
 		(0..l).each{|i|
@@ -285,32 +235,21 @@
 			}
 		}
 
-		puts "getFileList:"
-		puts files,files.class
-		puts "---------"
-
+		# add files of classes with unknown level
 		@classList.each{|c|
 			if @levels[c].nil? and @class2File[c]
 				files << @class2File[c]
 			end
 		}
 
-		puts "getFileList:"
-		puts files,files.class
-		puts "---------"
-		files=files.select{|f|@myfiles.member?(f)}
+		files=files.select{|f|@myfiles.member?(f)} # select only "my" files - those included in this directory
 		addfiles=@files-files
-		files+=addfiles
+		files+=addfiles                            # add files that are in other directories
 
-
-		puts "getFileList:"
-		puts files,files.class
-		puts "---------"
+		# unique the array
 		if files.length>0
 			files.uniq!
 		end
-		puts files,files.class
-		puts "---------"
 		files
 	end
 
@@ -326,12 +265,8 @@
 
 def generateInterfaceFile(myInput,files,addfiles)
 	filename=myInput.interfaceName
-	puts "filename:",filename
 	interfaceI=File.open(filename,"w")
 	
-	
-	puts "SWIGINPUTS:",myInput.swigInput,"--------------"
-	
 	interfaceI.puts interface_template(myInput.moduleName,files,myInput.swigInput,addfiles,myInput.outputDir)
 	
 	interfaceI.close
@@ -357,12 +292,6 @@
 parsedClasses=ParsedClasses.new(files,`find $(pwd) -name "*.h"|grep -v swig`.split("\n"))
 files=parsedClasses.getFileList
 
-#exit
-
-puts "GETFILES:",files,files.class
-
-puts files.join("|")
-
 addfiles=[]
 myInput.swigInput.each{|inDir|
 	pattern=getDir(inDir)+Dir.separator+"*.h"
@@ -522,9 +451,6 @@
 
 myClasses=myClasses.sort.uniq
 
-puts "rubyClasses:",rubyClasses
-puts "myClasses:",myClasses
-
 file.puts <<EOT
 %{
 // cast-function map


Property changes on: antargis/branches/rant/ext
___________________________________________________________________
Name: svn:ignore
   + marker.i



Property changes on: antargis/branches/rant/ext/basic
___________________________________________________________________
Name: svn:ignore
   + *.oo
marker.i
interface.i



Property changes on: antargis/branches/rant/ext/external
___________________________________________________________________
Name: svn:ignore
   + *.oo
marker.i
interface.i



Property changes on: antargis/branches/rant/ext/game
___________________________________________________________________
Name: svn:ignore
   + *.oo
marker.i
interface.i



Property changes on: antargis/branches/rant/ext/gui
___________________________________________________________________
Name: svn:ignore
   + *.oo
marker.i
interface.i



Property changes on: antargis/branches/rant/ext/math
___________________________________________________________________
Name: svn:ignore
   + *.oo
marker.i
interface.i



Property changes on: antargis/branches/rant/ext/ruby
___________________________________________________________________
Name: svn:ignore
   + *.oo
marker.i
interface.i



Property changes on: antargis/branches/rant/ext/sound
___________________________________________________________________
Name: svn:ignore
   + *.oo
marker.i
interface.i



Property changes on: antargis/branches/rant/ext/video
___________________________________________________________________
Name: svn:ignore
   + *.oo
marker.i
interface.i




From davidkamphausen at mail.berlios.de  Tue Jun 26 20:25:39 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Tue, 26 Jun 2007 20:25:39 +0200
Subject: [Antargis-svn] r1119 - in antargis/branches/rant/ext: 3dengine
	basic external game gui math ruby sound video
Message-ID: <200706261825.l5QIPdgX017028@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-26 20:25:39 +0200 (Tue, 26 Jun 2007)
New Revision: 1119

Modified:
   antargis/branches/rant/ext/3dengine/
   antargis/branches/rant/ext/basic/
   antargis/branches/rant/ext/external/
   antargis/branches/rant/ext/game/
   antargis/branches/rant/ext/gui/
   antargis/branches/rant/ext/math/
   antargis/branches/rant/ext/ruby/
   antargis/branches/rant/ext/sound/
   antargis/branches/rant/ext/video/
Log:
* some more svn:ignores



Property changes on: antargis/branches/rant/ext/3dengine
___________________________________________________________________
Name: svn:ignore
   - *.oo
marker.i
interface.i

   + *.oo
marker.i
interface.i
*swig.cc
*swig.h



Property changes on: antargis/branches/rant/ext/basic
___________________________________________________________________
Name: svn:ignore
   - *.oo
marker.i
interface.i

   + *.oo
marker.i
interface.i
*swig.cc
*swig.h



Property changes on: antargis/branches/rant/ext/external
___________________________________________________________________
Name: svn:ignore
   - *.oo
marker.i
interface.i

   + *.oo
marker.i
interface.i
*swig.cc
*swig.h



Property changes on: antargis/branches/rant/ext/game
___________________________________________________________________
Name: svn:ignore
   - *.oo
marker.i
interface.i

   + *.oo
marker.i
interface.i
*swig.cc
*swig.h



Property changes on: antargis/branches/rant/ext/gui
___________________________________________________________________
Name: svn:ignore
   - *.oo
marker.i
interface.i

   + *.oo
marker.i
interface.i
*swig.cc
*swig.h



Property changes on: antargis/branches/rant/ext/math
___________________________________________________________________
Name: svn:ignore
   - *.oo
marker.i
interface.i

   + *.oo
marker.i
interface.i
*swig.cc
*swig.h



Property changes on: antargis/branches/rant/ext/ruby
___________________________________________________________________
Name: svn:ignore
   - *.oo
marker.i
interface.i

   + *.oo
marker.i
interface.i
*swig.cc
*swig.h



Property changes on: antargis/branches/rant/ext/sound
___________________________________________________________________
Name: svn:ignore
   - *.oo
marker.i
interface.i

   + *.oo
marker.i
interface.i
*swig.cc
*swig.h



Property changes on: antargis/branches/rant/ext/video
___________________________________________________________________
Name: svn:ignore
   - *.oo
marker.i
interface.i

   + *.oo
marker.i
interface.i
*swig.cc
*swig.h




From davidkamphausen at mail.berlios.de  Tue Jun 26 20:30:15 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Tue, 26 Jun 2007 20:30:15 +0200
Subject: [Antargis-svn] r1120 - antargis/branches/rant/ext
Message-ID: <200706261830.l5QIUFVd017372@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-26 20:30:15 +0200 (Tue, 26 Jun 2007)
New Revision: 1120

Modified:
   antargis/branches/rant/ext/
Log:
* more svn:ignores



Property changes on: antargis/branches/rant/ext
___________________________________________________________________
Name: svn:ignore
   - marker.i

   + *.so




From davidkamphausen at mail.berlios.de  Sat Jun 30 19:21:44 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 30 Jun 2007 19:21:44 +0200
Subject: [Antargis-svn] r1121 - in antargis/branches/rant: build ext/game
Message-ID: <200706301721.l5UHLij7029385@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-30 19:21:43 +0200 (Sat, 30 Jun 2007)
New Revision: 1121

Modified:
   antargis/branches/rant/build/create_interface.rb
   antargis/branches/rant/ext/game/headers.hh
Log:
* some small changs


Modified: antargis/branches/rant/build/create_interface.rb
===================================================================
--- antargis/branches/rant/build/create_interface.rb	2007-06-26 18:30:15 UTC (rev 1120)
+++ antargis/branches/rant/build/create_interface.rb	2007-06-30 17:21:43 UTC (rev 1121)
@@ -204,21 +204,23 @@
 
 		l=@levels.values.max
 
-		(0..l).each{|i|
-			@levels.each{|n,level|
-				if level==i
-					puts "#{i} #{n}"
-				end
-			}
-		}
-		failed=false
-		@classList.each{|c|
-			if @levels[c].nil?
-				puts "-- #{c}"
-				failed=true
-			end
-		}
-		raise "Non processes classes found!" if failed
+		# 		# output levels
+		# 		(0..l).each{|i|
+		# 			@levels.each{|n,level|
+		# 				if level==i
+		# 					puts "#{i} #{n}"
+		# 				end
+		# 			}
+		# 		}
+		# 		# check for failed classes
+		# 		failed=false
+		# 		@classList.each{|c|
+		# 			if @levels[c].nil?
+		# 				puts "-- #{c}"
+		# 				failed=true
+		# 			end
+		# 		}
+		# 		raise "Non processes classes found!" if failed
 	end
 
 	# in correct order

Modified: antargis/branches/rant/ext/game/headers.hh
===================================================================
--- antargis/branches/rant/ext/game/headers.hh	2007-06-26 18:30:15 UTC (rev 1120)
+++ antargis/branches/rant/ext/game/headers.hh	2007-06-30 17:21:43 UTC (rev 1121)
@@ -57,33 +57,33 @@
 #include "ext/video/ag_clip.h"
 #include "ext/video/ag_projection.h"
 #include "ext/video/ag_painter.h"
-#include "ext/gui/ag_colorbutton.h"
-#include "ext/gui/ag_checkbox.h"
-#include "ext/gui/ag_application.h"
-#include "ext/gui/ag_widget.h"
+#include "ext/gui/ag_image.h"
+#include "ext/gui/ag_listbox.h"
+#include "ext/gui/ag_edit.h"
+#include "ext/gui/ag_scroller.h"
+#include "ext/gui/ag_local.h"
 #include "ext/gui/ag_tooltip.h"
 #include "ext/gui/ag_radio.h"
-#include "ext/gui/ag_layout.h"
-#include "ext/gui/ag_menu.h"
-#include "ext/gui/ag_table.h"
-#include "ext/gui/ag_theme.h"
-#include "ext/gui/ag_edit.h"
+#include "ext/gui/ag_application.h"
+#include "ext/gui/ag_colorbutton.h"
+#include "ext/gui/ag_button.h"
+#include "ext/gui/ag_radiogroup.h"
 #include "ext/gui/ag_background.h"
-#include "ext/gui/ag_listbox.h"
+#include "ext/gui/ag_menuitem.h"
 #include "ext/gui/ag_screenwidget.h"
+#include "ext/gui/ag_widget.h"
+#include "ext/gui/ag_text.h"
+#include "ext/gui/ag_checkbox.h"
+#include "ext/gui/ag_table.h"
+#include "ext/gui/ag_frame.h"
+#include "ext/gui/ag_caption.h"
 #include "ext/gui/ag_combo.h"
-#include "ext/gui/ag_image.h"
-#include "ext/gui/ag_frame.h"
-#include "ext/gui/ag_button.h"
+#include "ext/gui/ag_theme.h"
+#include "ext/gui/ag_menu.h"
+#include "ext/gui/ag_layoutfactory.h"
+#include "ext/gui/ag_window.h"
+#include "ext/gui/ag_layout.h"
 #include "ext/gui/ag_border.h"
-#include "ext/gui/ag_window.h"
-#include "ext/gui/ag_layoutfactory.h"
-#include "ext/gui/ag_local.h"
-#include "ext/gui/ag_text.h"
-#include "ext/gui/ag_menuitem.h"
-#include "ext/gui/ag_scroller.h"
-#include "ext/gui/ag_caption.h"
-#include "ext/gui/ag_radiogroup.h"
 #include "ext/3dengine/scene_base.h"
 #include "ext/3dengine/scene.h"
 #include "ext/3dengine/scenenode.h"



From davidkamphausen at mail.berlios.de  Sat Jun 30 20:51:39 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 30 Jun 2007 20:51:39 +0200
Subject: [Antargis-svn] r1122 - in antargis/branches/rant: . build
Message-ID: <200706301851.l5UIpdZr021710@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-30 20:51:38 +0200 (Sat, 30 Jun 2007)
New Revision: 1122

Added:
   antargis/branches/rant/TODO
Modified:
   antargis/branches/rant/build/create_interface.rb
Log:
* cleanup of  build/create_interface.rb
A    TODO


Added: antargis/branches/rant/TODO
===================================================================
--- antargis/branches/rant/TODO	2007-06-30 17:21:43 UTC (rev 1121)
+++ antargis/branches/rant/TODO	2007-06-30 18:51:38 UTC (rev 1122)
@@ -0,0 +1,6 @@
+* docs
+* configure
+* "contrib"
+ * autopackage
+ * debian
+ * antargis.iss
\ No newline at end of file

Modified: antargis/branches/rant/build/create_interface.rb
===================================================================
--- antargis/branches/rant/build/create_interface.rb	2007-06-30 17:21:43 UTC (rev 1121)
+++ antargis/branches/rant/build/create_interface.rb	2007-06-30 18:51:38 UTC (rev 1122)
@@ -109,6 +109,7 @@
 	def loadAllDerivations(allfiles)
 		@class2File={}
 		@deriveList={} # x=>y :x is child of y
+		@allClasses=[]
 
 		allfiles.each{|fn|
 			g=File.open(fn)
@@ -120,9 +121,11 @@
 				
 				if a =~ /^class.*/ then
 					cn=a.gsub("class ","").gsub(/:.*/,"").gsub("\n","").gsub(" ","")
+					@allClasses << cn.gsub(";","")
 					if cn=~/^[A-Z].*/
 						if a=~ /.*public.*/ then
 							pn=a.gsub(/.*public /,"").gsub("\n","")
+							@allClasses << pn
 							@deriveList[cn]=pn
 							@class2File[cn]=fn
 						elsif not a=~/;/ then
@@ -135,6 +138,7 @@
 			}
 		}
 		@classList=@class2File.keys
+		@allClasses=@allClasses.sort.uniq
 	end
 
 	# check which classes are derived from AGRubyObject and thus handled specifically
@@ -262,6 +266,9 @@
 	def getAllRubyClasses
 		@rubyClasses
 	end
+	def getAllClasses
+		@allClasses
+	end
 end
 
 
@@ -303,61 +310,6 @@
 
 generateInterfaceFile(myInput,files,addfiles)
 
-# old implementation
-
-
-classList=[]
-deriveList={} # x=>y :x is child of y
-rubyClasses={} # all, which are derived from AGRubyObject
-class2File={}
-
-
-# take RubyObject as base for RubyObjects :-)
-# so simply search for classes deriveListd from this!
-
-files.each{|fn|
-	g=File.open(fn)
-	cn=""
-	g.each{|a|
-		abak=a
-		a.gsub!("AGEXPORT","")
-		a.gsub!("EXPORT","")
-		
-		if a =~ /^class.*/ then
-			cn=a.gsub("class ","").gsub(/[:;].*/,"").gsub(/\n/,"").gsub(" ","")
-			if cn=~/^[A-Z].*/
-				classList+=[cn]
-				if a=~ /.*public.*/ then
-					pn=a.gsub(/.*public /,"").gsub(/\n/,"")
-					deriveList[cn]=pn
-					rubyClasses[cn]=false
-					rubyClasses[pn]=false
-					class2File[cn]=fn
-				elsif not a=~/;/ then
-					deriveList[cn]=nil
-				end
-			end
-		end
-	
-	}
-}
-
-rubyClasses["AGRubyObject"]=true
-
-classList.sort!.uniq!
-
-# check for children of AGWidget
-changed=true
-while changed do
-	changed=false
-	deriveList.each {|x,y|
-		if rubyClasses[y] and rubyClasses[x]==false then
-			rubyClasses[x]=true
-			changed=true
-		end
-	}
-end
-
 file=File.open(myInput.markerName,"w")
 
 # ok, first marking is included
@@ -376,36 +328,6 @@
 	#end
 }
 
-# calculate class-derivations
-derivations={}
-rubyClasses.each{|x,y|
-	derivations[x]=[]
-}
-deriveList.each{|x,y|
-	if not derivations[y]
-		derivations[y]=[]
-	end
-	derivations[y].push(x)
-}
-changed=true
-while changed
-	changed=false
-	derivations.each{|x,y|
-		y.each{|a|
-			if derivations[a]
-				old=derivations[x]
-				derivations[x]+=derivations[a]
-				derivations[x].sort!
-				derivations[x].uniq!
-				#puts x+":"+old.length.to_s+" "+derivations[x].length.to_s
-				if old.length<derivations[x].length
-					changed=true
-				end
-			end
-		}
-	}
-end
-
 # swig typemaps
 # so that always the lowest children in a derivation hierarchy is returned
 myRubyClasses=parsedClasses.getMyRubyClasses
@@ -427,6 +349,8 @@
 
 	end
 }
+
+classList=parsedClasses.getAllClasses
 # normal typemaps
 classList.each{|c|
 	file.puts "%typemap(directorout) #{c} {"
@@ -443,16 +367,8 @@
 rubyClasses=parsedClasses.getMyRubyClasses
 allRubyClasses=parsedClasses.getAllRubyClasses
 
-myClasses=[]
+myClasses=parsedClasses.getMyRubyClasses
 
-deriveList.each{|b,a|
-	if rubyClasses.member?(b) || b=="AGRubyObject"
-		myClasses << b
-	end
-}
-
-myClasses=myClasses.sort.uniq
-
 file.puts <<EOT
 %{
 // cast-function map
@@ -488,7 +404,7 @@
 EOT
 }
 
-deriveList.each{|b,a|
+parsedClasses.deriveList.each{|b,a|
 	if rubyClasses.member?(b) and allRubyClasses.member?(a)
 		# for each pair generate a casting function and register it into agCastFunctions
 file.puts <<EOT



From davidkamphausen at mail.berlios.de  Sat Jun 30 22:40:27 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 30 Jun 2007 22:40:27 +0200
Subject: [Antargis-svn] r1123 - in antargis/branches/rant: . build
	build/configs
Message-ID: <200706302040.l5UKeRSZ028808@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-30 22:40:27 +0200 (Sat, 30 Jun 2007)
New Revision: 1123

Added:
   antargis/branches/rant/build/configs/
   antargis/branches/rant/build/configs/unix.rb
   antargis/branches/rant/build/configure.rb
   antargis/branches/rant/configure
Modified:
   antargis/branches/rant/Rantfile
   antargis/branches/rant/build/base_tools.rb
Log:
* addded new files


Modified: antargis/branches/rant/Rantfile
===================================================================
--- antargis/branches/rant/Rantfile	2007-06-30 18:51:38 UTC (rev 1122)
+++ antargis/branches/rant/Rantfile	2007-06-30 20:40:27 UTC (rev 1123)
@@ -45,9 +45,9 @@
 
 # configure cflags out of config.rb
 cflags=""
-cflags+=" -DGCDEBUG" if $antConfig["gcdebug"]   # enable debuggin of garbage-collection
-cflags+=" -g -O0"    if $antConfig["debug"]     # disable optimizations for better debugging
-cflags+=" -O2"       unless $antConfig["debug"] # enable optimizations
+cflags+=" -DGCDEBUG" if $config["gcdebug"]   # enable debuggin of garbage-collection
+cflags+=" -g -O0"    if $config["debug"]     # disable optimizations for better debugging
+cflags+=" -O2"       unless $config["debug"] # enable optimizations
 	
 
 var :CFLAGS => var[:INCLUDESTR]+cflags          # store cflags in "var" for later read-out while compiling
@@ -94,7 +94,7 @@
 	}
 	task target => tsources do |t|
 		# build command
-		cmd=makeCommand($antConfig["LINKSHARED"],sys.expand_path(t.name), (t.prerequisites.collect{|f|sys.expand_path(f)}+extlibs).join(" "))
+		cmd=makeCommand("LINK_SHARED",sys.expand_path(t.name), (t.prerequisites.collect{|f|sys.expand_path(f)}+extlibs).join(" "))
 		sys cmd
 	end
 }
@@ -118,7 +118,7 @@
 		end
 	}
 	task target => tsources do |t|
-		cmd=makeCommand($antConfig["LINKSHARED"],sys.expand_path(t.name), t.prerequisites.collect{|f|sys.expand_path(f)}.join(" "))
+		cmd=makeCommand("LINK_SHARED",sys.expand_path(t.name), t.prerequisites.collect{|f|sys.expand_path(f)}.join(" "))
 		sys cmd
 	end
 }
@@ -129,7 +129,7 @@
 # build c
 #
 gen Rule, '.o' => '.c' do |t|
-	cmd=makeCommand($antConfig["CC"],sys.expand_path(t.name),"#{var :CFLAGS} #{sys.expand_path(t.source)}")
+	cmd=makeCommand("CC_CALL",sys.expand_path(t.name),"#{var :CFLAGS} #{sys.expand_path(t.source)}")
 	sys cmd
 end
 ###########################################
@@ -138,7 +138,7 @@
 # build c++
 #
 gen Rule, '.oo' => '.cc' do |t|
-	cmd=makeCommand($antConfig["CXX"],sys.expand_path(t.name),"#{var :CFLAGS} #{sys.expand_path(t.source)}")
+	cmd=makeCommand("CXX_CALL",sys.expand_path(t.name),"#{var :CFLAGS} #{sys.expand_path(t.source)}")
 	sys cmd
 end
 #
@@ -155,7 +155,7 @@
 }
 
 gen Rule, /^.*swig.(cc|h)$/ => swigSrc do |t|
-	cmd=makeCommand($antConfig["SWIG"],sys.expand_path(t.name),"-DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR} #{sys.expand_path(t.source)}")
+	cmd=makeCommand("SWIG_CALL",sys.expand_path(t.name),"-DAGEXPORT -Ibuild -I#{sys.expand_path(getDir(t.name))} #{var :INCLUDESTR} #{sys.expand_path(t.source)}")
 	sys cmd
 end
 #
@@ -182,7 +182,7 @@
 	list
 }
 gen Rule, /^.*interface.i$/ => interfaceSrc do |t|
-	cmd=makeCommand($antConfig["CREATEINTERFACE"],getDir(sys.expand_path(t.name)),importsForInterface(t.name))
+	cmd=makeCommand("CREATEINTERFACE",getDir(sys.expand_path(t.name)),importsForInterface(t.name))
 	sys cmd
 end
 #

Modified: antargis/branches/rant/build/base_tools.rb
===================================================================
--- antargis/branches/rant/build/base_tools.rb	2007-06-30 18:51:38 UTC (rev 1122)
+++ antargis/branches/rant/build/base_tools.rb	2007-06-30 20:40:27 UTC (rev 1123)
@@ -16,14 +16,32 @@
 	"antargis"+dir.split(Dir.separator)[-1]
 end
 
-# the getConfig function reads out compiler-information out of the mkmf-configuration variables - these are defined in a recursive manner
-def getConfig(s)
-  r=CONFIG[s]
+# build a command out of templates in config.rb
+def makeCommand(cmd,output,input)
+	#cmd.sub("?OUTPUT?",output).sub("?INPUT?",input)
+	extendCommand($config,cmd,{"OUTPUT"=>output,"INPUT"=>input})
+end
+
+
+def extendCommandLine(config,s)
+  r=config[s]
   return r if r.nil?
-  r.gsub(/\$\(([^\)]*)\)/) {|a|getConfig(a[2..-2])} # replace recursive values within this form: $(...)
+  r.gsub(/\$\(([^\)]*)\)/) {|a|
+		n=a[2..-2] # filter "$(xy..z)" to "xy..z"
+		raise "Endless recursion in #{n}!" if n==s
+		extendCommandLine(config,n)  # replace recursive values within this form: $(...)
+	}
 end
 
-# build a command out of templates in config.rb
-def makeCommand(cmd,output,input)
-	cmd.sub("?OUTPUT?",output).sub("?INPUT?",input)
+def extendCommand(config,name,map={})
+	c=config.clone
+	map.each{|k,v|
+		c[k]=v
+	}
+	extendCommandLine(c,name)
+end
+
+# the getConfig function reads out compiler-information out of the mkmf-configuration variables - these are defined in a recursive manner
+def getConfig(s)
+	extendCommand(CONFIG,s)
 end
\ No newline at end of file

Added: antargis/branches/rant/build/configs/unix.rb
===================================================================
--- antargis/branches/rant/build/configs/unix.rb	2007-06-30 18:51:38 UTC (rev 1122)
+++ antargis/branches/rant/build/configs/unix.rb	2007-06-30 20:40:27 UTC (rev 1123)
@@ -0,0 +1,17 @@
+$config={
+	"CXX"=>"$(g++)",
+	"CC"=>"$(gcc)",
+	"SWIG"=>"$(swig)",
+	"RUBY"=>"$(ruby)",
+	"CCACHE"=>"$(ccache)",
+
+	"LINK"=>"$(CXX)",
+
+	"COMPILE_PARAMS"=>" -c -o $(OUTPUT) $(INPUT)",
+	"CC_CALL"=>"$(CCACHE) $(CC) $(COMPILE_PARAMS)",
+	"CXX_CALL"=>"$(CCACHE) $(CXX) $(COMPILE_PARAMS)",
+	"LINK_SHARED"=>"$(LINK) -shared -o $(OUTPUT) $(INPUT)",
+	"SWIG_CALL"=>"$(SWIG) -v -Wall -ruby -c++ -o $(OUTPUT) $(INPUT)",
+	"SWIGDEPS"=>"$(SWIG) -ruby -c++ -M $(INPUT)",
+	"CREATEINTERFACE"=>"$(RUBY) build/create_interface.rb -d=$(OUTPUT) -i=$(INPUT)"
+}

Added: antargis/branches/rant/build/configure.rb
===================================================================
--- antargis/branches/rant/build/configure.rb	2007-06-30 18:51:38 UTC (rev 1122)
+++ antargis/branches/rant/build/configure.rb	2007-06-30 20:40:27 UTC (rev 1123)
@@ -0,0 +1,177 @@
+module CFG
+	@@options=[]
+	@@config={}
+	@@checks=[]
+
+	def CFG.addOption(name,short,help,param=nil,&proc)
+		@@options.push({:name=>name,:short=>short,:help=>help,:proc=>proc,:param=>param})
+	end
+	def CFG.options
+		@@options
+	end
+	def CFG.addCheck(name,&proc)
+		@@checks << {:name=>name,:proc=>proc}
+	end
+
+	def CFG.call(name)
+		@@options.each{|op|
+			if op[:name]==name || op[:short]==name
+				op[:proc].call
+			end
+		}
+	end
+	def CFG.parseArgs
+		ARGV.each{|arg|
+			found=false
+			# parse single arguments like "-d" or "-dgh" (like tar -xfz)
+			if arg=~/^-[a-z]+$/
+				found=true
+				# check if all characters represent a correct option
+				arg[1..-1].scan(/./){|byte|
+					found=false if @@options.select{|op|op[:short]==byte}.length==0
+				}
+				if found
+					# all were ok, so call each these options
+					arg[1..-1].scan(/./){|byte|
+						@@options.each{|op|op[:proc].call if op[:short]==byte}
+					}
+				end
+			end
+			if not found
+				# option could not yet be processed, so do a second try
+				@@options.each{|op|
+					name=op[:name]
+					ename=name.gsub("+","\\\\+")
+					#puts "ENAME:#{ename}"
+					# parse "simple" options without parameters
+					if arg=~/^--#{ename}$/ or arg=~/^-#{op[:short]}$/
+						found=true
+						op[:proc].call
+					# parse options with parameter, given like this : "-d=<somedir>" or "--dir=bladir"
+					elsif arg=~/^--#{ename}=.+/ or arg=~/^-#{op[:short]}=.+$/
+						found=true
+						op[:proc].call(arg.gsub(/^[^=]+=/,""))
+					end
+				}
+			end
+			puts "ERROR: argument '#{arg}' could not be processed!" if not found
+		}
+	end
+
+	def CFG.run
+		parseArgs
+		ok=runChecks
+		saveConfig if ok
+	end
+
+	def CFG.runChecks
+		puts 
+		failed=[]
+		@@checks.each{|c|
+			text="checking "+c[:name]+" ..."
+			print text
+			ok=c[:proc].call
+			#ok=(not ok.nil?)
+			print " "*(40-text.length)
+			puts ({true=>"ok",false=>"failed"}[ok])
+			failed << c[:name] unless ok
+		}
+		if failed.length>0
+			puts 
+			puts "ERROR:"
+			puts "The following tests failed:"
+			failed.each{|f|puts f}
+		end
+
+		failed.length==0
+	end
+
+	def CFG.saveConfig
+		configName="config.rb"
+		f=File.open(configName,"w")
+		f.puts <<EOT
+$config={
+#{@@config.collect{|k,v|"  '"+k+"'=>"+toS(v)}.join(",\n")}
+}
+EOT
+		f.close
+		puts File.open(configName).read
+	
+	end
+
+	def CFG.toS(v)
+		case v
+			when String
+				"'"+v.to_s+"'"
+			else
+				v.to_s
+		end
+	end
+
+	def CFG.set(n,v)
+		@@config[n]=v
+	end
+	def CFG.get(n)
+		@@config[n]
+	end
+
+	def CFG.checkProgram(program)
+		addOption("path-"+program,"",
+			"set path to program '#{program}' like this:\n --path-#{program}=/usr/local/bin/#{program}","path") do |d|
+				set(program,d)
+			end
+
+		addCheck ("program "+program) do ||
+			path=get(program)
+			path||=findProgram(program)
+			r=testProgram(path)
+			set (program,path) if r
+			r
+		end
+	end
+
+	def CFG.findProgram(program)
+		`whereis #{program}`.gsub(/[^:]*: */,"").split(" ")[0]
+	end
+
+	def CFG.testProgram(path)
+		#puts path,File.exists?(path),"--"
+			File.exists?(path)
+	end
+
+	def CFG.includeConfig
+		avail=["unix"]
+		addOption("base-config","",
+			"set base-config like "+avail.join(", "),"config") do |v|
+			set("base-config",v)
+		end
+		addCheck ("base-config") do ||
+			c=get("base-config")
+			c=nil unless avail.member?(c)
+			c||="unix"
+			require "build/configs/"+c+".rb"
+			$config.each{|k,v|@@config[k]||=v}
+			true
+		end
+	end
+
+
+	addOption("help","h",
+		"display help text") do
+			CFG.options.each{|op|
+				text=""
+				text << "--#{op[:name]}"
+				text << "=<#{op[:param]}>" if op[:param]
+				text << ", -#{op[:short]}" if op[:short]!=""
+				text << "=<#{op[:param]}>" if op[:short]!="" and op[:param]
+				text+=" "*(40-text.length)
+				l=text.length
+				helpa=op[:help].split("\n")
+				text+=helpa[0]
+				helpa[1..-1].each{|h|
+					text << "\n"+" "*l+h
+				}
+				puts text
+			}
+	end
+end

Added: antargis/branches/rant/configure
===================================================================
--- antargis/branches/rant/configure	2007-06-30 18:51:38 UTC (rev 1122)
+++ antargis/branches/rant/configure	2007-06-30 20:40:27 UTC (rev 1123)
@@ -0,0 +1,51 @@
+#!/usr/bin/env ruby
+
+require 'build/configure.rb'
+
+puts <<EOT
+Battle of Antargis - Configuration
+-------------------------------------------------------------------------------
+EOT
+
+CFG.addOption("enable-debug","d",
+	"enable debugging") do  ||
+		CFG.set("debug",true)
+	end
+
+CFG.addOption("enable-gc-debug","g",
+	"enable debugging of garbage collector") do  ||
+		CFG.set("gcdebug",true)
+	end
+
+CFG.addOption("prefix","",
+	"set prefix directory","dir") do |d|
+		CFG.set("prefix",d)
+	end
+
+CFG.addOption("profile","p",
+	"enable profiling of C++-code") do ||
+		CFG.set("profile",true)
+	end
+
+CFG.addOption("drmuser","",
+	"set user for DRM","user") do |v|
+		CFG.set("drmuser",v)
+	end
+
+CFG.addOption("drmpw","",
+	"set password for DRM","password") do |v|
+		CFG.set("drmpass",v)
+	end
+
+CFG.checkProgram("ccache")
+CFG.checkProgram("gcc")
+CFG.checkProgram("g++")
+CFG.checkProgram("swig")
+CFG.checkProgram("ruby")
+
+CFG.includeConfig
+
+
+CFG.run
+
+puts 


Property changes on: antargis/branches/rant/configure
___________________________________________________________________
Name: svn:executable
   + *



From davidkamphausen at mail.berlios.de  Sat Jun 30 22:54:07 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 30 Jun 2007 22:54:07 +0200
Subject: [Antargis-svn] r1124 - in antargis/branches/rant/build: . configs
Message-ID: <200706302054.l5UKs7cR029590@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-30 22:54:07 +0200 (Sat, 30 Jun 2007)
New Revision: 1124

Modified:
   antargis/branches/rant/build/configs/unix.rb
   antargis/branches/rant/build/configure.rb
Log:
* some more documentation


Modified: antargis/branches/rant/build/configs/unix.rb
===================================================================
--- antargis/branches/rant/build/configs/unix.rb	2007-06-30 20:40:27 UTC (rev 1123)
+++ antargis/branches/rant/build/configs/unix.rb	2007-06-30 20:54:07 UTC (rev 1124)
@@ -1,3 +1,10 @@
+#
+# this is the reference implementation of a base-configuration file.
+# it's meant to configure all needed build-processes on a unix-os for BoA.
+# for other operation systems or compiler-systems please copy this file and
+# change the calls.
+# 
+
 $config={
 	"CXX"=>"$(g++)",
 	"CC"=>"$(gcc)",
@@ -7,11 +14,20 @@
 
 	"LINK"=>"$(CXX)",
 
+  # call the compiler using the standard unix-style mechanism <CC> -c -o <outputname> <input0> [<input1> ...]
 	"COMPILE_PARAMS"=>" -c -o $(OUTPUT) $(INPUT)",
+	# an ansi-c compiler call with parameters (using ccache if available)
 	"CC_CALL"=>"$(CCACHE) $(CC) $(COMPILE_PARAMS)",
+	# a c++ compiler call with parameters (using ccache if available)
 	"CXX_CALL"=>"$(CCACHE) $(CXX) $(COMPILE_PARAMS)",
+	# build a shared library (.so or .dll)
 	"LINK_SHARED"=>"$(LINK) -shared -o $(OUTPUT) $(INPUT)",
+	# generate c++-code from a swig-interface file
 	"SWIG_CALL"=>"$(SWIG) -v -Wall -ruby -c++ -o $(OUTPUT) $(INPUT)",
+	# generate dependencies for swig-interface files
 	"SWIGDEPS"=>"$(SWIG) -ruby -c++ -M $(INPUT)",
+
+	# generate a swig-interface-file from the c++-sources and some other pre-defined interface-files (.i)
+	# go to build/*.i or ext/*/*.i for more information
 	"CREATEINTERFACE"=>"$(RUBY) build/create_interface.rb -d=$(OUTPUT) -i=$(INPUT)"
 }

Modified: antargis/branches/rant/build/configure.rb
===================================================================
--- antargis/branches/rant/build/configure.rb	2007-06-30 20:40:27 UTC (rev 1123)
+++ antargis/branches/rant/build/configure.rb	2007-06-30 20:54:07 UTC (rev 1124)
@@ -1,3 +1,17 @@
+#
+# This is a library for simple build-configuration management.
+# For a brief example have a look at BoA's configure-script.
+# 
+# The configuration-process goes like this
+# 1) include this file
+# 2) define cmd-line-options with CFG.addOption
+# 3) add checks for programs, files, libraries (checkProgram, checkFile, checkLibrary)
+# 4) add custom-checks with addCheck(...)
+# 5) include basic-configuration functionality with CFG.includeConfig - have a look at build/configs/unix.rb for more information on this
+# 6) run the configuration with CFG.run - a config.rb file will be written 
+##
+
+
 module CFG
 	@@options=[]
 	@@config={}



From davidkamphausen at mail.berlios.de  Sat Jun 30 22:56:12 2007
From: davidkamphausen at mail.berlios.de (davidkamphausen at BerliOS)
Date: Sat, 30 Jun 2007 22:56:12 +0200
Subject: [Antargis-svn] r1125 - antargis/branches/rant
Message-ID: <200706302056.l5UKuCWu029732@sheep.berlios.de>

Author: davidkamphausen
Date: 2007-06-30 22:56:12 +0200 (Sat, 30 Jun 2007)
New Revision: 1125

Modified:
   antargis/branches/rant/INSTALL
Log:
* updated install instructions


Modified: antargis/branches/rant/INSTALL
===================================================================
--- antargis/branches/rant/INSTALL	2007-06-30 20:54:07 UTC (rev 1124)
+++ antargis/branches/rant/INSTALL	2007-06-30 20:56:12 UTC (rev 1125)
@@ -1,21 +1,21 @@
 INSTALLATION of Battles of Antargis
 ==========================================
 Quick Start:
-1) Install ruby, rake, libsdl, libsdl-image, libsdl-ttf, libsdl-mixer, opengl.
+1) Install ruby, rant, libsdl, libsdl-image, libsdl-ttf, libsdl-mixer, opengl.
 	You need the developer-packages of all these libraries/programs!
 2) Don't forget to install ruby1.8-dev (or ruby1.9-dev if you use ruby 1.9)
 3) After this step no root-privileges are needed.
-4) Run "rake" in this directory
+4) Run "rant" in this directory
 5) Run "./antargis" in this directory
 
-Essentials: Ruby, Rake
-This game is mostly written in Ruby (www.ruby-lang.org) and C++. It uses Rake (Ruby Make) as build system.
+Essentials: Ruby, Rant
+This game is mostly written in Ruby (www.ruby-lang.org) and C++. It uses Rant (Rant - Flexible, Ruby based make) as build system.
 
 Libraries: libSDL,libSDL_mixer libSDL_ttf, libSDL_image, opengl
 
 Links:
 Ruby          http://www.ruby-lang.org
-Rake          http://rake.rubyforge.org/
+Rant          http://rant.rubyforge.org/
 libSDL        http://www.libsdl.org
 libSDL-image  http://www.libsdl.org/projects/SDL_image
 libSDL-ttf    http://www.libsdl.org/projects/SDL_ttf



